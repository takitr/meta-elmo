diff --git a/Makefile b/Makefile
index e4499d7..28f86f9 100644
--- a/Makefile
+++ b/Makefile
@@ -3109,6 +3109,19 @@ omap3_pandora_config :	unconfig
 omap3_zoom1_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 zoom1 omap3 omap3
 
+vpe_apollo_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 vpe_apollo nxp pnx84xx
+
+vpe_apollo_eth_emu_config :	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_LIPP_6300ETH" >>$(obj)include/config.h
+	@echo "#define CONFIG_USING_EMU_PHY" >>$(obj)include/config.h
+	@echo "#define __USING_EMU_PHY__" >>$(obj)include/config.h
+	@echo "#define TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL 0x0U" >>$(obj)include/config.h
+	@echo "#define TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL 0x0U" >>$(obj)include/config.h
+	@$(MKCONFIG) $(@:_eth_emu_config=) arm arm_cortexa8 vpe_apollo nxp pnx84xx
+
 omap3_zoom2_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 zoom2 omap3 omap3
 
diff --git a/board/nxp/common/Makefile b/board/nxp/common/Makefile
new file mode 100644
index 0000000..306a8a4
--- /dev/null
+++ b/board/nxp/common/Makefile
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+ifneq ($(OBJTREE),$(SRCTREE))
+$(shell mkdir -p $(obj)board/$(VENDOR)/common)
+endif
+
+LIB	= $(obj)lib$(VENDOR).a
+
+COBJS-$(CONFIG_PNX84XX) += power.o
+COBJS-$(CONFIG_PNX8492) += power.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/nxp/common/power.c b/board/nxp/common/power.c
new file mode 100644
index 0000000..82eab44
--- /dev/null
+++ b/board/nxp/common/power.c
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright 2008-2009  NXP Semiconductors
+ *
+ * Author :
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+
+/******************************************************************************
+ * Routine: power_init_r
+ * Description: Configure power supply
+ *****************************************************************************/
+void power_init_r(void)
+{
+	unsigned char byte;
+
+#ifdef CONFIG_DRIVER_PNX*4XX_I2C
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+
+}
diff --git a/board/nxp/vpe_apollo/Makefile b/board/nxp/vpe_apollo/Makefile
new file mode 100644
index 0000000..94e3c9e
--- /dev/null
+++ b/board/nxp/vpe_apollo/Makefile
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= vpe_apollo.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/nxp/vpe_apollo/config.mk b/board/nxp/vpe_apollo/config.mk
new file mode 100644
index 0000000..282b517
--- /dev/null
+++ b/board/nxp/vpe_apollo/config.mk
@@ -0,0 +1,31 @@
+#
+# (C) Copyright 2009 NXP Semiconductors
+#
+# The appollo vpe modell uses an ARM-CortexA9
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 0000'0000 (bank0)
+# A000/0000 (bank1)
+# Linux-Kernel is expected to be at 0000'8000, entry 0000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x0a000000
diff --git a/board/nxp/vpe_apollo/u-boot.lds b/board/nxp/vpe_apollo/u-boot.lds
new file mode 100644
index 0000000..a3bc660
--- /dev/null
+++ b/board/nxp/vpe_apollo/u-boot.lds
@@ -0,0 +1,63 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x0A000000;
+
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm_cortexa8/start.o	(.text)
+		*(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/nxp/vpe_apollo/vpe_apollo.c b/board/nxp/vpe_apollo/vpe_apollo.c
new file mode 100644
index 0000000..3ecfe26
--- /dev/null
+++ b/board/nxp/vpe_apollo/vpe_apollo.c
@@ -0,0 +1,97 @@
+/*
+ * (C) Copyright 2009
+ * NXP Semiconductors, <www.nxp.com>
+ *
+ * Author :
+ *	TH <okc@nxp.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-types.h>
+#include "vpe_apollo.h"
+
+/******************************************************************************
+ * Routine: board_init
+ * Description: Early hardware init.
+ *****************************************************************************/
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gcs_init(); /* in SRAM or SDRAM, finish GCS */
+	/* board id for Linux */
+	gd->bd->bi_arch_number = MACH_TYPE_APOLLO;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (PNX84XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+/******************************************************************************
+ * Routine: board_eth_init
+ * Description: ethernet init.
+ *****************************************************************************/
+#undef CONFIG_LIPP_6300ETH
+
+extern void lipp_6300eth_initialize(void);
+
+int board_eth_init(bd_t *bis)
+{
+	int c=1;
+#ifdef CONFIG_LIPP_6300ETH
+	lipp_6300eth_initialize();
+#endif
+	return c;
+
+}
+
+/******************************************************************************
+ * Routine: misc_init_r
+ * Description: Configure board specific parts
+ *****************************************************************************/
+int misc_init_r(void)
+{
+	power_init_r();
+
+	dieid_num_r();
+
+	return 0;
+}
+
+/******************************************************************************
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ *****************************************************************************/
+void set_muxconf_regs(void)
+
+{
+	unsigned long temp_val;
+	global_reg_t *global_reg_base = (global_reg_t *)PNX84XX_GREG_BASE;
+
+	 writel( 0x02, global_reg_base->res_peripheral_config[GPIO_PIN_MUX_REG_0]);
+	 temp_val = readl(global_reg_base->res_peripheral_config[GPIO_SEC_PIN_MUX_REG_0]);
+	 temp_val = temp_val &~ 0x00100002;
+	 writel( 0x3000, global_reg_base->res_peripheral_config[GPIO_SEC_PIN_MUX_REG_0]);
+
+}
diff --git a/board/nxp/vpe_apollo/vpe_apollo.h b/board/nxp/vpe_apollo/vpe_apollo.h
new file mode 100644
index 0000000..d3f975d
--- /dev/null
+++ b/board/nxp/vpe_apollo/vpe_apollo.h
@@ -0,0 +1,122 @@
+/*
+ * (C) Copyright 2008
+ * Dirk Behme <dirk.behme@gmail.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _BEAGLE_H_
+#define _BEAGLE_H_
+
+const pnx84xx_sysinfo sysinfo = {
+	SDP_3430_V1,
+	SDP_3430_V2,
+	DDR_STACKED,
+	"APOLLO vpe model",
+#if defined(CONFIG_ENV_IS_IN_ONENAND)
+	"OneNAND",
+#else
+	"NAND",
+#endif
+};
+
+#define BOARD_REVISION_MASK	(0x1 << 11)
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_VPE_APOLLO() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*Serial Interface*/\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /*UART3_CTS_RCTX*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) /*UART3_RTS_SD */\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /*UART3_RX_IRRX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M4)) /*GPIO_168*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M4)) /*GPIO_183*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
+ MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /*GPIO_170*/\
+ MUX_VAL(CP(MCSPI1_CLK),	(IEN  | PTU | EN  | M4)) /*GPIO_171*/\
+ MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTU | EN  | M4)) /*GPIO_172*/\
+ MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI1_SOMI*/\
+ MUX_VAL(CP(MCSPI1_CS0),	(IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
+ MUX_VAL(CP(MCSPI1_CS1),	(IDIS | PTD | EN  | M0)) /*McSPI1_CS1*/\
+ MUX_VAL(CP(MCSPI1_CS2),	(IDIS | PTD | DIS | M4)) /*GPIO_176*/\
+
+#endif
diff --git a/common/Makefile b/common/Makefile
index 3781738..fbbb31c 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -141,8 +141,10 @@ COBJS-$(CONFIG_CMD_UBIFS) += cmd_ubifs.o
 COBJS-$(CONFIG_CMD_UNIVERSE) += cmd_universe.o
 ifdef CONFIG_CMD_USB
 COBJS-y += cmd_usb.o
+COBJS-y += cmd_sari.o
 COBJS-y += usb.o
 COBJS-$(CONFIG_USB_STORAGE) += usb_storage.o
+COBJS-$(CONFIG_USB_NETWORK) += usb_network.o
 endif
 COBJS-$(CONFIG_CMD_XIMG) += cmd_ximg.o
 COBJS-$(CONFIG_YAFFS2) += cmd_yaffs2.o
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 158a55f..f612286 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -41,6 +41,7 @@ static int nand_dump(nand_info_t *nand, ulong off, int only_oob)
 {
 	int i;
 	u_char *datbuf, *oobbuf, *p;
+	struct mtd_oob_ops ops;
 
 	datbuf = malloc(nand->writesize + nand->oobsize);
 	oobbuf = malloc(nand->oobsize);
@@ -50,7 +51,6 @@ static int nand_dump(nand_info_t *nand, ulong off, int only_oob)
 	}
 	off &= ~(nand->writesize - 1);
 	loff_t addr = (loff_t) off;
-	struct mtd_oob_ops ops;
 	memset(&ops, 0, sizeof(ops));
 	ops.datbuf = datbuf;
 	ops.oobbuf = oobbuf; /* must exist, but oob data will be appended to ops.datbuf */
diff --git a/common/dlmalloc.c b/common/dlmalloc.c
index 4a18562..bdb50aa 100644
--- a/common/dlmalloc.c
+++ b/common/dlmalloc.c
@@ -1,5 +1,7 @@
 #include <common.h>
 
+
+
 #if 0	/* Moved to malloc.h */
 /* ---------- To make a malloc.h, start cutting here ------------ */
 
@@ -220,7 +222,7 @@
 
 */
 
-
+
 
 
 /* Preliminaries */
@@ -1142,7 +1144,7 @@ gAllocatedSize))
 
 #endif
 
-
+
 
 /*
   Type declarations
@@ -1282,7 +1284,7 @@ nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        serviced via calls to mmap, and then later released via munmap.
 
 */
-
+
 /*  sizes, alignments */
 
 #define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))
@@ -1307,7 +1309,7 @@ nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 #define aligned_OK(m)    (((unsigned long)((m)) & (MALLOC_ALIGN_MASK)) == 0)
 
 
-
+
 
 /*
   Physical chunk operations
@@ -1342,7 +1344,7 @@ nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 #define chunk_at_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
 
 
-
+
 
 /*
   Dealing with use bits
@@ -1381,7 +1383,7 @@ nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  (((mchunkptr)(((char*)(p)) + (s)))->size &= ~(PREV_INUSE))
 
 
-
+
 
 /*
   Dealing with size fields
@@ -1404,7 +1406,7 @@ nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 #define set_foot(p, s)   (((mchunkptr)((char*)(p) + (s)))->prev_size = (s))
 
 
-
+
 
 
 /*
@@ -1502,7 +1504,7 @@ void malloc_bin_reloc (void)
 		*p++ += gd->reloc_off;
 	}
 }
-
+
 
 /* field-extraction macros */
 
@@ -1538,7 +1540,7 @@ void malloc_bin_reloc (void)
 
 #define is_small_request(nb) (nb < MAX_SMALLBIN_SIZE - SMALLBIN_WIDTH)
 
-
+
 
 /*
     To help compensate for the large number of bins, a one-level index
@@ -1562,7 +1564,7 @@ void malloc_bin_reloc (void)
 #define clear_binblock(ii)  (binblocks_w = (mbinptr)(binblocks_r & ~(idx2binblock(ii))))
 
 
-
+
 
 
 /*  Other static bookkeeping data */
@@ -1600,7 +1602,7 @@ static unsigned int max_n_mmaps = 0;
 static unsigned long max_mmapped_mem = 0;
 #endif
 
-
+
 
 /*
   Debugging support
@@ -1747,7 +1749,7 @@ static void do_check_malloced_chunk(p, s) mchunkptr p; INTERNAL_SIZE_T s;
 #define check_malloced_chunk(P,N)
 #endif
 
-
+
 
 /*
   Macro-based internal utilities
@@ -1819,7 +1821,7 @@ static void do_check_malloced_chunk(p, s) mchunkptr p; INTERNAL_SIZE_T s;
   (last_remainder->fd = last_remainder->bk = last_remainder)
 
 
-
+
 
 
 /* Routines dealing with mmap(). */
@@ -1950,7 +1952,7 @@ static mchunkptr mremap_chunk(p, new_size) mchunkptr p; size_t new_size;
 #endif /* HAVE_MMAP */
 
 
-
+
 
 /*
   Extend the top-most chunk by obtaining memory from system.
@@ -2067,7 +2069,7 @@ static void malloc_extend_top(nb) INTERNAL_SIZE_T nb;
 }
 
 
-
+
 
 /* Main public routines */
 
@@ -2152,7 +2154,7 @@ Void_t* mALLOc(bytes) size_t bytes;
 
   INTERNAL_SIZE_T nb;
 
-  if ((long)bytes < 0) return 0;
+  if ((long)bytes <= 0) return 0;
 
   nb = request2size(bytes);  /* padded request size; */
 
@@ -2368,7 +2370,7 @@ Void_t* mALLOc(bytes) size_t bytes;
 }
 
 
-
+
 
 /*
 
@@ -2485,7 +2487,7 @@ void fREe(mem) Void_t* mem;
 }
 
 
-
+
 
 
 /*
@@ -2722,7 +2724,7 @@ Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
 }
 
 
-
+
 
 /*
 
@@ -2840,7 +2842,7 @@ Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
 
 }
 
-
+
 
 
 /*
@@ -2947,7 +2949,7 @@ void cfree(mem) Void_t *mem;
 }
 #endif
 
-
+
 
 /*
 
@@ -3028,7 +3030,7 @@ int malloc_trim(pad) size_t pad;
   }
 }
 
-
+
 
 /*
   malloc_usable_size:
@@ -3064,7 +3066,7 @@ size_t malloc_usable_size(mem) Void_t* mem;
 }
 
 
-
+
 
 /* Utility to update current_mallinfo for malloc_stats and mallinfo() */
 
@@ -3108,7 +3110,7 @@ static void malloc_update_mallinfo()
 }
 #endif	/* 0 */
 
-
+
 
 /*
 
@@ -3155,7 +3157,7 @@ struct mallinfo mALLINFo()
 #endif	/* 0 */
 
 
-
+
 
 /*
   mallopt:
diff --git a/cpu/arm_cortexa8/cpu.c b/cpu/arm_cortexa8/cpu.c
index 5a5981e..75d30eb 100644
--- a/cpu/arm_cortexa8/cpu.c
+++ b/cpu/arm_cortexa8/cpu.c
@@ -39,7 +39,47 @@
 #include <asm/arch/sys_proto.h>
 #endif
 
-static void cache_flush(void);
+void cache_flush(void);
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1(void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 0\
+			     @ read control reg\n":"=r"(value)
+			     ::"memory");
+	return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1(unsigned long value)
+{
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 0\
+			     @ write it back\n"::"r"(value)
+			     : "memory");
+
+	read_p15_c1();
+}
+
+static void cp_delay(void)
+{
+	/* Many OMAP regs need at least 2 nops */
+	asm("nop");
+	asm("nop");
+}
+
+/* See also ARM Ref. Man. */
+#define C1_MMU		(1<<0)	/* mmu off/on */
+#define C1_ALIGN	(1<<1)	/* alignment faults off/on */
+#define C1_DC		(1<<2)	/* dcache off/on */
+#define C1_WB		(1<<3)	/* merging write buffer on/off */
+#define C1_BIG_ENDIAN	(1<<7)	/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)	/* system protection */
+#define C1_ROM_PROT	(1<<9)	/* ROM protection */
+#define C1_IC		(1<<12)	/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)	/* location of vectors: low/high addresses */
+#define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */
 
 int cleanup_before_linux(void)
 {
@@ -77,7 +117,7 @@ int cleanup_before_linux(void)
 	return 0;
 }
 
-static void cache_flush(void)
+void cache_flush(void)
 {
 	asm ("mcr p15, 0, %0, c7, c5, 0": :"r" (0));
 }
diff --git a/cpu/arm_cortexa8/pnx84xx/Makefile b/cpu/arm_cortexa8/pnx84xx/Makefile
new file mode 100644
index 0000000..121bb6d
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/Makefile
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	=  $(obj)lib$(SOC).a
+
+SOBJS	:= lowlevel_init.o
+COBJS	:= sys_info.o board.o cache.o clock.o timer.o mem.o syslib.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/arm_cortexa8/pnx84xx/board.c b/cpu/arm_cortexa8/pnx84xx/board.c
new file mode 100644
index 0000000..092d3cf
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/board.c
@@ -0,0 +1,272 @@
+/*
+ *
+ * Common board functions for pnx84xx (apollo) based boards.
+ *
+ * Copyright  2009(C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+
+extern pnx84xx_sysinfo sysinfo;
+
+/******************************************************************************
+ * Routine: delay
+ * Description: spinning delay to use before udelay works
+ *****************************************************************************/
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0"(loops));
+}
+
+/******************************************************************************
+ * Routine: secure_unlock
+ * Description: Setup security registers for access
+ *              (GP Device only)
+ *****************************************************************************/
+void secure_unlock_mem(void)
+{
+	pm_t *pm_rt_ape_base = (pm_t *)PM_RT_APE_BASE_ADDR_ARM;
+	pm_t *pm_gpmc_base = (pm_t *)PM_GCS_BASE_ADDR_ARM;
+	pm_t *pm_ocm_ram_base = (pm_t *)PM_OCM_RAM_BASE_ADDR_ARM;
+	pm_t *pm_iva2_base = (pm_t *)PM_IVA2_BASE_ADDR_ARM;
+	sms_t *sms_base = (sms_t *)PNX84XX_SMS_BASE;
+
+	/* Protection Module Register Target APE (PM_RT) */
+	writel(UNLOCK_1, &pm_rt_ape_base->req_info_permission_1);
+	writel(UNLOCK_1, &pm_rt_ape_base->read_permission_0);
+	writel(UNLOCK_1, &pm_rt_ape_base->wirte_permission_0);
+	writel(UNLOCK_2, &pm_rt_ape_base->addr_match_1);
+
+	writel(UNLOCK_3, &pm_gpmc_base->req_info_permission_0);
+	writel(UNLOCK_3, &pm_gpmc_base->read_permission_0);
+	writel(UNLOCK_3, &pm_gpmc_base->wirte_permission_0);
+
+	writel(UNLOCK_3, &pm_ocm_ram_base->req_info_permission_0);
+	writel(UNLOCK_3, &pm_ocm_ram_base->read_permission_0);
+	writel(UNLOCK_3, &pm_ocm_ram_base->wirte_permission_0);
+	writel(UNLOCK_2, &pm_ocm_ram_base->addr_match_2);
+
+	/* IVA Changes */
+	writel(UNLOCK_3, &pm_iva2_base->req_info_permission_0);
+	writel(UNLOCK_3, &pm_iva2_base->read_permission_0);
+	writel(UNLOCK_3, &pm_iva2_base->wirte_permission_0);
+
+	/* SDRC region 0 public */
+	writel(UNLOCK_1, &sms_base->rg_att0);
+}
+
+/******************************************************************************
+ * Routine: secureworld_exit()
+ * Description: If chip is EMU and boot type is external
+ *		configure secure registers and exit secure world
+ *              general use.
+ *****************************************************************************/
+void secureworld_exit()
+{
+	unsigned long i;
+
+	/* configrue non-secure access control register */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c1, 2":"=r"(i));
+	/* enabling co-processor CP10 and CP11 accesses in NS world */
+	__asm__ __volatile__("orr %0, %0, #0xC00":"=r"(i));
+	/*
+	 * allow allocation of locked TLBs and L2 lines in NS world
+	 * allow use of PLE registers in NS world also
+	 */
+	__asm__ __volatile__("orr %0, %0, #0x70000":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c1, 2":"=r"(i));
+
+	/* Enable ASA in ACR register */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+	__asm__ __volatile__("orr %0, %0, #0x10":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+
+	/* Exiting secure world */
+	__asm__ __volatile__("mrc p15, 0, %0, c1, c1, 0":"=r"(i));
+	__asm__ __volatile__("orr %0, %0, #0x31":"=r"(i));
+	__asm__ __volatile__("mcr p15, 0, %0, c1, c1, 0":"=r"(i));
+}
+
+/******************************************************************************
+ * Routine: setup_auxcr()
+ * Description: Write to AuxCR desired value using SMI.
+ *              general use.
+ *****************************************************************************/
+void setup_auxcr()
+{
+	unsigned long i;
+	volatile unsigned int j;
+	/* Save r0, r12 and restore them after usage */
+	__asm__ __volatile__("mov %0, r12":"=r"(j));
+	__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+	/*
+	 * GP Device ROM code API usage here
+	 * r12 = AUXCR Write function and r0 value
+	 */
+	__asm__ __volatile__("mov r12, #0x3");
+	__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+	/* Enabling ASA */
+	__asm__ __volatile__("orr r0, r0, #0x10");
+	/* Enable L1NEON */
+	__asm__ __volatile__("orr r0, r0, #1 << 5");
+	/* SMI instruction to call ROM Code API */
+	__asm__ __volatile__(".word 0xE1600070");
+	__asm__ __volatile__("mov r0, %0":"=r"(i));
+	__asm__ __volatile__("mov r12, %0":"=r"(j));
+}
+
+
+/******************************************************************************
+ * Routine: s_init
+ * Description: Does early system init of muxing and clocks.
+ *              - Called path is with SRAM stack.
+ *****************************************************************************/
+void s_init(void)
+{
+	int in_sdram = is_running_in_sdram();
+
+	watchdog_init();
+
+	/*
+	 * Right now flushing at low MPU speed.
+	 * Need to move after clock init
+	 */
+	v7_flush_dcache_all(get_device_type());
+#ifndef CONFIG_ICACHE_OFF
+	icache_enable();
+#endif
+
+#ifdef CONFIG_L2_OFF
+	l2_cache_disable();
+#else
+	l2_cache_enable();
+#endif
+
+	set_muxconf_regs();
+	delay(100);
+
+/*	prcm_init(); */
+
+/*	per_clocks_enable(); */
+
+	if (!in_sdram)
+		sdrc_init();
+}
+
+/******************************************************************************
+ * Routine: wait_for_command_complete
+ * Description: Wait for posting to finish on watchdog
+ *****************************************************************************/
+void wait_for_command_complete(watchdog_t *wd_base)
+{
+	int pending = 1;
+	do {
+		pending = readl(&wd_base->wcount);
+	} while (pending);
+}
+
+/******************************************************************************
+ * Routine: watchdog_init
+ * Description: Shut down watch dogs
+ *****************************************************************************/
+void watchdog_init(void)
+{
+	/* no watchdogs in first vpe model */
+}
+
+/******************************************************************************
+ * Routine: dram_init
+ * Description: sets uboots idea of sdram size
+ *****************************************************************************/
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned int size0 = 0, size1 = 0;
+	u32 btype;
+
+	btype = get_board_type();
+
+	display_board_info(btype);
+
+	/*
+	 * If a second bank of DDR is attached to CS1 this is
+	 * where it can be started.  Early init code will init
+	 * memory on CS0.
+	 */
+	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED)) {
+		do_sdrc_init(CS1, NOT_EARLY);
+		make_cs1_contiguous();
+	}
+
+	size0 = get_sdr_cs_size(CS0);
+	size1 = get_sdr_cs_size(CS1);
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = size0;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
+	gd->bd->bi_dram[1].size = size1;
+
+	return 0;
+}
+
+
+/******************************************************************************
+ * Dummy function to handle errors for EABI incompatibility
+ *****************************************************************************/
+void abort(void)
+{
+}
+
+#ifdef CONFIG_NAND_OMAP_GPMC
+/******************************************************************************
+ * OMAP3 specific command to switch between NAND HW and SW ecc
+ *****************************************************************************/
+static int do_switch_ecc(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	if (argc != 2)
+		goto usage;
+	if (strncmp(argv[1], "hw", 2) == 0)
+		omap_nand_switch_ecc(1);
+	else if (strncmp(argv[1], "sw", 2) == 0)
+		omap_nand_switch_ecc(0);
+	else
+		goto usage;
+
+	return 0;
+
+usage:
+	printf ("Usage: nandecc %s\n", cmdtp->help);
+	return 1;
+}
+
+U_BOOT_CMD(
+	nandecc, 2, 1,	do_switch_ecc,
+	"nandecc - switch OMAP3 NAND ECC calculation algorithm\n",
+	"[hw/sw] - Switch between NAND hardware (hw) or software (sw) ecc algorithm\n"
+	);
+
+#endif /* CONFIG_NAND_OMAP_GPMC */
diff --git a/cpu/arm_cortexa8/pnx84xx/cache.c b/cpu/arm_cortexa8/pnx84xx/cache.c
new file mode 100644
index 0000000..eb4b6f5
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/cache.c
@@ -0,0 +1,108 @@
+/*
+ * (C) Copyright 2008 Texas Insturments
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * omap3 L2 cache code
+ */
+
+#include <common.h>
+#include <asm/system.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/cache.h>
+
+void flush_dcache_range(ulong start_addr, ulong stop);
+void invalidate_dcache_range(ulong start_addr, ulong stop);
+
+void l2_cache_enable(void)
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() >= CPU_8400_ES1) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("orr %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/*
+		 * GP Device ROM code API usage here
+		 * r12 = AUXCR Write function and r0 value
+		 */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("orr r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+
+}
+
+void l2_cache_disable(void)
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() >= CPU_8400_ES1) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("bic %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1":"=r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/*
+		 * GP Device ROM code API usage here
+		 * r12 = AUXCR Write function and r0 value
+		 */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("bic r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+}
+void flush_dcache_range(ulong start_addr, ulong stop)
+{
+	cache_flush();
+}
+
+void invalidate_dcache_range(ulong start_addr, ulong stop)
+{
+	cache_flush();
+}
diff --git a/cpu/arm_cortexa8/pnx84xx/clock.c b/cpu/arm_cortexa8/pnx84xx/clock.c
new file mode 100644
index 0000000..bdb3ce1
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/clock.c
@@ -0,0 +1,49 @@
+/*
+ * (C) Copyright 2009
+ * NXP Semiconductors, <www.nxp.com>
+ *
+ * Author :
+ *      TH <okc@nxp.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+#include <environment.h>
+#include <command.h>
+
+
+/******************************************************************************
+ * prcm_init() - inits clocks for PRCM as defined in clocks.h
+ *               called from SRAM, or Flash (using temp SRAM stack).
+ *****************************************************************************/
+void prcm_init(void)
+{
+
+}
+
+/******************************************************************************
+ * peripheral_enable() - Enable the clks & power for perifs (GPT2, UART1,...)
+ *****************************************************************************/
+void per_clocks_enable(void)
+{
+
+}
diff --git a/cpu/arm_cortexa8/pnx84xx/config.mk b/cpu/arm_cortexa8/pnx84xx/config.mk
new file mode 100644
index 0000000..fbb753e
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/config.mk
@@ -0,0 +1,36 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+PLATFORM_RELFLAGS += -fno-strict-aliasing -fno-common -ffixed-r8 \
+		     -msoft-float
+
+# Make ARMv5 to allow more compilers to work, even though its v7a.
+PLATFORM_CPPFLAGS += -march=armv5
+# =========================================================================
+#
+# Supply options according to compiler version
+#
+# =========================================================================
+PLATFORM_CPPFLAGS +=$(call cc-option)
+PLATFORM_CPPFLAGS +=$(call cc-option,-mno-thumb-interwork,)
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,\
+		    $(call cc-option,-malignment-traps,))
diff --git a/cpu/arm_cortexa8/pnx84xx/lowlevel_init.S b/cpu/arm_cortexa8/pnx84xx/lowlevel_init.S
new file mode 100644
index 0000000..f8ed0c8
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/lowlevel_init.S
@@ -0,0 +1,54 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2009
+ * NXP Semiconductors BV, <www.nxp.com>
+ *
+ * Initial Code by:
+ * Tjeu Horsch <tjeu.horsch@nxp.com>
+  *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/mem.h>
+
+
+.globl lowlevel_init
+lowlevel_init:
+    /* early set up stack, normaly used to be able to use C during   */
+    /* init phases where SDRAM and Clocks are not yet initialized.   */
+    /* there for normaly the stack is located in SRAM. But since in  */
+    /* Apollo the uBootloader already has init DRAM and Clocks we    */
+    /* can use a Stack in SDRAM                                      */
+	ldr	sp, =(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_UBOOT_SIZE -12)
+
+	str	ip, [sp]	/* stash old link register */
+	mov	ip, lr		/* save link reg across call */
+	bl	s_init		/* go setup pll, mux, memory */
+	ldr	ip, [sp]	/* restore save ip */
+	mov	lr, ip		/* restore link reg */
+
+	/* back to arch calling code */
+	mov	pc, lr
+
+	/* the literal pools origin */
+	.ltorg
+
diff --git a/cpu/arm_cortexa8/pnx84xx/mem.c b/cpu/arm_cortexa8/pnx84xx/mem.c
new file mode 100644
index 0000000..fcc80e0
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/mem.c
@@ -0,0 +1,139 @@
+/*
+ * (C) Copyright 2009
+ * NXP Semiconductors, <www.nxp.com>
+ *
+ * Author :
+ *     T. Horsch <okc@nxp.com>
+ *
+ * Initial Code from:
+ *     Richard Woodruff <r-woodruff2@ti.com>
+ *     Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/sys_proto.h>
+#include <command.h>
+
+/*
+ * Only One NAND allowed on board at a time.
+ * The GPMC CS Base for the same
+ */
+unsigned int boot_flash_base;
+unsigned int boot_flash_off;
+unsigned int boot_flash_sec;
+unsigned int boot_flash_type;
+volatile unsigned int boot_flash_env_addr;
+
+
+
+static ip2035_t *sdrc_base = (ip2035_t *)PNX84XX_SDRC_BASE;
+
+/**************************************************************************
+ * make_cs1_contiguous() - for es2 and above remap cs1 behind cs0 to allow
+ *  command line mem=xyz use all memory with out discontinuous support
+ *  compiled in.  Could do it at the ATAG, but there really is two banks...
+ * Called as part of 2nd phase DDR init.
+ **************************************************************************/
+void make_cs1_contiguous(void)
+{
+	u32 size, a_add_low, a_add_high;
+
+	size = get_sdr_cs_size(CS0);
+	size /= SZ_32M;			/* find size to offset CS1 */
+	a_add_high = (size & 3) << 8;	/* set up low field */
+	a_add_low = (size & 0x3C) >> 2;	/* set up high field */
+/* TH	writel((a_add_high | a_add_low), &sdrc_base->cs_cfg); */
+
+}
+
+/********************************************************
+ *  mem_ok() - test used to see if timings are correct
+ *             for a part. Helps in guessing which part
+ *             we are currently using.
+ *******************************************************/
+u32 mem_ok(u32 cs)
+{
+	u32 val1, val2, addr;
+	u32 pattern = 0x12345678;
+
+	addr = PNX84XX_SDRC_CS0 + get_sdr_cs_offset(cs);
+
+	writel(0x0, addr + 0x400);	/* clear pos A */
+	writel(pattern, addr);		/* pattern to pos B */
+	writel(0x0, addr + 4);		/* remove pattern off the bus */
+	val1 = readl(addr + 0x400);	/* get pos A value */
+	val2 = readl(addr);		/* get val2 */
+
+	if ((val1 != 0) || (val2 != pattern))	/* see if pos A val changed */
+		return 0;
+	else
+		return 1;
+}
+
+/********************************************************
+ *  sdrc_init() - init the sdrc chip selects CS0 and CS1
+ *  - early init routines, called from flash or
+ *  SRAM.
+ *******************************************************/
+void sdrc_init(void)
+{
+	/* only init up first bank here */
+	do_sdrc_init(CS0, EARLY_INIT);
+}
+
+/*************************************************************************
+ * do_sdrc_init(): initialize the SDRAM for use.
+ *  -code sets up SDRAM basic SDRC timings for CS0
+ *  -optimal settings can be placed here, or redone after i2c
+ *      inspection of board info
+ *
+ *  - code called once in C-Stack only context for CS0 and a possible 2nd
+ *      time depending on memory configuration from stack+global context
+ **************************************************************************/
+
+void do_sdrc_init(u32 cs, u32 early)
+{
+	/* do not do anything. It is assumed that SDRAM is setup by Micro Boot */
+}
+
+
+/*****************************************************
+ * gcs_init(): init global system
+ * Init
+ * This code can only be executed from SRAM or SDRAM.
+ *****************************************************/
+void gcs_init(void)
+{
+	unsigned long temp_val;
+	gcs_config_t *gcs_base = (gcs_config_t *)(PNX84XX_GCS_BASE + PNX84XX_GCS_CFG_OFSET);
+/*
+ *
+ */
+	 writel( 0x03, &gcs_base->flash_config);
+	 writel( 0xc0000000, &gcs_base->dscn_nor_base);
+	 writel( 0xf0000000, &gcs_base->dscn_nor_aperture);
+	 writel( 0x0, &gcs_base->dscn_nor_addr_remap);
+	 writel( 0xc0000000, &gcs_base->dma_nor_base);
+	 writel( 0xf0000000, &gcs_base->dma_nor_aperture);
+	 writel( 0x00, &gcs_base->nor_cs_route);
+
+
+}
+
diff --git a/cpu/arm_cortexa8/pnx84xx/sys_info.c b/cpu/arm_cortexa8/pnx84xx/sys_info.c
new file mode 100644
index 0000000..9fb8a5b
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/sys_info.c
@@ -0,0 +1,325 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Author :
+ *      Manikandan Pillai <mani.pillai@ti.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *      Richard Woodruff <r-woodruff2@ti.com>
+ *      Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>	/* get mem tables */
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+
+extern pnx84xx_sysinfo sysinfo;
+/* TODO: remove  static gcs_csx_t *gcs_cs_base = (gcs_csx_t *)GCS_CONFIG_CS0_BASE; */
+static ip2035_t *sdrc_base = (ip2035_t *)PNX84XX_SDRC_BASE;
+static global_reg_t *global_reg_base = (global_reg_t *)PNX84XX_GREG_BASE;
+
+/*****************************************************************
+ * dieid_num_r(void) - read and set die ID
+ *****************************************************************/
+void dieid_num_r(void)
+{
+	char *uid_s, die_id[34];
+	u32 id;
+
+	memset(die_id, 0, sizeof(die_id));
+
+	uid_s = getenv("dieid#");
+
+	if (uid_s == NULL) {
+		id = readl(&global_reg_base->globalreg_module_id);
+		sprintf(die_id, "%08x", id);
+		setenv("dieid#", die_id);
+		uid_s = die_id;
+	}
+
+	printf("Die ID #%s\n", uid_s);
+}
+
+/******************************************
+ * get_cpu_type(void) - extract cpu info
+ ******************************************/
+u32 get_cpu_type(void)
+{
+	return readl(&global_reg_base->globalreg_module_id);
+}
+
+/******************************************
+ * get_cpu_rev(void) - extract version info
+ ******************************************/
+u32 get_cpu_rev(void)
+{
+	u32 cpuid = 0;
+
+	/*
+	 * On ES1.0 the IDCODE register is not exposed on L4
+	 * so using CPU ID to differentiate
+	 * between ES2.0 and ES1.0.
+	 */
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 0":"=r"(cpuid));
+	if ((cpuid & 0xf) == 0x0)
+		return CPU_8400_ES1;
+	else
+		return CPU_8400_ES2;
+
+}
+
+/****************************************************
+ * is_mem_sdr() - return 1 if mem type in use is SDR
+ ****************************************************/
+u32 get_dram_type(void)
+{
+	u32 mtype;
+
+	mtype =   readl(&sdrc_base->ctl ) & 0x7;
+	return mtype;
+}
+
+/***********************************************************************
+ * get_cs0_size() - get size of chip select 0/1
+ ************************************************************************/
+u32 get_sdr_cs_size(u32 cs)
+{
+	u32 rank0;
+	u32 size, col_w, row_w, bank_w, data_w, adress_w;
+	/* get ram size field */
+	rank0 = readl(&sdrc_base->rank0);
+	col_w = rank0 & 0xf;
+	row_w = (rank0 >>4) & 0xf;
+	bank_w = (rank0 >>8) & 0x3;
+	data_w = (rank0 >>10) & 0x3;
+
+	adress_w = col_w + row_w + bank_w + data_w;
+
+	size = 1 << adress_w;
+	return size;
+}
+
+/***********************************************************************
+ * get_sdr_cs_offset() - get offset of cs from cs0 start
+ ************************************************************************/
+u32 get_sdr_cs_offset(u32 cs)
+{
+	u32 offset;
+
+	if (!cs)
+		return 0;
+	offset = 0x10000000;
+	return offset ;
+}
+
+/***********************************************************************
+ * get_board_type() - get board type based on current production stats.
+ *  - NOTE-1-: 2 I2C EEPROMs will someday be populated with proper info.
+ *    when they are available we can get info from there.  This should
+ *    be correct of all known boards up until today.
+ *  - NOTE-2- EEPROMs are populated but they are updated very slowly.  To
+ *    avoid waiting on them we will use ES version of the chip to get info.
+ *    A later version of the FPGA migth solve their speed issue.
+ ************************************************************************/
+u32 get_board_type(void)
+{
+	if (get_cpu_rev() == CPU_8400_ES2)
+		return sysinfo.board_type_v2;
+	else
+		return sysinfo.board_type_v1;
+}
+
+/***************************************************************************
+ *  get_gcs0_base() - Return current address hardware will be
+ *     fetching from. The below effectively gives what is correct, its a bit
+ *   mis-leading compared to the TRM.  For the most general case the mask
+ *   needs to be also taken into account this does work in practice.
+ *   - for u-boot we currently map:
+ *       -- 0 to nothing,
+ *       -- 4 to flash
+ *       -- 8 to enent
+ *       -- c to wifi
+ ****************************************************************************/
+u32 get_gcs0_base(void)
+{
+	u32 b;
+
+/* TODO: remove 	b = readl(&gcs_cs_base->config7);  */
+	b &= 0x1F;		/* keep base [5:0] */
+	b = b << 24;		/* ret 0x0b000000 */
+	return b;
+}
+
+/*******************************************************************
+ * get_gcs0_width() - See if bus is in x8 or x16 (mainly for nand)
+ *******************************************************************/
+u32 get_gcs0_width(void)
+{
+	return WIDTH_16BIT;
+}
+
+/*************************************************************************
+ * get_board_rev() - setup to pass kernel board revision information
+ * returns:(bit[0-3] sub version, higher bit[7-4] is higher version)
+ *************************************************************************/
+u32 get_board_rev(void)
+{
+	return 0x20;
+}
+
+/*********************************************************************
+ *  display_board_info() - print banner with board info.
+ *********************************************************************/
+void display_board_info(u32 btype)
+{
+	char *cpu_s, *mem_s, *sec_s;
+
+	switch (get_cpu_type()) {
+	case OMAP3503:
+		cpu_s = "3503";
+		break;
+	case OMAP3515:
+		cpu_s = "3515";
+		break;
+	case OMAP3525:
+		cpu_s = "3525";
+		break;
+	case OMAP3530:
+		cpu_s = "3530";
+		break;
+	default:
+		cpu_s = "8493";
+		break;
+	}
+
+	switch (get_dram_type()) {
+	case 0:
+		mem_s = "SDR";
+		break;
+	case 1:
+		mem_s = "mSDR";
+		break;
+	case 2:
+		mem_s = "DDR";
+		break;
+	case 3:
+		mem_s = "LPDDR";
+		break;
+	case 4:
+		mem_s = "DDR2";
+		break;
+	default:
+		mem_s = "?";
+	}
+
+
+
+
+	switch (get_device_type()) {
+	case TST_DEVICE:
+		sec_s = "VPE";
+		break;
+	case EMU_DEVICE:
+		sec_s = "EMU";
+		break;
+	case HS_DEVICE:
+		sec_s = "HS";
+		break;
+	case GP_DEVICE:
+		sec_s = "GP";
+		break;
+	default:
+		sec_s = "?";
+	}
+
+
+	printf("PNX%s-%s rev %d, CPU-ARM-A9 L3-165MHz\n", cpu_s,
+	       sec_s, get_cpu_rev());
+	printf("%s + %s/%s\n", sysinfo.board_string,
+	       mem_s, sysinfo.nand_string);
+
+}
+
+/********************************************************
+ *  get_base(); get upper addr of current execution
+ *******************************************************/
+u32 get_base(void)
+{
+	u32 val;
+
+	__asm__ __volatile__("mov %0, pc \n":"=r"(val)::"memory");
+	val &= 0xF0000000;
+	val >>= 28;
+	return val;
+}
+
+/********************************************************
+ *  is_running_in_flash() - tell if currently running in
+ *  FLASH.
+ *******************************************************/
+u32 is_running_in_flash(void)
+{
+	if (get_base() == 0xC)
+		return 1;	/* in FLASH */
+
+	return 0;		/* running in SRAM or SDRAM */
+}
+
+/********************************************************
+ *  is_running_in_sram() - tell if currently running in
+ *  SRAM.
+ *******************************************************/
+u32 is_running_in_sram(void)
+{
+	if (get_base() == 0xf)
+		return 1;	/* in SRAM */
+
+	return 0;		/* running in FLASH or SDRAM */
+}
+
+/********************************************************
+ *  is_running_in_sdram() - tell if currently running in
+ *  SDRAM.
+ *******************************************************/
+u32 is_running_in_sdram(void)
+{
+	if (get_base() < 0x8)
+		return 1;	/* in SDRAM */
+
+	return 0;		/* running in SRAM or FLASH */
+}
+
+/***************************************************************
+ *  get_boot_type() - Is this an XIP type device or a stream one
+ *  bits 4-0 specify type. Bit 5 says mem/perif
+ ***************************************************************/
+u32 get_boot_type(void)
+{
+	return (readl(&global_reg_base->globalreg_module_id) & SYSBOOT_MASK);
+}
+
+/*************************************************************
+ *  get_device_type():
+ *************************************************************/
+u32 get_device_type(void)
+{
+	return ((readl(&global_reg_base->globalreg_module_id) & (DEVICE_MASK)) >> 8);
+}
diff --git a/cpu/arm_cortexa8/pnx84xx/syslib.c b/cpu/arm_cortexa8/pnx84xx/syslib.c
new file mode 100644
index 0000000..9ced495
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/syslib.c
@@ -0,0 +1,72 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/sys_proto.h>
+
+/************************************************************
+ * sdelay() - simple spin loop.  Will be constant time as
+ *  its generally used in bypass conditions only.  This
+ *  is necessary until timers are accessible.
+ *
+ *  not inline to increase chances its in cache when called
+ *************************************************************/
+void sdelay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0"(loops));
+}
+
+/*****************************************************************
+ * sr32 - clear & set a value in a bit range for a 32 bit address
+ *****************************************************************/
+void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
+{
+	u32 tmp, msk = 0;
+	msk = 1 << num_bits;
+	--msk;
+	tmp = readl((u32)addr) & ~(msk << start_bit);
+	tmp |= value << start_bit;
+	writel(tmp, (u32)addr);
+}
+
+/*********************************************************************
+ * wait_on_value() - common routine to allow waiting for changes in
+ *   volatile regs.
+ *********************************************************************/
+u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
+		  u32 bound)
+{
+	u32 i = 0, val;
+	do {
+		++i;
+		val = readl((u32)read_addr) & read_bit_mask;
+		if (val == match_value)
+			return 1;
+		if (i == bound)
+			return 0;
+	} while (1);
+}
diff --git a/cpu/arm_cortexa8/pnx84xx/timer.c b/cpu/arm_cortexa8/pnx84xx/timer.c
new file mode 100644
index 0000000..2cfb113
--- /dev/null
+++ b/cpu/arm_cortexa8/pnx84xx/timer.c
@@ -0,0 +1,168 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments
+ *
+ * Richard Woodruff <r-woodruff2@ti.com>
+ * Syed Moahmmed Khasim <khasim@ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/proc-armv/ptrace.h>
+#include <nxp_pnx8400_rgu.h>
+
+
+#define TIMER_PRESCALE_VAL (CONFIG_PERTIMER_CLOCK_HZ / CONFIG_SYS_HZ)
+#define __REG(x)	(*((volatile u32 *) x ))
+
+/*
+ * Nothing really to do with interrupts, just starts up a counter.
+ * We run the counter with 25MHz, divided by 250, resulting in timer
+ * frequency of 0.1 MHz. With 32bit counter register, counter
+ * overflows in ~11 hour
+ */
+
+#define TIMER_CLOCK	(CONFIG_SYS_HZ)
+#define TO_TICKS(x)     (x / (1000000/CONFIG_SYS_HZ))
+#define TO_USEC(x)      (x * (1000000/CONFIG_SYS_HZ))
+#define TIMER_LOAD_VAL	0xffffffff
+
+static ulong timestamp;
+static ulong lastinc;      /* counter value  in ticks */
+static ulong timeout_val;
+
+static gptimer_t *timer_base = (gptimer_t *)CONFIG_SYS_LOCALTIMERBASE;
+
+void reset_cpu (ulong addr)
+{
+	__REG(PNX84XX_RGU_BASE+NXP_PNX8400_RGU_SMARTCARD) = 1;
+}
+
+
+int timer_init(void)
+{
+	/* start the counter ticking up, reload value on overflow */
+	writel(TIMER_LOAD_VAL, &timer_base->tldr);
+	/* enable timer */
+	writel((TIMER_PRESCALE_VAL << 8) | TCLR_AI | TCLR_TE,
+		&timer_base->tclr);
+
+	reset_timer_masked();	/* init the timestamp and lastinc value */
+
+	return 0;
+}
+
+/*
+ * timer without interrupts
+ */
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void set_timer(ulong t)
+{
+	timestamp = t;
+}
+
+/* delay x useconds */
+void udelay(unsigned long usec)
+{
+	unsigned long tmo = TO_TICKS(usec);
+	unsigned long now, last = readl(&timer_base->tcrr);
+
+	while (tmo > 0) {
+		now = readl(&timer_base->tcrr);
+		if (last <  now) /* count down timer overflow */
+			tmo -= TIMER_LOAD_VAL - now + last;
+		else
+			tmo -= last - now;
+		last = now;
+	}
+}
+
+void reset_timer_masked(void)
+{
+	/* reset time, capture current incrementer value time */
+	lastinc = readl(&timer_base->tcrr);
+	timestamp = 0x0;		/* start "increasing" time stamp from 0x0 */
+}
+
+ulong get_timer_masked(void)
+{
+	/* current tick value */
+	 ulong now;
+
+	now = readl(&timer_base->tcrr);
+
+	if (now <= lastinc)	{/* normal mode (non roll) */
+		/* move stamp forward with absolute diff ticks */
+		timestamp += (lastinc-now);
+	}
+	else	{/* we have rollover of decrementer */
+		timestamp += (lastinc + (TIMER_LOAD_VAL - now));
+	}
+	lastinc = now;
+	return timestamp;
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+void set_timeout(unsigned long usec)
+{
+/*TODO:  make sure timeoutval_val stays positive ) */
+	timeout_val = get_timer_masked() + TO_TICKS( usec);
+}
+
+int did_timeout(void)
+{
+
+	return (int) get_timer_masked() > timeout_val;
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CONFIG_SYS_HZ;
+}
diff --git a/cpu/arm_cortexa8/start.S b/cpu/arm_cortexa8/start.S
index 6bd6552..00b83f8 100644
--- a/cpu/arm_cortexa8/start.S
+++ b/cpu/arm_cortexa8/start.S
@@ -95,10 +95,14 @@ FIQ_STACK_START:
 	.word 0x0badc0de
 #endif
 
+#define DEBUG_SCRATCH_PROGRESS 1
 /*
  * the actual reset code
  */
-
+uart_addr:
+	.word	0xe06e2000
+scratch2_addr:
+	.word	0xe06ead04
 reset:
 	/*
 	 * set the cpu to SVC32 mode
@@ -107,8 +111,42 @@ reset:
 	bic	r0, r0, #0x1f
 	orr	r0, r0, #0xd3
 	msr	cpsr,r0
+#if (CONFIG_PNX_EMU) 	/* working on emulator */
+debug:
+	ldr r1,uart_addr
+	mov r2,#0x39
+	str	r2,[r1]
+#endif
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x001
+	str	r2,[r1]
+#endif
 
+#if (CONFIG_PNX84XX)
+	/* Copy vectors to 0x0 */
+	adr	r0, _start		@ r0 <- current position of code
+	add	r0, r0, #4		@ skip reset vector
+	mov	r2, #64			@ r2 <- size to copy
+	add	r2, r0, r2		@ r2 <- source end address
+	mov	r1, #0       	@ vect addr
+next:
+	ldmia	r0!, {r3 - r10}		@ copy from source address [r0]
+	stmia	r1!, {r3 - r10}		@ copy to   target address [r1]
+	cmp	r0, r2			@ until source end address [r2]
+	bne	next			@ loop until equal */
+#endif
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x002
+	str	r2,[r1]
+#endif
 #if (CONFIG_OMAP34XX)
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x003
+	str	r2,[r1]
+#endif
 	/* Copy vectors to mask ROM indirect addr */
 	adr	r0, _start		@ r0 <- current position of code
 	add	r0, r0, #4		@ skip reset vector
@@ -130,13 +168,31 @@ next:
 	 */
 	bl	cpy_clk_code		@ put dpll adjust code behind vectors
 #endif /* NAND Boot */
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x004
+	str	r2,[r1]
+#endif
 #endif
-	/* the mask ROM code should have PLL and others stable */
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x005
+	str	r2,[r1]
+#endif	/* the mask ROM code should have PLL and others stable */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
-	bl	cpu_init_crit
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x006
+	str	r2,[r1]
+#endif	bl	cpu_init_crit
 #endif
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x007
+	str	r2,[r1]
+#endif
 relocate:				@ relocate U-Boot to RAM
 	adr	r0, _start		@ r0 <- current position of code
 	ldr	r1, _TEXT_BASE		@ test if we run from flash or RAM
@@ -153,20 +209,36 @@ copy_loop:				@ copy 32 bytes at a time
 	stmia	r1!, {r3 - r10}		@ copy to   target address [r1]
 	cmp	r0, r2			@ until source end addreee [r2]
 	ble	copy_loop
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x008
+	str	r2,[r1]
+#endif
 #endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
-
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x009
+	str	r2,[r1]
+#endif
 	/* Set up the stack */
 stack_setup:
-	ldr	r0, _TEXT_BASE		@ upper 128 KiB: relocated uboot
-	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN @ malloc area
-	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE @ bdinfo
-#ifdef CONFIG_USE_IRQ
+#ifdef CONFIG_MEMORY_UPPER_CODE
+	ldr	r0, =(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_UBOOT_SIZE )
+#else
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE /* bdinfo                        */
 	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ)
 #endif
-	sub	sp, r0, #12		@ leave 3 words for abort-stack
+	sub	sp, r0, #12		/* leave 3 words for abort-stack  CONFIG_SYS_MONITOR_BASE  */
 	and	sp, sp, #~7		@ 8 byte alinged for (ldr/str)d
 
 	/* Clear BSS (if any). Is below tx (watch load addr - need space) */
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x00a
+	str	r2,[r1]
+#endif
 clear_bss:
 	ldr	r0, _bss_start		@ find start of bss segment
 	ldr	r1, _bss_end		@ stop here
@@ -177,6 +249,12 @@ clbss_l:
 	add	r0, r0, #4		@ increment clear index pointer
 	bne	clbss_l			@ keep clearing till at end
 
+#if (DEBUG_SCRATCH_PROGRESS)
+	ldr r1,scratch2_addr
+	mov r2,#0x00b
+	str	r2,[r1]
+#endif
+
 	ldr	pc, _start_armboot	@ jump to C code
 
 _start_armboot: .word start_armboot
diff --git a/disk/part.c b/disk/part.c
index b92fb45..7cdfb93 100644
--- a/disk/part.c
+++ b/disk/part.c
@@ -39,6 +39,7 @@
      defined(CONFIG_CMD_SATA) || \
      defined(CONFIG_CMD_SCSI) || \
      defined(CONFIG_CMD_USB) || \
+     defined(CONFIG_CMD_UBI) || \
      defined(CONFIG_MMC) || \
      defined(CONFIG_SYSTEMACE) )
 
@@ -47,6 +48,8 @@ struct block_drvr {
 	block_dev_desc_t* (*get_dev)(int dev);
 };
 
+extern block_dev_desc_t *ubi_get_dev(int dev);
+
 static const struct block_drvr block_drvr[] = {
 #if defined(CONFIG_CMD_IDE)
 	{ .name = "ide", .get_dev = ide_get_dev, },
@@ -69,6 +72,9 @@ static const struct block_drvr block_drvr[] = {
 #if defined(CONFIG_CMD_MG_DISK)
 	{ .name = "mgd", .get_dev = mg_disk_get_dev, },
 #endif
+#if defined(CONFIG_CMD_UBI)
+	{ .name = "ubi", .get_dev = ubi_get_dev, },
+#endif
 	{ },
 };
 
@@ -100,6 +106,7 @@ block_dev_desc_t *get_dev(char* ifname, int dev)
      defined(CONFIG_CMD_SCSI) || \
      defined(CONFIG_CMD_USB) || \
      defined(CONFIG_MMC) || \
+     defined(CONFIG_CMD_UBI) || \
      defined(CONFIG_SYSTEMACE) )
 
 /* ------------------------------------------------------------------------- */
@@ -217,6 +224,7 @@ void dev_print (block_dev_desc_t *dev_desc)
      defined(CONFIG_CMD_SATA) || \
      defined(CONFIG_CMD_SCSI) || \
      defined(CONFIG_CMD_USB) || \
+     defined(CONFIG_CMD_UBI) || \
      defined(CONFIG_MMC)		|| \
      defined(CONFIG_SYSTEMACE) )
 
diff --git a/disk/part_dos.c b/disk/part_dos.c
index b915eb7..6d35cab 100644
--- a/disk/part_dos.c
+++ b/disk/part_dos.c
@@ -35,13 +35,14 @@
 #include <ide.h>
 #include "part_dos.h"
 
-#if defined(CONFIG_CMD_IDE) || \
-    defined(CONFIG_CMD_MG_DISK) || \
-    defined(CONFIG_CMD_SATA) || \
-    defined(CONFIG_CMD_SCSI) || \
-    defined(CONFIG_CMD_USB) || \
-    defined(CONFIG_MMC) || \
-    defined(CONFIG_SYSTEMACE)
+#if (defined(CONFIG_CMD_IDE) || \
+     defined(CONFIG_CMD_MG_DISK) || \
+     defined(CONFIG_CMD_SATA) || \
+     defined(CONFIG_CMD_SCSI) || \
+     defined(CONFIG_CMD_USB) || \
+     defined(CONFIG_CMD_UBI) || \
+     defined(CONFIG_MMC) || \
+     defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_DOS_PARTITION)
 
 /* Convert char[4] in little endian format to the host format integer
  */
diff --git a/disk/part_efi.c b/disk/part_efi.c
index 1b04c27..a339d9d 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -36,13 +36,14 @@
 #include <malloc.h>
 #include "part_efi.h"
 
-#if defined(CONFIG_CMD_IDE) || \
-    defined(CONFIG_CMD_MG_DISK) || \
-    defined(CONFIG_CMD_SATA) || \
-    defined(CONFIG_CMD_SCSI) || \
-    defined(CONFIG_CMD_USB) || \
-    defined(CONFIG_MMC) || \
-    defined(CONFIG_SYSTEMACE)
+#if (defined(CONFIG_CMD_IDE) || \
+     defined(CONFIG_CMD_MG_DISK) || \
+     defined(CONFIG_CMD_SATA) || \
+     defined(CONFIG_CMD_SCSI) || \
+     defined(CONFIG_CMD_USB) || \
+     defined(CONFIG_CMD_UBI) || \
+     defined(CONFIG_MMC) || \
+     defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_DOS_PARTITION)
 
 /* Convert char[2] in little endian format to the host format integer
  */
@@ -164,9 +165,7 @@ int get_partition_info_efi(block_dev_desc_t * dev_desc, int part,
 
 	/* The ulong casting limits the maximum disk size to 2 TB */
 	info->start = (ulong) le64_to_int((*pgpt_pte)[part - 1].starting_lba);
-	/* The ending LBA is inclusive, to calculate size, add 1 to it */
-	info->size = ((ulong)le64_to_int((*pgpt_pte)[part - 1].ending_lba) + 1)
-		     - info->start;
+	info->size = (ulong) le64_to_int((*pgpt_pte)[part - 1].ending_lba) - info->start;
 	info->blksz = GPT_BLOCK_SIZE;
 
 	sprintf((char *)info->name, "%s%d", GPT_ENTRY_NAME, part);
diff --git a/disk/part_iso.c b/disk/part_iso.c
index 990da95..de3144a 100644
--- a/disk/part_iso.c
+++ b/disk/part_iso.c
@@ -31,7 +31,7 @@
     defined(CONFIG_CMD_SATA) || \
     defined(CONFIG_CMD_USB) || \
     defined(CONFIG_MMC) || \
-    defined(CONFIG_SYSTEMACE)
+    defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_ISO_PARTITION)
 
 /* #define	ISO_PART_DEBUG */
 
diff --git a/disk/part_mac.c b/disk/part_mac.c
index bebe415..3ecdfab 100644
--- a/disk/part_mac.c
+++ b/disk/part_mac.c
@@ -40,7 +40,7 @@
     defined(CONFIG_CMD_SATA) || \
     defined(CONFIG_CMD_USB) || \
     defined(CONFIG_MMC) || \
-    defined(CONFIG_SYSTEMACE)
+    defined(CONFIG_SYSTEMACE) ) && defined(CONFIG_MAC_PARTITION)
 
 /* stdlib.h causes some compatibility problems; should fixe these! -- wd */
 #ifndef __ldiv_t_defined
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 36d99f9..397da84 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -26,6 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	:= $(obj)libdma.a
 
 COBJS-$(CONFIG_FSLDMAFEC) += MCD_tasksInit.o MCD_dmaApi.o MCD_tasks.o
+COBJS-$(CONFIG_DMAC_NXP_1902) += nx_dmac_ip1902.o
 COBJS-$(CONFIG_FSL_DMA) += fsl_dma.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/dma/nx_dmac_ip1902.c b/drivers/dma/nx_dmac_ip1902.c
new file mode 100755
index 0000000..0b3095d
--- /dev/null
+++ b/drivers/dma/nx_dmac_ip1902.c
@@ -0,0 +1,342 @@
+/*
+ * Device driver for NAND flash connected IP_2070 EFM.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version      Date          Remarks
+ * 0.0.1	 		20090108		Draft-Initial version
+ */
+/*----------------------------------------------------------------------
+ * Standard include files
+ *---------------------------------------------------------------------*/
+#include <common.h>
+#include <malloc.h>
+#include <watchdog.h>
+#include <linux/err.h>
+#include <linux/mtd/compat.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+
+ #include <linux/nx_dmac_ip1902.h>
+
+#undef DEBUG
+#define CACHE_LINE_SIZE (32)
+#define CACHE_LINE_MASK (CACHE_LINE_SIZE - 1)
+#ifdef DEBUG
+#define DBG_PRINT(x) printf x
+#else
+#define DBG_PRINT(x)
+#endif
+
+/**
+* DMAC LLI structure
+*/
+struct nx_dmac_lli_t {
+	uint32_t						src_addr;					/* Source physical address */
+	uint32_t						dst_addr;					/* Source physical address */
+	uint32_t						next_lli;					/* Next LLI address */
+	uint32_t						ctrl;							/* Control word for transfer */
+};
+
+/**
+* DMAC channel structure
+*/
+struct nx_dmac_chan_t {
+ 	int                 chanid;           /* channel ID */
+	int									busy;							/* In use */
+ 	int								  chan_status;      /* DMAC channel status */
+	struct nx_dmac_lli_t	*lli_ptr;				/* LLI ptr for channel */
+	struct nx_dmac_lli_t	*lli_ptr_unal;	/* Unaligned LLI ptr for channel */
+};
+
+/**
+* DMAC device structure
+*/
+struct nx_dmac_t {
+  void __iomem        		*dmac_base; 	/* DMAC base address */
+	int											num_chans;		/* # of supported channels */
+	int											num_ahb_mas;	/* # of AHB masters */
+	int											num_reqs;			/* # of requestors */
+	struct	nx_dmac_chan_t	*chans;				/* Channel structure */
+};
+
+/* DMAC device structure */
+static struct nx_dmac_t	*nx_dmac=NULL;
+
+
+/**
+* nx_dmac_init - DMAC initialisation function
+*
+* Initialises the DMAC module
+*/
+int nx_dmac_init(void)
+{
+	int	i, ret = 0;
+	uint32_t	per_id3;
+	int	num_chans;
+	struct nx_dmac_chan_t *chan;
+
+	/* Allocate memory for nand control structure */
+	nx_dmac = (struct nx_dmac_t *)kzalloc(sizeof(struct nx_dmac_t), GFP_KERNEL);
+	if (!nx_dmac) {
+		printk(KERN_ERR "nx_dmac: DMAC dev memory alloc \r\n");
+		return -ENOMEM;
+	}
+
+	/* IO remap controller base */
+#ifdef CONFIG_PNX84XX
+	nx_dmac->dmac_base =(void *)  PNX8XXX_DMAC_BASE;
+#else
+	nx_dmac->dmac_base =(void __iomem *) KSEG1ADDR( PNX8XXX_DMAC_BASE );
+#endif
+	/* Get HW info */
+	per_id3 = readl(nx_dmac->dmac_base + NX_DMAC_PERI_ID3);
+
+	/* # of channels */
+	num_chans = per_id3 & 0x7;
+	nx_dmac->num_chans = (0x2 << num_chans);
+
+	/* # of AHB masters */
+	if(per_id3 & 0x4) {
+		nx_dmac->num_ahb_mas = 2;
+	}
+	else {
+		nx_dmac->num_ahb_mas = 1;
+	}
+
+	/* # of requestors */
+	if(per_id3 & 0x80) {
+		nx_dmac->num_reqs = 32;
+	}
+	else {
+		nx_dmac->num_reqs = 16;
+	}
+
+	/* Allocate memory for channels */
+	nx_dmac->chans = kmalloc(sizeof(struct nx_dmac_chan_t) *
+			nx_dmac->num_chans, GFP_KERNEL);
+	if(!nx_dmac->chans) {
+		printk(KERN_ERR "nx_dmac: DMAC chan mem alloc failure \r\n");
+		ret = -ENOMEM;
+		goto out1_free;
+	}
+
+	/*Initialise channel */
+	for(i=0; i < nx_dmac->num_chans; i++) {
+		chan = &nx_dmac->chans[i];
+		chan->chanid = i;
+		chan->busy = 0;
+		chan->lli_ptr = NULL;
+		chan->chan_status = 0;
+	}
+#ifdef DEBUG
+	printk(KERN_INFO "nx_dmac: Registered with %d channels \r\n", nx_dmac->num_chans);
+#endif
+	return 0;
+
+out1_free:
+	kfree(nx_dmac);
+
+	return ret;
+}
+
+/**
+* nx_dmac_tfr - DMAC transfer function
+* @tfr: DMAC transfer request structure
+*
+* Start the DMAC transfers
+*/
+int	nx_dmac_tfr(nx_dmac_tfr_t *tfr)
+{
+	int i, j, chanid;
+	uint32_t	ctrl_wrd, chan_config;
+	struct nx_dmac_chan_t *chan;
+	void __iomem	*chan_start;
+
+	/* Get free channel */
+	i=0;
+	while(i < nx_dmac->num_chans) {
+		if(!(nx_dmac->chans[i].busy)) {
+			nx_dmac->chans[i].busy = 1;
+			break;
+		}
+		i++;
+	}
+
+	/* Return if channel not free */
+	if(i >= nx_dmac->num_chans) {
+		printk(KERN_ERR "nx_dmac: DMAC no free chan \r\n");
+		return -EBUSY;
+	}
+
+	/* Acquire channel */
+	chan = &nx_dmac->chans[i];
+	chanid = chan->chanid;
+
+	/* Allocate DMAC LLI array */
+	chan->lli_ptr_unal = kmalloc( (sizeof(struct nx_dmac_lli_t) + (CACHE_LINE_SIZE * 2)) *
+			tfr->num_reqs, GFP_KERNEL);
+	if(!chan->lli_ptr_unal) {
+		printk(KERN_ERR "nx_dmac: DMAC LLI mem failure \r\n");
+		nx_dmac->chans[i].busy = 0;
+		return -ENOMEM;
+	}
+
+	chan->lli_ptr = (struct nx_dmac_lli_t *)((((unsigned long)(chan->lli_ptr_unal + CACHE_LINE_SIZE - 1))& (~CACHE_LINE_MASK)));
+#ifdef DEBUG
+	printf("chan->lli_ptr_unal 0x%x chan->lli_ptr 0x%x \r\n", chan->lli_ptr_unal, chan->lli_ptr);
+#endif
+	/* Initialise lli array */
+	for(j=0; j < tfr->num_reqs; j++) {
+		chan->lli_ptr[j].src_addr = tfr->req[j].src_addr;
+		chan->lli_ptr[j].dst_addr = tfr->req[j].dst_addr;
+
+		ctrl_wrd = 0;
+		if(j == (tfr->num_reqs - 1)) {
+			chan->lli_ptr[j].next_lli = (uint32_t) NULL;
+			ctrl_wrd |= (1 << 31);										/* Enable TC interrupt */
+		}
+		else {
+			chan->lli_ptr[j].next_lli = (uint32_t) (virt_to_phys) (&(chan->lli_ptr[j+1]));
+		}
+
+		/* Control */
+		ctrl_wrd |= tfr->req[j].tfr_size & 0xFFF; /* Transfer size */
+		ctrl_wrd |= (tfr->req[j].src_brst << 12); /* Source burst size */
+		ctrl_wrd |= (tfr->req[j].dst_brst << 15); /* Destination burst size */
+		ctrl_wrd |= (tfr->req[j].src_width << 18); /* Source width */
+		ctrl_wrd |= (tfr->req[j].dst_width << 21); /* Destination width */
+		ctrl_wrd |= (tfr->req[j].src_inc << 26);	/* Source increment */
+		ctrl_wrd |= (tfr->req[j].dst_inc << 27);	/* Destination increment */
+		ctrl_wrd |= (tfr->req[j].src_ahb << 24); 	/* Source AHB */
+		ctrl_wrd |= (tfr->req[j].dst_ahb << 25); 	/* Destination AHB */
+		chan->lli_ptr[j].ctrl = ctrl_wrd;
+#ifdef DEBUG
+		printk(KERN_INFO "src 0x%x dst 0x%x next 0x%x ctrl 0x%x \r\n", chan->lli_ptr[j].src_addr,
+			chan->lli_ptr[j].dst_addr, chan->lli_ptr[j].next_lli, chan->lli_ptr[j].ctrl);
+#endif
+	}
+
+	/* Write the first LLI to HW */
+	chan_start = nx_dmac->dmac_base + (NX_DMAC_CHAN0_SRC + (NX_DMAC_CHAN_OFF * chanid));
+
+	/* Enable DMA HW, AHB mast1, AHB mast2 to little endian */
+	writel(0x1, nx_dmac->dmac_base + NX_DMAC_CONFIG);
+
+	writel(chan->lli_ptr[0].src_addr, chan_start);
+	writel(chan->lli_ptr[0].dst_addr, chan_start+0x4);
+	writel(chan->lli_ptr[0].next_lli, chan_start+0x8);
+	writel(chan->lli_ptr[0].ctrl, chan_start+0xC);
+
+	/* Clear the interrupts */
+	writel((1<<chanid), nx_dmac->dmac_base + NX_DMAC_INT_TC_CLR);
+	writel((1<<chanid), nx_dmac->dmac_base + NX_DMAC_INT_ERR_CLR);
+
+	/* Configure the channel */
+	chan_config = 0;
+	chan_config |= (tfr->req[0].src_per << 1);	/* Source peripheral number */
+	chan_config |= (tfr->req[0].dst_per << 6);	/* Destination peripheral number */
+	chan_config |= (tfr->req[0].flowctl << 11);	/* Flow control */
+	chan_config |= (1 << 15);										/* Unmask TC interrupt */
+	chan_config |= (1 << 14);										/* Unmask Error interrupt */
+	chan_config |= 0x1;													/* Enable channel */
+
+	chan->chan_status = 0xABCD;
+
+	/* Write chan config to HW */
+	writel(chan_config, chan_start + 0x10);
+
+	return chan->chanid;
+}
+
+/**
+* nx_dmac_complete - DMAC transfer complete function
+* @chanid: Channel id
+*
+* Complete the DMAC transfers
+*/
+int	nx_dmac_tfr_comp(int chanid)
+{
+	int res;
+	struct nx_dmac_chan_t *chan;
+	void __iomem	*chan_start;
+	volatile uint32_t	int_status, tc_stat, err_stat;
+	DBG_PRINT(("IP1902_dmac_tfr_comp  enter \r\n"));
+
+	/* Get the free channel */
+	chan = &nx_dmac->chans[chanid];
+	chan->chan_status = 0;
+
+	if(!(chan->busy)) {
+		printk(KERN_ERR "nx_dmac: DMAC tfr complete \r\n");
+		chan->chan_status = -EIO;
+	}
+	else {
+		/* Get the channel start */
+		chan_start = nx_dmac->dmac_base + (NX_DMAC_CHAN0_SRC + (NX_DMAC_CHAN_OFF * chanid));
+
+		/* Wait DMAC interrupt */
+		set_timeout(PNX8XXX_TIMEOUT);
+		int_status = readl(nx_dmac->dmac_base + NX_DMAC_INT_STATUS);
+		DBG_PRINT(("IP1902_DMAC_INT_STATUS 0x%x \r\n", int_status));
+		while (!(int_status & (1 << chanid)) && (chan->chan_status == 0 )) {
+			if(did_timeout()) {
+				printk("DMAC Transfer TIMEOUT \r\n");
+				chan->chan_status = -EIO;
+			}
+
+			int_status = readl(nx_dmac->dmac_base + NX_DMAC_INT_STATUS);
+		}
+
+		/* Check & Clear TC interrupt */
+		tc_stat = readl(nx_dmac->dmac_base + NX_DMAC_INT_TC_STATUS);
+		if(tc_stat & (1<<chanid) && (chan->chan_status == 0 )) {
+			writel((1<<chanid), nx_dmac->dmac_base + NX_DMAC_INT_TC_CLR);
+			chan->chan_status = 0;
+		}
+
+		/* Check & Clear Error interrupt */
+		err_stat = readl(nx_dmac->dmac_base + NX_DMAC_INT_ERR_STATUS);
+		if(err_stat & (1<<chanid) && (chan->chan_status == 0 )) {
+			writel((1<<chanid), nx_dmac->dmac_base + NX_DMAC_INT_ERR_CLR);
+			chan->chan_status = -EIO;
+		}
+	}
+	/* status */
+	res = chan->chan_status;
+
+	/* Disable channel */
+	writel(0x0, chan_start + 0x10);
+
+	/* Disable DMA HW, AHB mast1, AHB mast2 to little endian */
+	writel(0x0, nx_dmac->dmac_base + NX_DMAC_CONFIG);
+
+	/* Free memory */
+	kfree(chan->lli_ptr_unal);
+
+	/* Free channel */
+	chan->busy = 0;
+	DBG_PRINT(("IP1902_dmac_tfr_comp leave rc: 0x%x \r\n", res));
+	return res;
+}
+
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 3ca73e3..8b904d5 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -33,12 +33,11 @@
 
 /* The DEBUG define must be before common to enable debugging */
 /* #define DEBUG	*/
-
+#define DEBUG 10
 #include <common.h>
 #include <asm/processor.h>
 #include <asm/io.h>
 #include <asm/byteorder.h>
-#include <environment.h>
 
 /*
  * This file implements a Common Flash Interface (CFI) driver for
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 89ccec2..4e14a37 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -32,6 +32,8 @@ COBJS-y += nand_bbt.o
 COBJS-y += nand_ecc.o
 COBJS-y += nand_ids.o
 COBJS-y += nand_util.o
+COBJS-$(CONFIG_NAND_NXP_IPA051) += nand_nxp_ipa051.o
+COBJS-$(CONFIG_NAND_NXP_2070) += nx_nand_ip2070.o
 
 COBJS-$(CONFIG_NAND_ATMEL) += atmel_nand.o
 COBJS-$(CONFIG_DRIVER_NAND_BFIN) += bfin_nand.o
diff --git a/drivers/mtd/nand/nand.c b/drivers/mtd/nand/nand.c
index 9065fa9..0f3de4d 100644
--- a/drivers/mtd/nand/nand.c
+++ b/drivers/mtd/nand/nand.c
@@ -22,14 +22,15 @@
  */
 
 #include <common.h>
+
+#if defined(CONFIG_CMD_NAND)
+
 #include <nand.h>
 
 #ifndef CONFIG_SYS_NAND_BASE_LIST
 #define CONFIG_SYS_NAND_BASE_LIST { CONFIG_SYS_NAND_BASE }
 #endif
 
-DECLARE_GLOBAL_DATA_PTR;
-
 int nand_curr_device = -1;
 nand_info_t nand_info[CONFIG_SYS_MAX_NAND_DEVICE];
 
@@ -39,24 +40,26 @@ static ulong base_address[CONFIG_SYS_MAX_NAND_DEVICE] = CONFIG_SYS_NAND_BASE_LIS
 static const char default_nand_name[] = "nand";
 static __attribute__((unused)) char dev_name[CONFIG_SYS_MAX_NAND_DEVICE][8];
 
+extern int board_nand_init(struct nand_chip *nand);
+
 static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
 			   ulong base_addr)
 {
+	DECLARE_GLOBAL_DATA_PTR;
 	int maxchips = CONFIG_SYS_NAND_MAX_CHIPS;
 	int __attribute__((unused)) i = 0;
 
 	if (maxchips < 1)
 		maxchips = 1;
 	mtd->priv = nand;
-
 	nand->IO_ADDR_R = nand->IO_ADDR_W = (void  __iomem *)base_addr;
+
 	if (board_nand_init(nand) == 0) {
 		if (nand_scan(mtd, maxchips) == 0) {
 			if (!mtd->name)
 				mtd->name = (char *)default_nand_name;
 			else
 				mtd->name += gd->reloc_off;
-
 #ifdef CONFIG_MTD_DEVICE
 			/*
 			 * Add MTD device so that we can reference it later
@@ -72,7 +75,6 @@ static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
 		mtd->name = NULL;
 		mtd->size = 0;
 	}
-
 }
 
 void nand_init(void)
@@ -94,3 +96,5 @@ void nand_init(void)
 	board_nand_select_device(nand_info[nand_curr_device].priv, nand_curr_device);
 #endif
 }
+
+#endif
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 360b070..cd91e58 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -59,7 +59,7 @@
 #include <common.h>
 
 #define ENOTSUPP	524	/* Operation is not supported */
-
+//#if defined(CONFIG_CMD_NAND) && !defined(CONFIG_NAND_LEGACY)
 #include <malloc.h>
 #include <watchdog.h>
 #include <linux/err.h>
@@ -79,6 +79,7 @@
 #include <jffs2/jffs2.h>
 #endif
 
+#include <nxp_pcixio_ipa051.h>
 /*
  * CONFIG_SYS_NAND_RESET_CNT is used as a timeout mechanism when resetting
  * a flash.  NAND flash is initialized prior to interrupts so standard timers
@@ -137,10 +138,8 @@ static struct nand_ecclayout nand_oob_128 = {
 
 static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
 			   int new_state);
-
 static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 			     struct mtd_oob_ops *ops);
-
 static int nand_wait(struct mtd_info *mtd, struct nand_chip *this);
 
 /*
@@ -152,6 +151,23 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *this);
 DEFINE_LED_TRIGGER(nand_led_trigger);
 #endif
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+int nand_check_block(struct mtd_info *mtd, unsigned long offset);
+static void   nand_set_offset(loff_t offset);
+static loff_t nand_get_offset(void);
+
+extern int do_nand_read_page_raw (struct mtd_info *mtd, size_t offset, void* data);
+extern int do_nand_cache_read_page_raw (struct mtd_info *mtd, size_t offset, void* data);
+extern int do_nand_write_page_raw (struct mtd_info* mtd, size_t offset, void* data);
+
+#undef SHOW_PAGE_INFO
+#ifdef SHOW_PAGE_INFO
+static void show_page(struct mtd_info *mtd, uchar *data);
+#else
+#define show_page(a,b)
+#endif
+#endif
+
 /**
  * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
@@ -382,6 +398,10 @@ static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 		chip->select_chip(mtd, chipnr);
 	}
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+	res = nand_check_block(mtd, ofs);
+
+#else
 	if (chip->options & NAND_BUSWIDTH_16) {
 		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos & 0xFE,
 			      page);
@@ -395,6 +415,7 @@ static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 		if (chip->read_byte(mtd) != 0xff)
 			res = 1;
 	}
+#endif
 
 	if (getchip)
 		nand_release_device(mtd);
@@ -453,10 +474,28 @@ static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
  */
 static int nand_check_wp(struct mtd_info *mtd)
 {
+#if defined(CONFIG_NAND_NXP_IPA051)
+	unsigned long nandStatus;
+	int           ret = -1;
+
+	/* Check nand status */
+	ret = nand_read_status (mtd, &nandStatus);
+
+	if( (nandStatus & NAND_STATUS_WP) == 0 ) {
+		printf( "\nError: NAND device is write protected\n" );
+		ret = -3;
+	} else if( (nandStatus & NAND_STATUS_FAIL) != 0 ) {
+		printf( "\nError: NAND device reported an error (status = 0x%.8lX)\n", nandStatus );
+		ret = -2;
+	}
+	return (ret);
+#else
 	struct nand_chip *chip = mtd->priv;
+
 	/* Check the WP bit */
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
 	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
+	#endif
 }
 
 /**
@@ -479,8 +518,9 @@ static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
 		chip->scan_bbt(mtd);
 	}
 
-	if (!chip->bbt)
+	if (!chip->bbt) {
 		return chip->block_bad(mtd, ofs, getchip);
+	}
 
 	/* Return info from the table */
 	return nand_isbad_bbt(mtd, ofs, allowbbt);
@@ -897,9 +937,21 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *this)
 static int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
 			      uint8_t *buf)
 {
+#if defined(CONFIG_NAND_NXP_IPA051)
+	loff_t offset = nand_get_offset();
+	int ret = -1;
+
+	if (NAND_CANCACHEDREAD(chip)) {
+		ret = do_nand_cache_read_page_raw (mtd, offset, buf);
+	} else {
+		ret = do_nand_read_page_raw (mtd, offset, buf);
+	}
+	return ret;
+#else
 	chip->read_buf(mtd, buf, mtd->writesize);
 	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 	return 0;
+#endif
 }
 
 /**
@@ -915,18 +967,36 @@ static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
 	int eccbytes = chip->ecc.bytes;
 	int eccsteps = chip->ecc.steps;
 	uint8_t *p = buf;
+#if defined(CONFIG_NAND_NXP_IPA051)
+	uint8_t *poob = NULL;
+#endif
 	uint8_t *ecc_calc = chip->buffers->ecccalc;
 	uint8_t *ecc_code = chip->buffers->ecccode;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+	if ( chip->ecc.read_page_raw(mtd, chip, buf) != 0)
+		return -1;
+#else
 	chip->ecc.read_page_raw(mtd, chip, buf);
+#endif
+
+#if defined(CONFIG_NAND_NXP_IPA051)
+	/* read_page_raw: put oob data right after page data.
+	   oob_poi is not guaranteed to be after buf. */
+	poob = p + mtd->writesize;
+#endif
 
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
 		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+	for (i = 0; i < chip->ecc.total; i++)
+		ecc_code[i] = poob[eccpos[i]];
+#else
 	for (i = 0; i < chip->ecc.total; i++)
 		ecc_code[i] = chip->oob_poi[eccpos[i]];
-
+#endif
 	eccsteps = chip->ecc.steps;
 	p = buf;
 
@@ -969,12 +1039,26 @@ static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip, uint3
 	eccfrag_len = num_steps * chip->ecc.bytes;
 
 	data_col_addr = start_step * chip->ecc.size;
+
+#if defined(CONFIG_NAND_NXP_IPA051)
+	{
+		int ret;
+
+		mydebug("***current offset:%x, page:%x\n",
+			nand_get_offset(), nand_get_offset() >> chip->page_shift);
+		ret = chip->ecc.read_page_raw(mtd, chip, bufpoi);
+		if (ret != 0)
+			return ret;
+		p = bufpoi + data_col_addr;
+	}
+#else
 	/* If we read not a page aligned data */
 	if (data_col_addr != 0)
 		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);
 
 	p = bufpoi + data_col_addr;
 	chip->read_buf(mtd, p, datafrag_len);
+#endif
 
 	/* Calculate  ECC */
 	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
@@ -991,8 +1075,12 @@ static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip, uint3
 		}
 	}
 	if (gaps) {
+#if defined(CONFIG_NAND_NXP_IPA051)
+		printf("Warning: nand_read_subpage() gaps(%d) is not 0!\n", gaps);
+#else
 		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);
 		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+#endif
 	} else {
 		/* send the command to read the particular ecc bytes */
 		/* take care about buswidth alignment in read_buf */
@@ -1003,8 +1091,12 @@ static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip, uint3
 		if (eccpos[(start_step + num_steps) * chip->ecc.bytes] & (busw - 1))
 			aligned_len++;
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+	//YW: done in read_page_raw()
+#else
 		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize + aligned_pos, -1);
 		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
+#endif
 	}
 
 	for (i = 0; i < eccfrag_len; i++)
@@ -1132,7 +1224,6 @@ static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
 				  struct mtd_oob_ops *ops, size_t len)
 {
 	switch(ops->mode) {
-
 	case MTD_OOB_PLACE:
 	case MTD_OOB_RAW:
 		memcpy(oob, chip->oob_poi + ops->ooboffs, len);
@@ -1212,18 +1303,24 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 		if (realpage != chip->pagebuf || oob) {
 			bufpoi = aligned ? buf : chip->buffers->databuf;
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+			//YW: we need to tell IPA051 the nand offset
+			nand_set_offset(page << chip->page_shift);
+#else
 			if (likely(sndcmd)) {
 				chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
 				sndcmd = 0;
 			}
-
+#endif
 			/* Now read the page into the buffer */
-			if (unlikely(ops->mode == MTD_OOB_RAW))
+			if (unlikely(ops->mode == MTD_OOB_RAW)) {
 				ret = chip->ecc.read_page_raw(mtd, chip, bufpoi);
-			else if (!aligned && NAND_SUBPAGE_READ(chip) && !oob)
+			}
+			else if (!aligned && NAND_SUBPAGE_READ(chip) && !oob) {
 				ret = chip->ecc.read_subpage(mtd, chip, col, bytes, bufpoi);
-			else
+			} else {
 				ret = chip->ecc.read_page(mtd, chip, bufpoi);
+			}
 			if (ret < 0)
 				break;
 
@@ -1246,11 +1343,18 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 							oob, ops, toread);
 						oobreadlen -= toread;
 					}
-				} else
-					buf = nand_transfer_oob(chip,
-						buf, ops, mtd->oobsize);
+				}
+
+//YW: called by nand_dump. oob is appended to data. No transfer is needed.
+#if !defined(CONFIG_NAND_NXP_IPA051)
+				else {
+					buf = nand_transfer_oob(chip, buf, ops, mtd->oobsize);
+				}
+#endif
 			}
 
+//YW: done in reading data already
+#if !defined(CONFIG_NAND_NXP_IPA051)
 			if (!(chip->options & NAND_NO_READRDY)) {
 				/*
 				 * Apply delay or wait for ready/busy pin. Do
@@ -1264,6 +1368,7 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 				else
 					nand_wait_ready(mtd);
 			}
+#endif
 		} else {
 			memcpy(buf, chip->buffers->databuf + col, bytes);
 			buf += bytes;
@@ -1298,6 +1403,12 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 	if (oob)
 		ops->oobretlen = ops->ooblen - oobreadlen;
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+	if (NAND_CANCACHEDREAD(chip)) {
+		nand_stop_cache_read(mtd);
+	}
+#endif
+
 	if (ret)
 		return ret;
 
@@ -1362,6 +1473,32 @@ static int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
 	return sndcmd;
 }
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+/**
+ * nand_read_oob_std - [REPLACABLE] the most common OOB data read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to read
+ * @sndcmd:	flag whether to issue read command or not
+ * return:  error code
+ */
+static int nand_read_oob_nxp(struct mtd_info *mtd, struct nand_chip *chip,
+			     int page, int sndcmd)
+{
+	int col;
+	int result;
+
+	/* Fetch the requested data */
+	col  = (page<<chip->page_shift) & ((1 << chip->page_shift) - 1) ;
+	col |= 1 << chip->page_shift ;
+	mydebug("page=%x col=%x\n", page, col);
+
+	result = nand_dma_read(mtd, page, col, mtd->oobsize, chip->oob_poi, 0) ;
+	mydebug("result=%d\n", result);
+	return result;
+}
+#endif
+
 /**
  * nand_read_oob_syndrome - [REPLACABLE] OOB data read function for HW ECC
  *			    with syndromes
@@ -1424,6 +1561,40 @@ static int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
 	return status & NAND_STATUS_FAIL ? -EIO : 0;
 }
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+ /**
+  * nand_write_oob_nxp - [REPLACABLE] the most common OOB data write function
+  * @mtd:	 mtd info structure
+  * @chip:	 nand chip info structure
+  * @page:	 page number to write
+  * return:  error code
+  */
+static int nand_write_oob_nxp(struct mtd_info *mtd, struct nand_chip *chip, int page)
+{
+	int col;
+	int result;
+
+	/* Fetch the requested data */
+	col  = (page<<chip->page_shift) & ((1 << chip->page_shift) - 1) ;
+	col |= 1 << chip->page_shift ;
+	mydebug("page=%x col=%x... to write: \n", page, col);
+
+	{
+		int i;
+		for (i=0; i<0x20; i++) {
+			printf("%2x ", chip->oob_poi[i]);
+
+			if ( ((i+1)%0x10) ==0 )
+				puts("\n");
+		}
+	}
+
+	result = nand_dma_write(mtd, page, col, mtd->oobsize, chip->oob_poi) ;
+	mydebug("result=%d\n", result);
+	return result;
+}
+#endif
+
 /**
  * nand_write_oob_syndrome - [REPLACABLE] OOB data write function for HW ECC
  *			     with syndrome - only for large page flash !
@@ -1491,8 +1662,7 @@ static int nand_write_oob_syndrome(struct mtd_info *mtd,
  *
  * NAND read out-of-band data from the spare area
  */
-static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
-			    struct mtd_oob_ops *ops)
+static int nand_do_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
 	int page, realpage, chipnr, sndcmd = 1;
 	struct nand_chip *chip = mtd->priv;
@@ -1532,11 +1702,18 @@ static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
 	page = realpage & chip->pagemask;
 
 	while(1) {
+#if defined(CONFIG_NAND_NXP_IPA051)
+		if ( chip->ecc.read_oob(mtd, chip, page, sndcmd) != 0 )
+			return -2;
+#else
 		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);
+#endif
 
 		len = min(len, readlen);
 		buf = nand_transfer_oob(chip, buf, ops, len);
 
+//YW: we are sure nand is ready by now
+#if !defined(CONFIG_NAND_NXP_IPA051)
 		if (!(chip->options & NAND_NO_READRDY)) {
 			/*
 			 * Apply delay or wait for ready/busy pin. Do this
@@ -1549,7 +1726,7 @@ static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
 			else
 				nand_wait_ready(mtd);
 		}
-
+#endif
 		readlen -= len;
 		if (!readlen)
 			break;
@@ -1584,8 +1761,7 @@ static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
  *
  * NAND read data and/or out-of-band data
  */
-static int nand_read_oob(struct mtd_info *mtd, loff_t from,
-			 struct mtd_oob_ops *ops)
+static int nand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
 	struct nand_chip *chip = mtd->priv;
 	int ret = -ENOTSUPP;
@@ -1631,8 +1807,13 @@ static int nand_read_oob(struct mtd_info *mtd, loff_t from,
 static void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
 				const uint8_t *buf)
 {
+#if defined(CONFIG_NAND_NXP_IPA051)
+	loff_t offset = nand_get_offset();
+	do_nand_write_page_raw (mtd, offset, (void *)buf);
+#else
 	chip->write_buf(mtd, buf, mtd->writesize);
 	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+#endif
 }
 
 /**
@@ -1746,14 +1927,17 @@ static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 			   const uint8_t *buf, int page, int cached, int raw)
 {
 	int status;
-
+#if !defined(CONFIG_NAND_NXP_IPA051)
 	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+#endif
 
 	if (unlikely(raw))
 		chip->ecc.write_page_raw(mtd, chip, buf);
 	else
 		chip->ecc.write_page(mtd, chip, buf);
 
+//YW: no cache write at this moment
+#if 0
 	/*
 	 * Cached progamming disabled for now, Not sure if its worth the
 	 * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
@@ -1778,7 +1962,9 @@ static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 		chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
 		status = chip->waitfunc(mtd, chip);
 	}
-
+#endif
+// Verification has been done in nand_write_page_raw().
+#if !defined(CONFIG_NAND_NXP_IPA051)
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
 	/* Send command to read back the data */
 	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
@@ -1786,6 +1972,7 @@ static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 	if (chip->verify_buf(mtd, buf, mtd->writesize))
 		return -EIO;
 #endif
+#endif
 	return 0;
 }
 
@@ -1878,11 +2065,14 @@ static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
 	chipnr = (int)(to >> chip->chip_shift);
 	chip->select_chip(mtd, chipnr);
 
+//YW: will be done in do_nand_write_page_raw()
+#if !defined(CONFIG_NAND_NXP_IPA051)
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd)) {
 		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
 		return -EIO;
 	}
+#endif
 
 	realpage = (int)(to >> chip->page_shift);
 	page = realpage & chip->pagemask;
@@ -1911,10 +2101,24 @@ static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
 			memcpy(&chip->buffers->databuf[column], buf, bytes);
 			wbuf = chip->buffers->databuf;
 		}
+#if defined(CONFIG_NAND_NXP_IPA051)
+		else {
+			//YW: ipa051 writes data and oob in one run...
+			//    need to put them together.
+			cached = 0;
+			chip->pagebuf = -1;
+			memcpy(&chip->buffers->databuf, buf, mtd->writesize);
+			wbuf = chip->buffers->databuf;
+		}
+#endif
 
-		if (unlikely(oob))
+		if (unlikely(oob)) {
 			oob = nand_fill_oob(chip, oob, ops);
+		}
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+		nand_set_offset(page << chip->page_shift);
+#endif
 		ret = chip->write_page(mtd, chip, wbuf, page, cached,
 				       (ops->mode == MTD_OOB_RAW));
 		if (ret)
@@ -2031,6 +2235,8 @@ static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 	/* Shift to get page */
 	page = (int)(to >> chip->page_shift);
 
+//YW: do_nand_write_page_raw will check WP
+#if !defined(CONFIG_NAND_NXP_IPA051)
 	/*
 	 * Reset the chip. Some chips (like the Toshiba TC5832DC found in one
 	 * of my DiskOnChip 2000 test units) will clear the whole data page too
@@ -2042,6 +2248,7 @@ static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd))
 		return -EROFS;
+#endif
 
 	/* Invalidate the page cache, if we write to the cached page */
 	if (page == chip->pagebuf)
@@ -2146,7 +2353,26 @@ static void multi_erase_cmd(struct mtd_info *mtd, int page)
  */
 static int nand_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
+#if defined(CONFIG_NAND_NXP_IPA051)
+	int		ret = 0;
+
+	//Always called with erasing ONE block
+	/* Erase the block */
+	if (nand_erase_block(mtd, instr->addr) < 0) {
+		myinfo("nand_erase_block fails\n");
+		return -1;
+	}
+
+	if (nand_check_wp(mtd)) {
+		ret = -1;
+	}
+
+	//Page cache flag is not updated!!!!
+	return ret;
+#else
 	return nand_erase_nand(mtd, instr, 0);
+#endif
+
 }
 
 #define BBT_PAGE_MASK	0xffffff3f
@@ -2163,7 +2389,7 @@ int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 {
 	int page, len, status, pages_per_block, ret, chipnr;
 	struct nand_chip *chip = mtd->priv;
-	int rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS]={0};
+	int rewrite_bbt[NAND_MAX_CHIPS]={0};
 	unsigned int bbt_masked_page = 0xffffffff;
 
 	MTDDEBUG (MTD_DEBUG_LEVEL3, "nand_erase: start = 0x%08x, len = %i\n",
@@ -2440,8 +2666,11 @@ static void nand_set_defaults(struct nand_chip *chip, int busw)
 		chip->read_buf = busw ? nand_read_buf16 : nand_read_buf;
 	if (!chip->verify_buf)
 		chip->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
+
+#if !defined(CONFIG_NAND_NXP_IPA051)
 	if (!chip->scan_bbt)
 		chip->scan_bbt = nand_default_bbt;
+#endif
 
 	if (!chip->controller) {
 		chip->controller = &chip->hwcontrol;
@@ -2463,12 +2692,15 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 						  int busw, int *maf_id)
 {
 	struct nand_flash_dev *type = NULL;
+	//int i, maf_idx;
 	int i, dev_id, maf_idx;
-	int tmp_id, tmp_manf;
+	int tmp_id, tmp_manf, tmp_word3, tmp_word4;
 
 	/* Select the device */
 	chip->select_chip(mtd, 0);
 
+	/* Have got ids in board_nand_init() */
+#if !defined(CONFIG_NAND_NXP_IPA051)
 	/*
 	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
 	 * after power-up
@@ -2481,13 +2713,15 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	/* Read manufacturer and device IDs */
 	*maf_id = chip->read_byte(mtd);
 	dev_id = chip->read_byte(mtd);
+	tmp_word3 = chip->read_byte(mtd);
+	tmp_word4 = chip->read_byte(mtd);
 
 	/* Try again to make sure, as some systems the bus-hold or other
 	 * interface concerns can cause random data which looks like a
 	 * possibly credible NAND flash to appear. If the two results do
 	 * not match, ignore the device completely.
 	 */
-
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
@@ -2501,10 +2735,19 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		       *maf_id, dev_id, tmp_manf, tmp_id);
 		return ERR_PTR(-ENODEV);
 	}
+#endif
+
+#if defined(CONFIG_NAND_NXP_IPA051)
+	*maf_id = chip->mafid;
+#endif
 
 	/* Lookup the flash id */
 	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+#if defined(CONFIG_NAND_NXP_IPA051)
+		if (chip->devid == nand_flash_ids[i].id) {
+#else
 		if (dev_id == nand_flash_ids[i].id) {
+#endif
 			type =  &nand_flash_ids[i];
 			break;
 		}
@@ -2520,12 +2763,19 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 
 	/* Newer devices have all the information in additional id bytes */
 	if (!type->pagesize) {
+#if defined(CONFIG_NAND_NXP_IPA051)
+		int extid = chip->extid;
+#else
 		int extid;
+#endif
+
+#if !defined(CONFIG_NAND_NXP_IPA051)
 		/* The 3rd id byte holds MLC / multichip data */
 		chip->cellinfo = chip->read_byte(mtd);
 		/* The 4th id byte is the important one */
 		extid = chip->read_byte(mtd);
 		/* Calc pagesize */
+#endif
 		mtd->writesize = 1024 << (extid & 0x3);
 		extid >>= 2;
 		/* Calc oobsize */
@@ -2549,18 +2799,34 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
+#if defined(CONFIG_NAND_NXP_IPA051)
+		if (nand_manuf_ids[maf_idx].id == chip->mafid)
+#else
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
+#endif
 			break;
 	}
 
+    //mydebug("erasesize = 0x%x\n", mtd->erasesize);
+    //mydebug("oobblock  = 0x%x\n", mtd->writesize);
+    //mydebug("oobsize   = 0x%x\n", mtd->oobsize);
+
 	/*
 	 * Check, if buswidth is correct. Hardware drivers should set
 	 * chip correct !
 	 */
 	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
+#if defined(CONFIG_NAND_NXP_IPA051)
+		printk(KERN_INFO "NAND device: Manufacturer ID:"
+				" 0x%02x, Chip ID: 0x%02x (%s %s)\n",
+				chip->mafid, chip->devid,
+		        nand_manuf_ids[maf_idx].name, mtd->name);
+#else
 		printk(KERN_INFO "NAND device: Manufacturer ID:"
-		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
-		       dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
+				" 0x%02x, Chip ID: 0x%02x (%s %s)\n",
+				*maf_id, dev_id,
+		        nand_manuf_ids[maf_idx].name, mtd->name);
+#endif
 		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
 		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
 		       busw ? 16 : 8);
@@ -2580,6 +2846,33 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	chip->badblockpos = mtd->writesize > 512 ?
 		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+	switch (mtd->oobsize) {
+		case 8: /* Tiny (256 + 8 bytes per page) */
+			chip->badblockpos2 = NAND_NOOB_BADBPOS;
+			break;
+		case 16:/* Small (512 + 16 bytes per page) */
+			if ((chip->mafid== NAND_MFR_TOSHIBA) || (chip->mafid== NAND_MFR_SAMSUNG))
+				chip->badblockpos2 = NAND_JFFS2_OOB_BADBPOS2;
+			else
+				chip->badblockpos2 = NAND_NOOB_BADBPOS;
+			break;
+		case 64: /* Large (2048 + 64 bytes per page) */
+			if ( (chip->devid==0xF1) && (chip->mafid==NAND_MFR_STMICRO) ) {
+				//ST LP 128MB flash: check 1st + 6th byte
+				chip->badblockpos2 = NAND_SMALL_BADBLOCK_POS;
+			} else {
+				chip->badblockpos2 = NAND_NOOB_BADBPOS;
+			}
+			break;
+		default:
+			printk (KERN_WARNING "No oob scheme defined for oobsize %d\n",
+				mtd->writesize);
+			BUG();
+			break;
+	}
+#endif
+
 	/* Get chip options, preserve non chip based options */
 	chip->options &= ~NAND_CHIPOPTIONS_MSK;
 	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
@@ -2595,6 +2888,7 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
 		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
 
+#if !defined(CONFIG_NAND_NXP_IPA051)
 	/* Check for AND chips with 4 page planes */
 	if (chip->options & NAND_4PAGE_ARRAY)
 		chip->erase_cmd = multi_erase_cmd;
@@ -2604,10 +2898,17 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	/* Do not replace user supplied command function ! */
 	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
 		chip->cmdfunc = nand_command_lp;
+#endif
 
+#if defined(CONFIG_NAND_NXP_IPA051)
+	MTDDEBUG (MTD_DEBUG_LEVEL0, "NAND device: Manufacturer ID:"
+	          " 0x%02x, Chip ID: 0x%02x (%s %s)\n", chip->mafid, chip->devid,
+	          nand_manuf_ids[maf_idx].name, type->name);
+#else
 	MTDDEBUG (MTD_DEBUG_LEVEL0, "NAND device: Manufacturer ID:"
 	          " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
 	          nand_manuf_ids[maf_idx].name, type->name);
+#endif
 
 	return type;
 }
@@ -2624,7 +2925,11 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
  */
 int nand_scan_ident(struct mtd_info *mtd, int maxchips)
 {
+#if defined(CONFIG_NAND_NXP_IPA051)
+	int i, busw, nand_maf_id = -1;
+#else
 	int i, busw, nand_maf_id;
+#endif
 	struct nand_chip *chip = mtd->priv;
 	struct nand_flash_dev *type;
 
@@ -2637,14 +2942,14 @@ int nand_scan_ident(struct mtd_info *mtd, int maxchips)
 	type = nand_get_flash_type(mtd, chip, busw, &nand_maf_id);
 
 	if (IS_ERR(type)) {
-#ifndef CONFIG_SYS_NAND_QUIET_TEST
 		printk(KERN_WARNING "No NAND device found!!!\n");
-#endif
 		chip->select_chip(mtd, -1);
 		return PTR_ERR(type);
 	}
 
 	/* Check for a chip array */
+	// maxchips is called with 1; only 1 chip avaible for now
+#if !defined(CONFIG_NAND_NXP_IPA051)
 	for (i = 1; i < maxchips; i++) {
 		chip->select_chip(mtd, i);
 		/* See comment in nand_get_flash_type for reset */
@@ -2656,6 +2961,7 @@ int nand_scan_ident(struct mtd_info *mtd, int maxchips)
 		    type->id != chip->read_byte(mtd))
 			break;
 	}
+#endif
 #ifdef DEBUG
 	if (i > 1)
 		printk(KERN_INFO "%d NAND chips detected\n", i);
@@ -2734,8 +3040,13 @@ int nand_scan_tail(struct mtd_info *mtd)
 			chip->ecc.read_page = nand_read_page_hwecc;
 		if (!chip->ecc.write_page)
 			chip->ecc.write_page = nand_write_page_hwecc;
+#if defined(CONFIG_NAND_NXP_IPA051)
+		if (!chip->ecc.read_oob)
+			chip->ecc.read_oob = nand_read_oob_nxp;
+#else
 		if (!chip->ecc.read_oob)
 			chip->ecc.read_oob = nand_read_oob_std;
+#endif
 		if (!chip->ecc.write_oob)
 			chip->ecc.write_oob = nand_write_oob_std;
 
@@ -2773,8 +3084,13 @@ int nand_scan_tail(struct mtd_info *mtd)
 		chip->ecc.read_page = nand_read_page_swecc;
 		chip->ecc.read_subpage = nand_read_subpage;
 		chip->ecc.write_page = nand_write_page_swecc;
+#if defined(CONFIG_NAND_NXP_IPA051)
+		chip->ecc.read_oob = nand_read_oob_nxp;
+		chip->ecc.write_oob = nand_write_oob_nxp;
+#else
 		chip->ecc.read_oob = nand_read_oob_std;
 		chip->ecc.write_oob = nand_write_oob_std;
+#endif
 		chip->ecc.size = 256;
 		chip->ecc.bytes = 3;
 		break;
@@ -2784,8 +3100,13 @@ int nand_scan_tail(struct mtd_info *mtd)
 		       "This is not recommended !!\n");
 		chip->ecc.read_page = nand_read_page_raw;
 		chip->ecc.write_page = nand_write_page_raw;
+#if defined(CONFIG_NAND_NXP_IPA051)
+		chip->ecc.read_oob = nand_read_oob_nxp;
+		chip->ecc.write_oob = nand_write_oob_nxp;
+#else
 		chip->ecc.read_oob = nand_read_oob_std;
 		chip->ecc.write_oob = nand_write_oob_std;
+#endif
 		chip->ecc.size = mtd->writesize;
 		chip->ecc.bytes = 0;
 		break;
@@ -2962,3 +3283,185 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Steven J. Hill <sjhill@realitydiluted.com>, Thomas Gleixner <tglx@linutronix.de>");
 MODULE_DESCRIPTION("Generic NAND flash driver code");
 #endif
+
+#if defined(CONFIG_NAND_NXP_IPA051)
+/* From nand_nxp_ipa051.c (nand_legacy) */
+/* returns 0 if block containing pos is OK:
+ *		valid erase block and
+ *		not marked bad, or no bad mark position is specified
+ * returns 1 if marked bad or otherwise invalid
+ */
+int nand_check_block(struct mtd_info *mtd, unsigned long offset)
+{
+	struct			nand_chip *nand = mtd->priv;
+	int				result;
+	unsigned long	page0 = offset & ~(mtd->erasesize - 1);
+	unsigned long	page1 = page0 + (1<<nand->page_shift);
+	union {
+		uint32_t	bb_marker32;
+		uint16_t	bb_marker16[sizeof(uint32_t)/sizeof(uint16_t)];
+		uint8_t		bb_marker8[sizeof(uint32_t)/sizeof(uint8_t)];
+	} bb_marker ;
+
+	struct mtd_oob_ops ops = {
+		.oobbuf = (u_char*)&bb_marker,
+		.ooblen = sizeof(bb_marker),
+		.mode   = MTD_OOB_RAW
+	};
+
+	/* Dirty hack to work around the 96 MiB block access problem */
+	if ((offset >= 0x06000000) && (offset < 0x06020000))
+		return 1;
+
+	if (nand->options & NAND_BUSWIDTH_16) {
+		if (nand->badblockpos >= 0) {
+			result = mtd->read_oob(mtd, (loff_t)(page0 + nand->badblockpos), &ops);
+
+			if( result != 0 ) {
+				printf("\nError reading bad block marker at 0x%.8lX", page0 + nand->badblockpos);
+				return -1;
+			}
+			if( bb_marker.bb_marker16[0] != (uint16_t)0xFFFF )
+				return 1;
+		}
+
+		if (nand->badblockpos2 >= 0) {
+			result = mtd->read_oob(mtd, (loff_t)(page0 + nand->badblockpos2), &ops);
+
+			if( result != 0 ) {
+				printf("\nError reading bad block marker at 0x%.8lX", page0 + nand->badblockpos2);
+				return -1;
+			}
+			if( bb_marker.bb_marker16[0] != (uint16_t)0xFFFF )
+				return 1;
+		}
+
+		if (nand->mafid == NAND_MFR_SAMSUNG) {
+			if (nand->badblockpos >= 0) {
+				result = mtd->read_oob(mtd, (loff_t)(page1 + nand->badblockpos), &ops);
+
+				if( result != 0) {
+					printf("\nError reading bad block marker at 0x%.8lX", page1 + nand->badblockpos);
+					return -1;
+				}
+				if( bb_marker.bb_marker16[0] != (uint16_t)0xFFFF )
+					return 1;
+			}
+
+			if (nand->badblockpos2 >= 0) {
+				result = mtd->read_oob(mtd, (loff_t)(page1 + nand->badblockpos2), &ops);
+
+				if( result != 0 ) {
+					printf("\nError reading bad block marker at 0x%.8lX", page1 + nand->badblockpos2);
+					return -1;
+				}
+				if( bb_marker.bb_marker16[0] != (uint16_t)0xFFFF )
+					return 1;
+			}
+		}
+	} else {
+		unsigned long gpxio_addr ;
+		unsigned long bb_offset ;
+
+		gpxio_addr = ROUND_DOWN(page0 + nand->badblockpos, sizeof(uint32_t)) ;
+		bb_offset  = (page0 + nand->badblockpos) - gpxio_addr;
+
+		if( nand_gpxio_read( mtd,
+				     gpxio_addr >> nand->page_shift,
+				     (gpxio_addr & ((1 << nand->page_shift) - 1)) | (1 << nand->page_shift),
+				     &bb_marker.bb_marker32 ) ) {
+			printf("\nError reading bad block marker at 0x%.8lX", page0 + nand->badblockpos);
+			return -1;
+		}
+
+		if( bb_marker.bb_marker8[bb_offset] != (uint8_t)0xFF )
+			return 1;
+
+//YW: to avoid conflict with jffs2 cleanmark....
+//    but we are not compatible with nand spec anymore.
+#if 0
+		if ( (nand->mafid == NAND_MFR_STMICRO) && (nand->devid==0xF1) ) {
+			//ST NANDD01GW3B3B LP 128MB flash: check 1st + 6th byte
+			gpxio_addr = ROUND_DOWN(page0 + nand->badblockpos2, sizeof(uint32_t)) ;
+			bb_offset  = (page0 + nand->badblockpos2) - gpxio_addr;
+
+			if( nand_gpxio_read( mtd,
+						 gpxio_addr >> nand->page_shift,
+						 (gpxio_addr & ((1 << nand->page_shift) - 1)) | (1 << nand->page_shift),
+						 &bb_marker.bb_marker32 ) ) {
+				printf("\nError reading bad block marker at 0x%.8lX", page0 + nand->badblockpos);
+				return -1;
+			}
+
+			if( bb_marker.bb_marker8[bb_offset] != (uint8_t)0xFF )
+				return 1;
+		}
+#endif
+
+		if (nand->mafid == NAND_MFR_SAMSUNG) {
+			gpxio_addr = ROUND_DOWN(page1 + nand->badblockpos, sizeof(uint32_t)) ;
+			bb_offset  = (page1 + nand->badblockpos) - gpxio_addr;
+
+			if( nand_gpxio_read( mtd,
+					     gpxio_addr >> nand->page_shift,
+					     (gpxio_addr & ((1 << nand->page_shift) - 1)) | (1 << nand->page_shift),
+					     &bb_marker.bb_marker32 ) ) {
+				printf("\nError reading bad block marker at 0x%.8lX", page1 + nand->badblockpos);
+				return -1;
+			}
+
+			if( bb_marker.bb_marker8[bb_offset] != (uint8_t)0xFF )
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static loff_t currentoffs = 0;
+static void nand_set_offset(loff_t offset) {
+	currentoffs = offset;
+}
+
+static loff_t nand_get_offset(void) {
+	return currentoffs;
+}
+
+#ifdef SHOW_PAGE_INFO
+static void show_page(struct mtd_info *mtd, uchar *data) {
+	int x, y;
+	uchar *cp=NULL;
+
+	myinfo("data......\n");
+	cp = (uchar *) data;
+	for (x=0; x<4; x++) {
+		for (y=0; y<16; y++) {
+			printf("%2x ", cp[x*16+y]);
+		}
+		puts("\n");
+	}
+
+	/*
+	cp = (uchar *) data;
+	for (x=0; x<2; x++) {
+		for (y=0; y<16; y++) {
+			printf("%c ", cp[x*16+y]);
+		}
+		puts("\n");
+	}
+	*/
+	myinfo("oob......\n");
+	cp = (uchar *)data + mtd->writesize;
+	mydebug("cp - data=%x\n", cp-(uchar *)data);
+	for (x=0; x<4; x++) {
+		for (y=0; y<16; y++) {
+			printf("%2x ", cp[x*16+y]);
+		}
+		puts("\n");
+	}
+}
+#endif
+#endif
+
+//#endif //defined(CONFIG_CMD_NAND) && !defined(CONFIG_NAND_LEGACY)
+
diff --git a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
index d68a315..c4ad9f5 100644
--- a/drivers/mtd/nand/nand_bbt.c
+++ b/drivers/mtd/nand/nand_bbt.c
@@ -348,6 +348,8 @@ static int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
 	ops.datbuf = NULL;
 	ops.mode = MTD_OOB_PLACE;
 
+	mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
+
 	for (j = 0; j < len; j++) {
 		/*
 		 * Read the full oob until read_oob is fixed to
@@ -363,6 +365,9 @@ static int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
 
 		offs += mtd->writesize;
 	}
+	
+	mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
+
 	return 0;
 }
 
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index 077c305..f297703 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -10,6 +10,9 @@
  */
 
 #include <common.h>
+
+#if defined(CONFIG_CMD_NAND) && !defined(CONFIG_NAND_LEGACY)
+
 #include <linux/mtd/nand.h>
 /*
 *	Chip ID list
@@ -82,7 +85,7 @@ struct nand_flash_dev nand_flash_ids[] = {
 
 	/* 1 Gigabit */
 	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS | NAND_CACHEDREAD | NAND_SKIP_BBTSCAN}, 
 	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
 	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
 
@@ -143,3 +146,4 @@ struct nand_manufacturers nand_manuf_ids[] = {
 	{NAND_MFR_AMD, "AMD"},
 	{0x0, "Unknown"}
 };
+#endif
diff --git a/drivers/mtd/nand/nand_nxp_ipa051.c b/drivers/mtd/nand/nand_nxp_ipa051.c
new file mode 100644
index 0000000..c985177
--- /dev/null
+++ b/drivers/mtd/nand/nand_nxp_ipa051.c
@@ -0,0 +1,266 @@
+/*
+ * Driver for NAND support, Rick Bronson
+ * borrowed heavily from:
+ * (c) 1999 Machine Vision Holdings, Inc.
+ * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
+ * PNX85xx support by Robert Delien, June 2007
+ *
+ * 22-08-2007, RDe:
+ * The local functions 'nand_read_page_raw' and 'nand_write_page_raw'
+ * always read and write whole pages. The idea behind this is that
+ * the ganularity of NAND operations is always the page size because
+ * ECC is calculated and validated over a whole pages.
+ * BUT: That is not entirely true. ECC is calculated over chunks of
+ * data of 256 bytes each. So theoretically it is possible to alter
+ * data in only one of these chucks, recaculate only the ECC codes
+ * of this specific chuck and write back both the chuck of data and
+ * the ECC code to the device, using two separate write cycles.
+ * As far as I know, this theoratical possibility isn't used
+ * anywhere in U-Boot. Implementing support for this would cost
+ * quite a performance penalty.
+ *
+ * 24-08-2007, RDe:
+ * The following things still need to be improved in this legacy
+ * NAND flash support file:
+ * 1. Bad block detection shoudn't use DMA transfers but GPXIO
+ *    cycles to read the bad-block-markers of a device. 
+ * 2. Bad block detection should determine the bad-block-marker
+ *    offset(S) according the bus-width, the device geometry and
+ *    the manufacturer of the device.
+ * 3. ECC calculation and validation should determine the offsets
+ *    of the code also according the bus-width and the device
+ *    geometry. The oob_config should be removed.
+ * 4. The NAND flash primitives should be moved to
+ *    NXP_PCIXIO_IPA051.c
+ */
+
+#include <common.h>
+#include <command.h>
+
+#ifdef CONFIG_NXP_PCIXIO_IPA051
+#if defined(CONFIG_CMD_NAND) && defined(CONFIG_NAND) &&!defined(CONFIG_NAND_LEGACY) \
+	&& defined (CONFIG_NAND_NXP_IPA051)
+
+#include <malloc.h>
+#include <watchdog.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <linux/mtd/nand.h>
+#include <jffs2/jffs2.h>
+#include <nxp_pcixio_ipa051.h>
+
+static void xio_nand_select_chip(struct mtd_info *mtd, int chipnr);
+int do_nand_write_page_raw (struct mtd_info* mtd, size_t offset, void* data);
+int do_nand_read_page_raw (struct mtd_info *mtd, size_t offset, void* data);
+int do_nand_cache_read_page_raw (struct mtd_info *mtd, off_t offset, void* data);
+extern int nand_check_block (struct mtd_info *mtd, unsigned long offset);
+extern void set_timeout(unsigned long usec);
+extern int did_timeout(void);
+
+int board_nand_init(struct nand_chip *nand)
+{
+    /* Initial the IO_ADDR_R and IO_ADDR_W contains the xio profile register */
+	unsigned long deviceAddr ;
+	unsigned long nandId;
+    unsigned long xioProfileValue = readl(IPA051 + nand->IO_ADDR_R) ;
+	int           i;
+
+    /*
+     * This is a bit of an ugly function, but we need it because at this level
+     * we don't know what XIO profile we're dealing with. We need to know the
+     * XIO profile because it contains the bus width configuration and there's
+     * no other way to determine that.
+     */
+
+    /* Check if profile is enabled and configured for NAND FLASH */
+    if (  (xioProfileValue & IPA051_XIO_SELx_PROF__ENAB) &&
+         ((xioProfileValue & IPA051_XIO_SELx_PROF__TYPE) == IPA051_XIO_SELx_PROF__TYPE_NAND) )
+    {
+        /* Calculate the offset from the profile value */
+		deviceAddr = ((xioProfileValue & IPA051_XIO_SELx_PROF__OFFSET_EXT) >> 23) |
+              		 ((xioProfileValue & IPA051_XIO_SELx_PROF__OFFSET) >> 5 ) ;
+        deviceAddr *= 0x00800000UL ;
+
+       	/* Add the address off XIO aperture */
+       	deviceAddr += readl(IPA051 + IPA051_BASE18) & (unsigned long)IPA051_BASExx__ADDRESS ;
+
+        mydebug("Dev: (E), profile=%08lx, deviceAddr = %08lx\n", xioProfileValue, deviceAddr);
+    }  else {
+        return 1;
+    }                                       
+
+    /* Correct the IO_ADDR base */
+    nand->IO_ADDR_R         = (void __iomem *)deviceAddr;
+    nand->IO_ADDR_W         = (void __iomem *)deviceAddr;
+    
+    nand->chip_delay        = 0;
+	//nand->options           = NAND_NO_AUTOINCR | NAND_ALLOW_CLEAR_BBT | NAND_NO_SUBPAGE_WRITE;
+
+    nand->ecc.mode       	      = NAND_ECC_SOFT;
+    nand->select_chip         	  = xio_nand_select_chip;
+
+	nand_reset(nand);
+	if (nand_read_id(nand, &nandId) < 0)
+		return (2);
+
+	/* Check for 16 bit device */
+	if (xioProfileValue & IPA051_XIO_SELx_PROF__EN_16BIT) {
+		/* 16-bit device */
+		nand->mafid =  nandId & 0x000000FFUL;
+		nand->devid = (nandId & 0x00FF0000UL) >> 16;
+		//Fix me.... todo: check spec
+		nand->extid = (nandId & 0xFF000000UL) >> 24;  
+		//bus16 = 1 ;
+	} else {
+		/* 8-bit device */
+		nand->mafid =  nandId & 0x000000FFUL;
+		nand->devid = (nandId & 0x0000FF00UL) >> 8;
+		nand->extid = (nandId & 0xFF000000UL) >> 24;
+		//bus16 = 0 ;
+	}
+
+	/* Try to identify manufacturer */
+	for (i = 0; nand_flash_ids[i].id != 0x0; i++) {
+		if (nand_flash_ids[i].id == nand->devid)
+			break;
+	}
+	nand->options = nand_flash_ids[i].options;
+	
+    //xio_nand_scan_partitions(mtd);
+    return 0;
+}
+
+/*
+ * Select a chip
+ */
+static void xio_nand_select_chip(struct mtd_info *mtd, int chipnr)
+{
+#if 0   
+    	struct nand_chip *nc = mtd->priv;
+    	if (chipnr == -1)
+        		return;
+    	/*
+     	* Get the XIO slot base address
+     	*/
+    	nc->slotbase = xn->slotbase[chipnr];
+#endif  
+}
+
+int do_nand_read_page_raw (struct mtd_info *mtd, size_t offset, void* data)
+{
+	struct nand_chip *nand = mtd->priv;
+	/*
+	 * Pleas note: We dereference '*data' here beyond what may be expected:
+	 * The calling function probably expects this pointer to be dereferenced
+	 * by the In Band page length only, while in fact OOB is copied to this
+	 * pointer as well. In normal circumstances this is no problem becuase
+	 * we're just copying data to SDRAM. But when loading to variables
+	 * surrounded by other variables, or loading pages out of sequence
+	 * problems will arise
+	 */
+	 
+	/* Read the page from the device using DMA */
+	return( nand_dma_read( mtd,			    	     /* Device	*/
+			       offset >> nand->page_shift,	     /* Row		*/
+			       0,				                 /* Column	*/
+				   mtd->writesize + mtd->oobsize,	 /* Length	 */
+			       data, 		                     /* Destination	*/
+				   0 ) );                            /* Cache read flag  */
+}
+
+int do_nand_cache_read_page_raw (struct mtd_info *mtd, off_t offset, void* data)
+{
+	struct nand_chip *nand = mtd->priv;
+	/*
+	 * Pleas note: We dereference '*data' here beyond what may be expected:
+	 * The calling function probably expects this pointer to be dereferenced
+	 * by the In Band page length only, while in fact OOB is copied to this
+	 * pointer as well. In normal circumstances this is no problem becuase
+	 * we're just copying data to SDRAM. But when loading to variables
+	 * surrounded by other variables, or loading pages out of sequence
+	 * problems will arise
+	 */
+
+	/* Read the page from the device using DMA */
+	return( nand_dma_read( mtd,				/* Device	*/
+			       offset >> nand->page_shift,	/* Row		*/
+			       0,				/* Column	*/
+				   mtd->writesize + mtd->oobsize,	 /* Length	 */
+			       data, 			/* Destination	*/
+				   NAND_CANCACHEDREAD(nand) ) );  /* Cache read flag  */
+}
+
+int do_nand_write_page_raw(struct mtd_info* mtd, size_t offset, void* data)
+{
+	struct nand_chip *nand = mtd->priv;
+	unsigned long	nandStatus ;
+	int		ret = 0;
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	unsigned char*	compareBuffer_nonal;
+	unsigned char*	compareBuffer;
+
+	/* malloc unaligned compare buffer */
+	compareBuffer_nonal = (unsigned char*)malloc(
+		/* round up to cacheline to have a multiple number of cachelines in buffer */
+		ROUND_UP(mtd->writesize + mtd->oobsize, CONFIG_SYS_CACHELINE_SIZE)
+		/* make sure we can align the nonaligned buffer */
+		+ (CONFIG_SYS_CACHELINE_SIZE - 1));
+	/* align buffer pointer to nonaligned buffer */
+	compareBuffer = (unsigned char*)ROUND_UP((unsigned int)compareBuffer_nonal, CONFIG_SYS_CACHELINE_SIZE);
+#endif /* CONFIG_MTD_NAND_VERIFY_WRITE */
+
+	/* Write the page to the device using DMA */
+	if( nand_dma_write( mtd,				/* Device	*/
+			    offset >> nand->page_shift,		/* Row		*/
+			    0,					/* Column	*/
+				mtd->writesize + mtd->oobsize, /* Length	*/
+			    data ) ) {				/* Source	*/
+		ret = -1;
+		goto _cleanup;
+	}
+
+	/* Check nand status */
+	nand_read_status (mtd, &nandStatus);
+	if( (nandStatus & NAND_STATUS_WP) == 0 ) {
+		printf( "\nError: NAND device is write protected\n" );
+		ret = -3;
+		goto _cleanup;
+	} else if( (nandStatus & NAND_STATUS_FAIL) != 0 ) {
+		printf( "\nError: NAND device reported an error (status = 0x%.8lX)\n", nandStatus );
+		ret = -2;
+		goto _cleanup;
+	}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Read back the page from the device using DMA */
+	if( nand_dma_read( mtd,				/* Device	*/
+			   offset >> nand->page_shift,		/* Row		*/
+			   0,					/* Column	*/
+			   mtd->writesize + mtd->oobsize,  /* Length	 */
+			   compareBuffer,			/* Destination	*/
+			   0 ) )	 { 		 /* Normal (uncached read)  */
+		ret = -4;
+		goto _cleanup;
+	}
+
+	/* Compare the read page with written page */
+	if( memcmp( data, compareBuffer, mtd->writesize + mtd->oobsize ) != 0 )
+	{
+		printf("\nError: Verification failed (Forgotten to erase the block?)\n");
+		ret = -5;
+		goto _cleanup;
+	}
+#endif /* CONFIG_MTD_NAND_VERIFY_WRITE */
+
+_cleanup:
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* free the malloc'ed compare buffer before exit.. */
+	free(compareBuffer_nonal);
+#endif /* CONFIG_MTD_NAND_VERIFY_WRITE */
+
+	return (ret);
+}
+
+#endif /* CONFIG_NAND* */
+#endif /* CONFIG_NXP_PCIXIO_IPA051 */
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index bec9277..5cab515 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -40,6 +40,7 @@
 #include <linux/mtd/mtd.h>
 #include <nand.h>
 #include <jffs2/jffs2.h>
+#include <nxp_pcixio_ipa051.h>
 
 #if !defined(CONFIG_SYS_64BIT_VSPRINTF)
 #warning Please define CONFIG_SYS_64BIT_VSPRINTF for correct output!
@@ -196,12 +197,15 @@ int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 	if (!opts->quiet)
 		printf("\n");
 
+//YW: we don't maintain BBT
+#if 0
 	if (nand_block_bad_old) {
 		struct nand_chip *priv_nand = meminfo->priv;
 
 		priv_nand->block_bad = nand_block_bad_old;
 		priv_nand->scan_bbt(meminfo);
 	}
+#endif
 
 	return 0;
 }
@@ -288,7 +292,7 @@ int nand_lock(struct mtd_info *mtd, int tight)
 		      -1, -1);
 
 	/* call wait ready function */
-	status = chip->waitfunc(mtd, chip);
+	status = chip->waitfunc(mtd, chip, FL_WRITING);
 
 	/* see if device thinks it succeeded */
 	if (status & 0x01) {
@@ -511,8 +515,10 @@ int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 		WATCHDOG_RESET ();
 
 		if (nand_block_isbad (nand, offset & ~(nand->erasesize - 1))) {
+#if CONFIG_SYS_NAND_QUIET==0
 			printf ("Skip bad block 0x%08llx\n",
 				offset & ~(nand->erasesize - 1));
+#endif
 			offset += nand->erasesize - block_offset;
 			continue;
 		}
diff --git a/drivers/mtd/nand/nx_nand_ip2070.c b/drivers/mtd/nand/nx_nand_ip2070.c
new file mode 100644
index 0000000..2a67b69
--- /dev/null
+++ b/drivers/mtd/nand/nx_nand_ip2070.c
@@ -0,0 +1,1666 @@
+/*
+ * Device driver for NAND flash connected IP_2070 EFM.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version      Date          Remarks
+ * 0.0.1	 		20081211		Draft-Initial version
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <watchdog.h>
+#include <linux/err.h>
+#include <linux/mtd/compat.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+
+#ifdef CONFIG_JFFS2_NAND
+#include <jffs2/jffs2.h>
+#endif
+
+#undef DEBUG
+#ifdef DEBUG
+#define DBG_PRINT(x) printf x
+#else
+#define DBG_PRINT(x)
+#endif
+
+/* NAND specific files */
+#include "nx_nand_ip2070.h"
+#include <linux/nx_dmac_ip1902.h>
+
+extern void flush_dcache_range(ulong start_addr, ulong stop);
+extern void invalidate_dcache_range(ulong start_addr, ulong stop);
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+*	OOB structure
+*/
+/* For LPF */
+static struct nand_ecclayout nx_nand_oob_128 = {
+	.eccbytes = 96,
+	.eccpos = {
+		   4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+		   20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+			 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+			 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
+			 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
+			 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
+			 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
+			 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,126, 127
+			 },
+
+	.oobfree = {
+		{.offset = 2,
+		 .length = 2},
+		{.offset = 16,
+		 .length = 4},
+		{.offset = 32,
+		 .length = 4},
+		{.offset = 48,
+		 .length = 4},
+		{.offset = 64,
+		 .length = 4},
+		{.offset = 80,
+		 .length = 4},
+		{.offset = 96,
+		 .length = 4},
+		{.offset = 112,
+		 .length = 4},
+	}
+};
+
+static struct nand_ecclayout nx_nand_oob_64 = {
+	.eccbytes = 48,
+	.eccpos = {
+		   4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+		   20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+			 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+			 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 2},
+		{.offset = 16,
+		 .length = 4},
+		{.offset = 32,
+		 .length = 4},
+		{.offset = 48,
+		 .length = 4},
+	}
+};
+
+/* For SPF */
+static struct nand_ecclayout nx_nand_oob_16 = {
+	.eccbytes = 16,
+	.eccpos = {
+				4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
+	.oobfree = {
+		{.offset = 0,
+		 .length = 4},
+		}
+};
+
+/**
+*	Flash based BBT information
+*/
+static uint8_t nx_bbt_pattern[] = {'N', 'X', 'P' };
+static uint8_t nx_mirror_pattern[] = {'P', 'X', 'N' };
+
+static struct nand_bbt_descr nx_bbt_main = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 3,
+	.veroffs = 3,
+	.maxblocks = 4,
+	.pattern = nx_bbt_pattern
+};
+
+static struct nand_bbt_descr nx_bbt_mirror = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 3,
+	.veroffs = 3,
+	.maxblocks = 4,
+	.pattern = nx_mirror_pattern
+};
+
+#endif
+
+/**
+* NAND control structure
+*/
+struct nx_nand_ctrl *nx_nc = NULL;
+
+
+/*------------------------------------------------------------------------------------
+* Internal functions
+--------------------------------------------------------------------------------------*/
+/**
+* nx_nand_dmac_init - Configure the DMAC scatter gather list
+* @nc: NAND control structure
+* @read: Read command
+* @req: Request structure
+* @stgt: Scatter gather array
+*
+* Initialise the DMAC scatter gather list
+*/
+static inline void nx_nand_dmac_init(struct nx_nand_ctrl *nc,
+			uint32_t cmd, nx_dmac_tfr_t *req, nx_dmac_stgt_t *stgt)
+{
+	int i;
+
+	if(cmd) {
+
+		/* Read Main Area */
+		for(i=0; i < nc->num_blks; i++) {
+			stgt[i].src_addr = NX_NAND_AHB_BUF;
+			stgt[i].dst_addr = virt_to_phys(nc->dmabuf + (i * NX_NAND_BLK_SIZE));
+			stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;
+			stgt[i].flowctl = nx_dmac_per2mem_dma;
+/*			stgt[i].flowctl = nx_dmac_mem2mem_dma; */
+			stgt[i].src_per = 0;
+			stgt[i].dst_per = 0;
+			stgt[i].src_ahb = 1;		          /* Source AHB master 2 */
+			stgt[i].dst_ahb = 0;              /* Dest AHB master 1 */
+			stgt[i].src_inc = 1;
+			stgt[i].dst_inc = 1;
+			stgt[i].src_brst = nx_dmac_128;
+			stgt[i].dst_brst = nx_dmac_128;
+			stgt[i].src_width = nx_dmac_width_32;
+			stgt[i].dst_width = nx_dmac_width_32;
+		}
+
+		/* Read OOB area */
+		stgt[i].src_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;
+		stgt[i].dst_addr = virt_to_phys(nc->dmabuf + (i * NX_NAND_BLK_SIZE));
+		stgt[i].tfr_size = nc->mtd->oobsize >> 2;
+
+		stgt[i].flowctl = nx_dmac_per2mem_dma;
+/*		stgt[i].flowctl = nx_dmac_mem2mem_dma; */
+ 		stgt[i].src_ahb = 1;		          /* Source AHB master 1 */
+ 		stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
+		stgt[i].src_per = 0;
+ 		stgt[i].dst_per = 0;
+ 		stgt[i].src_inc = 1;
+ 		stgt[i].dst_inc = 1;
+		if(nc->mtd->oobsize == 128) {
+ 			stgt[i].src_brst = nx_dmac_32;
+ 			stgt[i].dst_brst = nx_dmac_32;
+		}
+		else if(nc->mtd->oobsize == 64) {
+ 			stgt[i].src_brst = nx_dmac_16;
+ 			stgt[i].dst_brst = nx_dmac_16;
+		}
+		else {
+ 			stgt[i].src_brst = nx_dmac_4;
+ 			stgt[i].dst_brst = nx_dmac_4;
+		}
+		stgt[i].src_width = nx_dmac_width_32;
+		stgt[i].dst_width = nx_dmac_width_32;
+	}
+	else {
+
+		/* Write OOB area */
+		i=0;
+		stgt[i].dst_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;
+		stgt[i].src_addr = virt_to_phys(nc->dmabuf + (nc->num_blks * NX_NAND_BLK_SIZE));
+		stgt[i].tfr_size = nc->mtd->oobsize >> 2;
+		stgt[i].flowctl = nx_dmac_mem2per_dma;
+/*		stgt[i].flowctl = nx_dmac_mem2mem_dma; */
+ 		stgt[i].src_ahb = 0;		          /* Source AHB master 0 */
+ 		stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+		stgt[i].src_per = 0;
+ 		stgt[i].dst_per = 0;
+ 		stgt[i].src_inc = 1;
+ 		stgt[i].dst_inc = 1;
+		if(nc->mtd->oobsize == 128) {
+ 			stgt[i].src_brst = nx_dmac_32;
+ 			stgt[i].dst_brst = nx_dmac_32;
+		}
+		else if(nc->mtd->oobsize == 64) {
+ 			stgt[i].src_brst = nx_dmac_16;
+ 			stgt[i].dst_brst = nx_dmac_16;
+		}
+		else {
+ 			stgt[i].src_brst = nx_dmac_4;
+ 			stgt[i].dst_brst = nx_dmac_4;
+		}
+		stgt[i].src_width = nx_dmac_width_32;
+		stgt[i].dst_width = nx_dmac_width_32;
+
+		/* Write Main area */
+		for(i=1; i< (nc->num_blks+1); i++) {
+  		stgt[i].src_addr = virt_to_phys(nc->dmabuf + ( (i-1) * NX_NAND_BLK_SIZE));
+		stgt[i].dst_addr = NX_NAND_AHB_BUF;
+  		stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;
+		stgt[i].flowctl = nx_dmac_mem2per_dma;
+/*		stgt[i].flowctl = nx_dmac_mem2mem_dma; */
+ 		stgt[i].src_per = 0;
+  		stgt[i].dst_per = 0;
+ 		stgt[i].src_ahb = 0;		          /* Source AHB master 0 */
+  		stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+  		stgt[i].src_inc = 1;
+  		stgt[i].dst_inc = 1;
+  		stgt[i].src_brst = nx_dmac_128;
+  		stgt[i].dst_brst = nx_dmac_128;
+  		stgt[i].src_width = nx_dmac_width_32;
+  		stgt[i].dst_width = nx_dmac_width_32;
+		}
+	}
+
+	req->num_reqs = nc->num_blks + 1;
+	req->req = &stgt[0];
+}
+
+/**
+* nx_nand_cmd_addr - Send cmd & address cycles to chip
+* @nc: NAND control structure
+* @cmd: Command to be send
+* @data: command or data
+* @last: Last cycle
+*
+* Send command & address cycles to chip for small page chips
+*/
+static inline void nx_nand_cmd_addr(struct nx_nand_ctrl *nc, uint32_t cmd,
+				     uint32_t data, int last)
+{
+	uint32_t cmd_addr = 0;
+
+	/* Send command & address to chip */
+	cmd_addr = (0 << (nc->slotid + CMD_FIFO_CE_POS));
+	cmd_addr |= ((cmd & CMD_FIFO_CYCLE_MSK) << CMD_FIFO_CYCLE_POS);
+	cmd_addr |= ((last & CMD_FIFO_LAST_MSK) << CMD_FIFO_LAST_POS);
+	cmd_addr |= (data & CMD_FIFO_IO_MSK);
+	writel(cmd_addr, (nx_nc->ctrl_base + CMD_ADDR_FIFO_OFFSET));
+	DBG_PRINT(("nx_nand_cmd_addr: 0x%x \r\n", cmd_addr));
+
+	return;
+}
+
+/**
+* nx_nand_erase - Erase the block
+* @nc: NAND control structure
+*
+* Erase the block
+*/
+static inline void nx_nand_erase(struct nx_nand_ctrl *nc)
+{
+	struct mtd_info *mtd=nc->mtd;
+	struct nand_chip *chip = mtd->priv;
+	uint32_t intr;
+	volatile uint32_t int_status;
+	int addr;
+
+	/* Enable READY interupt */
+	intr = (1 << (NX_NAND_INT_READY_START + nc->slotid));
+	writel(intr, (nx_nc->ctrl_base + INT_SET_ENABLE_OFFSET));
+
+	/* Clear interrupt */
+	writel(intr, (nx_nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+
+	/* Send address ERASE1 command */
+	nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
+
+	/* Send address cycles */
+	addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+	nx_nand_cmd_addr(nc, 0, addr, 0);
+
+	addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+	nx_nand_cmd_addr(nc, 0, addr, 0);
+
+	if(nc->lb_chip) {
+		/* LPF */
+		if (chip->chipsize > (1 << 28)) {
+			addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+			nx_nand_cmd_addr(nc, 0, addr, 0);
+		}
+	}
+	else {
+		/* SPF */
+		if (chip->chipsize > (32 << 20)) {
+			addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+			nx_nand_cmd_addr(nc, 0, addr, 0);
+		}
+	}
+
+	/* Send ERASE2 command */
+	nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
+
+	/* Wait for ready interrupt */
+	set_timeout(PNX8XXX_TIMEOUT);
+	int_status = readl(nx_nc->ctrl_base + INT_STATUS_OFFSET);
+	while (!(int_status & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+		if(did_timeout()) {
+			printk("TIMEOUT:Erase \r\n");
+			return;
+		}
+		int_status = readl(nx_nc->ctrl_base + INT_STATUS_OFFSET);
+	}
+
+	/* Clear interrupt */
+	writel(intr, (nx_nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+
+	/* Disable interrupt */
+	writel(intr, (nx_nc->ctrl_base + INT_CLR_ENABLE_OFFSET));
+
+	return;
+}
+
+/**
+* nx_nand_read - Read page into driver buffer
+* @nc: NAND control structure
+*
+* Read a page into driver buffer
+*/
+static inline void nx_nand_read(struct nx_nand_ctrl *nc)
+{
+	struct mtd_info *mtd=nc->mtd;
+	struct nand_chip *chip = mtd->priv;
+	uint32_t intr, page_cfg, int_ecc;
+	volatile uint32_t int_status;
+	int status, addr, chanid;
+	nx_dmac_tfr_t	req;
+	nx_dmac_stgt_t	stgt[5];
+
+	DBG_PRINT(("> IP2017 nx_nand_read enter \r\n"));
+
+	/* Init DMAC Scatter gather list */
+	nx_nand_dmac_init(nc, 1, &req, stgt);
+
+	/* Set DMAC Flow control */
+
+/* TODO: TH  are we not permited to do this multiple times
+ *
+ *	DBG_PRINT(  ("IP2017_DMA_CTRL = 0x%x \r\n", DMA_CTRL_PER_2_MEM) 	);
+ *	writel(DMA_CTRL_PER_2_MEM, (nc->ctrl_base + DMA_CTRL_OFFSET));
+ */
+	/* Enable the SEQ READ PAGE DONE interrupt */
+	intr = NX_NAND_INT_SEQ_READ;
+	writel(intr, (nc->ctrl_base + INT_SET_ENABLE_OFFSET));
+
+	/* Clear interrupt */
+	DBG_PRINT(("IP2017_INT_CLR_STATUS 0x%x \r\n", intr));
+	writel(intr, (nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+
+	/* Clear interrupt */
+	DBG_PRINT(("nx_nand_read: reset all interrupts \r\n"));
+	writel(0xFFFFFFFF, (nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+	int_status = readl(nx_nc->ctrl_base + INT_STATUS_OFFSET);
+	DBG_PRINT(("nx_nand_read: interrupt status: 0x%x \r\n", int_status));
+	if(nc->cur_cmd == NAND_CMD_READ0) {
+
+		/* Page operation */
+		page_cfg = PAGE_RW_OOB_MSK | PAGE_RW_PAGE_READ_MSK;
+		if(nc->aes) {
+			page_cfg |= PAGE_RW_AES_MSK;
+		}
+
+		if(chip->ecc.mode == NAND_ECC_HW) {
+			page_cfg |= PAGE_RW_ECC_MSK;
+		}
+
+		DBG_PRINT(("IP2017_PAGE_RW 0x%x \r\n", page_cfg));
+		writel(page_cfg, (nc->ctrl_base + PAGE_RW_OFFSET));
+
+		/* Start DMAC */
+		chanid = nx_dmac_tfr(&req);
+		if(chanid < 0) {
+			printk( "nx_nand_read: NAND_READ0 DMAC config \r\n");
+			return;
+		}
+
+		/* Send READ0 command */
+		nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+
+		/* Send address cycles */
+		addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+		nx_nand_cmd_addr(nc, 0, addr, 0);
+
+		if(nc->lb_chip) {
+			addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+			nx_nand_cmd_addr(nc, 0, addr, 0);
+		}
+
+		addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+		nx_nand_cmd_addr(nc, 0, addr, 0);
+		if(nc->lb_chip) {
+			/* LPF */
+			addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+			nx_nand_cmd_addr(nc, 0, addr, 0);
+			if (chip->chipsize > (1 << 28)) {
+				addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 0);
+			}
+
+			/* Send READSTART command */
+			nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+
+		}
+		else {
+			/* SPF */
+			if (chip->chipsize > (32 << 20)) {
+				/* Chip size > 64MB */
+				addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 0);
+
+				addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 1);
+			}
+			else {
+				/* Chip size < 64MB */
+				addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 1);
+			}
+		}
+
+	}
+	else {
+		/* Page operation */
+		page_cfg = PAGE_RW_OOB_MSK | PAGE_RW_PAGE_READ_MSK;
+		if(nc->aes) {
+			page_cfg |= PAGE_RW_AES_MSK;
+		}
+
+		if(chip->ecc.mode == NAND_ECC_HW) {
+			page_cfg |= PAGE_RW_ECC_MSK;
+		}
+		writel(page_cfg, (nc->ctrl_base + PAGE_RW_OFFSET));
+
+		/* Send CACHED READ cmd */
+
+		nx_nand_cmd_addr(nc, 1, NAND_CMD_CACHEREAD, 1);
+	}
+
+#if (1)
+	/* Wait for SEQ_READ interrupt */
+	DBG_PRINT(("nx_nand_read: Wait for SEQ_READ interrupt \r\n"));
+	set_timeout(PNX8XXX_TIMEOUT);
+	int_status = readl(nx_nc->ctrl_base + INT_STATUS_OFFSET);
+	while (!(int_status & NX_NAND_INT_SEQ_READ))
+	{
+		DBG_PRINT(("nx_nand_read:interrupt status: 0x%x \r\n", int_status));
+		/* Check Timeout */
+		if(did_timeout()) {
+			printk("TIMEOUT: Read\r\n");
+			return;
+		}
+		int_status = readl(nx_nc->ctrl_base + INT_STATUS_OFFSET);
+	}
+
+	/* Check ECC status */
+	if(chip->ecc.mode == NAND_ECC_HW) {
+		DBG_PRINT(("nx_nand_read: Check ECC status \r\n"));
+		/* Get HW ECC status */
+		int_ecc = int_status & (NX_NAND_INT_DEC_UNCOR |
+                   NX_NAND_INT_DEC_0_ERR |
+                   NX_NAND_INT_DEC_1_ERR |
+                   NX_NAND_INT_DEC_2_ERR |
+                   NX_NAND_INT_DEC_3_ERR |
+                   NX_NAND_INT_DEC_4_ERR |
+                   NX_NAND_INT_DEC_5_ERR);
+
+		if(int_ecc) {
+			int i = 0 ;
+		 	nc->ecc_status[i] = int_ecc;
+			writel(int_ecc, (nx_nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+			i++;
+		}
+	}
+
+	/* Clear interrupt */
+	writel(int_status, (nx_nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+#endif
+
+	/* Complete DMAC transfer */
+	status = nx_dmac_tfr_comp(chanid);
+	if(status) {
+		printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");
+		return;
+	}
+
+	DBG_PRINT(("nx_nand_read: NAND_READ0 DMAC complete status: 0x%x \r\n", status));
+
+	/* Disable interrupt */
+	writel(intr, (nx_nc->ctrl_base + INT_CLR_ENABLE_OFFSET));
+	DBG_PRINT(("nx_nand_read: interrupts disabled \r\n"));
+
+	/* Disable DMAC Flow control */
+/* TODO: check:	writel(0, (nx_nc->ctrl_base + DMA_CTRL_OFFSET));  */
+	DBG_PRINT(("nx_nand_read: dma flow control disabled \r\n"));
+	DBG_PRINT(("< IP2017 nx_nand_read exit \r\n"));
+
+	return;
+}
+
+
+/*------------------------------------------------------------------------------------
+* NAND chip specific functions
+--------------------------------------------------------------------------------------*/
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+* nx_nand_calculate_ecc - HW ECC calculate
+* @mtd: MTD information structure
+* @dat: Databuffer
+* @ecc_code: ECC code buffer
+*
+* Dummy function for HW ECC calculation
+*/
+static int nx_nand_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,
+							uint8_t *ecc_code)
+{
+	return 0;
+}
+
+/**
+* nx_nand_correct_data - HW ECC correct
+* @mtd: MTD information structure
+* @dat: Databuffer
+* @read_ecc: Read ECC code buffer
+* @calc_ecc: Calculated ECC buffer
+*
+* Dummy function for HW ECC calculation
+*/
+static int nx_nand_correct_data(struct mtd_info *mtd, uint8_t *dat,
+		             uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+	return 0;
+}
+
+/**
+* nx_nand_hwctl - HW ECC control function
+* @mtd: MTD information structure
+* @mode: Mode
+*
+* Dummy function for HW ECC calculation
+*/
+static void nx_nand_hwctl(struct mtd_info *mtd, int mode)
+{
+	return;
+}
+
+#endif
+
+/**
+* nx_nand_select_chip - Enable or Disable chip
+* @mtd: MTD information structure
+* @chipnr: Chip number
+*
+* Enable the chip if it chipnr >= 0, else disable the chip
+*/
+static void nx_nand_select_chip(struct mtd_info *mtd, int chipnr)
+{
+	struct nand_chip *chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+
+	if(chipnr == -1)
+		return;
+
+	/* Store the value in nand control structure
+	 * Chip enable/disable done in command function */
+	nc->slotid = chipnr;
+}
+
+/**
+* nx_nand_dev_ready - Check device ready
+* @mtd: MTD information structure
+*
+* Return true if the device is ready, false otherwise
+*/
+static int nx_nand_dev_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+	int status, ready = 0;
+
+	/* Get status from controller */
+	status = readl(nc->ctrl_base + NAND_STATUS_OFFSET);
+	if(status & (NAND_STATUS_RB_DEV0 << nc->slotid)) {
+		ready = 1;
+	}
+
+	/* Return R/B status */
+	return ready;
+}
+
+/**
+* nx_nand_read_byte - Read a byte from chip
+* @mtd: MTD information structure
+*
+* Read a byte from the nand chip
+*/
+static uint8_t nx_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+	int data;
+
+	/* Read data */
+	data = readl(nc->ctrl_base + SINGLE_READ_OFFSET);
+	return (uint8_t) cpu_to_le16(data);
+}
+
+/**
+* nx_nand_read_byte16 - Read a byte from 16bit chip
+* @mtd: MTD information structure
+*
+* Read a byte from the 16bit nand chip
+*/
+static uint8_t nx_nand_read_byte16(struct mtd_info *mtd)
+{
+	struct nand_chip *chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+	uint16_t data;
+
+	/* Read data */
+	data = readl(nc->ctrl_base + SINGLE_READ_OFFSET);
+	return (uint8_t) cpu_to_le16(data);
+}
+
+/**
+* nx_nand_read_buf - Read data from chip
+* @mtd: MTD information structure
+* @buf: Data buffer
+* @len: Transfer size
+*
+* Read specified number of bytes from the driver buffer
+*/
+static void nx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct nand_chip *chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+	DBG_PRINT(("> IP2017 nx_nand_read_buf enter \r\n"));
+
+	/* Copy from driver buffer */
+	memcpy(buf, nc->dmabuf + nc->offset, len);
+	nc->offset += len;
+	DBG_PRINT(("< IP2017 nx_nand_read_buf exit \r\n"));
+
+}
+
+/**
+* nx_nand_read_page_raw - Read 1 page data from chip
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Read a full page + oob into the buffer
+*/
+static int nx_nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+				  uint8_t *buf)
+{
+	struct nx_nand_ctrl *nc = chip->priv;
+	DBG_PRINT(("> IP2017 nx_nand_read_page_raw enter \r\n"));
+
+	/* Copy to user buffer */
+	invalidate_dcache_range(nc->dmabuf, (nc->dmabuf + mtd->writesize + mtd->oobsize));
+	chip->read_buf(mtd, buf, mtd->writesize);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	DBG_PRINT(("< IP2017 nx_nand_read_page_raw exit \r\n"));
+
+	return 0;
+}
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+* nx_nand_read_page - Read 1 page data from chip with HWECC
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Read a full page + oob into the buffer
+*/
+static int nx_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+				  uint8_t *buf)
+{
+	int stat=0,i, j;
+	struct nx_nand_ctrl *nc = chip->priv;
+	int eccsteps = chip->ecc.steps;
+	int no_all_ffs=0;
+
+	/* Read page data */
+	nx_nand_read_page_raw(mtd, chip, buf);
+
+	/* Check ECC status */
+	for (i = 0 ; i<eccsteps; i++) {
+
+		if(nc->ecc_status[i] == NX_NAND_INT_DEC_UNCOR) {
+
+			for(j=0; j < mtd->writesize; j++) {
+				if(buf[j] != 0xFF) {
+					no_all_ffs = 1;
+					break;
+				}
+			}
+			if(no_all_ffs) {
+				printk(KERN_INFO "step %d: ECC failed \r\n", i);
+				mtd->ecc_stats.failed++;
+			}
+		}
+		else {
+			/* Update ECC stats */
+			if(nc->ecc_status[i] != NX_NAND_INT_DEC_0_ERR) {
+				for(j=0; j < 5; j++) {
+					if(nc->ecc_status[i] == (NX_NAND_INT_DEC_1_ERR << j)) {
+						stat = j+1;
+					}
+				}
+				mtd->ecc_stats.corrected += stat;
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
+/**
+* nx_nand_read_oob - Read OOB data
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @page: Page address
+* @sndcmd: Send command flag
+*
+* Read OOB data into the buffer
+*/
+static int nx_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+				  int page, int sndcmd)
+{
+	struct nx_nand_ctrl *nc = chip->priv;
+	uint8_t *buf = chip->oob_poi;
+	int length = mtd->oobsize;
+	int column, addr, i;
+	uint32_t	data;
+	uint32_t page_cfg;
+
+	DBG_PRINT(("> IP2017 nx_nand_read_oob enter \r\n"));
+
+	if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+		/* Use device OOB layout */
+		DBG_PRINT(("Use device OOB layout \r\n"));
+		/* No page operation */
+		page_cfg = PAGE_RW_OOB_MSK;
+		DBG_PRINT(("IP2017_PAGE_RW 0x%x \r\n", page_cfg));
+		writel(page_cfg, (nc->ctrl_base + PAGE_RW_OFFSET));
+
+		/* Send READOOB command */
+		if(sndcmd) {
+			chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		}
+
+		/* Check if CE DON't care is supported */
+		column = nc->cur_col;
+		i = 0;
+		while(length) {
+			/* Send Address & cmd cycles */
+			if(sndcmd) {
+				/* Send READ0 command */
+				nx_nand_cmd_addr(nc, 1, nc->cur_cmd, 0);
+				DBG_PRINT(("CMD: 0x%x \r\n", nc->cur_cmd));
+
+				/* Send address cycles */
+				addr = column & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 0);
+				DBG_PRINT(("addr0 0x%x \r\n", addr));
+
+				if(nc->lb_chip) {
+					addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+					nx_nand_cmd_addr(nc, 0, addr, 0);
+					DBG_PRINT(("addr1 0x%x \r\n", addr));
+				}
+
+				addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 0);
+				DBG_PRINT(("addr2 0x%x \r\n", addr));
+
+				if(nc->lb_chip) {
+					/* if > 2Gb, extra address cycle */
+					if (chip->chipsize > (1 << 28)) {
+						addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 0);
+						DBG_PRINT(("addr3 0x%x \r\n", addr));
+					}
+
+					/* Send READSTART command */
+					nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+					DBG_PRINT(("READSTART 0x%x \r\n", NAND_CMD_READSTART));
+				}
+				else {
+					if (chip->chipsize > (32 << 20)) {
+						addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 0);
+						DBG_PRINT(("addr3 0x%x \r\n", addr));
+
+						addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 1);
+						DBG_PRINT(("addr4 0x%x \r\n", addr));
+					}
+					else {
+						addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 1);
+						DBG_PRINT(("addr3 0x%x \r\n", addr));
+					}
+				}
+				sndcmd = 0;
+
+				/* Wait for completion */
+				udelay(chip->chip_delay);
+			}
+
+			/* Read data from chip */
+
+			data = readl(nx_nc->ctrl_base + SINGLE_READ_OFFSET);
+			buf[i] = (uint8_t) data;
+			DBG_PRINT(("Sinlge_READ: 0x%x \r\n", addr));
+
+			length--;
+			i++;
+
+			if(!nx_nc->cedontcare) {
+				sndcmd = 1;
+				column++;
+			}
+		}
+	}
+	else {
+		/* Use IP_2017 OOB layout - (512 Bytes data + 16 bytes OOB data) */
+		DBG_PRINT(("Use IP_2017 device OOB layout \r\n"));
+		/* Send READOOB command */
+		if(sndcmd) {
+			chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+			sndcmd = 0;
+		}
+
+		/* Copy into user buffer */
+		nc->offset = mtd->writesize;
+		invalidate_dcache_range(nc->dmabuf, (nc->dmabuf + mtd->writesize + mtd->oobsize));
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	}
+	DBG_PRINT(("< IP2017 nx_nand_read_oob exit \r\n"));
+
+	return 0;
+}
+
+/**
+* nx_nand_write_buf - Write data into chip
+* @mtd: MTD information structure
+* @buf: Data buffer
+* @len: Transfer size
+*
+* Write specified number of bytes into the nand chip
+*/
+static void nx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+		int len)
+{
+	DBG_PRINT(("> IP2017 nx_nand_write_buf enter \r\n"));
+
+	struct nand_chip *chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+
+	/* Copy data to driver buffer */
+	memcpy(nc->dmabuf + nc->offset, buf, len);
+	nc->offset += len;
+	DBG_PRINT(("< IP2017 nx_nand_write_buf leave \r\n"));
+
+}
+
+/**
+* nx_nand_write_page_raw - Write 1 page data into chip
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Write a full page + oob into the buffer
+*/
+static void nx_nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	struct nx_nand_ctrl *nc = chip->priv;
+	unsigned long len = mtd->writesize + mtd->oobsize;
+	uint32_t	intr=0;
+	volatile 	uint32_t int_status;
+	uint16_t	addr;
+	int chanid, status;
+	uint32_t page_cfg;
+	nx_dmac_tfr_t				req;
+	nx_dmac_stgt_t			stgt[5];
+
+	DBG_PRINT(("> IP2017 nx_nand_write_page_raw enter \r\n"));
+
+	/* Copy data into buffer */
+	chip->write_buf(mtd, buf, mtd->writesize);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+	flush_dcache_range(nc->dmabuf, nc->dmabuf + len);
+
+	/* Scatter gather list for DMAC */
+	nx_nand_dmac_init(nc, 0, &req, stgt);
+
+	/* Configure Flow control */
+/*	writel(DMA_CTRL_MEM_2_PER, (nx_nc->ctrl_base + DMA_CTRL_OFFSET)); */
+
+	/* Start DMA */
+	chanid = nx_dmac_tfr(&req);
+	if(chanid < 0) {
+		printk(KERN_ERR "nx_nand: NAND_SEQIN DMAC config \r\n");
+		return;
+	}
+
+	/* Page operation */
+	page_cfg = PAGE_RW_OOB_MSK | PAGE_RW_PAGE_WRITE_MSK;
+	if(nc->aes) {
+		page_cfg |= PAGE_RW_AES_MSK;
+	}
+
+	if(chip->ecc.mode == NAND_ECC_HW) {
+		page_cfg |= PAGE_RW_ECC_MSK;
+	}
+	writel(page_cfg, (nx_nc->ctrl_base + PAGE_RW_OFFSET));
+
+	/* Clear interrupt */
+	writel(NX_NAND_INT_ALL, (nx_nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+
+	/* Enable SEQ WRIEt & READY interrupts */
+	intr = NX_NAND_INT_SEQ_WRITE | (1 << (NX_NAND_INT_READY_START + nc->slotid));
+	writel(intr, (nx_nc->ctrl_base + INT_SET_ENABLE_OFFSET));
+
+	/* Send SEQIN command */
+	nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+
+	/* Send address commands */
+	addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+	nx_nand_cmd_addr(nc, 0, addr, 0);
+
+	if(nc->lb_chip) {
+		addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+		nx_nand_cmd_addr(nc, 0, addr, 0);
+	}
+
+	addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+	nx_nand_cmd_addr(nc, 0, addr, 0);
+
+	addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+	nx_nand_cmd_addr(nc, 0, addr, 0);
+
+	if(nc->lb_chip) {
+		/* if > 2Gb, extra address cycle */
+		if (chip->chipsize > (1 << 28)) {
+			addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+			nx_nand_cmd_addr(nc, 0, addr, 0);
+		}
+	}
+	else {
+		/* if > 64MB, extra adddress cycle */
+		if (chip->chipsize > (32 << 20)) {
+			addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+			nx_nand_cmd_addr(nc, 0, addr, 0);
+		}
+	}
+
+	/* Send PAGEPROG - post write command */
+	nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
+
+	/* Complete DMAC transfer */
+	status = nx_dmac_tfr_comp(chanid);
+	if(status) {
+		printk(KERN_ERR "nx_nand: write_page_raw \r\n");
+		return;
+	}
+
+	/* Wait till READY interrupt */
+	set_timeout(PNX8XXX_TIMEOUT);
+	int_status = readl(nx_nc->ctrl_base + INT_STATUS_OFFSET);
+	while (!(1 << (NX_NAND_INT_READY_START + nc->slotid))) {
+		/* Timeout */
+		if(did_timeout()) {
+			printk("TIMEOUT: Write \r\n");
+			return;
+		}
+
+		/* Get Page done */
+		if(int_status & NX_NAND_INT_SEQ_WRITE) {
+			writel(NX_NAND_INT_SEQ_WRITE, (nx_nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+		}
+		int_status = readl(nx_nc->ctrl_base + INT_STATUS_OFFSET);
+	}
+
+	/* Clear interrupt */
+	writel(int_status, (nx_nc->ctrl_base + INT_CLR_STATUS_OFFSET));
+
+	/* Disable interrupt */
+	writel(intr, (nx_nc->ctrl_base + INT_CLR_ENABLE_OFFSET));
+
+	/* Disable Flow control */
+/*	writel(0, (nx_nc->ctrl_base + DMA_CTRL_OFFSET)); */
+
+	DBG_PRINT(("< IP2017 nx_nand_write_page_raw leave \r\n"));
+
+	return;
+}
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+/**
+* nx_nand_write_page - Write 1 page data into chip when HW ECC enabled
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @buf: Data buffer
+*
+* Write a full page + oob into the buffer
+*/
+static void nx_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+				  const uint8_t *buf)
+{
+	/* write page */
+	nx_nand_write_page_raw(mtd, chip, buf);
+
+	return;
+}
+#endif
+
+static uint8_t temp_buf[NAND_MAX_PAGESIZE+NAND_MAX_OOBSIZE];
+#define OOB_BYTES_PER_BLK (16)
+
+/**
+* nx_nand_write_oob - Write OOB data
+* @mtd: MTD information structure
+* @chip: Chip information structure
+* @page: Page address
+*
+* Write OOB data into the chip
+*/
+static int nx_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+				  int page)
+{
+	struct nx_nand_ctrl *nc = chip->priv;
+	int status = 0, sndcmd = 1;
+  const uint8_t *buf = chip->oob_poi;
+  int length;
+	int column, addr, i;
+	uint16_t	data;
+	uint32_t page_cfg;
+	int	ecc_old, aes_old;
+	uint8_t	*oob_poi_orig, *temp1;
+
+	DBG_PRINT(("> IP2017 nx_nand_write_oob enter \r\n"));
+
+	if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+		/* Use Device OOB layout -  write only OOB data */
+		/* No page operation */
+		page_cfg = PAGE_RW_OOB_MSK;
+		writel(page_cfg, (nx_nc->ctrl_base + PAGE_RW_OFFSET));
+
+		/* Send SEQIN command */
+		chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+		/* Write to driver buffer */
+		length = mtd->oobsize;
+		chip->write_buf(mtd, buf, length);
+
+		/* Check if CE DON't care is supported */
+		column = nc->cur_col;
+		i = 0;
+
+		while(length) {
+			/* Send Address & cmd cycles */
+			if(sndcmd) {
+				/* Send SEQIN comand */
+				nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+
+				/* Send address cycles */
+				addr = column & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 0);
+
+				if(nc->lb_chip) {
+					addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+					nx_nand_cmd_addr(nc, 0, addr, 0);
+				}
+
+				addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+				nx_nand_cmd_addr(nc, 0, addr, 0);
+
+				if(nc->lb_chip) {
+					/* if > 2Gb, extra address cycle */
+					if (chip->chipsize > (1 << 28)) {
+						addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 0);
+
+						addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 1);
+					}
+					else {
+						addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 1);
+					}
+				}
+				else {
+					/* if > 64Mb, extra adddress cycle */
+					if (chip->chipsize > (32 << 20)) {
+						addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 0);
+
+						addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 1);
+					}
+					else {
+						addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+						nx_nand_cmd_addr(nc, 0, addr, 1);
+					}
+				}
+				sndcmd = 0;
+			}
+
+			/* Write data into chip */
+			data = buf[i];
+			writel(data, nx_nc->ctrl_base + SINGLE_WRITE_OFFSET);
+
+			length--;
+			i++;
+			if(!nx_nc->cedontcare) {
+				sndcmd = 1;
+				column++;
+			}
+		}
+
+		/* write PAGEPROG command */
+		nx_nand_cmd_addr(nc, 1, NAND_CMD_PAGEPROG, 1);
+	}
+	else {
+		/* Use IP_2017 OOB layout - write page */
+		/* Store ECC,AES values & Disbale */
+		ecc_old = chip->ecc.mode;
+		aes_old = nc->aes;
+		oob_poi_orig = chip->oob_poi;
+		chip->ecc.mode = NAND_ECC_NONE;
+		nc->aes = 0;
+
+		/* Send SEQIN command */
+		chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
+
+		/* Write dummy_buf for page write */
+		memset(temp_buf, 0xff, (mtd->writesize+mtd->oobsize));
+
+		/* copy OOB */
+		temp1 = temp_buf;
+		for(i=0; i < nc->num_blks; i++) {
+			temp1 += NX_NAND_BLK_SIZE;
+			memcpy(temp1, (chip->oob_poi + (i * OOB_BYTES_PER_BLK)), OOB_BYTES_PER_BLK);
+			temp1 += OOB_BYTES_PER_BLK;
+		}
+		chip->oob_poi = &temp_buf[mtd->writesize];
+
+		/* Call write page raw */
+		nx_nand_write_page_raw(mtd, chip, temp_buf);
+
+		/* Restore ECC,AES values & Disbale */
+		chip->oob_poi = oob_poi_orig;
+		chip->ecc.mode = ecc_old;
+		nc->aes = aes_old;
+	}
+
+	/* Send command to program the OOB data */
+  chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+  status = chip->waitfunc(mtd, chip);
+  DBG_PRINT(("< IP2017 nx_nand_write_oob leave \r\n"));
+
+  return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/**
+* nx_nand_command - Command function for small page chips
+* @mtd: MTD information structure
+* @cmd: Command
+* @column: Column address
+* @page_addr: Page address
+*
+* Command control function:
+*/
+static void nx_nand_command(struct mtd_info *mtd, unsigned int cmd,
+			     int column, int page_addr)
+{
+	struct nand_chip 		*chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+	uint32_t page_cfg;
+
+	/* Store the command, colmn & page address */
+	nc->cur_cmd = cmd;
+	if(column == -1)
+		column = 0;
+	nc->cur_col = column;
+	if(page_addr == -1)
+		page_addr = 0;
+	nc->cur_page = page_addr;
+	nc->mtd = mtd;
+	/*
+	 * Issue the correct first command, when we write to
+	 * the device.
+	 */
+	switch(cmd) {
+	case NAND_CMD_SEQIN:
+		nc->offset = 0;
+		/* Address & command sent in write_page_raw */
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		/* command will be sent as post write command */
+		break;
+
+	case NAND_CMD_RESET:
+	case NAND_CMD_STATUS:
+		nx_nand_cmd_addr(nc, 1, cmd, 1);
+		break;
+
+	case NAND_CMD_ERASE1:
+		nx_nand_erase(nc);
+		break;
+
+	case NAND_CMD_ERASE2:
+		/* Already done in CMD_ERASE1 */
+		break;
+
+	case NAND_CMD_READ0:
+		nc->offset = 0;
+		nx_nand_read(nc);
+		break;
+
+	case NAND_CMD_READOOB:
+		/* use READ0 command */
+		nc->offset = mtd->writesize;
+		nx_nand_read(nc);
+		break;
+
+	case NAND_CMD_READID:
+
+		/* No Page operation */
+		page_cfg = 0;
+		if(nc->aes) {
+			page_cfg |= PAGE_RW_AES_MSK;
+		}
+		if(chip->ecc.mode == NAND_ECC_HW) {
+			page_cfg |= PAGE_RW_ECC_MSK;
+		}
+		writel(page_cfg, (nx_nc->ctrl_base + PAGE_RW_OFFSET));
+
+		nx_nand_cmd_addr(nc, 1, cmd, 0);
+		nx_nand_cmd_addr(nc, 0, column, 1);
+		break;
+
+	default:
+		printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+	}
+}
+
+/**
+* nx_nand_command_lp - Command function for large page chips
+* @mtd: MTD information structure
+* @cmd: Command
+* @column: Column address
+* @page_addr: Page address
+*
+* Command control function:
+*/
+static void nx_nand_command_lp(struct mtd_info *mtd, unsigned int cmd,
+			     int column, int page_addr)
+{
+	uint32_t	page_cfg;
+	struct nand_chip 		*chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+
+	/* Store the command, colmn & page address */
+	if(cmd == NAND_CMD_READOOB) {
+		cmd = NAND_CMD_READ0;
+
+		/* If Device OOB layout, read data in read_OOB function */
+		if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+			nc->cur_cmd = cmd;
+			nc->cur_col = mtd->writesize;
+			nc->cur_page = page_addr;
+			return;
+		}
+	}
+
+	nc->cur_cmd = cmd;
+	if(column == -1)
+		column = 0;
+	nc->cur_col = column;
+	if(page_addr == -1)
+		page_addr = 0;
+	nc->cur_page =  (page_addr);
+	nc->mtd = mtd;
+
+	/*
+	 * Issue the correct first command, when we write to
+	 * the device.
+	 */
+	switch(cmd) {
+	case NAND_CMD_SEQIN:
+		nc->offset = column;
+		/* Address cycles & command will be sent in write_page_raw */
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		break;
+
+	case NAND_CMD_RESET:
+	case NAND_CMD_STATUS:
+		nx_nand_cmd_addr(nc, 1, cmd, 1);
+		break;
+
+	case NAND_CMD_ERASE1:
+		nx_nand_erase(nc);
+		break;
+
+	case NAND_CMD_ERASE2:
+		/* Already done in CMD_ERASE1 */
+		break;
+
+	case NAND_CMD_READ0:
+		nc->offset = column;
+		nx_nand_read(nc);
+		break;
+
+	case NAND_CMD_READID:
+		/* No Page operation */
+		page_cfg = 0;
+		if(nc->aes) {
+			page_cfg |= PAGE_RW_AES_MSK;
+		}
+		if(chip->ecc.mode == NAND_ECC_HW) {
+			page_cfg |= PAGE_RW_ECC_MSK;
+		}
+		writel(page_cfg, (nx_nc->ctrl_base + PAGE_RW_OFFSET));
+
+		nx_nand_cmd_addr(nc, 1, cmd, 0);
+		nx_nand_cmd_addr(nc, 0, column, 1);
+		break;
+
+	default:
+		printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+	}
+}
+
+/**
+ * nx_nand_block_bad - Read bad block marker from the chip
+ * @mtd:	MTD device structure
+ * @ofs:	offset from device start
+ * @getchip:	0, if the chip is already selected
+ *
+ * Check, if the block is bad.
+ */
+static int nx_nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
+{
+	struct mtd_oob_ops ops;
+	uint8_t	buf[NAND_MAX_OOBSIZE];
+  int ret;
+	u8 bad;
+	int res = 0;
+	struct nand_chip *chip = mtd->priv;
+
+	mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
+	/* Read OOB data */
+  ops.ooblen = mtd->oobsize;
+  ops.oobbuf = buf;
+  ops.ooboffs = 0;
+  ops.datbuf = NULL;
+  ops.mode = MTD_OOB_PLACE;
+  ret = mtd->read_oob(mtd, ofs, &ops);
+  if (ret) {
+		printk(KERN_INFO "READOOB failed 0x%x \r\n", ret);
+		mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
+    return ret;
+	}
+	mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
+
+	/* Check the bad block marker */
+	bad = buf[chip->badblockpos];
+	if (bad != 0xff) {
+		res = 1;
+	}
+
+	return res;
+}
+
+/**
+* nx_nand_verify_buf - Verify user buffer with read back data
+* @mtd: MTD information structure
+* @buf: User buffer
+* @len: Size
+*
+* Command control function:
+*/
+static int nx_nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf,
+		int len)
+{
+	int i,status = 0;
+	struct nand_chip 		*chip= mtd->priv;
+	struct nx_nand_ctrl *nc = chip->priv;
+
+	/* After READ0 is sent, data will be available in driver buffer */
+	for(i=0; i < len; i++) {
+		if(buf[i] != nc->dmabuf[i]){
+			printk(KERN_INFO "Data mismatch at %d W: 0x%x R: 0x%x\r\n", i, buf[i], nc->dmabuf[i]);
+			status = -EIO;
+			break;
+		}
+	}
+
+	return status;
+}
+
+/* For Testing - To be removed */
+#define  DEV0_TYPE 			(0x0004C)
+#define  DEV0_TIME0			(0x00050)
+#define  DEV0_TIME1			(0x00054)
+/* For Testing - To be removed */
+
+#define CACHE_LINE_SIZE (32)
+#define CACHE_LINE_MASK (CACHE_LINE_SIZE - 1)
+
+/**
+* board_nand_init - NAND Initialisation function
+* @chip: NAND chip structure
+*
+* Repartition a device
+*/
+int board_nand_init(struct nand_chip *chip)
+{
+	uint32_t	mod_config, dev_type, page_size;
+	int page, oob;
+	int ret;
+
+	/* Allocate memory NAND control for structure */
+	if(!nx_nc) {
+			nx_nc = kzalloc(sizeof(struct nx_nand_ctrl), GFP_KERNEL);
+			if(!nx_nc) {
+				printk("board_nand_init: nx_nc memory alloc failure \r\n");
+				return -ENOMEM;
+			}
+	}
+
+	/* For Testing - To be removed */
+	//glb_misc2 = readl((unsigned long *)(0xBBE63600));
+	//glb_misc2 |= 0x00000100;
+	//writel(glb_misc2, (unsigned long *)(0xBBE63600));
+
+#ifdef  CONFIG_PNX84XX
+ 	writel(0x00000010, (unsigned long *) (PNX8XXX_EFM_BASE + DEV0_TYPE));
+	writel(0x02644448, (unsigned long *) (PNX8XXX_EFM_BASE + DEV0_TIME0));
+	writel(0x01008444, (unsigned long *) (PNX8XXX_EFM_BASE + DEV0_TIME1));
+#endif
+
+	/* Initialise NAND control structure */
+	nx_nc->ctrl_base = (void __iomem *) KSEG1ADDR(PNX8XXX_EFM_BASE);
+
+	/* Read Module configuration */
+	mod_config = readl(nx_nc->ctrl_base + MOD_CONFIG_OFFSET);
+	if(mod_config & MOD_CONFIG_AES_MSK) {
+		nx_nc->aes = 1;
+	}
+	nx_nc->slotid = 0;
+
+	/* Read Flash configuration */
+	mod_config = readl(nx_nc->ctrl_base + DEV_TYPE0_OFFSET);
+	if(mod_config & DEV_TYPE0_CEN_DONT_MSK) {
+		nx_nc->cedontcare = 1;
+	}
+	nx_nc->lb_chip = 0;
+
+	/* NAND Chip structure */
+	chip->priv = nx_nc;
+	chip->chip_delay = 0;
+	chip->options = NAND_NO_AUTOINCR | NAND_ALLOW_CLEAR_BBT |
+		NAND_NO_SUBPAGE_WRITE;
+	chip->select_chip = nx_nand_select_chip;
+	chip->dev_ready = nx_nand_dev_ready;
+	dev_type = mod_config & DEV_TYPE0_DATA_WIDTH_MSK;
+	if (dev_type) {
+		chip->options |= NAND_BUSWIDTH_16;
+		chip->read_byte = nx_nand_read_byte16;
+	} else {
+		chip->read_byte = nx_nand_read_byte;
+	}
+	chip->cmdfunc = nx_nand_command;
+
+	/* Page & OOB size calculation */
+	page_size = (mod_config & DEV_TYPE0_PAGE_SIZE_MASK) >> DEV_TYPE0_PAGE_SIZE_POS;
+	switch (page_size) {
+		case 0:
+			page = 512;
+			oob = 16;
+			break;
+
+		case 1:
+			page = 2048;
+			oob = 64;
+			nx_nc->lb_chip = 1;
+			chip->cmdfunc = nx_nand_command_lp;
+			break;
+
+		case 2:
+			page = 4096;
+			oob = 128;
+			nx_nc->lb_chip = 1;
+			chip->cmdfunc = nx_nand_command_lp;
+			break;
+
+		default:
+			printk("Invalid page configuration %d\n", page_size);
+			return -ENXIO;
+	}
+
+	chip->ecc.read_page_raw = nx_nand_read_page_raw;
+	chip->ecc.write_page_raw = nx_nand_write_page_raw;
+	chip->ecc.read_oob = nx_nand_read_oob;
+	chip->ecc.write_oob = nx_nand_write_oob;
+	chip->read_buf = nx_nand_read_buf;
+	chip->write_buf = nx_nand_write_buf;
+	chip->verify_buf = nx_nand_verify_buf;
+	chip->block_bad = nx_nand_block_bad;
+
+#ifdef CONFIG_MTD_NX_NAND_HWECC
+	chip->ecc.read_page = nx_nand_read_page;
+	chip->ecc.write_page = nx_nand_write_page;
+	chip->ecc.mode = NAND_ECC_HW;
+	chip->ecc.calculate = nx_nand_calculate_ecc;
+	chip->ecc.correct = nx_nand_correct_data;
+	chip->ecc.hwctl = nx_nand_hwctl;
+	chip->ecc.size = 512;
+	chip->ecc.bytes = 12;
+
+	/* Use BBT decsriptors */
+	chip->bbt_td = &nx_bbt_main;
+	chip->bbt_md = &nx_bbt_mirror;
+
+	/* Use OOB layout */
+	switch (oob) {
+		case 16:
+			chip->ecc.layout = &nx_nand_oob_16;
+			break;
+
+		case 64:
+			chip->ecc.layout = &nx_nand_oob_64;
+			break;
+
+		case 128:
+			chip->ecc.layout = &nx_nand_oob_128;
+			break;
+
+		default:
+			printk("No oob scheme defined for oobsize %d\n", oob);
+			return -ENXIO;
+	}
+#endif
+
+#ifdef CONFIG_MTD_NX_NAND_SWECC
+	chip->ecc.mode = NAND_ECC_SOFT;
+#endif
+
+#ifdef CONFIG_MTD_NX_NAND_NONEECC
+	chip->ecc.read_page = nx_nand_read_page_raw;
+	chip->ecc.write_page = nx_nand_write_page_raw;
+	chip->ecc.mode = NAND_ECC_NONE;
+#endif
+
+	/* Calculate number of 512byte blocks in a page */
+	nx_nc->num_blks = page >> 9;
+
+	/* Allocate ECC status array */
+	nx_nc->ecc_status = kzalloc(sizeof(int) * nx_nc->num_blks, GFP_KERNEL);
+	if(!nx_nc->ecc_status) {
+		printk(KERN_ERR "board_nand_init: ECC status alloc \r\n");
+		ret = -ENOMEM;
+		goto out_free1;
+	}
+
+	/* Allocate internal driver buffer */
+	nx_nc->dmabuf_unalgn =  kzalloc( ((page + oob) + (CACHE_LINE_SIZE * 2)),
+			      GFP_DMA | GFP_KERNEL);
+	if(!nx_nc->dmabuf_unalgn) {
+		printk(KERN_ERR "board_nand_init: DMA buf alloc \r\n");
+		ret = -ENOMEM;
+		goto out_free2;
+	}
+	nx_nc->dmabuf = (uint8_t *)((unsigned long)(nx_nc->dmabuf_unalgn + CACHE_LINE_SIZE - 1)
+						& (~CACHE_LINE_MASK));
+	invalidate_dcache_range(nx_nc->dmabuf, (nx_nc->dmabuf + page + oob));
+
+	chip->options |= NAND_ALLOW_CLEAR_BBT | NAND_NO_SUBPAGE_WRITE | NAND_USE_FLASH_BBT;
+
+	ret = nx_dmac_init();
+	if(ret) {
+		printf(KERN_ERR "board_nand_init:DMAC init failed \r\n");
+		return -EIO;
+	}
+
+	return 0;
+
+out_free2:
+	kfree(nx_nc->ecc_status);
+
+out_free1:
+	kfree(nx_nc);
+
+	return ret;
+}
+
diff --git a/drivers/mtd/nand/nx_nand_ip2070.h b/drivers/mtd/nand/nx_nand_ip2070.h
new file mode 100644
index 0000000..58e807c
--- /dev/null
+++ b/drivers/mtd/nand/nx_nand_ip2070.h
@@ -0,0 +1,171 @@
+/*
+ * Device driver for NAND flash connected IP_2070 EFM.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version    Date          Remarks
+ * 0.0.1		20080318		Draft-Initial version
+ */
+
+#include <common.h>
+#include <watchdog.h>
+#include <linux/err.h>
+#include <linux/mtd/compat.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+
+/* Fix me: To be taken from glb.h */
+#define		PNX8XXX_EFM_BASE		(PNX84XX_GCS_BASE + PNX84XX_GCS_IP2017_OFSET)
+#define 	NX_NAND_AHB_BUF			(0x40000000) 		/* DMAC Flow conttrol */
+
+/* Max Data buffer size */
+#define NX_NAND_BLK_SIZE          (512)
+
+/* Max OOB buffer size */
+#define NX_NAND_MAX_OOB_SIZE      (128)
+
+/* Maximum AHB buffer size */
+#define NX_NAND_AHB_BUF_MAX_SIZE  (NX_NAND_BLK_SIZE+NX_NAND_MAX_OOB_SIZE)
+
+/* IP_2017 Register offsets */
+#define CMD_ADDR_FIFO_OFFSET          (0x000) /**< EFMC Nand Flash Command / Address FIFO register */
+#define PAGE_RW_OFFSET                (0x004) /**< EFMC Nand Flash Page Read/Write register */
+#define NAND_STATUS_OFFSET            (0x008) /** Nand Flash Status registers */
+#define DMA_CTRL_OFFSET               (0x00C) /** DMA Control Register */
+#define EBI_CTRL_OFFSET               (0x010) /**<  EBI Pin-Sharing Control Register*/
+#define AHB_LATENCY_OFFSET            (0x014) /**< AX/AHB Latency Register */
+#define APB_LATENCY_OFFSET            (0x018) /**<  APB Latency Register*/
+#define APB_ERROR_GEN_OFFSET          (0x01C) /**<  APB Error Register */
+#define AES_KEY1_OFFSET               (0x020) /**< AES Key Register(1st 32bit) */
+#define AES_KEY2_OFFSET               (0x024) /**< AES Key Register(2nd 32bit) */
+#define AES_KEY3_OFFSET               (0x028) /**< AES Key Register (3rd 32bit) */
+#define AES_KEY4_OFFSET               (0x02C) /**< AES Key Register (4th 32bit) */
+#define AES_IV1_OFFSET                (0x030) /**<  AES Initial Value Register (1st 32bit)*/
+#define AES_IV2_OFFSET                (0x034) /**< AES Initial Value Register (2nd32bit) */
+#define AES_IV3_OFFSET                (0x038) /**< AES Initial Value Register (3rd 32bit) */
+#define AES_IV4_OFFSET                (0x03C) /**< AES Initial Value Register (4th 32bit) */
+#define AES_STATUS_OFFSET             (0x040) /**< AES Status Register */
+#define SINGLE_READ_OFFSET            (0x044) /**<  Nand Flash SInge Read Register*/
+#define SINGLE_WRITE_OFFSET           (0x048) /**< Nand Flash SInge Write Register */
+#define DEV_TYPE0_OFFSET              (0x04C) /**<  Nand Flash Device Type Register for CEn[n]*/
+#define DEV_TYPE0_DIFF                (0x00C) /**  */
+#define DEV_TIMING0_OFFSET            (0x050) /**<Nand Flash Device Timing Register #0 for CEn[n]  */
+#define DEV_TIMING0_DIFF              (0x00C) /**  */
+#define DEV_TIMING1_OFFSET            (0x054) /**< Nand Flash Device Timing Register #1 for CEn[n] */
+#define DEV_TIMING1_DIFF              (0x00C) /**  */
+#define MOD_CONFIG_OFFSET             (0xFD4) /**< Module Configuration Register */
+#define INT_CLR_ENABLE_OFFSET         (0xFD8) /** Interrupt Clear Enable Register */
+#define INT_SET_ENABLE_OFFSET         (0xFDC) /** Interrupt Set Enable Register */
+#define INT_STATUS_OFFSET             (0xFE0) /** Interrupt Status Register */
+#define INT_ENABLE_OFFSET             (0xFE4) /** Interrupt Enable Register */
+#define INT_CLR_STATUS_OFFSET         (0xFE8) /** Interrupt Clear Status Set Register */
+#define INT_SET_STATUS_OFFSET         (0xFEC) /** Interrupt Set Status Set Register */
+#define SWRESET_OFFSET                (0xFF0) /**< Software reset register */
+#define POWER_DOWN_OFFSET             (0xFF4) /**< Power down register */
+#define EXT_MODID_OFFSET              (0xFF8) /**< Dynamic memory write recovery time register */
+#define MODID_OFFSET                  (0xFFC) /**< Dynamic memory write recovery time register */
+
+/* Module Config Register bits */
+#define MOD_CONFIG_AES_MSK            	(0x00000020)
+
+/* Device Type Register bits */
+#define DEV_TYPE0_CEN_DONT_MSK   		(0x00000004)
+#define DEV_TYPE0_DATA_WIDTH_MSK 		(0x00000003)
+#define DEV_TYPE0_PAGE_SIZE_MASK      	(0x00000070)
+#define DEV_TYPE0_PAGE_SIZE_POS			(4)
+
+/* NAND Status register bits */
+#define	NAND_STATUS_RB_DEV0				(0x00000001)
+
+/* Cmd FIFO bit information */
+#define CMD_FIFO_CE_POS    				(19)
+#define CMD_FIFO_CE_MSK					(0x00000003)
+#define CMD_FIFO_CYCLE_POS    			(16)
+#define CMD_FIFO_CYCLE_MSK    			(0x00000003)
+#define CMD_FIFO_LAST_POS    			(18)
+#define CMD_FIFO_LAST_MSK	   			(0x00000001)
+#define CMD_FIFO_IO_POS					(0)
+#define CMD_FIFO_IO_MSK					(0x0000FFFF)
+
+/* Interrupt Register bits */
+#define NX_NAND_INT_READY_START   (20)
+#define NX_NAND_INT_ALL           (0x00FFFFFFFF)
+#define NX_NAND_INT_OOB_READ      (1<<0)
+#define NX_NAND_INT_OOB_WRITE     (1<<1)
+#define NX_NAND_INT_BLK_READ      (1<<2)
+#define NX_NAND_INT_BLK_WRITE     (1<<3)
+#define NX_NAND_INT_ENC           (1<<4)
+#define NX_NAND_INT_DEC           (1<<5)
+#define NX_NAND_INT_DEC_0_ERR     (1<<6)
+#define NX_NAND_INT_DEC_1_ERR     (1<<7)
+#define NX_NAND_INT_DEC_2_ERR     (1<<8)
+#define NX_NAND_INT_DEC_3_ERR     (1<<9)
+#define NX_NAND_INT_DEC_4_ERR     (1<<10)
+#define NX_NAND_INT_DEC_5_ERR     (1<<11)
+#define NX_NAND_INT_DEC_UNCOR     (1<<12)
+#define NX_NAND_INT_AES_DEC       (1<<13)
+#define NX_NAND_INT_SEQ_READ      (1<<14)
+#define NX_NAND_INT_SEQ_WRITE     (1<<15)
+#define NX_NAND_INT_BUSY1         (1<<16)
+#define NX_NAND_INT_BUSY2         (1<<17)
+#define NX_NAND_INT_BUSY3         (1<<18)
+#define NX_NAND_INT_BUSY4         (1<<19)
+#define NX_NAND_INT_READY1        (1<<20)
+#define NX_NAND_INT_READY2        (1<<21)
+#define NX_NAND_INT_READY3        (1<<22)
+#define NX_NAND_INT_READY4        (1<<23)
+
+/* DMA control register bits */
+#define DMA_CTRL_PER_2_MEM        (0x1)
+#define DMA_CTRL_MEM_2_PER        (0x2)
+
+/*  Page Operation register bits */
+#define PAGE_RW_OOB_MSK           (0x00000010)
+#define PAGE_RW_ECC_MSK           (0x00000004)
+#define PAGE_RW_AES_MSK           (0x00000008)
+#define PAGE_RW_PAGE_WRITE_MSK    (0x00000002)
+#define PAGE_RW_PAGE_READ_MSK     (0x00000001)
+
+#define NX_NAND_SP_ADDR_MASK      (0x000000FF)
+/**
+* NAND control structure
+*/
+struct nx_nand_ctrl {
+	struct mtd_info       *mtd;          /* MTD information structure */
+  uint8_t               *dmabuf;    	/* DMA buffer */
+  uint8_t				*dmabuf_unalgn; /* Unaligned buffer */
+  int                   slotid;     	/* current chip number */
+  int                   cur_col;    	/* Current column address */
+  int                   cur_page;   	/* Current page address */
+  int                   cur_cmd;   		/* Current page address */
+  int                   lb_chip;   	  /* Large Block chip flag */
+  void __iomem          *ctrl_base; 	/* Controller base address */
+  int                   aes;        	/* AES decryption support */
+  uint32_t              aes_key[4]; 	/* AES 128 bit key */
+  uint32_t              aes_val[4]; 	/* AES initial 128 bit value */
+  int	                num_blks;   	/* # of 512 bytes blocks per page */
+  int	                blk_index;  	/* Block index */
+  int                   *ecc_status;	/* ECC status array */
+  int                   offset;				/* Offset in inetrnal driver buffer */
+  int 					cedontcare;		/* CE dont care support */
+};
diff --git a/drivers/mtd/onenand/Makefile b/drivers/mtd/onenand/Makefile
index 1d35a57..f9a2124 100644
--- a/drivers/mtd/onenand/Makefile
+++ b/drivers/mtd/onenand/Makefile
@@ -26,6 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	:= $(obj)libonenand.a
 
 COBJS-$(CONFIG_CMD_ONENAND)	:= onenand_uboot.o onenand_base.o onenand_bbt.o
+COBJS-$(CONFIG_MTD_NX_ONENAND) += nx_onenand.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/mtd/onenand/nx_onenand.c b/drivers/mtd/onenand/nx_onenand.c
new file mode 100755
index 0000000..2c02588
--- /dev/null
+++ b/drivers/mtd/onenand/nx_onenand.c
@@ -0,0 +1,320 @@
+/*
+ * Device driver for OneNAND flash connected IP_2070 ESMC.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version    Author           Date          Remarks
+ * 0.0.1    Bangaragiri G     20080318    Draft-Initial version
+ */
+
+#include <common.h>
+#include <linux/mtd/compat.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/onenand.h>
+#include <linux/nx_onenand.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+
+#ifdef CONFIG_DMAC_NXP_1902
+#include <linux/nx_dmac_ip1902.h>
+#endif
+
+#define CACHE_LINE_SIZE (32)
+#define CACHE_LINE_MASK (CACHE_LINE_SIZE - 1)
+
+struct nx_onenand_ctrl *nx_onenand=NULL;
+
+static void nx_onenand_rw(void __iomem *addr, unsigned short *data, 
+		int read)
+{
+	unsigned long misc2;
+	unsigned int addr17, addr18, act_off;
+	
+	/* Set ENA bit */
+	misc2 = readl(nx_onenand->glb_misc2);
+	misc2 |= ONENAND_CFG_ENA;
+
+	/* Get DCSN 18 bit Address */
+	addr17 = ((unsigned int) addr) - ((unsigned int)nx_onenand->chip->base); 
+	addr18 = addr17  << 1;
+	act_off = addr18 & (~ONENAND_ADDR_MSB_BIT);
+	addr = nx_onenand->chip->base + act_off;
+	if(addr18 & ONENAND_ADDR_MSB_BIT) {
+		misc2 |= (1 << ONENAND_ADDR_MSB_POS);
+	}
+	else {
+		misc2 &= (~(1 << ONENAND_ADDR_MSB_POS));
+	}
+	writel(misc2, nx_onenand->glb_misc2);
+
+	if(read) {
+		*data = readw(addr);
+	}
+	else {
+		writew(*data, addr);	
+	}
+	
+	/* Reset ENA bit */
+	misc2 = readl(nx_onenand->glb_misc2);
+	misc2 &= ~ONENAND_CFG_ENA;
+	writel(misc2, nx_onenand->glb_misc2);
+
+	return;
+}
+
+/**
+ * nx_onenand_readw - Read OneNAND register
+ * @param addr    address to read
+ *
+ * Read OneNAND register
+ */
+static unsigned short nx_onenand_readw(void __iomem *addr)
+{
+	
+	unsigned short data;
+	
+	/* Read Data */
+	nx_onenand_rw(addr, &data, 1);
+	return data;
+}
+
+/**
+ * nx_onenand_writew - Write OneNAND register with value
+ * @param value   value to write
+ * @param addr    address to write
+ *
+ * Write OneNAND register with value
+ */
+static void nx_onenand_writew(unsigned short value, void __iomem *addr)
+{
+	nx_onenand_rw(addr, &value, 0);
+}
+
+
+#ifdef CONFIG_DMAC_NXP_1902
+
+void nx_onenand_dmac_tfr(struct mtd_info *mtd, unsigned char *buffer, 
+		int offset, size_t count, int read)	
+{
+	struct onenand_chip *this = mtd->priv;
+	nx_dmac_tfr_t       req;
+	nx_dmac_stgt_t      stgt[1];
+	int chanid, status;
+	unsigned short word;
+	unsigned char *word1;
+	void __iomem *addr;
+	int i;
+	unsigned long misc2;
+	
+	/* Reset ENA bit */
+	misc2 = readl(nx_onenand->glb_misc2);
+	misc2 &= ~ONENAND_CFG_ENA;
+	writel(misc2, nx_onenand->glb_misc2);
+
+	if(count < 4) {
+		addr = (void __iomem *)(offset + this->base);
+		word1 = (unsigned char *) buffer;
+		for(i=0; i < (count >> 1); i++)
+		{
+			if(read) {
+				word = this->read_word(addr + i);
+				word1[(2 * i)] = word & 0xFF;
+				word1[(2 * i)+1] = (word >>8) & 0xFF;
+			}
+			else {
+				word = (word1[(2*i)+1] << 8) | word1[2*i];
+				this->write_word(word, (addr + i));	
+			}	
+		}
+
+	}
+	else {	
+		/* Set up DMAC */
+		if(read) {
+			stgt[0].src_addr = (nx_onenand->ahb_base + offset);
+			stgt[0].dst_addr = virt_to_phys(nx_onenand->dmabuf);
+			stgt[0].tfr_size = count >> 1;    
+			stgt[0].flowctl = nx_dmac_mem2mem_dma;         
+			stgt[0].src_brst = nx_dmac_8;
+			stgt[0].dst_brst = nx_dmac_1;
+			stgt[0].src_width = nx_dmac_width_16;
+			stgt[0].dst_width = nx_dmac_width_32;
+			stgt[0].src_ahb = 1;		  /* Source AHB master 0 */
+			stgt[0].dst_ahb = 0;      /* Dest AHB master 1 */
+		}
+		else {
+			memcpy(nx_onenand->dmabuf, buffer, count);	
+			flush_dcache_range(nx_onenand->dmabuf, (nx_onenand->dmabuf + count));
+
+			stgt[0].src_addr = virt_to_phys(nx_onenand->dmabuf);
+			stgt[0].dst_addr = (offset + nx_onenand->ahb_base);
+			stgt[0].tfr_size = count >> 2;    
+			stgt[0].flowctl = nx_dmac_mem2mem_dma;         
+			stgt[0].dst_brst = nx_dmac_1;
+			stgt[0].src_brst = nx_dmac_8;
+			stgt[0].src_width = nx_dmac_width_32;
+			stgt[0].dst_width = nx_dmac_width_16;
+			stgt[0].src_ahb = 0;		  /* Source AHB master 0 */
+			stgt[0].dst_ahb = 1;              /* Dest AHB master 1 */
+		}
+ 		stgt[0].src_per = 0;		          
+ 		stgt[0].dst_per = 0;
+ 		stgt[0].src_inc = 1;
+ 		stgt[0].dst_inc = 1;
+		req.num_reqs = 1;
+		req.req = &stgt[0];
+
+		/* Start DMAC */
+		chanid = nx_dmac_tfr(&req);
+		if(chanid < 0) {
+			printk(KERN_ERR "nx_onenand: Start DMAC \r\n");
+			return;
+		}
+
+		/* Complete DMAC transfer */
+		status = nx_dmac_tfr_comp(chanid);
+		if(status) {
+			printk(KERN_ERR "nx_onenand: COMP DMAC \r\n");	
+			return;
+		}
+
+		if(read) {
+			invalidate_dcache_range(nx_onenand->dmabuf, (nx_onenand->dmabuf + count));
+			memcpy(buffer, nx_onenand->dmabuf, count);	
+		}
+	}
+	
+	/* Reset ENA bit */
+	misc2 = readl(nx_onenand->glb_misc2);
+	misc2 |= ONENAND_CFG_ENA;
+	writel(misc2, nx_onenand->glb_misc2);
+}	
+
+EXPORT_SYMBOL(nx_onenand_dmac_tfr);
+
+#else
+
+void nx_memcpy(void __iomem *addr, unsigned char *data, size_t count, 
+		int read)
+{
+	unsigned long misc2;
+	unsigned int addr17, addr18, act_off;
+	int i;
+	unsigned short *src, *dst;
+	unsigned short word;	
+	
+	/* Set ENA bit */
+	misc2 = readl(nx_onenand->glb_misc2);
+	misc2 |= ONENAND_CFG_ENA;
+
+	/* Get DCSN 18 bit Address */
+	addr17 = ((unsigned int) addr) - ((unsigned int)nx_onenand->chip->base); 
+	addr18 = addr17  << 1;
+	act_off = addr18 & (~ONENAND_ADDR_MSB_BIT);
+	addr = nx_onenand->chip->base + act_off;
+	if(addr18 & ONENAND_ADDR_MSB_BIT) {
+		misc2 |= (1 << ONENAND_ADDR_MSB_POS);
+	}
+	else {
+		misc2 &= (~(1 << ONENAND_ADDR_MSB_POS));
+	}
+	writel(misc2, nx_onenand->glb_misc2);
+
+	if(read) {
+		src = (unsigned short *)addr;
+		for(i=0; i< (count >> 1); i++) {
+			word = readw(src + i);
+			data[(2 * i)] = word & 0xFF;
+			data[(2 * i)+1] = (word >>8) & 0xFF;
+		}
+	}
+	else {
+		dst = (unsigned short *)addr;
+		for(i=0; i< (count >> 1); i++) {
+			word = ((data[(2 * i)+1] << 8) | data[2 * i]);
+			writew(word, (dst + i));
+		}
+	}
+	
+	/* Reset ENA bit */
+	misc2 = readl(nx_onenand->glb_misc2);
+	misc2 &= ~ONENAND_CFG_ENA;
+	writel(misc2, nx_onenand->glb_misc2);
+
+	return;
+}
+
+EXPORT_SYMBOL(nx_memcpy);
+
+#endif /* CONFIG_MTD_NX_NAND_DMAC */
+
+
+void nx_onenand_init(struct mtd_info *mtd, struct onenand_chip *chip)
+{
+	int ret, page_size, oob_size, buf_size,slot_num;
+
+	/* Allocate memory for onenand structure */ 
+	nx_onenand = kzalloc(sizeof(struct nx_onenand_ctrl), GFP_KERNEL);
+	if (!nx_onenand) {
+		printk(KERN_ERR "nx_onenand: Dev Mem alloc failure \r\n");
+		return;
+	}
+	nx_onenand->chip = chip;
+	nx_onenand->mtd = mtd;
+	nx_onenand->glb_misc2 = (void __iomem *) KSEG1ADDR(0x1BE63600);
+	
+	/* Store Base address */
+	nx_onenand->onenand_base_phys = CONFIG_SYS_ONENAND_BASE;
+
+	/* Initialise chip structre */
+	chip->base = (void __iomem *) KSEG1ADDR(nx_onenand->onenand_base_phys);
+
+	/* Find AHB base address */
+	slot_num = readl(nx_onenand->glb_misc2);
+	slot_num >>= GLB_MISC2_ONENAND_SLOT_POS;
+	slot_num &= 0x3;
+	nx_onenand->ahb_base = (slot_num * ONENAND_2016_AHB_SIZE);
+
+	/* Initilise the functions */
+	chip->mmcontrol = NULL;
+	chip->read_word = nx_onenand_readw;
+	chip->write_word = nx_onenand_writew;
+	mtd->name = "nxonenand";
+	mtd->priv = chip;
+
+	/* Allocate DMA buffer */
+	buf_size = MAX_ONENAND_PAGESIZE;
+	nx_onenand->dmabuf_unalgn =  kzalloc( (buf_size + (CACHE_LINE_SIZE * 2)),
+            GFP_DMA | GFP_KERNEL);
+  if(!nx_onenand->dmabuf_unalgn) {
+    printk(KERN_ERR "onenand_init: DMA buf alloc \r\n");
+    return;
+  }
+  nx_onenand->dmabuf = (uint8_t *)((unsigned long)(nx_onenand->dmabuf_unalgn + CACHE_LINE_SIZE - 1)
+            & (~CACHE_LINE_MASK));
+  invalidate_dcache_range(nx_onenand->dmabuf, (nx_onenand->dmabuf + buf_size));
+	
+	/* DMAC init */
+	ret = nx_dmac_init();
+	if(ret) {
+		printf(KERN_ERR "onenand_init:DMAC init failed \r\n");
+		return;
+	}
+}
diff --git a/drivers/mtd/onenand/onenand_base.c b/drivers/mtd/onenand/onenand_base.c
index d482437..48024be 100644
--- a/drivers/mtd/onenand/onenand_base.c
+++ b/drivers/mtd/onenand/onenand_base.c
@@ -23,6 +23,8 @@
 #include <asm/errno.h>
 #include <malloc.h>
 
+#define ONENAND_DEBUG 1
+
 /* It should access 16-bit instead of 8-bit */
 static inline void *memcpy_16(void *dst, const void *src, unsigned int len)
 {
@@ -36,35 +38,6 @@ static inline void *memcpy_16(void *dst, const void *src, unsigned int len)
 	return ret;
 }
 
-/**
- * onenand_oob_64 - oob info for large (2KB) page
- */
-static struct nand_ecclayout onenand_oob_64 = {
-	.eccbytes	= 20,
-	.eccpos		= {
-		8, 9, 10, 11, 12,
-		24, 25, 26, 27, 28,
-		40, 41, 42, 43, 44,
-		56, 57, 58, 59, 60,
-		},
-	.oobfree	= {
-		{2, 3}, {14, 2}, {18, 3}, {30, 2},
-		{34, 3}, {46, 2}, {50, 3}, {62, 2}
-	}
-};
-
-/**
- * onenand_oob_32 - oob info for middle (1KB) page
- */
-static struct nand_ecclayout onenand_oob_32 = {
-	.eccbytes	= 10,
-	.eccpos		= {
-		8, 9, 10, 11, 12,
-		24, 25, 26, 27, 28,
-		},
-	.oobfree	= { {2, 3}, {14, 2}, {18, 3}, {30, 2} }
-};
-
 static const unsigned char ffchars[] = {
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	/* 16 */
@@ -107,11 +80,20 @@ static void onenand_writew(unsigned short value, void __iomem * addr)
  *
  * Setup Start Address 1 Register (F100h)
  */
-static int onenand_block_address(struct onenand_chip *this, int block)
+static int onenand_block_address(int device, int block)
 {
-	/* Device Flash Core select, NAND Flash Block Address */
-	if (block & this->density_mask)
-		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
+	if (device & ONENAND_DEVICE_IS_DDP) {
+		/* Device Flash Core select, NAND Flash Block Address */
+		int dfs = 0, density, mask;
+
+		density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
+		mask = (1 << (density + 6));
+
+		if (block & mask)
+			dfs = 1;
+
+		return (dfs << ONENAND_DDP_SHIFT) | (block & (mask - 1));
+	}
 
 	return block;
 }
@@ -124,13 +106,22 @@ static int onenand_block_address(struct onenand_chip *this, int block)
  *
  * Setup Start Address 2 Register (F101h) for DDP
  */
-static int onenand_bufferram_address(struct onenand_chip *this, int block)
+static int onenand_bufferram_address(int device, int block)
 {
-	/* Device BufferRAM Select */
-	if (block & this->density_mask)
-		return ONENAND_DDP_CHIP1;
+	if (device & ONENAND_DEVICE_IS_DDP) {
+		/* Device BufferRAM Select */
+		int dbs = 0, density, mask;
+
+		density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
+		mask = (1 << (density + 6));
 
-	return ONENAND_DDP_CHIP0;
+		if (block & mask)
+			dbs = 1;
+
+		return (dbs << ONENAND_DDP_SHIFT);
+	}
+
+	return 0;
 }
 
 /**
@@ -180,18 +171,6 @@ static int onenand_buffer_address(int dataram1, int sectors, int count)
 }
 
 /**
- * onenand_get_density - [DEFAULT] Get OneNAND density
- * @param dev_id        OneNAND device ID
- *
- * Get OneNAND density from device ID
- */
-static inline int onenand_get_density(int dev_id)
-{
-	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
-	return (density & ONENAND_DEVICE_DENSITY_MASK);
-}
-
-/**
  * onenand_command - [DEFAULT] Send command to OneNAND device
  * @param mtd		MTD device structure
  * @param cmd		the command to be sent
@@ -215,7 +194,6 @@ static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
 	case ONENAND_CMD_UNLOCK:
 	case ONENAND_CMD_LOCK:
 	case ONENAND_CMD_LOCK_TIGHT:
-	case ONENAND_CMD_UNLOCK_ALL:
 		block = -1;
 		page = -1;
 		break;
@@ -236,7 +214,7 @@ static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
 	/* NOTE: The setting order of the registers is very important! */
 	if (cmd == ONENAND_CMD_BUFFERRAM) {
 		/* Select DataRAM for DDP */
-		value = onenand_bufferram_address(this, block);
+		value = onenand_bufferram_address(this->device_id, block);
 		this->write_word(value,
 				 this->base + ONENAND_REG_START_ADDRESS2);
 
@@ -248,14 +226,9 @@ static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
 
 	if (block != -1) {
 		/* Write 'DFS, FBA' of Flash */
-		value = onenand_block_address(this, block);
+		value = onenand_block_address(this->device_id, block);
 		this->write_word(value,
 				 this->base + ONENAND_REG_START_ADDRESS1);
-
-		/* Write 'DFS, FBA' of Flash */
-		value = onenand_bufferram_address(this, block);
-		this->write_word(value,
-				 this->base + ONENAND_REG_START_ADDRESS2);
 	}
 
 	if (page != -1) {
@@ -281,6 +254,15 @@ static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
 		/* Write 'BSA, BSC' of DataRAM */
 		value = onenand_buffer_address(dataram, sectors, count);
 		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
+
+		if (readcmd) {
+			/* Select DataRAM for DDP */
+			value =
+			    onenand_bufferram_address(this->device_id, block);
+			this->write_word(value,
+					 this->base +
+					 ONENAND_REG_START_ADDRESS2);
+		}
 	}
 
 	/* Interrupt clear */
@@ -316,11 +298,14 @@ static int onenand_wait(struct mtd_info *mtd, int state)
 	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
 
 	if (ctrl & ONENAND_CTRL_ERROR) {
-		printk("onenand_wait: controller error = 0x%04x\n", ctrl);
-		if (ctrl & ONENAND_CTRL_LOCK)
-			printk("onenand_wait: it's locked error = 0x%04x\n",
-				ctrl);
+		MTDDEBUG (MTD_DEBUG_LEVEL0,
+			  "onenand_wait: controller error = 0x%04x\n", ctrl);
+		return -EAGAIN;
+	}
 
+	if (ctrl & ONENAND_CTRL_LOCK) {
+		MTDDEBUG (MTD_DEBUG_LEVEL0,
+			  "onenand_wait: it's locked error = 0x%04x\n", ctrl);
 		return -EIO;
 	}
 
@@ -358,6 +343,17 @@ static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
 	return 0;
 }
 
+#ifdef CONFIG_MTD_NX_ONENAND
+
+#ifdef CONFIG_DMAC_NXP_1902
+extern void nx_onenand_dmac_tfr(struct mtd_info *mtd, unsigned char *buffer, 
+		int offset, size_t count, int read);	
+#else
+extern void nx_memcpy(void __iomem *addr, unsigned char *data, size_t count, 
+		int read);
+#endif
+#endif
+
 /**
  * onenand_read_bufferram - [OneNAND Interface] Read the bufferram area
  * @param mtd		MTD data structure
@@ -368,7 +364,7 @@ static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
  *
  * Read the BufferRAM area
  */
-static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
+static int onenand_read_bufferram(struct mtd_info *mtd, int area,
 				  unsigned char *buffer, int offset,
 				  size_t count)
 {
@@ -378,7 +374,18 @@ static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
 	bufferram = this->base + area;
 	bufferram += onenand_bufferram_offset(mtd, area);
 
+#ifdef CONFIG_MTD_NX_ONENAND
+
+#ifdef CONFIG_DMAC_NXP_1902
+  nx_onenand_dmac_tfr(mtd, buffer, (int)((bufferram + offset) - this->base),
+				      count, 1);
+#else
+	nx_memcpy((bufferram + offset), buffer, count, 1);
+#endif /* CONFIG_MTD_NX_NAND_DMAC */
+
+#else
 	memcpy_16(buffer, bufferram + offset, count);
+#endif /* CONFIG_MTD_NX_ONENAND */
 
 	return 0;
 }
@@ -393,7 +400,7 @@ static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
  *
  * Read the BufferRAM area with Sync. Burst Mode
  */
-static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
+static int onenand_sync_read_bufferram(struct mtd_info *mtd, int area,
 				       unsigned char *buffer, int offset,
 				       size_t count)
 {
@@ -405,7 +412,18 @@ static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int ar
 
 	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
 
+#ifdef CONFIG_MTD_NX_ONENAND
+
+#ifdef CONFIG_DMAC_NXP_1902
+  nx_onenand_dmac_tfr(mtd, buffer, (int)((bufferram + offset) - this->base),
+				      count, 1);
+#else
+	nx_memcpy((bufferram + offset), buffer, count, 1);
+#endif /* CONFIG_MTD_NX_NAND_DMAC */
+
+#else
 	memcpy_16(buffer, bufferram + offset, count);
+#endif
 
 	this->mmcontrol(mtd, 0);
 
@@ -422,7 +440,7 @@ static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int ar
  *
  * Write the BufferRAM area
  */
-static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
+static int onenand_write_bufferram(struct mtd_info *mtd, int area,
 				   const unsigned char *buffer, int offset,
 				   size_t count)
 {
@@ -432,33 +450,20 @@ static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
 	bufferram = this->base + area;
 	bufferram += onenand_bufferram_offset(mtd, area);
 
-	memcpy_16(bufferram + offset, buffer, count);
+#ifdef CONFIG_MTD_NX_ONENAND
 
-	return 0;
-}
-
-/**
- * onenand_get_2x_blockpage - [GENERIC] Get blockpage at 2x program mode
- * @param mtd		MTD data structure
- * @param addr		address to check
- * @return		blockpage address
- *
- * Get blockpage address at 2x program mode
- */
-static int onenand_get_2x_blockpage(struct mtd_info *mtd, loff_t addr)
-{
-	struct onenand_chip *this = mtd->priv;
-	int blockpage, block, page;
+#ifdef CONFIG_DMAC_NXP_1902
+  nx_onenand_dmac_tfr(mtd, buffer, (int)((bufferram + offset) - this->base),
+				      count, 0);
+#else
+	nx_memcpy((bufferram + offset), buffer, count, 0);
+#endif /* CONFIG_MTD_NX_NAND_DMAC */
 
-	/* Calculate the even block number */
-	block = (int) (addr >> this->erase_shift) & ~1;
-	/* Is it the odd plane? */
-	if (addr & this->writesize)
-		block++;
-	page = (int) (addr >> (this->page_shift + 1)) & this->page_mask;
-	blockpage = (block << 7) | page;
+#else
+	memcpy_16(bufferram + offset, buffer, count);
+#endif
 
-	return blockpage;
+	return 0;
 }
 
 /**
@@ -472,39 +477,21 @@ static int onenand_get_2x_blockpage(struct mtd_info *mtd, loff_t addr)
 static int onenand_check_bufferram(struct mtd_info *mtd, loff_t addr)
 {
 	struct onenand_chip *this = mtd->priv;
-	int blockpage, found = 0;
-	unsigned int i;
-
-#ifdef CONFIG_S3C64XX
-	return 0;
-#endif
+	int block, page;
+	int i;
 
-	if (ONENAND_IS_2PLANE(this))
-		blockpage = onenand_get_2x_blockpage(mtd, addr);
-	else
-		blockpage = (int) (addr >> this->page_shift);
+	block = (int)(addr >> this->erase_shift);
+	page = (int)(addr >> this->page_shift);
+	page &= this->page_mask;
 
-	/* Is there valid data? */
 	i = ONENAND_CURRENT_BUFFERRAM(this);
-	if (this->bufferram[i].blockpage == blockpage)
-		found = 1;
-	else {
-		/* Check another BufferRAM */
-		i = ONENAND_NEXT_BUFFERRAM(this);
-		if (this->bufferram[i].blockpage == blockpage) {
-			ONENAND_SET_NEXT_BUFFERRAM(this);
-			found = 1;
-		}
-	}
 
-	if (found && ONENAND_IS_DDP(this)) {
-		/* Select DataRAM for DDP */
-		int block = (int) (addr >> this->erase_shift);
-		int value = onenand_bufferram_address(this, block);
-		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
-	}
+	/* Is there valid data? */
+	if (this->bufferram[i].block == block &&
+	    this->bufferram[i].page == page && this->bufferram[i].valid)
+		return 1;
 
-	return found;
+	return 0;
 }
 
 /**
@@ -519,25 +506,25 @@ static int onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,
 				    int valid)
 {
 	struct onenand_chip *this = mtd->priv;
-	int blockpage;
-	unsigned int i;
+	int block, page;
+	int i;
 
-	if (ONENAND_IS_2PLANE(this))
-		blockpage = onenand_get_2x_blockpage(mtd, addr);
-	else
-		blockpage = (int)(addr >> this->page_shift);
+	block = (int)(addr >> this->erase_shift);
+	page = (int)(addr >> this->page_shift);
+	page &= this->page_mask;
 
-	/* Invalidate another BufferRAM */
-	i = ONENAND_NEXT_BUFFERRAM(this);
-	if (this->bufferram[i].blockpage == blockpage)
-		this->bufferram[i].blockpage = -1;
+	/* Invalidate BufferRAM */
+	for (i = 0; i < MAX_BUFFERRAM; i++) {
+		if (this->bufferram[i].block == block &&
+		    this->bufferram[i].page == page)
+			this->bufferram[i].valid = 0;
+	}
 
 	/* Update BufferRAM */
 	i = ONENAND_CURRENT_BUFFERRAM(this);
-	if (valid)
-		this->bufferram[i].blockpage = blockpage;
-	else
-		this->bufferram[i].blockpage = -1;
+	this->bufferram[i].block = block;
+	this->bufferram[i].page = page;
+	this->bufferram[i].valid = valid;
 
 	return 0;
 }
@@ -559,10 +546,10 @@ static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
 
 	/* Invalidate BufferRAM */
 	for (i = 0; i < MAX_BUFFERRAM; i++) {
-		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
+		loff_t buf_addr = this->bufferram[i].block << this->erase_shift;
 
 		if (buf_addr >= addr && buf_addr < end_addr)
-			this->bufferram[i].blockpage = -1;
+			this->bufferram[i].valid = 0;
 	}
 }
 
@@ -615,7 +602,7 @@ static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
 			readend += free->offset - lastgap;
 		lastgap = free->offset + free->length;
 	}
-	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
+	this->read_bufferram(mtd, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
 	free = this->ecclayout->oobfree;
 	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
 		int free_end = free->offset + free->length;
@@ -653,7 +640,9 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 	int ret = 0, boundary = 0;
 	int writesize = this->writesize;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3,
+		"onenand_read_ops_nolock: from = 0x%08x, len = %i\n",
+		(unsigned int) from, (int) len);
 
 	if (ops->mode == MTD_OOB_AUTO)
 		oobsize = this->ecclayout->oobavail;
@@ -677,7 +666,6 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 	/* Do first load to bufferRAM */
 	if (read < len) {
 		if (!onenand_check_bufferram(mtd, from)) {
-			this->main_buf = buf;
 			this->command(mtd, ONENAND_CMD_READ, from, writesize);
 			ret = this->wait(mtd, FL_READING);
 			onenand_update_bufferram(mtd, from, !ret);
@@ -695,7 +683,6 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 		/* If there is more to load then start next load */
 		from += thislen;
 		if (read + thislen < len) {
-			this->main_buf = buf + thislen;
 			this->command(mtd, ONENAND_CMD_READ, from, writesize);
 			/*
 			 * Chip boundary handling in DDP
@@ -712,7 +699,7 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 		}
 
 		/* While load is going, read from last bufferRAM */
-		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);
+		this->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);
 
 		/* Read oob area if needed */
 		if (oobbuf) {
@@ -722,7 +709,7 @@ static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
 			if (ops->mode == MTD_OOB_AUTO)
 				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
 			else
-				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
+				this->read_bufferram(mtd, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
 			oobread += thisooblen;
 			oobbuf += thisooblen;
 			oobcolumn = 0;
@@ -785,7 +772,9 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 
 	from += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3,
+		"onenand_read_oob_nolock: from = 0x%08x, len = %i\n",
+		(unsigned int) from, (int) len);
 
 	/* Initialize return length value */
 	ops->oobretlen = 0;
@@ -816,7 +805,6 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 		thislen = oobsize - column;
 		thislen = min_t(int, thislen, len);
 
-		this->spare_buf = buf;
 		this->command(mtd, ONENAND_CMD_READOOB, from, mtd->oobsize);
 
 		onenand_update_bufferram(mtd, from, 0);
@@ -830,7 +818,7 @@ static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
 		if (mode == MTD_OOB_AUTO)
 			onenand_transfer_auto_oob(mtd, buf, column, thislen);
 		else
-			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
+			this->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);
 
 		read += thislen;
 
@@ -911,10 +899,11 @@ int onenand_read_oob(struct mtd_info *mtd, loff_t from,
 	}
 
 	onenand_get_device(mtd, FL_READING);
-	if (ops->datbuf)
-		ret = onenand_read_ops_nolock(mtd, from, ops);
-	else
+	if (!ops->datbuf)
 		ret = onenand_read_oob_nolock(mtd, from, ops);
+	else
+		ret = onenand_read_ops_nolock(mtd, from, ops);
+
 	onenand_release_device(mtd);
 
 	return ret;
@@ -944,6 +933,12 @@ static int onenand_bbt_wait(struct mtd_info *mtd, int state)
 	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
 	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
 
+	/* Initial bad block case: 0x2400 or 0x0400 */
+	if (ctrl & ONENAND_CTRL_ERROR) {
+		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
+		return ONENAND_BBT_READ_ERROR;
+	}
+
 	if (interrupt & ONENAND_INT_READ) {
 		int ecc = this->read_word(this->base + ONENAND_REG_ECC_STATUS);
 		if (ecc & ONENAND_ECC_2BIT_ALL)
@@ -954,12 +949,6 @@ static int onenand_bbt_wait(struct mtd_info *mtd, int state)
 		return ONENAND_BBT_READ_FATAL_ERROR;
 	}
 
-	/* Initial bad block case: 0x2400 or 0x0400 */
-	if (ctrl & ONENAND_CTRL_ERROR) {
-		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
-		return ONENAND_BBT_READ_ERROR;
-	}
-
 	return 0;
 }
 
@@ -980,7 +969,9 @@ int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
 	size_t len = ops->ooblen;
 	u_char *buf = ops->oobbuf;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3,
+		"onenand_bbt_read_oob: from = 0x%08x, len = %zi\n",
+		(unsigned int) from, len);
 
 	/* Initialize return value */
 	ops->oobretlen = 0;
@@ -1001,16 +992,15 @@ int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
 		thislen = mtd->oobsize - column;
 		thislen = min_t(int, thislen, len);
 
-		this->spare_buf = buf;
 		this->command(mtd, ONENAND_CMD_READOOB, from, mtd->oobsize);
 
 		onenand_update_bufferram(mtd, from, 0);
 
-		ret = this->bbt_wait(mtd, FL_READING);
+		ret = onenand_bbt_wait(mtd, FL_READING);
 		if (ret)
 			break;
 
-		this->read_spareram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
+		this->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);
 		read += thislen;
 		if (read == len)
 			break;
@@ -1052,7 +1042,7 @@ static int onenand_verify_oob(struct mtd_info *mtd, const u_char *buf, loff_t to
 	if (status)
 		return status;
 
-	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
+	this->read_bufferram(mtd, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
 	for (i = 0; i < mtd->oobsize; i++)
 		if (buf[i] != 0xFF && buf[i] != oob_buf[i])
 			return -EBADMSG;
@@ -1108,7 +1098,7 @@ static int onenand_verify(struct mtd_info *mtd, const u_char *buf, loff_t addr,
 #define onenand_verify_oob(...)         (0)
 #endif
 
-#define NOTALIGNED(x)	((x & (this->subpagesize - 1)) != 0)
+#define NOTALIGNED(x)	((x & (mtd->writesize - 1)) != 0)
 
 /**
  * onenand_fill_auto_oob - [Internal] oob auto-placement transfer
@@ -1172,7 +1162,9 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 	u_char *oobbuf;
 	int ret = 0;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3,
+		"onenand_write_ops_nolock: to = 0x%08x, len = %i\n",
+		(unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->retlen = 0;
@@ -1216,7 +1208,7 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 			wbuf = this->page_buf;
 		}
 
-		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
+		this->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
 
 		if (oob) {
 			oobbuf = this->oob_buf;
@@ -1235,7 +1227,7 @@ static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
 		} else
 			oobbuf = (u_char *) ffchars;
 
-		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
+		this->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
 
 		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
 
@@ -1299,7 +1291,9 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
 
 	to += ops->ooboffs;
 
-	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	MTDDEBUG(MTD_DEBUG_LEVEL3,
+		"onenand_write_oob_nolock: to = 0x%08x, len = %i\n",
+		(unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	ops->oobretlen = 0;
@@ -1346,7 +1340,7 @@ static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
 			onenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);
 		else
 			memcpy(oobbuf + column, buf, thislen);
-		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
+		this->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
 
 		this->command(mtd, ONENAND_CMD_PROGOOB, to, mtd->oobsize);
 
@@ -1435,10 +1429,10 @@ int onenand_write_oob(struct mtd_info *mtd, loff_t to,
 	}
 
 	onenand_get_device(mtd, FL_WRITING);
-	if (ops->datbuf)
-		ret = onenand_write_ops_nolock(mtd, to, ops);
-	else
+	if (!ops->datbuf)
 		ret = onenand_write_oob_nolock(mtd, to, ops);
+	else
+		ret = onenand_write_ops_nolock(mtd, to, ops);
 	onenand_release_device(mtd);
 
 	return ret;
@@ -1519,14 +1513,7 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 
 	while (len) {
 
-		/* Check if we have a bad block, we do not erase bad blocks */
-		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
-			printk(KERN_WARNING "onenand_erase: attempt to erase"
-				" a bad block at addr 0x%08x\n",
-				(unsigned int) addr);
-			instr->state = MTD_ERASE_FAILED;
-			goto erase_exit;
-		}
+		/* TODO Check badblock */
 
 		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);
 
@@ -1542,16 +1529,8 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
 					  "Failed erase, block %d\n",
 					  (unsigned)(addr >> this->erase_shift));
-			if (ret == -EPERM)
-				printk("onenand_erase: "
-					  "Device is write protected!!!\n");
-			else
-				printk("onenand_erase: "
-					  "Failed erase, block %d\n",
-					  (unsigned)(addr >> this->erase_shift));
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = addr;
-
 			goto erase_exit;
 		}
 
@@ -1561,7 +1540,7 @@ int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 
 	instr->state = MTD_ERASE_DONE;
 
-erase_exit:
+      erase_exit:
 
 	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
 	/* Do call back function */
@@ -1613,37 +1592,6 @@ int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
 }
 
 /**
- * onenand_default_block_markbad - [DEFAULT] mark a block bad
- * @param mtd           MTD device structure
- * @param ofs           offset from device start
- *
- * This is the default implementation, which can be overridden by
- * a hardware specific driver.
- */
-static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
-{
-	struct onenand_chip *this = mtd->priv;
-	struct bbm_info *bbm = this->bbm;
-	u_char buf[2] = {0, 0};
-	struct mtd_oob_ops ops = {
-		.mode = MTD_OOB_PLACE,
-		.ooblen = 2,
-		.oobbuf = buf,
-		.ooboffs = 0,
-	};
-	int block;
-
-	/* Get block number */
-	block = ((int) ofs) >> bbm->bbt_erase_shift;
-	if (bbm->bbt)
-		bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
-
-	/* We write two bytes, so we dont have to mess with 16 bit access */
-	ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
-	return onenand_write_oob_nolock(mtd, ofs, &ops);
-}
-
-/**
  * onenand_block_markbad - [MTD Interface] Mark the block at the given offset as bad
  * @param mtd		MTD device structure
  * @param ofs		offset relative to mtd start
@@ -1668,30 +1616,23 @@ int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 }
 
 /**
- * onenand_do_lock_cmd - [OneNAND Interface] Lock or unlock block(s)
- * @param mtd           MTD device structure
- * @param ofs           offset relative to mtd start
- * @param len           number of bytes to lock or unlock
- * @param cmd           lock or unlock command
+ * onenand_unlock - [MTD Interface] Unlock block(s)
+ * @param mtd		MTD device structure
+ * @param ofs		offset relative to mtd start
+ * @param len		number of bytes to unlock
  *
- * Lock or unlock one or more blocks
+ * Unlock one or more blocks
  */
-static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
+int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
 {
 	struct onenand_chip *this = mtd->priv;
 	int start, end, block, value, status;
-	int wp_status_mask;
 
 	start = ofs >> this->erase_shift;
 	end = len >> this->erase_shift;
 
-	if (cmd == ONENAND_CMD_LOCK)
-		wp_status_mask = ONENAND_WP_LS;
-	else
-		wp_status_mask = ONENAND_WP_US;
-
 	/* Continuous lock scheme */
-	if (this->options & ONENAND_HAS_CONT_LOCK) {
+	if (this->options & ONENAND_CONT_LOCK) {
 		/* Set start block address */
 		this->write_word(start,
 				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
@@ -1699,7 +1640,7 @@ static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int
 		this->write_word(end - 1,
 				 this->base + ONENAND_REG_END_BLOCK_ADDRESS);
 		/* Write unlock command */
-		this->command(mtd, cmd, 0, 0);
+		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
 
 		/* There's no return value */
 		this->wait(mtd, FL_UNLOCKING);
@@ -1718,14 +1659,7 @@ static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int
 	}
 
 	/* Block lock scheme */
-	for (block = start; block < start + end; block++) {
-		/* Set block address */
-		value = onenand_block_address(this, block);
-		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
-		/* Select DataRAM for DDP */
-		value = onenand_bufferram_address(this, block);
-		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
-
+	for (block = start; block < end; block++) {
 		/* Set start block address */
 		this->write_word(block,
 				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
@@ -1740,6 +1674,11 @@ static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int
 		       & ONENAND_CTRL_ONGO)
 			continue;
 
+		/* Set block address for read block status */
+		value = onenand_block_address(this->device_id, block);
+		this->write_word(value,
+				 this->base + ONENAND_REG_START_ADDRESS1);
+
 		/* Check lock status */
 		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
 		if (!(status & ONENAND_WP_US))
@@ -1750,199 +1689,33 @@ static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int
 	return 0;
 }
 
-#ifdef ONENAND_LINUX
-/**
- * onenand_lock - [MTD Interface] Lock block(s)
- * @param mtd           MTD device structure
- * @param ofs           offset relative to mtd start
- * @param len           number of bytes to unlock
- *
- * Lock one or more blocks
- */
-static int onenand_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
-{
-	int ret;
-
-	onenand_get_device(mtd, FL_LOCKING);
-	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_LOCK);
-	onenand_release_device(mtd);
-	return ret;
-}
-
-/**
- * onenand_unlock - [MTD Interface] Unlock block(s)
- * @param mtd           MTD device structure
- * @param ofs           offset relative to mtd start
- * @param len           number of bytes to unlock
- *
- * Unlock one or more blocks
- */
-static int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
-{
-	int ret;
-
-	onenand_get_device(mtd, FL_LOCKING);
-	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
-	onenand_release_device(mtd);
-	return ret;
-}
-#endif
-
-/**
- * onenand_check_lock_status - [OneNAND Interface] Check lock status
- * @param this          onenand chip data structure
- *
- * Check lock status
- */
-static int onenand_check_lock_status(struct onenand_chip *this)
-{
-	unsigned int value, block, status;
-	unsigned int end;
-
-	end = this->chipsize >> this->erase_shift;
-	for (block = 0; block < end; block++) {
-		/* Set block address */
-		value = onenand_block_address(this, block);
-		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
-		/* Select DataRAM for DDP */
-		value = onenand_bufferram_address(this, block);
-		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
-		/* Set start block address */
-		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
-
-		/* Check lock status */
-		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
-		if (!(status & ONENAND_WP_US)) {
-			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
-/**
- * onenand_unlock_all - [OneNAND Interface] unlock all blocks
- * @param mtd           MTD device structure
- *
- * Unlock all blocks
- */
-static void onenand_unlock_all(struct mtd_info *mtd)
-{
-	struct onenand_chip *this = mtd->priv;
-	loff_t ofs = 0;
-	size_t len = this->chipsize;
-
-	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
-		/* Set start block address */
-		this->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
-		/* Write unlock command */
-		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
-
-		/* There's no return value */
-		this->wait(mtd, FL_LOCKING);
-
-		/* Sanity check */
-		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
-				& ONENAND_CTRL_ONGO)
-			continue;
-
-		return;
-
-		/* Check lock status */
-		if (onenand_check_lock_status(this))
-			return;
-
-		/* Workaround for all block unlock in DDP */
-		if (ONENAND_IS_DDP(this)) {
-			/* All blocks on another chip */
-			ofs = this->chipsize >> 1;
-			len = this->chipsize >> 1;
-		}
-	}
-
-	onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
-}
-
-
-/**
- * onenand_check_features - Check and set OneNAND features
- * @param mtd           MTD data structure
- *
- * Check and set OneNAND features
- * - lock scheme
- * - two plane
- */
-static void onenand_check_features(struct mtd_info *mtd)
-{
-	struct onenand_chip *this = mtd->priv;
-	unsigned int density, process;
-
-	/* Lock scheme depends on density and process */
-	density = onenand_get_density(this->device_id);
-	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
-
-	/* Lock scheme */
-	switch (density) {
-	case ONENAND_DEVICE_DENSITY_4Gb:
-		this->options |= ONENAND_HAS_2PLANE;
-
-	case ONENAND_DEVICE_DENSITY_2Gb:
-		/* 2Gb DDP don't have 2 plane */
-		if (!ONENAND_IS_DDP(this))
-			this->options |= ONENAND_HAS_2PLANE;
-		this->options |= ONENAND_HAS_UNLOCK_ALL;
-
-	case ONENAND_DEVICE_DENSITY_1Gb:
-		/* A-Die has all block unlock */
-		if (process)
-			this->options |= ONENAND_HAS_UNLOCK_ALL;
-		break;
-
-	default:
-		/* Some OneNAND has continuous lock scheme */
-		if (!process)
-			this->options |= ONENAND_HAS_CONT_LOCK;
-		break;
-	}
-
-	if (this->options & ONENAND_HAS_CONT_LOCK)
-		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
-	if (this->options & ONENAND_HAS_UNLOCK_ALL)
-		printk(KERN_DEBUG "Chip support all block unlock\n");
-	if (this->options & ONENAND_HAS_2PLANE)
-		printk(KERN_DEBUG "Chip has 2 plane\n");
-}
-
 /**
  * onenand_print_device_info - Print device ID
  * @param device        device ID
  *
  * Print device ID
  */
-char *onenand_print_device_info(int device, int version)
+char * onenand_print_device_info(int device)
 {
 	int vcc, demuxed, ddp, density;
 	char *dev_info = malloc(80);
-	char *p = dev_info;
 
 	vcc = device & ONENAND_DEVICE_VCC_MASK;
 	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
 	ddp = device & ONENAND_DEVICE_IS_DDP;
 	density = device >> ONENAND_DEVICE_DENSITY_SHIFT;
-	p += sprintf(dev_info, "%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
+	sprintf(dev_info, "%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
 	       demuxed ? "" : "Muxed ",
 	       ddp ? "(DDP)" : "",
 	       (16 << density), vcc ? "2.65/3.3" : "1.8", device);
-
-	sprintf(p, "\nOneNAND version = 0x%04x", version);
-	printk("%s\n", dev_info);
+	printk(KERN_INFO "%s \r\n",dev_info);
 
 	return dev_info;
 }
 
 static const struct onenand_manufacturers onenand_manuf_ids[] = {
 	{ONENAND_MFR_SAMSUNG, "Samsung"},
+	{ONENAND_MFR_UNKNOWN, "Unknown"}
 };
 
 /**
@@ -1953,24 +1726,19 @@ static const struct onenand_manufacturers onenand_manuf_ids[] = {
  */
 static int onenand_check_maf(int manuf)
 {
-	int size = ARRAY_SIZE(onenand_manuf_ids);
-	char *name;
 	int i;
 
-	for (i = 0; size; i++)
+	for (i = 0; onenand_manuf_ids[i].id; i++) {
 		if (manuf == onenand_manuf_ids[i].id)
 			break;
-
-	if (i < size)
-		name = onenand_manuf_ids[i].name;
-	else
-		name = "Unknown";
+	}
 
 #ifdef ONENAND_DEBUG
-	printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n", name, manuf);
+	printk(KERN_DEBUG "OneNAND Manufacturer: %s (0x%0x)\n",
+	       onenand_manuf_ids[i].name, manuf);
 #endif
 
-	return i == size;
+	return (i != ONENAND_MFR_UNKNOWN);
 }
 
 /**
@@ -1983,14 +1751,9 @@ static int onenand_check_maf(int manuf)
 static int onenand_probe(struct mtd_info *mtd)
 {
 	struct onenand_chip *this = mtd->priv;
-	int bram_maf_id, bram_dev_id, maf_id, dev_id, ver_id;
+	int bram_maf_id, bram_dev_id, maf_id, dev_id;
+	int version_id;
 	int density;
-	int syscfg;
-
-	/* Save system configuration 1 */
-	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
-	/* Clear Sync. Burst Read mode to read BootRAM */
-	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ), this->base + ONENAND_REG_SYS_CFG1);
 
 	/* Send the command for reading device ID from BootRAM */
 	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
@@ -1999,23 +1762,19 @@ static int onenand_probe(struct mtd_info *mtd)
 	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
 	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
 
+	/* Check manufacturer ID */
+	if (onenand_check_maf(bram_maf_id))
+		return -ENXIO;
+
 	/* Reset OneNAND to read default register values */
 	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
 
 	/* Wait reset */
 	this->wait(mtd, FL_RESETING);
 
-	/* Restore system configuration 1 */
-	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
-
-	/* Check manufacturer ID */
-	if (onenand_check_maf(bram_maf_id))
-		return -ENXIO;
-
 	/* Read manufacturer and device IDs from Register */
 	maf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);
 	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
-	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
 
 	/* Check OneNAND device */
 	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
@@ -2028,17 +1787,11 @@ static int onenand_probe(struct mtd_info *mtd)
 	}
 
 	/* Flash device information */
-	mtd->name = onenand_print_device_info(dev_id, ver_id);
+	mtd->name = onenand_print_device_info(dev_id);
 	this->device_id = dev_id;
-	this->version_id = ver_id;
 
-	density = onenand_get_density(dev_id);
+	density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
 	this->chipsize = (16 << density) << 20;
-	/* Set density mask. it is used for DDP */
-	if (ONENAND_IS_DDP(this))
-		this->density_mask = (1 << (density + 6));
-	else
-		this->density_mask = 0;
 
 	/* OneNAND page size & block size */
 	/* The data buffer size is equal to page size */
@@ -2059,8 +1812,19 @@ static int onenand_probe(struct mtd_info *mtd)
 
 	mtd->size = this->chipsize;
 
-	/* Check OneNAND features */
-	onenand_check_features(mtd);
+	/* Version ID */
+	version_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
+#ifdef ONENAND_DEBUG
+	printk(KERN_DEBUG "OneNAND version = 0x%04x\n", version_id);
+	printk(KERN_DEBUG "OneNAND page 0x%04x page_shift 0x%04x block 0x%04x erase_shift 0x%04x \n", mtd->writesize, this->page_shift, mtd->erasesize, this->erase_shift);
+#endif
+
+	/* Lock scheme */
+	if (density <= ONENAND_DEVICE_DENSITY_512Mb &&
+	    !(version_id >> ONENAND_VERSION_PROCESS_SHIFT)) {
+		printk(KERN_INFO "Lock scheme is Continues Lock\n");
+		this->options |= ONENAND_CONT_LOCK;
+	}
 
 	mtd->flags = MTD_CAP_NANDFLASH;
 	mtd->erase = onenand_erase;
@@ -2087,7 +1851,6 @@ static int onenand_probe(struct mtd_info *mtd)
  */
 int onenand_scan(struct mtd_info *mtd, int maxchips)
 {
-	int i;
 	struct onenand_chip *this = mtd->priv;
 
 	if (!this->read_word)
@@ -2099,21 +1862,12 @@ int onenand_scan(struct mtd_info *mtd, int maxchips)
 		this->command = onenand_command;
 	if (!this->wait)
 		this->wait = onenand_wait;
-	if (!this->bbt_wait)
-		this->bbt_wait = onenand_bbt_wait;
 
 	if (!this->read_bufferram)
 		this->read_bufferram = onenand_read_bufferram;
-	if (!this->read_spareram)
-		this->read_spareram = onenand_read_bufferram;
 	if (!this->write_bufferram)
 		this->write_bufferram = onenand_write_bufferram;
 
-	if (!this->block_markbad)
-		this->block_markbad = onenand_default_block_markbad;
-	if (!this->scan_bbt)
-		this->scan_bbt = onenand_default_bbt;
-
 	if (onenand_probe(mtd))
 		return -ENXIO;
 
@@ -2145,50 +1899,9 @@ int onenand_scan(struct mtd_info *mtd, int maxchips)
 		this->options |= ONENAND_OOBBUF_ALLOC;
 	}
 
-	this->state = FL_READY;
-
-	/*
-	 * Allow subpage writes up to oobsize.
-	 */
-	switch (mtd->oobsize) {
-	case 64:
-		this->ecclayout = &onenand_oob_64;
-		mtd->subpage_sft = 2;
-		break;
-
-	case 32:
-		this->ecclayout = &onenand_oob_32;
-		mtd->subpage_sft = 1;
-		break;
-
-	default:
-		printk(KERN_WARNING "No OOB scheme defined for oobsize %d\n",
-			mtd->oobsize);
-		mtd->subpage_sft = 0;
-		/* To prevent kernel oops */
-		this->ecclayout = &onenand_oob_32;
-		break;
-	}
-
-	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
-
-	/*
-	 * The number of bytes available for a client to place data into
-	 * the out of band area
-	 */
-	this->ecclayout->oobavail = 0;
-	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
-	    this->ecclayout->oobfree[i].length; i++)
-		this->ecclayout->oobavail +=
-			this->ecclayout->oobfree[i].length;
-	mtd->oobavail = this->ecclayout->oobavail;
-
-	mtd->ecclayout = this->ecclayout;
-
-	/* Unlock whole block */
-	onenand_unlock_all(mtd);
+	onenand_unlock(mtd, 0, mtd->size);
 
-	return this->scan_bbt(mtd);
+	return onenand_default_bbt(mtd);
 }
 
 /**
diff --git a/drivers/mtd/onenand/onenand_uboot.c b/drivers/mtd/onenand/onenand_uboot.c
index 9823b5b..619ead8 100644
--- a/drivers/mtd/onenand/onenand_uboot.c
+++ b/drivers/mtd/onenand/onenand_uboot.c
@@ -22,12 +22,19 @@ struct mtd_info onenand_mtd;
 struct onenand_chip onenand_chip;
 static __attribute__((unused)) char dev_name[] = "onenand0";
 
+
+extern void nx_onenand_init(struct mtd_info *mtd, struct onenand_chip * chip);
+
 void onenand_init(void)
 {
 	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
 	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
 
 	onenand_mtd.priv = &onenand_chip;
+#ifdef CONFIG_MTD_NX_ONENAND		
+	nx_onenand_init(&onenand_mtd, &onenand_chip);
+#endif
+
 
 #ifdef CONFIG_USE_ONENAND_BOARD_INIT
 	/*
@@ -36,8 +43,11 @@ void onenand_init(void)
 	onenand_board_init(&onenand_mtd);
 #else
 	onenand_chip.base = (void *) CONFIG_SYS_ONENAND_BASE;
+	onenand_mtd.priv = &onenand_chip;
 #endif
 
+
+	/* OneNAND scan */
 	onenand_scan(&onenand_mtd, 1);
 
 	puts("OneNAND: ");
diff --git a/drivers/mtd/ubi/Makefile b/drivers/mtd/ubi/Makefile
index 8bd82c3..d8e2f2f 100644
--- a/drivers/mtd/ubi/Makefile
+++ b/drivers/mtd/ubi/Makefile
@@ -30,6 +30,7 @@ COBJS-y += build.o vtbl.o vmt.o upd.o kapi.o eba.o io.o wl.o scan.o crc32.o
 
 COBJS-y += misc.o
 COBJS-y += debug.o
+COBJS-y += ubiblock.o
 endif
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/mtd/ubi/ubiblock.c b/drivers/mtd/ubi/ubiblock.c
new file mode 100644
index 0000000..489764e
--- /dev/null
+++ b/drivers/mtd/ubi/ubiblock.c
@@ -0,0 +1,69 @@
+#include <common.h>
+#include <ubi_uboot.h>
+#include <command.h>
+#include <part.h>
+#include <asm/io.h>
+
+static unsigned long ubiblock_read(int dev, unsigned long start,
+				    unsigned long blkcnt, void *buffer);
+
+static block_dev_desc_t ubi_dev = { 0 };
+
+struct ubi_device *ubiblock_ubi;
+struct ubi_volume *ubiblock_vol;
+
+block_dev_desc_t *ubi_get_dev(int dev)
+{
+	/* The first time through this, the ubi_dev object is
+	   not yet initialized. In that case, fill it in. */
+	if (ubi_dev.blksz == 0) {
+		ubi_dev.if_type = IF_TYPE_UNKNOWN;
+		ubi_dev.dev = 0;
+		ubi_dev.part_type = PART_TYPE_UNKNOWN;
+		ubi_dev.type = DEV_TYPE_HARDDISK;
+		ubi_dev.blksz = 512;
+		ubi_dev.removable = 1;
+		ubi_dev.block_read = ubiblock_read;
+		ubiblock_ubi = ubi_get_device (dev);
+		ubiblock_vol = ubiblock_ubi->volumes[0];
+
+		init_part(&ubi_dev);
+
+	}
+
+	return &ubi_dev;
+}	
+
+static unsigned long ubiblock_read(int dev, unsigned long start,
+				    unsigned long blkcnt, void *buffer)
+{
+	int err = 0, lnum, offs, total_read, len;
+
+	printk (KERN_ALERT "ubiblock_read start: %d, blkcnt: %d\n", start, blkcnt);
+
+	start = start * 512;
+	len = blkcnt * ubi_dev.blksz;
+
+	lnum = start / ubiblock_vol->usable_leb_size;
+	offs = start % ubiblock_vol->usable_leb_size;
+	total_read = len;
+	while (total_read) {
+		size_t to_read = ubiblock_vol->usable_leb_size - offs;
+
+		if (to_read > total_read) {
+			to_read = total_read;
+		}
+
+		err = ubi_eba_read_leb (ubiblock_ubi, ubiblock_vol, lnum, 
+				  buffer, offs, to_read, 0);
+
+		if (err) {
+			break;
+		}
+
+		lnum ++; offs = 0; 
+		total_read -= to_read; buffer += to_read;
+	}
+
+	return blkcnt;
+}
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 1c6e402..dc980cf 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -74,6 +74,8 @@ COBJS-$(CONFIG_ULI526X) += uli526x.o
 COBJS-$(CONFIG_VSC7385_ENET) += vsc7385.o
 COBJS-$(CONFIG_XILINX_EMAC) += xilinx_emac.o
 COBJS-$(CONFIG_XILINX_EMACLITE) += xilinx_emaclite.o
+COBJS-$(CONFIG_LIPP_6300ETH) += lipp_6300eth/lipp_6300eth.o \
+				lipp_6300eth/tmbslPhy.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/net/lipp_6300eth/glb.h b/drivers/net/lipp_6300eth/glb.h
new file mode 100644
index 0000000..c920930
--- /dev/null
+++ b/drivers/net/lipp_6300eth/glb.h
@@ -0,0 +1,107 @@
+/* Copyright (C) 2007 NXP B.V.
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   PNX8XXX global definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8XXX_GLB_H
+#define __PNX8XXX_GLB_H
+
+/* MMIO base in virtual in KSEG1 and physical */
+#define PNX8XXX_MMIO_BASE_PHYS		0x1BE00000
+#define PNX8XXX_MMIO_BASE_VIRT		0x1BE00000
+
+/* Global register block and reset block base addresses */
+#define PNX8XXX_GLB_BASE		(PNX8XXX_MMIO_BASE_VIRT + 0x63000)
+#define PNX8XXX_RESET_BASE		(PNX8XXX_MMIO_BASE_VIRT + 0x60000)
+
+/* Global register block */
+#define PNX8XXX_GLB_IO_CTRL		*(volatile unsigned long *)(PNX8XXX_GLB_BASE + 0x400)
+/* PCI ctrl contains PCI inta output enable bit */
+#define PNX8XXX_GLB_PCI_CTRL		*(volatile unsigned long *)(PNX8XXX_GLB_BASE + 0x404)
+#define PNX8XXX_GLB_SYS_ENDIAN		*(volatile unsigned long *)(PNX8XXX_GLB_BASE + 0x014)
+#define PNX8XXX_GLB_MIPS_RESET_VEC	*(volatile unsigned long *)(PNX8XXX_GLB_BASE + 0x010)
+
+#define PNX8XXX_GLB_MIPS_RESET_VEC_MTL_BSHIFT   (4)
+#define PNX8XXX_GLB_MIPS_RESET_VEC_MTL_MASK     (0xFF0)
+
+#define PNX8XXX_GLB_PCI_CTRL_INTA_OUTPUT_MASK	(0x00000002)
+
+#define PNX8XXX_SCRATCH_0		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x500)
+#define PNX8XXX_SCRATCH_1		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x504)
+#define PNX8XXX_SCRATCH_2		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x508)
+#define PNX8XXX_SCRATCH_3		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x50C)
+#define PNX8XXX_SCRATCH_4		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x510)
+#define PNX8XXX_SCRATCH_5		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x514)
+#define PNX8XXX_SCRATCH_6		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x518)
+#define PNX8XXX_SCRATCH_7		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x51C)
+#define PNX8XXX_SCRATCH_31		*(volatile unsigned long *)(PNX8XXX_GLB_BASE+0x57C)
+
+/* Reset register block */
+#define PNX8XXX_RST_STATUS0		(PNX8XXX_RESET_BASE + 0x0110)
+#define PNX8XXX_RST_STATUS1		(PNX8XXX_RESET_BASE + 0x0114)
+#define PNX8XXX_RST_CTL0		(PNX8XXX_RESET_BASE + 0x0100)
+#define PNX8XXX_RST_CTL1		(PNX8XXX_RESET_BASE + 0x0104)
+
+/* Peripheral MMIO base addresses */
+#define PNX8XXX_GIC_BASE		(PNX8XXX_MMIO_BASE_VIRT + 0x03E000)	/* GIC implementation expects virtual addresses */
+#define PNX8XXX_TMGIC_BASE		(PNX8XXX_MMIO_BASE_VIRT + 0x102000)	/* GIC implementation expects virtual addresses */
+#define PNX8XXX_PCI_BASE		(PNX8XXX_MMIO_BASE_PHYS + 0x040000)
+#define PNX8XXX_PCI_BASE_VIRT		(PNX8XXX_MMIO_BASE_VIRT + 0x040000)
+#define PNX8XXX_DDRCTRL_BASE		(PNX8XXX_MMIO_BASE_VIRT + 0x065000)	/* DDR ctrl driver expects virtual addresses */
+#define PNX8XXX_CLOCK_BASE		(PNX8XXX_MMIO_BASE_VIRT + 0x047000)	/* Clock Module implementation expects virtual addresses */
+#define PNX8XXX_XIO_BASE_PHYS		(PNX8XXX_MMIO_BASE_PHYS + 0x040000)
+#define PNX8XXX_XIO_BASE_VIRT           (PNX8XXX_MMIO_BASE_VIRT + 0x040000)
+#define PNX8XXX_UDMA_BASE_PHYS		(PNX8XXX_MMIO_BASE_PHYS + 0x040000)
+#define PNX8XXX_I2C0_BASE_PHYS		(PNX8XXX_MMIO_BASE_PHYS + 0x045000)
+#define PNX8XXX_I2C1_BASE_PHYS		(PNX8XXX_MMIO_BASE_PHYS + 0x046000)
+#define PNX8XXX_I2C0_BASE_VIRT		(PNX8XXX_MMIO_BASE_VIRT + 0x045000)
+#define PNX8XXX_I2C1_BASE_VIRT		(PNX8XXX_MMIO_BASE_VIRT + 0x046000)
+#define PNX8XXX_GPIO_BASE_VIRT		(PNX8XXX_MMIO_BASE_VIRT + 0x14C000)	/* GPIO in board boot code expects virtual addresses */
+#define PNX8XXX_GPIO_BASE_PHYS		(PNX8XXX_MMIO_BASE_PHYS + 0x14C000)
+#define PNX8XXX_MDCS_CFG_BASE_PHYS	(PNX8XXX_MMIO_BASE_PHYS + 0x103000)
+#define PNX8XXX_MDCS_SEC_BASE_PHYS	(PNX8XXX_MMIO_BASE_PHYS + 0x115000)
+#define PNX8XXX_TDCS_CFG_BASE_PHYS	(PNX8XXX_MMIO_BASE_PHYS + 0x04E000)
+#define PNX8XXX_TDCS_SEC_BASE_PHYS	(PNX8XXX_MMIO_BASE_PHYS + 0x068000)
+
+/* PCI Direct Mappings */
+
+#define PNX8XXX_PCI_BASE1_LO_VALUE	0x20000000
+#define PNX8XXX_PCI_BASE1_HI_VALUE	0x30000000
+#define PNX8XXX_PCI_BASE2_LO_VALUE	0x30000000
+#define PNX8XXX_PCI_BASE2_HI_VALUE	0x30100000
+
+#define PNX8XXX_PCIMEM			0x20000000
+#define PNX8XXX_PCIMEM_SIZE		0x10000000
+
+#define PNX8XXX_PCIIO			0x30000000
+#define PNX8XXX_PCIIO_SIZE		0x00100000
+
+/* Revision ID */
+#define PNX8XXX_REVISION		(*(volatile unsigned long *)(PNX8XXX_PCI_BASE_VIRT + 0x48) & 0xFF)
+
+/* Uncached base */
+#define PNX8XXX_PORT_BASE		KSEG1
+
+/* GPIO registers */
+#define GPIO_0_15_MODE_CTL0		*(volatile unsigned long *)(PNX8XXX_GPIO_BASE_VIRT + 0x000)
+
+/* NAND base address (from nand.h)  */
+#define PNX8XXX_NAND_BASE_ADDR		0x10000000
+
+#endif
diff --git a/drivers/net/lipp_6300eth/i2c_ip3203.c b/drivers/net/lipp_6300eth/i2c_ip3203.c
new file mode 100644
index 0000000..ee88b1a
--- /dev/null
+++ b/drivers/net/lipp_6300eth/i2c_ip3203.c
@@ -0,0 +1,126 @@
+/*
+ *  Copyright (C) 2007 NXP B.V.
+ *
+ *  Philips PNX8XXX i2c_ip3203.c
+ *
+ *  Copyright (C) 2006 Koninklijke Philips Electronics N.V.
+ *  Niels Sterrenburg, niels.sterrenburg@philips.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+//#include <linux/init.h>
+//#include <linux/kernel.h>
+//#include <linux/ctype.h>
+
+#include "i2c_ip3203.h"
+
+void pnx8xxx_ip3203_init( void )
+{
+	/* Make sure IIC is not in the power down mode */
+	*IP3203_POWERDOWN = 0;
+
+	/* Disable IIC module and make sure Ack and Start are off */
+	*IP3203_CONTROL &= ~IP3203_EN;
+	*IP3203_CONTROL &= ~IP3203_AA;
+	*IP3203_CONTROL &= ~IP3203_STA;
+
+	/* Set the speed to 100KHz */
+	*IP3203_FSBIR = 0x18;
+
+	/* Disable IIC interrupt line */
+	*IP3203_INT_EN = 0;
+
+	/* Clear any pending interrupts */
+	*IP3203_INT_CLR = IP3203_INTBIT;
+
+	/* Enable IIC module */
+	*IP3203_CONTROL |= IP3203_EN;
+
+}
+
+int pnx8xxx_ip3203_write(char* i2c_message, int message_len)
+{
+	int counter;
+	char *messagePointer;
+	int result = 1;
+
+	/* Generate start condition */
+	*IP3203_CONTROL |= IP3203_STA;
+
+	/* Wait till start condition is generated */
+	WAIT_IP3203INT();
+
+	if( !(*IP3203_STATUS == 0x08) )
+	{
+		result = 0; /* Wrong state  */
+	}
+	else
+	{
+		/* Clear start request bit */
+		*IP3203_CONTROL &= ~IP3203_STA;
+
+		/* Set SlaveAddress of the Standby processor */
+		*IP3203_DAT = IP3203_SLAVE_ADDR;
+
+		/* Clear interrupt */
+		*IP3203_INT_CLR = IP3203_INTBIT;
+
+		/* Wait till address is transmitted */
+		WAIT_IP3203INT();
+
+		if( !(*IP3203_STATUS == 0x18) )
+		{
+			result = 0; /* Wrong state  */
+		}
+		else
+		{
+			messagePointer = i2c_message;
+			/* Transmit the I2c Rpc message */
+			for(counter = 0; counter < message_len; counter++)
+			{
+				/* Set databyte */
+				*IP3203_DAT = *messagePointer++;
+
+				/* Clear interrupt */
+				*IP3203_INT_CLR = IP3203_INTBIT;
+
+				/* Wait till databyte is transmitted */
+				WAIT_IP3203INT();
+
+				if( !(*IP3203_STATUS == 0x28) )
+				{
+					result = 0; /* Wrong state  */
+					break;
+				}
+			}
+		}
+	}
+
+	/* Stop transmission by sending stop condition */
+	*IP3203_CONTROL |= IP3203_STO;
+
+	/* Clear interrupt */
+	*IP3203_INT_CLR = IP3203_INTBIT;
+
+	return result;
+}
+
diff --git a/drivers/net/lipp_6300eth/i2c_ip3203.h b/drivers/net/lipp_6300eth/i2c_ip3203.h
new file mode 100644
index 0000000..12e83b9
--- /dev/null
+++ b/drivers/net/lipp_6300eth/i2c_ip3203.h
@@ -0,0 +1,61 @@
+/*
+ *  NXP PNX8XXX i2c_ip3203.h
+ *
+ *  Copyright (C) 2006 Koninklijke Philips Electronics N.V.
+ *  Vincent van der Locht, vincent.van.der.locht@philips.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "glb.h"
+
+#define IP3203_SLAVE_ADDR              0x60
+#define IP3203_TIMEOUT                 20000
+
+#define MMIO_IP3203_UNIT0              PNX8XXX_I2C0_BASE_VIRT
+
+/* Local Macros for IP3203 */
+#define IP3203_CONTROL                 ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000000) )
+#define IP3203_STATUS                  ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000004) )
+#define IP3203_DAT                     ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000008) )
+#define IP3203_HSBIR                   ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000010) )
+#define IP3203_FSBIR                   ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000014) )
+#define IP3203_INT_STATUS              ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000FE0) )
+#define IP3203_INT_EN                  ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000FE4) )
+#define IP3203_INT_CLR                 ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000FE8) )
+#define IP3203_POWERDOWN               ( (volatile unsigned int *)(MMIO_IP3203_UNIT0 + 0x00000FF4) )
+
+#define IP3203_FSBIR_BITRATE_POS       (0)
+#define IP3203_FSBIR_BITRATE_MASK      (0x0000007f)
+#define IP3203_AA                      (0x04) /* Bit in the register CONTROL    */
+#define IP3203_STO                     (0x10) /* Bit in the register CONTROL    */
+#define IP3203_STA                     (0x20) /* Bit in the register CONTROL    */
+#define IP3203_INTBIT                  (0x01) /* Bit in the register INT_STATUS */
+#define IP3203_EN                      (0x40) /* Bit in the register CONTROL    */
+
+#define WAIT_IP3203INT()               do{ int t = IP3203_TIMEOUT;                            \
+                                           while(!(*IP3203_INT_STATUS & IP3203_INTBIT)        \
+                                                  && (t-->0)){}                               \
+                                         }while(0)
+
+void pnx8xxx_ip3203_init(void);
+int pnx8xxx_ip3203_write(char* i2c_message, int message_len);
+
diff --git a/drivers/net/lipp_6300eth/lipp_6300eth.c b/drivers/net/lipp_6300eth/lipp_6300eth.c
new file mode 100644
index 0000000..987d33d
--- /dev/null
+++ b/drivers/net/lipp_6300eth/lipp_6300eth.c
@@ -0,0 +1,881 @@
+/* Include files for ethernet driver */
+
+/* lipp_6300eth_common.h includes config.h from uboot code,MAC base address,
+** Speed, mode & autonegotiation
+*/
+
+#include "lipp_6300eth_common.h"
+#include "lipp_6300eth.h"
+#include "tmhwLIPP6100Eth_Vhip.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "tmhwLIPP6100Eth.h"
+#include "tmbslPhy.h"
+
+#include <linux/types.h>
+#include <common.h> /* Needed for datatypes for ethernet driver */
+#include <asm/io.h>
+#include <net.h>
+
+/*----------------------------------------------------------------------------*/
+/* Global data:                                                               */
+/*----------------------------------------------------------------------------*/
+
+/* Global pointer to get the PHY function pointers */
+tmbslPhyConfig_t * gpPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] = {NULL};
+
+/*Array of dma tx & rx descriptor pointers */
+dma_descs_t gDma_desc[NUMBER_OF_INTERFACES] __attribute__((__aligned__(4)));
+
+/* Transmit descriptor list, for each interface */
+TX_DESCR_t gTxDescList[NUMBER_OF_INTERFACES][HW_DESCR_QUEUE_LEN_TX]__attribute__((__aligned__(4)));
+
+/* Receive descriptor list, for each interface */
+RX_DESCR_t gRxDescList[NUMBER_OF_INTERFACES][HW_DESCR_QUEUE_LEN_RX]__attribute__((__aligned__(4)));
+
+/* Allocate buffers, to be used by DMA */
+typedef struct txRxBuffs
+{
+    volatile UInt8 rxBuffer[HW_DESCR_QUEUE_LEN_RX][MAX_ETH_FRAME_SIZE];
+    volatile UInt8 rxCopyBuffer[HW_DESCR_QUEUE_LEN_RX][MAX_ETH_FRAME_SIZE];
+} txRxBuffs_t,*ptxRxBuffs_t;
+
+/* DMA buffers for receive */
+txRxBuffs_t gDmaBuffers[NUMBER_OF_INTERFACES];
+
+UInt8 dev_addr[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF};
+
+/* Ethernet device structure for uboot */
+struct eth_device *pEthDevice[MAX_LIPP_6300ETH_UNITS] = {NULL};
+
+static UInt32 gInitialized = 0;
+/*----------------------------------------------------------------------------*/
+/* Function prototypes                                                        */
+/*----------------------------------------------------------------------------*/
+
+void lipp_6300eth_initialize(void);
+
+static int lipp_6300eth_init(struct eth_device *pEth, bd_t * bis);
+
+static int lipp_6300Eth_recv(struct eth_device *pEth);
+
+static int lipp_6300eth_transmit(struct eth_device *pEth, volatile void *packet, int length);
+
+static void lipp_6300Eth_halt(struct eth_device *pEth);
+
+Int32 setup_phy(plipp_6300eth_priv_t pPriv);
+
+tmErrorCode_t setup_mac(plipp_6300eth_priv_t pPriv);
+
+void setup_dma_descriptors(pdma_descs_t pDesc, UInt32 interfaceNum);
+
+
+/*----------------------------------------------------------------------------*/
+/* Function definitions                                                       */
+/*----------------------------------------------------------------------------*/
+
+void lipp_6300eth_initialize(void)
+{
+
+    UInt32 unitNum,i;
+    plipp_6300eth_priv_t pPriv = NULL;
+
+    GMAC_DBG("Initialize:Start\n");
+
+    gtmhwLIPP6100Eth_Base[0].baseAddress = MAC_BASE_ADDRESS;
+
+    GMAC_DBG("Ethernet MAC base address:%08x\n",MAC_BASE_ADDRESS);
+
+    for(unitNum=0; unitNum < MAX_LIPP_6300ETH_UNITS; unitNum++)
+    {
+
+        pEthDevice[unitNum] = (struct eth_device *) malloc(sizeof (struct eth_device));
+
+        GMAC_DBG("pEthDevice :%08x\n",pEthDevice[unitNum]);
+
+        pEthDevice[unitNum]->priv = NULL;
+
+        if(pEthDevice[unitNum] == NULL)
+        {
+            GMAC_DBG("Mem alloc failed for ethdevice: lip%d ... exiting\n",unitNum);
+            goto __free_mem;
+        }
+
+        pPriv = (plipp_6300eth_priv_t) malloc(sizeof (lipp_6300eth_priv_t));
+
+        if(pPriv == NULL)
+        {
+            GMAC_DBG("Mem alloc failed for priv for lip%d ... exiting\n",unitNum);
+            goto __free_mem;
+        }
+
+        /* Used in tx,rx routines */
+        pEthDevice[unitNum]->priv = pPriv;
+
+        /* Fill the info for future use in init & other functions */
+        pPriv->hwUnitNo = unitNum;
+
+ //       pEthDevice[unitNum]->iobase = (int)gtmhwLIPP6100Eth_Base[unitNum];
+
+        /* Fill the ethernet interface info */
+        sprintf(pEthDevice[unitNum]->name, "lip%d",unitNum);
+
+        memcpy(pEthDevice[unitNum]->enetaddr,dev_addr,6);
+
+        pEthDevice[unitNum]->init = lipp_6300eth_init;
+        pEthDevice[unitNum]->send = lipp_6300eth_transmit;
+        pEthDevice[unitNum]->recv = lipp_6300Eth_recv;
+        pEthDevice[unitNum]->halt = lipp_6300Eth_halt;
+
+        /* Store the descriptor start addresses in the data structure */
+        pPriv->p_tx_descr = &gTxDescList[unitNum][0];
+        pPriv->p_rx_descr = &gRxDescList[unitNum][0];
+        pPriv->dmaEnabled = 0;
+
+		/* Buffers for these descriptors are assigned statically */
+        GMAC_DBG("p_tx_descr list :%08x\n",pPriv->p_tx_descr);
+        GMAC_DBG("p_rx_descr list :%08x\n",pPriv->p_rx_descr);
+
+        /* This used in descriptor initialization only */
+        gDma_desc[unitNum].pTx_desc = &gTxDescList[unitNum][0];
+        gDma_desc[unitNum].pRx_desc = &gRxDescList[unitNum][0];
+
+        setup_dma_descriptors(&gDma_desc[unitNum],unitNum);
+
+        eth_register(pEthDevice[unitNum]);
+
+    }
+
+    GMAC_DBG("lipp_6300eth_initialize:End\n");
+
+    return;
+
+__free_mem:
+    for(i=0;i<unitNum;i++)
+    {
+        if(pEthDevice[unitNum] != NULL)
+        {
+            if(pEthDevice[unitNum]->priv != NULL)
+            {
+                free(pEthDevice[unitNum]->priv);
+            }
+
+            free(pEthDevice[unitNum]);
+        }
+
+    }
+
+}
+
+
+/* Called from n/w interface for h/w initialization */
+static int lipp_6300eth_init(struct eth_device *pEth, bd_t * bis)
+{
+    int ret_val = 0;
+
+    plipp_6300eth_priv_t pPriv = pEth->priv;
+    tmhwLIPP6100Eth_EnTxfr_t Txfer;
+    UInt32 hwVersion;
+    UInt32 i;
+
+    if(gInitialized == 1U)
+    {
+        Txfer.dirFlag = tmhwLIPP6100Eth_Dir_TxRx;
+
+        Txfer.enFlag = tmhwLIPP6100Eth_Enable;
+
+        tmhwLIPP6100Eth_GmacEnableDisable(pPriv->hwUnitNo,&Txfer);
+
+        tmhwLIPP6100Eth_DmaEnableDisable(pPriv->hwUnitNo,&Txfer);
+
+        pPriv->dmaEnabled = 1;
+
+        return 1;
+    }
+
+#ifndef CONFIG_PNX84XX  /*Commented for Apollo */
+    memcpy(dev_addr,bis->bi_enetaddr,6);
+#endif
+
+    memcpy(pEthDevice[0]->enetaddr,dev_addr,6);
+
+    /* Fill in the private structure members */
+    pPriv->rx_consume_index = 0;
+    pPriv->tx_produce_index = 0;
+    pPriv->u_autoneg = ETH_AUTO_NEGOTIATION;
+    pPriv->u_speed = ETH_LINK_SPEED;
+    pPriv->u_mode = ETH_LINK_MODE;
+
+    for(i=0;i< HW_DESCR_QUEUE_LEN_RX;i++)
+    {
+        pPriv->bufferFlip[i] = 0;
+    }
+
+    pPriv->dmaEnabled = 0;
+
+    setup_dma_descriptors(&gDma_desc[pPriv->hwUnitNo],pPriv->hwUnitNo);
+
+    /* Get the PHY interface function pointers */
+    tmbslPhyGetInterface(pPriv->hwUnitNo,&gpPhyInterface[pPriv->hwUnitNo]);
+
+    tmhwLIPP6100Eth_GetHWVersion(pPriv->hwUnitNo,&hwVersion);
+
+    GMAC_DBG("HW Version:%08x\n",hwVersion);
+
+    if(hwVersion != 0x2535U)
+    {
+        GMAC_DBG("Wrong Module ID, returning from initialization\n");
+        return 0;
+    }
+
+    ret_val = tmhwLIPP6100Eth_Init(pPriv->hwUnitNo);
+
+    if(TM_OK !=  ret_val)
+    {
+        GMAC_DBG("MAC init failed\n");
+
+        return (ret_val);
+    }
+
+    ret_val = gpPhyInterface[pPriv->hwUnitNo]->initFunc(pPriv->hwUnitNo);
+
+    if(TM_OK !=  ret_val)
+    {
+        GMAC_DBG("Phy init failed\n");
+
+        return (ret_val);
+    }
+
+    /* Set up the physical layer */
+    ret_val = setup_phy(pPriv);
+
+    if(TM_OK !=  ret_val)
+    {
+        GMAC_DBG("Auto neg failed\n");
+        return (ret_val);
+    }
+
+    ret_val = setup_mac(pPriv);
+
+    if(TM_OK !=  ret_val)
+    {
+        GMAC_DBG("MAC setup failed\n");
+        return (ret_val);
+    }
+
+    /* Enable the GMAC and DMA for both tx & rx directions */
+    Txfer.dirFlag = tmhwLIPP6100Eth_Dir_TxRx;
+    Txfer.enFlag = tmhwLIPP6100Eth_Enable;
+    pPriv->dmaEnabled = 1;
+
+   /* Reads the register and sets the corresponding bit */
+    tmhwLIPP6100Eth_GmacEnableDisable(pPriv->hwUnitNo,&Txfer);
+
+    tmhwLIPP6100Eth_DmaEnableDisable(pPriv->hwUnitNo,&Txfer);
+
+    gInitialized = 1U;
+
+    GMAC_DBG("MAC-PHY init complete,Rx DMA enabled\n");
+
+    return 1;
+
+}
+
+static int lipp_6300Eth_recv(struct eth_device *pEth)
+{
+//    UInt32 intr_status;
+    plipp_6300eth_priv_t pPriv = pEth->priv;
+
+    Int32 ret_val = 0;
+    UInt32 frameSize;
+    pUInt8 pEmptyBuf, pFullBuf;
+    tmhwLIPP6100Eth_Int_t   macStatus;
+    UInt32 intr_status;
+
+//    tmhwLIPP6100Eth_Int_t   IntDis;
+
+//    GMAC_DBG("rx recv : Start");
+
+//    while(1)
+//    {
+
+        /* Read the interrupt status */
+//        tmhwLIPP6100Eth_IntGetStatus( pPriv->hwUnitNo, &IntDis);
+
+#if ENABLE_CACHE
+        invalidate_dcache_range(&pPriv->p_rx_descr[pPriv->rx_consume_index],
+                                ((UInt32)&pPriv->p_rx_descr[pPriv->rx_consume_index])+
+                                 sizeof(RX_DESCR_t));
+#endif
+
+        /* If the descriptor is not processed by DMA then break */
+        if((pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_OWN_VAL) != 0)
+        {
+
+            tmhwLIPP6100Eth_IntGetStatus(pPriv->hwUnitNo,&macStatus);
+
+            intr_status = macStatus.dmaIntVal;
+
+            if(((intr_status & 0xe0000) >> 17) == 0x4)
+            {
+                tmhwLIPP6100Eth_DmaPollDesc(pPriv->hwUnitNo, tmhwLIPP6100Eth_Dir_Rx);
+            }
+
+            goto __no_pkts_received;
+
+        }
+
+        /* If length Error bit is set */
+        if(pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_LEN_ERR_VAL )
+        {
+            GMAC_DBG("\nhandle_receive_packets: Length Errors");
+            goto _err_drop_packet ;
+        }
+
+        if(pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_DRIBBLE_VAL)
+        {
+            GMAC_DBG("\nhandle_receive_packets: Dribble Error");
+            goto _err_drop_packet ;
+        }
+
+        if((pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_FIRST_DESC_VAL) &&
+            (pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_LAST_DESC_VAL))
+        {
+
+            /* If the error summary bit is set, check for overflow and CRC errors
+            ** This is valid when last descriptor bit is set
+            */
+            if(pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_ERR_SUM_VAL)
+            {
+                if(pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_OVERFLOW_ERR_VAL)
+                {
+                    GMAC_DBG("\nhandle_receive_packets: OverFlow Error: Index %d",pPriv->rx_consume_index);
+                }
+                if(pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 & RXDESC_RDES0_CRC_ERR_VAL)
+                {
+                    GMAC_DBG("\nhandle_receive_packets: CRC Error");
+                }
+
+                goto _err_drop_packet ;
+
+            }
+
+            /* Submit the frame to the Kernel */
+            frameSize = (pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 &
+                        RXDESC_RDES0_FRM_LEN_MSK) >> RXDESC_RDES0_FRM_LEN_POS;
+
+			#if ENABLE_VIRT_TO_PHYS
+            pFullBuf = phys_to_virt((pUInt8)pPriv->p_rx_descr[pPriv->rx_consume_index].RDES2);
+			#else
+            pFullBuf = (pUInt8)pPriv->p_rx_descr[pPriv->rx_consume_index].RDES2;
+			#endif
+
+			#if ENABLE_CACHE
+			//           flush_cache(pFullBuf,frameSize);
+            invalidate_dcache_range(pFullBuf, pFullBuf+frameSize);
+			#endif
+
+//            GMAC_DBG("Rx %u\n",++rxPktCount);
+
+            /* If the frame received is valid, pass it to the upper layer */
+            NetReceive(pFullBuf,le32_to_cpu(frameSize));
+
+            if( pPriv->bufferFlip[pPriv->rx_consume_index] == 0)
+            {
+                pEmptyBuf = &gDmaBuffers[pPriv->hwUnitNo].rxCopyBuffer[pPriv->rx_consume_index][0];
+                pPriv->bufferFlip[pPriv->rx_consume_index] = 1;
+            }
+            else
+            {
+                pEmptyBuf = &gDmaBuffers[pPriv->hwUnitNo].rxBuffer[pPriv->rx_consume_index][0];
+                pPriv->bufferFlip[pPriv->rx_consume_index] =0;
+            }
+
+			#if ENABLE_VIRT_TO_PHYS
+            pPriv->p_rx_descr[pPriv->rx_consume_index].RDES2 = virt_to_phys(pEmptyBuf);
+			#else
+            pPriv->p_rx_descr[pPriv->rx_consume_index].RDES2 = (UInt32)pEmptyBuf;
+			#endif
+
+			/* When bufferflip =0, rx buf is full & copybuf is empty. Next time again use
+            ** rx buf as empty buf & copy buf as full buff. Invert the same.
+            */
+
+//            GMAC_DBG("Next Rx DMA desc :%08x",*(UInt32*)(TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0+0x104C));
+
+//          flush_cache(pPriv->p_rx_descr,HW_DESCR_QUEUE_LEN_RX*sizeof(RX_DESCR_t));
+            ret_val = 1;
+
+        }
+        else
+        {
+            tmhwLIPP6100Eth_Int_t intStat;
+            GMAC_DBG("handle_receive_packets: Dropped Pkt..EOF not set");
+            GMAC_DBG("Current RDES0:%08x\n",pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0);
+            tmhwLIPP6100Eth_IntGetStatus(0,&intStat);
+            GMAC_DBG("Int Stat:%08x\n",intStat.dmaIntVal);
+
+            GMAC_DBG("Current Rx DMA desc :%08x",*(UInt32*)(MAC_BASE_ADDRESS+0x104C));
+            GMAC_DBG("Current Rx Buf:%08x",*(UInt32*)(MAC_BASE_ADDRESS+0x1054));
+
+            goto _err_drop_packet;
+
+        }
+
+        _err_drop_packet :
+
+//		 GMAC_DBG("Current Rx DMA desc :%08x\n",*(UInt32*)(TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0+0x104C));
+
+		 /* Set back the own bit for this descriptor, use the same buffer */
+        pPriv->p_rx_descr[pPriv->rx_consume_index].RDES0 = RXDESC_RDES0_OWN_VAL;
+
+#if ENABLE_CACHE
+        /* After setting & upating the buffer, flush cache */
+        flush_cache((UInt32)(&pPriv->p_rx_descr[pPriv->rx_consume_index]),sizeof(RX_DESCR_t));
+#endif
+
+        if(pPriv->rx_consume_index >= (HW_DESCR_QUEUE_LEN_RX-1))
+        {
+            pPriv->rx_consume_index = 0;
+        }
+        else
+        {
+            pPriv->rx_consume_index++;
+        }
+
+__no_pkts_received:
+
+//        GMAC_DBG("rx recv : End\n");
+        return (ret_val);
+
+//    }
+
+}
+
+
+static int
+lipp_6300eth_transmit(struct eth_device *pEth, volatile void *packet, int length)
+{
+
+    plipp_6300eth_priv_t pPriv = (plipp_6300eth_priv_t)pEth->priv;
+
+    UInt32 ret_val = 0;
+    UInt32 intr_status;
+    tmhwLIPP6100Eth_Int_t   macStatus;
+    tmhwLIPP6100Eth_EnTxfr_t Txfer;
+
+#if 0
+    int i;
+    char*p = (char*)packet;
+
+    GMAC_DBG("Tx: Start\n");
+
+    GMAC_DBG("Virt bufaddr:%08x\n",p);
+
+    if (*(unsigned long *)p == *(unsigned long *) ((unsigned long)p & 0x0FFFFFFFUL))
+        {
+        printf (" Mirror check successful\r\n");
+        }else
+        printf (" Mirror check failed\r\n");
+
+    for(i=0;i< length;i++)
+    {
+        GMAC_DBG("%1x",*(p++));
+    }
+#endif
+
+
+		/* Check if the own bit is cleared for the current transmit index.
+    ** Transmit index loops back after reaching the max descriptor length
+    ** For transmit descriptor, only end of ring is set in setup_descriptors()
+    */
+//    pPriv->p_tx_descr = (struct TX_DESCR_t *)0x500000;
+
+ /*   invalidate_dcache_range(&pPriv->p_tx_descr[pPriv->tx_produce_index],
+                            ((UInt32)&pPriv->p_tx_descr[pPriv->tx_produce_index])+
+                             sizeof(TX_DESCR_t));
+*/
+
+    if(0 == (pPriv->p_tx_descr[pPriv->tx_produce_index].TDES0 & TXDESC_TDES0_OWN_VAL))
+    {
+
+		#if ENABLE_VIRT_TO_PHYS
+        pPriv->p_tx_descr[pPriv->tx_produce_index].TDES2 = (UInt32)virt_to_phys(packet);
+		#else
+        pPriv->p_tx_descr[pPriv->tx_produce_index].TDES2 = (UInt32)packet;
+		#endif
+
+//        pPriv->p_tx_descr[pPriv->tx_produce_index].TDES2 = (UInt32)CPHYSADDR(packet);
+
+		pPriv->p_tx_descr[pPriv->tx_produce_index].TDES1 &= TXDESC_TDES1_TX_BUF1_SIZE_CLR;
+        pPriv->p_tx_descr[pPriv->tx_produce_index].TDES0 |=
+                                                        TXDESC_TDES0_LASTSEG_VAL |
+                                                        TXDESC_TDES0_FIRSTSEG_VAL;
+
+		pPriv->p_tx_descr[pPriv->tx_produce_index].TDES1 = length;
+
+        /* Set the own bit value as the last statement. Otherwise, there could be a race condition */
+        pPriv->p_tx_descr[pPriv->tx_produce_index].TDES0 |= TXDESC_TDES0_OWN_VAL;
+
+#if ENABLE_CACHE
+        flush_cache((UInt32)(&pPriv->p_tx_descr[pPriv->tx_produce_index]),sizeof(TX_DESCR_t));
+
+        flush_cache(packet,length);
+#endif
+
+        if( 1 == pPriv->dmaEnabled)
+        {
+            /* If DMA is in suspended state, write to Transmit poll demand register
+            ** Otherwise, enable GMAC and DMA
+            */
+            tmhwLIPP6100Eth_IntGetStatus(pPriv->hwUnitNo,&macStatus);
+
+            intr_status = macStatus.dmaIntVal;
+
+            if(((intr_status & 0x700000) >> 20) == 0x6)
+            {
+                tmhwLIPP6100Eth_DmaPollDesc(pPriv->hwUnitNo, tmhwLIPP6100Eth_Dir_Tx);
+            }
+
+        }
+        else
+        {
+            /* Enable the GMAC and DMA for both tx direction */
+            Txfer.dirFlag = tmhwLIPP6100Eth_Dir_Tx;
+            Txfer.enFlag = tmhwLIPP6100Eth_Enable;
+
+            /* Reads the register and sets the corresponding bit */
+            tmhwLIPP6100Eth_GmacEnableDisable(pPriv->hwUnitNo,&Txfer);
+
+            tmhwLIPP6100Eth_DmaEnableDisable(pPriv->hwUnitNo,&Txfer);
+
+            pPriv->dmaEnabled =1;
+        }
+
+       /* Get the next produce index to set to. For 1 desc, this executes always */
+        if( pPriv->tx_produce_index >= ( HW_DESCR_QUEUE_LEN_TX - 1 ))
+        {
+            pPriv->tx_produce_index = 0 ;
+        }
+        else
+        {
+            pPriv->tx_produce_index++;
+        }
+
+//       mdelay(2);
+
+#if 0
+        GMAC_DBG("Buff Len:%d",length);
+
+        GMAC_DBG("Current Tx Desc:%08x",*(UInt32*)(TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0+0x1048));
+        GMAC_DBG("Current Tx Buf:%08x",*(UInt32*)(TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0+0x1050));
+
+        GMAC_DBG("Virtual Addr:%08x",&pPriv->p_tx_descr[pPriv->tx_produce_index]);
+        GMAC_DBG("TDES0:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES0);
+        GMAC_DBG("TDES1:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES1);
+        GMAC_DBG("TDES2:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES2);
+        GMAC_DBG("TDES3:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES3);
+        GMAC_DBG("Pkt txtd");
+#endif
+        /* Wait for the transmission to complete & own bit to get cleared  */
+        ret_val = 1;
+    }
+    else
+    {
+        #if 0
+        GMAC_DBG("W$$W%WOWN not clred%%#$#\n\n");
+        GMAC_DBG("Buff Len:%d",length);
+
+        GMAC_DBG("Current Tx Desc:%08x",*(UInt32*)(TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0+0x1048));
+        GMAC_DBG("Current Tx Buf:%08x",*(UInt32*)(TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0+0x1050));
+
+        GMAC_DBG("Virtual Addr:%08x",&pPriv->p_tx_descr[pPriv->tx_produce_index]);
+        GMAC_DBG("TDES0:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES0);
+        GMAC_DBG("TDES1:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES1);
+        GMAC_DBG("TDES2:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES2);
+        GMAC_DBG("TDES3:%08x",pPriv->p_tx_descr[pPriv->tx_produce_index].TDES3);
+        #endif
+
+    }
+
+//    GMAC_DBG("Tx: End\n\n");
+
+    return ret_val;
+
+}
+
+static void lipp_6300Eth_halt(struct eth_device *pEth)
+{
+
+    plipp_6300eth_priv_t pPriv = pEth->priv;
+
+    tmhwLIPP6100Eth_EnTxfr_t txfer;
+
+    GMAC_DBG("Halt:Start\n");
+
+    txfer.dirFlag = tmhwLIPP6100Eth_Dir_TxRx;
+
+    txfer.enFlag = tmhwLIPP6100Eth_Disable;
+
+    tmhwLIPP6100Eth_GmacEnableDisable(pPriv->hwUnitNo,&txfer);
+
+    tmhwLIPP6100Eth_DmaEnableDisable(pPriv->hwUnitNo,&txfer);
+
+    pPriv->dmaEnabled = 0;
+
+    /* Reset all the own bits in receive descriptors , so that no pkts are received */
+    mdelay(1);
+
+    GMAC_DBG("Halt:End\n");
+
+}
+
+Int32 setup_phy(plipp_6300eth_priv_t pPriv)
+{
+    Int32 i = 0 ;
+    tmbslPhyBasicModeStatus_t  bms ;
+    tmbslPhyBasicModeControl_t bmc ;
+    tmbslPhyAutoNegotiationMask_t auto_neg_mask ;
+    tmErrorCode_t ret_val;
+
+    memset(&auto_neg_mask,0,sizeof(tmbslPhyAutoNegotiationMask_t));
+
+    /*
+    * Now check the parameters that are stored in private structure and
+    * accordingly configure the Phy and Mac
+    */
+
+    /* Common parameters. Enabling the mask disables the feature */
+    auto_neg_mask.mask100BaseT4 = tmbslPhyEnable;
+    auto_neg_mask.masknextPageDesired = tmbslPhyEnable;
+    auto_neg_mask.protocolSel = tmbslPhyIEEE8023;
+    auto_neg_mask.maskRemoteFault = tmbslPhyEnable;
+
+    if( pPriv->u_autoneg == LX_AUTONEG_ENABLE )
+    {
+
+        if(LX_SPEED_10 == ETH_LINK_SPEED)
+        {
+            auto_neg_mask.mask100BaseTxFullDuplexSupport = tmbslPhyEnable;
+            auto_neg_mask.mask100BaseTxSupport = tmbslPhyEnable;
+        }
+
+        /* autonegotiate for three times. If every time it fails, then set fixed values */
+        for( i = 0 ; i < AUTO_NEG_RETRY_COUNT ; i++ )
+        {
+            ret_val =  gpPhyInterface[pPriv->hwUnitNo]->autoNegotiateFunc( pPriv->hwUnitNo, &auto_neg_mask);
+
+            if(TM_OK ==  ret_val)
+            {
+                break;
+            }
+
+        }
+
+        if(TM_OK != ret_val)
+        {
+            GMAC_DBG("Auto Negotiation Failed.Disabling auto negotiation\n");
+        }
+
+    }
+
+    if( ( pPriv->u_autoneg == LX_AUTONEG_DISABLE ) || ( i == AUTO_NEG_RETRY_COUNT) )
+    {
+        /* auto negotiation is disabled or auto negotiation is failed, then set the parameters
+        ** into phy register
+        */
+
+        switch(pPriv->u_speed)
+        {
+        case LX_SPEED_100:
+            bmc.speed = tmbslPhySpeed100Mbps;
+            break;
+        case LX_SPEED_10:
+            bmc.speed = tmbslPhySpeed10Mbps;
+            break;
+        default:
+            bmc.speed = tmbslPhySpeed10Mbps;
+            break;
+        }
+
+        bmc.duplexMode = ( pPriv->u_mode == LX_MODE_FULL_DUPLEX )? tmbslPhyFullDuplex : tmbslPhyHalfDuplex ;
+
+        bmc.enableCollisionTest = tmbslPhyDisable ;
+
+        /* Write into basic mode control register, the speed and mode values. This function
+        ** disables auto negotiation
+        */
+        if( gpPhyInterface[pPriv->hwUnitNo]->setBasicModeControlFunc(pPriv->hwUnitNo,&bmc ) != TM_OK )
+        {
+            GMAC_DBG("PHY link setup failed\n");
+            goto _err_setup_phy ;
+        }
+
+    }
+
+    /* read the status register to get the speed/duplex mode */
+    if( gpPhyInterface[pPriv->hwUnitNo]->getBasicModeStatusFunc( pPriv->hwUnitNo, &bms) != TM_OK )
+    {
+        GMAC_DBG("Get Basic Mode status failed\n");
+        goto _err_setup_phy ;
+    }
+
+    /* store the updated results into the priv structure */
+    pPriv->u_mode = bms.duplexMode ;
+
+    if(tmbslPhySpeed100Mbps == bms.speed)
+    {
+        pPriv->u_speed = LX_SPEED_100;
+    }
+    else if(tmbslPhySpeed10Mbps == bms.speed)
+    {
+        pPriv->u_speed = LX_SPEED_10;
+    }
+
+    return 0 ;
+
+_err_setup_phy:
+
+    return -1 ;
+
+}
+
+tmErrorCode_t setup_mac(plipp_6300eth_priv_t pPriv)
+{
+
+    tmhwLIPP6100Eth_DevConfig_t	eth_cfg ;
+    tmhwLIPP6100Eth_DmaCfg_t dmaCfg;
+    tmhwLIPP6100Eth_Int_t IntDis;
+
+    UInt32 unitNum = pPriv->hwUnitNo;
+
+    GMAC_DBG("setup_mac: Start\n");
+
+    /* Clear the structure */
+    memset(&eth_cfg,0,sizeof(tmhwLIPP6100Eth_DevConfig_t));
+    memset(&dmaCfg,0,sizeof(tmhwLIPP6100Eth_DmaCfg_t));
+
+    /* Do the ethernet MAC configuration */
+    eth_cfg.autoPadCRC = True;
+    eth_cfg.backOffLim = tmhwLIPP6100Eth_BackoffVal0;
+    eth_cfg.clockSelect = (tmhwLIPP6100Eth_ClkDiv_t)TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL;
+    eth_cfg.ifg = tmhwLIPP6100Eth_IFG96bits;
+    eth_cfg.phyAddress = TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL;
+
+    if(LX_SPEED_1000 != pPriv->u_speed)
+    {
+        eth_cfg.miiSelect = True; /* 10/100Mbps mode */
+    }
+    else
+    {
+        eth_cfg.miiSelect = False;
+    }
+
+    if(LX_SPEED_100 == pPriv->u_speed)
+    {
+        eth_cfg.speed100Mbps = True;
+    }
+
+    if( LX_MODE_FULL_DUPLEX == pPriv->u_mode)
+    {
+        eth_cfg.duplexMode = True;
+    }
+
+     /* set the MAC address & correct endianness */
+    eth_cfg.station.adrHigh = (__u32) le16_to_cpu(*((__u16 *)&dev_addr[4]));
+
+    eth_cfg.station.adrLow = le32_to_cpu(*((__u32 *)dev_addr));
+
+    tmhwLIPP6100Eth_SetConfig( unitNum, &eth_cfg);
+
+    /* DMA transmits packets in store and forward mode */
+    dmaCfg.storeNforwardEn = (Bool)ETH_STORE_FWD_ENABLE;
+    dmaCfg.rxThreshold = (tmhwLIPP6100Eth_RTC_t)ETH_RX_THRESHOLD;
+    dmaCfg.txThreshold = (tmhwLIPP6100Eth_TTC_t)ETH_TX_THRESHOLD;
+
+    dmaCfg.disableFrameFlush  = (Bool)ETH_DISABLE_FRAME_FLUSH;
+    dmaCfg.fixedBurstEn = (Bool)ETH_FIXED_BURST_ENABLE;
+
+    dmaCfg.differentPBL = (Bool)ETH_DIFF_PBL_ENABLE;
+    dmaCfg.pBL4xmode = (Bool)ETH_4XPBL_ENABLE;
+    dmaCfg.burstLen = (tmhwLIPP6100Eth_PBL_t)ETH_TX_PBL_VAL;
+    dmaCfg.rxPBL = (tmhwLIPP6100Eth_PBL_t)ETH_RX_PBL_VAL;
+
+    dmaCfg.txSecondFrameEn = (Bool)ETH_ENABLE_OSF;
+
+    dmaCfg.dmaArbitration = (Bool)ETH_DMA_ARBITRATION;
+
+    dmaCfg.priority = (tmhwLIPP6100Eth_DmaPriority_t)ETH_DMA_PRIORITY;
+
+    /* Set the base addresses in the DMA registers */
+#if ENABLE_VIRT_TO_PHYS
+    dmaCfg.txDescListBaseAdr = (UInt32)virt_to_phys(pPriv->p_tx_descr);
+    dmaCfg.rxDescListBaseAdr = (UInt32)virt_to_phys(pPriv->p_rx_descr);
+#else
+    dmaCfg.txDescListBaseAdr = (UInt32)(pPriv->p_tx_descr);
+    dmaCfg.rxDescListBaseAdr = (UInt32)(pPriv->p_rx_descr);
+#endif
+
+//    dmaCfg.txDescListBaseAdr = (UInt32)CPHYSADDR(pPriv->p_tx_descr);
+//    dmaCfg.rxDescListBaseAdr = (UInt32)CPHYSADDR(pPriv->p_rx_descr);
+
+	tmhwLIPP6100Eth_DmaConfig(unitNum,&dmaCfg);
+
+	/* Disable all interrupts */
+    IntDis.dmaIntVal = DMA_MASK_ALL_INTS;
+    IntDis.gmacIntVal = 0 ;
+
+    tmhwLIPP6100Eth_IntDisable(unitNum,&IntDis);
+
+    GMAC_DBG("setup_mac: End\n");
+
+    return 0 ;
+
+}
+
+/* Initializes one Tx & Rx descriptor chain, and the buffers for Tx and Rx direction */
+void setup_dma_descriptors(pdma_descs_t pDesc, UInt32 interfaceNum)
+{
+
+    UInt32 num_descs;
+
+    memset(pDesc->pTx_desc,0, (sizeof(TX_DESCR_t)*HW_DESCR_QUEUE_LEN_TX));
+
+    /* Set the Transmit End of Ring bit */
+    pDesc->pTx_desc[HW_DESCR_QUEUE_LEN_TX-1].TDES0 |= TXDESC_TDES0_END_OF_RING_VAL;
+
+    /* Transmit gets buffer from n/w stack. So no need to allocate */
+    #if 0
+    for(num_descs=0; num_descs < HW_DESCR_QUEUE_LEN_TX; num_descs++)
+    {
+        /* Initialize the buffers */
+        pDesc->pTx_desc[num_descs].TDES2= &gDmaBuffers[interfaceNum].txBuffer[interfaceNum][num_descs];
+    }
+    #endif
+
+    /* Initialize receive descriptors with buffer pointers and set the own bit */
+    for(num_descs=0; num_descs < HW_DESCR_QUEUE_LEN_RX; num_descs++)
+    {
+        /* Set the own bit. DMA can process the descriptors only with own bit set */
+        pDesc->pRx_desc[num_descs].RDES0 = RXDESC_RDES0_OWN_VAL;
+        pDesc->pRx_desc[num_descs].RDES1 = MAX_ETH_FRAME_SIZE;
+
+		#if ENABLE_VIRT_TO_PHYS
+        pDesc->pRx_desc[num_descs].RDES2 = (UInt32)virt_to_phys( &gDmaBuffers[interfaceNum].rxBuffer[num_descs][0]);
+		#else
+        pDesc->pRx_desc[num_descs].RDES2 = (UInt32)&gDmaBuffers[interfaceNum].rxBuffer[num_descs][0];
+		#endif
+
+//        pDesc->pRx_desc[num_descs].RDES2 = (UInt32)CPHYSADDR(&gDmaBuffers[interfaceNum].rxBuffer[num_descs][0]);
+        pDesc->pRx_desc[num_descs].RDES3 = 0;
+    }
+
+    /*End of ring bit is set for receive direction */
+    pDesc->pRx_desc[num_descs-1].RDES1 |= RXDESC_RDES1_END_OF_RING_VAL;
+
+	#if ENABLE_CACHE
+    flush_cache(pDesc->pRx_desc,sizeof(RX_DESCR_t)*HW_DESCR_QUEUE_LEN_RX);
+	#endif
+
+}
+
+
diff --git a/drivers/net/lipp_6300eth/lipp_6300eth.h b/drivers/net/lipp_6300eth/lipp_6300eth.h
new file mode 100644
index 0000000..c18c4b0
--- /dev/null
+++ b/drivers/net/lipp_6300eth/lipp_6300eth.h
@@ -0,0 +1,362 @@
+/* lipp_6300eth.h */
+#ifndef _LIPP_6300ETH_H_
+#define _LIPP_6300ETH_H_
+
+#include "tmNxTypes.h"
+
+/* Macros for MAC driver */
+
+/* Device speed macros */
+#define DEVICE_SPEED_10MBPS (10)
+#define DEVICE_SPEED_100MBPS (100)
+#define DEVICE_SPEED_1G (1000)
+
+/* Macros to define speed of the link */
+#define LX_SPEED_1000  (1000)
+#define LX_SPEED_100 (100)
+#define LX_SPEED_10 (10)
+
+#define LX_MODE_FULL_DUPLEX (1)
+#define LX_MODE_HALF_DUPLEX (0)
+
+/* Autonegotiation enable/disable macros */
+#define LX_AUTONEG_ENABLE (1)
+#define LX_AUTONEG_DISABLE (0)
+
+#define LX_FLOW_CONTROL_ENABLED (1)
+#define LX_FLOW_CONTROL_DISABLED (0)
+
+#define LX_RX_FLOW_CONTROL (0x02)
+#define LX_TX_FLOW_CONTROL (0x04)
+
+#define LX_FILTER_TYPE_SW (0)
+#define LX_FILTER_TYPE_HW (1)
+
+#define LX_PROMISC_ENABLED (1)
+#define LX_PROMISC_DISABLED (0)
+
+#define LX_4SLOT_TIMES (0)
+#define LX_28SLOT_TIMES (1)
+#define LX_144SLOT_TIMES (2)
+#define LX_256SLOT_TIMES (3)
+
+/* Fill level of receive FIFO for activating/deactivating
+** hardware flow control. Used when the macro ENABLE_HW_FLOW_CONTROL
+** is set to 1.
+*/
+#define FIFO_FILL_LEVEL_1K (0)
+#define FIFO_FILL_LEVEL_2K (1)
+#define FIFO_FILL_LEVEL_3K (2)
+#define FIFO_FILL_LEVEL_4K (3)
+#define FIFO_FILL_LEVEL_5K (4)
+#define FIFO_FILL_LEVEL_6K (5)
+#define FIFO_FILL_LEVEL_7K (6)
+
+/* Programmable burst length values */
+#define BURST_LENGTH_1 (1)
+#define BURST_LENGTH_2 (2)
+#define BURST_LENGTH_4 (4)
+#define BURST_LENGTH_8 (8)
+#define BURST_LENGTH_16 (16)
+#define BURST_LENGTH_32 (32)
+
+/* DMA transmit threshold values */
+#define TX_DMA_THRESHOLD_VAL_64 (0)
+#define TX_DMA_THRESHOLD_VAL_128 (1)
+#define TX_DMA_THRESHOLD_VAL_192 (2)
+#define TX_DMA_THRESHOLD_VAL_256 (3)
+#define TX_DMA_THRESHOLD_VAL_40 (4)
+#define TX_DMA_THRESHOLD_VAL_32 (5)
+#define TX_DMA_THRESHOLD_VAL_24 (6)
+#define TX_DMA_THRESHOLD_VAL_16 (7)
+
+/* DMA receive threshold values */
+#define RX_DMA_THRESHOLD_VAL_64 (0)
+#define RX_DMA_THRESHOLD_VAL_32 (1)
+#define RX_DMA_THRESHOLD_VAL_96 (2)
+#define RX_DMA_THRESHOLD_VAL_128 (3)
+
+/* DMA priorities in Rx:Tx ratio */
+#define DMA_RX1_TX1 (0)
+#define DMA_RX2_TX1 (1)
+#define DMA_RX3_TX1 (2)
+#define DMA_RX4_TX1 (3)
+
+
+/*----------------------------------------------------------------------------*/
+/*********************** configuration options for MAC    *********************/
+/*----------------------------------------------------------------------------*/
+
+/* Rx Frame size should be multiple of 4/8/16 depending on bus width. 
+ * The frame size should be at least (MTU+14) bytes after meeting the above
+ * condition
+ */
+#define MAX_ETH_FRAME_SIZE (1536)
+
+/* Number of descriptors for transmit side */
+#define HW_DESCR_QUEUE_LEN_TX  (1)
+
+/* Number of descriptors for receive side */
+#define HW_DESCR_QUEUE_LEN_RX  (10)
+
+/* Interfaces macros */
+#define NUMBER_OF_INTERFACES (1)
+
+/* HW or SW filtering */
+#define ETH_FILTER_TYPE (LX_FILTER_TYPE_HW)
+
+/* Software based flow control -Enable/Disable */
+#define ETH_FLOW_CTRL (LX_FLOW_CONTROL_DISABLED)
+
+/* Macro to enable hardware flow control if the receive FIFO size
+ * is greater than 4K
+ */    
+#define ENABLE_HW_FLOW_CONTROL (0)
+
+/* Activate flow control when the empty space falls below this value */
+#define RFA_THRESHOLD (FIFO_FILL_LEVEL_5K)
+
+/* Deactivate flow control when FIFO fill level is less than this value */
+#define RFD_THRESHOLD (FIFO_FILL_LEVEL_4K)
+
+#define ETH_DISABLE_FRAME_FLUSH (1)
+
+/* Enable Operate on second frame. 1-Enable, 0-Disable */
+#define ETH_ENABLE_OSF (0)
+
+#define ETH_STORE_FWD_ENABLE (1)
+
+#define ETH_TX_THRESHOLD (TX_DMA_THRESHOLD_VAL_256)
+
+#define ETH_RX_THRESHOLD (RX_DMA_THRESHOLD_VAL_128)
+
+/* 4*X PBL mode enable/disable */
+#define ETH_4XPBL_ENABLE (0)
+
+/* Separate PBL for Tx & Rx */
+#define ETH_DIFF_PBL_ENABLE (0)
+
+#define ETH_FIXED_BURST_ENABLE (1)
+
+/* Programmable burst length value */
+#define ETH_TX_PBL_VAL (BURST_LENGTH_32)
+
+#define ETH_RX_PBL_VAL (BURST_LENGTH_32)
+
+/* Enable/Disable DMA arbitration scheme */
+#define ETH_DMA_ARBITRATION (0)
+
+/* When DA bit is reset, the values are valid */
+#define ETH_DMA_PRIORITY (DMA_RX1_TX1)
+
+/* Flow control direction Tx/Rx or Both */
+#define ETH_FLOW_CTRL_DIR (LX_RX_FLOW_CONTROL | LX_TX_FLOW_CONTROL)
+
+/* Promiscuous mode enable/disable */
+#define ETH_PROMISC_MODE (LX_PROMISC_DISABLED)
+
+/* Time sent in a pause frame in slot times. Max value is 0xFFFF slot time
+** Each slot time is 512 bit times in GMII/MII mode
+*/    
+#define LX_PAUSE_TIMER_VALUE (256)
+
+/* Pause low threshold value  */
+#define ETH_PLT_VALUE (LX_4SLOT_TIMES)
+
+/* To find if there are enough descriptors are available to receive frames */
+#define LX_DESC_GAP (10)
+
+#undef  CONTROL_INTR_FREQ
+
+/* Frequency at which the transmit side is interrupted */
+#define ETH_TX_INTR_FREQ (1)
+
+/* Frequency at which the receive side is interrupted */
+#define ETH_RX_INTR_FREQ (1)
+
+/* Autonegotiation retry count */
+#define AUTO_NEG_RETRY_COUNT (3)
+
+/* Number of perfect address filters available on the hardware
+** Perfect Filter register 0 is used for MAC address
+** Remaining Perfect Filter registers (1-31) are used for programming multicast addresses 
+*/
+#define ETH_NUM_OF_PER_ADR_FILTERS (32)
+
+/*----------------------------------------------------------------------------*/
+/**********************      Descriptor values     ****************************/
+/*----------------------------------------------------------------------------*/
+
+/* Transmit descriptor macros */
+#define TXDESC_TDES0_OWN_VAL (0x80000000)
+
+/* Status bits 16:0 */
+#define TXDESC_TDES0_IHE_VAL (0x10000)
+#define TXDESC_TDES0_ES_VAL (0x8000)
+#define TXDESC_TDES0_JABTIMEOUT_VAL (0x4000)
+#define TXDESC_TDES0_FRMFLUSH_VAL (0x2000)
+#define TXDESC_TDES0_LOSSOFCAR_VAL (0x800)
+#define TXDESC_TDES0_NOCAR_VAL (0x400)
+#define TXDESC_TDES0_LATECOL_VAL (0x200)
+#define TXDESC_TDES0_EXCOL_VAL (0x100)
+#define TXDESC_TDES0_VLAN_VAL (0x80)
+#define TXDESC_TDES0_COLCNT_MSK (0x78)
+#define TXDESC_TDES0_COLCNT_POS (3)
+#define TXDESC_TDES0_EXDEF_VAL (0x4)
+#define TXDESC_TDES0_UNDERFLOW_VAL (0x2)
+#define TXDESC_TDES0_DEF_BIT_VAL (0x1)
+
+/* Control  Bits 30:26 */
+#define TXDESC_TDES0_INT_VAL (0x40000000)
+#define TXDESC_TDES0_LASTSEG_VAL (0x20000000)
+#define TXDESC_TDES0_FIRSTSEG_VAL (0x10000000)
+#define TXDESC_TDES0_CRC_DISABLE_VAL (0x8000000)
+#define TXDESC_TDES0_PAD_DISABLE_VAL (0x4000000)
+
+/* Control  Bits  Bits 23:20 */
+#define TXDESC_TDES0_CIC_CLR (0xC00000)
+#define TXDESC_TDES0_CIC_POS (22)
+#define TXDESC_TDES0_END_OF_RING_VAL (0x200000)
+#define TXDESC_TDES0_SEC_ADR_CHAIN_VAL (0x100000)
+
+#define TXDESC_TDES1_TX_BUF2_SIZE_CLR (0xE000FFFF)
+#define TXDESC_TDES1_TX_BUF2_SIZE_POS (16)
+#define TXDESC_TDES1_TX_BUF1_SIZE_CLR (0xFFFFE000)
+#define TXDESC_TDES1_TX_BUF1_SIZE_MSK (0x1FFF)
+
+/* Receive descriptor macros */
+#define RXDESC_RDES0_OWN_VAL (0x80000000)
+#define RXDESC_RDES0_DST_ADR_FAIL_VAL (0x40000000)
+
+#define RXDESC_RDES0_FRM_LEN_MSK (0x3fff0000)
+#define RXDESC_RDES0_FRM_LEN_POS (16)
+
+#define RXDESC_RDES0_ERR_SUM_VAL (0x8000)
+#define RXDESC_RDES0_DESC_ERR_VAL (0x4000)
+#define RXDESC_RDES0_SRC_ADR_FAIL_VAL (0x2000)
+#define RXDESC_RDES0_LEN_ERR_VAL (0x1000)
+#define RXDESC_RDES0_OVERFLOW_ERR_VAL (0x800)
+#define RXDESC_RDES0_VLAN_TAG_VAL (0x400)
+#define RXDESC_RDES0_FIRST_DESC_VAL (0x200)
+#define RXDESC_RDES0_LAST_DESC_VAL (0x100)
+#define RXDESC_RDES0_IPC_GIANT_VAL (0x80)
+#define RXDESC_RDES0_LATE_COL_VAL (0x40)
+#define RXDESC_RDES0_FRM_TYP_VAL (0x20)
+#define RXDESC_RDES0_WDOG_VAL (0x10)
+#define RXDESC_RDES0_RX_ERR_VAL (0x8)
+#define RXDESC_RDES0_DRIBBLE_VAL (0x4)
+#define RXDESC_RDES0_CRC_ERR_VAL (0x2)
+#define RXDESC_RDES0_ADR_MATCH_VAL (0x1)
+
+/* RDES1 */
+#define RXDESC_RDES1_DIS_IOC_VAL (0x80000000)
+#define RXDESC_RDES1_DIS_IOC_CLR (0x7FFFFFFF)
+
+#define RXDESC_RDES1_END_OF_RING_VAL (0x8000)
+#define RXDESC_RDES1_SEC_ADR_CHN_VAL (0x4000)
+#define RXDESC_RDES1_BUF2_LEN_CLR (0xE000FFFF)
+#define RXDESC_RDES1_BUF2_LEN_POS (16)
+#define RXDESC_RDES1_BUF1_LEN_MSK (0x1FFF)
+#define RXDESC_RDES1_BUF1_LEN_CLR (0xFFFFE000)
+
+/*----------------------------------------------------------------------------*/
+/**********************      Interrupt masks       ****************************/
+/*----------------------------------------------------------------------------*/
+#define DMA_MASK_ALL_INTS (0xFFFF)
+
+#define GMAC_MASK_ALL_INTS (0xF)
+
+/* Macro to clear the status bits. Bits are clear on write */
+#define DMA_CLR_ALL_INTS (0xE7FF)
+
+/* Macro for clearing receive status */
+#define RX_STAT_MSK (TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_RU_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_NIS_VAL | \
+                                  TMHW_LIPP6100ETH_DMA_STATUS_AIS_VAL)
+
+/* Receive interrupts macro for disabling interrupts for NAPI */
+#define RX_INT_MSK (TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL |  \
+                                TMHW_LIPP6100ETH_DMA_INT_RUE_EN_VAL | \
+                                TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL )
+
+/* Desired transmit interrupts */
+/* Fatal bus error interrupt, Normal Interrupt summary,Abnormal Interrupt summary
+** Underflow interrupt enable, Transmit interrupt enable 
+*/
+#define TX_INTR_VAL (TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL  | \
+                     TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL  | \
+                     TMHW_LIPP6100ETH_DMA_INT_UNE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL )
+
+/* Fatal Bus Error Interrupt, Over run error interrupt, Normal Interrupt Summary, 
+** Abnormal Interrupt Summary, Receive Interrupt Enable 
+*/
+#define RX_INTR_VAL (TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL | \
+                     TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL )
+
+/* Early Transmit and Early Receive Interrupts */
+#define ERE_ETE_INT_VAL ( TMHW_LIPP6100ETH_DMA_INT_ERE_EN_VAL | \
+                          TMHW_LIPP6100ETH_DMA_INT_ETE_EN_VAL )
+
+#define MAX_LIPP_6300ETH_UNITS (1)
+
+#define NULL 0
+
+/*----------------------------------------------------------------------------*/
+/**********************      Structures  definitions     **********************/
+/*----------------------------------------------------------------------------*/
+
+/* structure for TX descriptors */
+typedef struct TX_DESCR 
+{
+    volatile UInt32 TDES0;
+    volatile UInt32 TDES1;
+    volatile UInt32 TDES2;
+    volatile UInt32 TDES3;
+} TX_DESCR_t ;
+
+typedef struct RX_DESCR
+{
+    volatile UInt32 RDES0;
+    volatile UInt32 RDES1;
+    volatile UInt32 RDES2;
+    volatile UInt32 RDES3;
+} RX_DESCR_t ;
+
+
+typedef struct dma_descs
+{
+    TX_DESCR_t* pTx_desc;
+    RX_DESCR_t* pRx_desc;
+
+} dma_descs_t,*pdma_descs_t;
+
+/* Structure for storing the tx & rx transactions */
+typedef struct lipp_6300eth_priv 
+{
+
+    struct eth_addr *ethaddr;
+
+    /* Add whatever per-interface state that is needed here. */
+    TX_DESCR_t *p_tx_descr;  /* Transmit descriptor ring pointer */ 
+    RX_DESCR_t *p_rx_descr;  /* Receive descriptor ring pointer */   
+    UInt32 tx_produce_index; /* Counter to keep track of transmit descriptor index */
+    UInt32 rx_consume_index; /* Pointer to keep track of receive descriptor index */    
+    UInt32 u_speed; /* speed setting 10/100/1000 */
+    UInt32 u_mode; /* mode setting Full Duplex, Half Duplex */
+    UInt32 u_autoneg; /* auto negotiation enable/disable */
+    tmUnitSelect_t hwUnitNo; /* Hardware unit  < Combination of GMAC & PHY >*/
+    UInt32 bufferFlip[HW_DESCR_QUEUE_LEN_RX]; /* Used to swap buffers & avoid memcpy */
+    UInt32 dmaEnabled;
+
+} lipp_6300eth_priv_t,*plipp_6300eth_priv_t ;
+
+#endif /* _LIPP_6300ETH_H_ */
+
+
diff --git a/drivers/net/lipp_6300eth/lipp_6300eth_common.h b/drivers/net/lipp_6300eth/lipp_6300eth_common.h
new file mode 100644
index 0000000..cc7e9d3
--- /dev/null
+++ b/drivers/net/lipp_6300eth/lipp_6300eth_common.h
@@ -0,0 +1,55 @@
+#ifndef __LIPP_6300ETH_COMMON_H__
+#define __LIPP_6300ETH_COMMON_H__
+
+#include <config.h> /* PHY & ethernet driver related macros are defined here */
+
+#define MAC_BASE_ADDRESS ((PNX84XX_IO_BASE+0xB8000))
+
+#define ENABLE_CACHE 0
+
+/* Speed of the ethernet link */
+#define ETH_LINK_SPEED (LX_SPEED_100)
+
+/* Mode of the ethernet link */
+#define ETH_LINK_MODE (LX_MODE_FULL_DUPLEX)
+  
+/* Macro to enable/disable autonegotiation */
+#define ETH_AUTO_NEGOTIATION (LX_AUTONEG_DISABLE)
+
+#define GMAC_PRINT 1
+
+#if (GMAC_PRINT == 1)
+#define GMAC_DBG(args...)	printf("\nlipp6300eth: " args)
+#define GMAC_DBGOUT(fmt,args...) printf(fmt ,##args)
+#else
+#define GMAC_DBG(args...)
+#define GMAC_DBGOUT()
+#endif
+
+
+#define __LIPP_6300ETH__ /* Defined inside PHY code */
+
+/* Macros for PHY driver */
+#define mdelay(n)   udelay((n)*1000)
+
+#endif /* __LIPP_6300ETH_COMMON_H__ */
+
+
+/* Usage instructions
+
+;For choosing smsc 8700 ethernet phy, run the below config & compile
+
+make tv55x_smsc8700_config
+make 
+
+;For choosing National semiconductor PHY DP83848 PHY, run the below config 
+
+make tv55x_dp83848_config
+make 
+
+;For choosing smsc 8710 ethernet phy, run the below config & compile
+make tv55x_smsc8710_config
+make 
+
+*/
+
diff --git a/drivers/net/lipp_6300eth/tmFlags.h b/drivers/net/lipp_6300eth/tmFlags.h
new file mode 100644
index 0000000..2cb04af
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmFlags.h
@@ -0,0 +1,47 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmFlags.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+ #ifndef TMFLAGS_H                                    
+ #define TMFLAGS_H                                                   
+
+ #define TMFL_OS_IS_NULLOS             1
+ #define TMFL_ENDIAN                   0
+ #define TMFL_ENDIAN_BIG               1
+ #define TMFL_ENDIAN_LITTLE            0
+ #define TMFL_REL_TRACE                0x00000003
+ #define TMFL_REL_ASSERT               0x00000002
+ #define TMFL_REL_DEBUG                0x00000001
+ #define TMFL_REL_RETAIL               0x00000000
+
+#define TMFL_REL  TMFL_REL_RETAIL
+
+ #endif   /* TMFLAGS_H*/
diff --git a/drivers/net/lipp_6300eth/tmNxCompId.h b/drivers/net/lipp_6300eth/tmNxCompId.h
new file mode 100644
index 0000000..7144272
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmNxCompId.h
@@ -0,0 +1,70 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmNxCompId.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMNXCOMPID_H
+#define TMNXCOMPID_H
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*   Standard include files:                                                  */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define CID_IID_FLAG_BITSHIFT    31
+#define CID_ID_BITSHIFT          12
+
+#define TM_OK                     0U         /* Global success return status   */
+
+#define CID_ID(number)           ((number) << CID_ID_BITSHIFT)
+#define CID_FLAG                 (0x1U << CID_IID_FLAG_BITSHIFT)
+
+
+#define CID_BSL_PHY                 (CID_ID(0x80deU) | CID_FLAG)
+
+#define TM_ERR_INIT_FAILED              0x014U /* Initialization failed        */
+#define TM_ERR_BAD_UNIT_NUMBER          0x005U /* Invalid device unit number   */
+#define TM_ERR_NOT_SUPPORTED            0x013U /* Function is not supported    */
+#define TM_ERR_TIMEOUT                  0x01FU /* Timeout error                */
+#define TM_ERR_HW_RESET_FAILED          0x04BU /* Hardware reset failed        */
+#define TM_ERR_READ                     0x017U /* Read error                   */
+#define TM_ERR_WRITE                    0x018U /* Write error                  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TMNXCOMPID_H ----------------- */
diff --git a/drivers/net/lipp_6300eth/tmNxModId.h b/drivers/net/lipp_6300eth/tmNxModId.h
new file mode 100644
index 0000000..7aae646
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmNxModId.h
@@ -0,0 +1,48 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmNxModId.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMNXMODID_H
+#define TMNXMODID_H
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* TMNXMODID_H */ 
diff --git a/drivers/net/lipp_6300eth/tmNxTypes.h b/drivers/net/lipp_6300eth/tmNxTypes.h
new file mode 100644
index 0000000..1212182
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmNxTypes.h
@@ -0,0 +1,173 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmNxTypes.h %
+ * %pid_version:          %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMNXTYPES_H
+#define TMNXTYPES_H
+
+/*-----------------------------------------------------------------------------
+** Standard include files:
+**-----------------------------------------------------------------------------
+*/
+
+#include "tmFlags.h"          
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*-----------------------------------------------------------------------------
+** Types and defines:
+**-----------------------------------------------------------------------------
+*/
+
+#define TM_FALSE            0       /* replaces legacy False macro */
+#define TM_TRUE             1       /* replaces legacy True  macro */
+
+#define TM_ENDIAN_BIG       0       /* replaces legacy BigEndian    macro */
+#define TM_ENDIAN_LITTLE    1       /* replaces legacy LittleEndian macro */
+
+#ifndef False
+#define False         (TM_FALSE)  /* NOTE: Legacy - use TM_FALSE instead */
+#endif
+
+#ifndef True
+#define True          (TM_TRUE)   /* NOTE: Legacy - use TM_TRUE  instead */
+#endif
+
+#ifdef __cplusplus
+#define Null          0
+#else
+#define Null          ((Void *) 0)
+#endif
+
+#define HAL_DEVICE_NAME_LENGTH  16
+
+/*
+** Standard Types
+*/
+typedef void            Void;       /* Void (typeless) */
+typedef signed   char   Int8;       /*  8-bit   signed integer */
+typedef signed   short  Int16;      /* 16-bit   signed integer */
+typedef signed   long   Int32;      /* 32-bit   signed integer */
+typedef unsigned char   UInt8;      /*  8-bit unsigned integer */
+typedef unsigned short  UInt16;     /* 16-bit unsigned integer */
+typedef unsigned long   UInt32;     /* 32-bit unsigned integer */
+typedef float           Float;      /* 32-bit floating point */
+typedef unsigned int    Bool;       /* Boolean (True/False) */
+typedef char            Char;       /* character, character array ptr */
+typedef int             Int;        /* machine-natural integer */
+typedef unsigned int    UInt;       /* machine-natural unsigned integer */
+typedef char           *String;     /* Null-terminated 8-bit char str */
+
+
+typedef struct tmVersion
+{
+    UInt8   majorVersion;
+    UInt8   minorVersion;
+    UInt16  buildVersion;
+}   tmVersion_t, *ptmVersion_t;
+
+
+typedef signed   int    IBits32;    /* 32-bit   signed integer bitfields */
+typedef unsigned int    UBits32;    /* 32-bit unsigned integer bitfields */
+
+typedef Int8    *pInt8;             /*  8-bit   signed integer ptr */
+typedef Int16   *pInt16;            /* 16-bit   signed integer ptr */
+typedef Int32   *pInt32;            /* 32-bit   signed integer ptr */
+typedef IBits32 *pIBits32;          /* 32-bit   signed integer bitfield ptr */
+typedef UBits32 *pUBits32;          /* 32-bit unsigned integer bitfield ptr */
+typedef UInt8   *pUInt8;            /*  8-bit unsigned integer ptr */
+typedef UInt16  *pUInt16;           /* 16-bit unsigned integer ptr */
+typedef UInt32  *pUInt32;           /* 32-bit unsigned integer ptr */
+typedef Void    *pVoid;             /* Void (typeless) ptr */
+typedef Float   *pFloat;            /* 32-bit floating point, float ptr */
+typedef double  Double, *pDouble;   /* 32/64-bit floating point, double ptr */
+typedef Bool    *pBool;             /* Boolean (True/False) ptr */
+typedef Char    *pChar;             /* character, character array ptr */
+typedef Int     *pInt;              /* machine-natural integer ptr */
+typedef UInt    *pUInt;             /* machine-natural unsigned integer ptr */
+typedef String  *pString;           /* Null-terminated 8-bit char str ptr */
+
+
+
+typedef UInt32 tmErrorCode_t;
+
+
+/*-----------------------------------------------------------------------------
+** Hardware device power states
+*/
+typedef enum tmPowerState
+{
+    tmPowerOn,                          /* Device powered on      (D0 state) */
+    tmPowerStandby,                     /* Device power standby   (D1 state) */
+    tmPowerSuspend,                     /* Device power suspended (D2 state) */
+    tmPowerOff                          /* Device powered off     (D3 state) */
+}   tmPowerState_t, *ptmPowerState_t;
+
+/*-----------------------------------------------------------------------------
+** Software Version Structure
+*/
+typedef struct tmSWVersion
+{
+    UInt32      compatibilityNr;        /* Interface compatibility number */
+    UInt32      majorVersionNr;         /* Interface major version number */
+    UInt32      minorVersionNr;         /* Interface minor version number */
+
+}   tmSWVersion_t, *ptmSWVersion_t;
+
+typedef Int tmInstance_t, *ptmInstance_t;
+
+/*-----------------------------------------------------------------------------
+
+** HW Unit Selection
+*/
+
+typedef Int tmUnitSelect_t, *ptmUnitSelect_t;
+
+#define tmUnitNone (-1)
+#define tmUnit0    0
+#define tmUnit1    1
+#define tmUnit2    2
+#define tmUnit3    3
+#define tmUnit4    4
+#define tmUnit5    5
+#define tmUnit6    6
+#define tmUnit7    7
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* ifndef TMNXTYPES_H */
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhy.c b/drivers/net/lipp_6300eth/tmbslPhy.c
new file mode 100644
index 0000000..22fff3d
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhy.c
@@ -0,0 +1,54 @@
+#include "lipp_6300eth_common.h"
+
+/* config.h, included in lipp_6300eth_common.h has defines for 
+** CONFIG_LIPP_6300ETH & one of the PHY to be compiled
+** as CONFIG_USING_<phy type>_PHY. 
+**
+** PHY source files are included as part of this file, so as to 
+** keep the make file constant, even if a different PHY is used.
+*/
+
+/* pnx85500 on board ethernet */
+
+#ifdef CONFIG_LIPP_6300ETH
+
+    /* For national dp83848 phy */
+    #ifdef CONFIG_USING_DP83848_PHY
+    #include "tmbslPhyDP83848.h"
+    #include "tmbslPhyDP83848.c"
+    #endif
+
+    /* For smsc 8700 ethernet phy */
+    #ifdef CONFIG_USING_SMSC8700_PHY
+    #include "tmbslPhySMSC8700.h"        
+    #include "tmbslPhySMSC8700.c"    
+    #endif
+
+    /* For smsc 8700 ethernet phy */
+    #ifdef CONFIG_USING_SMSC8710_PHY
+    #include "tmbslPhySMSC8710.h"        
+    #include "tmbslPhySMSC8710.c"    
+    #endif
+
+    /* For smsc 8700 ethernet phy */
+    #ifdef CONFIG_USING_EMU_PHY
+    #include "tmbslPhyEmu.h"        
+    #include "tmbslPhyEmu.c"    
+    #endif
+
+    /* Files which are must for ethernet driver, utilizing 
+    ** macros in config.h, tv55x.h
+    */
+
+    #include "tmbslPhyAccess.c"
+    #include "tmhwLIPP6100Eth_Cfg.c"
+    #include "tmhwLIPP6100Eth.c"
+
+#endif /* CONFIG_LIPP_6300ETH */
+
+
+
+
+
+
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhy.h b/drivers/net/lipp_6300eth/tmbslPhy.h
new file mode 100644
index 0000000..9cdc237
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhy.h
@@ -0,0 +1,719 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:               tmbslPhy.h %
+ * %pid_version:                 1.2      %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+#ifndef  TMBSLPHY_H
+#define  TMBSLPHY_H
+//-----------------------------------------------------------------------------
+// Standard include files:
+//-----------------------------------------------------------------------------
+//
+#include "tmNxTypes.h"  // DVP standard types/defines/structs
+#include "tmNxCompId.h" // DVP system wide component IDs
+
+//-----------------------------------------------------------------------------
+// Project include files:
+//-----------------------------------------------------------------------------
+//
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//-----------------------------------------------------------------------------
+// Types and defines:
+//-----------------------------------------------------------------------------
+//
+
+
+#define TMBSL_PHY_COMPATIBILITY_NR       1
+#define TMBSL_PHY_MAJOR_VERSION_NR       1
+#define TMBSL_PHY_MINOR_VERSION_NR       0
+
+
+
+#define TMBSL_ERR_PHY_BASE          	CID_BSL_PHY
+#define TMBSL_ERR_PHY_COMP          	(CID_BSL_PHY | \
+                                        	 TM_ERR_COMP_UNIQUE_START)
+//PHY unit not supported                                         	 
+#define TMBSL_ERR_PHY_NOT_SUPPORTED 	(TMBSL_ERR_PHY_BASE+TM_ERR_NOT_SUPPORTED)
+// Invalid device unit number
+#define TMBSL_ERR_PHY_BAD_UNIT_NUM  	(TMBSL_ERR_PHY_BASE+TM_ERR_BAD_UNIT_NUMBER)
+// AutoNegotiation Time out occured
+#define TMBSL_ERR_PHY_AUTONEG_TIMEOUT   (TMBSL_ERR_PHY_BASE+TM_ERR_TIMEOUT)
+//PHY unit register read failed
+#define TMBSL_ERR_PHY_READ_FAILED       (TMBSL_ERR_PHY_BASE + TM_ERR_READ)
+//PHY unit register write failed
+#define TMBSL_ERR_PHY_WRITE_FAILED      (TMBSL_ERR_PHY_BASE + TM_ERR_WRITE)
+//PHY Initialisation failed
+#define TMBSL_ERR_PHY_INIT_FAILED       (TMBSL_ERR_PHY_BASE + TM_ERR_INIT_FAILED)
+//PHY unit reset failed
+#define TMBSL_ERR_PHY_RESET_FAILED      (TMBSL_ERR_PHY_BASE + TM_ERR_HW_RESET_FAILED)
+
+#if 0
+#define tmbslPhyRegisterComponent(unitNumber, pIntInterface)            \
+         tmbslCoreRegisterComponent(TMBSL_ERR_PHY_BASE,                  \
+                                    unitNumber,                          \
+                                    (ptmbslCompInterface_t) pIntInterface)
+
+
+#define tmbslPhyGetInterface(unitNumber, ppIntInterface)                \
+         tmbslCoreGetInterface(TMBSL_ERR_PHY_BASE,                       \
+                               unitNumber,                               \
+                               (tmbslCompInterface_t **) ppIntInterface)
+                               
+#endif
+
+// PHY DUPLEX MODE
+typedef enum	_tmbslPhyDuplexMode_t
+{
+	tmbslPhyHalfDuplex	=0,
+	tmbslPhyFullDuplex	=1
+} tmbslPhyDuplexMode_t, *ptmbslPhyDuplexMode_t;
+
+// PHY SPEED
+typedef enum	_tmbslPhySpeed_t
+{
+	tmbslPhySpeed10Mbps	=0,
+	tmbslPhySpeed100Mbps	=1,
+	tmbslPhySpeed1Gbps	= 2	
+} tmbslPhySpeed_t, *ptmbslPhySpeed_t;
+
+// ENABLE DISABLE MODE
+typedef enum	_tmbslPhyEnableDisable_t
+{
+	tmbslPhyDisable		=0,
+	tmbslPhyEnable		=1
+} tmbslPhyEnableDisable_t, *ptmbslPhyEnableDisable_t;
+
+// PHY BASIC MODE CONTROL
+typedef struct	_tmbslPhyBasicModeControl_t
+{
+	Bool					enableCollisionTest; 
+	tmbslPhyDuplexMode_t	duplexMode;
+	tmbslPhySpeed_t			speed;
+} tmbslPhyBasicModeControl_t, *ptmbslPhyBasicModeControl_t;
+
+// PHY BASIC MODE STATUS
+typedef struct	_tmbslPhyBasicModeStatus_t
+{
+	Bool					jabberDetect; // This applies only in 10Mbps : value 1 - jabber condition detected
+	Bool					remoteFaultDetected; 
+	Bool					autoNegotiationComplete;
+	Bool					receiverErrorLatch;
+	Bool					invertedPolarityDetected; // Detects link polarity
+	Bool					falseCarrierEverntOccured;
+	Bool					linkCodeWordPageReceived;
+	Bool					loopBackEnabled; //loopback status
+	tmbslPhyDuplexMode_t	duplexMode; // deplex mode status
+	tmbslPhySpeed_t			speed;
+	Bool					linkpartnerAcknolwedged ; // Link partner acknolwedged
+	Bool					parallelDetectFaultDetected ; // Parallel detect fault is deteced
+
+} tmbslPhyBasicModeStatus_t, *ptmbslPhyBasicModeStatus_t;
+
+// PHY PROTOCOL SELECTION
+typedef enum	_tmbslPhyProtocol_t
+{
+	tmbslPhyProtocolNone		= 0,
+	tmbslPhyIEEE8023			= 1
+} tmbslPhyProtocol_t, *ptmbslPhyProtocol_t;
+
+/* PHY auto negotiation mask 
+** When the below flags are true, that particular option is disabled/not advertised
+*/
+typedef struct	_tmbslPhyAutoNegotiationMask_t
+{
+    Bool				      masknextPageDesired;
+    Bool				      maskRemoteFault; // advertise remote fault detection
+    Bool					mask100BaseT4;  //advertise/mask 100BaseT4 capability 
+    Bool					mask100BaseTxFullDuplexSupport; 
+    Bool					mask100BaseTxSupport;
+    Bool					mask10BaseTFullDuplexSupport; //advertise/mask 10BaseTFullDuplex support
+    Bool					mask10BaseTSupport;
+    tmbslPhyProtocol_t		protocolSel;			//(0x0001 IEEE802.3 CSMA/Cd)
+    Bool                             maskAsymmetricPause;
+    Bool                             maskPauseFrame;    
+    /* 1G related enum  start */
+    Bool                            maskMSConfigEn;
+    Bool                            maskMasterEn;
+    Bool                            maskMultiPortEn;
+    Bool                            mask1000BaseTFullDuplexSupport;
+    Bool                            mask1000BaseTHalfDuplexSupport;    
+    /* 1G related ends*/
+} tmbslPhyAutoNegotiationMask_t, *ptmbslPhyAutoNegotitationMask_t;
+
+
+// PHY IDENTIFIER
+typedef struct	_tmbslPhyIdentifier_t
+{
+	UInt32		oui; //PHY Organizationally Unique Identifier
+	UInt32		vendorModelNr; 
+	UInt32		modelRevNr;
+	UInt32		siliconRevisionNr; 
+} tmbslPhyIdentifier_t, *ptmbslPhyIdentifier_t;
+
+
+// PHY CAPABILITIES
+typedef struct	_tmbslPhyCapabilities_t
+{
+    Bool			T4Support100Base;
+    Bool			Tx_FullDuplexSupport100Base;
+    Bool			Tx_HalfDuplexSupport100Base;
+    Bool			Tx_FullDuplexSupport10Base;
+    Bool			Tx_HalfDuplexSupport10Base;
+    Bool		 	preAmbleSuppresionCapability;
+    Bool		 	autoNegotiationAbility;
+    Bool		 	nextPageIndication;
+    Bool			force100MbpsTxOff; 
+    Bool			bypassSymbolAlignment; 
+    Bool			badSSDDetectionConfig; 
+    Bool		 	ledStatusSupport;	   
+
+    /* 1G related capabilities */
+    Bool		 	X1000BaseFDSupport;	       
+    Bool		 	X1000BaseHDSupport;	           
+    Bool		 	T1000BaseFDSupport;	       
+    Bool		 	T1000BaseHDSupport;	               
+
+} tmbslPhyCapabilities_t, *ptmbslPhyCapabilities_t;
+
+
+// PHY LINK PARTNER CAPABILITIES
+
+typedef struct	_tmbslPhyLinkPartnerCapabilities_t
+{
+
+	tmbslPhyProtocol_t			protocolSel;
+	Bool						TSupport10Base;
+	Bool						TFullDuplexSupport10Base;
+	Bool						TxSupport100Base;
+	Bool						TxFullDuplexSupport100Base;
+	Bool						T4Support100Base;
+	Bool						flowControl;
+	Bool						remoteFault;
+	Bool						acknoweledges;
+	Bool						nextPageIndication;
+	Bool						autoNegotiation;	
+} tmbslPhyLinkPartnerCapabilities_t, *ptmbslPhyLinkPartnerCapabilities_t;
+
+
+// PHY PCS(PHYSICAL SUBBAND CODING
+typedef struct	_tmbslPhyPcsConfig_t
+{
+    /* 1 - force good link condition
+         0 - normal operation  */
+    Bool forceGoodLink100Mbps; 
+    Bool force100MbpsTxOff;
+    Bool bypassSymbolAlignment;
+    /* 1 - Enable bad SSD detection */
+    tmbslPhyEnableDisable_t badSSDDetection; 
+} tmbslPhyPcsConfig_t, *ptmbslPhyPcsConfig_t;
+
+// PHY COUNTERS
+typedef struct 	_tmbslPhyCounters_t
+{
+	UInt32			disconnectCounter;		
+	UInt32			falseCarrierEventCounter;//Gives the number of false carrier events 
+	UInt32			rxErrorCounter;	//Gives the number of Receive error occured 		
+} tmbslPhyCounters_t, *ptmbslPhyCounters_t;
+
+
+// PSEUDO RANDOM SEQUENCES
+typedef enum	_tmbslPhyPseudoRandomSeq_t
+{
+	tmbslPhyPseudoRandomSequenc9bit	=0,
+	tmbslPhyPseudoRandomSequenc15bit	=1
+} tmbslPhyPseudoRandomSeq_t, *ptmbslPhyPseudoRandomSeq_t;
+
+
+// PHY BYPASS OPTIONS
+typedef struct	_tmbslPhyBypass_t
+{
+	Bool		bypass4B5BCodec; //Bypass 4B 5B Encoding / Decoding
+	Bool		bypassNrzi;      //Bypass NRZI Encoding / Decoding
+	Bool		bypassScrambler; 
+	Bool		bypassDescrambler;
+} tmbslPhyBypass_t, *ptmbslPhyBypass_t;  
+
+
+
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetSWVersion_t) (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetCapabilities_t) (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+    
+    
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyInit_t)(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+    
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyDeinit_t)(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhySetPowerState_t)(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetPowerState_t)(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t 
+(*tmbslPhyGetBasicModeControl_t) (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t 
+(*tmbslPhySetBasicModeControl_t) (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetBasicModeStatus_t) (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyAutoNegotiate_t) (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetIdentifier_t) (
+    tmUnitSelect_t               			phyUnitId,   
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetLinkPartnerCapabilities_t) (
+    tmUnitSelect_t                         phyUnitId,   
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetCounters_t) (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations. 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyPcsSetConfig_t) (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration 
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyPcsGetConfig_t) (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result 
+//				will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//              pBistState  --> result of BIST (Built in self test) Test 
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyBist_t) (		
+    tmUnitSelect_t  						phyUnitId,   
+    tmbslPhyPseudoRandomSeq_t    			phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyConfigBypass_t) (
+    tmUnitSelect_t                        	phyUnitId,   
+    ptmbslPhyBypass_t                     	pPhyBypass
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyLoopBack_t) (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhySoftReset_t) (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TMBSL_ERR_PHY_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+typedef tmErrorCode_t
+(*tmbslPhyGetLinkStatus_t) (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+);
+
+typedef struct _tmbslPhyConfig_t 
+{
+	char     phyName[HAL_DEVICE_NAME_LENGTH];
+	UInt32   lanClkSrc; // To select Clock source
+	UInt32   lanClkSpeed; // To select the speed
+	
+	tmbslPhyGetSWVersion_t            getSWVersionFunc; 
+	tmbslPhyGetCapabilities_t         getCapabilitiesFunc;
+	tmbslPhyInit_t                    initFunc;
+	tmbslPhyDeinit_t                  deinitFunc;  
+	tmbslPhySetPowerState_t           setPowerStateFunc;
+	tmbslPhyGetPowerState_t           getPowerStateFunc;
+	tmbslPhyGetBasicModeControl_t     getBasicModeControlFunc;
+	tmbslPhySetBasicModeControl_t     setBasicModeControlFunc;
+	tmbslPhyGetBasicModeStatus_t      getBasicModeStatusFunc;
+	tmbslPhyAutoNegotiate_t           autoNegotiateFunc;
+	tmbslPhyGetIdentifier_t           getIdentifier_tFunc;
+	tmbslPhyGetLinkPartnerCapabilities_t  getLinkPartnerCapabilitiesFunc;
+	tmbslPhyGetCounters_t                 getCountersFunc;
+	tmbslPhyPcsSetConfig_t                   pcsConfigFunc;
+	tmbslPhyPcsGetConfig_t                pcsGetConfigFunc;
+	tmbslPhyBist_t                        bistFunc;
+	tmbslPhyConfigBypass_t                configBypassFunc;
+	tmbslPhyLoopBack_t                    loopBackFunc;
+	tmbslPhySoftReset_t                   softResetFunc;
+	tmbslPhyGetLinkStatus_t               getLinkStatusFunc;
+
+} tmbslPhyConfig_t,*ptmbslPhyConfig_t;
+
+void tmbslPhyGetInterface(int unitno,tmbslPhyConfig_t**pPhyInterface);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus) 
+#endif //#ifndef  TMBSLPHYDP83847_H
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhyAccess.c b/drivers/net/lipp_6300eth/tmbslPhyAccess.c
new file mode 100644
index 0000000..a176c5a
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhyAccess.c
@@ -0,0 +1,218 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:             tmbslPhyAccess.c %
+ * %pid_version:             1.2                  %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  PHY interface file for Linux Ethernet driver
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        This is to be updated if there is change in PHY hardware
+ *               Appropriate APIs are to be repopulated in the array.
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+#include "tmbslPhy.h" /* tmbslPhyConfig_t declaration */
+#include "tmhwLIPP6100Eth_Cfg.h" /* For TMHWLIPP6100ETH_NUM_UNITS */
+
+/* lipp_6300eth_common.h has PHY macros definitions __USING_<phy name>_PHY__*/
+#include "lipp_6300eth_common.h" 
+
+#define LAN_CLK_SEL        0
+#define LAN_CLK_SPEED_SEL  0
+
+#ifdef __USING_SMSC8700_PHY__
+#include "tmbslPhySMSC8700.h" /* For function prototypes of PHY*/
+/* PHY interface structure to store PHY register access functions */    
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] = 
+{
+    {  "SMSC8700",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhySMSC8700GetSWVersion, 
+        tmbslPhySMSC8700GetCapabilities,
+        tmbslPhySMSC8700Init,
+        tmbslPhySMSC8700Deinit,  
+        tmbslPhySMSC8700SetPowerState,
+        tmbslPhySMSC8700GetPowerState,
+        tmbslPhySMSC8700GetBasicModeControl,
+        tmbslPhySMSC8700SetBasicModeControl,
+        tmbslPhySMSC8700GetBasicModeStatus,
+        tmbslPhySMSC8700AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhySMSC8700LoopBack,
+        tmbslPhySMSC8700SoftReset,
+        tmbslPhySMSC8700GetLinkStatus
+    }
+
+};
+
+#endif
+
+#ifdef __USING_SMSC8710_PHY__
+#include "tmbslPhySMSC8710.h" /* For function prototypes of PHY*/
+/* PHY interface structure to store PHY register access functions */    
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] = 
+{
+    {  "SMSC8710",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhySMSC8710GetSWVersion, 
+        tmbslPhySMSC8710GetCapabilities,
+        tmbslPhySMSC8710Init,
+        tmbslPhySMSC8710Deinit,  
+        tmbslPhySMSC8710SetPowerState,
+        tmbslPhySMSC8710GetPowerState,
+        tmbslPhySMSC8710GetBasicModeControl,
+        tmbslPhySMSC8710SetBasicModeControl,
+        tmbslPhySMSC8710GetBasicModeStatus,
+        tmbslPhySMSC8710AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhySMSC8710LoopBack,
+        tmbslPhySMSC8710SoftReset,
+        tmbslPhySMSC8710GetLinkStatus
+    }
+
+};
+
+#endif
+
+#ifdef  __USING_DP83848_PHY__
+#include "tmbslPhyDP83848.h"
+/* PHY interface structure to store PHY register access functions */    
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] = 
+{
+    {  "DP83848",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyDP83848GetSWVersion, 
+        tmbslPhyDP83848GetCapabilities,
+        tmbslPhyDP83848Init,
+        tmbslPhyDP83848Deinit,  
+        tmbslPhyDP83848SetPowerState,
+        tmbslPhyDP83848GetPowerState,
+        tmbslPhyDP83848GetBasicModeControl,
+        tmbslPhyDP83848SetBasicModeControl,
+        tmbslPhyDP83848GetBasicModeStatus,
+        tmbslPhyDP83848AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyDP83848LoopBack,
+        tmbslPhyDP83848SoftReset,
+        tmbslPhyDP83848GetLinkStatus
+    }
+
+};
+
+#endif
+
+#ifdef __USING_DP83865_PHY__
+#include "tmbslPhyDP83865.h"
+/* PHY interface structure to store PHY register access functions */    
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] = 
+{
+    {  "DP83865",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyDP83865GetSWVersion, 
+        tmbslPhyDP83865GetCapabilities,
+        tmbslPhyDP83865Init,
+        tmbslPhyDP83865Deinit,  
+        tmbslPhyDP83865SetPowerState,
+        tmbslPhyDP83865GetPowerState,
+        tmbslPhyDP83865GetBasicModeControl,
+        tmbslPhyDP83865SetBasicModeControl,
+        tmbslPhyDP83865GetBasicModeStatus,
+        tmbslPhyDP83865AutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyDP83865LoopBack,
+        tmbslPhyDP83865SoftReset,
+        tmbslPhyDP83865GetLinkStatus
+    }
+
+};
+#endif
+
+#ifdef __USING_EMU_PHY__
+#include "tmbslPhyEmu.h"
+/* PHY interface structure to store PHY register access functions */    
+ tmbslPhyConfig_t gtmbslPhyInterface[TMHWLIPP6100ETH_NUM_UNITS] = 
+{
+    {  "EMULATOR",
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyEmuGetSWVersion, 
+        tmbslPhyEmuGetCapabilities,
+        tmbslPhyEmuInit,
+        tmbslPhyEmuDeinit,  
+        tmbslPhyEmuSetPowerState,
+        tmbslPhyEmuGetPowerState,
+        tmbslPhyEmuGetBasicModeControl,
+        tmbslPhyEmuSetBasicModeControl,
+        tmbslPhyEmuGetBasicModeStatus,
+        tmbslPhyEmuAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyEmuLoopBack,
+        tmbslPhyEmuSoftReset,
+        tmbslPhyEmuGetLinkStatus
+    }
+
+};
+
+#endif
+
+
+void tmbslPhyGetInterface(int unitnumber, tmbslPhyConfig_t ** pPhyInterface)
+{
+     *(pPhyInterface) = &gtmbslPhyInterface[unitnumber];
+}
+
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhyDP83848.c b/drivers/net/lipp_6300eth/tmbslPhyDP83848.c
new file mode 100644
index 0000000..d28d57c
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhyDP83848.c
@@ -0,0 +1,1095 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyDP83848.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: API source file for DP83848 National Semiconductors PHY
+ *
+ * DOCUMENT REF: Datasheet DP83848 Gig PHYTER V10/100/1000 Ethernet 
+ *               Physical Layer, October 2004
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+
+#include "lipp_6300eth_common.h"
+
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyDP83848.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include "i2c_ip3203.h"
+#define AUTO_NEG_DELAY_MULTIPLIER (4000)
+#endif /* __LINUX_GMAC_DRV__*/
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF)
+
+#define TMBSLPHYDP83848_PHY_MMIO_ADDRESS0 (0x1be00000+0x38000) 
+
+#define ANAR_DEFAULT_VAL (0xDE1)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+tmbslPhyDP83848Context_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYDP83848_PHY_MMIO_ADDRESS0}}; 
+
+typedef	enum	_tmbslPhyDP83848Reg_t
+{
+    /* Basic mode control */
+    tmbslPhyDP83848Bmcr		      = 0x0,  
+    /* Basic mode status */    
+    tmbslPhyDP83848Bmsr		      =0x1,  
+
+    /* PHY ID1 register */        
+    tmbslPhyDP83848PhyIdr1		=0x2,
+
+    /* PHY ID2 register */            
+    tmbslPhyDP83848PhyIdr2		=0x3,
+
+    /* Auto negotiation advertisement register */                
+    tmbslPhyDP83848Anar			=0x4,
+
+    /* Auto negotiation link partner ability register */                    
+    tmbslPhyDP83848Anlpar		=0x5,
+
+    /* Auto negotiation expansion register */                        
+    tmbslPhyDP83848Aner			=0x6,
+
+    /* Auto negotiation next page transmit register */                            
+    tmbslPhyDP83848AnnPtr		=0x7,
+
+    /* 0x8 to 0xF reserved-*/
+    tmbslPhyDP83848Phystsr = 0x10,        
+
+    /* 0x11 to 0x13 reserved */
+  
+   /* False carrier sense counter register */                                    
+    tmbslPhyDP83848Fcscr  = 0x14,
+
+   /* Receive Error Counter Register  */                                        
+    tmbslPhyDP83848Recr = 0x15,
+
+   /* PCS Sub-Layer Configuration and Status Register */                                            
+    tmbslPhyDP83848Pcsr = 0x16,
+
+   /* RMII and Bypass Register */                                        
+    tmbslPhyDP83848Rmiir = 0x17,    
+
+    /* LED Direct Control Register  */    
+    tmbslPhyDP83848Ledcr	= 0x18,
+    
+    /* BIST Configuration register1 */        
+    tmbslPhyDP83848Phycr = 0x19,    
+
+    /* 10Base-T Status/Control Register */            
+    tmbslPhyDP8384810Btscr = 0x1A,        
+
+    tmbslPhyDP83848Cdctrl1 = 0x1B,
+
+    /* 0x1C reserved */
+    
+    /* Energy detect control register */ 
+    tmbslPhyDP83848Edcr = 0x1D,
+
+    /* 0x1E to 0x1F reserved*/
+
+} tmbslPhyDP83848Reg_t, *ptmbslPhyDP83848Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t 
+tmbslPhyDP83848Read (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t				reg,   
+    pUInt16						pVal
+	);
+	
+	
+static tmErrorCode_t	
+tmbslPhyDP83848Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t				reg,   
+    UInt16						val
+	);
+
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void);
+#endif
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+	
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+	
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY. 
+//				 
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83848GetCapabilities (
+    tmUnitSelect_t                			ethUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    )
+
+{
+
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmsr, &bmsr);
+
+
+    pPhyCaps->T4Support100Base = 
+        (((bmsr & TMBSL_PHYDP83848_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYDP83848_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYDP83848_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYDP83848_BMSR_10MBPSFD) > 0) ? True : False);        
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYDP83848_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability = 
+        (((bmsr &TMBSL_PHYDP83848_BMSR_PREAMBLE_SUP) > 0) ? True : False);        
+
+    pPhyCaps->autoNegotiationAbility = 
+                (((bmsr &TMBSL_PHYDP83848_BMSR_AN_ABLE) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;		
+
+    /* Other capabilites set to False */   
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+	
+    return TM_OK;
+
+}   
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.No Autonegotiation is done in the 
+//				initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83848Init(
+    tmUnitSelect_t  						ethUnitId   
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;     		
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+    UInt16 id1, id2;
+
+//    mdelay(10);
+
+    #ifdef __LIPP_6300ETH__
+    get_phy_out_of_rst();
+    #endif
+
+    gEthContext[ethUnitId].pRegs = MAC_BASE_ADDRESS;
+
+    GMAC_DBG("Base addr:%x",gEthContext[ethUnitId].pRegs);
+
+    regval = TMBSL_PHYDP83848_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,regval);
+
+    GMAC_DBG("After write in PHY");
+    
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regval);
+    
+    while( (regval & TMBSL_PHYDP83848_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regval);
+
+        if(ethStatus != TM_OK) 
+        {
+            break;
+        }
+
+        timeout++;
+    }  
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYDP83848_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);	
+    } 
+    
+#if 0
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848PhyIdr1,&id1);
+    
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+    
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+  /*  if( ( id1 == 0x2000 ) && (id2 == 0x5C7A) )
+    {
+        // IDs are valid. Do Nothing 
+    }
+    else
+    {
+        return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+    }
+*/
+#endif
+
+    regval =0;
+
+    /* Set the PHY for the 10Mbps and Half Duplex mode */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848Deinit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYDP83848_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else	
+    {
+        return TM_OK;
+    }
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848SetPowerState(
+    tmUnitSelect_t           				ethUnitId ,  
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYDP83848_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYDP83848_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,  
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYDP83848_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhyDP83848GetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,   
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = 
+                (((bmcr & TMBSL_PHYDP83848_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode = 
+                (((bmcr & TMBSL_PHYDP83848_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    if(bmcr & TMBSL_PHYDP83848_BMCR_SPEED_MSK)
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;            
+    }
+    else
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;                            
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhyDP83848SetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,   
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYDP83848_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYDP83848_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed100Mbps :       
+            bmcr |= TMBSL_PHYDP83848_BMCR_SPEED_100;                
+            break;
+
+        case tmbslPhySpeed10Mbps :       
+            bmcr |= TMBSL_PHYDP83848_BMCR_SPEED_10;                
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,   
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus     
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16           bmsr,bmcr,phySts;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from PHY status register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId, tmbslPhyDP83848Phystsr, &phySts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYDP83848_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYDP83848_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYDP83848_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYDP83848_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYDP83848_BMCR_AN_EN) == 0) 
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode = 
+                (((bmcr & TMBSL_PHYDP83848_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        if(bmcr & TMBSL_PHYDP83848_BMCR_SPEED_MSK)
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;            
+        }
+        else
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;                        
+        }
+
+    }
+    else 
+    {	
+        /* If autonegotiation is enabled, read from PHYSTS register */
+        pPhyBasicModeStatus->duplexMode = 
+                (((phySts & TMBSL_PHYDP83848_PHYSTS_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        pPhyBasicModeStatus->speed= 
+                (((phySts & TMBSL_PHYDP83848_PHYSTS_SPEED_10) > 0) ? tmbslPhySpeed10Mbps : tmbslPhySpeed100Mbps);
+
+
+
+    }
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+	
+tmErrorCode_t
+tmbslPhyDP83848AutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=AUTO_NEG_DELAY_MULTIPLIER; /* Timeout of 800*5 msecs = 4 Sec */
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_NP;        
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_ADV_RF;        
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_AP;        
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_PAUSE;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_100B_TX_FD;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_100B_TX_HD;        
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_10B_TX_FD;        
+    }    
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYDP83848_ANAR_10B_TX_HD;        
+    }    
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Anar,regVal);
+
+    /* Enable the Auto negotiation in the BMCR register 
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYDP83848_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYDP83848_BMCR_AN_EN;
+    
+    tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,regVal);
+	
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYDP83848_BMSR_AN_VAL) != TMBSL_PHYDP83848_BMSR_AN_VAL) && 
+           (timeout != 0 ) )
+    {
+        mdelay(5);
+        
+        ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmsr,&regVal);
+
+        if(ethStatus != TM_OK) 
+        {
+            return ethStatus;
+        }
+
+        timeout--;
+    }
+
+    if(  (timeout <= 0) && 
+         ( (regVal & TMBSL_PHYDP83848_BMSR_AN_VAL) != TMBSL_PHYDP83848_BMSR_AN_VAL)
+      )
+    {
+        return(-1);
+    }
+
+    GMAC_DBG("Autonegotiation Time:%d msec\n",(AUTO_NEG_DELAY_MULTIPLIER-timeout)*5);
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback 
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyDP83848LoopBack (
+    tmUnitSelect_t                  ethUnitId,   
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYDP83848_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYDP83848_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848SoftReset (
+    tmUnitSelect_t                     		ethUnitId      
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyDP83848Write(ethUnitId,tmbslPhyDP83848Bmcr,TMBSL_PHYDP83848_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,   
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 physts;
+
+    /* Read the ANSR register */
+    ethStatus = tmbslPhyDP83848Read(ethUnitId,tmbslPhyDP83848Phystsr,&physts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus = 
+    (((physts & TMBSL_PHYDP83848_PHYSTS_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}   
+
+//-----------------------------------------------------------------------------
+//	Local static functions	
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyDP83848Read (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t		reg,   
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;        
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;        
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && 
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }  
+	
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+    
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyDP83848Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyDP83848Reg_t		reg,   
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL | 
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;        
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+             (timeout < PHY_TIMEOUT) );
+	
+	if( (timeout == PHY_TIMEOUT) && 
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}  
+
+	return TM_OK;
+    
+}   
+
+//-----------------------------------------------------------------------------
+
+
+
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void)
+{
+    //Msg for High, to bring PHY out of reset
+    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x01}; 
+
+    //Msg for Low, to put PHY in reset     
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x00}; 
+
+//    pnx8xxx_ip3203_init();
+//    pnx8xxx_ip3203_write(msg, sizeof(msg));
+
+    /*Wait till the PHY is out of reset */    
+    mdelay(1);
+
+    /* Turn the clocks to MAC from PHY */
+
+#if 0
+    /* PHY clocks */
+    writel(0x00000003, (unsigned long *)(0xbbe47710));	
+    writel(0x00000003, (unsigned long *)(0xbbe47714));	
+    writel(0x00000003, (unsigned long *)(0xbbe47718));	
+#endif 
+
+    #ifdef __LIPP_6300ETH__
+    /* PHY clocks */
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    #endif
+
+
+    mdelay(1);
+//    GMAC_DBG("\nETHERNET CLOCK1:%08x\n",*(unsigned int *)(0x1be47710));                    
+//    GMAC_DBG("\nETHERNET CLOCK2:%08x\n",*(unsigned int *)(0x1be47714));                    
+//    GMAC_DBG("\nETHERNET CLOCK3:%08x\n",*(unsigned int*)(0x1be47718));                       
+//    GMAC_DBG("\nSMSC PHY INIT successful\n\n\n");    
+
+    return;
+
+}
+
+#endif 
+
+
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhyDP83848.h b/drivers/net/lipp_6300eth/tmbslPhyDP83848.h
new file mode 100644
index 0000000..2715cb9
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhyDP83848.h
@@ -0,0 +1,503 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyDP83848.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for DP83848 PHY
+ *
+ * DOCUMENT REF: Datasheet DP83848 Gig PHYTER V10/100/1000 Ethernet 
+ *               Physical Layer, October 2004
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _TMBSLPHYDP83848_H_
+#define _TMBSLPHYDP83848_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYDP83848_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYDP83848_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYDP83848_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYDP83848_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYDP83848_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYDP83848_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYDP83848_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYDP83848_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYDP83848_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYDP83848_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYDP83848_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYDP83848_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYDP83848_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYDP83848_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYDP83848_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYDP83848_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYDP83848_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYDP83848_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYDP83848_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYDP83848_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYDP83848_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYDP83848_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYDP83848_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYDP83848_BMSR_AN_VAL (0x20)
+#define TMBSL_PHYDP83848_BMCR_LPBK_VAL (0x4000)
+
+
+/* Remote fault value */
+#define TMBSL_PHYDP83848_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYDP83848_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYDP83848_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYDP83848_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYDP83848_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYDP83848_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYDP83848_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYDP83848_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYDP83848_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYDP83848_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYDP83848_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYDP83848_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYDP83848_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYDP83848_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYDP83848_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYDP83848_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYDP83848_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYDP83848_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYDP83848_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYDP83848_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYDP83848_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYDP83848_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYDP83848_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYDP83848_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYDP83848_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYDP83848_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYDP83848_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYDP83848_STRAP_ANE (0x8000)
+#define TMBSL_PHYDP83848_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYDP83848_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYDP83848_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYDP83848_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYDP83848_STRAP_SPD_10 (0x0)
+
+#define TMBSL_PHYDP83848_PHYSTS_SPEED_10 (0x2)
+#define TMBSL_PHYDP83848_PHYSTS_LINK_STAT (0x1)
+#define TMBSL_PHYDP83848_PHYSTS_DUP_MODE (0x4)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhyDP83848Context_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhyDP83848Context_t, *ptmbslPhyDP83848Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyDP83848GetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhyDP83848Init(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyDP83848Deinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848SetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhyDP83848GetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhyDP83848SetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848AutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDP83848LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848LoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848SoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyDP83848GetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif //_TMBSLPHYDP83848_H_
diff --git a/drivers/net/lipp_6300eth/tmbslPhyEmu.c b/drivers/net/lipp_6300eth/tmbslPhyEmu.c
new file mode 100644
index 0000000..19a1e8e
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhyEmu.c
@@ -0,0 +1,1271 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEmu.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: API source file for DP83865 National Semiconductors PHY
+ *
+ * DOCUMENT REF: iSolve Ethernet user's guide Version 1.0, Release 1
+ *               February 2008, Document Revision 5
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+
+#include "lipp_6300eth_common.h"
+
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyEmu.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF)
+
+#define TMBSLPHYEMU_PHY_MMIO_ADDRESS0 (0xC0000000)
+
+#define ANAR_DEFAULT_VAL (0xADE1)
+#define KTCR1_DEFAULT_VAL (0x300)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+
+tmbslPhyEmuContext_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYEMU_PHY_MMIO_ADDRESS0}};
+
+typedef	enum	_tmbslPhyEmuReg_t
+{
+    /* Basic mode control */
+    tmbslPhyEmuBmcr		      = 0x0,
+    /* Basic mode status */
+    tmbslPhyEmuBmsr		      =0x1,
+
+    /* PHY ID1 register */
+    tmbslPhyEmuPhyIdr1		=0x2,
+
+    /* PHY ID2 register */
+    tmbslPhyEmuPhyIdr2		=0x3,
+
+    /* Auto negotiation advertisement register */
+    tmbslPhyEmuAnar			=0x4,
+
+    /* Auto negotiation link partner ability register */
+    tmbslPhyEmuAnlpar		=0x5,
+
+    /* Auto negotiation expansion register */
+    tmbslPhyEmuAner			=0x6,
+
+    /* Auto negotiation next page transmit register */
+    tmbslPhyEmuAnnPtr		=0x7,
+
+    /* Auto negotiation Link Partner received Next Page */
+    tmbslPhyEmuAnnprr=0x8,
+
+    /* Auto negotiation 1000 Base-T Master-Slave Control register*/
+    tmbslPhyEmu1ktcr =0x9,
+
+    /* Auto negotiation 1000 Base-T Master-Slave status register*/
+    tmbslPhyEmu1kstsr  = 0xA,
+
+    /* 0xB-1E are reserved */
+
+    /*Extended status register */
+    tmbslPhyEmu1kscr = 0xF,
+
+    /**** Vendor Specific Registers *****/
+    /*Strap */
+    tmbslPhyEmuSor 	= 0x10,
+
+   /* Link and Autonegotiation Register */
+    tmbslPhyEmuLanr 	= 0x11,
+
+   /* Auxiliary Control Register */
+    tmbslPhyEmuAcr 	= 0x12,
+
+   /* Led Control register */
+    tmbslPhyEmuLedcr = 0x13,
+
+   /* Interrupt status register */
+    tmbslPhyEmuIsr  = 0x14,
+
+   /* Interrupt mask register */
+    tmbslPhyEmuImr = 0x15,
+
+   /* Expanded memory access control */
+    tmbslPhyEmuEmcr = 0x16,
+
+   /* Interrupt clear register */
+    tmbslPhyEmuIcr = 0x17,
+
+    /* BIST Counter register */
+    tmbslPhyEmuBcr	= 0x18,
+
+    /* BIST Configuration register1 */
+    tmbslPhyEmuBcfgr1 = 0x19,
+
+    /* BIST Configuration register2 */
+    tmbslPhyEmuBcfgr2 = 0x1A,
+
+    /* 0x1B to 0x1C are reserved */
+     /* Expanded memory data */
+    tmbslPhyEmuEmdr = 0x1D,
+
+    /* Expanded memory address register */
+    tmbslPhyEmuEmar = 0x1E,
+
+    /* Expanded memory address  register */
+    tmbslPhyEmuPsupr = 0x1F
+
+} tmbslPhyEmuReg_t, *ptmbslPhyEmuReg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t
+tmbslPhyEmuRead (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t				reg,
+    pUInt16						pVal
+	);
+
+
+static tmErrorCode_t
+tmbslPhyEmuWrite (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t				reg,
+    UInt16						val
+	);
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's
+//				capabilities (PHY unit initialization is not necessary).
+//				Capabilities may be different among multiple PHY units.For completeness,
+//				a PHY BSL user should call this function for each PHY unit to
+//				determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEmuGetCapabilities (
+    tmUnitSelect_t                			ethUnitId,
+    ptmbslPhyCapabilities_t  				pPhyCaps
+    )
+
+{
+
+    UInt16 bmsr,extStat;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmsr, &bmsr);
+
+
+    /*  Read the extended status register */
+    tmbslPhyEmuRead(ethUnitId, tmbslPhyEmu1kstsr, &extStat);
+
+
+    pPhyCaps->T4Support100Base =
+        (((bmsr & TMBSL_PHYEMU_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYEMU_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base =
+        (((bmsr &TMBSL_PHYEMU_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYEMU_BMSR_10MBPSFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base =
+        (((bmsr &TMBSL_PHYEMU_BMSR_10MBPSHD) > 0) ? True : False);
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYEMU_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility =
+                (((bmsr &TMBSL_PHYEMU_BMSR_AN_ABLE) > 0) ? True : False);
+
+
+    pPhyCaps->X1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASEX_FD) > 0) ? True : False);
+
+    pPhyCaps->X1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASEX_HD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASET_FD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEMU_1KSCR_1000BASET_HD) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//				default initial configuration.No Autonegotiation is done in the
+//				initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEmuInit(
+    tmUnitSelect_t  						ethUnitId
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+
+
+
+    gEthContext[ethUnitId].pRegs = MAC_BASE_ADDRESS;
+
+    GMAC_DBG("Base addr:%x",gEthContext[ethUnitId].pRegs);
+
+#if 0
+    regval = TMBSL_PHYEMU_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    GMAC_DBG("Reset write is OK\n");
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regval);
+
+    while( (regval & TMBSL_PHYEMU_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regval);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+    }
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYEMU_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);
+    }
+
+    GMAC_DBG("Reset read is OK\n");
+
+
+    regval =0;
+
+    /* Set the PHY for the 10Mbps and Half Duplex mode */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+#endif
+
+    GMAC_DBG("PHY init complete\n");
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuDeinit(
+    tmUnitSelect_t  						ethUnitId
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYEMU_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuSetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuSetPowerState(
+    tmUnitSelect_t           				ethUnitId ,
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYEMU_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYEMU_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYEMU_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest =
+                (((bmcr & TMBSL_PHYEMU_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYEMU_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYEMU_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEMU_BMCR_SPEED_1G:
+            pPhyBasicModeControl->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEMU_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYEMU_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            break;
+    }
+
+    return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuSetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuSetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;
+    UInt16 bmcr =0;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYEMU_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYEMU_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed1Gbps :
+            bmcr |= TMBSL_PHYEMU_BMCR_SPEED_1G;
+            break;
+
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYEMU_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYEMU_BMCR_SPEED_10;
+            break;
+
+        default:
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+    return ethStatus;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16           bmsr,bmcr,linkan=0;
+    UInt16 speedVal;
+
+    GMAC_DBG("Get Basic Mode Status:Start\n");
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuBmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+#ifndef __NULL_PHY__
+    /* Read the autonegotiation status from Link and Autonegotiation register*/
+    ethStatus = tmbslPhyEmuRead(ethUnitId, tmbslPhyEmuLanr, &linkan);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+#endif
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYEMU_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYEMU_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYEMU_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYEMU_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYEMU_BMCR_AN_EN) == 0)
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode =
+                (((bmcr & TMBSL_PHYEMU_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        switch(bmcr & TMBSL_PHYEMU_BMCR_SPEED_MSK)
+        {
+            case TMBSL_PHYEMU_BMCR_SPEED_1G:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+
+            case TMBSL_PHYEMU_BMCR_SPEED_100:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+                break;
+
+            case TMBSL_PHYEMU_BMCR_SPEED_10:
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+                break;
+
+            default:
+                break;
+        }
+
+    }
+    else
+    {
+        /* If autonegotiation is enabled, read from LINK_AN register */
+        pPhyBasicModeStatus->duplexMode =
+                (((linkan & TMBSL_PHYEMU_LINKAN_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        speedVal = TMBSL_PHYEMU_LINKAN_SPEED_MSK & linkan;
+
+        switch(speedVal)
+        {
+            case TMBSL_PHYEMU_LINKAN_SPEED_1000 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+                break;
+            case TMBSL_PHYEMU_LINKAN_SPEED_100 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+                break;
+            case TMBSL_PHYEMU_LINKAN_SPEED_10 :
+                pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps ;
+                break;
+            default:
+                break;
+        }
+
+    }
+
+    GMAC_DBG("Get Basic Mode Status:End\n");
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//				with Link Partner. Best possible performance configuration is
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuAutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=0;
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    GMAC_DBG("Autonegotiate:Start\n");
+
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuAnar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_NP;
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_ADV_RF;
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_AP;
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_PAUSE;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_100B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_100B_TX_HD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_10B_TX_FD;
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_ANAR_10B_TX_HD;
+    }
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the Auto negotiation mask */
+    tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuAnar,regVal);
+
+    /* For 1G configuration */
+    regVal = KTCR1_DEFAULT_VAL;
+
+    mask =0;
+
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmu1ktcr,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->maskMSConfigEn == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_MS_CONFIG;
+    }
+
+    if(pAutoNegotiationMask->maskMasterEn == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_MASTER_EN;
+    }
+
+    if(pAutoNegotiationMask->maskMultiPortEn == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_MULTIPORT_EN;
+    }
+
+    if(pAutoNegotiationMask->mask1000BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_1000BT_FD;
+    }
+
+    if(pAutoNegotiationMask->mask1000BaseTHalfDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYEMU_1KTCR_1000BT_HD;
+    }
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+    /* Program the master/Slave config register 1KTCR */
+    tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmu1ktcr,regVal);
+
+    /* 1G config ends */
+
+    /* Enable the Auto negotiation in the BMCR register
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYEMU_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYEMU_BMCR_AN_EN;
+
+    tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,regVal);
+
+    /* Wait till the Auto negotiation is complete Or Do we need to set the Timeout */
+    tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYEMU_BMSR_AN_VAL) != TMBSL_PHYEMU_BMSR_AN_VAL) &&
+            (timeout < PHY_TIMEOUT) )
+    {
+        ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmsr,&regVal);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+    }
+
+    if(timeout >= PHY_TIMEOUT )
+    {
+        ethStatus = !TM_OK;
+    }
+
+    GMAC_DBG("Autonegotiate:End\n");
+
+    return ethStatus;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEmuLoopBack (
+    tmUnitSelect_t                  ethUnitId,
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYEMU_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYEMU_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,bmcr);
+
+    return ethStatus;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuSoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuSoftReset (
+    tmUnitSelect_t                     		ethUnitId
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhyEmuWrite(ethUnitId,tmbslPhyEmuBmcr,TMBSL_PHYEMU_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;
+    UInt16 ansr;
+
+    /* Read the ANSR register */
+    ethStatus = tmbslPhyEmuRead(ethUnitId,tmbslPhyEmuLanr,&ansr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+    (((ansr & TMBSL_PHYEMU_LINKAN_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}
+
+//-----------------------------------------------------------------------------
+//	Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuRead:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyEmuRead (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t		reg,
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+
+    return TM_OK;
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuWrite:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhyEmuWrite (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhyEmuReg_t		reg,
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+             (timeout < PHY_TIMEOUT) );
+
+	if( (timeout == PHY_TIMEOUT) &&
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}
+
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetIdentifier(
+    tmUnitSelect_t               			phyUnitId,
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEmuGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         ethUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the Phy counters
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyGetCounters(
+    tmUnitSelect_t                  		phyUnitId,
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will set the pcs configuration
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsSetConfig(
+    tmUnitSelect_t phyUnitId,
+    ptmbslPhyPcsConfig_t pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyPcsGetConfig (
+    tmUnitSelect_t                 			phyUnitId,
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+ tmErrorCode_t
+tmbslPhyBist(
+    tmUnitSelect_t                        phyUnitId,
+    tmbslPhyPseudoRandomSeq_t    phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyConfigBypass(
+    tmUnitSelect_t                        	phyUnitId,
+    ptmbslPhyBypass_t                     	pPhyBypass
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhyEmu.h b/drivers/net/lipp_6300eth/tmbslPhyEmu.h
new file mode 100644
index 0000000..74fc9e5
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhyEmu.h
@@ -0,0 +1,636 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEmu.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for DP83865 PHY
+ *
+ * DOCUMENT REF: Datasheet DP83865 Gig PHYTER V10/100/1000 Ethernet 
+ *               Physical Layer, October 2004
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _TMBSLPHYEMU_H_
+#define _TMBSLPHYEMU_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYEMU_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYEMU_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYEMU_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYEMU_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYEMU_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYEMU_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYEMU_BMCR_SPEED_MSK (0x2040)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYEMU_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYEMU_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYEMU_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYEMU_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYEMU_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYEMU_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYEMU_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYEMU_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYEMU_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYEMU_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYEMU_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYEMU_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYEMU_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYEMU_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYEMU_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYEMU_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYEMU_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYEMU_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYEMU_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYEMU_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYEMU_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYEMU_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYEMU_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYEMU_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYEMU_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYEMU_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYEMU_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYEMU_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYEMU_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYEMU_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYEMU_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYEMU_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYEMU_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYEMU_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYEMU_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYEMU_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYEMU_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYEMU_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYEMU_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYEMU_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYEMU_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYEMU_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYEMU_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYEMU_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYEMU_STRAP_ANE (0x8000)
+#define TMBSL_PHYEMU_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYEMU_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYEMU_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYEMU_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYEMU_STRAP_SPD_10 (0x0)
+
+/* Link and Autonegotiation Register. Read only */
+#define TMBSL_PHYEMU_LINKAN_SPEED_MSK (0x18)
+#define TMBSL_PHYEMU_LINKAN_SPEED_10 (0x0)
+#define TMBSL_PHYEMU_LINKAN_SPEED_100 (0x8)
+#define TMBSL_PHYEMU_LINKAN_SPEED_1000 (0x10)
+#define TMBSL_PHYEMU_LINKAN_LINK_STAT (0x4)
+#define TMBSL_PHYEMU_LINKAN_DUP_MODE (0x2)
+#define TMBSL_PHYEMU_LINKAN_PHY_MASTER (0x1)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  tmbslPhyEmuContext
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhyEmuContext_t, *ptmbslPhyEmuContext_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEmuGetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhyEmuInit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyEmuDeinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuSetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhyEmuGetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhyEmuSetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuAutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetIdentifier (
+    tmUnitSelect_t               			phyUnitId,   
+    ptmbslPhyIdentifier_t     				pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,   
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetCounters (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyCounters_t      		 		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuPcsConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuPcsGetConfig (
+    tmUnitSelect_t                 			phyUnitId,   
+    ptmbslPhyPcsConfig_t    				pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result 
+//				will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuBist (		
+    tmUnitSelect_t  						phyUnitId,   
+    tmbslPhyPseudoRandomSeq_t    			phyPsedoRandomSeq ,
+    pUInt8                              	pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuConfigBypass (
+    tmUnitSelect_t                        	phyUnitId,   
+    ptmbslPhyBypass_t                     	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuLoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuSoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEmuGetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff --git a/drivers/net/lipp_6300eth/tmbslPhySMSC8700.c b/drivers/net/lipp_6300eth/tmbslPhySMSC8700.c
new file mode 100644
index 0000000..3a5e253
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhySMSC8700.c
@@ -0,0 +1,1151 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8700.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8700 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8700/LAN8700i  
+ *               Revision 2.1 (03-06-09)
+ *
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+
+#include "lipp_6300eth_common.h"
+
+/*  Project include files */
+#include "tmbslPhy.h"
+#include "tmbslPhySMSC8700.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include "i2c_ip3203.h"
+#define AUTO_NEG_DELAY_MULTIPLIER (800)
+#endif /* __LINUX_GMAC_DRV__*/
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF)
+
+#define TMBSLPHYSMSC8700_PHY_MMIO_ADDRESS0 ((0x1be00000+0x38000))
+
+#define ANAR_DEFAULT_VAL (0x1E1)
+
+/* gEthContext[] is filled with MAC base address in the tmbslPhySMSC8700Init() 
+** function 
+*/
+
+tmbslPhySMSC8700Context_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYSMSC8700_PHY_MMIO_ADDRESS0}}; 
+
+typedef enum _tmbslPhySMSC8700Reg_t
+{
+    /* Basic mode control */
+    tmbslPhySMSC8700Bmcr		      = 0,  
+
+    /* Basic mode status */    
+    tmbslPhySMSC8700Bmsr		      =1,  
+
+    /* PHY ID1 register */        
+    tmbslPhySMSC8700PhyIdr1		=2,
+
+    /* PHY ID2 register */            
+    tmbslPhySMSC8700PhyIdr2		=3,
+
+    /* Auto negotiation advertisement register */                
+    tmbslPhySMSC8700Anar			=4,
+
+    /* Auto negotiation link partner ability register */                    
+    tmbslPhySMSC8700Anlpar		=5,
+
+    /* Auto negotiation expansion register */                        
+    tmbslPhySMSC8700Aner			=6,
+
+    /* 0x7 to 0xF reserved-*/
+
+    /* Silicon Revision register */
+    tmbslPhySMSC8700Srr=16,
+
+    /* Mode control & status register */
+    tmbslPhySMSC8700Mcsr=17,
+
+    /* Special modes register */
+    tmbslPhySMSC8700Smr=18,
+
+    /* 19-25 reserved */
+
+    /* Symbol error counter register */    
+    tmbslPhySMSC8700Secr	= 26,
+    
+    /* Control/Status indication register */        
+    tmbslPhySMSC8700Csir = 27,    
+
+    /* Special internal testability controls register*/            
+    tmbslPhySMSC8700Sitcr = 28,        
+    
+    /* Interrupt source register */
+    tmbslPhySMSC8700Isr = 29,
+
+    /* Interrupt mask register */
+    tmbslPhySMSC8700Imr = 30,    
+
+    /* PHY special control & status register */    
+    tmbslPhySMSC8700Pscsr = 31,    
+
+} tmbslPhySMSC8700Reg_t, *ptmbslPhySMSC8700Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t 
+tmbslPhySMSC8700Read (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t				reg,   
+    pUInt16						pVal
+	);
+	
+	
+static tmErrorCode_t	
+tmbslPhySMSC8700Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t				reg,   
+    UInt16						val
+	);
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void);
+#endif
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+	
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+	
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY. 
+//				 
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8700GetCapabilities (
+    tmUnitSelect_t                			ethUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    )
+
+{
+
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmsr, &bmsr);
+
+    pPhyCaps->T4Support100Base = 
+        (((bmsr & TMBSL_PHYSMSC8700_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_10MBPSFD) > 0) ? True : False);        
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8700_BMSR_10MBPSHD) > 0) ? True : False);
+
+
+    pPhyCaps->autoNegotiationAbility = 
+                (((bmsr &TMBSL_PHYSMSC8700_BMSR_AN_ABLE) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;		
+
+    /* Other capabilites set to False */   
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+	
+    return TM_OK;
+
+}   
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration. No Autonegotiation is done in the 
+//				initialization function
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700Init(
+    tmUnitSelect_t  						ethUnitId   
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;     		
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+    UInt16 id1, id2;
+
+
+    #ifdef __LIPP_6300ETH__
+    get_phy_out_of_rst();
+    #endif
+
+//    printf("\nIn SMSC Init\n");           
+
+    gEthContext[ethUnitId].pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Set the mode register to default value */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+//    printf("\nSMR val: %08x\n",regval);           
+
+    regval &= 0xBF1F; /* Set to 100Mbps FD, MII mode */
+    regval |= 0x60;    
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regval);        
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+//    printf("\nSMR val: %08x\n",regval);           
+
+    regval = TMBSL_PHYSMSC8700_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regval);
+
+    while( (regval & TMBSL_PHYSMSC8700_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regval);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+
+    }  
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYSMSC8700_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);	
+    } 
+
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700PhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+//    printf("\nETHERNET CLOCK1:%08x\n",*(unsigned long *)(0xbbe47710));                    
+//    printf("\nETHERNET CLOCK2:%08x\n",*(unsigned long *)(0xbbe47714));                    
+//    printf("\nETHERNET CLOCK3:%08x\n",*(unsigned long *)(0xbbe47718));                       
+//    printf("\nSMSC PHY INIT successful\n\n\n");    
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700Deinit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYSMSC8700_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else	
+    {
+        return TM_OK;
+    }
+
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700SetPowerState(
+    tmUnitSelect_t           				ethUnitId ,  
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYSMSC8700_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYSMSC8700_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,  
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYSMSC8700_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8700GetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,   
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = 
+                (((bmcr & TMBSL_PHYSMSC8700_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8700_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    if(bmcr & TMBSL_PHYSMSC8700_BMCR_SPEED_MSK)
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;            
+    }
+    else
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;                            
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8700SetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,   
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+    UInt16 regval;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYSMSC8700_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYSMSC8700_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed100Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8700_BMCR_SPEED_100;                
+        /* Set the mode register to default value */
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+
+        /* Clear the mode bits */
+        regval &= 0xFF1F;
+
+        regval |= 0x60;
+        ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regval);        
+
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+        printf("\nSMR val: %08x\n",regval);           
+            break;
+
+        case tmbslPhySpeed10Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8700_BMCR_SPEED_10;                
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+
+        /* Clear the mode bits */
+        regval &= 0xFF1F;
+
+        regval |= 0x20;
+
+        ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regval);        
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regval);
+        printf("\nSMR val: %08x\n",regval);           
+            
+                
+            break;
+
+        default:
+            break;
+
+    }
+
+    ethStatus = tmbslPhySMSC8700SoftReset(ethUnitId);
+
+    mdelay(10);
+    printf("\nSPEED/MODE updated from MODE pins\n");               
+
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Pscsr,&regval);
+    printf("\nPHY STS reg:%04x\n",regval);               
+
+    if(ethStatus != TM_OK)
+    {
+        printf("\nRESET failed after mode change\n");           
+    }
+
+    /* Write the result to the BMC register */
+//    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,   
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus     
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16           bmsr,bmcr,phySts;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from PHY status register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId, tmbslPhySMSC8700Pscsr, &phySts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYSMSC8700_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYSMSC8700_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYSMSC8700_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYSMSC8700_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYSMSC8700_BMCR_AN_EN) == 0) 
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8700_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        if(bmcr & TMBSL_PHYSMSC8700_BMCR_SPEED_MSK)
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;            
+        }
+        else
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;                        
+        }
+
+    }
+    else 
+    {
+        /* If autonegotiation is enabled, read from PHYSTS register */
+        pPhyBasicModeStatus->duplexMode = 
+                (((phySts & TMBSL_PHYSMSC8700_PHYSTS_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        pPhyBasicModeStatus->speed= 
+                (((phySts & TMBSL_PHYSMSC8700_PHYSTS_SPEED_MSK) == 0x4) ? tmbslPhySpeed10Mbps : tmbslPhySpeed100Mbps);
+
+    }
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700AutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=AUTO_NEG_DELAY_MULTIPLIER; 
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_NP;        
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_ADV_RF;        
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_AP;        
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_PAUSE;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_100B_TX_FD;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_100B_TX_HD;        
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_10B_TX_FD;        
+    }    
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8700_ANAR_10B_TX_HD;        
+    }    
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+//    printf("\nANAR val: %08x\n",regVal);
+   
+    /* Program the Auto negotiation mask */
+    tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Anar,regVal);
+
+    /* Enable the Auto negotiation in the BMCR register 
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYSMSC8700_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYSMSC8700_BMCR_AN_EN |
+              TMBSL_PHYSMSC8700_BMCR_AN_RESTART;
+    
+//    printf("\nBMCR val: %08x\n",regVal);
+   
+    tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,regVal);
+
+    /* Wait till the Auto negotiation is complete */
+    tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYSMSC8700_BMSR_AN_VAL) != TMBSL_PHYSMSC8700_BMSR_AN_VAL) && 
+           (timeout != 0 ) )
+    {
+        mdelay(5);
+        
+        ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&regVal);
+
+        if(ethStatus != TM_OK) 
+        {
+            return ethStatus;
+        }
+
+        timeout--;
+    }
+
+    if(  (timeout <= 0) && 
+         ( (regVal & TMBSL_PHYSMSC8700_BMSR_AN_VAL) != TMBSL_PHYSMSC8700_BMSR_AN_VAL)
+      )
+    {
+        return(-1);
+    }
+
+    GMAC_DBG("Autonegotiation Time:%d msec\n",(AUTO_NEG_DELAY_MULTIPLIER-timeout)*5);
+    
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback 
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8700LoopBack (
+    tmUnitSelect_t                  ethUnitId,   
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYSMSC8700_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYSMSC8700_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700SoftReset (
+    tmUnitSelect_t                     		ethUnitId      
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Bmcr,TMBSL_PHYSMSC8700_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,   
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 physts;
+
+    /* Read the BMSR register twice, as per datasheet */
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&physts);
+    ethStatus = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Bmsr,&physts);    
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+        (((physts & TMBSL_PHYSMSC8700_PHYSTS_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}   
+
+//-----------------------------------------------------------------------------
+//	Local static functions	
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8700Read (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t		reg,   
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;        
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;        
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && 
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        printf("\n&*&*&*PHY READ FAILED\n");    
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }  
+	
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+    
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8700Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8700Reg_t		reg,   
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL | 
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;        
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+             (timeout < PHY_TIMEOUT) );
+	
+	if( (timeout == PHY_TIMEOUT) && 
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+        printf("\n&*&*&*PHY WRITE FAILED\n");
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}  
+
+	return TM_OK;
+    
+}   
+
+//-----------------------------------------------------------------------------
+
+#if 0
+static tmErrorCode_t
+set_regs (void );
+
+static tmErrorCode_t
+    set_regs (void )
+{
+
+    tmErrorCode_t err = TM_OK;
+    UInt16 regVal=0;
+    tmUnitSelect_t ethUnitId = 0;
+
+    regVal =0x0;
+    err = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Mcsr,regVal);
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Mcsr,&regVal);
+    printf("\nMCSR val: %08x\n",regVal);           
+
+    regVal = 0xF6;
+    err = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Smr,regVal);        
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Smr,&regVal);
+    printf("\nSMR val: %08x\n",regVal);           
+
+    regVal =0;
+    err = tmbslPhySMSC8700Write(ethUnitId,tmbslPhySMSC8700Csir,regVal);        
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Csir,&regVal);
+    printf("\nCSIR val: %08x\n",regVal);           
+
+    err = tmbslPhySMSC8700Read(ethUnitId,tmbslPhySMSC8700Pscsr,&regVal);
+    printf("\nPSCSR val: %08x\n",regVal);  
+
+    return err;
+}           
+#endif
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void)
+{
+    //Msg for High, to bring PHY out of reset
+    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x01}; 
+
+    //Msg for Low, to put PHY in reset     
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x00}; 
+
+    pnx8xxx_ip3203_init();
+    pnx8xxx_ip3203_write(msg, sizeof(msg));
+
+    /*Wait till the PHY is out of reset */    
+    mdelay(1);
+
+    /* Turn the clocks to MAC from PHY */
+
+#if 0
+    /* PHY clocks */
+    writel(0x00000003, (unsigned long *)(0xbbe47710));	
+    writel(0x00000003, (unsigned long *)(0xbbe47714));	
+    writel(0x00000003, (unsigned long *)(0xbbe47718));	
+#endif 
+
+    #ifdef __LIPP_6300ETH__
+    /* PHY clocks */
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    #endif
+
+
+    mdelay(1);
+//    GMAC_DBG("\nETHERNET CLOCK1:%08x\n",*(unsigned int *)(0x1be47710));                    
+//    GMAC_DBG("\nETHERNET CLOCK2:%08x\n",*(unsigned int *)(0x1be47714));                    
+//    GMAC_DBG("\nETHERNET CLOCK3:%08x\n",*(unsigned int*)(0x1be47718));                       
+//    GMAC_DBG("\nSMSC PHY INIT successful\n\n\n");    
+
+    return;
+
+}
+
+#endif 
+
+
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhySMSC8700.h b/drivers/net/lipp_6300eth/tmbslPhySMSC8700.h
new file mode 100644
index 0000000..f9cafc8
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhySMSC8700.h
@@ -0,0 +1,504 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8700.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8700 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8700/LAN8700i  
+ *               Revision 2.1 (03-06-09)
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _TMBSL_PHYSMSC8700_H_
+#define _TMBSL_PHYSMSC8700_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYSMSC8700_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYSMSC8700_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYSMSC8700_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYSMSC8700_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYSMSC8700_BMCR_AN_EN (0x1000)
+
+#define TMBSL_PHYSMSC8700_BMCR_AN_RESTART (0x200)
+#define TMBSL_PHYSMSC8700_BMCR_AN_RESTART_CLR (0xFDFF)
+
+#define TMBSL_PHYSMSC8700_BMCR_AN_CLR (0xEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYSMSC8700_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYSMSC8700_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYSMSC8700_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYSMSC8700_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYSMSC8700_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYSMSC8700_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYSMSC8700_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYSMSC8700_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYSMSC8700_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYSMSC8700_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYSMSC8700_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYSMSC8700_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYSMSC8700_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYSMSC8700_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYSMSC8700_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYSMSC8700_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYSMSC8700_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYSMSC8700_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYSMSC8700_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYSMSC8700_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYSMSC8700_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYSMSC8700_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYSMSC8700_ANAR_PAUSE (0xc00)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYSMSC8700_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYSMSC8700_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYSMSC8700_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYSMSC8700_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYSMSC8700_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYSMSC8700_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYSMSC8700_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYSMSC8700_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYSMSC8700_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYSMSC8700_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYSMSC8700_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYSMSC8700_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYSMSC8700_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYSMSC8700_STRAP_ANE (0x8000)
+#define TMBSL_PHYSMSC8700_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYSMSC8700_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYSMSC8700_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYSMSC8700_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYSMSC8700_STRAP_SPD_10 (0x0)
+
+#define TMBSL_PHYSMSC8700_PHYSTS_SPEED_MSK (0xC)
+#define TMBSL_PHYSMSC8700_PHYSTS_LINK_STAT (0x4)
+#define TMBSL_PHYSMSC8700_PHYSTS_DUP_MODE (0x10)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhySMSC8700Context_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhySMSC8700Context_t, *ptmbslPhySMSC8700Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8700GetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhySMSC8700Init(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhySMSC8700Deinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700SetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhySMSC8700GetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhySMSC8700SetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700AutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8700LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700LoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700SoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8700GetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif //_TMBSL_PHYSMSC8700_H_
diff --git a/drivers/net/lipp_6300eth/tmbslPhySMSC8710.c b/drivers/net/lipp_6300eth/tmbslPhySMSC8710.c
new file mode 100644
index 0000000..c8163fb
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhySMSC8710.c
@@ -0,0 +1,1153 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8710.c %
+ * %pid_version:           1.2                %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8710 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8710/LAN8710i  
+ *               Revision 2.1 (03-06-09)
+ *
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+
+#include "lipp_6300eth_common.h"
+
+/*  Project include files */
+#include "tmbslPhy.h"
+#include "tmbslPhySMSC8710.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/* Timeout in case of linux */
+#ifdef __LIPP_6300ETH__
+#include "i2c_ip3203.h"
+#define AUTO_NEG_DELAY_MULTIPLIER (800)
+#endif /* __LINUX_GMAC_DRV__*/
+
+/* Defines */
+#define PHY_UNIT_ID_COUNT  			1
+
+#define PHY_TIMEOUT                 (0x0FFFFFFF)
+
+#define TMBSLPHYSMSC8710_PHY_MMIO_ADDRESS0 ((0x1be00000+0x38000))
+
+#define ANAR_DEFAULT_VAL (0x1E1)
+
+/* gEthContext[] is filled with MAC base address in the tmbslPhySMSC8710Init() 
+** function 
+*/
+
+tmbslPhySMSC8710Context_t gEthContext[PHY_UNIT_ID_COUNT] = {{TMBSLPHYSMSC8710_PHY_MMIO_ADDRESS0}}; 
+
+typedef enum _tmbslPhySMSC8710Reg_t
+{
+    /* Basic mode control */
+    tmbslPhySMSC8710Bmcr		      = 0,  
+
+    /* Basic mode status */    
+    tmbslPhySMSC8710Bmsr		      =1,  
+
+    /* PHY ID1 register */        
+    tmbslPhySMSC8710PhyIdr1		=2,
+
+    /* PHY ID2 register */            
+    tmbslPhySMSC8710PhyIdr2		=3,
+
+    /* Auto negotiation advertisement register */                
+    tmbslPhySMSC8710Anar			=4,
+
+    /* Auto negotiation link partner ability register */                    
+    tmbslPhySMSC8710Anlpar		=5,
+
+    /* Auto negotiation expansion register */                        
+    tmbslPhySMSC8710Aner			=6,
+
+    /* 0x7 to 0xF reserved-*/
+
+    /* Silicon Revision register */
+    tmbslPhySMSC8710Srr=16,
+
+    /* Mode control & status register */
+    tmbslPhySMSC8710Mcsr=17,
+
+    /* Special modes register */
+    tmbslPhySMSC8710Smr=18,
+
+    /* 19-25 reserved */
+
+    /* Symbol error counter register */    
+    tmbslPhySMSC8710Secr	= 26,
+    
+    /* Control/Status indication register */        
+    tmbslPhySMSC8710Csir = 27,    
+
+    /* Special internal testability controls register*/            
+    tmbslPhySMSC8710Sitcr = 28,        
+    
+    /* Interrupt source register */
+    tmbslPhySMSC8710Isr = 29,
+
+    /* Interrupt mask register */
+    tmbslPhySMSC8710Imr = 30,    
+
+    /* PHY special control & status register */    
+    tmbslPhySMSC8710Pscsr = 31,    
+
+} tmbslPhySMSC8710Reg_t, *ptmbslPhySMSC8710Reg_t;
+
+
+/* Static functions definition */
+
+static tmErrorCode_t 
+tmbslPhySMSC8710Read (
+	tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t				reg,   
+    pUInt16						pVal
+	);
+	
+	
+static tmErrorCode_t	
+tmbslPhySMSC8710Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t				reg,   
+    UInt16						val
+	);
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void);
+#endif
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetSWVersion (
+	ptmSWVersion_t					pPhyVersion
+	)
+{
+	
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+	
+	return TM_OK;
+
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY. 
+//				 
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8710GetCapabilities (
+    tmUnitSelect_t                			ethUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    )
+
+{
+
+    UInt16 bmsr;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmsr, &bmsr);
+
+    pPhyCaps->T4Support100Base = 
+        (((bmsr & TMBSL_PHYSMSC8710_BMSR_T4100BASE) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_X100BASEFD) > 0) ? True : False);
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_X100BASEHD) > 0) ? True : False);
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_10MBPSFD) > 0) ? True : False);        
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = 
+        (((bmsr &TMBSL_PHYSMSC8710_BMSR_10MBPSHD) > 0) ? True : False);
+
+
+    pPhyCaps->autoNegotiationAbility = 
+                (((bmsr &TMBSL_PHYSMSC8710_BMSR_AN_ABLE) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;		
+
+    /* Other capabilites set to False */   
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+	
+    return TM_OK;
+
+}   
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Init:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration. No Autonegotiation is done in the 
+//				initialization function
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710Init(
+    tmUnitSelect_t  						ethUnitId   
+    )
+{
+
+    tmErrorCode_t       		ethStatus = TM_OK;     		
+    UInt32                         timeout=0;
+    UInt16 regval=0;
+    UInt16 id1, id2;
+
+    #ifdef __LIPP_6300ETH__
+    get_phy_out_of_rst();
+    #endif
+
+//    printf("\nIn SMSC Init\n");           
+
+    gEthContext[ethUnitId].pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+
+    /* Set the mode register to default value */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+//    printf("\nSMR val: %08x\n",regval);           
+
+    regval &= 0xBF1F; /* Set to 100Mbps FD, MII mode */
+    regval |= 0x60;    
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regval);        
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+//    printf("\nSMR val: %08x\n",regval);           
+
+    regval = TMBSL_PHYSMSC8710_BMCR_RST_VAL;
+
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    /* Check if PHY is back to normal condition */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regval);
+
+    while( (regval & TMBSL_PHYSMSC8710_BMCR_RST_VAL) && (timeout < PHY_TIMEOUT) )
+    {
+
+
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regval);
+
+        if(ethStatus != TM_OK)
+        {
+            break;
+        }
+
+        timeout++;
+
+    }  
+
+    if(ethStatus != TM_OK)
+    {
+        return(ethStatus);
+    }
+
+    if( (timeout == PHY_TIMEOUT) && (regval & TMBSL_PHYSMSC8710_BMCR_RST_VAL) )
+    {
+        return(TMBSL_ERR_PHY_INIT_FAILED);	
+    } 
+
+#if 0
+    /* Read PHY Identification Register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710PhyIdr1,&id1);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710PhyIdr2,&id2);
+
+    if (ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+
+//    printf("\nETHERNET CLOCK1:%08x\n",*(unsigned long *)(0xbbe47710));                    
+//    printf("\nETHERNET CLOCK2:%08x\n",*(unsigned long *)(0xbbe47714));                    
+//    printf("\nETHERNET CLOCK3:%08x\n",*(unsigned long *)(0xbbe47718));                       
+//    printf("\nSMSC PHY INIT successful\n\n\n");    
+#endif
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Deinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710Deinit(
+    tmUnitSelect_t  						ethUnitId   
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+
+    bmcr |= TMBSL_PHYSMSC8710_BMCR_RST_VAL;
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else	
+    {
+        return TM_OK;
+    }
+
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710SetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710SetPowerState(
+    tmUnitSelect_t           				ethUnitId ,  
+    tmPowerState_t          				phyPowerState
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr = 0;
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    if( (phyPowerState == tmPowerOn) || (phyPowerState == tmPowerOff) )
+    {
+        if(phyPowerState == tmPowerOff)
+        {
+            bmcr |= TMBSL_PHYSMSC8710_BMCR_PWRDN_EN;
+        }
+        else
+        {
+            bmcr &=TMBSL_PHYSMSC8710_BMCR_PWRDN_CLR;
+        }
+
+        ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+        return ethStatus;
+
+    }
+    else
+    {
+        return TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetPowerState(
+    tmUnitSelect_t                  		ethUnitId ,  
+    ptmPowerState_t				phyPowerState
+    )
+
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 regVal=0;
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *phyPowerState = (((regVal & TMBSL_PHYSMSC8710_BMCR_PWRDN_EN) > 0) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8710GetBasicModeControl (
+    tmUnitSelect_t                   		ethUnitId,   
+    ptmbslPhyBasicModeControl_t       pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = 
+                (((bmcr & TMBSL_PHYSMSC8710_BMCR_COLTEST ) > 0) ? True : False);
+
+    pPhyBasicModeControl->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8710_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    if(bmcr & TMBSL_PHYSMSC8710_BMCR_SPEED_MSK)
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;            
+    }
+    else
+    {
+        pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;                            
+    }
+
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710SetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t 
+tmbslPhySMSC8710SetBasicModeControl (
+    tmUnitSelect_t                           ethUnitId,   
+    ptmbslPhyBasicModeControl_t        pPhyBasicModeControl
+    )
+{
+
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+    UInt16 bmcr =0;
+    UInt16 regval;
+
+    if(pPhyBasicModeControl->enableCollisionTest == True)
+    {
+        bmcr |= TMBSL_PHYSMSC8710_BMCR_COLTEST;
+    }
+
+    if(pPhyBasicModeControl->duplexMode == True)
+    {
+        bmcr |= TMBSL_PHYSMSC8710_BMCR_FD_EN;
+    }
+
+    switch(pPhyBasicModeControl->speed)
+    {
+
+        case tmbslPhySpeed100Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8710_BMCR_SPEED_100;                
+        /* Set the mode register to default value */
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+
+        /* Clear the mode bits */
+        regval &= 0xFF1F;
+
+        regval |= 0x60;
+        ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regval);        
+
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+        printf("\nSMR val: %08x\n",regval);           
+            break;
+
+        case tmbslPhySpeed10Mbps :       
+//            bmcr |= TMBSL_PHYSMSC8710_BMCR_SPEED_10;                
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+
+        /* Clear the mode bits */
+        regval &= 0xFF1F;
+
+        regval |= 0x20;
+
+        ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regval);        
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regval);
+        printf("\nSMR val: %08x\n",regval);           
+            
+                
+            break;
+
+        default:
+            break;
+
+    }
+
+    ethStatus = tmbslPhySMSC8710SoftReset(ethUnitId);
+
+    mdelay(10);
+    printf("\nSPEED/MODE updated from MODE pins\n");               
+
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Pscsr,&regval);
+    printf("\nPHY STS reg:%04x\n",regval);               
+
+    if(ethStatus != TM_OK)
+    {
+        printf("\nRESET failed after mode change\n");           
+    }
+
+    /* Write the result to the BMC register */
+//    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetBasicModeStatus (
+    tmUnitSelect_t                  		ethUnitId,   
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus     
+    )
+
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16           bmsr,bmcr,phySts;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Bmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the autonegotiation status from PHY status register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId, tmbslPhySMSC8710Pscsr, &phySts);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = (((bmsr & TMBSL_PHYSMSC8710_BMSR_JAB_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->remoteFaultDetected = (((bmsr & TMBSL_PHYSMSC8710_BMSR_RF_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->autoNegotiationComplete = (((bmsr & TMBSL_PHYSMSC8710_BMSR_AN_VAL) > 0) ? True : False);
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYSMSC8710_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    if((bmcr & TMBSL_PHYSMSC8710_BMCR_AN_EN) == 0) 
+    {
+        /* Not an auto negotiation. So read the values from BMCR */
+        pPhyBasicModeStatus->duplexMode = 
+                (((bmcr & TMBSL_PHYSMSC8710_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        if(bmcr & TMBSL_PHYSMSC8710_BMCR_SPEED_MSK)
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;            
+        }
+        else
+        {
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;                        
+        }
+
+    }
+    else 
+    {
+        /* If autonegotiation is enabled, read from PHYSTS register */
+        pPhyBasicModeStatus->duplexMode = 
+                (((phySts & TMBSL_PHYSMSC8710_PHYSTS_DUP_MODE) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+        pPhyBasicModeStatus->speed= 
+                (((phySts & TMBSL_PHYSMSC8710_PHYSTS_SPEED_MSK) == 0x4) ? tmbslPhySpeed10Mbps : tmbslPhySpeed100Mbps);
+
+    }
+
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710AutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710AutoNegotiate (
+    tmUnitSelect_t                       	      ethUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    )
+{
+
+    tmErrorCode_t   ethStatus=TM_OK;
+    UInt32             timeout=AUTO_NEG_DELAY_MULTIPLIER; 
+
+    UInt16 regVal = ANAR_DEFAULT_VAL;
+    UInt16 mask =0;
+
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Anar,regVal);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(pAutoNegotiationMask->masknextPageDesired == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_NP;        
+    }
+
+    if(pAutoNegotiationMask->maskRemoteFault == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_ADV_RF;        
+    }
+
+    if(pAutoNegotiationMask->maskAsymmetricPause == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_AP;        
+    }
+
+    if(pAutoNegotiationMask->maskPauseFrame == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_PAUSE;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_100B_TX_FD;        
+    }
+
+    if(pAutoNegotiationMask->mask100BaseTxSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_100B_TX_HD;        
+    }
+
+    if(pAutoNegotiationMask->mask10BaseTFullDuplexSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_10B_TX_FD;        
+    }    
+
+    if(pAutoNegotiationMask->mask10BaseTSupport == True)
+    {
+        mask |= TMBSL_PHYSMSC8710_ANAR_10B_TX_HD;        
+    }    
+
+    /* Clear the corresponding bits in the regVal*/
+    regVal &= ~(mask);
+
+//    printf("\nANAR val: %08x\n",regVal);
+   
+    /* Program the Auto negotiation mask */
+    tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Anar,regVal);
+
+    /* Enable the Auto negotiation in the BMCR register 
+    ** First clear the auto negotiate bit and then enable
+    */
+    tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&regVal);
+
+    /* Clear autonegotiation bit */
+    regVal &= TMBSL_PHYSMSC8710_BMCR_AN_CLR;
+
+    regVal |= TMBSL_PHYSMSC8710_BMCR_AN_EN |
+              TMBSL_PHYSMSC8710_BMCR_AN_RESTART;
+    
+//    printf("\nBMCR val: %08x\n",regVal);
+   
+    tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,regVal);
+
+    /* Wait till the Auto negotiation is complete */
+    tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&regVal);
+
+    /* While the Autonegotiation is not complete, stay in loop */
+    while(((regVal & TMBSL_PHYSMSC8710_BMSR_AN_VAL) != TMBSL_PHYSMSC8710_BMSR_AN_VAL) && 
+           (timeout != 0 ) )
+    {
+        mdelay(5);
+        
+        ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&regVal);
+
+        if(ethStatus != TM_OK) 
+        {
+            return ethStatus;
+        }
+
+        timeout--;
+    }
+
+    if(  (timeout <= 0) && 
+         ( (regVal & TMBSL_PHYSMSC8710_BMSR_AN_VAL) != TMBSL_PHYSMSC8710_BMSR_AN_VAL)
+      )
+    {
+        return(-1);
+    }
+
+    GMAC_DBG("Autonegotiation Time:%d msec\n",(AUTO_NEG_DELAY_MULTIPLIER-timeout)*5);
+    
+    return TM_OK;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback 
+//				mode.
+//
+// RETURN:      TM_OK
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhySMSC8710LoopBack (
+    tmUnitSelect_t                  ethUnitId,   
+    tmbslPhyEnableDisable_t     loopbackMode
+    )
+{
+
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYSMSC8710_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYSMSC8710_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,bmcr);
+
+    return ethStatus;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710SoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710SoftReset (
+    tmUnitSelect_t                     		ethUnitId      
+	)
+
+{
+    tmErrorCode_t       		ethStatus=TM_OK;     		
+
+    /* All the registers will be reset */
+    ethStatus = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Bmcr,TMBSL_PHYSMSC8710_BMCR_RST_VAL);
+
+    return ethStatus;
+
+}   
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710GetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetLinkStatus (
+    tmUnitSelect_t                          ethUnitId,   
+    ptmbslPhyEnableDisable_t            pLinkStatus
+    )
+{
+    tmErrorCode_t ethStatus=TM_OK;     		
+    UInt16 physts;
+
+    /* Read the BMSR register twice, as per datasheet */
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&physts);
+    ethStatus = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Bmsr,&physts);    
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+        (((physts & TMBSL_PHYSMSC8710_PHYSTS_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+
+}   
+
+//-----------------------------------------------------------------------------
+//	Local static functions	
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Read:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8710Read (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t		reg,   
+    pUInt16						pVal
+	)
+
+{
+
+    UInt32  timeout=0;
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;        
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;        
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) && 
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        printf("\n&*&*&*PHY READ FAILED\n");    
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }  
+	
+    /* Read the data from the data register */
+
+    *pVal = (UInt16) *pDataReg;
+    
+    return TM_OK;
+
+}   
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710Write:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:      
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+static tmErrorCode_t
+tmbslPhySMSC8710Write (
+    tmUnitSelect_t				ethUnitId,
+    tmbslPhySMSC8710Reg_t		reg,   
+    UInt16						val
+	)
+
+{
+
+    UInt32 pEthRegs;       
+    volatile UInt32 *pAdrReg;
+    volatile  UInt32 *pDataReg;
+    UInt32 regValue;
+
+    UInt32      timeout=0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gEthContext[ethUnitId].pRegs;
+
+    /* Get the Address register */  
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+       
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;  
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL | 
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;        
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) && 
+             (timeout < PHY_TIMEOUT) );
+	
+	if( (timeout == PHY_TIMEOUT) && 
+           ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+	{
+        printf("\n&*&*&*PHY WRITE FAILED\n");
+	    return(TMBSL_ERR_PHY_WRITE_FAILED);
+	}  
+
+	return TM_OK;
+    
+}   
+
+//-----------------------------------------------------------------------------
+
+#if 0
+static tmErrorCode_t
+set_regs (void );
+
+static tmErrorCode_t
+    set_regs (void )
+{
+
+    tmErrorCode_t err = TM_OK;
+    UInt16 regVal=0;
+    tmUnitSelect_t ethUnitId = 0;
+
+    regVal =0x0;
+    err = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Mcsr,regVal);
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Mcsr,&regVal);
+    printf("\nMCSR val: %08x\n",regVal);           
+
+    regVal = 0xF6;
+    err = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Smr,regVal);        
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Smr,&regVal);
+    printf("\nSMR val: %08x\n",regVal);           
+
+    regVal =0;
+    err = tmbslPhySMSC8710Write(ethUnitId,tmbslPhySMSC8710Csir,regVal);        
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Csir,&regVal);
+    printf("\nCSIR val: %08x\n",regVal);           
+
+    err = tmbslPhySMSC8710Read(ethUnitId,tmbslPhySMSC8710Pscsr,&regVal);
+    printf("\nPSCSR val: %08x\n",regVal);  
+
+    return err;
+}           
+#endif
+
+#ifdef __LIPP_6300ETH__
+static void get_phy_out_of_rst( void)
+{
+    //Msg for High, to bring PHY out of reset
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x01}; 
+
+    //Msg for Low, to put PHY in reset     
+//    unsigned char msg[]={0x00,0x04,0x00,0x02,0x07,0x00}; 
+
+//    pnx8xxx_ip3203_init();
+//    pnx8xxx_ip3203_write(msg, sizeof(msg));
+
+    /*Wait till the PHY is out of reset */    
+    mdelay(1);
+
+    /* Turn the clocks to MAC from PHY */
+
+#if 0
+    /* PHY clocks */
+    writel(0x00000003, (unsigned long *)(0xbbe47710));	
+    writel(0x00000003, (unsigned long *)(0xbbe47714));	
+    writel(0x00000003, (unsigned long *)(0xbbe47718));	
+#endif 
+
+    #ifdef __LIPP_6300ETH__
+    /* PHY clocks */
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    *(unsigned long *)(MMIO_BASE) = 0x00000003;
+    #endif
+
+
+    mdelay(1);
+//    GMAC_DBG("\nETHERNET CLOCK1:%08x\n",*(unsigned int *)(0x1be47710));                    
+//    GMAC_DBG("\nETHERNET CLOCK2:%08x\n",*(unsigned int *)(0x1be47714));                    
+//    GMAC_DBG("\nETHERNET CLOCK3:%08x\n",*(unsigned int*)(0x1be47718));                       
+//    GMAC_DBG("\nSMSC PHY INIT successful\n\n\n");    
+
+    return;
+
+}
+
+#endif 
+
+
+
diff --git a/drivers/net/lipp_6300eth/tmbslPhySMSC8710.h b/drivers/net/lipp_6300eth/tmbslPhySMSC8710.h
new file mode 100644
index 0000000..bf1afc4
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmbslPhySMSC8710.h
@@ -0,0 +1,504 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhySMSC8710.h %
+ * %pid_version:              1.2              %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for SMSC8710 PHY
+ *
+ * DOCUMENT REF: Datasheet SMSC LAN8710/LAN8710i  
+ *               Revision 2.1 (03-06-09)
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef _TMBSL_PHYSMSC8710_H_
+#define _TMBSL_PHYSMSC8710_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYSMSC8710_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYSMSC8710_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYSMSC8710_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYSMSC8710_BMCR_SPEED_MSK (0x2000)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYSMSC8710_BMCR_AN_EN (0x1000)
+
+#define TMBSL_PHYSMSC8710_BMCR_AN_RESTART (0x200)
+#define TMBSL_PHYSMSC8710_BMCR_AN_RESTART_CLR (0xFDFF)
+
+#define TMBSL_PHYSMSC8710_BMCR_AN_CLR (0xEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYSMSC8710_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYSMSC8710_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYSMSC8710_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYSMSC8710_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYSMSC8710_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYSMSC8710_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYSMSC8710_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYSMSC8710_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYSMSC8710_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYSMSC8710_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYSMSC8710_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYSMSC8710_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYSMSC8710_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYSMSC8710_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYSMSC8710_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYSMSC8710_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYSMSC8710_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYSMSC8710_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYSMSC8710_BMSR_JAB_VAL (0x2)
+
+
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYSMSC8710_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYSMSC8710_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYSMSC8710_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYSMSC8710_ANAR_PAUSE (0xc00)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYSMSC8710_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYSMSC8710_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYSMSC8710_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYSMSC8710_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYSMSC8710_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYSMSC8710_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYSMSC8710_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYSMSC8710_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYSMSC8710_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYSMSC8710_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYSMSC8710_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYSMSC8710_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYSMSC8710_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** STRAP options register ******/
+#define TMBSL_PHYSMSC8710_STRAP_ANE (0x8000)
+#define TMBSL_PHYSMSC8710_STRAP_DUP (0x4000)
+
+/* Bit 13:12  similar to bits 6:13 in basic mode control register */
+#define TMBSL_PHYSMSC8710_STRAP_SPD_MSK (0x3000)
+#define TMBSL_PHYSMSC8710_STRAP_SPD_1G (0x2000)
+#define TMBSL_PHYSMSC8710_STRAP_SPD_100 (0x1000)
+#define TMBSL_PHYSMSC8710_STRAP_SPD_10 (0x0)
+
+#define TMBSL_PHYSMSC8710_PHYSTS_SPEED_MSK (0xC)
+#define TMBSL_PHYSMSC8710_PHYSTS_LINK_STAT (0x4)
+#define TMBSL_PHYSMSC8710_PHYSTS_DUP_MODE (0x10)
+
+
+
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef struct  _tmbslPhySMSC8710Context_t
+{
+    UInt32    			pRegs;         // Array ETHERNET Module regs 
+} tmbslPhySMSC8710Context_t, *ptmbslPhySMSC8710Context_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version 
+//				information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhySMSC8710GetSWVersion (
+    ptmSWVersion_t      					pPhyVersion    
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//				unit. The function is callable at any time to return the unit's 
+//				capabilities (PHY unit initialization is not necessary). 
+//				Capabilities may be different among multiple PHY units.For completeness, 
+//				a PHY BSL user should call this function for each PHY unit to 
+//				determine its individual capabilities. 
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY 
+//				or in PowerOff state. 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetCapabilities (
+    tmUnitSelect_t                			phyUnitId,  
+    ptmbslPhyCapabilities_t  				pPhyCaps    
+    );
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//				before any access to the device is made. 
+//
+// RETURN:      TM_OK 
+
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following 
+//				default initial configuration.
+//				1. Enable the auto negotiation. In auto-negotiation mode the 
+//				highest possible performance mode is selected automatically 
+//				which the Link Partner also supports. (In auto negotiation mode
+//				speed and duplex mode will be selected by means of auto negotiation. 
+//				Writing to speed and duplex mode does not have meaning in auto 
+//				negotiation mode.)
+//				2. The device abilities are programmed to Auto negotiation advertise 
+//				register. None of the device abilities are masked. If the PHY 
+//				device does not support Auto-negotiation mode, then this function 
+//				will set the PHY to basic capabilities of the device.The function 
+//				tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to 
+//				know what are the default configurations the tmbslPhyInit function 
+//				has set to
+ 
+//-----------------------------------------------------------------------------
+//
+    
+tmErrorCode_t
+tmbslPhySMSC8710Init(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+    
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//				deinitilized device will no more be available to access 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhySMSC8710Deinit(
+    tmUnitSelect_t  						phyUnitId   
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified 
+//				power state
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710SetPowerState(
+    tmUnitSelect_t           				phyUnitId ,  
+    tmPowerState_t          				phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetPowerState(
+    tmUnitSelect_t                  		phyUnitId ,  
+    ptmPowerState_t							phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.  
+//				tmbslPhyInit Enable the Auto negotiation mode and will configure 
+//				the PHY device for the maximum performance mode available. After 
+//				the device is initialized this function can be called to know the 
+//				present settings of the PHY device. If application wants to change 
+//				the settings it can call tmbslPhySetBasicModeControl to change 
+//				the configuration after knowing the capabilities of the PHY device 
+//				and Link Partner. #define for the Basic Mode Control 
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t 
+tmbslPhySMSC8710GetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode. 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t 
+tmbslPhySMSC8710SetBasicModeControl (
+    tmUnitSelect_t                   		phyUnitId,   
+    ptmbslPhyBasicModeControl_t      		pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device 
+//				such as the speed, duplex mode 
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetBasicModeStatus (
+    tmUnitSelect_t                  		phyUnitId,   
+    ptmbslPhyBasicModeStatus_t    			pPhyBasicModeStatus     
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device 
+//				with Link Partner. Best possible performance configuration is 
+//				selected automatically during this process
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710AutoNegotiate (
+    tmUnitSelect_t                       	phyUnitId,   
+    ptmbslPhyAutoNegotitationMask_t      	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySMSC8710LoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710LoopBack (
+    tmUnitSelect_t                      	phyUnitId,   
+    tmbslPhyEnableDisable_t           		loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710SoftReset (
+    tmUnitSelect_t                     		phyUnitId      
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//				TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:      
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhySMSC8710GetLinkStatus (
+    tmUnitSelect_t                          phyUnitId,   
+    ptmbslPhyEnableDisable_t           		pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif //_TMBSL_PHYSMSC8710_H_
diff --git a/drivers/net/lipp_6300eth/tmhwLIPP6100Eth.c b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth.c
new file mode 100644
index 0000000..90c393c
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth.c
@@ -0,0 +1,3069 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth.c %
+ * %pid_version:          1.7                  %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   Scalable HwApi Driver for Ethernet GMAC
+ *
+ *  DOCUMENT REF: Synopsys DesignWare Ethernet Universal Databook 
+ *                         Version 3.41a, February 7, 2008 
+  *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+/*-----------------------------------------------------------------------------
+/ Standard include files:
+/-----------------------------------------------------------------------------
+*/
+
+#include "tmNxTypes.h"
+
+/*-----------------------------------------------------------------------------
+/ Project include files:
+/-----------------------------------------------------------------------------
+*/
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "tmhwLIPP6100Eth.h"
+#include "tmhwLIPP6100Eth_Vhip.h"
+
+/*-----------------------------------------------------------------------------
+/ Types and defines:
+/-----------------------------------------------------------------------------
+*/
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+    
+    #if ( IPVERSION_34_1_A)
+    #define MMC_RST_ON_RD_SAVE(_base_, _val_) \
+    {\
+        UInt32 _tmp_;\
+        TMVH_GEN_READ(_base_+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,_val_);\
+        _tmp_ = _val_;\
+        _tmp_ &= ~TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL;\
+        TMVH_GEN_WRITE(_base_+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,_tmp_);\
+    }
+
+    #define MMC_RST_ON_RD_RESTORE(_base_,_val_) \
+        TMVH_GEN_WRITE(_base_+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,_val_)
+    #else
+    #define MMC_RST_ON_RD_SAVE(_base_, _val_) 
+    #define MMC_RST_ON_RD_RESTORE(_base_,_val_) 
+    #endif
+
+#endif
+
+/*-----------------------------------------------------------------------------
+/ Global data:
+/-----------------------------------------------------------------------------
+*/
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+
+    #if ( IPVERSION_34_1_A)
+    static UInt32 gtmhwLIPP6100Eth_ActRegVal[14];
+    #endif
+
+#endif
+
+/*-----------------------------------------------------------------------------
+/ Internal Prototypes:
+/-----------------------------------------------------------------------------
+*/
+
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+
+    #if ( IPVERSION_34_1_A)
+    UInt32  compute_ipc_value (UInt32 pRegs,UInt32 regOffset,UInt32 index);
+    #endif
+
+#endif
+
+
+/*-----------------------------------------------------------------------------
+/ Exported functions:
+/-----------------------------------------------------------------------------
+*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetSWVersion:
+**
+** DESCRIPTION: This function returns the Ethernet HWAPI device interface software 
+** version information.Higher-level software layers to ensure that the 
+** Ethernet HWAPI exports the expected function interface version typically
+** call it.
+**
+** RETURN:      TM_OK
+**
+** NOTES:   This API can be called anytime i.e. before initializing the Ethernet 
+**          or in PowerOff state.
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSWVersion (
+    ptmSWVersion_t  pEthGmacVersion    
+    )
+{
+    pEthGmacVersion->compatibilityNr = TMHW_LIPP6100ETH_COMPATIBILITY_NR;
+    pEthGmacVersion->majorVersionNr  = TMHW_LIPP6100ETH_MAJOR_VERSION_NR;
+    pEthGmacVersion->minorVersionNr  = TMHW_LIPP6100ETH_MINOR_VERSION_NR;
+    return (TM_OK);
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetHWVersion:
+**
+** DESCRIPTION: This function returns the hardware version number of the
+**                      Ethernet unit passed as parameter to this function.
+**
+** RETURN:      TM_OK
+**
+** NOTES:       This API can be called anytime i.e. before initializing the Ethernet
+**                   or in PowerOff state
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetHWVersion(
+    tmUnitSelect_t                    ethUnitId,  
+    pUInt32                             pHWVersion
+    ) 
+{
+    UInt32 pRegs; 
+    
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_VERSION_REG_OFFSET,*pHWVersion);
+
+    return (TM_OK);
+
+}        
+
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_Init:
+**
+** DESCRIPTION: This function initializes the Ethernet device hardware. 
+**                      It should be called before any access to the device is made. 
+**                      This function does the following things
+**                      Initialize MAC with
+**                      1. Loop back disabled
+**                      2. Tx Flow control enabled
+**                      3. Rx Flow control enabled
+**                      4. Half Duplex mode
+**                      5. 10 Mbps Speed
+**                      6. Inter frame gap = 0.96ms 
+**                      7. Disable all interrupts 
+**                      8. Power State = ON
+**
+** RETURN:      TM_OK
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_Init(
+    tmUnitSelect_t  ethUnitId
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Reset the GMAC core */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,
+                                TMVH_LIPP6100ETH_BUS_MODE_RESET_VAL);
+
+    /* Program the MAC configuration register. Untouched values are in default state 
+    ** PS =1 : MII 10/100 Mbps 
+    ** FES = : 10 Mbps 
+    ** Half duplex
+    ** Automatic CRC padding/stripping
+    */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,
+                                TMVH_LIPP6100ETH_CONFIG_MII_VAL |
+                                TMVH_LIPP6100ETH_CONFIG_ACS_VAL);
+
+    /* Default values for PHY at address 2, MDIO clock is selected in 
+    ** GMII address register 
+    */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,
+                             regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_CLR) & 
+                    TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_CLR);
+
+    regVal |= (TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL << TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS) |
+                  (TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL << TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,
+                                regVal);    
+
+    /* Flow control settings 
+    ** Enable transmit and receive flow control in half duplex mode
+    */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,
+                                TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL |
+                                TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL);
+
+    /* Address filtering: Accept broadcast & Unicast packets. 
+    ** No special settings required 
+    */
+
+    /* All interrupts are disabled after reset */
+
+    return (TM_OK);
+   
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_Deinit:
+** 
+**  DESCRIPTION: This function deinitializes the Ethernet device. 
+**                      This function will perform following actions
+**                      Disables DMA tx & rx
+**                      Disables GMAC tx & rx state machines
+**                      Resets the GMAC
+** 
+**  RETURN:        TM_OK
+**  
+**  NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_Deinit(
+    tmUnitSelect_t  ethUnitId   
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);        
+
+    /* Disable DMA transmission & reception */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                               regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR) &
+                    TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                regVal);
+
+    /* Disable GMAC transmission & reception state machines */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR) & 
+                    TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    /* Reset the GMAC */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,regVal);
+
+    regVal |=TMVH_LIPP6100ETH_BUS_MODE_RESET_VAL;
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,regVal);
+
+    return (TM_OK);
+
+}    
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_GetPowerState
+**
+** DESCRIPTION: Function will get the existing power state of the device
+**
+** RETURN       : TM_OK
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetPowerState(
+    tmUnitSelect_t    ethUnitId ,
+    ptmPowerState_t pEthPowerState
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);  
+    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+    regVal &=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_MSK;
+
+    *pEthPowerState = ( (regVal == TMVH_LIPP6100ETH_POWER_OFF ) ? tmPowerOff : tmPowerOn);
+
+    return TM_OK;
+    
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetPowerState
+**
+** DESCRIPTION: Function will set the power state to the device to the specified value
+**
+** RETURN:      TM_OK
+**
+** NOTES:       Set the Power state to power down will do the following things
+**                  1. Disable the both the transmitt and receive DMA Manager
+**                  2. set the Power down bit by writing to the power down register
+**                  Set the power state of the device to the power up will do the following things
+**                  1. Reset the power down bit in the power down register
+**                  2. Reenable the both the transmitt and receive  channels
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t	
+tmhwLIPP6100Eth_SetPowerState(
+    tmUnitSelect_t   ethUnitId  , 
+    tmPowerState_t  ethPowerState
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+    regVal &=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_MSK;
+
+    if( ((ethPowerState == tmPowerOff) && (regVal == TMVH_LIPP6100ETH_POWER_ON)) || 
+        ((ethPowerState == tmPowerOn) && (regVal == TMVH_LIPP6100ETH_POWER_OFF)) )
+    {
+
+        if(ethPowerState == tmPowerOff)
+        {
+            /* Disable DMA Transmission and reception */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                       regVal);
+
+            regVal = ((regVal & TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR) &
+                            TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                        regVal);
+
+            /* Disable GMAC transmission & reception state machines */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            regVal = ((regVal & TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR) & 
+                            TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            /* Turn off the port power */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+            regVal |=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_VAL;
+
+        }
+        else
+        {
+
+            /* Enable GMAC transmission & reception state machines */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            regVal |=(TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL|
+                            TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+            /* Enable DMA Transmission and reception */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                       regVal);
+            regVal |= (TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL|
+                            TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL);
+
+            TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,
+                                        regVal);
+
+            /* Clear the port power bit */
+            TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);
+
+            regVal &=TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_CLR;
+           
+        }
+
+        TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);          
+
+    }
+
+    return (TM_OK);
+
+}   
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_WoLConfig
+**
+** DESCRIPTION: This function will set the wakeup procedure, required before going down 
+**                     to power down mode.
+**
+** RETURN:         TM_OK 
+**
+** NOTES:       See tmhwLIPP6100Eth_WkupCfg_t structure.
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t	
+tmhwLIPP6100Eth_WoLConfig(
+    tmUnitSelect_t   ethUnitId  , 
+    tmhwLIPP6100Eth_WkupCfg_Kpk_t  pWolConfig
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal = 0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(pWolConfig->rstRegptr == True)
+    {
+        TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,TMVH_LIPP6100ETH_WKUP_FMFILTER_RSTREG_VAL);
+    }
+
+    if(pWolConfig->globalUnicastEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_PWRMGMT_GU_VAL;        
+    }
+
+    if(pWolConfig->magicPktEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_PWRMGMT_MAGIC_PKT_EN_VAL;
+    }
+
+    if(pWolConfig->wkupFrameEn == True)
+    {
+         regVal |= TMVH_LIPP6100ETH_PWRMGMT_WKUP_FM_EN_VAL;        
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,regVal);    
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[0]);
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[1]);   
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[2]);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterMask[3]);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterCommand);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterOffset);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterCrcVal6);    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET,pWolConfig->filterCrcVal7);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetWakeupStatus
+**
+** DESCRIPTION: This function is used to find the cause of wakeup event when in power down
+**                     mode.
+**                     
+** RETURN:         TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetWakeupStatus(
+    tmUnitSelect_t       ethUnitId ,    
+    pUInt32                  pRegVal
+    )
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET,*pRegVal);
+
+    return(TM_OK);    
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetConfig
+**
+** DESCRIPTION: This function will configure the general Ethernet configuration 
+**                     related Ethernet and PHY device with the parameters passed
+**
+** RETURN:         TM_OK 
+**
+** NOTES:       See tmhwLIPP6100Eth_DevConfig_t structure.
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetConfig(
+    tmUnitSelect_t                  ethUnitId ,    
+    tmhwLIPP6100Eth_DevConfig_Kpk_t pEthConfig
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);  
+
+    if(pEthConfig->txConfiginfo == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL ;
+    }
+
+    if(pEthConfig->wdTimer == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_WD_VAL ;
+    }
+
+    if(pEthConfig->jabberTimer == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_JD_VAL;
+    }
+
+    if((pEthConfig->miiSelect == False ) && (pEthConfig->frameBurst == True)) 
+    {
+        regVal |=TMVH_LIPP6100ETH_CONFIG_FBE_VAL;
+    }
+
+    if (pEthConfig->jumboFrame == True)
+    {
+        regVal |=TMVH_LIPP6100ETH_CONFIG_JFE_VAL;
+    }
+
+    if (pEthConfig->disableCS == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DISCS_VAL;
+    }
+
+    regVal |= (UInt32)(pEthConfig->ifg << TMVH_LIPP6100ETH_CONFIG_IFG_POS);    
+
+    
+    if(pEthConfig->miiSelect == True)
+    {
+        /* Select the GMII or MII interface */
+        regVal |= TMVH_LIPP6100ETH_CONFIG_MII_VAL;
+
+        if(pEthConfig->speed100Mbps == True)
+        {
+            regVal |= TMVH_LIPP6100ETH_CONFIG_FES_VAL;
+        }
+    }
+
+    if(pEthConfig->disableReceiveOwn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DRXOWN_VAL;
+    }
+
+    if(pEthConfig->duplexMode == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DUPLEX_VAL;
+    }
+
+    if(pEthConfig->ipChecksumOffload == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_IPCCHK_VAL;
+    }
+
+    if(pEthConfig->disableRetry == True)
+    {
+      regVal |= TMVH_LIPP6100ETH_CONFIG_DRETRY_VAL;
+    }
+    
+    if(pEthConfig->autoPadCRC == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_ACS_VAL;
+    }
+
+    regVal |= (UInt32)(pEthConfig->backOffLim << TMVH_LIPP6100ETH_CONFIG_BACKOFF_POS);
+
+    if(pEthConfig->deferralCheck == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_DEFCHK_VAL;
+    }
+
+    /* Write regVal to MAC config register */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    /* Write the PHY adress & Select MDC clock frequency in GMII address register */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,regVal);
+
+    regVal = ((regVal & TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_CLR) &    
+                    TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_CLR);
+
+    regVal |= pEthConfig->phyAddress << TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS;
+    regVal |= (UInt32)(pEthConfig->clockSelect << TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS);
+        
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,regVal);
+
+    /* Set the station Address */
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_ADDR0_HIGH_REG_OFFSET,
+                                pEthConfig->station.adrHigh); 
+    
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_ADDR0_LOW_REG_OFFSET,
+                                pEthConfig->station.adrLow); 
+
+    return (TM_OK);
+    
+}    
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_GetConfig
+** 
+** DESCRIPTION: This function will get the present configure of the Ethernet and PHY device
+** RETURN:         TM_OK 
+** 
+** NOTES:       See ptmhwLIPP6100Eth_DevConfig_t structure.
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetConfig(
+    tmUnitSelect_t                      ethUnitId ,    
+    ptmhwLIPP6100Eth_DevConfig_t    pEthConfig
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);  
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    pEthConfig->txConfiginfo = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL) > 0) ? True : False);
+
+    pEthConfig->wdTimer = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_WD_VAL) > 0) ? True : False);
+
+    pEthConfig->txConfiginfo = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL) > 0) ? True : False);    
+
+    pEthConfig->jabberTimer = (Bool) (((regVal & TMVH_LIPP6100ETH_CONFIG_JD_VAL) > 0) ? True : False);
+    
+    pEthConfig->frameBurst = (Bool) (((regVal & TMVH_LIPP6100ETH_CONFIG_FBE_VAL) > 0) ? True : False);
+    pEthConfig->jumboFrame = (Bool) (((regVal & TMVH_LIPP6100ETH_CONFIG_JFE_VAL) > 0) ? True : False);
+
+    pEthConfig->ifg = (tmhwLIPP6100Eth_IFG_t) ((regVal &TMVH_LIPP6100ETH_CONFIG_IFG_MSK) >>
+                                TMVH_LIPP6100ETH_CONFIG_IFG_POS);
+
+    pEthConfig->disableCS = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DISCS_VAL) > 0) ? True : False);        
+
+    pEthConfig->miiSelect = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_MII_VAL) > 0) ? True : False);
+    pEthConfig->speed100Mbps = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_FES_VAL) > 0) ? True : False);
+    
+    pEthConfig->duplexMode = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DUPLEX_VAL) > 0) ? True : False);
+    pEthConfig->disableReceiveOwn = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DRXOWN_VAL) > 0) ? True : False);
+    pEthConfig->ipChecksumOffload = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_IPCCHK_VAL) > 0) ? True : False);
+    pEthConfig->disableRetry = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_DRETRY_VAL) > 0) ? True : False);
+    pEthConfig->linkup = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_LNKUP_VAL) > 0) ? True : False);
+    pEthConfig->autoPadCRC = (Bool)(((regVal & TMVH_LIPP6100ETH_CONFIG_ACS_VAL) > 0) ? True : False);
+    pEthConfig->backOffLim = (tmhwLIPP6100Eth_BackOffLimit_t) ((regVal & TMVH_LIPP6100ETH_CONFIG_BACKOFF_MSK) >> 
+                                            TMVH_LIPP6100ETH_CONFIG_BACKOFF_POS);
+
+    pEthConfig->deferralCheck = (Bool)(regVal & TMVH_LIPP6100ETH_CONFIG_DEFCHK_VAL);
+
+    /* Get the MDC clock value */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET,regVal);
+
+    pEthConfig->clockSelect = (tmhwLIPP6100Eth_ClkDiv_t) ((regVal & TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_MSK) >> 
+                                            TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS);
+
+    pEthConfig->phyAddress = (regVal & TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_MSK) >>TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS;
+
+    /* Read the station address into the structure member */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_ADDR0_HIGH_REG_OFFSET,regVal);
+    
+    pEthConfig->station.adrHigh = regVal & TMVH_LIPP6100ETH_ADDR0_HIGH_REG_MSK;
+    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_ADDR0_LOW_REG_OFFSET,regVal);
+    
+    pEthConfig->station.adrLow = regVal;
+
+    return (TM_OK);
+    
+}    
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_IntGetStatus
+**
+** DESCRIPTION: The function returns the DMA interrupt status register value
+**
+** RETURN       :  TM_OK 
+** NOTES        :  
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntGetStatus (
+    tmUnitSelect_t   ethUnitId ,    
+    ptmhwLIPP6100Eth_Int_t pIntStat
+    )
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Read the DMA interrupt status register */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_DMA_STATUS_REG_OFFSET,pIntStat->dmaIntVal);
+
+    /* Read the MMC, PMT, PCS, RGMII interrupt status */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_INTR_STATUS_REG_OFFSET,pIntStat->gmacIntVal);    
+
+    return (TM_OK);
+
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION    : tmhwLIPP6100Eth_IntEnable
+**
+** DESCRIPTION: Read the current interrupt register values & OR the value passed
+**
+** RETURN       : TM_OK 
+** NOTES        :       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntEnable (
+    tmUnitSelect_t              ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t pIntEn
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Writing a 1 in the DMA interrupt enable register enables the interrupt */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);
+    
+    regVal |=pIntEn->dmaIntVal;
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);    
+
+    /* Clearing the corresponding bit in the Interrupt mask register enables the interrupt, 
+    ** if previously masked 
+    */    
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);
+
+    regVal &= ~(pIntEn->gmacIntVal);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);     
+
+    return (TM_OK);
+    
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwEthGmacIntDisable
+**
+** DESCRIPTION: This function will Disable the sources of interrupt(s) for DMA
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntDisable (
+    tmUnitSelect_t                  ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t pIntDis
+    )
+{
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* Writing a 0, disables the interrupt */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);
+
+    regVal &=~(pIntDis->dmaIntVal);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET,regVal);    
+
+    /* Writing a 1 masks the corresponding interrupt */
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);
+
+    regVal |=pIntDis->gmacIntVal;
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET,regVal);        
+
+    return (TM_OK);
+
+}    
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_IntClear
+**
+** DESCRIPTION: This function will clear the sources of interrupt(s) for DMA
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntClear (
+    tmUnitSelect_t              ethUnitId ,    
+    UInt32                         ethIntstatus
+    )
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_DMA_STATUS_REG_OFFSET,ethIntstatus);
+
+    return (TM_OK);
+}    
+
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     ttmhwLIPP6100Eth_PerfectAdrSetConfig
+**
+** DESCRIPTION: This function Configures the perfect address filtering register 
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           There are 31 perfect address filter registers available. The register number (1-31)
+**                       is passed as the paramter to this function.
+**                       Station address register is not part of these 1-31 registers
+**
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrSetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,
+    tmhwLIPP6100Eth_Kpk_PerAdrCfg_t pAdrConfig
+)
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(pAdrConfig->addressEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_ADDR_ENABLE_VAL;    
+    }
+
+    if(pAdrConfig->srcAddrCmp == True)
+    {
+        regVal |=TMVH_LIPP6100ETH_ADDR_SA_EN_VAL;    
+    }
+
+    /* Set the mask value */
+    regVal |= pAdrConfig->addrMask << TMVH_LIPP6100ETH_ADDR_MBC_POS;
+
+    regVal |= (pAdrConfig->macAddrHigh & TMVH_LIPP6100ETH_ADDR_HIGH_REG_MSK);
+
+    if (regNum < 16 )
+    {
+        /* Write into the perfect address High Register */        
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR1_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),regVal);        
+
+        /* Write into the perfect address low Register */            
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR1_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),pAdrConfig->macAddrlow);                
+    }
+    else
+    {
+        /* Write into the perfect address High Register */        
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR16_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),regVal);        
+
+        /* Write into the perfect address low Register */            
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR16_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),pAdrConfig->macAddrlow);                    
+    }
+
+    return (TM_OK);
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_PerfectAdrGetConfig
+**
+** DESCRIPTION: This function gets the current values of perfect address filtering register 
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           There are 32 perfect filter registers available. The register number (0-31)
+**                       is passed as the paramter to this function
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,    
+    ptmhwLIPP6100Eth_PerfectAdrConfig_t pAdrConfig
+)
+{
+
+    UInt32 pEthRegs;
+    UInt32 regHigh=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if (regNum < 16 )
+    {
+        /* Read from the High Register */        
+        TMVH_GEN_READ((pEthRegs+TMVH_LIPP6100ETH_ADDR1_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),regHigh);        
+
+        /*Read from the perfect address low Register */            
+        TMVH_GEN_READ((pEthRegs+TMVH_LIPP6100ETH_ADDR1_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(regNum)),pAdrConfig->macAddrlow);                
+    }
+    else
+    {
+        /* Read from the perfect address High Register */        
+        TMVH_GEN_READ((pEthRegs+TMVH_LIPP6100ETH_ADDR16_HIGH_REG_OFFSET)+
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),regHigh);        
+
+        /* Read from the perfect address low Register */            
+        TMVH_GEN_WRITE((pEthRegs+TMVH_LIPP6100ETH_ADDR16_LOW_REG_OFFSET)+        
+                                    (TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(regNum)),pAdrConfig->macAddrlow);                    
+    }
+
+    pAdrConfig->addressEnable = (Bool)(((regHigh & TMVH_LIPP6100ETH_ADDR_ENABLE_VAL ) > 0) ? True: False); 
+
+    pAdrConfig->addrMask = (regHigh & TMVH_LIPP6100ETH_ADDR_MBC_MSK) >> 
+                                        TMVH_LIPP6100ETH_ADDR_MBC_POS;
+    
+    pAdrConfig->macAddrHigh = regHigh & TMVH_LIPP6100ETH_ADDR_HIGH_REG_MSK;
+
+    pAdrConfig->srcAddrCmp = (Bool) ( ((regHigh & TMVH_LIPP6100ETH_ADDR_SA_EN_VAL ) > 0) ? True: False); 
+
+    return (TM_OK);
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FilterSetConfig
+**
+** DESCRIPTION: This function configures the filters for incoming frames.
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterSetConfig(
+    tmUnitSelect_t                          ethUnitId , 
+    tmhwLIPP6100Eth_FilterConfig_Kpk_t  pFilterConfig
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+    
+    if(pFilterConfig->receiveAllEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_RX_ALL_VAL;    
+    }
+
+    if(pFilterConfig->passAllFrames == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_PR_VAL;
+    }                
+
+    if(pFilterConfig->srcAdrFilterEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_SAF_VAL;     
+    }    
+
+    if(pFilterConfig->srcAdrInvFilterEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_SAIF_VAL;     
+    }    
+
+    if(pFilterConfig->destAdrInvFiltering == True)
+    {
+         regVal |= TMVH_LIPP6100ETH_FMFLTR_DAIF_VAL;   
+    }        
+
+    if(pFilterConfig->filterBroadCastFrames == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_DBF_VAL;     
+    }        
+
+    if(pFilterConfig->recvAllMulticast == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_PM_VAL;    
+    }        
+
+    if(pFilterConfig->hashMulticastEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HMC_VAL;     
+    }        
+    
+    if(pFilterConfig->hashUnicastEnable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HUC_VAL;    
+    }        
+
+     /* Enable hash filtering as well as perfect address filtering simultaneously on a given frame.
+     i.e. Frame is dropped only when it fails the hash filtering as well as perfect address filtering.
+     To enable this bit 10 of Filter Frame Register has to be set. Also Hash Unicast & Hash Multicast
+     bits in Filter Frame Register should be set. The bit 10 when set ensures that perfect address
+     filtering is enabled for both Unicast as well as Multicast frames (irrespective of value of Hash
+     Unicast & Hash Multicast bits).
+     */
+    if(pFilterConfig->hashNPerfectFilterEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_VAL;
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HMC_VAL;             
+        regVal |= TMVH_LIPP6100ETH_FMFLTR_HUC_VAL;            
+    }
+
+    regVal |= (UInt32)(pFilterConfig->pauseSetting << TMVH_LIPP6100ETH_FMFLTR_PCF_POS);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FMFLTR_REG_OFFSET,regVal);
+
+    return (TM_OK);    
+
+}
+
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FilterGetConfig
+**
+** DESCRIPTION: This function gets the current configuration of filters
+**
+** RETURN:         TM_OK 
+**
+** NOTES:           
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    ptmhwLIPP6100Eth_FilterConfig_t        pFilterConfig
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FMFLTR_REG_OFFSET,regVal);
+
+    pFilterConfig->receiveAllEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_RX_ALL_VAL) > 0 )? True:False);
+    pFilterConfig->srcAdrFilterEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_SAF_VAL) > 0) ? True:False);
+    pFilterConfig->srcAdrInvFilterEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_SAIF_VAL) > 0) ? True:False);
+    pFilterConfig->hashNPerfectFilterEn = (Bool) (((regVal & TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_VAL) > 0) ? True:False);
+    pFilterConfig->filterBroadCastFrames = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_DBF_VAL) > 0) ? True:False);    
+    pFilterConfig->recvAllMulticast = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_PM_VAL) > 0) ? True:False);    
+    pFilterConfig->destAdrInvFiltering = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_DAIF_VAL) > 0) ? True:False);    
+    pFilterConfig->hashMulticastEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_HMC_VAL) > 0) ? True:False);    
+    pFilterConfig->hashUnicastEnable = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_HUC_VAL) > 0) ? True:False);    
+    pFilterConfig->passAllFrames = (Bool) (((regVal &TMVH_LIPP6100ETH_FMFLTR_PR_VAL) > 0) ? True:False);    
+    pFilterConfig->pauseSetting = (tmhwLIPP6100Eth_PCF_t) ((regVal & TMVH_LIPP6100ETH_FMFLTR_PCF_MSK) >>
+                                                TMVH_LIPP6100ETH_FMFLTR_PCF_POS);
+    return (TM_OK);    
+    
+}
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_HASH)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_HashFilterSetConfig
+**
+** DESCRIPTION: This function will configure the Hash Filter Table.
+**
+** RETURN:      TM_OK 
+**
+** NOTES:        Hash filtering (Multicast/Unicast) must be enabled by calling the function 
+**                   tmhwLIPP6100Eth_FilterSetConfig()
+** 
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterSetConfig(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_HashFilter_Kpk_t    pHashConfig
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_HIGH_REG_OFFSET,
+                                pHashConfig->hashFilterH);
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_LOW_REG_OFFSET,
+                                pHashConfig->hashFilterL);
+    
+    return (TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_HashFilterGetConfig
+**
+** DESCRIPTION: Function will get the present Hash Filter Table configuration.
+**
+** RETURN:      TM_OK 
+**                  
+** NOTES:        
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterGetConfig(
+    tmUnitSelect_t                                ethUnitId ,
+    ptmhwLIPP6100Eth_HashFilter_t          pHashConfig
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_HIGH_REG_OFFSET,
+                                pHashConfig->hashFilterH);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_HASHTBL_LOW_REG_OFFSET,
+                                pHashConfig->hashFilterL);
+    
+    return (TM_OK);
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GmacEnableDisable
+**
+** DESCRIPTION: Enables/Disables the GMAC state machine. 
+**
+** RETURN:      TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_GmacEnableDisable (
+    tmUnitSelect_t                              ethUnitId,
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t            pEndir    
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+        
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    if(pEndir->dirFlag == tmhwLIPP6100Eth_Dir_TxRx)
+    {
+        if(pEndir->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL | 
+                          TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL;
+        }
+        else
+        {
+            regVal = ((regVal & TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR) & 
+                            TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR);        
+        }
+
+    }
+    else if(pEndir->dirFlag == tmhwLIPP6100Eth_Dir_Tx)
+    {
+        if(pEndir->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+             regVal |= TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL;
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR;        
+        }
+        
+    }
+    else
+    {
+        if(pEndir->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+             regVal |= TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL;
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR;        
+        }
+
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_LpbkEnableDisable
+**
+** DESCRIPTION: Function will set the hardware in the loop back mode at the MAC interface
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_LpbkEnableDisable (
+    tmUnitSelect_t                              ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t     enableDisable
+    ) 
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);
+
+    if(enableDisable == tmhwLIPP6100Eth_Enable)
+    {
+        regVal |= TMVH_LIPP6100ETH_CONFIG_LPBK_VAL ;
+    }
+    else
+    {
+        regVal &=TMVH_LIPP6100ETH_CONFIG_LPBK_CLR;
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_CONFIG_REG_OFFSET,regVal);    
+
+    return (TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_FlowCtrlSetConfig
+**
+** DESCRIPTION: Configures the flow control register.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlSetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t        pFlowCtrlCfg
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    regVal |= (UInt32)pFlowCtrlCfg->pauseTime << TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_POS;
+
+    if (pFlowCtrlCfg->zeroQuanta == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL;
+    }
+
+    regVal |= (UInt32)pFlowCtrlCfg->pauseLowThreshold << TMVH_LIPP6100ETH_FLOWCTRL_PLT_POS;
+
+    if (pFlowCtrlCfg->unicastPsDetect == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_UP_VAL;
+    }
+
+    if (pFlowCtrlCfg->rxFlowCtrlEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL;
+    }
+
+    if (pFlowCtrlCfg->txFlowCtrlEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL;
+    }    
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);        
+
+    return(TM_OK);    
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FlowCtrlGetConfig
+**
+** DESCRIPTION: Gets the configured values in the the flow control register.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlGetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    ptmhwLIPP6100Eth_FlowCtrlConfig_t        pFlowCtrlCfg
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);
+
+    pFlowCtrlCfg->pauseLowThreshold = (tmhwLIPP6100Eth_PLT_t) ((regVal & TMVH_LIPP6100ETH_FLOWCTRL_PLT_MSK) >>
+                                                    TMVH_LIPP6100ETH_FLOWCTRL_PLT_POS);
+
+    pFlowCtrlCfg->zeroQuanta = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL) >0) ? True: False);
+    
+    pFlowCtrlCfg->pauseTime = (regVal & TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_MSK) >> 
+                                                    TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_POS;
+
+    pFlowCtrlCfg->zeroQuanta = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL) >0) ? True: False);
+
+    pFlowCtrlCfg->rxFlowCtrlEn = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL) >0) ? True: False);
+    
+    pFlowCtrlCfg->txFlowCtrlEn = (Bool)(((regVal & TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL) > 0) ? True:False); 
+    
+    pFlowCtrlCfg->unicastPsDetect = (Bool)(((regVal &TMVH_LIPP6100ETH_FLOWCTRL_UP_VAL) > 0) ? True:False);
+
+    return(TM_OK);    
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FlowCtrlEnableDisable
+**
+** DESCRIPTION: Enables flow control in Full Duplex and Half duplex modes
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlEnableDisable(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t enableDisable
+) 
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);    
+
+    if(enableDisable == tmhwLIPP6100Eth_Disable) 
+    {
+        regVal &=TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_CLR;
+    }
+    else
+    {
+        regVal |=TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL;
+    }
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,regVal);
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_FlowCtrlStatus
+**
+** DESCRIPTION: Gets the staus of FCA/BP bit 
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlStatus(
+    tmUnitSelect_t                          ethUnitId,
+    pUInt32                                    pRegVal
+) 
+{
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs+TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET,*pRegVal);    
+
+    return(TM_OK);
+
+}
+
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaConfig
+**
+** DESCRIPTION: This function does the general configuration of DMA
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaConfig(
+    tmUnitSelect_t                               ethUnitId ,
+    tmhwLIPP6100Eth_DmaCfg_Kpk_t        pDmaConfig
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    /* General DMA configuration */
+    if(pDmaConfig->fixedBurstEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_FB_VAL; 
+    }
+
+    if(pDmaConfig->pBL4xmode == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_4XPBL_VAL; 
+    }
+
+    if(pDmaConfig->differentPBL == True)
+    {
+        /* Separate PBL for reception */
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_SEPPBL_VAL; 
+        regVal |= (UInt32)pDmaConfig->rxPBL << TMVH_LIPP6100ETH_BUS_MODE_RX_PBL_POS;        
+    }
+
+    regVal |= (UInt32)pDmaConfig->burstLen << TMVH_LIPP6100ETH_BUS_MODE_PBL_POS;
+    
+    regVal |= pDmaConfig->descSkipLen << TMVH_LIPP6100ETH_BUS_MODE_DSL_POS;
+
+    if(pDmaConfig->dmaArbitration == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_DA_VAL;
+    }
+    else
+    {
+        regVal |= (UInt32)pDmaConfig->priority << TMVH_LIPP6100ETH_BUS_MODE_PR_POS; 
+    }
+
+    if(pDmaConfig->addrAlignedBtsEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_BUS_MODE_AAL_VAL;
+    }
+
+    /* Write to Bus mode register */
+     TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET,regVal);
+
+    regVal =0;
+
+    if(pDmaConfig->disableFrameFlush == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FRM_FLUSH_DIS_VAL; 
+    }
+
+    if(pDmaConfig->storeNforwardEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_SF_VAL;
+    }
+
+    if(pDmaConfig->rxStoreNforwardEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RSF_VAL;
+    }
+
+    if(pDmaConfig->recvTcpIpErrFrms == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_DT_VAL;
+    }
+
+    if(pDmaConfig->txSecondFrameEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_OSF_VAL;
+    }
+
+    regVal |= (UInt32) (pDmaConfig->txThreshold << TMVH_LIPP6100ETH_OPERN_MODE_TTC_POS);
+
+    regVal |= (UInt32) (pDmaConfig->rxThreshold << TMVH_LIPP6100ETH_OPERN_MODE_RTC_POS);
+
+    /* Receive side configuration */
+    if(pDmaConfig->hwFlowCtrlEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_EFC_VAL;
+    }
+
+    if(pDmaConfig->errFramesEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FEF_VAL;
+    }
+    
+    if(pDmaConfig->underSizedGdFramesEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FUF_VAL;
+    }
+
+    if(pDmaConfig->actRxThreshold > tmhwLIPP6100Eth_RFA_4K)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RFA2_VAL;
+    }
+
+    regVal |= (UInt32)((((UInt32)pDmaConfig->actRxThreshold) &TMVH_LIPP6100ETH_OPERN_MODE_MSB_CLR) << 
+                    TMVH_LIPP6100ETH_OPERN_MODE_RFA_POS);
+
+    if(pDmaConfig->deactRxThreshold > tmhwLIPP6100Eth_RFD_4K)
+    {
+        regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RFD2_VAL;
+    }
+
+    regVal |= (UInt32) ((((UInt32)pDmaConfig->deactRxThreshold) & TMVH_LIPP6100ETH_OPERN_MODE_MSB_CLR) << 
+                    TMVH_LIPP6100ETH_OPERN_MODE_RFD_POS);
+
+    /* Write to Operation mode register */
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);    
+
+    /* Write the Transmit descriptor base address */
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_TXDESC_LISTADDR_REG_OFFSET,
+                                pDmaConfig->txDescListBaseAdr);
+
+    /* Write the receive descriptor base address */    
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_RXDESC_LISTADDR_REG_OFFSET,
+                                pDmaConfig->rxDescListBaseAdr);
+
+    return(TM_OK);
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaFlushTxFifo
+**
+** DESCRIPTION: This function flushes the transmit fifo
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaFlushTxFifo(
+    tmUnitSelect_t  ethUnitId 
+) 
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);        
+
+    regVal |= TMVH_LIPP6100ETH_OPERN_MODE_FTF_VAL;
+
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);            
+
+    return(TM_OK);
+
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaEnableDisable
+**
+** DESCRIPTION: This function enables/disables the DMA in Tx & Rx directions
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaEnableDisable(
+    tmUnitSelect_t                      ethUnitId, 
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t    pTxfr
+) 
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);        
+
+    if(pTxfr->dirFlag == tmhwLIPP6100Eth_Dir_TxRx) 
+    {
+    
+        if(pTxfr->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= (TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL |
+                           TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL);
+        }
+        else
+        {
+            /* If it is disable, clear the tx enable & rx enable bits */
+            regVal = ((regVal & TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR) & 
+                            TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR);
+
+        }
+
+    }
+    else if(pTxfr->dirFlag == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        if(pTxfr->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL;                    
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR;
+        }
+
+    }
+    else
+    {
+        if(pTxfr->enFlag == tmhwLIPP6100Eth_Enable)
+        {
+            regVal |= TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL;                    
+        }
+        else
+        {
+            regVal &= TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR;
+        }
+
+    }
+
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET,regVal);            
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaPollDesc
+**
+** DESCRIPTION: This function writes a dummy value into either Tx or Rx or both the registers
+**                     depending on the 'dir' value passed. This reenables DMA if it is suspended. 
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaPollDesc   (
+    tmUnitSelect_t          ethUnitId,
+    tmhwLIPP6100Eth_Dir_t       dir
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(dir == tmhwLIPP6100Eth_Dir_Tx)
+    {
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_TXMT_DMD_REG_OFFSET,0xFF);        
+    }
+    else if (dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_RECV_DMD_REG_OFFSET,0xFF);            
+    }
+    else
+    {
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_TXMT_DMD_REG_OFFSET,0xFF);            
+        TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_RECV_DMD_REG_OFFSET,0xFF);            
+    }
+
+    return(TM_OK);
+
+}
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaGetCurrentHostRegs
+**
+** DESCRIPTION: This function returns all the host register values.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetCurrentHostRegs(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaHostRegs_t     pDmaHostReg       
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+     
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_TX_DESC_REG_OFFSET,
+                                pDmaHostReg->curHostTxDesc);       
+    
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_RX_DESC_REG_OFFSET,
+                                pDmaHostReg->curHostRxDesc);       
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_TXBUFADR_REG_OFFSET,
+                                pDmaHostReg->curHostTxBufferAdr);       
+
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_CUR_HOST_RXBUFADR_REG_OFFSET,
+                                pDmaHostReg->curHostRxBufferAdr);       
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaGetMissedFrameCount
+**
+** DESCRIPTION: This function returns the number of missed frames during reception 
+**                     due to Receive FIFO overflow or due to host buffer being unavailable
+**                     This API can be used for debug purposes
+**
+** RETURN:        TM_OK 
+**
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetMissedFrameCount(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaMissedFrmCnt_t pMissedFrmCnt
+    )
+{
+
+    UInt32 pEthRegs;
+    UInt32 regVal;
+
+    pEthRegs = GET_BASE(ethUnitId);
+     
+    TMVH_GEN_READ(pEthRegs +TMVH_LIPP6100ETH_MISSFR_BUFOVRFLOW_CNT_REG_OFFSET,
+                                regVal);       
+
+    pMissedFrmCnt->fifoOverflowCnt = (regVal & TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_MSK) >>
+                                                       TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_POS;
+
+    pMissedFrmCnt->buffNotAvlCnt = (regVal & TMVH_LIPP6100ETH_MISSFR_BUF_CNT_MSK);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_DmaMissedFrameCounterClear
+**
+** DESCRIPTION: This function clears the missed frame counter values
+**                      This API can be used for debug purposes
+**
+** RETURN:        TM_OK 
+**
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaMissedFrameCounterClear(
+    tmUnitSelect_t                                 ethUnitId
+    )
+{
+
+    UInt32 pEthRegs;
+
+    pEthRegs = GET_BASE(ethUnitId);
+     
+    TMVH_GEN_WRITE(pEthRegs +TMVH_LIPP6100ETH_MISSFR_BUFOVRFLOW_CNT_REG_OFFSET,0x1fffffff);       
+
+    return(TM_OK);
+}
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCConfig
+**
+** DESCRIPTION: Configures the behaviour of MAC statistics counters
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_MMCConfig(
+    tmUnitSelect_t                      ethUnitId,
+    tmhwLIPP6100Eth_MmcCtrl_Kpk_t           pCtrlConfig
+    
+)
+{
+    UInt32 pEthRegs;
+    UInt32 regVal=0;
+
+    pEthRegs = GET_BASE(ethUnitId);
+
+    if(pCtrlConfig->freezeCntrs == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_CNTR_FREZ_VAL;
+    }
+
+    if(pCtrlConfig->resetCounters == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_CNTR_RESET_VAL;
+    }
+    if(pCtrlConfig->resetOnRdEn == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL;
+    }
+
+    if(pCtrlConfig->rollOverDisable == True)
+    {
+        regVal |= TMVH_LIPP6100ETH_MMC_CTRL_STOP_ROLLOVER_VAL;
+    }
+
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)     
+    #if ( IPVERSION_34_1_A)
+    if (pCtrlConfig->resetCounters == True )
+    {
+        UInt8 i;
+        for(i=0;i < 28;i++)
+        {
+            gtmhwLIPP6100Eth_ActRegVal[i]=0;
+        }
+    }
+    #endif    
+#endif
+
+    TMVH_GEN_WRITE(pEthRegs+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET, regVal);
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCIntStatus
+**
+** DESCRIPTION: This function gets the current interrupt status on the MMC counters in Tx 
+** and Rx direction
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntStatus(
+    tmUnitSelect_t                            ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcIntStat_t   pMmcStat
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if (pMmcStat->dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RX_REG_OFFSET,pMmcStat->intStat);
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INT_REG_OFFSET,pMmcStat->rxCsumStatus);
+    }
+    else
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TX_REG_OFFSET,pMmcStat->intStat);    
+    }
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCIntEnable
+**
+** DESCRIPTION: This function enables MMC interrupts. The value passed is ORed with the 
+**                      already configured interrupts
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntEnable(
+    tmUnitSelect_t                           ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t  pMmcIntEn
+    )
+{
+
+    UInt32 pRegs;
+    UInt32 regVal;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if (pMmcIntEn->dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regVal);
+
+        regVal &=~(pMmcIntEn->intrVal);
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regVal);
+
+        /* Checksum offload interrupt mask register */        
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regVal);
+
+        regVal &= ~(pMmcIntEn->rxCsumIntVal);
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regVal);
+
+    }
+    else
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regVal);
+
+        regVal &=~(pMmcIntEn->intrVal);
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regVal);
+    }
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCIntDisable
+**
+** DESCRIPTION: This function disables the MMC interrupts. Only the interrupts which 
+**                      needs to be disabled are cleared.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntDisable(
+    tmUnitSelect_t                            ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t   pMmcIntDis
+    )
+{
+
+    UInt32 pRegs;
+    UInt32 regValue;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if (pMmcIntDis->dir == tmhwLIPP6100Eth_Dir_Rx)
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regValue);
+
+        regValue |= pMmcIntDis->intrVal;
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET,regValue);
+
+        /* Checksum offload interrupt mask register */        
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regValue);
+
+        regValue |= pMmcIntDis->rxCsumIntVal;
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET,regValue);
+
+    }
+    else
+    {
+        TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regValue);
+
+        regValue |= pMmcIntDis->intrVal;
+
+        TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET,regValue);
+    }
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_MMCCountersRead
+**
+** DESCRIPTION: This function reads the MMC counter and returns the value. 
+**                      The counter to be read is passed as a parameter to this function
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+  
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCCountersRead(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcRegVal_t pMmcReg
+    )
+{
+    UInt32 pRegs;
+
+#if ( IPVERSION_34_1_A)
+    UInt32 regVal;
+#endif
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if(pMmcReg->dir == tmhwLIPP6100Eth_Dir_Tx)
+    {
+
+        switch(pMmcReg->regToRd)
+        {
+            case TMHW_LIPP6100ETH_TX_OCTET_CNT_GB:
+
+                    MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXOCTET_CNT_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    MMC_RST_ON_RD_RESTORE(pRegs,regVal);
+                    break;
+                
+            case TMHW_LIPP6100ETH_TX_FRAME_CNT_GB :
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXFRAME_CNT_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;
+                
+            case TMHW_LIPP6100ETH_TX_BRDCST_CNT_G:
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXBRDCST_CNT_G_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;
+
+            case TMHW_LIPP6100ETH_TX_MULTCST_CNT_G:
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TXMULTCST_CNT_G_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;
+
+            case TMHW_LIPP6100ETH_TX_64_CNT_GB:
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX64_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+
+            case TMHW_LIPP6100ETH_TX_65TO127_CNT_GB:
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX65TO127_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+
+            case TMHW_LIPP6100ETH_TX_128TO255_CNT_GB:    
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX128TO255_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_256TO511_CNT_GB:    
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX256TO511_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_512TO1023_CNT_GB:        
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX512TO1023_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_1024TOMAX_CNT_GB:            
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX1024TOMAX_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                    
+            case TMHW_LIPP6100ETH_TX_UNICAST_CNT_GB:                
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_UNICAST_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                    
+            case TMHW_LIPP6100ETH_TX_MULTCST_CNT_GB:                
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_MULTCST_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_BRDCST_CNT_GB:                
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_BRDCST_GB_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_UNDERFLOW_ERR_CNT:                    
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_UNNDERFLOW_ERR_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_SINGLE_COL_CNT_G:                    
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_SINGLCOL_G_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_MULTICOL_COL_G:                        
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_MULTICOL_G_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_DEFERRED_CNT:                            
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_DEFERRED_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_LATECOL_CNT:                                
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_LATECOL_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_EXCESSCOL_CNT:                                    
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_EXCESSCOL_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_CARRIER_ERR_CNT:    
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_CARRIER_ERR_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_OCTET_CNT_G:        
+
+                    MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_OCTET_CNT_G_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    MMC_RST_ON_RD_RESTORE(pRegs,regVal);                    
+                    
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_FRAME_CNT_G:            
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_FRM_CNT_G_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_EXCESSDEF_CNT:                
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_EXCESS_DEF_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;            
+
+            case TMHW_LIPP6100ETH_TX_PAUSE_FRAMES_CNT:                    
+                
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_PAUSE_FRAMES_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                
+                
+            case TMHW_LIPP6100ETH_TX_VLAN_FRAMES_CNT_G:                        
+
+                    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TX_VLAN_FRAMES_G_REG_OFFSET,\
+                        pMmcReg->mmcRegVal);
+                    break;                            
+
+            default:
+                
+                    break;
+
+        } 
+
+    }
+    else
+    {
+
+        switch(pMmcReg->regToRd)
+        {
+            
+            case TMHW_LIPP6100ETH_RX_FRM_CNT_GB:
+                
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXFRM_CNT_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+               
+                break;                            
+                
+            case TMHW_LIPP6100ETH_RX_OCTET_CNT_GB:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);  
+
+                break;                            
+                
+            case TMHW_LIPP6100ETH_RX_OCTET_CNT_G:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);  
+
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_BRDCSTF_CNT_G:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_BRDCSTF_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_MULTCSTF_CNT_G:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_MULTCSTF_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_CRC_ERR_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_CRC_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_ALIGNMT_ERR_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_ALIGNMT_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_RUNT_ERR_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_RUNT_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_JABBER_ERR_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_JABBER_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_UNDERSIZE_CNT_G:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_UNDERSIZE_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;                            
+
+            case TMHW_LIPP6100ETH_RX_OVERSIZE_CNT_G:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_OVERSIZE_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_64_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_64_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_65TO127_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_65TO127_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_128TO255_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_128TO255_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_256TO511_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_256TO511_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_512TO1023_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_512TO1023_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_1024TOMAX_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_1024TOMAX_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_UNICAST_CNT_G:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_UNICAST_G_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_LEN_ERR_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_LEN_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_OUTOFRANGE_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_OUTOFRANGE_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_PAUSE_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_PAUSE_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_FIFO_OVERFLOW_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_FIFO_OVERFLOW_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_VLAN_FRAMES_CNT_GB:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_VLAN_FRAMES_GB_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_WATCHDOG_ERR_CNT:
+
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RX_WATCHDOG_ERR_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                break;            
+
+            /* IPC counters */
+            case TMHW_LIPP6100ETH_RX_IPV4_FRMCNT_G:
+
+                #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_GD_FRMS_REG_OFFSET,0);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_GD_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif            
+
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_FRMCNT:
+
+                #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_HDERR_FRMS_REG_OFFSET,1);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_HDERR_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_FRMCNT:
+
+                #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_FRMS_REG_OFFSET,2);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_FRAG_FRMCNT:
+
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_FRMS_REG_OFFSET,3);
+                #else
+                  TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_FRMS_REG_OFFSET,\
+                  pMmcReg->mmcRegVal);
+                #endif
+
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_FRMCNT:
+
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_FRMS_REG_OFFSET,4);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV6_FRMCNT_G:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV6_GD_FRMS_REG_OFFSET,5);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_GD_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_FRMCNT:
+
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV6_HDERR_FRMS_REG_OFFSET,6);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_HDERR_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV6_NOPAY_FRMCNT:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_FRMS_REG_OFFSET,7);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_UDP_FRMCNT_G:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXUDP_GD_FRMS_REG_OFFSET,8);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_GD_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_UDP_ERR_FRMCNT:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXUDP_ERR_FRMS_REG_OFFSET,9);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_ERR_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_TCP_FRMCNT_G:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXTCP_GD_FRMS_REG_OFFSET,10);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXTCP_GD_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_TCP_ERR_FRMCNT:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXTCP_ERR_FRMS_REG_OFFSET,11);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXTCP_ERR_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_ICMP_FRMCNT_G:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXICMP_GD_FRMS_REG_OFFSET,12);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXICMP_GD_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_ICMP_ERR_FRMCNT:
+               #if ( IPVERSION_34_1_A)
+                pMmcReg->mmcRegVal = \
+                compute_ipc_value(pRegs,TMVH_LIPP6100ETH_MMC_RXICMP_ERR_FRMS_REG_OFFSET,13);
+                #else
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXICMP_ERR_FRMS_REG_OFFSET,\
+                pMmcReg->mmcRegVal);
+                #endif
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_OCTETS_G:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_GD_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);               
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_HDRERR_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_FRAG_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_OCTECTS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV6_OCTETS_G:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_GD_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);     
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_HDRERR_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_IPV6_NOPAY_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+ 
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_UDP_OCTETS_G:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_GD_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_UDP_ERR_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_RXUDP_ERR_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_TCP_OCTETS_G:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TCP_GD_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_TCP_ERR_OCTETS:
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_TCP_ERR_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_ICMP_OCTETS_G:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_ICMP_GD_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+                
+                break;            
+
+            case TMHW_LIPP6100ETH_RX_ICMP_ERR_OCTETS:
+
+                MMC_RST_ON_RD_SAVE(pRegs,regVal);
+                TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_MMC_ICMP_ERR_OCTETS_REG_OFFSET,\
+                    pMmcReg->mmcRegVal);
+                MMC_RST_ON_RD_RESTORE(pRegs,regVal);                
+
+                break;            
+
+            default:
+                break;
+
+        }
+
+    }
+
+    return(TM_OK);
+
+}
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_VLAN)
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetVLANTag
+**
+** DESCRIPTION: This function sets the VLAN tag value which is used for comparison with the
+**                     received VLAN frames.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetVLANTag (
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    regValue &=TMVH_LIPP6100ETH_VLANTAG_MASK;
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_VLANTAG_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_GetVLANTag
+**
+** DESCRIPTION: This function returns the VLAN tag value 
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetVLANTag (
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_VLANTAG_REG_OFFSET,*pRegValue);    
+    
+    *pRegValue &=TMVH_LIPP6100ETH_VLANTAG_MASK;
+
+    return(TM_OK);
+}
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_GetTsCtrlVal
+**
+** DESCRIPTION: This function returns the control value of the time stamp registers.
+**
+**                         Below macros can be used to check if a corresponding bit is set/reset in 
+**                         the register: 
+**                          TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+**
+** RETURN :           TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetTsCtrlVal(
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(pRegs+TMVH_LIPP6100ETH_TS_CTRL_REG_OFFSET,*pRegValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:     tmhwLIPP6100Eth_SetTsCtrl
+**
+** DESCRIPTION: This function enables/disables certain features of time stamp operation,
+**                         depending on the value passed.
+**
+**                         Parameter to this function can be any of the below macros
+**
+**                          TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+**                          TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsCtrl(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+    )
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_CTRL_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsSubSecInc
+**
+** DESCRIPTION:  API to set the value of sub-second increment register
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsSubSecInc(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+)
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_SUB_SECOND_INCR_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsAddend
+**
+** DESCRIPTION:  This API is used to set Time Stamp Addend value. This is used only when system 
+**                          time is configured for Fine Update mode.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsAddend(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                       regValue
+)
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_ADDEND_REG_OFFSET,regValue);    
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_GetSysTs
+**
+** DESCRIPTION:  This API fetches the current system time stamp value
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSysTs(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+)
+{
+
+    UInt32 regBase;
+
+    regBase = GET_BASE(ethUnitId);
+
+    TMVH_GEN_READ(regBase+TMVH_LIPP6100ETH_TS_HIGH_REG_OFFSET,pRegs->highVal);    
+    TMVH_GEN_READ(regBase+TMVH_LIPP6100ETH_TS_LOW_REG_OFFSET,pRegs->lowVal);        
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsUpdate
+**
+** DESCRIPTION:  This API is used to set the values of Time Stamp update registers & the parameter
+**                          passed to this function also indicates if the value is to be added to the system time
+**                          or subracted from the system time.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsUpdate(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsUpdateReg_t pUpdate   
+)
+{
+
+    UInt32 pRegs;
+
+    pRegs = GET_BASE(ethUnitId);
+
+    if(pUpdate->addSub == tmhwLIPP6100Eth_SubFromSysTime)
+    {
+        /*  Subtract this value from system time */    
+        pUpdate->updateReg.lowVal |= TMVH_LIPP6100ETH_TS_LOW_UPDATE_PSNT_VAL;
+    }
+    else
+    {
+        /* Add this value to system time */
+        pUpdate->updateReg.lowVal &= (~TMVH_LIPP6100ETH_TS_LOW_UPDATE_PSNT_VAL);            
+    }
+
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_HIGH_UPDATE_REG_OFFSET, \
+                                        pUpdate->updateReg.highVal);    
+    TMVH_GEN_WRITE(pRegs+TMVH_LIPP6100ETH_TS_LOW_UPDATE_REG_OFFSET, \
+                                        pUpdate->updateReg.lowVal);        
+
+    return(TM_OK);
+
+}
+
+/*-----------------------------------------------------------------------------
+** FUNCTION:    tmhwLIPP6100Eth_SetTsTgtTime
+**
+** DESCRIPTION:  This API is used to schedule an interrupt event when the system time exceeds the
+**                          value programmed in the target registers.
+**
+** RETURN:        TM_OK 
+**
+** NOTES:       
+**-----------------------------------------------------------------------------
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsTgtTime(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+)
+{
+
+    UInt32 regBase;
+
+    regBase = GET_BASE(ethUnitId);
+
+    TMVH_GEN_WRITE(regBase+TMVH_LIPP6100ETH_TS_TGT_TIME_HIGH_REG_OFFSET, \
+                                        pRegs->highVal);    
+    TMVH_GEN_WRITE(regBase+TMVH_LIPP6100ETH_TS_TGT_TIME_LOW_REG_OFFSET, \
+                                        pRegs->lowVal);        
+
+    return(TM_OK);
+
+}
+#endif /* End of timestamp routines */
+
+
+#if (  TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC) 
+
+     #if ( IPVERSION_34_1_A)
+
+UInt32  compute_ipc_value (UInt32 base,UInt32 regOffset,UInt32 index)
+{
+        UInt32 temp, org;
+        UInt32 sum;
+        UInt32 regVal;
+
+        /* Read the control & set clear on read */
+        TMVH_GEN_READ(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,org);
+
+        temp = org;
+
+        if((org & TMVH_LIPP6100ETH_MMC_CTRL_STOP_ROLLOVER_VAL) &&
+            ( (org & TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL)==0))
+        {
+
+            if(org & TMVH_LIPP6100ETH_MMC_CTRL_CNTR_FREZ_VAL)
+            {
+                return(gtmhwLIPP6100Eth_ActRegVal[index]);
+            }
+
+            /* Enable read clear */
+            temp |= TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL;
+
+            TMVH_GEN_WRITE(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,temp); 
+
+            TMVH_GEN_READ(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,temp);
+
+            /* If you are reading after previously returning all Fs, reset the value to zero */            
+            if(gtmhwLIPP6100Eth_ActRegVal[index] == 0xFFFFFFFF)        
+            {
+                gtmhwLIPP6100Eth_ActRegVal[index] = 0;
+            }
+
+            /* Read the IPC counter value */        
+            TMVH_GEN_READ(base+regOffset,regVal);                
+
+            sum = gtmhwLIPP6100Eth_ActRegVal[index] + regVal;
+
+            /* Over flow case */
+            if(sum < regVal)
+            {
+                /* On overflow, return all Fs */
+                gtmhwLIPP6100Eth_ActRegVal[index] = 0xFFFFFFFF;                    
+            }
+            else
+            {
+                /* Accumulate into a variable... until it overflows */
+                gtmhwLIPP6100Eth_ActRegVal[index] += regVal;
+            }
+
+            /* Actual value to be returned */
+            regVal = gtmhwLIPP6100Eth_ActRegVal[index];
+
+            /* Restore the register settings */                
+            TMVH_GEN_WRITE(base+TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET,org);
+
+
+        }
+        else
+        {
+            /* When rollover disable is not set */
+            TMVH_GEN_READ(base+regOffset,regVal);       
+            
+            /* Store the value for returning, when freeze =1 */            
+             gtmhwLIPP6100Eth_ActRegVal[index] = regVal;
+        }
+
+        return(regVal);        
+
+
+}
+     #endif
+
+#endif /* __IPVERSION_34_1_A__ */
+
+
diff --git a/drivers/net/lipp_6300eth/tmhwLIPP6100Eth.h b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth.h
new file mode 100644
index 0000000..35234ef
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth.h
@@ -0,0 +1,3092 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth.h %
+ * %pid_version:          1.5                  %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  Configuration header file for Ethernet HwApi Driver
+ *
+ * DOCUMENT REF: Synopsys DesignWare Cores Ethernet MAC Universal Databook 
+ *                         Version 3.30a, March 22nd 2007 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef  TMHWLIPP6100ETH_H
+#define  TMHWLIPP6100ETH_H
+
+/*-----------------------------------------------------------------------------
+* Standard include files:
+*-----------------------------------------------------------------------------
+*/
+
+#include "tmNxTypes.h"      /*! This is a standard type definition file for NxHome.*/
+#include "tmNxCompId.h"    /*! This file registers all the component IDs as defined in NxHome.*/
+#include "tmNxModId.h"
+#include "tmhwLIPP6100Eth_Cfg.h" /*! Configuration header file */
+
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif  /* defined(__cplusplus) */
+
+/*-----------------------------------------------------------------------------
+** Error Codes :
+**-----------------------------------------------------------------------------
+*/
+
+#define TMHW_LIPP6100ETH_COMPATIBILITY_NR (1)
+/*! \def TMHW_LIPP6100ETH_COMPATIBILITY_NR
+*     Compatability number         
+*/
+
+#define TMHW_LIPP6100ETH_MAJOR_VERSION_NR (1)
+/*! \def TMHW_LIPP6100ETH_MAJOR_VERSION_NR
+*     Major version Number         
+*/
+
+#define TMHW_LIPP6100ETH_MINOR_VERSION_NR (0)
+/*! \def TMHW_LIPP6100ETH_MINOR_VERSION_NR
+*     Minor Version Number         
+*/
+
+#define TMHW_ERR_LIPP6100ETH_BASE         (CID_LIPP6100ETH | CID_LAYER_HWAPI)
+#define TMHW_ERR_LIPP6100ETH_COMP        (CID_LIPP6100ETH | CID_LAYER_HWAPI | \
+                                                                                TM_ERR_COMP_UNIQUE_START)
+
+/*! \def TMHW_ERR_LIPP6100ETH_COMP
+*    This error code is the initial offset from which other error codes are based.
+*/
+
+#define TMHW_ERR_LIPP6100ETH_NOT_SUPPORTED  (TMHW_ERR_LIPP6100ETH_BASE+TM_ERR_NOT_SUPPORTED)
+
+/*! \def TMHW_ERR_LIPP6100ETH_NOT_SUPPORTED
+*    This error code is returned if the feature is not supported by Ethernet hardware.
+*/
+
+/* Interrupt identification flags */
+
+/*! \brief Typedef for interrupt mask value */
+typedef  UInt32  tmhwLIPP6100Eth_IntMask_t,*ptmhwLIPP6100Eth_IntMask_t;
+
+/*! \brief Typedef for interrupt status value */
+typedef  UInt32  tmhwLIPP6100Eth_IntStatus_t,  *ptmhwLIPP6100Eth_IntStatus_t;
+
+/*! \brief Typedef for status value */
+typedef  UInt32  tmhwLIPP6100Eth_StatusMask_t,*ptmhwLIPP6100Eth_StatusMask_t;
+
+
+/*-----------------------------------------------------------------------------
+** Interrupt Macros :
+**-----------------------------------------------------------------------------
+*/
+
+/**
+ * \defgroup group0 Basic Operations
+ */
+/*\{*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_NIE_EN_VAL
+*   Macro to enable Normal Interrupt Summary Interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_AIE_EN_VAL
+*      Macro to enable Abnormal Interrupt Summary Interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_ERE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_ERE_EN_VAL
+*    Macro to enable Early Receive Interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_FBE_EN_VAL
+*    Macro to enable Fatal Bus Error interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_ETE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_ETE_EN_VAL
+* Macro to enable Early Transmit interrupt  
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_INT_RWE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RWE_EN_VAL
+*Macro to enable Watchdog Timeout interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_RSE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RSE_EN_VAL
+*Macro to enable Receive Stopped interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_RUE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RUE_EN_VAL
+* Macro to enable Receive Buffer Unavailable interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_RIE_EN_VAL
+* Macro to enable Receive Interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_INT_UNE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_UNE_EN_VAL
+* Macro to enable Underflow interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_OVE_EN_VAL
+*Macro to enable Overflow interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TJE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TJE_EN_VAL
+* Macro to enable Transmit Jabber Timeout interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TUE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TUE_EN_VAL
+* Macro to enable Transmit Buffer Unavailable interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TSE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TSE_EN_VAL
+* Macro to enable Transmit Stopped interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_DMA_INT_TIE_EN_VAL
+* Macro to enable Transmit Interrupt  
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PCS_AN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_INTR_PCS_AN_VAL
+* Macro to enable/disable interrupt generation due to auto negotiation completion event
+*/
+
+#define TMHW_LIPP6100ETH_INTR_LNKSTAT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_INTR_LNKSTAT_VAL
+* Macro to enable/disable interrupt generation due to change in link status event
+*/
+
+#define TMHW_LIPP6100ETH_INTR_RGMII_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_INTR_RGMII_VAL
+* Macro to enable/disable interrupt generation due to the setting of RGMII status bit
+*/
+
+/* DMA status register macros. Some are Read Only & Some are Read Clear */
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_GPI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x10000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_GPI_VAL
+* Macro to check if the cause of the interrupt is due to the Power Management Unit
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_GMI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x8000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_GMI_VAL
+* Macro to check if the cause of the interrupt is due to MMC unit 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_GLI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_GLI_VAL
+* Macro to check if the cause of the interrupt is due to PCS interface block  
+*/
+
+/* The below bits are valid only when the fatal bus error interrupt is set */
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EB_MSK ((tmhwLIPP6100Eth_StatusMask_t)0x3800000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EB_MSK
+* Mask to extract the Error bits 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EBTX_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EBTX_VAL
+* Macro to check if the Error is due to data transfer by TxDMA 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EBRD_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EBRD_VAL
+* Macro to check if there is an Error during read transfer 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_EBDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2000000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_EBDESC_VAL
+* Macro to check if there is an Error during descriptor access 
+*/
+
+/* DMA Transmit process status */
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_MSK ((tmhwLIPP6100Eth_StatusMask_t)0x700000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_MSK
+* DMA Transmit process state mask  
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_TXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_TXDESC_VAL
+* DMA state is running and it is Fetching Transmit Transfer Descriptor   
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_TXSTAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_TXSTAT_VAL
+* DMA state is running and it is  Waiting for status   
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_RDDAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x300000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_RDDAT_VAL
+* DMA state is running: It is  Reading data from host memory buffer and queuing 
+* it to transmit buffer (TX FIFO)  
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_SUSP_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x600000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_SUSP_VAL
+* DMA state is Suspended: Transmit Descriptor Unavailable or Transmit Buffer Underflow 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TS_CTXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x700000)  
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TS_CTXDESC_VAL
+* DMA is running: Closing Transmit Descriptor
+*/
+
+/* Receive process status 
+**
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_MSK ((tmhwLIPP6100Eth_StatusMask_t)0xE0000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_MSK
+* Receive process state mask
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_RXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_RXDESC_VAL
+* DMA state is Running: Fetching Receive Transfer Descriptor 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_WTRX_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x60000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_WTRX_VAL
+* DMA state is Running: Waiting for receive packet
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_NO_RXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_NO_RXDESC_VAL
+ * DMA state is Suspended: No Rx Descriptor available 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_CLOSE_RXDESC_VAL ((tmhwLIPP6100Eth_StatusMask_t)0xA0000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_CLOSE_RXDESC_VAL
+* DMA state is Running: Closing receive descriptor 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RS_TXFRDATA_VAL ((tmhwLIPP6100Eth_StatusMask_t)0xE0000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RS_TXFRDATA_VAL
+* DMA state is Running: Transferring the receive packet data from receive 
+* buffer to host memory
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_NIS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_NIS_VAL
+*  Normal Interrupt Summary status. To clear this bit, write a 1 to this bit position
+*  after clearing the cause of NIS interrupt
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_AIS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_AIS_VAL
+*  Abnormal Interrupt Summary 
+*/
+
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_ERI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_ERI_VAL
+*  Early Receive Interrupt macro which  indicates that the DMA had 
+*  filled the first data buffer of the packet.
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_FBI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_FBI_VAL
+* Macro to indicate that a Bus Error occurred.  
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_ETI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_ETI_VAL
+* Early Transmit Interrupt : This macro indicates that the frame 
+* to be transmitted was fully transferred to the MTL Transmit FIFO 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RWT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RWT_VAL
+* Receive Watchdog Timeout indicates a frame with a length greater than 
+* 2048 bytes was received 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RPS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RPS_VAL
+* Receive Process Stopped: Receive process has entered the stopped state
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RU_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RU_VAL
+*    Receive Buffer Unavailable indicates the next descriptor is owned by host. 
+*    DMA enters suspended state 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_RI_VAL
+*     Receive Interrupt indicates completion of frame reception 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_UNF_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_UNF_VAL
+*     Transmit Underflow: Transmit buffer had an underflow during transmission 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_OVF_VAL
+*     Receive Overflow: There was an overflow during frame reception 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TJT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TJT_VAL
+*     Transmit Jabber Timeout: The transmitter has been excessively active 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TU_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TU_VAL
+*     Transmit Buffer Unavailable: The next descriptor in the transmit list is 
+*     owned by host and cannot be acquired by DMA 
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TPS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TPS_VAL
+*     Macro indicates Transmit Process is in Stopped state
+*/
+
+#define TMHW_LIPP6100ETH_DMA_STATUS_TI_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_DMA_STATUS_TI_VAL
+*     Transmit Interrupt: Status to indicate frame transmission is complete
+*/
+
+
+#define TMHW_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL
+* Macro for checking the FCB/BPA bit status
+*/
+
+/* Additional macros to check the status */
+#define TMHW_LIPP6100ETH_INTR_PCS_AN_STAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_INTR_PCS_AN_STAT_VAL
+* Macro for checking the staus of auto negotiation completion in TBI/RTBI/SGMII PHY interface
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PCS_LS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_INTR_PCS_LS_VAL
+* Macro for checking the change in the link staus in the TBI/RTBI/SGMII PHY interface
+*/
+
+#define TMHW_LIPP6100ETH_INTR_RGMII_STAT_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_INTR_RGMII_STAT_VAL
+* Macro for checking the change in the link status for RGMII PHY interface
+*/
+
+/*\}*/ /* Group0 definition end */
+
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+
+/*
+*  MAC management Interrupt status values. All the bits are clear on read 
+*  Receive interrupt register macros 
+*/
+
+/**
+ * \defgroup group3 MAC Management Counters
+ */
+/*\{*/
+
+#define TMHW_LIPP6100ETH_INTR_MMC_STAT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000000)
+/*! \def TMHW_LIPP6100ETH_INTR_MMC_STAT_VAL
+* Macro to check if the interrupt is due to MMC unit
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_WD_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_WD_VAL
+* Macro to check if the interrupt is due to watchdog error counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_VLANGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_VLANGB_VAL
+* Macro to check if  the interrupt is due to rxvlanframes_gb counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OVERFLOW_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OVERFLOW_VAL
+* Macro to check if  the interrupt is due to rxfifooverflow counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_PAUSE_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_PAUSE_VAL
+* Macro to check if  the interrupt is due to rxpauseframes counter reaching 
+* half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OUTOFR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OUTOFR_VAL
+* Macro to check if  the interrupt is due to rxoutofrange counter reaching 
+* half the maximum value 
+*/
+
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_LEN_ERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_LEN_ERR_VAL
+* Macro to check if  the interrupt is due to rxlengtherror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_UNICASTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_UNICASTGB_VAL
+* Macro to check if  the interrupt is due to rxunicastframes_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_1024TOMAXGB_VAL
+* Macro to check if  the interrupt is due to rx1024tomaxoctects_gb counter reaching 
+* half the maximum value  
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_512TO1023GB_VAL
+* Macro to check if  the interrupt is due to rx512to1023octects_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_256TO511GB_VAL
+* Macro to check if  the interrupt is due to rx256to511octects_gb counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_128TO255GB_VAL
+* Macro to check if  the interrupt is due to rx128to255octects_gb counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_65TO127GB_VAL
+* Macro to check if  the interrupt is due to rx65to127octects_gb counter 
+* reaching half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_64GB_VAL
+* Macro to check if  the interrupt is due to rx64octects_gb counter 
+* reaching half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OVERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OVERSIZEG_VAL
+* Macro to check if  the interrupt is due to rxoversize_g counter reaching 
+* half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_UNDERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_UNDERSIZEG_VAL
+* Macro to check if  the interrupt is due to rxundersize_g counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_JABBER_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_JABBER_VAL
+* Macro to check if  the interrupt is due to rxjabbererror counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_RUNTERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_RUNTERR_VAL
+* Macro to check if  the interrupt is due to rxrunterror counter reaching half the 
+* maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_ALIGN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_ALIGN_VAL
+* Macro to check if  the interrupt is due to rxalignmenterror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_CRC_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_CRC_VAL
+* Macro to check if  the interrupt is due to rxcrcerror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_MULTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_MULTG_VAL
+* Macro to check if  the interrupt is due to rxmulticastframes_g counter 
+* reaching half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_BDCSTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_BDCSTG_VAL
+* Macro to check if  the interrupt is due to rxbroadcastframes_g  counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTG_VAL
+* Macro to check if  the interrupt is due to rxoctetcount_g counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_OCTCNTGB_VAL
+* Macro to check if  the interrupt is due to rxoctetcount_gb counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RX_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RX_FRMCNTGB_VAL
+* Macro to check if  the interrupt is due to rxframecount_gb counter reaching 
+* half the maximum value
+*/
+
+/* Checksum offload interrupt status register macros. Register is clear on read */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERROCT_VAL
+* Macro to check if  the interrupt is due to rxicmp_err_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000000) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxicmp_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERROCT_VAL
+* Macro to check if  the interrupt is due to rxtcp_err_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000000 ) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxtcp_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERROCT_VAL
+* Macro to check if  the interrupt is due to rxudp_err_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxudp_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAYOCT_VAL
+* Macro to check if  the interrupt is due to rxipv6_nopay_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERROCT_VAL
+* Macro to check if  the interrupt is due to rxipv6_hdrerr_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxipv6_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDISOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDISOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_udsbl_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAGOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAGOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_frag_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAYOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_nopay_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERROCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_hdrerr_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GDOCT_VAL
+* Macro to check if  the interrupt is due to rxipv4_gd_octets counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_ERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxicmp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXICMP_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxicmp_gd_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_ERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxtcp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXTCP_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxtcp_gd_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_ERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxudp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXUDP_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxudp_err_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_NOPAY_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv6_nopay_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_HDRERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv6_hdrerr_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV6_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv6_gd_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDIS_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_UDPDIS_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_udsbl_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAG_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_FRAG_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_frag_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_NOPAY_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_nopay_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_HDRERR_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_hdrerr_frms counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXIPV4_GD_FRMS_VAL
+* Macro to check if  the interrupt is due to rxipv4_gd_frms counter reaching 
+* half the maximum value
+*/
+
+
+/* MMC Transmit interrupt register status macros */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_VLANG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_VLANG_VAL
+* Macro to check if  the interrupt is due to txvlanframes_g counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_PAUSEERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_PAUSEERR_VAL
+* Macro to check if  the interrupt is due to txpauseframes error counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_EXSDEF_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_EXSDEF_VAL
+* Macro to check if  the interrupt is due to txoexcessdef  counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTG_VAL
+* Macro to check if  the interrupt is due to txframecount_g  counter reaching 
+* half the maximum value
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTG_VAL
+* Macro to check if  the interrupt is due to txoctectcount_g   counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_CARERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_CARERR_VAL
+* Macro to check if  the interrupt is due to txcarriererror counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_EXSCOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_EXSCOL_VAL
+* Macro to check if  the interrupt is due to txexcesscol counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_LATECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_LATECOL_VAL
+* Macro to check if  the interrupt is due to txlatecol counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_DEFCNT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_DEFCNT_VAL
+* Macro to check if  the interrupt is due to txdeferred counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_MULTICOLG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_MULTICOLG_VAL
+* Macro to check if  the interrupt is due to txmulticol_g counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_SINGLECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_SINGLECOL_VAL
+* Macro to check if  the interrupt is due to txsinglecol_g counter reaching half 
+* the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_UNFLWERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_UNFLWERR_VAL
+* Macro to check if  the interrupt is due to txunderflowerror counter 
+* reaching half the maximum value  
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_BRDCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_BRDCSTFMGB_VAL
+* Macro to check if  the interrupt is due to txbroadcastframes_gb counter reaching 
+* half the maximum value
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFMGB_VAL
+* Macro to check if  the interrupt is due to txmulticastframes_gb counter 
+* reaching half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_UNICSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_UNICSTFMGB_VAL
+* Macro to check if  the interrupt is due to txunicastframes_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_1024TOMAXGB_VAL
+* Macro to check if  the interrupt is due to tx1024tomaxoctects_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_512TO1023GB_VAL
+* Macro to check if  the interrupt is due to tx512to1023octects_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_256TO511GB_VAL
+* Macro to check if  the interrupt is due to tx256to511octects_gb counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_128TO255GB_VAL
+* Macro to check if  the interrupt is due to tx128to255octects_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_65TO127GB_VAL
+* Macro to check if  the interrupt is due to tx65to127octects_gb counter reaching 
+* half the maximum value 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_64GB_VAL
+* Macro to check if  the interrupt is due to tx64to127octects_gb counter reaching 
+* half the maximum value   
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_MULTCSTFRMG_VAL
+* Macro to check if  the interrupt is due to txmulticastframes_g counter reaching 
+* half the maximum value   
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_BDCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_BDCSTFRMG_VAL
+* Macro to check if  the interrupt is due to txbroadcastframes_g counter reaching 
+* half the maximum value   
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_FRMCNTGB_VAL
+* Macro to check if  the interrupt is due to txframecount_gb counter reaching
+* half the maximum value   
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TX_OCTCNTGB_VAL
+* Macro to check if  the interrupt is due to txoctectcount_gb counter reaching 
+* half the maximum value 
+*/
+
+
+/* MMC bit masks to disable interrupts in Rx Directon */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_WD_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_WD_VAL
+* Macro to mask the  generation of rxwatchdog interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_VLANGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_VLANGB_VAL
+* Macro to mask the  generation of rxvlanframes_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERFLOW_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERFLOW_VAL
+* Macro to mask the  generation of rxfifooverflow interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_PAUSE_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_PAUSE_VAL
+* Macro to mask the  generation of rxpauseframes interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OUTOFR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OUTOFR_VAL
+* Macro to mask the  generation of  rxoutofrange interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_LEN_ERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_LEN_ERR_VAL
+* Macro to mask the  generation of rxlengtherror interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNICASTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNICASTGB_VAL
+* Macro to mask the  generation of rxunicastframes_gb interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_1024TOMAXGB_VAL
+* Macro to mask the  generation of rx1024tomaxoctects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_512TO1023GB_VAL
+* Macro to mask the  generation of rx512to1023octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_256TO511GB_VAL
+* Macro to mask the  generation of rx256to511octects_gb interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_128TO255GB_VAL
+* Macro to mask the  generation of rx128to255octects_gb interrupt 
+*/
+
+/* Macro to mask the  generation of rx65to127octects_gb interrupt */
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_65TO127GB_VAL
+* Macro to check if  the interrupt is due to rxcrcerror counter reaching 
+* half the maximum value 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_64GB_VAL
+* Macro to mask the  generation of rx64octects_gb interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OVERSIZEG_VAL
+* Macro to mask the  generation of rxoversize_g interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNDERSIZEG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_UNDERSIZEG_VAL
+* Macro to mask the  generation of rxundersize_g interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_JABBER_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_JABBER_VAL
+* Macro to mask the  generation of rxjabbererror  interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_RUNTERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_RUNTERR_VAL
+* Macro to mask the  generation of rxrunterror interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_ALIGN_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_ALIGN_VAL
+* Macro to mask the  generation of rxalignmenterror interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_CRC_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_CRC_VAL
+* Macro to mask the  generation of  rxcrcerror interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_MULTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_MULTG_VAL
+* Macro to mask the  generation of rxmulticastframes_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_BDCSTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_BDCSTG_VAL
+* Macro to mask the  generation of rxbroadcastframes_g interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTG_VAL
+* Macro to mask the  generation of rxoctetcount_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_OCTCNTGB_VAL
+* Macro to mask the  generation of rxoctetcount_gb interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_RXMASK_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_RXMASK_FRMCNTGB_VAL
+* Macro to mask the  generation of rxframecount_gb interrupt 
+*/
+
+/* MMC Transmit interrupt mask register bits */
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_VLANG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_VLANG_VAL
+* Macro to mask the  generation of  txvlanframes_g interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_PAUSEERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_PAUSEERR_VAL
+* Macro to mask the  generation of  txpauseframes interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSDEF_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSDEF_VAL
+* Macro to mask the  generation of  txoexcessdef interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTG_VAL
+* Macro to mask the  generation of  txframecount_g   interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTG_VAL
+* Macro to mask the  generation of  txoctectcount_g  interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_CARERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_CARERR_VAL
+* Macro to mask the  generation of  txcarriererror interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSCOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_EXSCOL_VAL
+* Macro to mask the  generation of  txexcesscol interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_LATECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_LATECOL_VAL
+* Macro to mask the  generation of  txlatecol interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_DEFCNT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_DEFCNT_VAL
+* Macro to mask the  generation of  txdeferred interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTICOLG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTICOLG_VAL
+* Macro to mask the  generation of  txmulticol_g interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_SINGLECOL_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_SINGLECOL_VAL
+* Macro to mask the  generation of txsinglecol_g   interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNFLWERR_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNFLWERR_VAL
+* Macro to mask the  generation of  txunderflowerror interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BRDCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BRDCSTFMGB_VAL
+* Macro to mask the  generation of  txbroadcastframes_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFMGB_VAL
+* Macro to mask the  generation of  txmulticastframes_gb interrupt 
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNICSTFMGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_UNICSTFMGB_VAL
+* Macro to mask the  generation of  txunicastframes_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_1024TOMAXGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_1024TOMAXGB_VAL
+* Macro to mask the  generation of  tx1024tomaxoctects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_512TO1023GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_512TO1023GB_VAL
+* Macro to mask the  generation of  tx512to1023octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_256TO511GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_256TO511GB_VAL
+* Macro to mask the  generation of  tx256to511octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_128TO255GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_128TO255GB_VAL
+* Macro to mask the  generation of  tx128to255octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_65TO127GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_65TO127GB_VAL
+* Macro to mask the  generation of  tx65to127octects_gb interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_64GB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_64GB_VAL
+* Macro to mask the  generation of  tx64to127octects_gb interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_MULTCSTFRMG_VAL
+* Macro to mask the  generation of  txmulticastframes_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BDCSTFRMG_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_BDCSTFRMG_VAL
+* Macro to mask the  generation of  txbroadcastframes_g interrupt
+*/
+
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_FRMCNTGB_VAL
+*Macro to mask the  generation of  txframecount_gb interrupt 
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTGB_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_TXMASK_OCTCNTGB_VAL
+* Macro to mask the  generation of  txoctectcount_gb interrupt
+*/
+
+/* Mask to disable generation of interrupts due to ipv4, ipv6, tcp/udp/icmp counters reaching half 
+** the maximum value
+*/    
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERROCT_VAL
+* Macro to mask the  generation of  rxicmp_err_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000000) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GDOCT_VAL
+* Macro to mask the  generation of  rxicmp_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERROCT_VAL
+* Macro to mask the  generation of  rxtcp_err_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4000000 ) 
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GDOCT_VAL
+* Macro to mask the  generation of  rxtcp_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERROCT_VAL
+* Macro to mask the  generation of  rxudp_err_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000000)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GDOCT_VAL
+* Macro to mask the  generation of  rxudp_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAYOCT_VAL
+* Macro to mask the  generation of  rxipv6_nopay_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERROCT_VAL
+* Macro to mask the  generation of  rxipv6_hdrerr_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GDOCT_VAL
+* Macro to mask the  generation of  rxipv6_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDISOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDISOCT_VAL
+* Macro to mask the  generation of  rxipv4_udsbl_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAGOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAGOCT_VAL
+* Macro to mask the  generation of  rxipv4_frag_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAYOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAYOCT_VAL
+* Macro to mask the  generation of  rxipv4_nopay_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERROCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERROCT_VAL
+* Macro to mask the  generation of  rxipv4_hdrerr_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GDOCT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GDOCT_VAL
+* Macro to mask the  generation of  rxipv4_gd_octets interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_ERR_FRMS_VAL
+* Macro to mask the  generation of  rxicmp_err_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1000 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXICMP_GD_FRMS_VAL
+* Macro to mask the  generation of  rxicmp_gd_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x800 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_ERR_FRMS_VAL
+* Macro to mask the  generation of  rxtcp_err_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x400 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXTCP_GD_FRMS_VAL
+* Macro to mask the  generation of  rxtcp_gd_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_ERR_FRMS_VAL
+* Macro to mask the  generation of  rxudp_err_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x100 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXUDP_GD_FRMS_VAL
+* Macro to mask the  generation of  rxudp_gd_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x80 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_NOPAY_FRMS_VAL
+* Macro to mask the  generation of  rxipv6_nopay_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x40 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_HDRERR_FRMS_VAL
+* Macro to mask the  generation of  rxipv6_hdrerr_frms counter interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x20 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV6_GD_FRMS_VAL
+* Macro to mask the  generation of  rxipv6_hdrerr_frms counter interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDIS_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x10 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_UDPDIS_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_udsbl_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAG_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_FRAG_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_frag_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAY_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x4 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_NOPAY_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_nopay_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERR_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x2 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_HDRERR_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_hdrerr_frms interrupt
+*/
+
+#define TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GD_FRMS_VAL ((tmhwLIPP6100Eth_IntMask_t)0x1 )
+/*! \def TMHW_LIPP6100ETH_MMC_INTR_MSKRXIPV4_GD_FRMS_VAL
+* Macro to mask the  generation of  rxipv4_gd_frms interrupt
+*/
+
+/* Macros to read various MAC management counters */
+
+#define TMHW_LIPP6100ETH_TX_OCTET_CNT_GB (0U)
+/*! \def TMHW_LIPP6100ETH_TX_OCTET_CNT_GB
+* Macro used to read the txoctetcount_gb counter
+*/
+
+
+#define TMHW_LIPP6100ETH_TX_FRAME_CNT_GB (1U)
+/*! \def TMHW_LIPP6100ETH_TX_FRAME_CNT_GB
+* Macro used to read the txframecount_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_BRDCST_CNT_G (2U)
+/*! \def TMHW_LIPP6100ETH_TX_BRDCST_CNT_G
+* Macro used to read the txbroadcastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_MULTCST_CNT_G (3U)
+/*! \def TMHW_LIPP6100ETH_TX_MULTCST_CNT_G
+* Macro used to read the txmulticastframes_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_64_CNT_GB (4U)
+/*! \def TMHW_LIPP6100ETH_TX_64_CNT_GB
+* Macro used to read the tx64octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_65TO127_CNT_GB (5U)
+/*! \def TMHW_LIPP6100ETH_TX_65TO127_CNT_GB
+* Macro used to read the tx65to127octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_128TO255_CNT_GB (6U)
+/*! \def TMHW_LIPP6100ETH_TX_128TO255_CNT_GB
+* Macro used to read the tx128to255octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_256TO511_CNT_GB (7U)
+/*! \def TMHW_LIPP6100ETH_TX_256TO511_CNT_GB
+* Macro used to read the tx256to511octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_512TO1023_CNT_GB (8U)
+/*! \def TMHW_LIPP6100ETH_TX_512TO1023_CNT_GB
+* Macro used to read the tx512to1023octets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_1024TOMAX_CNT_GB (9U)
+/*! \def TMHW_LIPP6100ETH_TX_1024TOMAX_CNT_GB
+* Macro used to read the tx1024tomaxoctets_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_UNICAST_CNT_GB (10U)
+/*! \def TMHW_LIPP6100ETH_TX_UNICAST_CNT_GB
+* Macro used to read the txunicastframes_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_MULTCST_CNT_GB (11U)
+/*! \def TMHW_LIPP6100ETH_TX_MULTCST_CNT_GB
+*  Macro used to read the txmulticastcastframes_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_BRDCST_CNT_GB (12U)
+/*! \def TMHW_LIPP6100ETH_TX_BRDCST_CNT_GB
+* Macro used by MMC API to read the txbroadcastframes_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_UNDERFLOW_ERR_CNT (13U)
+/*! \def TMHW_LIPP6100ETH_TX_UNDERFLOW_ERR_CNT
+* Macro used by MMC API to read the txunderflowerror counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_SINGLE_COL_CNT_G (14U)
+/*! \def TMHW_LIPP6100ETH_TX_SINGLE_COL_CNT_G
+* Macro used by MMC API to read the txsinglecol_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_MULTICOL_COL_G (15U)
+/*! \def TMHW_LIPP6100ETH_TX_MULTICOL_COL_G
+* Macro used by MMC API to read the txmulticol_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_DEFERRED_CNT (16U)
+/*! \def TMHW_LIPP6100ETH_TX_DEFERRED_CNT
+* Macro used by MMC API to read the txdeferred counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_LATECOL_CNT (17U)
+/*! \def TMHW_LIPP6100ETH_TX_LATECOL_CNT
+* Macro used by MMC API to read txlatecol counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_EXCESSCOL_CNT (18U)
+/*! \def TMHW_LIPP6100ETH_TX_EXCESSCOL_CNT
+* Macro used by MMC API to read txexcesscol counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_CARRIER_ERR_CNT (19U)
+/*! \def TMHW_LIPP6100ETH_TX_CARRIER_ERR_CNT
+* Macro used by MMC API to read txcarriererror counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_OCTET_CNT_G (20U)
+/*! \def TMHW_LIPP6100ETH_TX_OCTET_CNT_G
+* Macro used by MMC API to read txoctetcount_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_FRAME_CNT_G (21U)
+/*! \def TMHW_LIPP6100ETH_TX_FRAME_CNT_G
+* Macro used by MMC API to read txframecount_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_EXCESSDEF_CNT (22U)
+/*! \def TMHW_LIPP6100ETH_TX_EXCESSDEF_CNT
+* Macro used by MMC API to read txexcessdef counter
+*/
+
+#define TMHW_LIPP6100ETH_TX_PAUSE_FRAMES_CNT (23U)
+/*! \def TMHW_LIPP6100ETH_TX_PAUSE_FRAMES_CNT
+* Macro used by MMC API to read txpauseframes counter 
+*/
+
+#define TMHW_LIPP6100ETH_TX_VLAN_FRAMES_CNT_G (24U)
+/*! \def TMHW_LIPP6100ETH_TX_VLAN_FRAMES_CNT_G
+* Macro used by MMC API to read txvlanframes_g counter 
+*/
+
+/* Receive frame statistics*/
+
+ #define TMHW_LIPP6100ETH_RX_FRM_CNT_GB (0U)
+/*! \def TMHW_LIPP6100ETH_RX_FRM_CNT_GB
+* Macro used by MMC API to read rxframecount_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_RX_OCTET_CNT_GB (1U)
+/*! \def TMHW_LIPP6100ETH_RX_OCTET_CNT_GB
+* Macro used by MMC API to read rxoctetcount_gb counter 
+*/
+
+#define TMHW_LIPP6100ETH_RX_OCTET_CNT_G (2U)
+/*! \def TMHW_LIPP6100ETH_RX_OCTET_CNT_G
+* Macro used by MMC API to read rxoctetcount_g counter 
+*/
+
+#define TMHW_LIPP6100ETH_RX_BRDCSTF_CNT_G (3U)
+/*! \def TMHW_LIPP6100ETH_RX_BRDCSTF_CNT_G
+* Macro used by MMC API to read rxbroadcastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_MULTCSTF_CNT_G (4U)
+/*! \def TMHW_LIPP6100ETH_RX_MULTCSTF_CNT_G
+* Macro used by MMC API to read rxmulticastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_CRC_ERR_CNT (5U)
+/*! \def TMHW_LIPP6100ETH_RX_CRC_ERR_CNT
+* Macro used by MMC API to read rxcrcerror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_ALIGNMT_ERR_CNT (6U)
+/*! \def TMHW_LIPP6100ETH_RX_ALIGNMT_ERR_CNT
+* Macro used by MMC API to read rxalignmenterror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_RUNT_ERR_CNT (7U)
+/*! \def TMHW_LIPP6100ETH_RX_RUNT_ERR_CNT
+* Macro used by MMC API to read rxrunterror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_JABBER_ERR_CNT (8U)
+/*! \def TMHW_LIPP6100ETH_RX_JABBER_ERR_CNT
+* Macro used by MMC API to read rxjabbererror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_UNDERSIZE_CNT_G (9U)
+/*! \def TMHW_LIPP6100ETH_RX_UNDERSIZE_CNT_G
+* Macro used by MMC API to read rxundersize_g counter
+*/
+
+
+#define TMHW_LIPP6100ETH_RX_OVERSIZE_CNT_G (10U)
+/*! \def TMHW_LIPP6100ETH_RX_OVERSIZE_CNT_G
+* Macro used by MMC API to read rxoversize_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_64_CNT_GB (11U)
+/*! \def TMHW_LIPP6100ETH_RX_64_CNT_GB
+* Macro used by MMC API to read rx64octets_gb counter
+*/
+
+
+
+#define TMHW_LIPP6100ETH_RX_65TO127_CNT_GB (12U)
+/*! \def TMHW_LIPP6100ETH_RX_65TO127_CNT_GB
+* Macro used by MMC API to read rx65to127octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_128TO255_CNT_GB (13U)
+/*! \def TMHW_LIPP6100ETH_RX_128TO255_CNT_GB
+* Macro used by MMC API to read rx128to255octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_256TO511_CNT_GB (14U)
+/*! \def TMHW_LIPP6100ETH_RX_256TO511_CNT_GB
+* Macro used by MMC API to read rx256to511octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_512TO1023_CNT_GB (15U)
+/*! \def TMHW_LIPP6100ETH_RX_512TO1023_CNT_GB
+* Macro used by MMC API to read rx512to1023octets_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_1024TOMAX_CNT_GB (16U)
+/*! \def TMHW_LIPP6100ETH_RX_1024TOMAX_CNT_GB
+* Macro used by MMC API to read rx1024tomaxoctets_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_UNICAST_CNT_G (17U)
+/*! \def TMHW_LIPP6100ETH_RX_UNICAST_CNT_G
+* Macro used by MMC API to read rxunicastframes_g counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_LEN_ERR_CNT (18U)
+/*! \def TMHW_LIPP6100ETH_RX_LEN_ERR_CNT
+* Macro used by MMC API to read rxlengtherror counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_OUTOFRANGE_CNT (19U)
+/*! \def TMHW_LIPP6100ETH_RX_OUTOFRANGE_CNT
+* Macro used by MMC API to read rxoutofrangetype counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_PAUSE_CNT (20U)
+/*! \def TMHW_LIPP6100ETH_RX_PAUSE_CNT
+* Macro used by MMC API to read rxpauseframes counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_FIFO_OVERFLOW_CNT (21U)
+/*! \def TMHW_LIPP6100ETH_RX_FIFO_OVERFLOW_CNT
+* Macro used by MMC API to read rxfifooverflow counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_VLAN_FRAMES_CNT_GB (22U)
+/*! \def TMHW_LIPP6100ETH_RX_VLAN_FRAMES_CNT_GB
+* Macro used by MMC API to read rxvlanframes_gb counter
+*/
+
+#define TMHW_LIPP6100ETH_RX_WATCHDOG_ERR_CNT (23U)
+/*! \def TMHW_LIPP6100ETH_RX_WATCHDOG_ERR_CNT
+* Macro used by MMC API to read rxwatchdogerror counter 
+*/
+
+/* Macros to read checksum offload counters on the receive side */
+
+#define TMHW_LIPP6100ETH_RX_IPV4_FRMCNT_G (24U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_FRMCNT_G
+* Macro used by MMC API to read number of ipv4 good frames received
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_FRMCNT (25U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_FRMCNT
+* Macro used by MMC API to read number ipv4 packets with header errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_FRMCNT (26U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_FRMCNT
+* Macro used by MMC API to read number of ipv4 frames without TCP/UDP/ICMP payloads
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_FRAG_FRMCNT (27U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_FRAG_FRMCNT
+* Macro used by MMC API to read number of good IPv4 datagrams with fragmentation
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_FRMCNT (28U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_FRMCNT
+* Macro used by MMC API to read number of UDP frames without checksum
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_FRMCNT_G (29U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_FRMCNT_G
+* Macro used by MMC API to read number of ipv6 frames 
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_FRMCNT (30U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_FRMCNT
+* Macro used by MMC API to read number of ipv6 frames with error in header
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_NOPAY_FRMCNT (31U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_NOPAY_FRMCNT
+* Macro used by MMC API to read number of ipv6 frames without TCP/ICMP/UDP payload
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_FRMCNT_G (32U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_FRMCNT_G
+* Macro used by MMC API to read number of UDP frames received
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_ERR_FRMCNT (33U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_ERR_FRMCNT
+* Macro used by MMC API to read number of UDP frames received with checksum errors 
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_FRMCNT_G (34U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_FRMCNT_G
+* Macro used by MMC API to read number of good TCP frames 
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_ERR_FRMCNT (35U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_ERR_FRMCNT
+* Macro used by MMC API to read  of TCP frames received with checksum errors 
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_FRMCNT_G (36U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_FRMCNT_G
+* Macro used by MMC API to read number of good ICMP frames received
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_ERR_FRMCNT (37U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_ERR_FRMCNT
+* Macro used by MMC API to read number of ICMP frames received with checksum errors 
+*/
+
+/* Octets */
+#define TMHW_LIPP6100ETH_RX_IPV4_OCTETS_G (38U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_OCTETS_G
+* Macro used by MMC API to read number of ipv4 octets received
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_OCTETS (39U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_HDR_ERR_OCTETS
+* Macro used by MMC API to read number of octets received in ipv4 packets with 
+*     header errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_OCTETS (40U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_NOPPAY_OCTETS
+* Macro used by MMC API to read no. octets received in ipv4 frame with payload 
+*     other than TCP/UDP/ICMP 
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_FRAG_OCTETS (41U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_FRAG_OCTETS
+* Macro used by MMC API to read number of octects in the fragmented IP packet 
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_OCTETS (42U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV4_UDPCSUMDSL_OCTETS
+* Macro used by MMC API to read number of octets received in a UDP segment that 
+*     had the UDP checksum disabled
+*/
+
+
+#define TMHW_LIPP6100ETH_RX_IPV6_OCTETS_G (43U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_OCTETS_G
+*      Number of bytes received in good IPv6 datagrams encapsulating TCP, UDP or 
+*      ICMPv6 data
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_OCTETS (44U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_HDR_ERR_OCTETS
+* Number of bytes received in IPv6 datagrams with header errors (length, version mismatch).
+*/
+
+#define TMHW_LIPP6100ETH_RX_IPV6_NOPAY_OCTETS (45U)
+/*! \def TMHW_LIPP6100ETH_RX_IPV6_NOPAY_OCTETS
+* Number of bytes received in IPv6 datagrams that did not have a TCP, UDP, or
+*     ICMP payload.
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_OCTETS_G (46U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_OCTETS_G
+* Number of bytes received in a good UDP segment
+*/
+
+#define TMHW_LIPP6100ETH_RX_UDP_ERR_OCTETS (47U)
+/*! \def TMHW_LIPP6100ETH_RX_UDP_ERR_OCTETS
+* Number of bytes received in a UDP segment that had checksum errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_OCTETS_G (48U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_OCTETS_G
+* Number of bytes received in a good TCP segment
+*/
+
+#define TMHW_LIPP6100ETH_RX_TCP_ERR_OCTETS (49U)
+/*! \def TMHW_LIPP6100ETH_RX_TCP_ERR_OCTETS
+* Number of bytes received in a TCP segment with checksum errors
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_OCTETS_G (50U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_OCTETS_G
+* Number of bytes received in a good ICMP segment
+*/
+
+#define TMHW_LIPP6100ETH_RX_ICMP_ERR_OCTETS (51U)
+/*! \def TMHW_LIPP6100ETH_RX_ICMP_ERR_OCTETS
+* Number of bytes received in an ICMP segment with checksum errors
+*/
+
+/*\}*/ /* end of group3 */
+
+#endif /* End of MAC management group */
+
+/* Power management related interrupts */
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+/**
+ * \defgroup group1 Power Management 
+ */
+/*\{*/
+
+/* Macro to detect the reception of wakeup frame */
+#define TMHW_LIPP6100ETH_PWRMGMT_WKUPFM_RECVD_VAL (0x40U)
+/*! \def TMHW_LIPP6100ETH_PWRMGMT_WKUPFM_RECVD_VAL
+*       Macro to detect the reception of wakeup frame
+*/
+
+/* Macro to detect the reception of magic packet */
+#define TMHW_LIPP6100ETH_PWRMGMT_MAGICPKT_RECVD_VAL (0x20U)
+/*! \def TMHW_LIPP6100ETH_PWRMGMT_MAGICPKT_RECVD_VAL
+*       Macro to detect the reception of magic packet
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PMT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_INTR_PMT_VAL
+* Macro to enable/disable interrupt generation from power management
+*/
+
+#define TMHW_LIPP6100ETH_INTR_PMT_STAT_VAL ((tmhwLIPP6100Eth_IntMask_t)0x8)
+/*! \def TMHW_LIPP6100ETH_INTR_PMT_STAT_VAL
+* Macro to check if the PMT bit in interrupt status register is set
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MSK (0xFU)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MSK
+* Mask to extract the command value
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_EN_VAL (0x1U)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_EN_VAL
+* Macro to check if the PMT bit in interrupt status register is set
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MULT_VAL (0x8U)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD_MULT_VAL
+* Macro to enable multicast wakeup frame 
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD1_POS (8)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD1_POS
+* Macro for command value for wakeup framefilter1 register
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD2_POS (16)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD2_POS
+* Macro for command value for wakeup framefilter2 register
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD3_POS (24)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CMD3_POS
+* Macro for command value for wakeup framefilter3 register
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET_MSK (0xFFU)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET_MSK
+* Wakeup frame filter register offset mask
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET1_POS (8)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET1_POS
+* Wakeup frame filter register offset position for frame filter1
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET2_POS (16)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET2_POS
+* Wakeup frame filter register offset position for frame filter2
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET3_POS (24)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_OFFSET3_POS
+* Wakeup frame filter register offset position for frame filter3
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_MSK (0xFFFFU)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_MSK
+* Wakeup frame filter register crc mask
+*/
+
+#define TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_POS (16)
+/*! \def TMHW_LIPP6100ETH_WKUP_FMFILTER_CRC_POS
+* Wakeup frame filter register crc offset for filter 1 and 3
+*/
+
+/*\}*/
+#endif /* End of power management */
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/**
+ * \defgroup group6 IEEE 1588 Time Stamp option
+ */
+/*\{*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL (0x20U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+*  Macro to enable addend register update. The Time Stamp Addend registers contents are 
+*  updated to the PTP block for fine correction.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL (0x10U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+*   Macro to enable time stamp interrupt when the system time becomes greater than the value 
+*   written in Target Time register.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL (0x8U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+*   Used when the system time needs to be  updated (added to or subtracted from) with the
+*   value specified in the Time Stamp High Update and Time Stamp Low Update registers.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL (0x4U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+*  When used  the system time is initialized (overwritten) with the value specified in the 
+*  Time Stamp High Update and Time Stamp Low Update registers.
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL (0x2)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+*  This macro is used when system time stamp is to be updated using fine update method
+*/
+
+#define TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL (0x1U)
+/*! \def TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+*  This macro is used to enable time stamping for transmit and receive frames
+*/
+
+/* Interrupt status related macros w.r.t time stamp options */
+
+#define TMHW_LIPP6100ETH_TS_INT_TRIG_STATUS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x20000000)
+/*! \def TMHW_LIPP6100ETH_TS_INT_TRIG_STATUS_VAL
+*     Time stamp interrupt trigger status value. This is a read only bit.
+*/
+
+#define TMHW_LIPP6100ETH_TS_INT_STATUS_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_TS_INT_STATUS_VAL
+*     Time stamp interrupt status. This is a clear on read bit.
+*/
+
+/* Macro to disable Time stamp interrupts */
+
+#define TMHW_LIPP6100ETH_TS_INT_MSK_VAL ((tmhwLIPP6100Eth_StatusMask_t)0x200)
+/*! \def TMHW_LIPP6100ETH_TS_INT_MSK_VAL
+*     Macro used to mask time stamp interrupt generation.
+*/
+
+/*\}*/
+
+#endif
+
+/*-----------------------------------------------------------------------------
+** Data structures:
+**-----------------------------------------------------------------------------
+*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+/**
+ * \defgroup group5 Debug/Support Functions
+ */
+/*\{*/
+
+typedef struct tmhwLIPP6100Eth_DmaHostRegs
+/*! Current Host register values */
+{
+    UInt32 curHostTxDesc ;          /*!< Current Host transmit descriptor */
+    UInt32 curHostRxDesc;           /*!< Current Host Receive descriptor */
+    UInt32 curHostTxBufferAdr;   /*!< Current Host Transmit Buffer address */
+    UInt32 curHostRxBufferAdr;   /*!< Current Host Receive Buffer address */
+}tmhwLIPP6100Eth_DmaHostRegs_t,*ptmhwLIPP6100Eth_DmaHostRegs_t;
+
+typedef struct tmhwLIPP6100Eth_DmaMissedFrmCnt
+/*!Missed Frames Counter */    
+{
+    UInt32 fifoOverflowCnt;    
+    UInt32 buffNotAvlCnt;    
+} tmhwLIPP6100Eth_DmaMissedFrmCnt_t,*ptmhwLIPP6100Eth_DmaMissedFrmCnt_t;
+
+/*\}*/
+
+#endif
+
+/*! \addtogroup group0
+   *  
+   *  \{
+   */
+/* MDC clock values */
+typedef enum tmhwLIPP6100Eth_ClkDiv
+/*! This enum is useful while deciding the MDIO clock frequency */
+{
+    tmhwLIPP6100Eth_ClkDiv_0,  /*!< clk_csr_i/42 */    
+    tmhwLIPP6100Eth_ClkDiv_1,  /*!< clk_csr_i/62 */      
+    tmhwLIPP6100Eth_ClkDiv_2,  /*!< clk_csr_i/16 */
+    tmhwLIPP6100Eth_ClkDiv_3,  /*!< clk_csr_i/26 */
+    tmhwLIPP6100Eth_ClkDiv_4,  /*!< clk_csr_i/102 */
+    tmhwLIPP6100Eth_ClkDiv_5   /*!< clk_csr_i/122 */    
+
+}tmhwLIPP6100Eth_ClkDiv_t,*ptmhwLIPP6100Eth_ClkDiv_t;
+
+/* Flow control structures */
+typedef enum  tmhwLIPP6100Eth_IFG
+/*! This enum is useful for selecting the interframe gap duration */
+{
+    tmhwLIPP6100Eth_IFG96bits=0,  /*!< Inter frame gap of 96 bit times */    
+    tmhwLIPP6100Eth_IFG88bits,      /*!< Inter frame gap of 88 bit times */    
+    tmhwLIPP6100Eth_IFG80bits,      /*!< Inter frame gap of 80 bit times */       
+    tmhwLIPP6100Eth_IFG72bits,      /*!< Inter frame gap of 72 bit times */          
+    tmhwLIPP6100Eth_IFG64bits,      /*!< Inter frame gap of 64 bit times */    
+    tmhwLIPP6100Eth_IFG56bits,      /*!< Inter frame gap of 56 bit times */      
+    tmhwLIPP6100Eth_IFG48bits,      /*!< Inter frame gap of 48 bit times */           
+    tmhwLIPP6100Eth_IFG40bits       /*!< Inter frame gap of 40 bit times */              
+}tmhwLIPP6100Eth_IFG_t,*ptmhwLIPP6100Eth_IFG_t;
+
+typedef enum  tmhwLIPP6100Eth_BackOffLimit
+/*! This enum decides the random integer of slot delays the GMAC waits
+*     before rescheduling a transmission attempt after collision 
+*     n = Retransmission attempt
+*     Range of r : 0 <= r < 2^k
+*/
+{
+    tmhwLIPP6100Eth_BackoffVal0=0,  /*!< k= min(n,10)*/
+    tmhwLIPP6100Eth_BackoffVal1,      /*!< k= min(n,8)*/
+    tmhwLIPP6100Eth_BackoffVal2,      /*!< k= min(n,4)*/   
+    tmhwLIPP6100Eth_BackoffVal3       /*!< k= min(n,1)*/ 
+   
+}tmhwLIPP6100Eth_BackOffLimit_t,*ptmhwLIPP6100Eth_BackOffLimit_t;
+
+typedef struct tmhwLIPP6100Eth_StationAddress
+/*! Structure  to store the station address */
+{
+    UInt32 adrHigh; /*!< Upper 2 bytes of station address */
+    UInt32 adrLow;  /*!< Lower 4 bytes of station address*/  
+
+}tmhwLIPP6100Eth_StationAddress_t, *ptmhwLIPP6100Eth_StationAddress_t;
+
+typedef struct  tmhwLIPP6100Eth_DevConfig
+/*! Ethernet configuration structure */
+{
+    Bool txConfiginfo;                /*!< When True, MAC transfers info to PHY in SGMII/RGMII ports*/                  
+    Bool wdTimer;                      /*!< When True, disables Watchdog timer */                  
+    Bool jabberTimer;                /*!< When True, disables Jabber timer */
+    Bool frameBurst;                  /*!< When True, enables frame bursting in 1G mode */
+    Bool jumboFrame;                /*!< When True, enables Jumbo frame transmission */
+    tmhwLIPP6100Eth_IFG_t ifg;/*!< Interframe gap selection */
+    Bool miiSelect;                      /*!< When True, selects MII Interface */
+    Bool disableCS;                     /*!< When True, MAC ignores CRS signal during txmn in Half duplex mode */
+    Bool speed100Mbps;            /*!< When True, selects 100Mbps mode, False selects 10 Mbps */
+    Bool duplexMode;                 /*!< When True, selects duplex mode */    
+    Bool disableReceiveOwn;    /*!<  Disable receive Own Enable/Disable */ 
+    Bool ipChecksumOffload;     /*!<  Enable IP checksum offload & IPv4 checksum verification */
+    Bool disableRetry;                /*!<  When set, GMAC attempts only 1 transmission */
+    Bool linkup;                           /*!<  Read only bit. Valid only during get configruation */ 
+    Bool autoPadCRC;                 /*!<  GMAC Hw calculates the CRC */ 
+    tmhwLIPP6100Eth_BackOffLimit_t backOffLim; /*!< Decides random backoff value */ 
+    Bool deferralCheck;             /*!<  Enable/Disable Deferral check */
+    tmhwLIPP6100Eth_ClkDiv_t clockSelect; /*!<  MDIO Clock selection */
+    UInt32  phyAddress;            /*!< PHY addresss */
+    tmhwLIPP6100Eth_StationAddress_t station; /*!< Station Address */
+} tmhwLIPP6100Eth_DevConfig_t, *ptmhwLIPP6100Eth_DevConfig_t;
+/*! \brief Constant pointer to constant structure of type tmhwLIPP6100Eth_DevConfig_t  */
+typedef const tmhwLIPP6100Eth_DevConfig_t* const tmhwLIPP6100Eth_DevConfig_Kpk_t;
+
+typedef struct  tmhwLIPP6100Eth_PerfectAdrConfig
+/*! Perfect Address filter configuration structure */
+{
+    Bool addressEnable;  /*!< Enable this perfect address filter */
+    Bool srcAddrCmp;      /*!< Compare source address in the received frame */   
+    UInt32 addrMask;      /*!< Bytes to ignore while comparison */       
+    UInt32 macAddrHigh; /*!< Upper 2 bytes of MAC address */
+    UInt32 macAddrlow;  /*!< First 4 bytes of MAC address  */
+} tmhwLIPP6100Eth_PerfectAdrConfig_t,*ptmhwLIPP6100Eth_PerfectAdrConfig_t;
+
+/*! \brief Constant pointer to constant structure of type tmhwLIPP6100Eth_PerfectAdrConfig_t  */
+typedef const tmhwLIPP6100Eth_PerfectAdrConfig_t* const tmhwLIPP6100Eth_Kpk_PerAdrCfg_t;
+
+typedef enum tmhwLIPP6100Eth_PCF
+/*! Enum to configure the reception of Control Frames */
+{
+   tmhwLIPP6100Eth_PCF_DisableAll0=0,  /*!< Disable reception of Pause frames */  
+   tmhwLIPP6100Eth_PCF_DisableAll1,      /*!< Disable reception of Pause frames */  
+   tmhwLIPP6100Eth_PCF_PassAll,             /*!< Pass all Pause frames */  
+   tmhwLIPP6100Eth_PCF_EnableFilter      /*!< Pass Pause frames after passing filter */  
+} tmhwLIPP6100Eth_PCF_t, *ptmhwLIPP6100Eth_PCF_t;
+
+typedef struct tmhwLIPP6100Eth_FilterConfig
+/*! General filter configuration structure */
+{
+    Bool receiveAllEnable;                            /*!<  Receive all frames with status updation */
+    Bool srcAdrFilterEnable;                         /*!<  Enable/Disable source address filtering */
+    Bool srcAdrInvFilterEnable;                   /*!<  Enable/Disable source address inverse filtering */
+    Bool hashNPerfectFilterEn;                    /*!<  Enable/Disable both perfect and hash filtering */
+    tmhwLIPP6100Eth_PCF_t pauseSetting;/*!<  Pause frame filter configuration */
+    Bool filterBroadCastFrames;                  /*!<  Enable/Disable all broadcast frames*/
+    Bool recvAllMulticast;                             /*!<  Enable/Disable reception of all Multicast frames */
+    Bool destAdrInvFiltering;                       /*!<  Enable/Disable Destination Inverse filtering*/
+    Bool hashMulticastEnable;                      /*!<  Enable/Disable Hash Multicast filtering */
+    Bool hashUnicastEnable;                        /*!<  Enable/Disable Hash Unicast filtering */
+    Bool passAllFrames;                               /*!<  Receive all frames without status updation */
+}tmhwLIPP6100Eth_FilterConfig_t,*ptmhwLIPP6100Eth_FilterConfig_t;
+
+/*! \brief Constant pointer to constant structure of type tmhwLIPP6100Eth_FilterConfig_t  */
+typedef const tmhwLIPP6100Eth_FilterConfig_t* const tmhwLIPP6100Eth_FilterConfig_Kpk_t;
+
+
+typedef enum tmhwLIPP6100Eth_EnableDisable
+/*! Enum to enable disable a particular option */
+{
+    tmhwLIPP6100Eth_Disable=0,  /*!< Disable */
+    tmhwLIPP6100Eth_Enable=1    /*!< Enable */
+}tmhwLIPP6100Eth_EnableDisable_t,*ptmhwLIPP6100Eth_EnableDisable_t;
+
+typedef enum tmhwLIPP6100Eth_Dir
+/*! Enum to select the direction */
+{
+    tmhwLIPP6100Eth_Dir_Tx,      /*!< Transmit Direction */
+    tmhwLIPP6100Eth_Dir_Rx,      /*!< Receive Direction */
+    tmhwLIPP6100Eth_Dir_TxRx   /*!< Transmit & Receive Directions */
+}tmhwLIPP6100Eth_Dir_t,*ptmhwLIPP6100Eth_Dir_t;
+
+typedef enum tmhwLIPP6100Eth_PLT
+/*! Enum to select Pause Low Threshold value */
+{
+    tmhwLIPP6100Eth_PLT_4slotTime=0,  /*!<  PLT of 4 Slot times */
+    tmhwLIPP6100Eth_PLT_28slotTime,    /*!<  PLT of 28 Slot times */
+    tmhwLIPP6100Eth_PLT_144slotTime, /*!<  PLT of 144 Slot times */
+    tmhwLIPP6100Eth_PLT_256slotTime  /*!<  PLT of 256 Slot times */
+
+}tmhwLIPP6100Eth_PLT_t,*ptmhwLIPP6100Eth_PLT_t;
+
+typedef struct tmhwLIPP6100Eth_FlowCtrlConfig
+/*! Structure for flow control configuration */
+{
+    UInt32                         pauseTime;                    /*!< Pause Time Value (16 Bit) */
+    Bool                             zeroQuanta;                   /*!< Disable automatic generation of zero quanta pause */
+    tmhwLIPP6100Eth_PLT_t pauseLowThreshold;/*!< Pause Low Threshold */
+    Bool                             unicastPsDetect;            /*!< Enable/Disable Unicast Pause Frame */
+    Bool                             rxFlowCtrlEn;                 /*!< Enable/Disable rx flow control */
+    Bool                             txFlowCtrlEn;                 /*!< Enable/Disable tx flow control */
+
+}tmhwLIPP6100Eth_FlowCtrlConfig_t,*ptmhwLIPP6100Eth_FlowCtrlConfig_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_FlowCtrlConfig_t  */
+typedef const tmhwLIPP6100Eth_FlowCtrlConfig_t* const tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t;
+
+
+typedef enum tmhwLIPP6100Eth_DmaPriority
+/*! Enum to choose the Rx:Tx DMA priority ratio */
+{
+    tmhwLIPP6100Eth_DmaPriority0,/*!< 1:1 */
+    tmhwLIPP6100Eth_DmaPriority1,/*!< 2:1 */
+    tmhwLIPP6100Eth_DmaPriority2,/*!< 3:1 */
+    tmhwLIPP6100Eth_DmaPriority3/*!< 4:1 */
+}tmhwLIPP6100Eth_DmaPriority_t,*ptmhwLIPP6100Eth_DmaPriority_t;
+
+typedef enum tmhwLIPP6100Eth_PBL
+/*! Enum to choose Programmable Burst Length */
+{
+    tmhwLIPP6100Eth_PBL_Val1 =1,     /*!< PBL of 1 */
+    tmhwLIPP6100Eth_PBL_Val2 =2,     /*!< PBL of 2 */
+    tmhwLIPP6100Eth_PBL_Val4 =4,     /*!< PBL of 4 */
+    tmhwLIPP6100Eth_PBL_Val8 =8,     /*!< PBL of 8 */
+    tmhwLIPP6100Eth_PBL_Val16 =16, /*!< PBL of 16 */       
+    tmhwLIPP6100Eth_PBL_Val32 =32  /*!< PBL of 32 */          
+
+}tmhwLIPP6100Eth_PBL_t,*ptmhwLIPP6100Eth_PBL_t ; 
+
+/* For configuring DMA in transmit direction */
+typedef enum tmhwLIPP6100Eth_TTC
+/*! Enum to configure the transmit threshold control */
+{
+    tmhwLIPP6100Eth_TTC_64bytes,    /*!< 64 bytes */
+    tmhwLIPP6100Eth_TTC_128bytes,  /*!< 128 bytes */
+    tmhwLIPP6100Eth_TTC_192bytes,  /*!< 192 bytes */   
+    tmhwLIPP6100Eth_TTC_256bytes,  /*!< 256 bytes */
+    tmhwLIPP6100Eth_TTC_40bytes,    /*!< 40 bytes */ 
+    tmhwLIPP6100Eth_TTC_32bytes,    /*!< 32 bytes */
+    tmhwLIPP6100Eth_TTC_24bytes,    /*!< 24 bytes */
+    tmhwLIPP6100Eth_TTC_16bytes     /*!< 16 bytes */
+
+}tmhwLIPP6100Eth_TTC_t,*ptmhwLIPP6100Eth_TTC_t;
+
+typedef enum tmhwLIPP6100Eth_RTC
+/*! Enum to configure the receive threshold control */
+{
+    tmhwLIPP6100Eth_RTC_64bytes,    /*!< 64 bytes */
+    tmhwLIPP6100Eth_RTC_32bytes,    /*!< 32 bytes */  
+    tmhwLIPP6100Eth_RTC_96bytes,    /*!< 96 bytes */       
+    tmhwLIPP6100Eth_RTC_128bytes   /*!< 128 bytes */
+
+}tmhwLIPP6100Eth_RTC_t,*ptmhwLIPP6100Eth_RTC_t;
+
+typedef struct tmhwLIPP6100Eth_EnTxfr
+/*! Structure  to Enable/Disable Tx/Rx transfers */
+{
+    tmhwLIPP6100Eth_EnableDisable_t  enFlag; /*!< Enable/Disable flag */
+    tmhwLIPP6100Eth_Dir_t                    dirFlag; /*!<  Direction flag */
+}tmhwLIPP6100Eth_EnTxfr_t,*ptmhwLIPP6100Eth_EnTxfr_t;
+
+/*! \brief Constant pointer to constant data refering tmhwLIPP6100Eth_EnTxfr_t */
+typedef const tmhwLIPP6100Eth_EnTxfr_t * const  tmhwLIPP6100Eth_EnTxfr_Kpk_t;
+
+typedef struct tmhwLIPP6100Eth_Int
+/*! Structure  to store the interrupt register values */
+{
+    UInt32 dmaIntVal;      /*!<  Variable to store DMA interrupt mask/status values */
+    UInt32 gmacIntVal;     /*!<  Variable to store GMAC interrupt mask/status values */
+}tmhwLIPP6100Eth_Int_t,*ptmhwLIPP6100Eth_Int_t;
+
+/*! \brief Constant pointer to constant data refering tmhwLIPP6100Eth_Int_t */
+typedef const tmhwLIPP6100Eth_Int_t * const  tmhwLIPP6100Eth_Int_Kpk_t;
+
+typedef enum tmhwLIPP6100Eth_RFD
+/*! Enum to select the Flow control deactivating threshold value */
+{
+    tmhwLIPP6100Eth_RFD_1K,  /*!< Deassert flow control after Full-1K */
+    tmhwLIPP6100Eth_RFD_2K,  /*!< Deassert flow control after Full-2K */      
+    tmhwLIPP6100Eth_RFD_3K,  /*!< Deassert flow control after Full-3K */          
+    tmhwLIPP6100Eth_RFD_4K,   /*!< Deassert flow control after Full-4K */
+    tmhwLIPP6100Eth_RFD_5K,   /*!< Deassert flow control after Full-5K */    
+    tmhwLIPP6100Eth_RFD_6K,   /*!< Deassert flow control after Full-6K */        
+    tmhwLIPP6100Eth_RFD_7K    /*!< Deassert flow control after Full-7K */            
+
+}tmhwLIPP6100Eth_RFD_t,*ptmhwLIPP6100Eth_RFD_t;
+
+typedef enum tmhwLIPP6100Eth_RFA
+/*! Enum to select the Flow control activating threshold value */
+{
+    tmhwLIPP6100Eth_RFA_1K,  /*!<  Activate flow control when fifo fill level is (Full-1K) */
+    tmhwLIPP6100Eth_RFA_2K,  /*!<  Activate flow control when fifo fill level is (Full-2K) */      
+    tmhwLIPP6100Eth_RFA_3K,  /*!<  Activate flow control when fifo fill level is (Full-3K) */          
+    tmhwLIPP6100Eth_RFA_4K,  /*!<  Activate flow control when fifo fill level is (Full-4K) */
+    tmhwLIPP6100Eth_RFA_5K,  /*!<  Activate flow control when fifo fill level is (Full-5K) */    
+    tmhwLIPP6100Eth_RFA_6K,  /*!<  Activate flow control when fifo fill level is (Full-6K) */        
+    tmhwLIPP6100Eth_RFA_7K   /*!<  Activate flow control when fifo fill level is (Full-7K) */            
+}tmhwLIPP6100Eth_RFA_t,*ptmhwLIPP6100Eth_RFA_t;
+
+typedef struct tmhwLIPP6100Eth_DmaCfg
+/*! Structure to select the DMA configuration */
+{
+
+    Bool addrAlignedBtsEn;                             /*!< Address aligned beats enable */    
+    Bool fixedBurstEn;                                     /*!< Enable/Disable Fixed Bursting */
+    tmhwLIPP6100Eth_DmaPriority_t priority;/*!< Select the DMA priority */
+    Bool pBL4xmode;                                      /*!< When set, effective PBL becomes (4* burstLen) */
+    Bool differentPBL;                                     /*!<  Use separate PBL for tx & rx */
+    tmhwLIPP6100Eth_PBL_t rxPBL;              /*!<  PBL for receive direction */    
+    tmhwLIPP6100Eth_PBL_t burstLen;          /*!< Programmable Burst Length */
+    UInt32 descSkipLen;                                 /*!< Descriptor skip length */
+    Bool dmaArbitration;                                 /*!< Round Robin or Priority of Rx > Tx */
+
+    /* Transmit side configuration */
+    Bool                                    storeNforwardEn;  /*!< Enable/Disable Store and Forward Mechanism */
+    tmhwLIPP6100Eth_TTC_t   txThreshold;           /*!< Transmit Threshold control */
+    tmhwLIPP6100Eth_RTC_t   rxThreshold;           /*!< Receive Threshold control */
+    Bool                                    txSecondFrameEn;  /*!< Transmit second frame enable/disable  */
+    UInt32                                txDescListBaseAdr; /*!< Transmit descriptor list base address */
+
+     /* Receive side configuration */
+    tmhwLIPP6100Eth_RFA_t actRxThreshold;	/*!< Receive Flow control activate value */
+    tmhwLIPP6100Eth_RFD_t deactRxThreshold;/*!< Receive Flow control Deactivate value */
+    Bool                                   hwFlowCtrlEn; /*!< Enable/Disable Hardware Flow control */
+    Bool                                   errFramesEn; /*!< Enable/Disable reception of error frames */
+    Bool                                   underSizedGdFramesEn; /*!< Enable/Disable reception of undersized good frames */
+    UInt32                               rxDescListBaseAdr;   /*!< Receive descriptor list base address */ 
+    Bool disableFrameFlush;                         /*!< Disable frame flushing, when descriptors are not available */
+    Bool rxStoreNforwardEn; /*!< Enable/Disable receive store and Forward Mechanism */ 
+    Bool recvTcpIpErrFrms; /*!< Enable/Disable reception of TCP/IP error frames */       
+
+ }tmhwLIPP6100Eth_DmaCfg_t,*ptmhwLIPP6100Eth_DmaCfg_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_DmaCfg_t */
+typedef const tmhwLIPP6100Eth_DmaCfg_t* const tmhwLIPP6100Eth_DmaCfg_Kpk_t;
+
+
+/*! \} */ /* End of group0 */
+
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_HASH )
+
+/**
+ * \defgroup group2 Hash Filter Related
+ */
+/*\{*/
+
+typedef struct tmhwLIPP6100Eth_HashFilter
+/*! Hash Filter configuration Structure */
+{
+    UInt32 hashFilterH;  /*!< Hash Filter High Register */
+    UInt32 hashFilterL;  /*!<  Hash Filter Low Register */   
+}tmhwLIPP6100Eth_HashFilter_t,*ptmhwLIPP6100Eth_HashFilter_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_HashFilter_t */
+typedef const tmhwLIPP6100Eth_HashFilter_t* const tmhwLIPP6100Eth_HashFilter_Kpk_t;
+
+
+/*\}*/ /* End of group2 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC)
+
+/*! \addtogroup group3
+   *  \{
+   */
+typedef struct tmhwLIPP6100Eth_MmcCtrl
+/*! MAC management counters configuration */
+{
+    Bool freezeCntrs;          /*!< Enable/Disable freezing of counters */
+    Bool resetOnRdEn;        /*!< Enable/Disable reset on Read */
+    Bool rollOverDisable;    /*!< Enable/Disable rollover */
+    Bool resetCounters;       /*!< Reset counters */
+}tmhwLIPP6100Eth_MmcCtrl_t,*ptmhwLIPP6100Eth_MmcCtrl_t;
+
+/*! \brief Contant pointer to constant data of type tmhwLIPP6100Eth_MmcCtrl_t */
+typedef const tmhwLIPP6100Eth_MmcCtrl_t* const tmhwLIPP6100Eth_MmcCtrl_Kpk_t;
+
+typedef struct tmhwLIPP6100Eth_MmcIntStat
+/*! MAC management Interrupt status structure */
+{
+    UInt32                               rxCsumStatus; /*!< Rx checksum offload status */
+    UInt32                               intStat;             /*!< Interrupt status */
+    tmhwLIPP6100Eth_Dir_t    dir;                   /*!< Tx/Rx direction  */
+}tmhwLIPP6100Eth_MmcIntStat_t, *ptmhwLIPP6100Eth_MmcIntStat_t;
+
+typedef struct tmhwLIPP6100Eth_MmcIntr
+/*! Structure to enable and disable MAC interrupts */
+{
+    UInt32                          rxCsumIntVal; /*!< Rx checksum offload interrupts */
+    UInt32                          intrVal;             /*!< Interrupts to Enable or disable */
+    tmhwLIPP6100Eth_Dir_t dir;                 /*!< Tx/Rx direction  */
+}tmhwLIPP6100Eth_MmcIntr_t, *ptmhwLIPP6100Eth_MmcIntr_t;
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_MmcIntr_t */
+typedef const tmhwLIPP6100Eth_MmcIntr_t* const tmhwLIPP6100Eth_MmcIntr_Kpk_t;
+
+typedef struct tmhwLIPP6100Eth_MmcRegVal
+/*! MAC management structure to read MAC counters */
+{
+    UInt32                        mmcRegVal; /*!< Register Value read */
+    UInt32                        regToRd;       /*!< Register to be read */
+    tmhwLIPP6100Eth_Dir_t dir;            /*!< Tx/Rx direction  */
+}tmhwLIPP6100Eth_MmcRegVal_t, *ptmhwLIPP6100Eth_MmcRegVal_t;
+
+/*! \} */ /* End of group3 */
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+
+/* Power management related */
+/*! \addtogroup group1
+   *  \{
+   */
+typedef struct tmhwLIPP6100Eth_WkupCfg
+/*! Structure to store the Wakeup on LAN configuration */
+{
+    Bool      rstRegptr;               /*!< Reset wakeup frame filter register pointer */
+    Bool      globalUnicastEn;    /*!< Enable/Disable Wakeup on Unicast frame reception */
+    Bool      wkupFrameEn;       /*!< Enable/Disable Wakeup Frame */
+    Bool      magicPktEn;           /*!< Enable/Disable Wakeup on Magic Packet reception */
+    UInt32  filterMask[4];         /*!< Mask to be applied for the incoming frame */
+    UInt32  filterCommand;      /*!< Multicast/Unicast and Enable/disable filter options */
+    UInt32  filterOffset;            /*!<  Offset to start sampling the bytes for calucating CRC */
+    UInt32  filterCrcVal6;         /*!< CRC value to be used by filter 0 and filter 1 */
+    UInt32  filterCrcVal7;         /*!< CRC value to be used by filter 2 and filter 3 */    
+}tmhwLIPP6100Eth_WkupCfg_t,*ptmhwLIPP6100Eth_WkupCfg_t;
+/*! \} */ /* End of group1 */
+
+/*! \brief Constant pointer to constant data of type tmhwLIPP6100Eth_WkupCfg_t */
+typedef const tmhwLIPP6100Eth_WkupCfg_t* const tmhwLIPP6100Eth_WkupCfg_Kpk_t;
+
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/*! \addtogroup group6
+   *  \{
+   */
+typedef struct tmhwLIPP6100Eth_TsReg
+/*! Current Host register values */
+{
+    UInt32 highVal;/*!< Higher 32 bit value of the register */
+    UInt32 lowVal; /*!< Lower 32 bit value of the register */
+}tmhwLIPP6100Eth_TsReg_t,*ptmhwLIPP6100Eth_TsReg_t;
+
+typedef enum tmhwLIPP6100Eth_Ts_Psnt
+/*! Enum to indicate if the value in the update registers is to be added or 
+**   subtracted from the system time.
+*/
+{
+    tmhwLIPP6100Eth_AddToSysTime,
+    tmhwLIPP6100Eth_SubFromSysTime        
+}tmhwLIPP6100Eth_Ts_Psnt_t, *ptmhwLIPP6100Eth_Ts_Psnt_t;
+
+typedef struct tmhwLIPP6100Eth_TsUpdateReg
+/*! Value in the Time Stamp Update registers is added to the system time
+** or subtracted depending on addSub flag
+*/
+{
+    tmhwLIPP6100Eth_TsReg_t updateReg;
+    tmhwLIPP6100Eth_Ts_Psnt_t addSub;    
+
+}tmhwLIPP6100Eth_TsUpdateReg_t, *ptmhwLIPP6100Eth_TsUpdateReg_t;
+
+/*! \} */ /* End of group6 */
+#endif
+
+/*-----------------------------------------------------------------------------*/
+/* Exported functions:*/
+/*-----------------------------------------------------------------------------*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_OTHERS)
+
+/*! \addtogroup group5
+   *  Additional support functions
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetSWVersion (ptmSWVersion_t  pEthGmacVersion);
+* This function gets the sofware version of the driver 
+*  \param[out] pEthGmacVersion: Pointer to structure tmSWVersion_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSWVersion (
+    ptmSWVersion_t  pEthGmacVersion    
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetHWVersion(tmUnitSelect_t ethUnitId, pUInt32 pHWVersion);
+* This function returns the hardware version number of the ethernet unit
+*  \param[in] ethUnitId: Ethernet Unit ID
+*  \param[out] pHWVersion: Pointer to variable, where the version number is to be stored
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetHWVersion(
+    tmUnitSelect_t                    ethUnitId,  
+    pUInt32                             pHWVersion
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_Deinit(tmUnitSelect_t ethUnitId);
+* This function disables the GMAC hardware
+*  \param[in] ethUnitId: Ethernet Unit ID
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_Deinit(
+    tmUnitSelect_t  ethUnitId   
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetConfig(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_DevConfig_t pEthConfig);
+* This function gets the current configuration of the GMAC device
+*  \param[in] ethUnitId: Ethernet Unit ID
+*  \param[out] pEthConfig : Fills the information in the pEthConfig pointer passed as parameter
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetConfig(
+    tmUnitSelect_t                      ethUnitId ,    
+    ptmhwLIPP6100Eth_DevConfig_t    pEthConfig
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaFlushTxFifo (tmUnitSelect_t ethUnitId);
+* This function is used to flush the contents of a Transmit FIFO
+* \param[in] ethUnitId: GMAC unit number 
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaFlushTxFifo(
+    tmUnitSelect_t  ethUnitId 
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaGetCurrentHostRegs(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_DmaHostRegs_t pDmaHostReg);
+* This function is used to retrieve the DMA host registers for debug purposes
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pDmaHostReg: Pointer to structure tmhwLIPP6100Eth_DmaHostRegs_t for storing the read values 
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetCurrentHostRegs(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaHostRegs_t     pDmaHostReg       
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaGetMissedFrameCount (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_DmaMissedFrmCnt_t pMissedFrmCnt);
+* This function is used to clear the Missed Frames counter
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pMissedFrmCnt: Pointer to structure ptmhwLIPP6100Eth_DmaMissedFrmCnt_t
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaGetMissedFrameCount(
+    tmUnitSelect_t                                 ethUnitId,
+    ptmhwLIPP6100Eth_DmaMissedFrmCnt_t pMissedFrmCnt
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaMissedFrameCounterClear (tmUnitSelect_t ethUnitId);
+* This function is used to clear the Missed Frames counter
+* \param[in] ethUnitId: GMAC unit number 
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_DmaMissedFrameCounterClear(
+    tmUnitSelect_t                                 ethUnitId
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FilterGetConfig (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_FilterConfig_t pFilterConfig);
+* This function is used to get the receive filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pFilterConfig: Pointer to tmhwLIPP6100Eth_FilterConfig_t structure for storing the read values
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    ptmhwLIPP6100Eth_FilterConfig_t        pFilterConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_PerfectAdrGetConfig (tmUnitSelect_t ethUnitId,UInt32 regNum,ptmhwLIPP6100Eth_PerfectAdrConfig_t pAdrConfig);
+* This function is used to get the perfect address filter configuration
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regNum: Perfect address filter register number
+* \param[out] pAdrConfig: Pointer to structure tmhwLIPP6100Eth_PerfectAdrConfig_t
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrGetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,    
+    ptmhwLIPP6100Eth_PerfectAdrConfig_t pAdrConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlGetConfig (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_FlowCtrlConfig_t pFlowCtrlCfg);
+* This function is used to do flow control configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pFlowCtrlCfg: Pointer to tmhwLIPP6100Eth_FlowCtrlConfig_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlGetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    ptmhwLIPP6100Eth_FlowCtrlConfig_t        pFlowCtrlCfg
+);
+/*! \} */ /* Group5 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_POWER)
+/*! \addtogroup group1
+   *  Power Management Functions
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetPowerState (tmUnitSelect_t ethUnitId,ptmPowerState_t pEthPowerState);
+* This function gets the current power state of the GMAC device
+*  \param[in] ethUnitId: Ethernet unit ID
+*  \param[out] pEthPowerState: Pointer to tmPowerState_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetPowerState(
+    tmUnitSelect_t    ethUnitId ,
+    ptmPowerState_t pEthPowerState
+    );
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetPowerState(tmUnitSelect_t  ethUnitId, tmPowerState_t ethPowerState);
+* This function sets/resets power down bit of the GMAC. Function tmhwLIPP6100Eth_WoLConfig() is to be 
+* called before putting the device into power down mode.
+* \param[in] ethUnitId: GMAC Unit number.
+* \param[in] ethPowerState: Power On or Power Off
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetPowerState(
+    tmUnitSelect_t   ethUnitId  , 
+    tmPowerState_t  ethPowerState
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_WoLConfig(tmUnitSelect_t  ethUnitId, tmhwLIPP6100Eth_WkupCfg_Kpk_t pWolConfig);
+* This function sets the wakeup method for the GMAC when putting the device into power down mode. 
+* \param[in] ethUnitId: Instance number of the device
+* \param[in] pWolConfig: Pointer to structure tmhwLIPP6100Eth_WkupCfg_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_WoLConfig(
+    tmUnitSelect_t   ethUnitId  , 
+    tmhwLIPP6100Eth_WkupCfg_Kpk_t  pWolConfig
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetWakeupStatus(tmUnitSelect_t  ethUnitId, pUInt32 pRegVal);
+* This function is used to get the cause of a wakeup event 
+* \param[in] ethUnitId: Instance number of the device
+* \param[out] pRegVal: Pointer to variable to store the status
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_GetWakeupStatus(
+    tmUnitSelect_t       ethUnitId ,    
+    pUInt32                  pRegVal
+    );
+
+/*! \} */ /* group1 */
+#endif 
+
+/*! \addtogroup group0
+   *  Basic API set
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_Init (tmUnitSelect_t ethUnitId);
+* This function initializes the GMAC with default values
+* \param[in] ethUnitId: GMAC unit number
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_Init(
+    tmUnitSelect_t  ethUnitId
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_DevConfig_Kpk_t pEthConfig);
+* This function configures the GMAC device with the values passed.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pEthConfig: Pointer to structure tmhwLIPP6100Eth_DevConfig_t
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetConfig(
+    tmUnitSelect_t                  ethUnitId ,    
+    tmhwLIPP6100Eth_DevConfig_Kpk_t pEthConfig
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntGetStatus (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_Int_t pIntStat);
+* This function gets DMA interrupt status
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pIntStat: Pointer to structure tmhwLIPP6100Eth_Int_t 
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_IntGetStatus (
+    tmUnitSelect_t                               ethUnitId ,    
+    ptmhwLIPP6100Eth_Int_t                  pIntStat
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntEnable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Int_Kpk_t pIntEn);
+* This function enables the device interrupts
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pIntEn: Interrupts to be enabled
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_IntEnable (
+    tmUnitSelect_t              ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t pIntEn
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Int_Kpk_t pIntDis);
+* This function disables the device interrupts
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pIntDis: Interrupts to be disabled
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_IntDisable (
+    tmUnitSelect_t                       ethUnitId ,    
+    tmhwLIPP6100Eth_Int_Kpk_t     pIntDis
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_IntClear (tmUnitSelect_t ethUnitId,UInt32 ethIntstatus);
+* This function clears the device interrupts by writing 1s to the status register
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] ethIntstatus: Interrupts to be cleared
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_IntClear (
+    tmUnitSelect_t              ethUnitId ,    
+    UInt32                         ethIntstatus
+    );
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_PerfectAdrSetConfig (tmUnitSelect_t ethUnitId,UInt32 regNum,tmhwLIPP6100Eth_Kpk_PerAdrCfg_t pAdrConfig);
+* This function is used to configure the perfect address filters of GMAC
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regNum: Perfect address filter register number
+* \param[in] pAdrConfig: Pointer to structure tmhwLIPP6100Eth_PerfectAdrConfig_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_PerfectAdrSetConfig(
+    tmUnitSelect_t                      ethUnitId , 
+    UInt32                                 regNum,
+    tmhwLIPP6100Eth_Kpk_PerAdrCfg_t pAdrConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FilterSetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_FilterConfig_Kpk_t pFilterConfig);
+* This function is used to set the filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pFilterConfig: Pointer to tmhwLIPP6100Eth_FilterConfig_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_FilterSetConfig(
+    tmUnitSelect_t                          ethUnitId , 
+    tmhwLIPP6100Eth_FilterConfig_Kpk_t  pFilterConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GmacEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnTxfr_Kpk_t pEndir);
+* This function is used to enable or disable GMAC in transmit or receive or both the directions
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pEndir: Pointer to tmhwLIPP6100Eth_EnTxfr_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_GmacEnableDisable (
+    tmUnitSelect_t                              ethUnitId ,
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t      pEndir    
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_LpbkEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnableDisable_t enableDisable);
+* This function is used to enable loopback at the MAC level
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] enableDisable: Enum to enable or disable
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_LpbkEnableDisable (
+    tmUnitSelect_t                              ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t     enableDisable
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlSetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t pFlowCtrlCfg);
+* This function is used to do flow control configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pFlowCtrlCfg: Pointer to tmhwLIPP6100Eth_FlowCtrlConfig_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlSetConfig(
+    tmUnitSelect_t                                    ethUnitId ,
+    tmhwLIPP6100Eth_Kpk_FlowCtrlCfg_t        pFlowCtrlCfg
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnableDisable_t enableDisable);
+* This function is used to enable the generation of pause frame in full-duplex mode, and in half duplex
+* to activate/deactivate backpressure operation.
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] enableDisable: Enum to enable or disable
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlEnableDisable(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_EnableDisable_t enableDisable
+) ;
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_FlowCtrlStatus (tmUnitSelect_t ethUnitId,pUInt32 pRegVal);
+* This function is used to check if the FCA/BP bit is cleared after a pause frame transmission
+* \param[in] ethUnitId : Ethernet unit number 
+* \param[out] pRegVal: Pointer to variable to store the status 
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_FlowCtrlStatus(
+    tmUnitSelect_t                          ethUnitId,
+    pUInt32                                    pRegVal
+); 
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_DmaCfg_Kpk_t pDmaConfig);
+* This function is used to do the DMA configuration.
+* \param[in] ethUnitId : Ethernet unit number
+* \param[in] pDmaConfig: Pointer to tmhwLIPP6100Eth_DmaCfg_t structure
+* \return TM_OK - successful
+*/
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaConfig(
+    tmUnitSelect_t                               ethUnitId ,
+    tmhwLIPP6100Eth_DmaCfg_Kpk_t        pDmaConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaEnableDisable (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_EnTxfr_Kpk_t pTxfr);
+* This function is used to Enable/Disable DMA in a particular direction
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pTxfr: Pointer to structure tmhwLIPP6100Eth_EnTxfr_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaEnableDisable(
+    tmUnitSelect_t  ethUnitId, 
+    tmhwLIPP6100Eth_EnTxfr_Kpk_t pTxfr
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_DmaPollDesc(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_Dir_t dir);
+* This function is used to restart the DMA transmission/reception if it is in suspended state 
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] dir: Enum, which indicates the direction
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t  
+tmhwLIPP6100Eth_DmaPollDesc(
+    tmUnitSelect_t          ethUnitId,
+    tmhwLIPP6100Eth_Dir_t       dir
+);
+
+/*! \} */ /*End of  group0*/
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_HASH)
+/*! \addtogroup group2
+   *  Hash Filter APIs
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_HashFilterSetConfig (tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_HashFilter_Kpk_t pHashConfig);
+* This function is used to set the hash filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[in] pHashConfig: Pointer to tmhwLIPP6100Eth_HashFilter_t structure
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterSetConfig(
+    tmUnitSelect_t                          ethUnitId ,
+    tmhwLIPP6100Eth_HashFilter_Kpk_t    pHashConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_HashFilterGetConfig (tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_HashFilter_t pHashConfig);
+* This function is used to get the hash filter configuration
+* \param[in] ethUnitId: GMAC unit number 
+* \param[out] pHashConfig: Pointer to tmhwLIPP6100Eth_HashFilter_t structure
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t 
+tmhwLIPP6100Eth_HashFilterGetConfig(
+    tmUnitSelect_t                                ethUnitId ,
+    ptmhwLIPP6100Eth_HashFilter_t          pHashConfig
+);
+
+/*! \} */ /*End of  group2 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_MMC )
+
+/*! \addtogroup group3
+   *  APIs for MAC Management Counters 
+   *  \{
+   */
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCConfig(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_MmcCtrl_Kpk_t pCtrlConfig);
+* This function is used to configure the behaviour of MAC Management counters and also to reset counters
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pCtrlConfig: Pointer to structure tmhwLIPP6100Eth_MmcCtrl_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t 
+tmhwLIPP6100Eth_MMCConfig(
+    tmUnitSelect_t                      ethUnitId,
+    tmhwLIPP6100Eth_MmcCtrl_Kpk_t           pCtrlConfig
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCIntStatus(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_MmcIntStat_t pMmcStat);
+* This function is used to read the interrupt status register for transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcStat: Pointer to structure tmhwLIPP6100Eth_MmcIntStat_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntStatus(
+    tmUnitSelect_t                            ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcIntStat_t   pMmcStat
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCIntEnable(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_MmcIntr_Kpk_t pMmcIntEn);
+* This function is used to enable the MMC interrupts in transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcIntEn: Pointer to structure tmhwLIPP6100Eth_MmcIntr_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntEnable(
+    tmUnitSelect_t                            ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t   pMmcIntEn
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCIntDisable(tmUnitSelect_t ethUnitId,tmhwLIPP6100Eth_MmcIntr_Kpk_t pMmcIntDis);
+* This function is used to disable the MMC interrupts in transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcIntDis: Pointer to structure tmhwLIPP6100Eth_MmcIntr_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCIntDisable(
+    tmUnitSelect_t                            ethUnitId ,    
+    tmhwLIPP6100Eth_MmcIntr_Kpk_t   pMmcIntDis
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_MMCCountersRead(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_MmcRegVal_t pMmcReg);
+* This function is used to read the Mac Management Counters in transmit or receive direction
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pMmcReg: Pointer to structure tmhwLIPP6100Eth_MmcRegVal_t
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_MMCCountersRead(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_MmcRegVal_t pMmcReg
+);
+
+/*! \} */ /* End of group 3*/
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_VLAN)
+
+/**
+ * \defgroup group4 VLAN Tag APIs
+ */
+/*\{*/
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetVLANTag(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* This function is used to set the VLAN tag value.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue: VLAN tag value
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetVLANTag (
+    tmUnitSelect_t    ethUnitId ,    
+    UInt32            regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetVLANTag(tmUnitSelect_t ethUnitId,pUInt32 pRegValue);
+* This function is used to get the VLAN tag value.
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pRegValue: Pointer to store the VLAN tag value read 
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetVLANTag (
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+);
+
+/*\}*/ /* end of group4 */
+
+#endif
+
+#if (TMFL_SD_ALL || TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP)
+
+/**
+ * \addtogroup group6
+ */
+/*\{*/
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetTsCtrlVal(tmUnitSelect_t ethUnitId,pUInt32 pRegValue);
+* This function returns the control value of the time stamp registers.
+* Below macros can be used to check if a corresponding bit is set/reset in 
+* the register: 
+* TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pRegValue: Pointer to store the control value read 
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetTsCtrlVal(
+    tmUnitSelect_t               ethUnitId ,    
+    pUInt32                         pRegValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsCtrl(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* This function enables/disables certain features of time stamp operation,depending on the value 
+* passed. 
+* Parameter to this function can be any of the below macros:
+* TMHW_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TS_INIT_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL
+* TMHW_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue: Time stamp control value to set 
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsCtrl(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsSubSecInc(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* API to set sub-second increment value
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue: Sub-Second increment value
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsSubSecInc(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsAddend(tmUnitSelect_t ethUnitId,UInt32 regValue);
+* This API is used to set Time Stamp Addend value. This is used only when system time is configured 
+* for Fine Update mode.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] regValue:  Addend value
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsAddend(
+    tmUnitSelect_t               ethUnitId ,    
+    UInt32                           regValue
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_GetSysTs(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_TsReg_t pRegs);
+* This API fetches the current system time stamp value. 
+* \param[in] ethUnitId: GMAC unit number
+* \param[out] pRegs: Pointer to structure to store the values read
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_GetSysTs(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsUpdate(tmUnitSelect_t ethUnitId, ptmhwLIPP6100Eth_TsUpdateReg_t pUpdate);
+* This API is used to set the values of Time Stamp update registers & the parameter passed to this 
+* function also indicates if the value is to be added to the system time or subracted from the system 
+* time.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pUpdate: Pointer to structure that stores the time stamp values & flag that indicates 
+*   whether to add or subtract this value from system time.
+* \return TM_OK - successful
+*/
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsUpdate(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsUpdateReg_t pUpdate   
+);
+
+/*!
+* \fn tmErrorCode_t tmhwLIPP6100Eth_SetTsTgtTime(tmUnitSelect_t ethUnitId,ptmhwLIPP6100Eth_TsReg_t pRegs);
+* This API is used to set the target time stamp register values.
+* \param[in] ethUnitId: GMAC unit number
+* \param[in] pRegs: Pointer to structure which contains  target high & targe low register values
+* \return TM_OK - successful
+*/
+
+tmErrorCode_t
+tmhwLIPP6100Eth_SetTsTgtTime(
+    tmUnitSelect_t               ethUnitId ,    
+    ptmhwLIPP6100Eth_TsReg_t pRegs
+);
+
+/*\}*/ /* end of group6 */
+#endif
+
+/* End of function prototypes */
+
+#if defined(__cplusplus)
+}
+#endif  /* defined(__cplusplus) */
+
+#endif  /* TMHWLIPP6100ETH_H */
+
+
+
diff --git a/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Cfg.c b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Cfg.c
new file mode 100644
index 0000000..11fd1dc
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Cfg.c
@@ -0,0 +1,64 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth_Cfg.c %
+ * %pid_version:          1.1                         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  This file holds the code for configuration of ethernet GMAC HwApi
+ *
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+/*----------------------------------------------------------------------------*/
+/* Standard include files:                                                    */
+/*----------------------------------------------------------------------------*/
+
+#include "tmNxTypes.h"
+
+/*----------------------------------------------------------------------------*/
+/* Project include files:                                                     */
+/*----------------------------------------------------------------------------*/
+
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+/*----------------------------------------------------------------------------*/
+/* Types and defines:                                                         */
+/*----------------------------------------------------------------------------*/
+
+
+/* Base addresses of GMAC 0*/
+
+#ifndef TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0
+#define TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0     ((0x1be00000+0x38000))
+#endif
+
+
+/*----------------------------------------------------------------------------*/
+/* Global data:                                                               */
+/*----------------------------------------------------------------------------*/
+tmhwLIPP6100Eth_Cfg_t gtmhwLIPP6100Eth_Base[TMHWLIPP6100ETH_NUM_UNITS] = 
+{
+    {TMHW_LIPP6100ETH_PHY_MMIO_ADDRESS0}
+};
diff --git a/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Cfg.h b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Cfg.h
new file mode 100644
index 0000000..1859d08
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Cfg.h
@@ -0,0 +1,119 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth_Cfg.h%
+ * %pid_version:          1.5                         %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:  Configuration header file for Ethernet HwApi Driver
+ *
+ *
+ * DOCUMENT REF: 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMHWLIPP6100ETH_CFG_H
+#define TMHWLIPP6100ETH_CFG_H
+
+/*----------------------------------------------------------------------------*/
+/* Standard include files: */
+/*----------------------------------------------------------------------------*/
+
+
+#include "tmNxTypes.h"
+
+/*----------------------------------------------------------------------------*/
+/* Project include files: */
+/*----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*! 
+ * \def TMFL_SD_ALL
+ * Select all the APIs for final image. If this flag is disabled then scalability settings as 
+ * defined below are used by preprocessor.
+ * \n NOTE: The flags need to be modified by the user as per system requirements. Also, care 
+ * should be taken in case multiple units of this IP are available in Hw sybsystem. 
+ * In case of multiple units with different features User will need to enable superset of
+ * features of individual unit. In such case it is Applications responsibility to keep track of which 
+ * features are supported by which IP.
+ */
+
+/*  Scalability Settings Start  */
+#define TMFL_SD_ALL 0
+#if (TMFL_SD_ALL == 0)
+#define TMFL_LIPP6100ETHSD_MMC 0
+#define TMFL_LIPP6100ETHSD_POWER 0 
+#define TMFL_LIPP6100ETHSD_HASH 0
+#define TMFL_LIPP6100ETHSD_VLAN 0
+#define TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP 0
+#define TMFL_LIPP6100ETHSD_OTHERS 1
+#endif
+/* Scalability Settings End */
+
+/* Defining this macro to 1, incorporates work around for IPC counters bug in 3.41a */
+#define IPVERSION_34_1_A  0
+
+#define TMHWLIPP6100ETH_NUM_UNITS (1)
+/*! 
+ * \def TMHWLIPP6100ETH_NUM_UNITS
+ *  Indicates number of ethernet units supported.
+ *  The definition of gtmhwLIPP6100Eth_Base[] is to be modified.
+ *  with new base addresses, if there are multiple units.
+ */
+
+/* Defined as part common.h headerfile, since it varies for different PHYs */
+//#define  TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL (0x16U)
+/*! \def TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL
+*   Default PHY address value used
+*/
+
+/* Defined as part common.h headerfile in uboot */
+//#define TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL (0x1U)
+/*! \def TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL
+*     CSR clock value, which decides the frequency of MDC clock
+*/
+
+typedef struct tmhwLIPP6100Eth_Cfg
+/*! \brief This structure stores the base Address of Ethernet unit*/
+{
+    UInt32 baseAddress; /*!< baseAddress of GMAC unit */
+
+} tmhwLIPP6100Eth_Cfg_t, *ptmhwLIPP6100Eth_Cfg_t;
+
+extern tmhwLIPP6100Eth_Cfg_t gtmhwLIPP6100Eth_Base[TMHWLIPP6100ETH_NUM_UNITS]; /* ETH context */
+
+/*!
+ * \def GET_BASE(x)
+ * Computes the base address of GMAC unit.
+ */
+#define GET_BASE(x)     (gtmhwLIPP6100Eth_Base[x].baseAddress)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Vhip.h b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Vhip.h
new file mode 100644
index 0000000..9a13e0a
--- /dev/null
+++ b/drivers/net/lipp_6300eth/tmhwLIPP6100Eth_Vhip.h
@@ -0,0 +1,619 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmhwLIPP6100Eth_Vhip.h %
+ * %pid_version:          1.5                           %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:   vHAL file for ethernet HwApi driver
+ *
+ *  DOCUMENT REF: Synopsys DesignWare Ethernet Universal Databook 
+ *                         Version 3.41a, Feb 2008 
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef TMHWLIPP6100ETH_VHIP_H
+#define TMHWLIPP6100ETH_VHIP_H
+
+/*-----------------------------------------------------------------------------
+* Standard include files:
+*-----------------------------------------------------------------------------
+*/
+
+#include "tmhwLIPP6100Eth_Cfg.h"
+
+#ifdef __cplusplus
+extern "C" {  /* Assume C declarations for C++ */
+#endif
+
+
+/* Registers offsets of GMAC */
+#define TMVH_LIPP6100ETH_CONFIG_REG_OFFSET (0x0000)
+
+#define TMVH_LIPP6100ETH_CONFIG_TXCONFIG_VAL (0x1000000U)
+#define TMVH_LIPP6100ETH_CONFIG_TXCONFIG_POS (24)
+
+#define TMVH_LIPP6100ETH_CONFIG_WD_VAL (0x800000U)
+#define TMVH_LIPP6100ETH_CONFIG_WD_POS (23)
+
+#define TMVH_LIPP6100ETH_CONFIG_JD_VAL (0x400000U)
+#define TMVH_LIPP6100ETH_CONFIG_JD_POS (22)
+
+#define TMVH_LIPP6100ETH_CONFIG_FBE_VAL (0x200000U)
+#define TMVH_LIPP6100ETH_CONFIG_FBE_POS (21)
+
+
+#define TMVH_LIPP6100ETH_CONFIG_JFE_VAL (0x100000U)
+#define TMVH_LIPP6100ETH_CONFIG_JFE_POS (20)
+
+#define TMVH_LIPP6100ETH_CONFIG_DISCS_VAL (0x10000U)
+#define TMVH_LIPP6100ETH_CONFIG_DISCS_POS (16)
+
+#define TMVH_LIPP6100ETH_CONFIG_IFG_MSK (0xE0000U)
+#define TMVH_LIPP6100ETH_CONFIG_IFG_POS (17)
+
+#define TMVH_LIPP6100ETH_CONFIG_MII_VAL (0x8000U)
+#define TMVH_LIPP6100ETH_CONFIG_MII_POS (14)
+
+#define TMVH_LIPP6100ETH_CONFIG_FES_VAL (0x4000U)
+#define TMVH_LIPP6100ETH_CONFIG_FES_POS (14)
+
+/* Disable Receive Own */
+#define TMVH_LIPP6100ETH_CONFIG_DRXOWN_VAL (0x2000U)
+#define TMVH_LIPP6100ETH_CONFIG_DRXOWN_POS (13)
+
+#define TMVH_LIPP6100ETH_CONFIG_LPBK_VAL (0x1000U)
+#define TMVH_LIPP6100ETH_CONFIG_LPBK_POS (12)
+#define TMVH_LIPP6100ETH_CONFIG_LPBK_CLR (0xFFFFEFFFU) 
+
+#define TMVH_LIPP6100ETH_CONFIG_DUPLEX_VAL (0x800U)
+#define TMVH_LIPP6100ETH_CONFIG_DUPLEX_POS (11)
+
+#define TMVH_LIPP6100ETH_CONFIG_IPCCHK_VAL (0x400U)
+#define TMVH_LIPP6100ETH_CONFIG_IPCCHK_POS (10)
+
+#define TMVH_LIPP6100ETH_CONFIG_DRETRY_VAL (0x200U)
+#define TMVH_LIPP6100ETH_CONFIG_DRETRY_POS (9)
+
+#define TMVH_LIPP6100ETH_CONFIG_LNKUP_VAL (0x100U)
+
+/* Automatic PAD/CRC stripping */
+#define TMVH_LIPP6100ETH_CONFIG_ACS_VAL (0x80U)
+#define TMVH_LIPP6100ETH_CONFIG_ACS_POS (7)
+
+#define TMVH_LIPP6100ETH_CONFIG_BACKOFF_MSK (0x60U)
+#define TMVH_LIPP6100ETH_CONFIG_BACKOFF_POS (5)
+
+#define TMVH_LIPP6100ETH_CONFIG_DEFCHK_VAL (0x10U)
+#define TMVH_LIPP6100ETH_CONFIG_DEFCHK_POS (4)
+
+#define TMVH_LIPP6100ETH_CONFIG_TX_EN_VAL (0x8U)
+#define TMVH_LIPP6100ETH_CONFIG_TX_EN_CLR (0xFFFFFFF7U)
+
+#define TMVH_LIPP6100ETH_CONFIG_RX_EN_VAL (0x4U)
+#define TMVH_LIPP6100ETH_CONFIG_RX_EN_CLR (0xFFFFFFFBU)
+
+#define TMVH_LIPP6100ETH_FMFLTR_REG_OFFSET (0x0004)
+
+#define TMVH_LIPP6100ETH_FMFLTR_RX_ALL_VAL (0x80000000U)
+#define TMVH_LIPP6100ETH_FMFLTR_RX_ALL_POS (31)
+
+#define TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_VAL (0x400U)
+#define TMVH_LIPP6100ETH_FMFLTR_HASH_N_PER_EN_POS (10)
+
+#define TMVH_LIPP6100ETH_FMFLTR_SAF_VAL (0x200U)
+#define TMVH_LIPP6100ETH_FMFLTR_SAF_POS (9)
+
+#define TMVH_LIPP6100ETH_FMFLTR_SAIF_VAL (0x100U)
+#define TMVH_LIPP6100ETH_FMFLTR_SAIF_POS (8)
+
+#define TMVH_LIPP6100ETH_FMFLTR_PCF_POS (6)
+#define TMVH_LIPP6100ETH_FMFLTR_PCF_MSK (0xC0U)
+
+
+#define TMVH_LIPP6100ETH_FMFLTR_DBF_VAL (0x20U)
+#define TMVH_LIPP6100ETH_FMFLTR_DBF_POS (5)
+
+#define TMVH_LIPP6100ETH_FMFLTR_PM_VAL (0x10U)
+#define TMVH_LIPP6100ETH_FMFLTR_PM_POS (4)
+
+#define TMVH_LIPP6100ETH_FMFLTR_DAIF_VAL (0x8U)
+#define TMVH_LIPP6100ETH_FMFLTR_DAIF_POS (3)
+
+#define TMVH_LIPP6100ETH_FMFLTR_HMC_VAL (0x4U)
+#define TMVH_LIPP6100ETH_FMFLTR_HMC_POS (2)
+
+#define TMVH_LIPP6100ETH_FMFLTR_HUC_VAL (0x2U)
+#define TMVH_LIPP6100ETH_FMFLTR_HUC_POS (1)
+
+#define TMVH_LIPP6100ETH_FMFLTR_PR_VAL (0x1U)
+
+
+#define TMVH_LIPP6100ETH_HASHTBL_HIGH_REG_OFFSET (0x0008)
+#define TMVH_LIPP6100ETH_HASHTBL_LOW_REG_OFFSET (0x000C)
+
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_REG_OFFSET (0x0010)
+#define TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_CLR (0xffff07ffU)
+#define TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_MSK (0xF800)
+
+/* PHY address value is in  the configuraiton file */
+#define TMVH_LIPP6100ETH_GMII_PHY_ADDRESS_POS (11)
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_POS (2)
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_CLR (0xffffffe3U)
+#define TMVH_LIPP6100ETH_GMII_ADDRESS_CSR_MSK (0x1CU)
+/* CSR value is in the configuration file */
+
+#define TMVH_LIPP6100ETH_GMII_DATA_REG_OFFSET (0x0014)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_REG_OFFSET (0x0018)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_MSK (0xFFFF0000U)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PAUSET_POS (16)
+#define TMVH_LIPP6100ETH_FLOWCTRL_ZEROQ_VAL (0x40)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PLT_POS (4)
+#define TMVH_LIPP6100ETH_FLOWCTRL_PLT_MSK (0x30U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_UP_VAL (0x8U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_RFE_VAL (0x4U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_TFE_VAL (0x2U)
+
+#define TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_VAL (0x1U)
+#define TMVH_LIPP6100ETH_FLOWCTRL_FCBBPA_CLR (0xFFFFFFFEU)
+
+#define TMVH_LIPP6100ETH_VLANTAG_REG_OFFSET (0x001C)
+#define TMVH_LIPP6100ETH_VLANTAG_MASK (0xFFFFU)
+
+#define TMVH_LIPP6100ETH_VERSION_REG_OFFSET (0x0020)
+/*(0x0024) Reserved */
+#define TMVH_LIPP6100ETH_WKUP_FMFILTER_REG_OFFSET (0x0028)
+
+#define TMVH_LIPP6100ETH_WKUP_FMFILTER_RSTREG_VAL (0x80000000U)
+
+#if (TMFL_LIPP6100ETHSD_POWER || TMFL_SD_ALL)
+/* Power management register */
+#define TMVH_LIPP6100ETH_PWRMGMT_CTRLSTAT_REG_OFFSET (0x002C)
+#define TMVH_LIPP6100ETH_PWRMGMT_GU_VAL (0x200U)
+#define TMVH_LIPP6100ETH_PWRMGMT_WKUP_FM_EN_VAL (0x4U)
+#define TMVH_LIPP6100ETH_PWRMGMT_MAGIC_PKT_EN_VAL (0x2U)
+
+#define TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_VAL (0x1U)
+#define TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_MSK (0x1U)
+#define TMVH_LIPP6100ETH_PWRMGMT_POWERDN_EN_CLR (0xFFFFFFFEU)
+
+#define TMVH_LIPP6100ETH_POWER_ON (0x0U)
+#define TMVH_LIPP6100ETH_POWER_OFF (0x1U)
+
+#endif
+
+/* 0x30 to 0x34, reserved */
+
+/* Interrupt status register */
+#define TMVH_LIPP6100ETH_INTR_STATUS_REG_OFFSET (0x0038)
+
+/* Interrupt mask register */
+#define TMVH_LIPP6100ETH_INTR_MASK_REG_OFFSET (0x003C)
+
+/* Perfect filter registers */
+#define TMVH_LIPP6100ETH_ADDR0_HIGH_REG_OFFSET (0x0040)
+#define TMVH_LIPP6100ETH_ADDR0_HIGH_REG_MSK (0xFFFFU)
+#define TMVH_LIPP6100ETH_ADDR0_LOW_REG_OFFSET (0x0044)
+
+#define TMVH_LIPP6100ETH_ADDR_ENABLE_VAL (0x80000000U)
+#define TMVH_LIPP6100ETH_ADDR_SA_EN_VAL (0x40000000U)
+#define TMVH_LIPP6100ETH_ADDR_MBC_POS (24)
+#define TMVH_LIPP6100ETH_ADDR_MBC_MSK (0x3F000000U)
+#define TMVH_LIPP6100ETH_ADDR_MBC_CLR (0xc0ffffffU)
+#define TMVH_LIPP6100ETH_ADDR_HIGH_REG_MSK (0xFFFFU)
+
+#define TMVH_LIPP6100ETH_ADDR1_HIGH_REG_OFFSET (0x0048)
+#define TMVH_LIPP6100ETH_ADDR1_LOW_REG_OFFSET (0x004C)
+
+#define TMVH_LIPP6100ETH_ADDR2_HIGH_REG_OFFSET (0x0050)
+#define TMVH_LIPP6100ETH_ADDR2_LOW_REG_OFFSET (0x0054)
+
+#define TMVH_LIPP6100ETH_ADDR3_HIGH_REG_OFFSET (0x0058)
+#define TMVH_LIPP6100ETH_ADDR3_LOW_REG_OFFSET (0x005C)
+
+#define TMVH_LIPP6100ETH_ADDR4_HIGH_REG_OFFSET (0x0060)
+#define TMVH_LIPP6100ETH_ADDR4_LOW_REG_OFFSET (0x0064)
+
+#define TMVH_LIPP6100ETH_ADDR5_HIGH_REG_OFFSET (0x0068)
+#define TMVH_LIPP6100ETH_ADDR5_LOW_REG_OFFSET (0x006C)
+
+
+#define TMVH_LIPP6100ETH_ADDR6_HIGH_REG_OFFSET (0x0070)
+#define TMVH_LIPP6100ETH_ADDR6_LOW_REG_OFFSET (0x0074)
+
+#define TMVH_LIPP6100ETH_ADDR7_HIGH_REG_OFFSET (0x0078)
+#define TMVH_LIPP6100ETH_ADDR7_LOW_REG_OFFSET (0x007C)
+
+#define TMVH_LIPP6100ETH_ADDR8_HIGH_REG_OFFSET (0x0080)
+#define TMVH_LIPP6100ETH_ADDR8_LOW_REG_OFFSET (0x0084)
+
+#define TMVH_LIPP6100ETH_ADDR9_HIGH_REG_OFFSET (0x0088)
+#define TMVH_LIPP6100ETH_ADDR9_LOW_REG_OFFSET (0x008C)
+
+#define TMVH_LIPP6100ETH_ADDR10_HIGH_REG_OFFSET (0x0090)
+#define TMVH_LIPP6100ETH_ADDR10_LOW_REG_OFFSET (0x0094)
+
+
+#define TMVH_LIPP6100ETH_ADDR11_HIGH_REG_OFFSET (0x0098)
+#define TMVH_LIPP6100ETH_ADDR11_LOW_REG_OFFSET (0x009C)
+
+#define TMVH_LIPP6100ETH_ADDR12_HIGH_REG_OFFSET (0x00A0)
+#define TMVH_LIPP6100ETH_ADDR12_LOW_REG_OFFSET (0x00A4)
+
+#define TMVH_LIPP6100ETH_ADDR13_HIGH_REG_OFFSET (0x00A8)
+#define TMVH_LIPP6100ETH_ADDR13_LOW_REG_OFFSET (0x00AC)
+
+
+#define TMVH_LIPP6100ETH_ADDR14_HIGH_REG_OFFSET (0x00B0)
+#define TMVH_LIPP6100ETH_ADDR14_LOW_REG_OFFSET (0x00B4)
+
+#define TMVH_LIPP6100ETH_ADDR15_HIGH_REG_OFFSET (0x00B8)
+#define TMVH_LIPP6100ETH_ADDR15_LOW_REG_OFFSET (0x00BC)
+
+#define TMVH_LIPP6100ETH_ADDR16_HIGH_REG_OFFSET (0x0800)
+#define TMVH_LIPP6100ETH_ADDR16_LOW_REG_OFFSET (0x0804)
+
+
+/* Auto negotiation registers */
+#define TMVH_LIPP6100ETH_AN_CTRL_REG_OFFSET (0x00C0)
+#define TMVH_LIPP6100ETH_AN_STAT_REG_OFFSET (0x00C4)
+
+#define TMVH_LIPP6100ETH_AN_ADV_REG_OFFSET (0x00C8)
+#define TMVH_LIPP6100ETH_AN_LPA_REG_OFFSET (0x00CC)
+
+#define TMVH_LIPP6100ETH_AN_XPAN_REG_OFFSET (0x00D0)
+
+#define TMVH_LIPP6100ETH_TBI_EXTD_STAT_REG_OFFSET (0x00D4)
+#define TMVH_LIPP6100ETH_SGMII_RGMII_STAT_REG_OFFSET (0x00D8)
+
+
+/* DMA register offsets */
+#define TMVH_LIPP6100ETH_BUS_MODE_REG_OFFSET (0x1000)
+#define TMVH_LIPP6100ETH_BUS_MODE_4XPBL_VAL (0x1000000U)
+#define TMVH_LIPP6100ETH_BUS_MODE_SEPPBL_VAL (0x800000U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_RX_PBL_POS (17)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_AAL_VAL (0x2000000U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_FB_VAL (0x10000U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_PR_POS (14)
+#define TMVH_LIPP6100ETH_BUS_MODE_PBL_POS (8)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_DSL_POS (2)
+#define TMVH_LIPP6100ETH_BUS_MODE_DSL_MSK (0x7CU)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_DA_VAL (0x2U)
+
+#define TMVH_LIPP6100ETH_BUS_MODE_RESET_VAL (0x1U)
+
+#define TMVH_LIPP6100ETH_TXMT_DMD_REG_OFFSET (0x1004)
+#define TMVH_LIPP6100ETH_RECV_DMD_REG_OFFSET (0x1008)
+
+#define TMVH_LIPP6100ETH_RXDESC_LISTADDR_REG_OFFSET (0x100C) 
+
+#define TMVH_LIPP6100ETH_TXDESC_LISTADDR_REG_OFFSET (0x1010) 
+
+#define TMVH_LIPP6100ETH_DMA_STATUS_REG_OFFSET (0x1014) 
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_REG_OFFSET (0x1018) 
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_DT_VAL (0x4000000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RSF_VAL (0x2000000U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_FRM_FLUSH_DIS_VAL (0x1000000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_VAL (0x2000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TX_EN_CLR (0xFFFFDFFFU)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_VAL (0x2U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RX_EN_CLR (0xFFFFFFFDU)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_SF_VAL (0x200000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_FTF_VAL (0x100000U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_TTC_POS (14)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TTC_MSK (0x1C000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_TTC_CLR (0xFFFE3FFFU)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD_POS (11)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD2_POS (22)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD2_VAL (0x400000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD_MSK (0x1800U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFD_CLR (0xFFFFE7FFU)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA_POS (9)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA2_POS (23)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA2_VAL (0x800000U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA_MSK (0x600U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RFA_CLR (0xFFFFF9FFU)
+#define TMVH_LIPP6100ETH_OPERN_MODE_MSB_CLR (0xFFFFFFFBU)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_EFC_VAL (0x100U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_FEF_VAL (0x80U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_FUF_VAL (0x40U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_RTC_POS (3)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RTC_MSK (0x18U)
+#define TMVH_LIPP6100ETH_OPERN_MODE_RTC_CLR (0xFFFFFFE7U)
+
+#define TMVH_LIPP6100ETH_OPERN_MODE_OSF_VAL (0x4U)
+
+#define TMVH_LIPP6100ETH_DMA_INT_ENABLE_REG_OFFSET (0x101C)
+
+/*
+Offsets 0x1024 to 0x1044 are reserved.
+*/
+#if (TMFL_LIPP6100ETHSD_OTHERS || TMFL_SD_ALL)
+
+#define TMVH_LIPP6100ETH_MISSFR_BUFOVRFLOW_CNT_REG_OFFSET (0x1020)
+#define TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_POS (17)
+#define TMVH_LIPP6100ETH_MISSFR_FIFO_CNT_MSK (0xffe0000U)
+#define TMVH_LIPP6100ETH_MISSFR_BUF_CNT_MSK (0xFFFF)
+
+#define TMVH_LIPP6100ETH_CUR_HOST_TX_DESC_REG_OFFSET (0x1048)
+#define TMVH_LIPP6100ETH_CUR_HOST_RX_DESC_REG_OFFSET (0x104C)
+
+#define TMVH_LIPP6100ETH_CUR_HOST_TXBUFADR_REG_OFFSET (0x1050)
+#define TMVH_LIPP6100ETH_CUR_HOST_RXBUFADR_REG_OFFSET (0x1054)
+
+#endif
+
+#if (TMFL_LIPP6100ETHSD_MMC || TMFL_SD_ALL)
+/* Mac Management Counter register offsets */
+#define TMVH_LIPP6100ETH_MMC_CTRL_REG_OFFSET (0x100)
+#define TMVH_LIPP6100ETH_MMC_CTRL_CNTR_FREZ_VAL (0x8U)
+#define TMVH_LIPP6100ETH_MMC_CTRL_CNTR_RESET_VAL (0x1U)
+#define TMVH_LIPP6100ETH_MMC_CTRL_RESET_ON_RD_VAL (0x4U)
+#define TMVH_LIPP6100ETH_MMC_CTRL_STOP_ROLLOVER_VAL (0x2U)
+
+#define TMVH_LIPP6100ETH_MMC_INTR_RX_REG_OFFSET (0x104)
+#define TMVH_LIPP6100ETH_MMC_INTR_TX_REG_OFFSET (0x108)
+
+#define TMVH_LIPP6100ETH_MMC_INTR_TXMASK_REG_OFFSET (0x10C)
+#define TMVH_LIPP6100ETH_MMC_INTR_RXMASK_REG_OFFSET (0x110)
+
+/* Counters  on Transmission side */
+
+#define TMVH_LIPP6100ETH_MMC_TXOCTET_CNT_GB_REG_OFFSET (0x114)
+
+#define TMVH_LIPP6100ETH_MMC_TXFRAME_CNT_GB_REG_OFFSET (0x118)
+
+#define TMVH_LIPP6100ETH_MMC_TXBRDCST_CNT_G_REG_OFFSET (0x11C)
+
+#define TMVH_LIPP6100ETH_MMC_TXMULTCST_CNT_G_REG_OFFSET (0x120)
+
+#define TMVH_LIPP6100ETH_MMC_TX64_GB_REG_OFFSET (0x124)
+
+#define TMVH_LIPP6100ETH_MMC_TX65TO127_GB_REG_OFFSET (0x128)
+
+#define TMVH_LIPP6100ETH_MMC_TX128TO255_GB_REG_OFFSET (0x12C)
+
+#define TMVH_LIPP6100ETH_MMC_TX256TO511_GB_REG_OFFSET (0x130)
+
+#define TMVH_LIPP6100ETH_MMC_TX512TO1023_GB_REG_OFFSET (0x134)
+
+#define TMVH_LIPP6100ETH_MMC_TX1024TOMAX_GB_REG_OFFSET (0x138)
+
+#define TMVH_LIPP6100ETH_MMC_TX_UNICAST_GB_REG_OFFSET (0x13C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_MULTCST_GB_REG_OFFSET (0x140)
+
+#define TMVH_LIPP6100ETH_MMC_TX_BRDCST_GB_REG_OFFSET (0x144)
+
+#define TMVH_LIPP6100ETH_MMC_TX_UNNDERFLOW_ERR_REG_OFFSET (0x148)
+
+#define TMVH_LIPP6100ETH_MMC_TX_SINGLCOL_G_REG_OFFSET (0x14C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_MULTICOL_G_REG_OFFSET (0x150)
+
+#define TMVH_LIPP6100ETH_MMC_TX_DEFERRED_REG_OFFSET (0x154)
+
+#define TMVH_LIPP6100ETH_MMC_TX_LATECOL_REG_OFFSET (0x158)
+
+#define TMVH_LIPP6100ETH_MMC_TX_EXCESSCOL_REG_OFFSET (0x15C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_CARRIER_ERR_REG_OFFSET (0x160)
+
+#define TMVH_LIPP6100ETH_MMC_TX_OCTET_CNT_G_REG_OFFSET (0x164)
+
+#define TMVH_LIPP6100ETH_MMC_TX_FRM_CNT_G_REG_OFFSET (0x168)
+
+#define TMVH_LIPP6100ETH_MMC_TX_EXCESS_DEF_REG_OFFSET (0x16C)
+
+#define TMVH_LIPP6100ETH_MMC_TX_PAUSE_FRAMES_REG_OFFSET (0x170)
+
+#define TMVH_LIPP6100ETH_MMC_TX_VLAN_FRAMES_G_REG_OFFSET (0x174)
+
+/*
+0x1078 --0x107C reserved
+*/
+
+/* Received frames */
+#define TMVH_LIPP6100ETH_MMC_RXFRM_CNT_GB_REG_OFFSET (0x180)
+#define TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_GB_REG_OFFSET (0x184)
+#define TMVH_LIPP6100ETH_MMC_RXOCTET_CNT_G_REG_OFFSET (0x188)
+
+#define TMVH_LIPP6100ETH_MMC_RX_BRDCSTF_G_REG_OFFSET (0x18C)
+
+#define TMVH_LIPP6100ETH_MMC_RX_MULTCSTF_G_REG_OFFSET (0x190)
+
+#define TMVH_LIPP6100ETH_MMC_RX_CRC_ERR_REG_OFFSET (0x194)
+
+#define TMVH_LIPP6100ETH_MMC_RX_ALIGNMT_ERR_REG_OFFSET (0x198)
+
+#define TMVH_LIPP6100ETH_MMC_RX_RUNT_ERR_REG_OFFSET (0x19C)
+
+#define TMVH_LIPP6100ETH_MMC_RX_JABBER_ERR_REG_OFFSET (0x1A0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_UNDERSIZE_G_REG_OFFSET (0x1A4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_OVERSIZE_G_REG_OFFSET (0x1A8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_64_GB_REG_OFFSET (0x1AC)
+
+#define TMVH_LIPP6100ETH_MMC_RX_65TO127_GB_REG_OFFSET (0x1B0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_128TO255_GB_REG_OFFSET (0x1B4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_256TO511_GB_REG_OFFSET (0x1B8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_512TO1023_GB_REG_OFFSET (0x1BC)
+
+#define TMVH_LIPP6100ETH_MMC_RX_1024TOMAX_GB_REG_OFFSET (0x1C0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_UNICAST_G_REG_OFFSET (0x1C4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_LEN_ERR_REG_OFFSET (0x1C8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_OUTOFRANGE_REG_OFFSET (0x1CC)
+
+#define TMVH_LIPP6100ETH_MMC_RX_PAUSE_REG_OFFSET (0x1D0)
+
+#define TMVH_LIPP6100ETH_MMC_RX_FIFO_OVERFLOW_REG_OFFSET (0x1D4)
+
+#define TMVH_LIPP6100ETH_MMC_RX_VLAN_FRAMES_GB_REG_OFFSET (0x1D8)
+
+#define TMVH_LIPP6100ETH_MMC_RX_WATCHDOG_ERR_REG_OFFSET (0x1DC)
+
+
+/* IPv4, IPv6, TCP, UDP, ICMP statistics counters */
+
+/* 0x01E0 -- 0x01FC reserved */
+
+#define TMVH_LIPP6100ETH_MMC_IPC_INTMASK_REG_OFFSET (0x200)
+
+/* 0x204  reserved */
+
+#define TMVH_LIPP6100ETH_MMC_IPC_INT_REG_OFFSET (0x208)
+
+/* 0x020C reserved */
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_GD_FRMS_REG_OFFSET (0x210)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_HDERR_FRMS_REG_OFFSET (0x214)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_FRMS_REG_OFFSET (0x218)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_FRMS_REG_OFFSET (0x21C)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_FRMS_REG_OFFSET (0x220)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_GD_FRMS_REG_OFFSET (0x224)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_HDERR_FRMS_REG_OFFSET (0x228)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_FRMS_REG_OFFSET (0x22C)
+
+#define TMVH_LIPP6100ETH_MMC_RXUDP_GD_FRMS_REG_OFFSET (0x230)
+#define TMVH_LIPP6100ETH_MMC_RXUDP_ERR_FRMS_REG_OFFSET (0x234)
+
+#define TMVH_LIPP6100ETH_MMC_RXTCP_GD_FRMS_REG_OFFSET (0x238)
+#define TMVH_LIPP6100ETH_MMC_RXTCP_ERR_FRMS_REG_OFFSET (0x23C)
+
+#define TMVH_LIPP6100ETH_MMC_RXICMP_GD_FRMS_REG_OFFSET (0x240)
+#define TMVH_LIPP6100ETH_MMC_RXICMP_ERR_FRMS_REG_OFFSET (0x244)
+
+/* 0x248 -- 0x24C reserved */
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_GD_OCTETS_REG_OFFSET (0x250)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_HDRERR_OCTETS_REG_OFFSET (0x254)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_NOPAY_OCTETS_REG_OFFSET (0x258)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_FRAG_OCTETS_REG_OFFSET (0x25C)
+#define TMVH_LIPP6100ETH_MMC_RXIPV4_UDSBL_OCTECTS_REG_OFFSET (0x260)
+
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_GD_OCTETS_REG_OFFSET (0x264)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_HDRERR_OCTETS_REG_OFFSET (0x268)
+#define TMVH_LIPP6100ETH_MMC_RXIPV6_NOPAY_OCTETS_REG_OFFSET (0x26C)
+
+#define TMVH_LIPP6100ETH_MMC_RXUDP_GD_OCTETS_REG_OFFSET (0x270)
+#define TMVH_LIPP6100ETH_MMC_RXUDP_ERR_OCTETS_REG_OFFSET (0x274)
+
+#define TMVH_LIPP6100ETH_MMC_TCP_GD_OCTETS_REG_OFFSET (0x278)
+#define TMVH_LIPP6100ETH_MMC_TCP_ERR_OCTETS_REG_OFFSET (0x27C)
+
+#define TMVH_LIPP6100ETH_MMC_ICMP_GD_OCTETS_REG_OFFSET (0x280)
+#define TMVH_LIPP6100ETH_MMC_ICMP_ERR_OCTETS_REG_OFFSET (0x284)
+#endif
+
+#if (TMFL_LIPP6100ETHSD_IEEE1588_TIMESTAMP || TMFL_SD_ALL)
+/* IEEE 1588  Time stamp registers */
+#define TMVH_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_VAL (0x20U)
+#define TMVH_LIPP6100ETH_TS_CTRL_ADDEND_UPDT_POS (5)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_INT_TRIG_VAL (0x10U)
+#define TMVH_LIPP6100ETH_TS_CTRL_INT_TRIG_POS (4)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_UPDATE_VAL (0x8U)
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_UPDATE_POS (3)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_INIT_VAL (0x4U)
+#define TMVH_LIPP6100ETH_TS_CTRL_TS_INIT_POS (2)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_FINE_UPDATE_VAL (0x2U)
+#define TMVH_LIPP6100ETH_TS_CTRL_FINE_UPDATE_POS (1)
+
+#define TMVH_LIPP6100ETH_TS_CTRL_TIMESTAMP_EN_VAL (0x1U)
+#define TMVH_LIPP6100ETH_TS_CTRL_REG_OFFSET (0x700)
+
+#define TMVH_LIPP6100ETH_TS_SUB_SECOND_INCR_REG_OFFSET (0x704)
+#define TMVH_LIPP6100ETH_TS_HIGH_REG_OFFSET (0x708)
+#define TMVH_LIPP6100ETH_TS_LOW_REG_OFFSET (0x70C)
+
+#define TMVH_LIPP6100ETH_TS_HIGH_UPDATE_REG_OFFSET (0x710)
+
+#define TMVH_LIPP6100ETH_TS_LOW_UPDATE_PSNT_VAL (0x80000000U)
+#define TMVH_LIPP6100ETH_TS_LOW_UPDATE_REG_OFFSET (0x714)
+
+#define TMVH_LIPP6100ETH_TS_ADDEND_REG_OFFSET (0x718)
+
+#define TMVH_LIPP6100ETH_TS_TGT_TIME_HIGH_REG_OFFSET (0x71C)
+#define TMVH_LIPP6100ETH_TS_TGT_TIME_LOW_REG_OFFSET (0x720)
+
+#endif
+
+/* Macro to compute perfect address filter register offset value */
+#define TMVH_LIPP6100ETH_PERADRBLK1_OFFSET(_regnum_) (((_regnum_)-1)*8) 
+#define TMVH_LIPP6100ETH_PERADRBLK2_OFFSET(_regnum_) (((_regnum_)-16)*8) 
+
+/* Register Read Write Macro's  */
+
+#ifndef TMVH_GEN_READ
+
+#define TMVH_GEN_READ(_address_,_result_)                                          \
+            (_result_) = *(volatile UInt32 *)(_address_)
+#endif
+
+#ifndef TMVH_GEN_WRITE
+
+#define TMVH_GEN_WRITE(_address_,_value_)                                          \
+           *(volatile UInt32 *)(_address_) = (_value_)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif 
+
+
diff --git a/drivers/serial/ns16550.c b/drivers/serial/ns16550.c
index 2fcc8c3..4c71a1a 100644
--- a/drivers/serial/ns16550.c
+++ b/drivers/serial/ns16550.c
@@ -6,14 +6,18 @@
 
 #include <config.h>
 #include <ns16550.h>
-
-#define UART_LCRVAL UART_LCR_8N1		/* 8 data, 1 stop, no parity */
+#ifdef  CONFIG_PNX_VPE
+#define UART_LCRVAL UART_LCR_8N1			/* 8 data, 1 stop, no parity */
+#define UART_MCRVAL 0
+#define UART_FCRVAL UART_FCR_FIFO_EN       	/* do not Clear &  not enable FIFOs */
+#else
+#define UART_LCRVAL UART_LCR_8N1			/* 8 data, 1 stop, no parity */
 #define UART_MCRVAL (UART_MCR_DTR | \
-		     UART_MCR_RTS)		/* RTS/DTR */
+		     UART_MCR_RTS)					/* RTS/DTR */
 #define UART_FCRVAL (UART_FCR_FIFO_EN |	\
 		     UART_FCR_RXSR |	\
-		     UART_FCR_TXSR)		/* Clear & enable FIFOs */
-
+		     UART_FCR_TXSR)					/* Clear & enable FIFOs */
+#endif
 void NS16550_init (NS16550_t com_port, int baud_divisor)
 {
 	com_port->ier = 0x00;
@@ -30,6 +34,9 @@ void NS16550_init (NS16550_t com_port, int baud_divisor)
 	com_port->dll = baud_divisor & 0xff;
 	com_port->dlm = (baud_divisor >> 8) & 0xff;
 	com_port->lcr = UART_LCRVAL;
+#if defined(CONFIG_PNX84XX)
+	com_port->regD = 0;   /* make sure that UART is in normal mode */
+#endif
 #if defined(CONFIG_OMAP) && !defined(CONFIG_OMAP3_ZOOM2)
 #if defined(CONFIG_APTIX)
 	com_port->mdr1 = 3;	/* /13 mode so Aptix 6MHz can hit 115200 */
@@ -62,6 +69,18 @@ void NS16550_putc (NS16550_t com_port, char c)
 	com_port->thr = c;
 }
 
+#ifdef  CONFIG_PNX_VPE
+/******************************************************************************
+ * Routine: delay
+ * Description: spinning delay to use before udelay works
+ *****************************************************************************/
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b":"=r" (loops):"0"(loops));
+}
+#endif
+
 #ifndef CONFIG_NS16550_MIN_FUNCTIONS
 char NS16550_getc (NS16550_t com_port)
 {
@@ -70,6 +89,10 @@ char NS16550_getc (NS16550_t com_port)
 		extern void usbtty_poll(void);
 		usbtty_poll();
 #endif
+#ifdef  CONFIG_PNX_VPE
+		delay(100);
+#endif
+
 	}
 	return (com_port->rbr);
 }
diff --git a/drivers/serial/serial.c b/drivers/serial/serial.c
index dd5f332..f1f6945 100644
--- a/drivers/serial/serial.c
+++ b/drivers/serial/serial.c
@@ -140,6 +140,14 @@ static int calc_divisor (NS16550_t port)
 	}
 #endif
 
+#ifdef CONFIG_PNX84XX
+	/* baudrate cannot be set cleanly to 4800 baud so */
+	if ( gd->baudrate == 4800) {
+		port->regA = 0x10; 				/* fractional divider is set to 1 */
+		port->regB = 0x2e;				/* Oversampling is set to 46 */
+		return (1);						/* return 1 for base divisor */
+	}
+#endif
 #ifdef CONFIG_APTIX
 #define MODE_X_DIV 13
 #else
diff --git a/fs/ubifs/.svn/all-wcprops b/fs/ubifs/.svn/all-wcprops
new file mode 100644
index 0000000..152d4a9
--- /dev/null
+++ b/fs/ubifs/.svn/all-wcprops
@@ -0,0 +1,161 @@
+K 25
+svn:wc:ra_dav:version-url
+V 57
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs
+END
+super.c
+K 25
+svn:wc:ra_dav:version-url
+V 65
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/super.c
+END
+recovery.c
+K 25
+svn:wc:ra_dav:version-url
+V 68
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/recovery.c
+END
+tnc_misc.c
+K 25
+svn:wc:ra_dav:version-url
+V 68
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/tnc_misc.c
+END
+lpt.c
+K 25
+svn:wc:ra_dav:version-url
+V 63
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/lpt.c
+END
+misc.h
+K 25
+svn:wc:ra_dav:version-url
+V 64
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/misc.h
+END
+sb.c
+K 25
+svn:wc:ra_dav:version-url
+V 62
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/sb.c
+END
+io.c
+K 25
+svn:wc:ra_dav:version-url
+V 62
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/io.c
+END
+lpt_commit.c
+K 25
+svn:wc:ra_dav:version-url
+V 70
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/lpt_commit.c
+END
+ubifs.c
+K 25
+svn:wc:ra_dav:version-url
+V 65
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/ubifs.c
+END
+budget.c
+K 25
+svn:wc:ra_dav:version-url
+V 66
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/budget.c
+END
+ubifs.h
+K 25
+svn:wc:ra_dav:version-url
+V 65
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/ubifs.h
+END
+crc16.c
+K 25
+svn:wc:ra_dav:version-url
+V 65
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/crc16.c
+END
+lprops.c
+K 25
+svn:wc:ra_dav:version-url
+V 66
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/lprops.c
+END
+log.c
+K 25
+svn:wc:ra_dav:version-url
+V 63
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/log.c
+END
+crc16.h
+K 25
+svn:wc:ra_dav:version-url
+V 65
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/crc16.h
+END
+scan.c
+K 25
+svn:wc:ra_dav:version-url
+V 64
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/scan.c
+END
+tnc.c
+K 25
+svn:wc:ra_dav:version-url
+V 63
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/tnc.c
+END
+debug.c
+K 25
+svn:wc:ra_dav:version-url
+V 65
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/debug.c
+END
+orphan.c
+K 25
+svn:wc:ra_dav:version-url
+V 66
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/orphan.c
+END
+ubifs-media.h
+K 25
+svn:wc:ra_dav:version-url
+V 71
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/ubifs-media.h
+END
+master.c
+K 25
+svn:wc:ra_dav:version-url
+V 66
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/master.c
+END
+debug.h
+K 25
+svn:wc:ra_dav:version-url
+V 65
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/debug.h
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 66
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/Makefile
+END
+replay.c
+K 25
+svn:wc:ra_dav:version-url
+V 66
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/replay.c
+END
+tnc_commit.c
+K 25
+svn:wc:ra_dav:version-url
+V 70
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/tnc_commit.c
+END
+key.h
+K 25
+svn:wc:ra_dav:version-url
+V 63
+/svn/uboot/!svn/ver/207/branches/pnx8xxx-2009.01/fs/ubifs/key.h
+END
diff --git a/fs/ubifs/crc16.h b/fs/ubifs/crc16.h
index 052fd33..29f1226 100644
--- a/fs/ubifs/crc16.h
+++ b/fs/ubifs/crc16.h
@@ -27,3 +27,5 @@ static inline u16 crc16_byte(u16 crc, const u8 data)
 }
 
 #endif /* __CRC16_H */
+
+
diff --git a/fs/ubifs/lpt.c b/fs/ubifs/lpt.c
index 1a50d4c..657a518 100644
--- a/fs/ubifs/lpt.c
+++ b/fs/ubifs/lpt.c
@@ -46,6 +46,7 @@
 #include "ubifs.h"
 #include "crc16.h"
 #include <linux/math64.h>
+#include <asm/bitops.h>
 
 /**
  * do_calc_lpt_geom - calculate sizes for the LPT area.
diff --git a/fs/ubifs/super.c b/fs/ubifs/super.c
index 391dea4..05b768d 100644
--- a/fs/ubifs/super.c
+++ b/fs/ubifs/super.c
@@ -28,6 +28,7 @@
 
 #include "ubifs.h"
 #include <linux/math64.h>
+#include <asm/bitops.h>
 
 #define INODE_LOCKED_MAX	64
 
diff --git a/fs/ubifs/ubifs.h b/fs/ubifs/ubifs.h
index 43865aa..dd8f86a 100644
--- a/fs/ubifs/ubifs.h
+++ b/fs/ubifs/ubifs.h
@@ -454,6 +454,7 @@ static inline ino_t parent_ino(struct dentry *dentry)
 #define BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_LONG))
 #define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
 
+
 /* linux/include/asm-generic/bitops/non-atomic.h */
 
 /**
@@ -481,6 +482,7 @@ static inline void __clear_bit(int nr, volatile unsigned long *addr)
 	*p &= ~mask;
 }
 
+
 /* debug.c */
 
 #define DEFINE_SPINLOCK(...)
diff --git a/include/asm-arm/arch-pnx84xx/clocks.h b/include/asm-arm/arch-pnx84xx/clocks.h
new file mode 100644
index 0000000..71a0cb6
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/clocks.h
@@ -0,0 +1,62 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_H_
+#define _CLOCKS_H_
+
+#define LDELAY		12000000
+
+#define S12M		12000000
+#define S13M		13000000
+#define S19_2M		19200000
+#define S24M		24000000
+#define S26M		26000000
+#define S38_4M		38400000
+
+#define FCK_IVA2_ON	0x00000001
+#define FCK_CORE1_ON	0x03fffe29
+#define ICK_CORE1_ON	0x3ffffffb
+#define ICK_CORE2_ON	0x0000001f
+#define FCK_WKUP_ON	0x000000e9
+#define ICK_WKUP_ON	0x0000003f
+#define FCK_DSS_ON	0x00000005
+#define ICK_DSS_ON	0x00000001
+#define FCK_CAM_ON	0x00000001
+#define ICK_CAM_ON	0x00000001
+#define FCK_PER_ON	0x0003ffff
+#define ICK_PER_ON	0x0003ffff
+
+/* Used to index into DPLL parameter tables */
+typedef struct {
+	unsigned int m;
+	unsigned int n;
+	unsigned int fsel;
+	unsigned int m2;
+} dpll_param;
+
+/* Following functions are exported from lowlevel_init.S */
+extern dpll_param *get_mpu_dpll_param(void);
+extern dpll_param *get_iva_dpll_param(void);
+extern dpll_param *get_core_dpll_param(void);
+extern dpll_param *get_per_dpll_param(void);
+
+extern void *_end_vect, *_start;
+
+#endif
diff --git a/include/asm-arm/arch-pnx84xx/clocks_omap3.h b/include/asm-arm/arch-pnx84xx/clocks_omap3.h
new file mode 100644
index 0000000..661407b
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/clocks_omap3.h
@@ -0,0 +1,285 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _CLOCKS_OMAP3_H_
+#define _CLOCKS_OMAP3_H_
+
+#define PLL_STOP		1	/* PER & IVA */
+#define PLL_LOW_POWER_BYPASS	5	/* MPU, IVA & CORE */
+#define PLL_FAST_RELOCK_BYPASS	6	/* CORE */
+#define PLL_LOCK		7	/* MPU, IVA, CORE & PER */
+
+/*
+ * The following configurations are OPP and SysClk value independant
+ * and hence are defined here. All the other DPLL related values are
+ * tabulated in lowlevel_init.S.
+ */
+
+/* CORE DPLL */
+#define CORE_M3X2	2	/* 332MHz : CM_CLKSEL1_EMU */
+#define CORE_SSI_DIV	3	/* 221MHz : CM_CLKSEL_CORE */
+#define CORE_FUSB_DIV	2	/* 41.5MHz: */
+#define CORE_L4_DIV	2	/* 83MHz  : L4 */
+#define CORE_L3_DIV	2	/* 166MHz : L3 {DDR} */
+#define GFX_DIV		2	/* 83MHz  : CM_CLKSEL_GFX */
+#define WKUP_RSM	2	/* 41.5MHz: CM_CLKSEL_WKUP */
+
+/* PER DPLL */
+#define PER_M6X2	3	/* 288MHz: CM_CLKSEL1_EMU */
+#define PER_M5X2	4	/* 216MHz: CM_CLKSEL_CAM */
+#define PER_M4X2	2	/* 432MHz: CM_CLKSEL_DSS-dss1 */
+#define PER_M3X2	16	/* 54MHz : CM_CLKSEL_DSS-tv */
+
+#define CLSEL1_EMU_VAL ((CORE_M3X2 << 16) | (PER_M6X2 << 24) | (0x0A50))
+
+/* MPU DPLL */
+
+#define MPU_M_12_ES1		0x0FE
+#define MPU_N_12_ES1		0x07
+#define MPU_FSEL_12_ES1		0x05
+#define MPU_M2_12_ES1		0x01
+
+#define MPU_M_12_ES2		0x0FA
+#define MPU_N_12_ES2		0x05
+#define MPU_FSEL_12_ES2		0x07
+#define MPU_M2_ES2		0x01
+
+#define MPU_M_12		0x085
+#define MPU_N_12		0x05
+#define MPU_FSEL_12		0x07
+#define MPU_M2_12		0x01
+
+#define MPU_M_13_ES1		0x17D
+#define MPU_N_13_ES1		0x0C
+#define MPU_FSEL_13_ES1		0x03
+#define MPU_M2_13_ES1		0x01
+
+#define MPU_M_13_ES2		0x1F4
+#define MPU_N_13_ES2		0x0C
+#define MPU_FSEL_13_ES2		0x03
+#define MPU_M2_13_ES2		0x01
+
+#define MPU_M_13		0x10A
+#define MPU_N_13		0x0C
+#define MPU_FSEL_13		0x03
+#define MPU_M2_13		0x01
+
+#define MPU_M_19P2_ES1		0x179
+#define MPU_N_19P2_ES1		0x12
+#define MPU_FSEL_19P2_ES1	0x04
+#define MPU_M2_19P2_ES1		0x01
+
+#define MPU_M_19P2_ES2		0x271
+#define MPU_N_19P2_ES2		0x17
+#define MPU_FSEL_19P2_ES2	0x03
+#define MPU_M2_19P2_ES2		0x01
+
+#define MPU_M_19P2		0x14C
+#define MPU_N_19P2		0x17
+#define MPU_FSEL_19P2		0x03
+#define MPU_M2_19P2		0x01
+
+#define MPU_M_26_ES1		0x17D
+#define MPU_N_26_ES1		0x19
+#define MPU_FSEL_26_ES1		0x03
+#define MPU_M2_26_ES1		0x01
+
+#define MPU_M_26_ES2		0x0FA
+#define MPU_N_26_ES2		0x0C
+#define MPU_FSEL_26_ES2		0x07
+#define MPU_M2_26_ES2		0x01
+
+#define MPU_M_26		0x085
+#define MPU_N_26		0x0C
+#define MPU_FSEL_26		0x07
+#define MPU_M2_26		0x01
+
+#define MPU_M_38P4_ES1		0x1FA
+#define MPU_N_38P4_ES1		0x32
+#define MPU_FSEL_38P4_ES1	0x03
+#define MPU_M2_38P4_ES1		0x01
+
+#define MPU_M_38P4_ES2		0x271
+#define MPU_N_38P4_ES2		0x2F
+#define MPU_FSEL_38P4_ES2	0x03
+#define MPU_M2_38P4_ES2		0x01
+
+#define MPU_M_38P4		0x14C
+#define MPU_N_38P4		0x2F
+#define MPU_FSEL_38P4		0x03
+#define MPU_M2_38P4		0x01
+
+/* IVA DPLL */
+
+#define IVA_M_12_ES1		0x07D
+#define IVA_N_12_ES1		0x05
+#define IVA_FSEL_12_ES1		0x07
+#define IVA_M2_12_ES1		0x01
+
+#define IVA_M_12_ES2		0x0B4
+#define IVA_N_12_ES2		0x05
+#define IVA_FSEL_12_ES2		0x07
+#define IVA_M2_12_ES2		0x01
+
+#define IVA_M_12		0x085
+#define IVA_N_12		0x05
+#define IVA_FSEL_12		0x07
+#define IVA_M2_12		0x01
+
+#define IVA_M_13_ES1		0x0FA
+#define IVA_N_13_ES1		0x0C
+#define IVA_FSEL_13_ES1		0x03
+#define IVA_M2_13_ES1		0x01
+
+#define IVA_M_13_ES2		0x168
+#define IVA_N_13_ES2		0x0C
+#define IVA_FSEL_13_ES2		0x03
+#define IVA_M2_13_ES2		0x01
+
+#define IVA_M_13		0x10A
+#define IVA_N_13		0x0C
+#define IVA_FSEL_13		0x03
+#define IVA_M2_13		0x01
+
+#define IVA_M_19P2_ES1		0x082
+#define IVA_N_19P2_ES1		0x09
+#define IVA_FSEL_19P2_ES1	0x07
+#define IVA_M2_19P2_ES1		0x01
+
+#define IVA_M_19P2_ES2		0x0E1
+#define IVA_N_19P2_ES2		0x0B
+#define IVA_FSEL_19P2_ES2	0x06
+#define IVA_M2_19P2_ES2		0x01
+
+#define IVA_M_19P2		0x14C
+#define IVA_N_19P2		0x17
+#define IVA_FSEL_19P2		0x03
+#define IVA_M2_19P2		0x01
+
+#define IVA_M_26_ES1		0x07D
+#define IVA_N_26_ES1		0x0C
+#define IVA_FSEL_26_ES1		0x07
+#define IVA_M2_26_ES1		0x01
+
+#define IVA_M_26_ES2		0x0B4
+#define IVA_N_26_ES2		0x0C
+#define IVA_FSEL_26_ES2		0x07
+#define IVA_M2_26_ES2		0x01
+
+#define IVA_M_26		0x085
+#define IVA_N_26		0x0C
+#define IVA_FSEL_26		0x07
+#define IVA_M2_26		0x01
+
+#define IVA_M_38P4_ES1		0x13F
+#define IVA_N_38P4_ES1		0x30
+#define IVA_FSEL_38P4_ES1	0x03
+#define IVA_M2_38P4_ES1		0x01
+
+#define IVA_M_38P4_ES2		0x0E1
+#define IVA_N_38P4_ES2		0x17
+#define IVA_FSEL_38P4_ES2	0x06
+#define IVA_M2_38P4_ES2		0x01
+
+#define IVA_M_38P4		0x14C
+#define IVA_N_38P4		0x2F
+#define IVA_FSEL_38P4		0x03
+#define IVA_M2_38P4		0x01
+
+/* CORE DPLL */
+
+#define CORE_M_12		0xA6
+#define CORE_N_12		0x05
+#define CORE_FSEL_12		0x07
+#define CORE_M2_12		0x01	/* M3 of 2 */
+
+#define CORE_M_12_ES1		0x19F
+#define CORE_N_12_ES1		0x0E
+#define CORE_FSL_12_ES1		0x03
+#define CORE_M2_12_ES1		0x1	/* M3 of 2 */
+
+#define CORE_M_13		0x14C
+#define CORE_N_13		0x0C
+#define CORE_FSEL_13		0x03
+#define CORE_M2_13		0x01	/* M3 of 2 */
+
+#define CORE_M_13_ES1		0x1B2
+#define CORE_N_13_ES1		0x10
+#define CORE_FSL_13_ES1		0x03
+#define CORE_M2_13_ES1		0x01	/* M3 of 2 */
+
+#define CORE_M_19P2		0x19F
+#define CORE_N_19P2		0x17
+#define CORE_FSEL_19P2		0x03
+#define CORE_M2_19P2		0x01	/* M3 of 2 */
+
+#define CORE_M_19P2_ES1		0x19F
+#define CORE_N_19P2_ES1		0x17
+#define CORE_FSL_19P2_ES1	0x03
+#define CORE_M2_19P2_ES1	0x01	/* M3 of 2 */
+
+#define CORE_M_26		0xA6
+#define CORE_N_26		0x0C
+#define CORE_FSEL_26		0x07
+#define CORE_M2_26		0x01	/* M3 of 2 */
+
+#define CORE_M_26_ES1		0x1B2
+#define CORE_N_26_ES1		0x21
+#define CORE_FSL_26_ES1		0x03
+#define CORE_M2_26_ES1		0x01	/* M3 of 2 */
+
+#define CORE_M_38P4		0x19F
+#define CORE_N_38P4		0x2F
+#define CORE_FSEL_38P4		0x03
+#define CORE_M2_38P4		0x01	/* M3 of 2 */
+
+#define CORE_M_38P4_ES1		0x19F
+#define CORE_N_38P4_ES1		0x2F
+#define CORE_FSL_38P4_ES1	0x03
+#define CORE_M2_38P4_ES1	0x01	/* M3 of 2 */
+
+/* PER DPLL */
+
+#define PER_M_12		0xD8
+#define PER_N_12		0x05
+#define PER_FSEL_12		0x07
+#define PER_M2_12		0x09
+
+#define PER_M_13		0x1B0
+#define PER_N_13		0x0C
+#define PER_FSEL_13		0x03
+#define PER_M2_13		0x09
+
+#define PER_M_19P2		0xE1
+#define PER_N_19P2		0x09
+#define PER_FSEL_19P2		0x07
+#define PER_M2_19P2		0x09
+
+#define PER_M_26		0xD8
+#define PER_N_26		0x0C
+#define PER_FSEL_26		0x07
+#define PER_M2_26		0x09
+
+#define PER_M_38P4		0xE1
+#define PER_N_38P4		0x13
+#define PER_FSEL_38P4		0x07
+#define PER_M2_38P4		0x09
+
+#endif	/* endif _CLOCKS_OMAP3_H_ */
diff --git a/include/asm-arm/arch-pnx84xx/cpu.h b/include/asm-arm/arch-pnx84xx/cpu.h
new file mode 100644
index 0000000..b74e3b7
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/cpu.h
@@ -0,0 +1,439 @@
+/*
+ * (C) Copyright 2009
+ * NXP Semiconductors, <www.nxp.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef _CPU_H
+#define _CPU_H
+
+/* Register offsets of common modules */
+
+
+/* cpu type */
+#define OMAP3503		0x5c00
+#define OMAP3515		0x1c00
+#define OMAP3525		0x4c00
+#define OMAP3530		0x0c00
+
+#ifndef __ASSEMBLY__
+typedef struct ctrl_id {
+	unsigned char res1[0x4];
+	unsigned int idcode;		/* 0x04 */
+	unsigned int prod_id;		/* 0x08 */
+	unsigned char res2[0x0C];
+	unsigned int die_id_0;		/* 0x18 */
+	unsigned int die_id_1;		/* 0x1C */
+	unsigned int die_id_2;		/* 0x20 */
+	unsigned int die_id_3;		/* 0x24 */
+} ctrl_id_t;
+#endif /* __ASSEMBLY__ */
+
+/* device type */
+#define DEVICE_MASK		(0x7 << 8)
+#define SYSBOOT_MASK		0x1F
+#define TST_DEVICE		0x0
+#define EMU_DEVICE		0x1
+#define HS_DEVICE		0x2
+#define GP_DEVICE		0x3
+
+/* GPMC CS3/cs4/cs6 not avaliable */
+#define GCS_BASE			(PNX84XX_GCS_BASE)
+#define GCS_CONFIG_CS0		0x60
+#define GCS_CONFIG_CS6		0x150
+#define GCS_CONFIG_CS0_BASE	(GCS_BASE + GCS_CONFIG_CS0)
+#define GCS_CONFIG_CS6_BASE	(GCS_BASE + GCS_CONFIG_CS6)
+#define GCS_CONFIG_WP		0x10
+
+#define GCS_CONFIG_WIDTH	0x30
+
+#ifndef __ASSEMBLY__
+typedef struct gcs {
+	unsigned int GCS_mode;				/* 0x00 */
+	unsigned int PCI_config;			/* 0x04 */
+	unsigned int flash_config;			/* 0x08 */
+	unsigned int dscn_nor_base;			/* 0x0c */
+	unsigned int dscn_nor_aperture;		/* 0x10 */
+	unsigned int dscn_sfc_base;			/* 0x14 */
+	unsigned int dscn_sfc_aperture;		/* 0x18 */
+	unsigned int dscn_isa_base;			/* 0x1c */
+	unsigned int dscn_isa_aperture;		/* 0x20 */
+	unsigned int dscn_nor_addr_remap;	/* 0x24 */
+	unsigned int dscn_sfc_addr_remap;	/* 0x28 */
+	unsigned int dscn_isa_addr_remap;	/* 0x2c */
+	unsigned int dma_nor_base;			/* 0x30 */
+	unsigned int dma_nor_aperture;		/* 0x34 */
+	unsigned int dma_nand_base;			/* 0x38 */
+	unsigned int dma_nand_aperture;		/* 0x3c */
+	unsigned int dma_sfc_base;			/* 0x40 */
+	unsigned int dma_sfc_aperture;		/* 0x44 */
+	unsigned int dma_isa_base;			/* 0x48 */
+	unsigned int dma_isa_aperture;		/* 0x4c */
+	unsigned int nor_cs_route;			/* 0x50 */
+	unsigned int nand_cs_route;			/* 0x54 */
+	unsigned int sfc_cs_route;			/* 0x58 */
+	unsigned int isa_cs_route;			/* 0x5c */
+	unsigned int stdio_cs_route;		/* 0x60 */
+	unsigned int gcs_clock_mux;			/* 0x64 */
+	unsigned int gcs_stdio_clock_mux;	/* 0x68 */
+	unsigned int stdio_hprot;			/* 0x6c */
+	unsigned int delay_mux;  			/* 0x70 */
+} gcs_config_t;
+
+typedef struct gcs_csx {
+	unsigned int config1;		/* 0x00 */
+	unsigned int config2;		/* 0x04 */
+	unsigned int config3;		/* 0x08 */
+	unsigned int config4;		/* 0x0C */
+	unsigned int config5;		/* 0x10 */
+	unsigned int config6;		/* 0x14 */
+	unsigned int config7;		/* 0x18 */
+	unsigned int nand_cmd;		/* 0x1C */
+	unsigned int nand_adr;		/* 0x20 */
+	unsigned int nand_dat;		/* 0x24 */
+} gcs_csx_t;
+#else /* __ASSEMBLY__ */
+#define GCS_CONFIG1		0x00
+#define GCS_CONFIG2		0x04
+#define GCS_CONFIG3		0x08
+#define GCS_CONFIG4		0x0C
+#define GCS_CONFIG5		0x10
+#define GCS_CONFIG6		0x14
+#define GCS_CONFIG7		0x18
+#endif /* __ASSEMBLY__ */
+
+/* GPMC Mapping */
+#define FLASH_BASE		0x10000000	/* NOR flash, */
+						/* aligned to 256 Meg */
+#define FLASH_BASE_SDPV1	0x04000000	/* NOR flash, */
+						/* aligned to 64 Meg */
+#define FLASH_BASE_SDPV2	0x10000000	/* NOR flash, */
+						/* aligned to 256 Meg */
+#define DEBUG_BASE		0x08000000	/* debug board */
+#define NAND_BASE		0x30000000	/* NAND addr */
+						/* (actual size small port) */
+#define PISMO2_BASE		0x18000000	/* PISMO2 CS1/2 */
+#define ONENAND_MAP		0x20000000	/* OneNand addr */
+						/* (actual size small port) */
+/* SMS */
+#ifndef __ASSEMBLY__
+typedef struct sms {
+	unsigned char res1[0x10];
+	unsigned int sysconfig;		/* 0x10 */
+	unsigned char res2[0x34];
+	unsigned int rg_att0;		/* 0x48 */
+	unsigned char res3[0x84];
+	unsigned int class_arb0;	/* 0xD0 */
+} sms_t;
+#endif /* __ASSEMBLY__ */
+
+#define BURSTCOMPLETE_GROUP7	(0x1 << 31)
+
+/* SDRC */
+#ifndef __ASSEMBLY__
+typedef struct sdrc_cs {
+	unsigned int mcfg;		/* 0x80 || 0xB0 */
+	unsigned int mr;		/* 0x84 || 0xB4 */
+	unsigned char res1[0x4];
+	unsigned int emr2;		/* 0x8C || 0xBC */
+	unsigned char res2[0x14];
+	unsigned int rfr_ctrl;		/* 0x84 || 0xD4 */
+	unsigned int manual;		/* 0xA8 || 0xD8 */
+	unsigned char res3[0x4];
+} sdrc_cs_t;
+
+typedef struct sdrc_actim {
+	unsigned int ctrla;		/* 0x9C || 0xC4 */
+	unsigned int ctrlb;		/* 0xA0 || 0xC8 */
+} sdrc_actim_t;
+
+typedef struct ip2035 {
+	unsigned int ctl;			/* 0x00 */
+	unsigned char res1[0xc];
+	unsigned int modeset;		/* 0x10 */
+	unsigned int modeget;		/* 0x14 */
+	unsigned char res2[0x10];
+	unsigned int command2;		/* 0x24 */
+	unsigned char res3[0x18];
+	unsigned int region1base;	/* 0x40 */
+	unsigned int region1mask;	/* 0x44 */
+	unsigned int region0map;	/* 0x48 */
+	unsigned int region1map;	/* 0x4c */
+	unsigned char res4[0x30];
+	unsigned int mode;			/* 0x80 */
+	unsigned int extmode1;		/* 0x84 */
+	unsigned int extmode2;		/* 0x88 */
+	unsigned int extmode3;		/* 0x8c */
+	unsigned char res5[0x30];
+	unsigned int rank0; 		/* 0xc0 */
+	unsigned char res6[0x2c];
+	unsigned int tim_trcd;		/* 0x100 */
+	unsigned int tim_trc;		/* 0x104 */
+	unsigned int tim_twtr;		/* 0x108 */
+	unsigned int tim_twr;		/* 0x10c */
+	unsigned int tim_trp;		/* 0x110 */
+	unsigned int tim_tras;		/* 0x114 */
+	unsigned char res7[004];
+	unsigned int tim_trrd;		/* 0x11c */
+	unsigned int tim_trfc;		/* 0x120 */
+	unsigned int tim_tmrd;		/* 0x124 */
+	unsigned int tim_ltcy;		/* 0x128 */
+	unsigned int refresh;		/* 0x12c */
+	unsigned int tim_trtw;		/* 0x130 */
+	unsigned int tim_trtp;		/* 0x134 */
+	unsigned char res8[0x4];
+	unsigned int tim_al;		/* 0x13c */
+	unsigned int tim_odt;		/* 0x140 */
+	unsigned char res9[0x8];
+	unsigned int tim_txsr;		/* 0x14c */
+	unsigned int tim_tcke;		/* 0x150 */
+	unsigned char res10[0x8c];
+	unsigned int tim_toit;		/* 0x1e0 */
+	unsigned char res11[0x1c];
+	unsigned char res12[0xdfc];
+	unsigned int modid;			/* 0xffc */
+} ip2035_t;
+#endif /* __ASSEMBLY__ */
+
+#define DLLPHASE_90		(0x1 << 1)
+#define LOADDLL			(0x1 << 2)
+#define ENADLL			(0x1 << 3)
+#define DLL_DELAY_MASK		0xFF00
+#define DLL_NO_FILTER_MASK	((0x1 << 9) | (0x1 << 8))
+
+#define PAGEPOLICY_HIGH		(0x1 << 0)
+#define SRFRONRESET		(0x1 << 7)
+#define WAKEUPPROC		(0x1 << 26)
+
+#define DDR_SDRAM		(0x1 << 0)
+#define DEEPPD			(0x1 << 3)
+#define B32NOT16		(0x1 << 4)
+#define BANKALLOCATION		(0x2 << 6)
+#define RAMSIZE_128		(0x40 << 8) /* RAM size in 2MB chunks */
+#define ADDRMUXLEGACY		(0x1 << 19)
+#define CASWIDTH_10BITS		(0x5 << 20)
+#define RASWIDTH_13BITS		(0x2 << 24)
+#define BURSTLENGTH4		(0x2 << 0)
+#define CASL3			(0x3 << 4)
+#define SDRC_ACTIM_CTRL0_BASE	(PNX84XX_SDRC_BASE + 0x9C)
+#define SDRC_ACTIM_CTRL1_BASE	(PNX84XX_SDRC_BASE + 0xC4)
+#define ARE_ARCV_1		(0x1 << 0)
+#define ARCV			(0x4e2 << 8) /* Autorefresh count */
+#define PNX84XX_SDRC_CS0	0x00000000
+#define PNX84XX_SDRC_CS1	0x20000000
+#define CMD_NOP				0x0
+#define CMD_PRECHARGE		0x1
+#define CMD_AUTOREFRESH		0x2
+#define CMD_ENTR_PWRDOWN	0x3
+#define CMD_EXIT_PWRDOWN	0x4
+#define CMD_ENTR_SRFRSH		0x5
+#define CMD_CKE_HIGH		0x6
+#define CMD_CKE_LOW		0x7
+#define SOFTRESET		(0x1 << 1)
+#define SMART_IDLE		(0x2 << 3)
+#define REF_ON_IDLE		(0x1 << 6)
+
+/* timer regs offsets (32 bit regs) */
+
+#ifndef __ASSEMBLY__
+typedef struct gptimer {
+	unsigned int tldr;		/* 0x00 rw */
+	unsigned int tcrr;	    /* 0x04 rw */
+	unsigned int tclr;		/* 0x08 rw */
+	unsigned int tstat;		/* 0x0c rw */
+} gptimer_t;
+#endif /* __ASSEMBLY__ */
+
+#define TCLR_TE			(0x1 << 0)   /* timer enable */
+#define TCLR_AI			(0x1 << 3)   /* Auto Increment */
+#define TCLR_PRE		(0x1 << 8)
+
+/* enable sys_clk NO-prescale /1 */
+#define GPT_EN			((0x0 << 2) | (0x1 << 1) | (0x1 << 0))
+
+/* Watchdog */
+#ifndef __ASSEMBLY__
+typedef struct watchdog {
+	unsigned int wload;		/* 0x00 rw */
+	unsigned int wcount;	/* 0x04 rw */
+	unsigned int wctrl;		/* 0x08 rw */
+	unsigned int wstat;		/* 0x0c rw */
+	unsigned int wrst;		/* 0x10 rw */
+	unsigned int wdis;		/* 0x14 wo */
+} watchdog_t;
+#endif /* __ASSEMBLY__ */
+
+#define WD_UNLOCK1		0xAAAA
+#define WD_UNLOCK2		0x5555
+
+/* PRCM */
+#define PRCM_BASE		0x48004000
+
+#ifndef __ASSEMBLY__
+typedef struct prcm {
+	unsigned int fclken_iva2;	/* 0x00 */
+	unsigned int clken_pll_iva2;	/* 0x04 */
+	unsigned char res1[0x1c];
+	unsigned int idlest_pll_iva2;	/* 0x24 */
+	unsigned char res2[0x18];
+	unsigned int clksel1_pll_iva2 ;	/* 0x40 */
+	unsigned int clksel2_pll_iva2;	/* 0x44 */
+	unsigned char res3[0x8bc];
+	unsigned int clken_pll_mpu;	/* 0x904 */
+	unsigned char res4[0x1c];
+	unsigned int idlest_pll_mpu;	/* 0x924 */
+	unsigned char res5[0x18];
+	unsigned int clksel1_pll_mpu;	/* 0x940 */
+	unsigned int clksel2_pll_mpu;	/* 0x944 */
+	unsigned char res6[0xb8];
+	unsigned int fclken1_core;	/* 0xa00 */
+	unsigned char res7[0xc];
+	unsigned int iclken1_core;	/* 0xa10 */
+	unsigned int iclken2_core;	/* 0xa14 */
+	unsigned char res8[0x28];
+	unsigned int clksel_core;	/* 0xa40 */
+	unsigned char res9[0xbc];
+	unsigned int fclken_gfx;	/* 0xb00 */
+	unsigned char res10[0xc];
+	unsigned int iclken_gfx;	/* 0xb10 */
+	unsigned char res11[0x2c];
+	unsigned int clksel_gfx;	/* 0xb40 */
+	unsigned char res12[0xbc];
+	unsigned int fclken_wkup;	/* 0xc00 */
+	unsigned char res13[0xc];
+	unsigned int iclken_wkup;	/* 0xc10 */
+	unsigned char res14[0xc];
+	unsigned int idlest_wkup;	/* 0xc20 */
+	unsigned char res15[0x1c];
+	unsigned int clksel_wkup;	/* 0xc40 */
+	unsigned char res16[0xbc];
+	unsigned int clken_pll;		/* 0xd00 */
+	unsigned char res17[0x1c];
+	unsigned int idlest_ckgen;	/* 0xd20 */
+	unsigned char res18[0x1c];
+	unsigned int clksel1_pll;	/* 0xd40 */
+	unsigned int clksel2_pll;	/* 0xd44 */
+	unsigned int clksel3_pll;	/* 0xd48 */
+	unsigned char res19[0xb4];
+	unsigned int fclken_dss;	/* 0xe00 */
+	unsigned char res20[0xc];
+	unsigned int iclken_dss;	/* 0xe10 */
+	unsigned char res21[0x2c];
+	unsigned int clksel_dss;	/* 0xe40 */
+	unsigned char res22[0xbc];
+	unsigned int fclken_cam;	/* 0xf00 */
+	unsigned char res23[0xc];
+	unsigned int iclken_cam;	/* 0xf10 */
+	unsigned char res24[0x2c];
+	unsigned int clksel_cam;	/* 0xf40 */
+	unsigned char res25[0xbc];
+	unsigned int fclken_per;	/* 0x1000 */
+	unsigned char res26[0xc];
+	unsigned int iclken_per;	/* 0x1010 */
+	unsigned char res27[0x2c];
+	unsigned int clksel_per;	/* 0x1040 */
+	unsigned char res28[0xfc];
+	unsigned int clksel1_emu;	/* 0x1140 */
+} prcm_t;
+#else /* __ASSEMBLY__ */
+#define CM_CLKSEL_CORE		0x48004a40
+#define CM_CLKSEL_GFX		0x48004b40
+#define CM_CLKSEL_WKUP		0x48004c40
+#define CM_CLKEN_PLL		0x48004d00
+#define CM_CLKSEL1_PLL		0x48004d40
+#define CM_CLKSEL1_EMU		0x48005140
+#endif /* __ASSEMBLY__ */
+
+#define PRM_BASE		0x48306000
+
+#ifndef __ASSEMBLY__
+typedef struct prm {
+	unsigned char res1[0xd40];
+	unsigned int clksel;		/* 0xd40 */
+	unsigned char res2[0x50c];
+	unsigned int rstctrl;		/* 0x1250 */
+	unsigned char res3[0x1c];
+	unsigned int clksrc_ctrl;	/* 0x1270 */
+} prm_t;
+#else /* __ASSEMBLY__ */
+#define PRM_RSTCTRL		0x48307250
+#endif /* __ASSEMBLY__ */
+
+#define SYSCLKDIV_1		(0x1 << 6)
+#define SYSCLKDIV_2		(0x1 << 7)
+
+#define CLKSEL_GPT1		(0x1 << 0)
+
+#define EN_GPT1			(0x1 << 0)
+#define EN_32KSYNC		(0x1 << 2)
+
+#define ST_WDT2			(0x1 << 5)
+
+#define ST_MPU_CLK		(0x1 << 0)
+
+#define ST_CORE_CLK		(0x1 << 0)
+
+#define ST_PERIPH_CLK		(0x1 << 1)
+
+#define ST_IVA2_CLK		(0x1 << 0)
+
+#define RESETDONE		(0x1 << 0)
+
+#define TCLR_TE			(0x1 << 0)          /* timer enable     */
+#define TCLR_AR			(0x1 << 1)			/* auto reload      */
+#define TCLR_IE			(0x1 << 2)			/* Interrupt enable */
+
+/* SMX-APE */
+#define PM_RT_APE_BASE_ADDR_ARM		(SMX_APE_BASE + 0x10000)
+#define PM_GCS_BASE_ADDR_ARM		(SMX_APE_BASE + 0x12400)
+#define PM_OCM_RAM_BASE_ADDR_ARM	(SMX_APE_BASE + 0x12800)
+#define PM_IVA2_BASE_ADDR_ARM		(SMX_APE_BASE + 0x14000)
+
+#ifndef __ASSEMBLY__
+typedef struct pm {
+	unsigned char res1[0x48];
+	unsigned int req_info_permission_0;	/* 0x48 */
+	unsigned char res2[0x4];
+	unsigned int read_permission_0;		/* 0x50 */
+	unsigned char res3[0x4];
+	unsigned int wirte_permission_0;	/* 0x58 */
+	unsigned char res4[0x4];
+	unsigned int addr_match_1;		/* 0x58 */
+	unsigned char res5[0x4];
+	unsigned int req_info_permission_1;	/* 0x68 */
+	unsigned char res6[0x14];
+	unsigned int addr_match_2;		/* 0x80 */
+} pm_t;
+#endif /*__ASSEMBLY__ */
+
+/* Permission values for registers -Full fledged permissions to all */
+#define UNLOCK_1			0xFFFFFFFF
+#define UNLOCK_2			0x00000000
+#define UNLOCK_3			0x0000FFFF
+
+#define NOT_EARLY			0
+
+/* I2C base */
+#define I2C_BASE1		(PNX84XX_CORE_L4_IO_BASE + 0x70000)
+#define I2C_BASE2		(PNX84XX_CORE_L4_IO_BASE + 0x72000)
+#define I2C_BASE3		(PNX84XX_CORE_L4_IO_BASE + 0x60000)
+
+#endif /* _CPU_H */
diff --git a/include/asm-arm/arch-pnx84xx/cwr/v2007.1.project b/include/asm-arm/arch-pnx84xx/cwr/v2007.1.project
new file mode 100644
index 0000000..02fdcd7
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/cwr/v2007.1.project
@@ -0,0 +1,3 @@
+<registry>
+<table n="cwr"/>
+</registry>
diff --git a/include/asm-arm/arch-pnx84xx/cwr/vtemp.project b/include/asm-arm/arch-pnx84xx/cwr/vtemp.project
new file mode 100644
index 0000000..02fdcd7
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/cwr/vtemp.project
@@ -0,0 +1,3 @@
+<registry>
+<table n="cwr"/>
+</registry>
diff --git a/include/asm-arm/arch-pnx84xx/i2c.h b/include/asm-arm/arch-pnx84xx/i2c.h
new file mode 100644
index 0000000..3937f35
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/i2c.h
@@ -0,0 +1,128 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _I2C_H_
+#define _I2C_H_
+
+#define I2C_DEFAULT_BASE	I2C_BASE1
+
+#define I2C_REV		(I2C_DEFAULT_BASE + 0x00)
+#define I2C_IE 		(I2C_DEFAULT_BASE + 0x04)
+#define I2C_STAT	(I2C_DEFAULT_BASE + 0x08)
+#define I2C_IV 		(I2C_DEFAULT_BASE + 0x0c)
+#define I2C_BUF		(I2C_DEFAULT_BASE + 0x14)
+#define I2C_CNT		(I2C_DEFAULT_BASE + 0x18)
+#define I2C_DATA	(I2C_DEFAULT_BASE + 0x1c)
+#define I2C_SYSC	(I2C_DEFAULT_BASE + 0x20)
+#define I2C_CON		(I2C_DEFAULT_BASE + 0x24)
+#define I2C_OA 		(I2C_DEFAULT_BASE + 0x28)
+#define I2C_SA 		(I2C_DEFAULT_BASE + 0x2c)
+#define I2C_PSC		(I2C_DEFAULT_BASE + 0x30)
+#define I2C_SCLL	(I2C_DEFAULT_BASE + 0x34)
+#define I2C_SCLH	(I2C_DEFAULT_BASE + 0x38)
+#define I2C_SYSTEST	(I2C_DEFAULT_BASE + 0x3c)
+
+/* I2C masks */
+
+/* I2C Interrupt Enable Register (I2C_IE): */
+#define I2C_IE_GC_IE	(1 << 5)
+#define I2C_IE_XRDY_IE	(1 << 4) /* Transmit data ready interrupt enable */
+#define I2C_IE_RRDY_IE	(1 << 3) /* Receive data ready interrupt enable */
+#define I2C_IE_ARDY_IE	(1 << 2) /* Register access ready interrupt enable */
+#define I2C_IE_NACK_IE	(1 << 1) /* No acknowledgment interrupt enable */
+#define I2C_IE_AL_IE	(1 << 0) /* Arbitration lost interrupt enable */
+
+/* I2C Status Register (I2C_STAT): */
+
+#define I2C_STAT_SBD	(1 << 15) /* Single byte data */
+#define I2C_STAT_BB	(1 << 12) /* Bus busy */
+#define I2C_STAT_ROVR	(1 << 11) /* Receive overrun */
+#define I2C_STAT_XUDF	(1 << 10) /* Transmit underflow */
+#define I2C_STAT_AAS	(1 << 9)  /* Address as slave */
+#define I2C_STAT_GC	(1 << 5)
+#define I2C_STAT_XRDY	(1 << 4)  /* Transmit data ready */
+#define I2C_STAT_RRDY	(1 << 3)  /* Receive data ready */
+#define I2C_STAT_ARDY	(1 << 2)  /* Register access ready */
+#define I2C_STAT_NACK	(1 << 1)  /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL	(1 << 0)  /* Arbitration lost interrupt enable */
+
+/* I2C Interrupt Code Register (I2C_INTCODE): */
+
+#define I2C_INTCODE_MASK	7
+#define I2C_INTCODE_NONE	0
+#define I2C_INTCODE_AL		1	/* Arbitration lost */
+#define I2C_INTCODE_NAK		2	/* No acknowledgement/general call */
+#define I2C_INTCODE_ARDY	3	/* Register access ready */
+#define I2C_INTCODE_RRDY	4	/* Rcv data ready */
+#define I2C_INTCODE_XRDY	5	/* Xmit data ready */
+
+/* I2C Buffer Configuration Register (I2C_BUF): */
+
+#define I2C_BUF_RDMA_EN		(1 << 15) /* Receive DMA channel enable */
+#define I2C_BUF_XDMA_EN		(1 << 7)  /* Transmit DMA channel enable */
+
+/* I2C Configuration Register (I2C_CON): */
+
+#define I2C_CON_EN	(1 << 15)  /* I2C module enable */
+#define I2C_CON_BE	(1 << 14)  /* Big endian mode */
+#define I2C_CON_STB	(1 << 11)  /* Start byte mode (master mode only) */
+#define I2C_CON_MST	(1 << 10)  /* Master/slave mode */
+#define I2C_CON_TRX	(1 << 9)   /* Transmitter/receiver mode */
+				   /* (master mode only) */
+#define I2C_CON_XA	(1 << 8)   /* Expand address */
+#define I2C_CON_STP	(1 << 1)   /* Stop condition (master mode only) */
+#define I2C_CON_STT	(1 << 0)   /* Start condition (master mode only) */
+
+/* I2C System Test Register (I2C_SYSTEST): */
+
+#define I2C_SYSTEST_ST_EN	(1 << 15) /* System test enable */
+#define I2C_SYSTEST_FREE	(1 << 14) /* Free running mode, on brkpoint) */
+#define I2C_SYSTEST_TMODE_MASK	(3 << 12) /* Test mode select */
+#define I2C_SYSTEST_TMODE_SHIFT	(12)	  /* Test mode select */
+#define I2C_SYSTEST_SCL_I	(1 << 3)  /* SCL line sense input value */
+#define I2C_SYSTEST_SCL_O	(1 << 2)  /* SCL line drive output value */
+#define I2C_SYSTEST_SDA_I	(1 << 1)  /* SDA line sense input value */
+#define I2C_SYSTEST_SDA_O	(1 << 0)  /* SDA line drive output value */
+
+#define I2C_SCLL_SCLL		0
+#define I2C_SCLL_SCLL_M		0xFF
+#define I2C_SCLL_HSSCLL		8
+#define I2C_SCLH_HSSCLL_M	0xFF
+#define I2C_SCLH_SCLH		0
+#define I2C_SCLH_SCLH_M		0xFF
+#define I2C_SCLH_HSSCLH		8
+#define I2C_SCLH_HSSCLH_M	0xFF
+
+#define OMAP_I2C_STANDARD	100
+#define OMAP_I2C_FAST_MODE	400
+#define OMAP_I2C_HIGH_SPEED	3400
+
+#define SYSTEM_CLOCK_12		12000
+#define SYSTEM_CLOCK_13		13000
+#define SYSTEM_CLOCK_192	19200
+#define SYSTEM_CLOCK_96		96000
+
+#define I2C_IP_CLK		SYSTEM_CLOCK_96
+#define I2C_PSC_MAX		0x0f
+#define I2C_PSC_MIN		0x00
+
+#endif /* _I2C_H_ */
diff --git a/include/asm-arm/arch-pnx84xx/mem.h b/include/asm-arm/arch-pnx84xx/mem.h
new file mode 100644
index 0000000..812a4fb
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/mem.h
@@ -0,0 +1,157 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _MEM_H_
+#define _MEM_H_
+
+#define CS0		0x0
+#define CS1		0x1 /* mirror CS1 regs appear offset 0x30 from CS0 */
+
+#ifndef __ASSEMBLY__
+typedef enum {
+	STACKED = 0,
+	IP_DDR = 1,
+	COMBO_DDR = 2,
+	IP_SDR = 3,
+} mem_t;
+#endif /* __ASSEMBLY__ */
+
+#define EARLY_INIT	1
+
+/* Slower full frequency range default timings for x32 operation*/
+#define SDP_SDRC_SHARING	0x00000100
+#define SDP_SDRC_MR_0_SDR	0x00000031
+
+/* optimized timings good for current shipping parts */
+#define SDP_3430_SDRC_RFR_CTRL_165MHz	0x0004e201 /* 7.8us/6ns - 50=0x4e2 */
+
+#define DLL_OFFSET		0
+#define DLL_WRITEDDRCLKX2DIS	1
+#define DLL_ENADLL		1
+#define DLL_LOCKDLL		0
+#define DLL_DLLPHASE_72		0
+#define DLL_DLLPHASE_90		1
+
+/* rkw - need to find of 90/72 degree recommendation for speed like before */
+#define SDP_SDRC_DLLAB_CTRL	((DLL_ENADLL << 3) | \
+				(DLL_LOCKDLL << 2) | (DLL_DLLPHASE_90 << 1))
+
+/* Infineon part of 3430SDP (165MHz optimized) 6.06ns
+ *   ACTIMA
+ *	TDAL = Twr/Tck + Trp/tck = 15/6 + 18/6 = 2.5 + 3 = 5.5 -> 6
+ *	TDPL (Twr) = 15/6	= 2.5 -> 3
+ *	TRRD = 12/6	= 2
+ *	TRCD = 18/6	= 3
+ *	TRP = 18/6	= 3
+ *	TRAS = 42/6	= 7
+ *	TRC = 60/6	= 10
+ *	TRFC = 72/6	= 12
+ *   ACTIMB
+ *	TCKE = 2
+ *	XSR = 120/6 = 20
+ */
+#define TDAL_165	6
+#define TDPL_165	3
+#define TRRD_165	2
+#define TRCD_165	3
+#define TRP_165		3
+#define TRAS_165	7
+#define TRC_165		10
+#define TRFC_165	21
+#define V_ACTIMA_165	((TRFC_165 << 27) | (TRC_165 << 22) | \
+			(TRAS_165 << 18) | (TRP_165 << 15) |  \
+			(TRCD_165 << 12) | (TRRD_165 << 9) |  \
+			(TDPL_165 << 6) | (TDAL_165))
+
+#define TWTR_165	1
+#define TCKE_165	1
+#define TXP_165		5
+#define XSR_165		23
+#define V_ACTIMB_165	(((TCKE_165 << 12) | (XSR_165 << 0)) |	\
+			(TXP_165 << 8) | (TWTR_165 << 16))
+
+#define SDP_SDRC_ACTIM_CTRLA_0	V_ACTIMA_165
+#define SDP_SDRC_ACTIM_CTRLB_0	V_ACTIMB_165
+#define SDP_SDRC_RFR_CTRL	SDP_3430_SDRC_RFR_CTRL_165MHz
+
+/*
+ * GPMC settings -
+ * Definitions is as per the following format
+ * #define <PART>_GPMC_CONFIG<x> <value>
+ * Where:
+ * PART is the part name e.g. STNOR - Intel Strata Flash
+ * x is GPMC config registers from 1 to 6 (there will be 6 macros)
+ * Value is corresponding value
+ *
+ * For every valid PRCM configuration there should be only one definition of
+ * the same. if values are independent of the board, this definition will be
+ * present in this file if values are dependent on the board, then this should
+ * go into corresponding mem-boardName.h file
+ *
+ * Currently valid part Names are (PART):
+ * STNOR - Intel Strata Flash
+ * SMNAND - Samsung NAND
+ * MPDB - H4 MPDB board
+ * SBNOR - Sibley NOR
+ * MNAND - Micron Large page x16 NAND
+ * ONNAND - Samsung One NAND
+ *
+ * include/configs/file.h contains the defn - for all CS we are interested
+ * #define OMAP34XX_GPMC_CSx PART
+ * #define OMAP34XX_GPMC_CSx_SIZE Size
+ * #define OMAP34XX_GPMC_CSx_MAP Map
+ * Where:
+ * x - CS number
+ * PART - Part Name as defined above
+ * SIZE - how big is the mapping to be
+ *   GPMC_SIZE_128M - 0x8
+ *   GPMC_SIZE_64M  - 0xC
+ *   GPMC_SIZE_32M  - 0xE
+ *   GPMC_SIZE_16M  - 0xF
+ * MAP  - Map this CS to which address(GPMC address space)- Absolute address
+ *   >>24 before being used.
+ */
+
+/* max number of GPMC Chip Selects */
+#define GCS_MAX_CS	8
+/* max number of GPMC regs */
+#define GCS_MAX_REG	7
+
+#define PISMO1_NOR	1
+#define PISMO1_NAND	2
+#define PISMO2_CS0	3
+#define PISMO2_CS1	4
+#define PISMO1_ONENAND	5
+#define DBG_MPDB	6
+#define PISMO2_NAND_CS0 7
+#define PISMO2_NAND_CS1 8
+
+/* make it readable for the GCS_init */
+#define PISMO1_NOR_BASE		FLASH_BASE
+#define PISMO1_NAND_BASE	NAND_BASE
+#define PISMO2_CS0_BASE		PISMO2_MAP1
+#define PISMO1_ONEN_BASE	ONENAND_MAP
+#define DBG_MPDB_BASE		DEBUG_BASE
+
+#endif /* endif _MEM_H_ */
diff --git a/include/asm-arm/arch-pnx84xx/mmc.h b/include/asm-arm/arch-pnx84xx/mmc.h
new file mode 100644
index 0000000..55584d9
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/mmc.h
@@ -0,0 +1,235 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MMC_H
+#define MMC_H
+
+#include "mmc_host_def.h"
+
+/* Responses */
+#define RSP_TYPE_NONE	(RSP_TYPE_NORSP   | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R1	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R1B	(RSP_TYPE_LGHT48B | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R2	(RSP_TYPE_LGHT136 | CCCE_CHECK   | CICE_NOCHECK)
+#define RSP_TYPE_R3	(RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R4	(RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R5	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R6	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R7	(RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+
+/* All supported commands */
+#define MMC_CMD0	(INDEX(0)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD1	(INDEX(1)  | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD2	(INDEX(2)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD3	(INDEX(3)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_SDCMD3	(INDEX(3)  | RSP_TYPE_R6   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD4	(INDEX(4)  | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD6	(INDEX(6)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD7_SELECT	(INDEX(7)  | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD7_DESELECT (INDEX(7)| RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD8	(INDEX(8)  | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_SDCMD8	(INDEX(8)  | RSP_TYPE_R7   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD9	(INDEX(9)  | RSP_TYPE_R2   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD12	(INDEX(12) | RSP_TYPE_R1B  | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD13	(INDEX(13) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD15	(INDEX(15) | RSP_TYPE_NONE | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD16	(INDEX(16) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_CMD17	(INDEX(17) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_CMD24	(INDEX(24) | RSP_TYPE_R1   | DP_DATA    | DDIR_WRITE)
+#define MMC_ACMD6	(INDEX(6)  | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_ACMD41	(INDEX(41) | RSP_TYPE_R3   | DP_NO_DATA | DDIR_WRITE)
+#define MMC_ACMD51	(INDEX(51) | RSP_TYPE_R1   | DP_DATA    | DDIR_READ)
+#define MMC_CMD55	(INDEX(55) | RSP_TYPE_R1   | DP_NO_DATA | DDIR_WRITE)
+
+#define MMC_AC_CMD_RCA_MASK	(unsigned int)(0xFFFF << 16)
+#define MMC_BC_CMD_DSR_MASK	(unsigned int)(0xFFFF << 16)
+#define MMC_DSR_DEFAULT		0x0404
+#define SD_CMD8_CHECK_PATTERN	0xAA
+#define SD_CMD8_2_7_3_6_V_RANGE	(0x01 << 8)
+
+/* Clock Configurations and Macros */
+
+#define MMC_CLOCK_REFERENCE		96
+#define MMC_RELATIVE_CARD_ADDRESS	0x1234
+#define MMC_INIT_SEQ_CLK		(MMC_CLOCK_REFERENCE * 1000 / 80)
+#define MMC_400kHz_CLK			(MMC_CLOCK_REFERENCE * 1000 / 400)
+#define CLKDR(r, f, u)			((((r)*100) / ((f)*(u))) + 1)
+#define CLKD(f, u)			(CLKDR(MMC_CLOCK_REFERENCE, f, u))
+
+#define MMC_OCR_REG_ACCESS_MODE_MASK	(0x3 << 29)
+#define MMC_OCR_REG_ACCESS_MODE_BYTE 	(0x0 << 29)
+#define MMC_OCR_REG_ACCESS_MODE_SECTOR	(0x2 << 29)
+
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_MASK		(0x1 << 30)
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_BYTE		(0x0 << 30)
+#define MMC_OCR_REG_HOST_CAPACITY_SUPPORT_SECTOR	(0x1 << 30)
+
+#define MMC_SD2_CSD_C_SIZE_LSB_MASK	0xFFFF
+#define MMC_SD2_CSD_C_SIZE_MSB_MASK	0x003F
+#define MMC_SD2_CSD_C_SIZE_MSB_OFFSET	16
+#define MMC_CSD_C_SIZE_LSB_MASK		0x0003
+#define MMC_CSD_C_SIZE_MSB_MASK		0x03FF
+#define MMC_CSD_C_SIZE_MSB_OFFSET	2
+
+#define MMC_CSD_TRAN_SPEED_UNIT_MASK	(0x07 << 0)
+#define MMC_CSD_TRAN_SPEED_FACTOR_MASK	(0x0F << 3)
+#define MMC_CSD_TRAN_SPEED_UNIT_100MHZ	(0x3 << 0)
+#define MMC_CSD_TRAN_SPEED_FACTOR_1_0	(0x01 << 3)
+#define MMC_CSD_TRAN_SPEED_FACTOR_8_0	(0x0F << 3)
+
+typedef struct {
+	unsigned not_used:1;
+	unsigned crc:7;
+	unsigned ecc:2;
+	unsigned file_format:2;
+	unsigned tmp_write_protect:1;
+	unsigned perm_write_protect:1;
+	unsigned copy:1;
+	unsigned file_format_grp:1;
+	unsigned content_prot_app:1;
+	unsigned reserved_1:4;
+	unsigned write_bl_partial:1;
+	unsigned write_bl_len:4;
+	unsigned r2w_factor:3;
+	unsigned default_ecc:2;
+	unsigned wp_grp_enable:1;
+	unsigned wp_grp_size:5;
+	unsigned erase_grp_mult:5;
+	unsigned erase_grp_size:5;
+	unsigned c_size_mult:3;
+	unsigned vdd_w_curr_max:3;
+	unsigned vdd_w_curr_min:3;
+	unsigned vdd_r_curr_max:3;
+	unsigned vdd_r_curr_min:3;
+	unsigned c_size_lsb:2;
+	unsigned c_size_msb:10;
+	unsigned reserved_2:2;
+	unsigned dsr_imp:1;
+	unsigned read_blk_misalign:1;
+	unsigned write_blk_misalign:1;
+	unsigned read_bl_partial:1;
+	unsigned read_bl_len:4;
+	unsigned ccc:12;
+	unsigned tran_speed:8;
+	unsigned nsac:8;
+	unsigned taac:8;
+	unsigned reserved_3:2;
+	unsigned spec_vers:4;
+	unsigned csd_structure:2;
+} mmc_csd_reg_t;
+
+/* csd for sd2.0 */
+typedef struct {
+	unsigned not_used:1;
+	unsigned crc:7;
+	unsigned reserved_1:2;
+	unsigned file_format:2;
+	unsigned tmp_write_protect:1;
+	unsigned perm_write_protect:1;
+	unsigned copy:1;
+	unsigned file_format_grp:1;
+	unsigned reserved_2:5;
+	unsigned write_bl_partial:1;
+	unsigned write_bl_len:4;
+	unsigned r2w_factor:3;
+	unsigned reserved_3:2;
+	unsigned wp_grp_enable:1;
+	unsigned wp_grp_size:7;
+	unsigned sector_size:7;
+	unsigned erase_blk_len:1;
+	unsigned reserved_4:1;
+	unsigned c_size_lsb:16;
+	unsigned c_size_msb:6;
+	unsigned reserved_5:6;
+	unsigned dsr_imp:1;
+	unsigned read_blk_misalign:1;
+	unsigned write_blk_misalign:1;
+	unsigned read_bl_partial:1;
+	unsigned read_bl_len:4;
+	unsigned ccc:12;
+	unsigned tran_speed:8;
+	unsigned nsac:8;
+	unsigned taac:8;
+	unsigned reserved_6:6;
+	unsigned csd_structure:2;
+} mmc_sd2_csd_reg_t;
+
+/* extended csd - 512 bytes long */
+typedef struct {
+	unsigned char reserved_1[181];
+	unsigned char erasedmemorycontent;
+	unsigned char reserved_2;
+	unsigned char buswidthmode;
+	unsigned char reserved_3;
+	unsigned char highspeedinterfacetiming;
+	unsigned char reserved_4;
+	unsigned char powerclass;
+	unsigned char reserved_5;
+	unsigned char commandsetrevision;
+	unsigned char reserved_6;
+	unsigned char commandset;
+	unsigned char extendedcsdrevision;
+	unsigned char reserved_7;
+	unsigned char csdstructureversion;
+	unsigned char reserved_8;
+	unsigned char cardtype;
+	unsigned char reserved_9[3];
+	unsigned char powerclass_52mhz_1_95v;
+	unsigned char powerclass_26mhz_1_95v;
+	unsigned char powerclass_52mhz_3_6v;
+	unsigned char powerclass_26mhz_3_6v;
+	unsigned char reserved_10;
+	unsigned char minreadperf_4b_26mhz;
+	unsigned char minwriteperf_4b_26mhz;
+	unsigned char minreadperf_8b_26mhz_4b_52mhz;
+	unsigned char minwriteperf_8b_26mhz_4b_52mhz;
+	unsigned char minreadperf_8b_52mhz;
+	unsigned char minwriteperf_8b_52mhz;
+	unsigned char reserved_11;
+	unsigned int sectorcount;
+	unsigned char reserved_12[288];
+	unsigned char supportedcommandsets;
+	unsigned char reserved_13[7];
+} mmc_extended_csd_reg_t;
+
+/* mmc sd responce */
+typedef struct {
+	unsigned int ocr;
+} mmc_resp_r3;
+
+typedef struct {
+	unsigned short cardstatus;
+	unsigned short newpublishedrca;
+} mmc_resp_r6;
+
+extern mmc_card_data mmc_dev;
+
+unsigned char mmc_lowlevel_init(void);
+unsigned char mmc_send_command(unsigned int cmd, unsigned int arg,
+			       unsigned int *response);
+unsigned char mmc_setup_clock(unsigned int iclk, unsigned short clkd);
+unsigned char mmc_set_opendrain(unsigned char state);
+unsigned char mmc_read_data(unsigned int *output_buf);
+
+#endif /* MMC_H */
diff --git a/include/asm-arm/arch-pnx84xx/mmc_host_def.h b/include/asm-arm/arch-pnx84xx/mmc_host_def.h
new file mode 100644
index 0000000..aa751c9
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/mmc_host_def.h
@@ -0,0 +1,184 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <khasim@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation's version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MMC_HOST_DEF_H
+#define MMC_HOST_DEF_H
+
+/* T2 Register definitions */
+#define T2_BASE			0x48002000
+
+typedef struct t2 {
+	unsigned char res1[0x274];
+	unsigned int devconf0;		/* 0x274 */
+	unsigned char res2[0x2A8];
+	unsigned int pbias_lite;	/* 0x520 */
+} t2_t;
+
+#define MMCSDIO1ADPCLKISEL		(1 << 24)
+
+#define PBIASLITEPWRDNZ0		(1 << 1)
+#define PBIASSPEEDCTRL0			(1 << 2)
+#define PBIASLITEPWRDNZ1		(1 << 9)
+
+/*
+ * OMAP HSMMC register definitions
+ */
+#define OMAP_HSMMC_BASE		0x4809C000
+
+typedef struct hsmmc {
+	unsigned char res1[0x10];
+	unsigned int sysconfig;		/* 0x10 */
+	unsigned int sysstatus;		/* 0x14 */
+	unsigned char res2[0x14];
+	unsigned int con;		/* 0x2C */
+	unsigned char res3[0xD4];
+	unsigned int blk;		/* 0x104 */
+	unsigned int arg;		/* 0x108 */
+	unsigned int cmd;		/* 0x10C */
+	unsigned int rsp10;		/* 0x110 */
+	unsigned int rsp32;		/* 0x114 */
+	unsigned int rsp54;		/* 0x118 */
+	unsigned int rsp76;		/* 0x11C */
+	unsigned int data;		/* 0x120 */
+	unsigned int pstate;		/* 0x124 */
+	unsigned int hctl;		/* 0x128 */
+	unsigned int sysctl;		/* 0x12C */
+	unsigned int stat;		/* 0x130 */
+	unsigned int ie;		/* 0x134 */
+	unsigned char res4[0x8];
+	unsigned int capa;		/* 0x140 */
+} hsmmc_t;
+
+/*
+ * OMAP HS MMC Bit definitions
+ */
+#define MMC_SOFTRESET			(0x1 << 1)
+#define RESETDONE			(0x1 << 0)
+#define NOOPENDRAIN			(0x0 << 0)
+#define OPENDRAIN			(0x1 << 0)
+#define OD				(0x1 << 0)
+#define INIT_NOINIT			(0x0 << 1)
+#define INIT_INITSTREAM			(0x1 << 1)
+#define HR_NOHOSTRESP			(0x0 << 2)
+#define STR_BLOCK 			(0x0 << 3)
+#define MODE_FUNC			(0x0 << 4)
+#define DW8_1_4BITMODE 			(0x0 << 5)
+#define MIT_CTO				(0x0 << 6)
+#define CDP_ACTIVEHIGH			(0x0 << 7)
+#define WPP_ACTIVEHIGH 			(0x0 << 8)
+#define RESERVED_MASK			(0x3 << 9)
+#define CTPL_MMC_SD 			(0x0 << 11)
+#define BLEN_512BYTESLEN		(0x200 << 0)
+#define NBLK_STPCNT			(0x0 << 16)
+#define DE_DISABLE			(0x0 << 0)
+#define BCE_DISABLE			(0x0 << 1)
+#define ACEN_DISABLE			(0x0 << 2)
+#define DDIR_OFFSET			(4)
+#define DDIR_MASK			(0x1 << 4)
+#define DDIR_WRITE			(0x0 << 4)
+#define DDIR_READ			(0x1 << 4)
+#define MSBS_SGLEBLK			(0x0 << 5)
+#define RSP_TYPE_OFFSET			(16)
+#define RSP_TYPE_MASK			(0x3 << 16)
+#define RSP_TYPE_NORSP			(0x0 << 16)
+#define RSP_TYPE_LGHT136		(0x1 << 16)
+#define RSP_TYPE_LGHT48			(0x2 << 16)
+#define RSP_TYPE_LGHT48B		(0x3 << 16)
+#define CCCE_NOCHECK			(0x0 << 19)
+#define CCCE_CHECK			(0x1 << 19)
+#define CICE_NOCHECK			(0x0 << 20)
+#define CICE_CHECK			(0x1 << 20)
+#define DP_OFFSET			(21)
+#define DP_MASK				(0x1 << 21)
+#define DP_NO_DATA			(0x0 << 21)
+#define DP_DATA				(0x1 << 21)
+#define CMD_TYPE_NORMAL			(0x0 << 22)
+#define INDEX_OFFSET			(24)
+#define INDEX_MASK			(0x3f << 24)
+#define INDEX(i)			(i << 24)
+#define DATI_MASK			(0x1 << 1)
+#define DATI_CMDDIS			(0x1 << 1)
+#define DTW_1_BITMODE			(0x0 << 1)
+#define DTW_4_BITMODE			(0x1 << 1)
+#define SDBP_PWROFF			(0x0 << 8)
+#define SDBP_PWRON			(0x1 << 8)
+#define SDVS_1V8			(0x5 << 9)
+#define SDVS_3V0			(0x6 << 9)
+#define ICE_MASK			(0x1 << 0)
+#define ICE_STOP			(0x0 << 0)
+#define ICS_MASK			(0x1 << 1)
+#define ICS_NOTREADY			(0x0 << 1)
+#define ICE_OSCILLATE			(0x1 << 0)
+#define CEN_MASK			(0x1 << 2)
+#define CEN_DISABLE			(0x0 << 2)
+#define CEN_ENABLE			(0x1 << 2)
+#define CLKD_OFFSET			(6)
+#define CLKD_MASK			(0x3FF << 6)
+#define DTO_MASK			(0xF << 16)
+#define DTO_15THDTO			(0xE << 16)
+#define SOFTRESETALL			(0x1 << 24)
+#define CC_MASK				(0x1 << 0)
+#define TC_MASK				(0x1 << 1)
+#define BWR_MASK			(0x1 << 4)
+#define BRR_MASK			(0x1 << 5)
+#define ERRI_MASK			(0x1 << 15)
+#define IE_CC				(0x01 << 0)
+#define IE_TC				(0x01 << 1)
+#define IE_BWR				(0x01 << 4)
+#define IE_BRR				(0x01 << 5)
+#define IE_CTO				(0x01 << 16)
+#define IE_CCRC				(0x01 << 17)
+#define IE_CEB				(0x01 << 18)
+#define IE_CIE				(0x01 << 19)
+#define IE_DTO				(0x01 << 20)
+#define IE_DCRC				(0x01 << 21)
+#define IE_DEB				(0x01 << 22)
+#define IE_CERR				(0x01 << 28)
+#define IE_BADA				(0x01 << 29)
+
+#define VS30_3V0SUP			(1 << 25)
+#define VS18_1V8SUP			(1 << 26)
+
+/* Driver definitions */
+#define MMCSD_SECTOR_SIZE		512
+#define MMC_CARD			0
+#define SD_CARD				1
+#define BYTE_MODE			0
+#define SECTOR_MODE			1
+#define CLK_INITSEQ			0
+#define CLK_400KHZ			1
+#define CLK_MISC			2
+
+typedef struct {
+	unsigned int card_type;
+	unsigned int version;
+	unsigned int mode;
+	unsigned int size;
+	unsigned int RCA;
+} mmc_card_data;
+
+#define mmc_reg_out(addr, mask, val)\
+	writel((readl(addr) & (~(mask))) | ((val) & (mask)), (addr))
+
+#endif /* MMC_HOST_DEF_H */
diff --git a/include/asm-arm/arch-pnx84xx/mux.h b/include/asm-arm/arch-pnx84xx/mux.h
new file mode 100644
index 0000000..40056fe
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/mux.h
@@ -0,0 +1,412 @@
+/*
+ * (C) Copyright 2006-2008
+ * Texas Instruments, <www.ti.com>
+ * Syed Mohammed Khasim <x0khasim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _MUX_H_
+#define _MUX_H_
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ */
+
+#define IEN	(1 << 8)
+
+#define IDIS	(0 << 8)
+#define PTU	(1 << 4)
+#define PTD	(0 << 4)
+#define EN	(1 << 3)
+#define DIS	(0 << 3)
+
+#define M0	0
+#define M1	1
+#define M2	2
+#define M3	3
+#define M4	4
+#define M5	5
+#define M6	6
+#define M7	7
+
+/*
+ * To get the actual address the offset has to added
+ * with OMAP34XX_CTRL_BASE to get the actual address
+ */
+
+/*SDRC*/
+#define CONTROL_PADCONF_SDRC_D0		0x0030
+#define CONTROL_PADCONF_SDRC_D1		0x0032
+#define CONTROL_PADCONF_SDRC_D2		0x0034
+#define CONTROL_PADCONF_SDRC_D3		0x0036
+#define CONTROL_PADCONF_SDRC_D4		0x0038
+#define CONTROL_PADCONF_SDRC_D5		0x003A
+#define CONTROL_PADCONF_SDRC_D6		0x003C
+#define CONTROL_PADCONF_SDRC_D7		0x003E
+#define CONTROL_PADCONF_SDRC_D8		0x0040
+#define CONTROL_PADCONF_SDRC_D9		0x0042
+#define CONTROL_PADCONF_SDRC_D10	0x0044
+#define CONTROL_PADCONF_SDRC_D11	0x0046
+#define CONTROL_PADCONF_SDRC_D12	0x0048
+#define CONTROL_PADCONF_SDRC_D13	0x004A
+#define CONTROL_PADCONF_SDRC_D14	0x004C
+#define CONTROL_PADCONF_SDRC_D15	0x004E
+#define CONTROL_PADCONF_SDRC_D16	0x0050
+#define CONTROL_PADCONF_SDRC_D17	0x0052
+#define CONTROL_PADCONF_SDRC_D18	0x0054
+#define CONTROL_PADCONF_SDRC_D19	0x0056
+#define CONTROL_PADCONF_SDRC_D20	0x0058
+#define CONTROL_PADCONF_SDRC_D21	0x005A
+#define CONTROL_PADCONF_SDRC_D22	0x005C
+#define CONTROL_PADCONF_SDRC_D23	0x005E
+#define CONTROL_PADCONF_SDRC_D24	0x0060
+#define CONTROL_PADCONF_SDRC_D25	0x0062
+#define CONTROL_PADCONF_SDRC_D26	0x0064
+#define CONTROL_PADCONF_SDRC_D27	0x0066
+#define CONTROL_PADCONF_SDRC_D28	0x0068
+#define CONTROL_PADCONF_SDRC_D29	0x006A
+#define CONTROL_PADCONF_SDRC_D30	0x006C
+#define CONTROL_PADCONF_SDRC_D31	0x006E
+#define CONTROL_PADCONF_SDRC_CLK	0x0070
+#define CONTROL_PADCONF_SDRC_DQS0	0x0072
+#define CONTROL_PADCONF_SDRC_DQS1	0x0074
+#define CONTROL_PADCONF_SDRC_DQS2	0x0076
+#define CONTROL_PADCONF_SDRC_DQS3	0x0078
+/*GPMC*/
+#define CONTROL_PADCONF_GPMC_A1		0x007A
+#define CONTROL_PADCONF_GPMC_A2		0x007C
+#define CONTROL_PADCONF_GPMC_A3		0x007E
+#define CONTROL_PADCONF_GPMC_A4		0x0080
+#define CONTROL_PADCONF_GPMC_A5		0x0082
+#define CONTROL_PADCONF_GPMC_A6		0x0084
+#define CONTROL_PADCONF_GPMC_A7		0x0086
+#define CONTROL_PADCONF_GPMC_A8		0x0088
+#define CONTROL_PADCONF_GPMC_A9		0x008A
+#define CONTROL_PADCONF_GPMC_A10	0x008C
+#define CONTROL_PADCONF_GPMC_D0		0x008E
+#define CONTROL_PADCONF_GPMC_D1		0x0090
+#define CONTROL_PADCONF_GPMC_D2		0x0092
+#define CONTROL_PADCONF_GPMC_D3		0x0094
+#define CONTROL_PADCONF_GPMC_D4		0x0096
+#define CONTROL_PADCONF_GPMC_D5		0x0098
+#define CONTROL_PADCONF_GPMC_D6		0x009A
+#define CONTROL_PADCONF_GPMC_D7		0x009C
+#define CONTROL_PADCONF_GPMC_D8		0x009E
+#define CONTROL_PADCONF_GPMC_D9		0x00A0
+#define CONTROL_PADCONF_GPMC_D10	0x00A2
+#define CONTROL_PADCONF_GPMC_D11	0x00A4
+#define CONTROL_PADCONF_GPMC_D12	0x00A6
+#define CONTROL_PADCONF_GPMC_D13	0x00A8
+#define CONTROL_PADCONF_GPMC_D14	0x00AA
+#define CONTROL_PADCONF_GPMC_D15	0x00AC
+#define CONTROL_PADCONF_GPMC_NCS0	0x00AE
+#define CONTROL_PADCONF_GPMC_NCS1	0x00B0
+#define CONTROL_PADCONF_GPMC_NCS2	0x00B2
+#define CONTROL_PADCONF_GPMC_NCS3	0x00B4
+#define CONTROL_PADCONF_GPMC_NCS4	0x00B6
+#define CONTROL_PADCONF_GPMC_NCS5	0x00B8
+#define CONTROL_PADCONF_GPMC_NCS6	0x00BA
+#define CONTROL_PADCONF_GPMC_NCS7	0x00BC
+#define CONTROL_PADCONF_GPMC_CLK	0x00BE
+#define CONTROL_PADCONF_GPMC_NADV_ALE	0x00C0
+#define CONTROL_PADCONF_GPMC_NOE	0x00C2
+#define CONTROL_PADCONF_GPMC_NWE	0x00C4
+#define CONTROL_PADCONF_GPMC_NBE0_CLE	0x00C6
+#define CONTROL_PADCONF_GPMC_NBE1	0x00C8
+#define CONTROL_PADCONF_GPMC_NWP	0x00CA
+#define CONTROL_PADCONF_GPMC_WAIT0	0x00CC
+#define CONTROL_PADCONF_GPMC_WAIT1	0x00CE
+#define CONTROL_PADCONF_GPMC_WAIT2	0x00D0
+#define CONTROL_PADCONF_GPMC_WAIT3	0x00D2
+/*DSS*/
+#define CONTROL_PADCONF_DSS_PCLK	0x00D4
+#define CONTROL_PADCONF_DSS_HSYNC	0x00D6
+#define CONTROL_PADCONF_DSS_VSYNC	0x00D8
+#define CONTROL_PADCONF_DSS_ACBIAS	0x00DA
+#define CONTROL_PADCONF_DSS_DATA0	0x00DC
+#define CONTROL_PADCONF_DSS_DATA1	0x00DE
+#define CONTROL_PADCONF_DSS_DATA2	0x00E0
+#define CONTROL_PADCONF_DSS_DATA3	0x00E2
+#define CONTROL_PADCONF_DSS_DATA4	0x00E4
+#define CONTROL_PADCONF_DSS_DATA5	0x00E6
+#define CONTROL_PADCONF_DSS_DATA6	0x00E8
+#define CONTROL_PADCONF_DSS_DATA7	0x00EA
+#define CONTROL_PADCONF_DSS_DATA8	0x00EC
+#define CONTROL_PADCONF_DSS_DATA9	0x00EE
+#define CONTROL_PADCONF_DSS_DATA10	0x00F0
+#define CONTROL_PADCONF_DSS_DATA11	0x00F2
+#define CONTROL_PADCONF_DSS_DATA12	0x00F4
+#define CONTROL_PADCONF_DSS_DATA13	0x00F6
+#define CONTROL_PADCONF_DSS_DATA14	0x00F8
+#define CONTROL_PADCONF_DSS_DATA15	0x00FA
+#define CONTROL_PADCONF_DSS_DATA16	0x00FC
+#define CONTROL_PADCONF_DSS_DATA17	0x00FE
+#define CONTROL_PADCONF_DSS_DATA18	0x0100
+#define CONTROL_PADCONF_DSS_DATA19	0x0102
+#define CONTROL_PADCONF_DSS_DATA20	0x0104
+#define CONTROL_PADCONF_DSS_DATA21	0x0106
+#define CONTROL_PADCONF_DSS_DATA22	0x0108
+#define CONTROL_PADCONF_DSS_DATA23	0x010A
+/*CAMERA*/
+#define CONTROL_PADCONF_CAM_HS		0x010C
+#define CONTROL_PADCONF_CAM_VS		0x010E
+#define CONTROL_PADCONF_CAM_XCLKA	0x0110
+#define CONTROL_PADCONF_CAM_PCLK	0x0112
+#define CONTROL_PADCONF_CAM_FLD		0x0114
+#define CONTROL_PADCONF_CAM_D0		0x0116
+#define CONTROL_PADCONF_CAM_D1		0x0118
+#define CONTROL_PADCONF_CAM_D2		0x011A
+#define CONTROL_PADCONF_CAM_D3		0x011C
+#define CONTROL_PADCONF_CAM_D4		0x011E
+#define CONTROL_PADCONF_CAM_D5		0x0120
+#define CONTROL_PADCONF_CAM_D6		0x0122
+#define CONTROL_PADCONF_CAM_D7		0x0124
+#define CONTROL_PADCONF_CAM_D8		0x0126
+#define CONTROL_PADCONF_CAM_D9		0x0128
+#define CONTROL_PADCONF_CAM_D10		0x012A
+#define CONTROL_PADCONF_CAM_D11		0x012C
+#define CONTROL_PADCONF_CAM_XCLKB	0x012E
+#define CONTROL_PADCONF_CAM_WEN		0x0130
+#define CONTROL_PADCONF_CAM_STROBE	0x0132
+#define CONTROL_PADCONF_CSI2_DX0	0x0134
+#define CONTROL_PADCONF_CSI2_DY0	0x0136
+#define CONTROL_PADCONF_CSI2_DX1	0x0138
+#define CONTROL_PADCONF_CSI2_DY1	0x013A
+/*Audio Interface */
+#define CONTROL_PADCONF_MCBSP2_FSX	0x013C
+#define CONTROL_PADCONF_MCBSP2_CLKX	0x013E
+#define CONTROL_PADCONF_MCBSP2_DR	0x0140
+#define CONTROL_PADCONF_MCBSP2_DX	0x0142
+#define CONTROL_PADCONF_MMC1_CLK	0x0144
+#define CONTROL_PADCONF_MMC1_CMD	0x0146
+#define CONTROL_PADCONF_MMC1_DAT0	0x0148
+#define CONTROL_PADCONF_MMC1_DAT1	0x014A
+#define CONTROL_PADCONF_MMC1_DAT2	0x014C
+#define CONTROL_PADCONF_MMC1_DAT3	0x014E
+#define CONTROL_PADCONF_MMC1_DAT4	0x0150
+#define CONTROL_PADCONF_MMC1_DAT5	0x0152
+#define CONTROL_PADCONF_MMC1_DAT6	0x0154
+#define CONTROL_PADCONF_MMC1_DAT7	0x0156
+/*Wireless LAN */
+#define CONTROL_PADCONF_MMC2_CLK	0x0158
+#define CONTROL_PADCONF_MMC2_CMD	0x015A
+#define CONTROL_PADCONF_MMC2_DAT0	0x015C
+#define CONTROL_PADCONF_MMC2_DAT1	0x015E
+#define CONTROL_PADCONF_MMC2_DAT2	0x0160
+#define CONTROL_PADCONF_MMC2_DAT3	0x0162
+#define CONTROL_PADCONF_MMC2_DAT4	0x0164
+#define CONTROL_PADCONF_MMC2_DAT5	0x0166
+#define CONTROL_PADCONF_MMC2_DAT6	0x0168
+#define CONTROL_PADCONF_MMC2_DAT7	0x016A
+/*Bluetooth*/
+#define CONTROL_PADCONF_MCBSP3_DX	0x016C
+#define CONTROL_PADCONF_MCBSP3_DR	0x016E
+#define CONTROL_PADCONF_MCBSP3_CLKX	0x0170
+#define CONTROL_PADCONF_MCBSP3_FSX	0x0172
+#define CONTROL_PADCONF_UART2_CTS	0x0174
+#define CONTROL_PADCONF_UART2_RTS	0x0176
+#define CONTROL_PADCONF_UART2_TX	0x0178
+#define CONTROL_PADCONF_UART2_RX	0x017A
+/*Modem Interface */
+#define CONTROL_PADCONF_UART1_TX	0x017C
+#define CONTROL_PADCONF_UART1_RTS	0x017E
+#define CONTROL_PADCONF_UART1_CTS	0x0180
+#define CONTROL_PADCONF_UART1_RX	0x0182
+#define CONTROL_PADCONF_MCBSP4_CLKX	0x0184
+#define CONTROL_PADCONF_MCBSP4_DR	0x0186
+#define CONTROL_PADCONF_MCBSP4_DX	0x0188
+#define CONTROL_PADCONF_MCBSP4_FSX	0x018A
+#define CONTROL_PADCONF_MCBSP1_CLKR	0x018C
+#define CONTROL_PADCONF_MCBSP1_FSR	0x018E
+#define CONTROL_PADCONF_MCBSP1_DX	0x0190
+#define CONTROL_PADCONF_MCBSP1_DR	0x0192
+#define CONTROL_PADCONF_MCBSP_CLKS	0x0194
+#define CONTROL_PADCONF_MCBSP1_FSX	0x0196
+#define CONTROL_PADCONF_MCBSP1_CLKX	0x0198
+/*Serial Interface*/
+#define CONTROL_PADCONF_UART3_CTS_RCTX	0x019A
+#define CONTROL_PADCONF_UART3_RTS_SD	0x019C
+#define CONTROL_PADCONF_UART3_RX_IRRX	0x019E
+#define CONTROL_PADCONF_UART3_TX_IRTX	0x01A0
+#define CONTROL_PADCONF_HSUSB0_CLK	0x01A2
+#define CONTROL_PADCONF_HSUSB0_STP	0x01A4
+#define CONTROL_PADCONF_HSUSB0_DIR	0x01A6
+#define CONTROL_PADCONF_HSUSB0_NXT	0x01A8
+#define CONTROL_PADCONF_HSUSB0_DATA0	0x01AA
+#define CONTROL_PADCONF_HSUSB0_DATA1	0x01AC
+#define CONTROL_PADCONF_HSUSB0_DATA2	0x01AE
+#define CONTROL_PADCONF_HSUSB0_DATA3	0x01B0
+#define CONTROL_PADCONF_HSUSB0_DATA4	0x01B2
+#define CONTROL_PADCONF_HSUSB0_DATA5	0x01B4
+#define CONTROL_PADCONF_HSUSB0_DATA6	0x01B6
+#define CONTROL_PADCONF_HSUSB0_DATA7	0x01B8
+#define CONTROL_PADCONF_I2C1_SCL	0x01BA
+#define CONTROL_PADCONF_I2C1_SDA	0x01BC
+#define CONTROL_PADCONF_I2C2_SCL	0x01BE
+#define CONTROL_PADCONF_I2C2_SDA	0x01C0
+#define CONTROL_PADCONF_I2C3_SCL	0x01C2
+#define CONTROL_PADCONF_I2C3_SDA	0x01C4
+#define CONTROL_PADCONF_I2C4_SCL	0x0A00
+#define CONTROL_PADCONF_I2C4_SDA	0x0A02
+#define CONTROL_PADCONF_HDQ_SIO		0x01C6
+#define CONTROL_PADCONF_MCSPI1_CLK	0x01C8
+#define CONTROL_PADCONF_MCSPI1_SIMO	0x01CA
+#define CONTROL_PADCONF_MCSPI1_SOMI	0x01CC
+#define CONTROL_PADCONF_MCSPI1_CS0	0x01CE
+#define CONTROL_PADCONF_MCSPI1_CS1	0x01D0
+#define CONTROL_PADCONF_MCSPI1_CS2	0x01D2
+#define CONTROL_PADCONF_MCSPI1_CS3	0x01D4
+#define CONTROL_PADCONF_MCSPI2_CLK	0x01D6
+#define CONTROL_PADCONF_MCSPI2_SIMO	0x01D8
+#define CONTROL_PADCONF_MCSPI2_SOMI	0x01DA
+#define CONTROL_PADCONF_MCSPI2_CS0	0x01DC
+#define CONTROL_PADCONF_MCSPI2_CS1	0x01DE
+/*Control and debug */
+#define CONTROL_PADCONF_SYS_32K		0x0A04
+#define CONTROL_PADCONF_SYS_CLKREQ	0x0A06
+#define CONTROL_PADCONF_SYS_NIRQ	0x01E0
+#define CONTROL_PADCONF_SYS_BOOT0	0x0A0A
+#define CONTROL_PADCONF_SYS_BOOT1	0x0A0C
+#define CONTROL_PADCONF_SYS_BOOT2	0x0A0E
+#define CONTROL_PADCONF_SYS_BOOT3	0x0A10
+#define CONTROL_PADCONF_SYS_BOOT4	0x0A12
+#define CONTROL_PADCONF_SYS_BOOT5	0x0A14
+#define CONTROL_PADCONF_SYS_BOOT6	0x0A16
+#define CONTROL_PADCONF_SYS_OFF_MODE	0x0A18
+#define CONTROL_PADCONF_SYS_CLKOUT1	0x0A1A
+#define CONTROL_PADCONF_SYS_CLKOUT2	0x01E2
+#define CONTROL_PADCONF_JTAG_nTRST	0x0A1C
+#define CONTROL_PADCONF_JTAG_TCK	0x0A1E
+#define CONTROL_PADCONF_JTAG_TMS	0x0A20
+#define CONTROL_PADCONF_JTAG_TDI	0x0A22
+#define CONTROL_PADCONF_JTAG_EMU0	0x0A24
+#define CONTROL_PADCONF_JTAG_EMU1	0x0A26
+#define CONTROL_PADCONF_ETK_CLK		0x0A28
+#define CONTROL_PADCONF_ETK_CTL		0x0A2A
+#define CONTROL_PADCONF_ETK_D0		0x0A2C
+#define CONTROL_PADCONF_ETK_D1		0x0A2E
+#define CONTROL_PADCONF_ETK_D2		0x0A30
+#define CONTROL_PADCONF_ETK_D3		0x0A32
+#define CONTROL_PADCONF_ETK_D4		0x0A34
+#define CONTROL_PADCONF_ETK_D5		0x0A36
+#define CONTROL_PADCONF_ETK_D6		0x0A38
+#define CONTROL_PADCONF_ETK_D7		0x0A3A
+#define CONTROL_PADCONF_ETK_D8		0x0A3C
+#define CONTROL_PADCONF_ETK_D9		0x0A3E
+#define CONTROL_PADCONF_ETK_D10		0x0A40
+#define CONTROL_PADCONF_ETK_D11		0x0A42
+#define CONTROL_PADCONF_ETK_D12		0x0A44
+#define CONTROL_PADCONF_ETK_D13		0x0A46
+#define CONTROL_PADCONF_ETK_D14		0x0A48
+#define CONTROL_PADCONF_ETK_D15		0x0A4A
+#define CONTROL_PADCONF_ETK_CLK_ES2	0x05D8
+#define CONTROL_PADCONF_ETK_CTL_ES2	0x05DA
+#define CONTROL_PADCONF_ETK_D0_ES2	0x05DC
+#define CONTROL_PADCONF_ETK_D1_ES2	0x05DE
+#define CONTROL_PADCONF_ETK_D2_ES2	0x05E0
+#define CONTROL_PADCONF_ETK_D3_ES2	0x05E2
+#define CONTROL_PADCONF_ETK_D4_ES2	0x05E4
+#define CONTROL_PADCONF_ETK_D5_ES2	0x05E6
+#define CONTROL_PADCONF_ETK_D6_ES2	0x05E8
+#define CONTROL_PADCONF_ETK_D7_ES2	0x05EA
+#define CONTROL_PADCONF_ETK_D8_ES2	0x05EC
+#define CONTROL_PADCONF_ETK_D9_ES2	0x05EE
+#define CONTROL_PADCONF_ETK_D10_ES2	0x05F0
+#define CONTROL_PADCONF_ETK_D11_ES2	0x05F2
+#define CONTROL_PADCONF_ETK_D12_ES2	0x05F4
+#define CONTROL_PADCONF_ETK_D13_ES2	0x05F6
+#define CONTROL_PADCONF_ETK_D14_ES2	0x05F8
+#define CONTROL_PADCONF_ETK_D15_ES2	0x05FA
+/*Die to Die */
+#define CONTROL_PADCONF_D2D_MCAD0	0x01E4
+#define CONTROL_PADCONF_D2D_MCAD1	0x01E6
+#define CONTROL_PADCONF_D2D_MCAD2	0x01E8
+#define CONTROL_PADCONF_D2D_MCAD3	0x01EA
+#define CONTROL_PADCONF_D2D_MCAD4	0x01EC
+#define CONTROL_PADCONF_D2D_MCAD5	0x01EE
+#define CONTROL_PADCONF_D2D_MCAD6	0x01F0
+#define CONTROL_PADCONF_D2D_MCAD7	0x01F2
+#define CONTROL_PADCONF_D2D_MCAD8	0x01F4
+#define CONTROL_PADCONF_D2D_MCAD9	0x01F6
+#define CONTROL_PADCONF_D2D_MCAD10	0x01F8
+#define CONTROL_PADCONF_D2D_MCAD11	0x01FA
+#define CONTROL_PADCONF_D2D_MCAD12	0x01FC
+#define CONTROL_PADCONF_D2D_MCAD13	0x01FE
+#define CONTROL_PADCONF_D2D_MCAD14	0x0200
+#define CONTROL_PADCONF_D2D_MCAD15	0x0202
+#define CONTROL_PADCONF_D2D_MCAD16	0x0204
+#define CONTROL_PADCONF_D2D_MCAD17	0x0206
+#define CONTROL_PADCONF_D2D_MCAD18	0x0208
+#define CONTROL_PADCONF_D2D_MCAD19	0x020A
+#define CONTROL_PADCONF_D2D_MCAD20	0x020C
+#define CONTROL_PADCONF_D2D_MCAD21	0x020E
+#define CONTROL_PADCONF_D2D_MCAD22	0x0210
+#define CONTROL_PADCONF_D2D_MCAD23	0x0212
+#define CONTROL_PADCONF_D2D_MCAD24	0x0214
+#define CONTROL_PADCONF_D2D_MCAD25	0x0216
+#define CONTROL_PADCONF_D2D_MCAD26	0x0218
+#define CONTROL_PADCONF_D2D_MCAD27	0x021A
+#define CONTROL_PADCONF_D2D_MCAD28	0x021C
+#define CONTROL_PADCONF_D2D_MCAD29	0x021E
+#define CONTROL_PADCONF_D2D_MCAD30	0x0220
+#define CONTROL_PADCONF_D2D_MCAD31	0x0222
+#define CONTROL_PADCONF_D2D_MCAD32	0x0224
+#define CONTROL_PADCONF_D2D_MCAD33	0x0226
+#define CONTROL_PADCONF_D2D_MCAD34	0x0228
+#define CONTROL_PADCONF_D2D_MCAD35	0x022A
+#define CONTROL_PADCONF_D2D_MCAD36	0x022C
+#define CONTROL_PADCONF_D2D_CLK26MI	0x022E
+#define CONTROL_PADCONF_D2D_NRESPWRON	0x0230
+#define CONTROL_PADCONF_D2D_NRESWARM	0x0232
+#define CONTROL_PADCONF_D2D_ARM9NIRQ	0x0234
+#define CONTROL_PADCONF_D2D_UMA2P6FIQ	0x0236
+#define CONTROL_PADCONF_D2D_SPINT	0x0238
+#define CONTROL_PADCONF_D2D_FRINT	0x023A
+#define CONTROL_PADCONF_D2D_DMAREQ0	0x023C
+#define CONTROL_PADCONF_D2D_DMAREQ1	0x023E
+#define CONTROL_PADCONF_D2D_DMAREQ2	0x0240
+#define CONTROL_PADCONF_D2D_DMAREQ3	0x0242
+#define CONTROL_PADCONF_D2D_N3GTRST	0x0244
+#define CONTROL_PADCONF_D2D_N3GTDI	0x0246
+#define CONTROL_PADCONF_D2D_N3GTDO	0x0248
+#define CONTROL_PADCONF_D2D_N3GTMS	0x024A
+#define CONTROL_PADCONF_D2D_N3GTCK	0x024C
+#define CONTROL_PADCONF_D2D_N3GRTCK	0x024E
+#define CONTROL_PADCONF_D2D_MSTDBY	0x0250
+#define CONTROL_PADCONF_D2D_SWAKEUP	0x0A4C
+#define CONTROL_PADCONF_D2D_IDLEREQ	0x0252
+#define CONTROL_PADCONF_D2D_IDLEACK	0x0254
+#define CONTROL_PADCONF_D2D_MWRITE	0x0256
+#define CONTROL_PADCONF_D2D_SWRITE	0x0258
+#define CONTROL_PADCONF_D2D_MREAD	0x025A
+#define CONTROL_PADCONF_D2D_SREAD	0x025C
+#define CONTROL_PADCONF_D2D_MBUSFLAG	0x025E
+#define CONTROL_PADCONF_D2D_SBUSFLAG	0x0260
+#define CONTROL_PADCONF_SDRC_CKE0	0x0262
+#define CONTROL_PADCONF_SDRC_CKE1	0x0264
+
+#define MUX_VAL(OFFSET,VALUE)\
+	writew((VALUE), PNX84XX_CTRL_BASE + (OFFSET));
+
+#define	CP(x)	(CONTROL_PADCONF_##x)
+
+#endif
diff --git a/include/asm-arm/arch-pnx84xx/omap_gpmc.h b/include/asm-arm/arch-pnx84xx/omap_gpmc.h
new file mode 100644
index 0000000..bd22bce
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/omap_gpmc.h
@@ -0,0 +1,83 @@
+/*
+ * (C) Copyright 2004-2008 Texas Instruments, <www.ti.com>
+ * Rohit Choraria <rohitkc@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_ARCH_OMAP_GPMC_H
+#define __ASM_ARCH_OMAP_GPMC_H
+
+#define GPMC_BUF_EMPTY	0
+#define GPMC_BUF_FULL	1
+
+#define ECCCLEAR	(0x1 << 8)
+#define ECCRESULTREG1	(0x1 << 0)
+#define ECCSIZE512BYTE	0xFF
+#define ECCSIZE1	(ECCSIZE512BYTE << 22)
+#define ECCSIZE0	(ECCSIZE512BYTE << 12)
+#define ECCSIZE0SEL	(0x000 << 0)
+
+/* Generic ECC Layouts */
+/* Large Page x8 NAND device Layout */
+#ifdef GPMC_NAND_ECC_LP_x8_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 12,\
+	.eccpos = {1, 2, 3, 4, 5, 6, 7, 8,\
+		9, 10, 11, 12},\
+	.oobfree = {\
+		{.offset = 13,\
+		 .length = 51 } } \
+}
+#endif
+
+/* Large Page x16 NAND device Layout */
+#ifdef GPMC_NAND_ECC_LP_x16_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 12,\
+	.eccpos = {2, 3, 4, 5, 6, 7, 8, 9,\
+		10, 11, 12, 13},\
+	.oobfree = {\
+		{.offset = 14,\
+		 .length = 50 } } \
+}
+#endif
+
+/* Small Page x8 NAND device Layout */
+#ifdef GPMC_NAND_ECC_SP_x8_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 3,\
+	.eccpos = {1, 2, 3},\
+	.oobfree = {\
+		{.offset = 4,\
+		 .length = 12 } } \
+}
+#endif
+
+/* Small Page x16 NAND device Layout */
+#ifdef GPMC_NAND_ECC_SP_x16_LAYOUT
+#define GPMC_NAND_HW_ECC_LAYOUT {\
+	.eccbytes = 3,\
+	.eccpos = {2, 3, 4},\
+	.oobfree = {\
+		{.offset = 5,\
+		 .length = 11 } } \
+}
+#endif
+
+#endif /* __ASM_ARCH_OMAP_GPMC_H */
diff --git a/include/asm-arm/arch-pnx84xx/platform.h b/include/asm-arm/arch-pnx84xx/platform.h
new file mode 100644
index 0000000..8b8a24a
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/platform.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright  2009(C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+
+
+#define APOLLO_CLOCK_FREQ	(100000000 / HZ)
+
+/*
+ * Memory definitions
+ */
+//#define APOLLO_BOOT_ROM_LO	0xFFFF0000		/* DoC Base (64Kb) */
+//#define APOLLO_BOOT_ROM_HI	(0xFFFF0000 + SZ_64K)
+//#define APOLLO_BOOT_ROM_BASE	APOLLO_BOOT_ROM_HI	/* Normal position */
+//#define APOLLO_BOOT_ROM_SIZE	SZ_64K
+
+//#define APOLLO_SSRAM_BASE	/* APOLLO_SSMC_BASE ? */
+//#define APOLLO_SSRAM_SIZE	SZ_2M
+
+//#define APOLLO_FLASH_BASE	0xc0000000		/* NOR */
+//#define APOLLO_FLASH_SIZE	SZ_256M			/* dec. size 0x10000000 */
+
+/*
+ *  SDRAM
+ */
+#define APOLLO_SDRAM_BASE	0x00000000
+
+
+/*
+ *  MMIO Devices
+ */
+#define UART1_PORT0_OFFSET          0xE0000     /* Uart 1 -> Console */
+
+#define MMIO_BASE                   0xE0400000
+#define MMIO_HOST_ARM_MMIO_BASE     0xE0600000
+#define MMIO_UART1_BASE             (MMIO_HOST_ARM_MMIO_BASE + UART1_PORT0_OFFSET)
+
+#define IP3106_UART_BASE0           MMIO_UART1_BASE
+
+
+/*
+ * Cortex A9 Internal Peripheral IP
+ */
+#define APOLLO_CORTEX_A9_SCU_OFFSET         0x0000
+#define APOLLO_CORTEX_A9_INTC_OFFSET        0x0100
+#define APOLLO_CORTEX_A9_GLOB_TIMER_OFFSET  0x0200
+#define APOLLO_CORTEX_A9_PRIV_TIMER_OFFSET  0x0600
+#define APOLLO_CORTEX_A9_DISTR_OFFSET       0x1000
+
+#define APOLLO_CORTEX_A9_PERIPHBASE         0xE0100000
+#define APOLLO_CORTEX_A9_INTC_BASE          (APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_INTC_OFFSET)
+#define APOLLO_CORTEX_A9_TIMER_BASE         (APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_PRIV_TIMER_OFFSET)
+#define APOLLO_CORTEX_A9_DISTR_BASE         (APOLLO_CORTEX_A9_PERIPHBASE + APOLLO_CORTEX_A9_DISTR_OFFSET)
+
+
+
diff --git a/include/asm-arm/arch-pnx84xx/pnx84xx.h b/include/asm-arm/arch-pnx84xx/pnx84xx.h
new file mode 100644
index 0000000..d46f6ec
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/pnx84xx.h
@@ -0,0 +1,268 @@
+/*
+ * (C) Copyright 2006-2009
+ * NXP Semiconductors
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _PNX84XX_H_
+#define _PNX84XX_H_
+
+#define PNX84XX_IO_BASE		0xE0600000
+#define PNX84XX_PRIV_BASE	0xE0100000
+
+/* Stuff on L3 Interconnect */
+#define SMX_APE_BASE			0x68000000
+
+
+/* GCS */
+#define PNX84XX_GCS_BASE			( PNX84XX_IO_BASE + 0x30000 )
+#define PNX84XX_GCS_IP2016_OFSET   	(0x0000)	/* NOR controller offset */
+#define PNX84XX_GCS_IP2017_OFSET   	(0x1000)	/* NAND controller offset */
+#define PNX84XX_GCS_SPI_OFSET   	(0x2000)
+#define PNX84XX_GCS_ISA_OFSET   	(0x3000)
+#define PNX84XX_GCS_IP1902_OFSET   	(0x4000)	/* DMA controller offset  */
+#define PNX84XX_GCS_IP3413_OFSET   	(0x5000)    /* SDIO */
+#define PNX84XX_GCS_CFG_OFSET   	(0x6000)
+
+/* RGU */
+#define PNX84XX_RGU_BASE		( PNX84XX_IO_BASE + 0xE6000 )
+
+/* SMS */
+#define PNX84XX_SMS_BASE		0x6C000000
+
+/* SDRC */
+#define PNX84XX_SDRC_BASE		( PNX84XX_IO_BASE + 0x64000 )
+
+/* Make it possible to use Mips peripherals */
+#define KSEG1ADDR(p)			(p)
+/*
+ * L4 Peripherals - L4 Wakeup and L4 Core now
+ */
+#define PNX84XX_CORE_L4_IO_BASE		0xE0600000
+#define PNX84XX_WAKEUP_L4_IO_BASE	0x48300000
+#define PNX84XX_ID_L4_IO_BASE		0x4830A200
+#define PNX84XX_L4_PER				0x49000000
+#define PNX84XX_L4_IO_BASE			PNX84XX_CORE_L4_IO_BASE
+
+/* Global Reg */
+#define PNX84XX_GREG_BASE			( PNX84XX_IO_BASE + 0xEA000 )
+
+#ifndef __ASSEMBLY__
+typedef struct global_reg {
+	unsigned char res_arm_config[0x100];        /* 0x000 */
+	unsigned char res_peripheral_config[0x100];	/* 0x100 */
+	unsigned char res_various_config[0x100];	/* 0x200 */
+	unsigned char res_IPcontrols_config[0x100];	/* 0x300 */
+	unsigned char res_TM_config[0x100];     	/* 0x400 */
+	unsigned char res_spare_config[0x100];	    /* 0x500 */
+	unsigned char res_AFE_config[0x100];     	/* 0x600 */
+	unsigned char res1[0x600];
+	unsigned char res_debug_config[0x100];	    /* 0xc00 */
+	unsigned char res_scratch_config[0x100];	/* 0xd00 */
+	unsigned char res_semaphores_config[0x100];	/* 0xe00 */
+	unsigned char res_IPC_config[0xfc]; 		/* 0xf00 */
+	unsigned int  globalreg_module_id;		    /* 0xffe */
+} global_reg_t;
+#endif /* __ASSEMBLY__ */
+
+#define GPIO_PIN_MUX_REG_0              0
+#define GPIO_PIN_MUX_REG_1              1
+#define GPIO_PIN_MUX_REG_2              2
+#define GPIO_PIN_MUX_REG_3              3
+#define GPIO_PIN_MUX_REG_4              4
+#define GPIO_PIN_MUX_REG_5              5
+#define GPIO_PIN_MUX_REG_6              6
+
+#define GPIO_SEC_PIN_MUX_REG_0          8
+#define GPIO_SEC_PIN_MUX_REG_1          9
+#define GPIO_SEC_PIN_MUX_REG_2         10
+#define GPIO_SEC_PIN_MUX_REG_3         11
+#define GPIO_SEC_PIN_MUX_REG_4         12
+#define GPIO_SEC_PIN_MUX_REG_5         13
+#define GPIO_SEC_PIN_MUX_REG_6         14
+#define ALT_PIN_MUX_REG_0              16
+#define ALT_PIN_MUX_REG_1              17
+#define ALT_PIN_MUX_REG_2              18
+
+
+/* UART */
+#define PNX84XX_UART1				(PNX84XX_L4_IO_BASE + 0xe0000)
+#define PNX84XX_UART2				(PNX84XX_L4_IO_BASE + 0xe1000)
+#define PNX84XX_UART3				(PNX84XX_L4_IO_BASE + 0xe2000)
+
+/* General Purpose Timers */
+#define CONFIG_SYS_TIMERBASE		(PNX84XX_IO_BASE + 0xe8000)
+#define CONFIG_SYS_LOCALTIMERBASE	(PNX84XX_PRIV_BASE + 0x600)
+/* timer regs offsets (32 bit regs) */
+#define IP3012_TIMER_CONTROL	0x00	/* rw */
+#define IP3012_TIMER_COUNTER	0x04	/* rw */
+#define IP3012_TIMER_PRESCALE	0x08	/* rw */
+
+
+/* WatchDog Timers (1 GP) */
+#define WD1_BASE			    	(PNX84XX_GPT1 + 0x20)
+
+/* 32KTIMER */
+#define SYNC_32KTIMER_BASE			0x48320000
+
+#ifndef __ASSEMBLY__
+
+typedef struct s32ktimer {
+	unsigned char res[0x10];
+	unsigned int s32k_cr;		/* 0x10 */
+} s32ktimer_t;
+
+#endif /* __ASSEMBLY__ */
+
+/* OMAP3 GPIO registers */
+#define PNX84XX_GPIO1_BASE		0x48310000
+#define PNX84XX_GPIO2_BASE		0x49050000
+#define PNX84XX_GPIO3_BASE		0x49052000
+#define PNX84XX_GPIO4_BASE		0x49054000
+#define PNX84XX_GPIO5_BASE		0x49056000
+#define PNX84XX_GPIO6_BASE		0x49058000
+
+#ifndef __ASSEMBLY__
+typedef struct gpio {
+	unsigned char res1[0x34];
+	unsigned int oe;		/* 0x34 */
+	unsigned int datain;		/* 0x38 */
+	unsigned char res2[0x54];
+	unsigned int cleardataout;	/* 0x90 */
+	unsigned int setdataout;	/* 0x94 */
+} gpio_t;
+#endif /* __ASSEMBLY__ */
+
+#define GPIO0				(0x1 << 0)
+#define GPIO1				(0x1 << 1)
+#define GPIO2				(0x1 << 2)
+#define GPIO3				(0x1 << 3)
+#define GPIO4				(0x1 << 4)
+#define GPIO5				(0x1 << 5)
+#define GPIO6				(0x1 << 6)
+#define GPIO7				(0x1 << 7)
+#define GPIO8				(0x1 << 8)
+#define GPIO9				(0x1 << 9)
+#define GPIO10				(0x1 << 10)
+#define GPIO11				(0x1 << 11)
+#define GPIO12				(0x1 << 12)
+#define GPIO13				(0x1 << 13)
+#define GPIO14				(0x1 << 14)
+#define GPIO15				(0x1 << 15)
+#define GPIO16				(0x1 << 16)
+#define GPIO17				(0x1 << 17)
+#define GPIO18				(0x1 << 18)
+#define GPIO19				(0x1 << 19)
+#define GPIO20				(0x1 << 20)
+#define GPIO21				(0x1 << 21)
+#define GPIO22				(0x1 << 22)
+#define GPIO23				(0x1 << 23)
+#define GPIO24				(0x1 << 24)
+#define GPIO25				(0x1 << 25)
+#define GPIO26				(0x1 << 26)
+#define GPIO27				(0x1 << 27)
+#define GPIO28				(0x1 << 28)
+#define GPIO29				(0x1 << 29)
+#define GPIO30				(0x1 << 30)
+#define GPIO31				(0x1 << 31)
+
+/* base address for indirect vectors (internal boot mode) */
+#define SRAM_OFFSET0			0x00000000
+#define SRAM_OFFSET1			0x00200000
+#define SRAM_OFFSET2			0x0000F800
+#define SRAM_VECT_CODE			(SRAM_OFFSET0 | SRAM_OFFSET1 | \
+					 SRAM_OFFSET2)
+
+#define LOW_LEVEL_SRAM_STACK		0x00078000
+
+#define DEBUG_LED1			149	/* gpio */
+#define DEBUG_LED2			150	/* gpio */
+
+#define XDR_POP			5	/* package on package part */
+#define SDR_DISCRETE	4	/* 128M memory SDR module */
+#define DDR_STACKED		3	/* stacked part on 2422 */
+#define DDR_COMBO		2	/* combo part on cpu daughter card */
+#define DDR_DISCRETE	1	/* 2x16 parts on daughter card */
+
+#define DDR_100			100	/* type found on most mem d-boards */
+#define DDR_111			111	/* some combo parts */
+#define DDR_133			133	/* most combo, some mem d-boards */
+#define DDR_165			165	/* future parts */
+
+#define CPU_3430	0x3430
+
+/*
+ * 8400 real hardware:
+ *  ES1     = rev 0
+ *
+ * 8400 code defines:
+ * ES1     = 0+1 = 1
+ * ES1     = 1+1 = 1
+ */
+#define CPU_8400_ES1		1
+#define CPU_8400_ES2		2
+
+#define WIDTH_8BIT		0x0000
+#define WIDTH_16BIT		0x1000	/* bit pos for 16 bit in gpmc */
+
+/* SDP definitions according to FPGA Rev. Is this OK?? */
+#define SDP_3430_V1		0x1
+#define SDP_3430_V2		0x2
+
+/* EVM definitions */
+#define OMAP3EVM_V1		0x1
+#define OMAP3EVM_V2		0x2
+
+/* I2C power management companion definitions */
+#define PWRMGT_ADDR_ID1		0x48
+#define PWRMGT_ADDR_ID2		0x49
+#define PWRMGT_ADDR_ID3		0x4A
+#define PWRMGT_ADDR_ID4		0x4B
+
+/* I2C ID3 (slave3) register */
+#define LEDEN			0xEE
+
+#define LEDAON			(0x1 << 0)
+#define LEDBON			(0x1 << 1)
+#define LEDAPWM			(0x1 << 4)
+#define LEDBPWM			(0x1 << 5)
+
+/* I2C ID4 (slave4) register */
+#define VAUX2_DEV_GRP		0x76
+#define VAUX2_DEDICATED		0x79
+#define VAUX3_DEV_GRP		0x7A
+#define VAUX3_DEDICATED		0x7D
+#define VMMC1_DEV_GRP		0x82
+#define VMMC1_DEDICATED		0x85
+#define VPLL2_DEV_GRP		0x8E
+#define VPLL2_DEDICATED		0x91
+#define VDAC_DEV_GRP		0x96
+#define VDAC_DEDICATED		0x99
+
+#define DEV_GRP_P1		0x20
+#define DEV_GRP_ALL		0xE0
+
+#define VAUX2_VSEL_28		0x09
+#define VAUX3_VSEL_28		0x03
+#define VPLL2_VSEL_18		0x05
+#define VDAC_VSEL_18		0x03
+#define VMMC1_VSEL_30		0x02
+
+#endif
diff --git a/include/asm-arm/arch-pnx84xx/sys_proto.h b/include/asm-arm/arch-pnx84xx/sys_proto.h
new file mode 100644
index 0000000..3afecd9
--- /dev/null
+++ b/include/asm-arm/arch-pnx84xx/sys_proto.h
@@ -0,0 +1,71 @@
+/*
+ * (C) Copyright 2004-2008
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _SYS_PROTO_H_
+#define _SYS_PROTO_H_
+
+typedef struct {
+	u32 board_type_v1;
+	u32 board_type_v2;
+	u32 mtype;
+	char *board_string;
+	char *nand_string;
+} pnx84xx_sysinfo;
+
+void prcm_init(void);
+void per_clocks_enable(void);
+
+void memif_init(void);
+void sdrc_init(void);
+void do_sdrc_init(u32, u32);
+void gpmc_init(void);
+
+void watchdog_init(void);
+void set_muxconf_regs(void);
+
+u32 get_cpu_rev(void);
+u32 get_mem_type(void);
+u32 get_sysboot_value(void);
+u32 is_gpmc_muxed(void);
+u32 get_gpmc0_type(void);
+u32 get_gpmc0_width(void);
+u32 get_board_type(void);
+void display_board_info(u32);
+u32 get_sdr_cs_size(u32);
+u32 get_sdr_cs_offset(u32);
+u32 is_running_in_sdram(void);
+u32 is_running_in_sram(void);
+u32 is_running_in_flash(void);
+u32 get_device_type(void);
+void l2cache_enable(void);
+void secureworld_exit(void);
+void setup_auxcr(void);
+void try_unlock_memory(void);
+u32 get_boot_type(void);
+void v7_flush_dcache_all(u32);
+void sr32(void *, u32, u32, u32);
+u32 wait_on_value(u32, u32, void *, u32);
+void sdelay(unsigned long);
+void make_cs1_contiguous(void);
+void omap_nand_switch_ecc(int);
+void power_init_r(void);
+void dieid_num_r(void);
+
+#endif
diff --git a/include/configs/vpe_apollo.h b/include/configs/vpe_apollo.h
new file mode 100644
index 0000000..6d9f10b
--- /dev/null
+++ b/include/configs/vpe_apollo.h
@@ -0,0 +1,403 @@
+/*
+ * (C) Copyright 2005-2009
+ * NXP Semiconuctors,
+ * Tjeu Horsch <tjeu.horsch@nxp.com>
+ *
+ * Configuration settings for the NXP Apollo virtual prototyping environment .
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_PNX			1	/* in a NXP nexperia core */
+#define CONFIG_PNX84XX		1	/* which is a APOLLO */
+#define CONFIG_PNX8493		1	/* which is in a pnx8493 */
+
+#if 0     /* 0 is EMU,  1 for VPE */
+#define CONFIG_PNX_VPE		1   /* working with VPE */
+#else
+#define CONFIG_PNX_EMU		1 	/* working on emulator */
+#endif
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/pnx84xx.h>
+
+/* Clock config to target*/
+#define PRCM_CONFIG_I		1
+/* #define PRCM_CONFIG_II	1 */
+
+/* Boot method */
+/* uncomment if you use NOR boot */
+/* #define CONFIG_SYS_NOR_BOOT		1  */
+
+/* uncomment if you use NOR */
+/* #define CONFIG_SYS_USE_NOR		1 */
+
+/* uncomment if you want to use UBI */
+/* #define CONFIG_SYS_USE_UBI  */
+
+
+#define	V_SCLK	50000000
+
+/* input clock of PLL */
+#define	CONFIG_SYS_CLK_FREQ	V_SCLK
+#ifdef CONFIG_PNX_EMU
+#define	CONFIG_SYS_PERICLK_FREQ	25000000
+#else
+#define	CONFIG_SYS_PERICLK_FREQ	25000000
+#endif
+#undef	CONFIG_USE_IRQ	/* no support for IRQs */
+#define	CONFIG_MISC_INIT_R
+
+#define	CONFIG_CMDLINE_TAG	1	/* enable passing of ATAGs */
+#define	CONFIG_SETUP_MEMORY_TAGS	1
+#define	CONFIG_INITRD_TAG	1
+#define	CONFIG_REVISION_TAG	1
+
+#define CONFIG_MEMORY_UPPER_CODE
+#define CONFIG_SYS_UBOOT_SIZE		(SZ_4M)
+/*
+ * Size of malloc() pool
+ */
+#define	CONFIG_SYS_MALLOC_LEN	( SZ_2M)
+/* bytes reserved for initial data */
+#define	CONFIG_SYS_GBL_DATA_SIZE	512
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * SMC91c96 Etherent
+ */
+
+/*
+#define	CONFIG_DRIVER_LAN91C96
+#define	CONFIG_LAN91C96_BASE	(APOLLON_CS1_BASE+0x300)
+#define	CONFIG_LAN91C96_EXT_PHY
+*/
+
+/*
+ * NS16550 Configuration
+ */
+#ifdef CONFIG_PNX_EMU
+#define	V_NS16550_CLK	(76800)	/* 76800 Khz  */
+#else
+#define	V_NS16550_CLK	(25000000)	/* 25MHz  */
+#endif
+
+
+#define	CONFIG_SYS_NS16550
+#define	CONFIG_SYS_NS16550_SERIAL
+#define	CONFIG_SYS_NS16550_REG_SIZE	(-4)
+/*#define	CONFIG_SYS_NS16550_REG_SIZE	(4)  */
+#define	CONFIG_SYS_NS16550_CLK	V_NS16550_CLK	/* 3MHz (1.5MHz*2) */
+#ifdef CONFIG_PNX_EMU
+#define	CONFIG_SYS_NS16550_COM1	PNX84XX_UART3
+#endif
+#ifdef CONFIG_PNX_VPE
+#define	CONFIG_SYS_NS16550_COM1	PNX84XX_UART1
+#endif
+
+/*
+ * select serial console configuration
+ */
+#define	CONFIG_SERIAL1	1	/* UART1 */
+
+/* allow to overwrite serial and ethaddr */
+#define	CONFIG_ENV_OVERWRITE
+#define	CONFIG_CONS_INDEX	1
+#define	CONFIG_BAUDRATE		4800
+#define	CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600, 115200}
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include	<config_cmd_default.h>
+
+/* #define	CONFIG_CMD_DHCP  */
+#undef CONFIG_CMD_NET
+#undef CONFIG_CMD_NFS
+
+#define	CONFIG_CMD_DIAG
+/* #define	CONFIG_CMD_ONENAND  */
+
+#ifdef CONFIG_SYS_USE_UBI
+#define	CONFIG_CMD_JFFS2
+#define	CONFIG_CMD_UBI
+#define	CONFIG_RBTREE
+#define CONFIG_MTD_PARTITIONS
+#endif
+
+#define	CONFIG_CMD_AUTOSCRIPT
+
+
+	#define CONFIG_CMD_BSP		/* Board Specific functions	*/
+/*	#define CONFIG_CMD_CACHE	*//* icache, dcache		*/
+	#define CONFIG_CMD_DHCP		/* DHCP Support			*/
+	#define CONFIG_CMD_DIAG		/* Diagnostics			*/
+	#define CONFIG_CMD_FAT		/* FAT support			*/
+	#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+/*	#define CONFIG_CMD_I2C		*//* I2C serial bus support	*/
+	#undef  CONFIG_CMD_IMI		/* iminfo			*/
+	#undef  CONFIG_CMD_IMLS		/* List all found images	*/
+/*	#define CONFIG_CMD_JFFS2	*//* JFFS2 Support		*/
+	#define CONFIG_CMD_LOADB	/* loadb			*/
+	#define CONFIG_CMD_LOADS	/* loads			*/
+	#define CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop mtest */
+	#define CONFIG_CMD_MII		/* MII support			*/
+	#define CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+	#define CONFIG_CMD_MTDPARTS  /* MTD functions 		*/
+	#define CONFIG_CMD_NAND		/* NAND support			*/
+
+	#define CONFIG_NET_MULTI
+	#define CONFIG_BOOTP_SUBNETMASK
+	#define CONFIG_BOOTP_GATEWAY
+	#define CONFIG_BOOTP_DNS
+
+	#define CONFIG_CMD_NFS		/* NFS support		*/
+	#define CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+	#undef  CONFIG_CMD_ONENAND	/* OneNAND support		*/
+	#undef  CONFIG_CMD_PCI		/* pciinfo			*/
+/*	#define CONFIG_CMD_PCI		*//* pciinfo			*/
+	#define CONFIG_CMD_PING		/* ping support			*/
+	#define CONFIG_CMD_PORTIO	/* Port I/O			*/
+	#define CONFIG_CMD_REGINFO	/* Register dump		*/
+	#define CONFIG_CMD_RUN		/* run command in env variable	*/
+	#define	CONFIG_CMD_SARI		/* Simple arithmetic operations */
+/*	#define CONFIG_CMD_SDRAM	*//* SDRAM DIMM SPD info printout */
+/*	#define CONFIG_CMD_UBIFS	*//* UBIFS Support		*/
+/*	#define CONFIG_CMD_USB		*//* USB Support			*/\
+
+#ifdef CONFIG_CMD_NET
+
+    #define CONFIG_LIPP_6300ETH
+    #define CONFIG_USING_EMU_PHY
+    #define __USING_EMU_PHY__
+    #define TMFL_LIPP6100ETH_GMII_ADDRESS_CSR_VAL 0x4U
+    #define TMFL_LIPP6100ETH_GMII_PHY_ADDRESS_VAL 0x0U
+    #define __NULL_PHY__
+ //   #define CONFIG_NET_RETRY_COUNT 50
+
+    #define	CONFIG_NETMASK 255.255.255.0
+    #define	CONFIG_IPADDR 192.168.2.5
+    #define	CONFIG_SERVERIP 192.168.2.2
+    #define	CONFIG_BOOTFILE "loadfiles.mi"
+    #define	CONFIG_ETHADDR aa:bb:cc:dd:ee:ff
+
+    #define CONFIG_LOADADDR		0x09F00000
+    #define CONFIG_BOOTP_SERVERIP 10.0.0.9 //dummy
+
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Environment configuration
+ */
+#define  CONFIG_ENV_IS_NOWHERE
+
+#if (0)        /* TH */
+#if defined(CONFIG_CMD_NAND)
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		0x0003C000	/* Address of Environment Sector*/
+#endif
+#endif
+
+#if defined(CFG_ONENAND)
+#undef  CONFIG_ENV_IS_NOWHERE
+#define	CONFIG_ENV_IS_IN_ONENAND
+#define CONFIG_ENV_ADDR         0x00120000
+#endif
+
+#define CONFIG_ENV_SIZE		  0x00002000	/* Size of Environment Sector	*/
+
+/*
+#define	CONFIG_BOOTP_MASK	CONFIG_BOOTP_DEFAULT
+*/
+
+#define	CONFIG_BOOTDELAY	-1
+
+
+#define CONFIG_SYS_MEM	"mem=64M"
+
+#ifdef CONFIG_SYS_USE_UBI
+#define CONFIG_SYS_UBI "ubi.mtd=4"
+#else
+#define CONFIG_SYS_UBI ""
+#endif
+
+#define CONFIG_BOOTARGS "root=/dev/nfs rw " CONFIG_SYS_MEM \
+	" console=ttyS0,115200n8" \
+	" ip=192.168.116.25:192.168.116.1:192.168.116.1:255.255.255.0:" \
+	"apollon:eth0:off nfsroot=/tftpboot/nfsroot profile=2 " \
+	CONFIG_SYS_UBI
+
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+	"Image=tftp 0x80008000 Image; go 0x80008000\0"			\
+	"zImage=tftp 0x80180000 zImage; go 0x80180000\0"		\
+	"uImage=tftp 0x80180000 uImage; bootm 0x80180000\0"		\
+	"uboot=tftp 0x80008000 u-boot.bin; go 0x80008000\0"		\
+	"xloader=tftp 0x80180000 x-load.bin; "				\
+	" cp.w 0x80180000 0x00000400 0x1000; go 0x00000400\0"		\
+	"syncmode50=mw.w 0x1e442 0xc0c4; mw 0x6800a060 0xe30d1201\0"	\
+	"syncmode=mw.w 0x1e442 0xe0f4; mw 0x6800a060 0xe30d1201\0"	\
+	"norboot=cp32 0x18040000 0x80008000 0x200000; go 0x80008000\0"	\
+	"oneboot=onenand read 0x80008000 0x40000 0x200000; go 0x80008000\0" \
+	"onesyncboot=run syncmode oneboot\0"				\
+	"updateb=tftp 0x80180000 u-boot-onenand.bin; "			\
+	" onenand erase 0x0 0x20000; onenand write 0x80180000 0x0 0x20000\0" \
+	"ubi=setenv bootargs ${bootargs} ubi.mtd=4 ${mtdparts}; run uImage\0" \
+	"bootcmd=run uboot\0"
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	V_PROMPT	"Apollo # "
+
+#define	CONFIG_SYS_LONGHELP	/* undef to save memory */
+#define	CONFIG_SYS_PROMPT	V_PROMPT
+#define	CONFIG_SYS_CBSIZE	256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define	CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define	CONFIG_SYS_MAXARGS	16	/* max number of command args */
+/* Boot Argument Buffer Size */
+#define	CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE
+/* memtest works on */
+#define	CONFIG_SYS_MEMTEST_START	(PNX84XX_SDRC_CS0)
+#define	CONFIG_SYS_MEMTEST_END		(PNX84XX_SDRC_CS0+SZ_32M)
+
+#undef	CONFIG_SYS_CLKS_IN_HZ	/* everything, incl board info, in Hz */
+/* default load address */
+#define	CONFIG_SYS_LOAD_ADDR	(PNX84XX_SDRC_CS0)
+
+/* The PNX84XX uses the timers in the cortex-A9 driven by the SysClk (12/13/19.2)
+ * This rate is divided by a local
+ * divisor.
+ */
+#define	V_PTV	4 	/* TODO: correct value */
+
+#define	CONFIG_SYS_PTV	V_PTV	/* 2^(pvt+1) */
+#define	CONFIG_PERTIMER_CLOCK_HZ (CONFIG_SYS_PERICLK_FREQ)
+#define	CONFIG_SYS_HZ		 1000
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define	CONFIG_STACKSIZE SZ_64K	/* regular stack */
+#ifdef	CONFIG_USE_IRQ
+# define	CONFIG_STACKSIZE_IRQ SZ_4K	/* IRQ stack */
+# define	CONFIG_STACKSIZE_FIQ SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define	CONFIG_NR_DRAM_BANKS	1	/* CS1 may or may not be populated */
+#define	PHYS_SDRAM_1		PNX84XX_SDRC_CS0
+#define	PHYS_SDRAM_1_SIZE	SZ_128M
+#define	PHYS_SDRAM_2		PNX84XX_SDRC_CS1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#undef	CONFIG_CRAMFS		 /* No CRAM FS support although JFFS2 support */
+#define CONFIG_DOS_PARTITION
+/*-----------------------------------------------------------------------
+ * NOR flash configuration
+ */
+#define CONFIG_SYS_NO_CFI     /* disable nor flash support */
+#ifndef CONFIG_SYS_NO_CFI
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_FLASH_CFI_MTD
+#else
+#define CONFIG_SYS_NO_FLASH   /* disable  flash support */
+#undef CONFIG_SYS_FLASH_CFI
+#undef CONFIG_FLASH_CFI_DRIVER
+#undef CONFIG_FLASH_CFI_MTD
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND flash configuration
+ */
+
+#define CONFIG_SYS_FLASH_BASE		0xc0000000
+#define CONFIG_SYS_MONITOR_BASE		0x0A000000
+
+#undef  CFG_NAND_LEGACY
+#undef  CFG_NAND
+#undef	CONFIG_NAND_NXP_IPA051
+
+#if defined(CONFIG_CMD_NAND)
+#define CONFIG_DMAC_NXP_1902
+#define CONFIG_NAND_NXP_2070
+#define CONFIG_MTD_NX_NAND_HWECC
+#endif
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	4		/* Max number of NAND devices		*/
+#define CONFIG_SYS_NAND_MAX_CHIPS   1       /* TH nuber of chips in a device?)  */
+#define CONFIG_SYS_MAX_FLASH_SECT	(520)
+#define CONFIG_SYS_MAX_FLASH_BANKS 4
+#define CFG_NAND_QUIET			1
+
+/* Note: NAND_BASE refers to the xio profiles, in board_nand_init the correct base
+   values are retreived from the xio profiles
+*/
+#define CONFIG_SYS_NAND_BASE	        0x814, 0x818, 0x81C, 0x834, 0x838
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define NAND_MAX_FLOORS 		1
+#define NAND_MAX_CHIPS 			1
+#define NAND_ChipID_UNKNOWN		0x00
+#define SECTORSIZE			512
+
+/* UBIFS support */
+#ifdef CONFIG_CMD_UBIFS
+#define CONFIG_SYS_64BIT_VSPRINTF
+#define CONFIG_LZO
+#endif
+
+#define CONFIG_MTD_DEVICE
+
+#ifdef CONFIG_CMD_UBI
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_RBTREE
+#else
+#undef  CONFIG_MTD_PARTITIONS
+#undef  CONFIG_RBTREE
+#endif
+
+/* JFFS2 support */
+#ifdef CONFIG_CMD_JFFS2
+#define	CONFIG_JFFS2_CMDLINE		1
+#define	CONFIG_JFFS2_DEV		"nand0"
+#define	CONFIG_JFFS2_NAND
+#define	MTDIDS_DEFAULT			"nand0=sys"
+#define	MTDPARTS_DEFAULT		"mtdparts=sys:11232k@176k(bootfs);sys:4000k@11408k(rootfs)"
+#endif
+
+#endif /* __CONFIG_H */
diff --git a/include/linux/mtd/bbm.h b/include/linux/mtd/bbm.h
index 7db2546..abf8f1a 100644
--- a/include/linux/mtd/bbm.h
+++ b/include/linux/mtd/bbm.h
@@ -18,8 +18,8 @@
 #define __LINUX_MTD_BBM_H
 
 /* The maximum number of NAND chips in an array */
-#ifndef CONFIG_SYS_NAND_MAX_CHIPS
-#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#ifndef NAND_MAX_CHIPS
+#define NAND_MAX_CHIPS		8
 #endif
 
 /**
@@ -48,10 +48,10 @@
  */
 struct nand_bbt_descr {
 	int options;
-	int pages[CONFIG_SYS_NAND_MAX_CHIPS];
+	int pages[NAND_MAX_CHIPS];
 	int offs;
 	int veroffs;
-	uint8_t version[CONFIG_SYS_NAND_MAX_CHIPS];
+	uint8_t version[NAND_MAX_CHIPS];
 	int len;
 	int maxblocks;
 	int reserved_block_code;
diff --git a/include/linux/mtd/mtd-abi.h b/include/linux/mtd/mtd-abi.h
index 410c5dd..3c7cb36 100644
--- a/include/linux/mtd/mtd-abi.h
+++ b/include/linux/mtd/mtd-abi.h
@@ -34,6 +34,7 @@ struct mtd_oob_buf {
 #define MTD_BIT_WRITEABLE	0x800	/* Single bits can be flipped */
 #define MTD_NO_ERASE		0x1000	/* No erase necessary */
 #define MTD_STUPID_LOCK		0x2000	/* Always locked after reset */
+#define MTD_USE_DEV_OOB_LAYOUT    0x10000 /* Use Device OOB Layout */
 
 /* Some common devices / combinations of capabilities */
 #define MTD_CAP_ROM		0
@@ -108,7 +109,7 @@ struct nand_oobinfo {
 	uint32_t useecc;
 	uint32_t eccbytes;
 	uint32_t oobfree[8][2];
-	uint32_t eccpos[48];
+	uint32_t eccpos[96];
 };
 
 struct nand_oobfree {
@@ -123,7 +124,7 @@ struct nand_oobfree {
  */
 struct nand_ecclayout {
 	uint32_t eccbytes;
-	uint32_t eccpos[64];
+	uint32_t eccpos[96];
 	uint32_t oobavail;
 	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
 };
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 3e0044b..6848da6 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -46,6 +46,11 @@ extern void nand_release (struct mtd_info *mtd);
 /* Internal helper for board drivers which need to override command function */
 extern void nand_wait_ready(struct mtd_info *mtd);
 
+/* The maximum number of NAND chips in an array */
+#ifndef NAND_MAX_CHIPS
+#define NAND_MAX_CHIPS		8
+#endif
+
 /* This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
@@ -91,6 +96,9 @@ extern void nand_wait_ready(struct mtd_info *mtd);
 #define NAND_CMD_READSTART	0x30
 #define NAND_CMD_RNDOUTSTART	0xE0
 #define NAND_CMD_CACHEDPROG	0x15
+#define NAND_CMD_CACHEREAD		0x31
+#define NAND_CMD_EXIT_CACHEREAD	0x34
+
 
 /* Extended commands for AG-AND device */
 /*
@@ -173,7 +181,11 @@ typedef enum {
 #define NAND_NO_READRDY		0x00000100
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
+/* Allow clearing of bad block table entries */
+#define NAND_ALLOW_CLEAR_BBT	0x00000400   // NXP
 
+/* Chip supports page read cache mode */
+#define NAND_CACHEDREAD		0x00000800
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -184,6 +196,7 @@ typedef enum {
 #define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
 #define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
 #define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
+#define NAND_CANCACHEDREAD(chip)  ( (chip->options & NAND_CACHEDREAD ))
 /* Large page NAND with SOFT_ECC should support subpage reads */
 #define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
 					&& (chip->page_shift > 9))
@@ -423,6 +436,11 @@ struct nand_chip {
 	struct nand_bbt_descr	*badblock_pattern;
 
 	void		*priv;
+	// Added YW
+	int	badblockpos2;    // for the second bad block mark	
+	unsigned char mafid;
+	unsigned char devid;
+	unsigned char extid;
 };
 
 /*
@@ -472,6 +490,10 @@ struct nand_manufacturers {
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
 
+#ifndef NAND_MAX_CHIPS
+#define NAND_MAX_CHIPS 8
+#endif
+
 extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
 extern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
 extern int nand_default_bbt(struct mtd_info *mtd);
@@ -487,6 +509,10 @@ extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
 #define NAND_SMALL_BADBLOCK_POS		5
 #define NAND_LARGE_BADBLOCK_POS		0
 
+/* From nand_legacy.h */
+#define NAND_JFFS2_OOB_BADBPOS2		10
+#define NAND_NOOB_BADBPOS		-1
+
 /**
  * struct platform_nand_chip - chip level device structure
  * @nr_chips:		max. number of chips to scan for
diff --git a/include/linux/mtd/nand_legacy.h b/include/linux/mtd/nand_legacy.h
new file mode 100644
index 0000000..99eafbb
--- /dev/null
+++ b/include/linux/mtd/nand_legacy.h
@@ -0,0 +1,191 @@
+/*
+ *  linux/include/linux/mtd/nand.h
+ *
+ *  Copyright (c) 2000 David Woodhouse <dwmw2@mvhi.com>
+ *                     Steven J. Hill <sjhill@cotw.com>
+ *		       Thomas Gleixner <gleixner@autronix.de>
+ *
+ * $Id: nand.h,v 1.7 2003/07/24 23:30:46 a0384864 Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Info:
+ *   Contains standard defines and IDs for NAND flash devices
+ *
+ *  Changelog:
+ *   01-31-2000 DMW     Created
+ *   09-18-2000 SJH     Moved structure out of the Disk-On-Chip drivers
+ *			so it can be used by other NAND flash device
+ *			drivers. I also changed the copyright since none
+ *			of the original contents of this file are specific
+ *			to DoC devices. David can whack me with a baseball
+ *			bat later if I did something naughty.
+ *   10-11-2000 SJH     Added private NAND flash structure for driver
+ *   10-24-2000 SJH     Added prototype for 'nand_scan' function
+ *   10-29-2001 TG	changed nand_chip structure to support
+ *			hardwarespecific function for accessing control lines
+ *   02-21-2002 TG	added support for different read/write adress and
+ *			ready/busy line access function
+ *   02-26-2002 TG	added chip_delay to nand_chip structure to optimize
+ *			command delay times for different chips
+ *   04-28-2002 TG	OOB config defines moved from nand.c to avoid duplicate
+ *			defines in jffs2/wbuf.c
+ */
+#ifndef __LINUX_MTD_NAND_LEGACY_H
+#define __LINUX_MTD_NAND_LEGACY_H
+
+#ifndef CONFIG_NAND_LEGACY
+#error This module is for the legacy NAND support
+#endif
+
+/*
+ * Standard NAND flash commands
+ */
+#define NAND_CMD_READ0		0
+#define NAND_CMD_READ1		1
+#define NAND_CMD_PAGEPROG	0x10
+#define NAND_CMD_READOOB	0x50
+#define NAND_CMD_ERASE1		0x60
+#define NAND_CMD_STATUS		0x70
+#define NAND_CMD_SEQIN		0x80
+#define NAND_CMD_READID		0x90
+#define NAND_CMD_ERASE2		0xd0
+#define NAND_CMD_RESET		0xff
+
+/*
+ * NAND Private Flash Chip Data
+ *
+ * Structure overview:
+ *
+ *  IO_ADDR - address to access the 8 I/O lines of the flash device
+ *
+ *  hwcontrol - hardwarespecific function for accesing control-lines
+ *
+ *  dev_ready - hardwarespecific function for accesing device ready/busy line
+ *
+ *  chip_lock - spinlock used to protect access to this structure
+ *
+ *  wq - wait queue to sleep on if a NAND operation is in progress
+ *
+ *  state - give the current state of the NAND device
+ *
+ *  page_shift - number of address bits in a page (column address bits)
+ *
+ *  data_buf - data buffer passed to/from MTD user modules
+ *
+ *  data_cache - data cache for redundant page access and shadow for
+ *		 ECC failure
+ *
+ *  ecc_code_buf - used only for holding calculated or read ECCs for
+ *                 a page read or written when ECC is in use
+ *
+ *  reserved - padding to make structure fall on word boundary if
+ *             when ECC is in use
+ */
+struct Nand {
+	char floor, chip;
+	unsigned long curadr;
+	unsigned char curmode;
+	/* Also some erase/write/pipeline info when we get that far */
+};
+
+struct nand_chip {
+	int		page_shift;
+	u_char		*data_buf;
+	u_char		*data_cache;
+	int		cache_page;
+	u_char		ecc_code_buf[6];
+	u_char		reserved[2];
+	char ChipID; /* Type of DiskOnChip */
+	struct Nand *chips;
+	int chipshift;
+	char* chips_name;
+	unsigned long erasesize;
+	unsigned long mfr; /* Flash IDs - only one type of flash per device */
+	unsigned long id;
+	char* name;
+	int numchips;
+	char page256;
+	char pageadrlen;
+	unsigned long IO_ADDR;  /* address to access the 8 I/O lines to the flash device */
+	unsigned long totlen;
+	uint oobblock;  /* Size of OOB blocks (e.g. 512) */
+	uint oobsize;   /* Amount of OOB data per block (e.g. 16) */
+	uint eccsize;
+	int bus16;
+};
+
+/*
+ * NAND Flash Manufacturer ID Codes
+ */
+#define NAND_MFR_TOSHIBA	0x98
+#define NAND_MFR_SAMSUNG	0xec
+
+/*
+ * NAND Flash Device ID Structure
+ *
+ * Structure overview:
+ *
+ *  name - Complete name of device
+ *
+ *  manufacture_id - manufacturer ID code of device.
+ *
+ *  model_id - model ID code of device.
+ *
+ *  chipshift - total number of address bits for the device which
+ *              is used to calculate address offsets and the total
+ *              number of bytes the device is capable of.
+ *
+ *  page256 - denotes if flash device has 256 byte pages or not.
+ *
+ *  pageadrlen - number of bytes minus one needed to hold the
+ *               complete address into the flash array. Keep in
+ *               mind that when a read or write is done to a
+ *               specific address, the address is input serially
+ *               8 bits at a time. This structure member is used
+ *               by the read/write routines as a loop index for
+ *               shifting the address out 8 bits at a time.
+ *
+ *  erasesize - size of an erase block in the flash device.
+ */
+struct nand_flash_dev {
+	char * name;
+	int manufacture_id;
+	int model_id;
+	int chipshift;
+	char page256;
+	char pageadrlen;
+	unsigned long erasesize;
+	int bus16;
+};
+
+/*
+* Constants for oob configuration
+*/
+#define NAND_NOOB_ECCPOS0		0
+#define NAND_NOOB_ECCPOS1		1
+#define NAND_NOOB_ECCPOS2		2
+#define NAND_NOOB_ECCPOS3		3
+#define NAND_NOOB_ECCPOS4		6
+#define NAND_NOOB_ECCPOS5		7
+#define NAND_NOOB_BADBPOS		-1
+#define NAND_NOOB_ECCVPOS		-1
+
+#define NAND_JFFS2_OOB_ECCPOS0		0
+#define NAND_JFFS2_OOB_ECCPOS1		1
+#define NAND_JFFS2_OOB_ECCPOS2		2
+#define NAND_JFFS2_OOB_ECCPOS3		3
+#define NAND_JFFS2_OOB_ECCPOS4		6
+#define NAND_JFFS2_OOB_ECCPOS5		7
+#define NAND_JFFS2_OOB_BADBPOS		5
+#define NAND_JFFS2_OOB_ECCVPOS		4
+
+#define NAND_JFFS2_OOB8_FSDAPOS		6
+#define NAND_JFFS2_OOB16_FSDAPOS	8
+#define NAND_JFFS2_OOB8_FSDALEN		2
+#define NAND_JFFS2_OOB16_FSDALEN	8
+
+unsigned long nand_probe(unsigned long physadr);
+#endif /* __LINUX_MTD_NAND_LEGACY_H */
diff --git a/include/linux/mtd/onenand.h b/include/linux/mtd/onenand.h
index 2597e34..f6ddd57 100644
--- a/include/linux/mtd/onenand.h
+++ b/include/linux/mtd/onenand.h
@@ -30,10 +30,14 @@ extern void onenand_release (struct mtd_info *mtd);
 
 /**
  * struct onenand_bufferram - OneNAND BufferRAM Data
- * @param blockpage	block & page address in BufferRAM
+ * @param block		block address in BufferRAM
+ * @param page		page address in BufferRAM
+ * @param valid		valid flag
  */
 struct onenand_bufferram {
-	int blockpage;
+	int block;
+	int page;
+	int valid;
 };
 
 /**
@@ -66,8 +70,6 @@ struct onenand_chip {
 	void __iomem *base;
 	unsigned int chipsize;
 	unsigned int device_id;
-	unsigned int version_id;
-	unsigned int density_mask;
 	unsigned int options;
 
 	unsigned int erase_shift;
@@ -79,36 +81,26 @@ struct onenand_chip {
 	unsigned int bufferram_index;
 	struct onenand_bufferram bufferram[MAX_BUFFERRAM];
 
-	int (*command) (struct mtd_info *mtd, int cmd, loff_t address,
+	int (*command) (struct mtd_info * mtd, int cmd, loff_t address,
 			size_t len);
 	int (*wait) (struct mtd_info *mtd, int state);
-	int (*bbt_wait) (struct mtd_info *mtd, int state);
-	int (*read_bufferram) (struct mtd_info *mtd, loff_t addr, int area,
+	int (*read_bufferram) (struct mtd_info * mtd, int area,
 			       unsigned char *buffer, int offset, size_t count);
-	int (*read_spareram) (struct mtd_info *mtd, loff_t addr, int area,
-			       unsigned char *buffer, int offset, size_t count);
-	int (*write_bufferram) (struct mtd_info *mtd, loff_t addr, int area,
+	int (*write_bufferram) (struct mtd_info * mtd, int area,
 				const unsigned char *buffer, int offset,
 				size_t count);
-	unsigned short (*read_word) (void __iomem *addr);
-	void (*write_word) (unsigned short value, void __iomem *addr);
-	void (*mmcontrol) (struct mtd_info *mtd, int sync_read);
+	unsigned short (*read_word) (void __iomem * addr);
+	void (*write_word) (unsigned short value, void __iomem * addr);
+	void (*mmcontrol) (struct mtd_info * mtd, int sync_read);
 	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	int (*scan_bbt)(struct mtd_info *mtd);
 
-	unsigned char		*main_buf;
-	unsigned char		*spare_buf;
-#ifdef DONT_USE_UBOOT
-	spinlock_t chip_lock;
-	wait_queue_head_t wq;
-#endif
 	int state;
-	unsigned char		*page_buf;
-	unsigned char		*oob_buf;
+	unsigned char *page_buf;
+	unsigned char *oob_buf;
 
 	struct nand_oobinfo *autooob;
-	int			subpagesize;
-	struct nand_ecclayout	*ecclayout;
+	struct nand_ecclayout *ecclayout;
 
 	void *bbm;
 
@@ -133,9 +125,7 @@ struct onenand_chip {
 /*
  * Options bits
  */
-#define ONENAND_HAS_CONT_LOCK		(0x0001)
-#define ONENAND_HAS_UNLOCK_ALL		(0x0002)
-#define ONENAND_HAS_2PLANE		(0x0004)
+#define ONENAND_CONT_LOCK		(0x0001)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
 
@@ -143,6 +133,7 @@ struct onenand_chip {
  * OneNAND Flash Manufacturer ID Codes
  */
 #define ONENAND_MFR_SAMSUNG	0xec
+#define ONENAND_MFR_UNKNOWN	0x00
 
 /**
  * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
diff --git a/include/linux/mtd/onenand_regs.h b/include/linux/mtd/onenand_regs.h
index fc63380..a245e14 100644
--- a/include/linux/mtd/onenand_regs.h
+++ b/include/linux/mtd/onenand_regs.h
@@ -119,7 +119,6 @@
 #define ONENAND_CMD_UNLOCK		(0x23)
 #define ONENAND_CMD_LOCK		(0x2A)
 #define ONENAND_CMD_LOCK_TIGHT		(0x2C)
-#define ONENAND_CMD_UNLOCK_ALL		(0x27)
 #define ONENAND_CMD_ERASE		(0x94)
 #define ONENAND_CMD_RESET		(0xF0)
 #define ONENAND_CMD_READID		(0x90)
diff --git a/include/linux/nx_dmac_ip1902.h b/include/linux/nx_dmac_ip1902.h
new file mode 100755
index 0000000..0b4670f
--- /dev/null
+++ b/include/linux/nx_dmac_ip1902.h
@@ -0,0 +1,143 @@
+/*
+ * Device driver for NAND flash connected IP_2070 EFM.
+ *
+ * Copyright (C) 2008 NXP B.V.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Revision history
+ * Version      Date          Remarks
+ * 0.0.1	 		20090108		Draft-Initial version
+ */
+
+/* Fix me: To be taken from glb.h */
+#define   PNX8XXX_DMAC_BASE           (  0xe0634000 )
+#define		PNX8XXX_DMAC_LEN						(4096)
+#ifdef    CONFIG_PNX_EMU
+#define   PNX8XXX_TIMEOUT             (500000) // 1sec
+#else
+#define   PNX8XXX_TIMEOUT             (1000000) // 1sec
+#endif
+
+/* Fix me: To be taken from int.h */
+//#define		PNX8XXX_INT_DMAC						(96)
+
+#define 	NX_DMAC_INT_STATUS					(0x000)
+#define 	NX_DMAC_INT_TC_STATUS				(0x004)
+#define 	NX_DMAC_INT_TC_CLR					(0x008)
+#define 	NX_DMAC_INT_ERR_STATUS			(0x00C)
+#define 	NX_DMAC_INT_ERR_CLR					(0x010)
+#define 	NX_DMAC_INT_RAW_TC_STATUS		(0x014)
+#define 	NX_DMAC_INT_RAW_ERR_STATUS	(0x018)
+#define 	NX_DMAC_ENLD_CHANS					(0x01C)
+#define 	NX_DMAC_SOFT_BREQ						(0x020)
+#define 	NX_DMAC_SOFT_SREQ						(0x024)
+#define 	NX_DMAC_SOFT_LBREQ					(0x028)
+#define 	NX_DMAC_SOFT_LSREQ					(0x02C)
+#define 	NX_DMAC_CONFIG							(0x030)
+#define 	NX_DMAC_SYNC								(0x034)
+#define 	NX_DMAC_CHAN0_SRC						(0x100)
+#define 	NX_DMAC_CHAN0_DST						(0x104)
+#define 	NX_DMAC_CHAN0_LLI						(0x108)
+#define 	NX_DMAC_CHAN0_CTRL					(0x10C)
+#define 	NX_DMAC_CHAN0_CONFIG				(0x110)
+#define 	NX_DMAC_PERI_ID0						(0xFE0)
+#define 	NX_DMAC_PERI_ID1						(0xFE4)
+#define 	NX_DMAC_PERI_ID2						(0xFE8)
+#define 	NX_DMAC_PERI_ID3						(0xFEC)
+#define 	NX_DMAC_CELL_ID0						(0xFF0)
+#define 	NX_DMAC_CELL_ID1						(0xFF4)
+#define 	NX_DMAC_CELL_ID2						(0xFF8)
+#define 	NX_DMAC_CELL_ID3						(0xFFC)
+
+#define		NX_DMAC_CHAN_OFF						(0x020)
+
+/**
+* Flow control
+*/
+typedef enum tag_dmac_fl {
+  nx_dmac_mem2mem_dma=0x0,      /* mem2mem with DMA flow control */
+  nx_dmac_mem2per_dma=0x1,      /* mem2per with DMA flow control */
+  nx_dmac_per2mem_dma=0x2,      /* per2mem with DMA flow control */
+  nx_dmac_per2per_dma=0x3,      /* per2per with DMA flow control */
+  nx_dmac_per2per_dstper=0x4,   /* per2per with dst per flow control */
+  nx_dmac_mem2per_per=0x5,      /* mem2per with per flow control */
+  nx_dmac_per2mem_per=0x6,      /* per2mem with per flow control */
+  nx_dmac_per2per_srcper=0x7,   /* per2per with src per flow control */
+} nx_dmac_flctl_t;
+
+/**
+* DMAC burst size
+*/
+typedef enum tag_dmac_burst {
+  nx_dmac_1=0x0,          /*  1 word */
+  nx_dmac_4=0x1,          /*  4 words */
+  nx_dmac_8=0x2,          /*  8 words */
+  nx_dmac_16=0x3,         /*  16 words */
+  nx_dmac_32=0x4,         /*  32 words */
+  nx_dmac_64=0x5,         /*  64 words */
+  nx_dmac_128=0x6,        /*  128 words */
+  nx_dmac_256=0x7,        /*  256 words */
+} nx_dmac_burst_t;
+
+/**
+* DMAC width
+*/
+typedef enum tag_dmac_width {
+  nx_dmac_width_8=0x0,          /*  8 bits */
+  nx_dmac_width_16=0x1,         /*  16 bits */
+  nx_dmac_width_32=0x2,         /*  32 bits */
+} nx_dmac_width_t;
+
+/**
+* DMAC scatter gather request structure
+*/
+typedef struct tag_dmac_stgt {
+  uint32_t            src_addr;         /* Source physical address */
+  uint32_t            dst_addr;         /* Destination physical address */
+  uint32_t            tfr_size;         /* Transfer size in words */
+  nx_dmac_flctl_t     flowctl;          /* Flow control */
+  uint32_t            src_per;          /* Source peripheral number */
+  uint32_t            dst_per;          /* Destination perpheral number */
+  uint32_t            src_ahb;          /* Source AHB master */
+  uint32_t            dst_ahb;          /* Destination AHB master */
+  int                 src_inc;          /* Source Increment flag */
+  int                 dst_inc;          /* Destination Increment flag */
+  nx_dmac_burst_t     src_brst;         /* Source burst size */
+  nx_dmac_burst_t     dst_brst;         /* Destination burst size */
+  nx_dmac_width_t   	src_width;  			/* Source width */
+  nx_dmac_width_t   	dst_width;  			/* Destination width */
+} nx_dmac_stgt_t;
+
+/**
+* DMAC Transfer request structure
+*/
+typedef struct tag_dmac_tfr {
+  int                 num_reqs;         /* # of requests in scatter gather */
+  nx_dmac_stgt_t      *req;             /* Scatter gather structure */
+} nx_dmac_tfr_t;
+
+/**
+* DMAC Transfer function
+*/
+extern int nx_dmac_tfr(nx_dmac_tfr_t *req);
+
+/**
+* DMAC Transfer complete function
+*/
+extern int nx_dmac_tfr_comp(int chanid);
+
+
diff --git a/include/nxp_pcixio_ipa051.h b/include/nxp_pcixio_ipa051.h
new file mode 100644
index 0000000..6bad23f
--- /dev/null
+++ b/include/nxp_pcixio_ipa051.h
@@ -0,0 +1,329 @@
+/*
+ * (C) Copyright 2006
+ * NXP Semiconductors,
+ * Robert Delien robert.delien@nxp.com, Hans Zuidam hans.zuidam@nxp.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef NXP_PCIXIO_IPA051_H
+#define NXP_PCIXIO_IPA051_H
+
+/*
+ * Timeout and retry time for IO and CFG accesses
+ * in microseconds
+ */
+#define PCI_IO_TIMEOUT_US			10
+#define PCI_IO_RETRYTIME_US			1
+
+#define PCI_BYTE_ENABLE_MASK			0x0000000F
+#define PCI_CFG_BUS_SHIFT			16
+#define PCI_CFG_FUNC_SHIFT			8
+
+/*
+ * Register address definitions
+ */
+#define IPA051_PCI_SETUP			0x00000010
+#define IPA051_PCI_CONTROL			0x00000014
+#define IPA051_PCI_BASE1_LO			0x00000018
+#define IPA051_PCI_BASE1_HI			0x0000001C
+#define IPA051_PCI_BASE2_LO			0x00000020
+#define IPA051_PCI_BASE2_HI			0x00000024
+#define IPA051_READ_LIFETIME			0x00000028
+#define IPA051_GPPM_ADDR			0x0000002C
+#define IPA051_GPPM_WDAT			0x00000030
+#define IPA051_GPPM_RDAT			0x00000034
+#define IPA051_GPPM_CTRL			0x00000038
+#define IPA051_UNLOCK_REGISTER			0x0000003C
+#define IPA051_DEVICE_VENDORID			0x00000040
+#define IPA051_CONFIG_CMD_STAT			0x00000044
+#define IPA051_CLASS_CODE_REV_ID		0x00000048
+#define IPA051_LATENCY_TIMER			0x0000004C
+#define IPA051_BASE10				0x00000050
+#define IPA051_BASE14				0x00000054
+#define IPA051_BASE18				0x00000058
+/*	IPA051_RESERVED				0x0000005C ... 0x00000060 */
+#define IPA051_SUBSYSTEM_IDS			0x0000006C
+/*      IPA051_RESERVED				0x00000070 */
+#define IPA051_CAP_POINTER			0x00000074
+/*      IPA051_RESERVED				0x00000078 */
+#define IPA051_CONFIG_MISC			0x0000007C
+#define IPA051_PMC				0x00000080
+#define IPA051_PWR_STATE			0x00000084
+#define IPA051_PCI_IO				0x00000088
+#define IPA051_SLV_TUNING			0x0000008C
+#define IPA051_DMA_TUNING			0x00000090
+/*	IPA051_RESERVED				0x00000094 ... 0x000007FC */
+#define IPA051_DMA_EADDR			0x00000800
+#define IPA051_DMA_IADDR			0x00000804
+#define IPA051_DMA_LENGTH			0x00000808
+#define IPA051_DMA_CTRL				0x0000080C
+#define IPA051_XIO_CTRL				0x00000810
+#define IPA051_XIO_SEL0_PROF			0x00000814
+#define IPA051_XIO_SEL1_PROF			0x00000818
+#define IPA051_XIO_SEL2_PROF			0x0000081C
+#define IPA051_GPXIO_ADDR			0x00000820
+#define IPA051_GPXIO_WDATA			0x00000824
+#define IPA051_GPXIO_RDATA			0x00000828
+#define IPA051_GPXIO_CTRL			0x0000082C
+#define IPA051_NAND_CTRLS			0x00000830
+#define IPA051_XIO_SEL3_PROF			0x00000834
+#define IPA051_XIO_SEL4_PROF			0x00000838
+/*	IPA051_RESERVED				0x0000083C ... 0x00000FAC */
+#define IPA051_GPXIO_INT_STATUS			0x00000FB0
+#define IPA051_GPXIO_INT_MASK			0x00000FB4
+#define IPA051_GPXIO_INT_CLR			0x00000FB8
+#define IPA051_GPXIO_INT_SET			0x00000FBC
+#define IPA051_GPPM_INT_STATUS			0x00000FC0
+#define IPA051_GPPM_INT_MASK			0x00000FC4
+#define IPA051_GPPM_INT_CLR			0x00000FC8
+#define IPA051_GPPM_INT_SET			0x00000FCC
+#define IPA051_DMA_INT_STATUS			0x00000FD0
+#define IPA051_DMA_INT_MASK			0x00000FD4
+#define IPA051_DMA_INT_CLR			0x00000FD8
+#define IPA051_DMA_INT_SET			0x00000FDC
+#define IPA051_PCI_INT_STATUS			0x00000FE0
+#define IPA051_PCI_INT_MASK			0x00000FE4
+#define IPA051_PCI_INT_CLR			0x00000FE8
+#define IPA051_PCI_INT_SET			0x00000FEC
+/*	IPA051_RESERVED				0x00000FF0 ... 0x00000FF8 */
+#define IPA051_MODULE_ID			0x00000FFC
+
+
+/*
+ * Register layout definitions
+ */
+
+/* IPA051_PCI_SETUP register fields */
+#define IPA051_PCI_SETUP__DIS_REQGNT		(1<<30)
+#define IPA051_PCI_SETUP__DIS_REQGNT_A		(1<<29)
+#define IPA051_PCI_SETUP__DIS_REQGNT_B		(1<<28)
+#define IPA051_PCI_SETUP__D2_SUPPORT		(1<<27)
+#define IPA051_PCI_SETUP__D1_SUPPORT		(1<<26)
+#define IPA051_PCI_SETUP__EN_TA			(1<<24)
+#define IPA051_PCI_SETUP__EN_PCI2MMI		(1<<23)
+#define IPA051_PCI_SETUP__EN_XIO		(1<<22)
+#define IPA051_PCI_SETUP__BASE18_PREFETCHABLE	(1<<21)
+#define IPA051_PCI_SETUP__BASE18_SIZ(n)		(n<<18)
+#define IPA051_PCI_SETUP__EN_BASE18		(1<<17)
+#define IPA051_PCI_SETUP__BASE14_PREFETCHABLE	(1<<16)
+#define IPA051_PCI_SETUP__BASE14_SIZ(n)		(n<<12)
+#define IPA051_PCI_SETUP__EN_BASE14		(1<<11)
+#define IPA051_PCI_SETUP__BASE10_PREFETCHABLE	(1<<10)
+#define IPA051_PCI_SETUP__BASE10_SIZ(n)		((n)<<7)
+#define IPA051_PCI_SETUP__EN_CONFIG_MANAG	(1<<1)
+#define IPA051_PCI_SETUP__EN_PCI_ARB		(1<<0)
+#define IPA051_PCI_SETUP__BASExx_SIZ_16M	0x00000003
+#define IPA051_PCI_SETUP__BASExx_SIZ_32M	0x00000004
+#define IPA051_PCI_SETUP__BASExx_SIZ_64M	0x00000005
+#define IPA051_PCI_SETUP__BASExx_SIZ_128M	0x00000006
+#define IPA051_PCI_SETUP__BASExx_SIZ_256M	0x00000007
+
+/* IPA051_PCI_CONTROL register fields */
+
+#define IPA051_PCI_CONTROL__DECOUPLE_TARG	(1 << 19)
+#define IPA051_PCI_CONTROL__FST_RETRY		(1 << 18)
+#define IPA051_PCI_CONTROL__PARKING		(1 << 17)
+#define IPA051_PCI_CONTROL__DIS_SWAPPER2TARG	(1 << 16)
+#define IPA051_PCI_CONTROL__DIS_SWAPPER2INTREG	(1 << 15)
+#define IPA051_PCI_CONTROL__DIS_SWAPPER2DTLINIT	(1 << 14)
+#define IPA051_PCI_CONTROL__REGS_WR_POSTEN	(1 << 13)
+#define IPA051_PCI_CONTROL__XIO_WR_POSTEN	(1 << 12)
+#define IPA051_PCI_CONTROL__PCI2_WR_POSTEN	(1 << 11)
+#define IPA051_PCI_CONTROL__PCI1_WR_POSTEN	(1 << 10)
+#define IPA051_PCI_CONTROL__EN_SERR_SEEN	(1 << 9)
+#define IPA051_PCI_CONTROL__EN_BASE10_SPEC_RD	(1 << 6)
+#define IPA051_PCI_CONTROL__EN_BASE14_SPEC_RD	(1 << 5)
+#define IPA051_PCI_CONTROL__EN_BASE18_SPEC_RD	(1 << 4)
+#define IPA051_PCI_CONTROL__DISABLE_SUBWORD2_10	(1 << 3)
+#define IPA051_PCI_CONTROL__DISABLE_SUBWORD2_14	(1 << 2)
+#define IPA051_PCI_CONTROL__DISABLE_SUBWORD2_18	(1 << 1)
+#define IPA051_PCI_CONTROL__EN_RETRY_TIMER	(1 << 0)
+
+/* IPA051_UNLOCK_REGISTER register fields */
+#define IPA051_UNLOCK_REGISTER__UNLOCK_SSID	(0xCA << 8)
+#define IPA051_UNLOCK_REGISTER__UNLOCK_SETUP	(0xCA << 0)
+
+/* IPA051_BASE10 register fields */
+#define IPA051_BASE10__BASE_ADDRESS_10(n)	((n) & (0x7FF << 21))
+#define IPA051_BASE10__PREFETCHABLE		(1 << 3)
+#define IPA051_BASE10__TYPE(n)			((n) & (7 << 0))
+
+/* IPA051_PCI_IO register fields */
+#define IPA051_PCI_IO__UPPER_IO3_ADDR(n)	(((n)&0xFF) << 24)
+#define IPA051_PCI_IO__UPPER_IO2_ADDR(n)	(((n)&0xFF) << 16)
+#define IPA051_PCI_IO__USE_IO3_ADDR		(1 << 2)
+#define IPA051_PCI_IO__USE_IO2_ADDR		(1 << 1)
+#define IPA051_PCI_IO__USE_PCIBASE2_AS_IO	(1 << 0)
+
+/* IPA051_SLV_TUNING register fields */
+#define IPA051_SLV_TUNING__SLV_MEMRD_FETCH(n)	(((n)&0x1F) << 16)
+#define IPA051_SLV_TUNING__SLV_THRESHOLD(n)	(((n)&0xF) << 8)
+#define IPA051_SLV_TUNING__SLV_MRMUL_FETCH(n)	(((n)&0x7) << 0)
+
+/* IPA051_BASE10, IPA051_BASE14 and IPA051_BASE18 register fields */
+#define IPA051_BASExx__ADDRESS			(0xFFFFFFF << 4)
+#define IPA051_BASExx__PREFETCHABLE		(1 << 3)
+#define IPA051_BASExx__TYPE			(3 << 0)
+
+/* IPA051_GPXIO_CTRL register fields */
+#define IPA051_GPXIO_CTRL__GPXIO_CYC_PENDING	(1 << 9)
+#define IPA051_GPXIO_CTRL__GPXIO_DONE		(1 << 8)
+#define IPA051_GPXIO_CTRL__CLR_GPXIO_DONE	(1 << 7)
+#define IPA051_GPXIO_CTRL__GPXIO_INIT		(1 << 6)
+#define IPA051_GPXIO_CTRL__GPXIO_RD		(1 << 4)
+#define IPA051_GPXIO_CTRL__GPXIO_BEN(n)		((n) & 0x0000000F)
+
+/* IPA051_NAND_CTRLS register fields */
+#define IPA051_NAND_CTRLS__CTRLS_2ND_CMD	(1 << 27)
+#define IPA051_NAND_CTRLS__CTRLS_ROW_ADDR	(1 << 26)
+#define IPA051_NAND_CTRLS__CTRLS_COL_ADDR	(1 << 25)
+#define IPA051_NAND_CTRLS__CTRLS_LB		(1 << 24)
+#define IPA051_NAND_CTRLS__CTRLS_128MB		(1 << 22)
+#define IPA051_NAND_CTRLS__CTRLS_64MB		(1 << 21)
+#define IPA051_NAND_CTRLS__CTRLS_INC_DATA	(1 << 20)
+#define IPA051_NAND_CTRLS__CTRLS_CMD_PH(n)	(((n) & 0x00000003) << 18)
+#define IPA051_NAND_CTRLS__CTRLS_ADR_PH(n)	(((n) & 0x00000003) << 16)
+#define IPA051_NAND_CTRLS__COMMAND_B(n)		(((n) << 8) & 0x0000FF00)
+#define IPA051_NAND_CTRLS__COMMAND_A(n)		((n) & 0x000000FF)
+
+/* IPA051_DMA_CTRL register fields */
+#define IPA051_DMA_CTRL__SINGLE_DATA_PHASE	(1 << 10)
+#define IPA051_DMA_CTRL__SND2XIO		(1 << 9)
+#define IPA051_DMA_CTRL__FIX_ADDR		(1 << 8)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE(n)	(((n) & 0x00000007) << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_8	(0 << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_16	(1 << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_32	(2 << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_64	(3 << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_128	(4 << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_256	(5 << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_512	(6 << 5)
+#define IPA051_DMA_CTRL__MAX_BURST_SIZE_NORES	(7 << 5)
+#define IPA051_DMA_CTRL__INIT_DMA		(1 << 4)
+#define IPA051_DMA_CTRL__CMD_TYPE(n)		((n) & 0x0000000F)
+#define IPA051_DMA_CTRL__CMD_READ		0x00000006
+#define IPA051_DMA_CTRL__CMD_WRITE		0x00000007
+
+/* IPA051_XIO_SEL0_PROF, IPA051_XIO_SEL1_PROF, IPA051_XIO_SEL2_PROF,
+ * IPA051_XIO_SEL3_PROF, IPA051_XIO_SEL4_PROF register fields */
+#define IPA051_XIO_SELx_PROF__OFFSET_EXT	(1 << 27)
+#define IPA051_XIO_SELx_PROF__SIZ_EXT		(1 << 25)
+#define IPA051_XIO_SELx_PROF__MISC_CTRL		(1 << 24)
+#define IPA051_XIO_SELx_PROF__EN_16BIT		(1 << 23)
+#define IPA051_XIO_SELx_PROF__USE_ACK		(1 << 22)
+#define IPA051_XIO_SELx_PROF__WE_HI		(0xF << 18)
+#define IPA051_XIO_SELx_PROF__WE_LO		(0xF << 14)
+#define IPA051_XIO_SELx_PROF__WAIT		(0x1F << 9)
+#define IPA051_XIO_SELx_PROF__OFFSET		(0xF << 5)
+#define IPA051_XIO_SELx_PROF__TYPE_68360	(0x0 << 3)
+#define IPA051_XIO_SELx_PROF__TYPE_NOR		(0x1 << 3)
+#define IPA051_XIO_SELx_PROF__TYPE_NAND		(0x2 << 3)
+#define IPA051_XIO_SELx_PROF__TYPE_IDE		(0x3 << 3)
+#define IPA051_XIO_SELx_PROF__TYPE		(0x3 << 3)
+#define IPA051_XIO_SELx_PROF__SIZE_8MB		(0x0 << 1)
+#define IPA051_XIO_SELx_PROF__SIZE_16MB		(0x1 << 1)
+#define IPA051_XIO_SELx_PROF__SIZE_32MB		(0x2 << 1)
+#define IPA051_XIO_SELx_PROF__SIZE_64MB		(0x3 << 1)
+#define IPA051_XIO_SELx_PROF__SIZE		(0x3 << 1)
+#define IPA051_XIO_SELx_PROF__ENAB		(1 << 0)
+
+/* IPA051_GPPM_CTRL register fields */
+#define IPA051_GPPM_CTRL__GPPM_DONE		(1<<10)
+#define IPA051_GPPM_CTRL__INIT_PCI_CYCLE	(1<<9)
+#define IPA051_GPPM_CTRL__GPPM_CMD_IO_RD	0x00000020
+#define IPA051_GPPM_CTRL__GPPM_CMD_IO_WR	0x00000030
+#define IPA051_GPPM_CTRL__GPPM_CMD_MEM_RD	0x00000060 /*?*/
+#define IPA051_GPPM_CTRL__GPPM_CMD_MEM_WR	0x00000070 /*?*/
+#define IPA051_GPPM_CTRL__GPPM_CMD_CFG_RD	0x000000A0
+#define IPA051_GPPM_CTRL__GPPM_CMD_CFG_WR	0x000000B0
+#define IPA051_GPPM_CTRL__GPPM_CMD(X)		(((X)&0x0000000F)<<4)
+#define IPA051_GPPM_CTRL__GPPM_BEN(X)		((X)&0x0000000F)
+
+/* IPA051_GPXIO_INT register fields */
+#define IPA051_GPXIO_INT__GPXIO_XIO_ACK_DONE	(1 << 14)
+#define IPA051_GPXIO_INT__GPXIO_DONE		(1 << 13)
+#define IPA051_GPXIO_INT__GPXIO_ERR		(1 << 9)
+#define IPA051_GPXIO_INT__GPXIO_R_MABORT	(1 << 2)
+
+/* IPA051_GPPM_INT register fields */
+#define IPA051_GPPM_INT__GPPM_DONE		(1<<10)
+#define IPA051_GPPM_INT__GPPM_ERR		(1<<9)
+#define IPA051_GPPM_INT__GPPM_MSTR_PARITY_ERR	(1<<5)
+#define IPA051_GPPM_INT__GPPM_ERR_PARITY	(1<<4)
+#define IPA051_GPPM_INT__GPPM_R_MABORT		(1<<2)
+#define IPA051_GPPM_INT__GPPM_R_TABORT		(1<<1)
+
+/* IPA051_DMA_INT register fields */
+#define IPA051_DMA_INT__DMA_XIO_ACK_DONE	(1<<14)
+#define IPA051_DMA_INT__DMA_DONE		(1<<12)
+#define IPA051_DMA_INT__DMA_ERR			(1<<9)
+#define IPA051_DMA_INT__DMA_MSTR_PARITY_ERR	(1<<5)
+#define IPA051_DMA_INT__DMA_ERR_PARITY		(1<<4)
+#define IPA051_DMA_INT__DMA_R_MABORT		(1<<2)
+#define IPA051_DMA_INT__DMA_R_TABORT		(1<<1)
+
+struct pci_controller;
+
+struct nand_chip;
+
+struct mtd_info;
+
+void	init_nxp_ipa051_pci(	struct pci_controller	*hose		) ;
+
+
+/* Exported NAND flash functions */
+void	nand_reset(		struct nand_chip	*nand		) ;
+
+int	nand_read_id(		struct nand_chip	*nand,
+				unsigned long		*id		) ;
+
+int	nand_read_status(	struct mtd_info	*mtd,
+				unsigned long		*status		) ;
+
+int	nand_erase_block(	struct mtd_info	*mtd,
+				size_t			offset		) ;
+
+int nand_dma_read( struct mtd_info *mtd,
+			   off_t		row,
+			   off_t		column,
+			   size_t		length,
+			   void 		*dest,
+			   int			cached);
+
+int	nand_dma_write(		struct mtd_info	*mtd,
+				off_t			row,
+				off_t			column,
+				size_t			length,
+				void			*source		) ;
+
+int	nand_gpxio_read(	struct mtd_info	*nand,
+				off_t			row,
+				off_t			column,
+				uint32_t		*dest		) ;
+
+int	nand_gpxio_write(	struct nand_chip	*nand,
+				off_t			row,
+				off_t			column,
+				uint32_t		*source		) ;
+void nand_stop_cache_read(struct mtd_info* mtd);
+
+
+#endif /* NXP_PCIXIO_IPA051_H */
diff --git a/include/nxp_pnx8400_rgu.h b/include/nxp_pnx8400_rgu.h
new file mode 100644
index 0000000..fd2e40a
--- /dev/null
+++ b/include/nxp_pnx8400_rgu.h
@@ -0,0 +1,51 @@
+/*
+ * (C) Copyright 2009
+ * NXP Semiconductors,
+ * Tjeu Horsch tjeu.horsch@nxp.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef NXP_PNX8400_RGU_H
+#define NXP_PNX8400_RGU_H
+
+
+/*
+ * Register address definitions
+ */
+#define NXP_PNX8400_RGU_STATUS		0x00000000
+#define NXP_PNX8400_RGU_STANDBY		0x00000004
+#define NXP_PNX8400_RGU_SOFTRST		0x00000008
+#define NXP_PNX8400_RGU_GRESET0		0x0000000C
+#define NXP_PNX8400_RGU_GRESET1		0x00000010
+#define NXP_PNX8400_RGU_GRESET2		0x00000014
+#define NXP_PNX8400_RGU_BUTTON		0x0000001C
+#define NXP_PNX8400_RGU_SMARTCARD	0x00000020
+#define NXP_PNX8400_RGU_A9SELF		0x00000024
+#define NXP_PNX8400_RGU_LOCKCMD		0x00000028
+#define NXP_PNX8400_RGU_LOCKSTAT	0x0000002C
+#define NXP_PNX8400_RGU_CONFIG		0x00000030
+
+/*
+ * Register layout definitions
+ */
+
+
+#endif /* NXP_PNX8400_RGU_H */
diff --git a/lib_arm/board.c b/lib_arm/board.c
index a44d308..56ba9a7 100644
--- a/lib_arm/board.c
+++ b/lib_arm/board.c
@@ -39,6 +39,7 @@
  */
 
 #include <common.h>
+#include <config.h>
 #include <command.h>
 #include <malloc.h>
 #include <stdio_dev.h>
@@ -100,8 +101,11 @@ void mem_malloc_init (ulong dest_addr)
 	mem_malloc_end = dest_addr + CONFIG_SYS_MALLOC_LEN;
 	mem_malloc_brk = mem_malloc_start;
 
-	memset ((void *) mem_malloc_start, 0,
-			mem_malloc_end - mem_malloc_start);
+	printf("malloc: Using memory from 0x%08lx to 0x%08lx\n",
+	       mem_malloc_start, mem_malloc_end);
+
+/*	memset ((void *) mem_malloc_start, 0,
+			mem_malloc_end - mem_malloc_start);  */
 }
 
 void *sbrk (ptrdiff_t increment)
@@ -305,7 +309,11 @@ void start_armboot (void)
 #endif
 
 	/* Pointer is writable since we allocated a register for it */
+#ifdef CONFIG_MEMORY_UPPER_CODE
+	gd = (gd_t*)(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_UBOOT_SIZE - CONFIG_SYS_MALLOC_LEN - sizeof(gd_t));
+#else
 	gd = (gd_t*)(_armboot_start - CONFIG_SYS_MALLOC_LEN - sizeof(gd_t));
+#endif
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("": : :"memory");
 
@@ -324,7 +332,12 @@ void start_armboot (void)
 	}
 
 	/* armboot_start is defined in the board-specific linker script */
+#ifdef CONFIG_MEMORY_UPPER_CODE
+	mem_malloc_init (CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_UBOOT_SIZE - CONFIG_SYS_MALLOC_LEN);
+#else
 	mem_malloc_init (_armboot_start - CONFIG_SYS_MALLOC_LEN);
+#endif
+	puts ("==> Heap allocated.\n  ");
 
 #ifndef CONFIG_SYS_NO_FLASH
 	/* configure available FLASH banks */
@@ -377,6 +390,8 @@ void start_armboot (void)
 	/* initialize environment */
 	env_relocate ();
 
+	puts ("==> Env setup done.\n  ");
+
 #ifdef CONFIG_VFD
 	/* must do this after the framebuffer is allocated */
 	drv_vfd_init();
@@ -389,10 +404,14 @@ void start_armboot (void)
 	/* IP Address */
 	gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
 
+	puts ("==> U-Boot phase 2.\n  ");
+
 	stdio_init ();	/* get the devices list going. */
 
 	jumptable_init ();
 
+	puts ("==> U-Boot phase 3.\n  ");
+
 #if defined(CONFIG_API)
 	/* Initialize API */
 	api_init ();
@@ -412,6 +431,8 @@ void start_armboot (void)
 	/* enable exceptions */
 	enable_interrupts ();
 
+	puts ("==> U-Boot interrupts enabled.\n  ");
+
 	/* Perform network card initialisation if necessary */
 #ifdef CONFIG_DRIVER_TI_EMAC
 	/* XXX: this needs to be moved to board init */
