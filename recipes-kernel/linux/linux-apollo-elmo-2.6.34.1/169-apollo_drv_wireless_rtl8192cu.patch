diff -Nruap linux-2.6.34.orig/drivers/net/wireless/Kconfig linux-2.6.34.patched/drivers/net/wireless/Kconfig
--- linux-2.6.34.orig/drivers/net/wireless/Kconfig	2010-05-17 05:17:36.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/Kconfig	2011-04-26 12:32:35.000000000 +0800
@@ -343,7 +343,7 @@ config MWL8K
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called mwl8k.  If unsure, say N.
-
+source "drivers/net/wireless/rtl8192cu/Kconfig"
 source "drivers/net/wireless/ath/Kconfig"
 source "drivers/net/wireless/b43/Kconfig"
 source "drivers/net/wireless/b43legacy/Kconfig"
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/Makefile linux-2.6.34.patched/drivers/net/wireless/Makefile
--- linux-2.6.34.orig/drivers/net/wireless/Makefile	2010-05-17 05:17:36.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/Makefile	2011-04-26 12:31:46.000000000 +0800
@@ -1,7 +1,7 @@
 #
 # Makefile for the Linux Wireless network device drivers.
 #
-
+obj-$(CONFIG_RTL8192CU)  += rtl8192cu/ 
 obj-$(CONFIG_IPW2100) += ipw2x00/
 obj-$(CONFIG_IPW2200) += ipw2x00/
 
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/autoconf_rtl8192c_usb_linux.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/autoconf_rtl8192c_usb_linux.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/autoconf_rtl8192c_usb_linux.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/autoconf_rtl8192c_usb_linux.h	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,157 @@
+/*
+ * Automatically generated C config: don't edit
+ */
+
+#define AUTOCONF_INCLUDED
+#define RTL871X_MODULE_NAME "92CU"
+
+//#define CONFIG_DEBUG_RTL871X 1
+
+#define CONFIG_USB_HCI	1
+#undef  CONFIG_SDIO_HCI
+#undef CONFIG_PCIE_HCI
+
+#undef CONFIG_RTL8711
+#undef  CONFIG_RTL8712
+#define	CONFIG_RTL8192C 1
+#define	CONFIG_RTL8192D 1
+
+
+//#define CONFIG_LITTLE_ENDIAN 1 //move to Makefile depends on platforms
+//#undef CONFIG_BIG_ENDIAN
+
+#undef PLATFORM_WINDOWS
+#undef PLATFORM_OS_XP 
+#undef PLATFORM_OS_CE
+
+
+#define PLATFORM_LINUX 1
+
+//#define CONFIG_PWRCTRL	1
+//#define CONFIG_H2CLBK 1
+
+//#define CONFIG_MP_INCLUDED 1
+
+//#undef CONFIG_EMBEDDED_FWIMG
+#define CONFIG_EMBEDDED_FWIMG 1
+
+#define CONFIG_R871X_TEST 1
+
+#define CONFIG_80211N_HT 1
+
+#define CONFIG_RECV_REORDERING_CTRL 1
+
+//#define CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX 1
+
+//#define CONFIG_DRVEXT_MODULE 1
+
+
+#define CONFIG_IPS	1
+#define CONFIG_LPS	1
+#define CONFIG_BT_COEXIST  	1
+#define CONFIG_ANTENNA_DIVERSITY	1
+//#define CONFIG_WOWLAN 1
+
+#define SUPPORT_HW_RFOFF_DETECTED	1
+
+#ifdef PLATFORM_LINUX
+//	#define CONFIG_PROC_DEBUG 1
+#endif
+
+#ifdef CONFIG_RTL8192C
+
+	#define DBG 0
+
+	#define CONFIG_DEBUG_RTL8192C				1
+
+	#define DEV_BUS_PCI_INTERFACE				1
+	#define DEV_BUS_USB_INTERFACE				2	
+
+	#define RTL8192C_WEP_ISSUE					0
+	
+	#define RTL8192C_RX_PACKET_NO_INCLUDE_CRC	1
+
+	#define SUPPORTED_BLOCK_IO
+	
+	#ifdef CONFIG_USB_HCI
+
+		#define DEV_BUS_TYPE	DEV_BUS_USB_INTERFACE
+
+		#define USB_TX_AGGREGATION_92C	1
+		#define USB_RX_AGGREGATION_92C	1		
+		#define CONFIG_PS_CMD				1
+
+		#ifdef CONFIG_WISTRON_PLATFORM	
+			#define SILENT_RESET_FOR_SPECIFIC_PLATFOM	1				
+		#endif
+		
+		#define RTL8192CU_FW_DOWNLOAD_ENABLE	1
+
+		#define CONFIG_ONLY_ONE_OUT_EP_TO_LOW	0
+	
+		#define CONFIG_OUT_EP_WIFI_MODE	0
+
+		#define ENABLE_USB_DROP_INCORRECT_OUT	0
+
+		#define RTL8192CU_ASIC_VERIFICATION	0	// For ASIC verification.
+
+		#define RTL8192CU_ADHOC_WORKAROUND_SETTING 1
+
+		#ifdef PLATFORM_LINUX
+			#define CONFIG_SKB_COPY 			1//for amsdu
+			#define CONFIG_PREALLOC_RECV_SKB	1			
+			#define CONFIG_REDUCE_USB_TX_INT	1
+			#define CONFIG_EASY_REPLACEMENT	1
+			#ifdef CONFIG_WISTRON_PLATFORM
+			#define DYNAMIC_ALLOCIATE_VENDOR_CMD	0
+			#else
+			#define DYNAMIC_ALLOCIATE_VENDOR_CMD	1
+			#endif
+		#endif		
+
+		#ifdef CONFIG_R871X_TEST
+
+			//#define CONFIG_AP_MODE 1
+			//#define CONFIG_NATIVEAP_MLME 1
+
+			#ifdef CONFIG_AP_MODE
+
+				#ifndef CONFIG_NATIVEAP_MLME
+					#define CONFIG_HOSTAPD_MLME 1
+				#endif
+			
+			#endif
+		
+		#endif
+    
+	
+	#endif
+
+	#ifdef CONFIG_PCIE_HCI
+
+		#define DEV_BUS_TYPE	DEV_BUS_PCI_INTERFACE
+		
+	#endif
+
+	
+	#define DISABLE_BB_RF	0	
+
+	#define RTL8191C_FPGA_NETWORKTYPE_ADHOC 0
+
+	//#define FW_PROCESS_VENDOR_CMD 1
+
+	#ifdef CONFIG_MP_INCLUDED
+		#define MP_DRIVER 1
+	#else
+		#define MP_DRIVER 0
+	#endif
+
+#endif
+
+
+//#define CONFIG_NON_SKB_TRANSFER_BUFFER 1
+
+#ifdef CONFIG_NON_SKB_TRANSFER_BUFFER
+#undef CONFIG_PREALLOC_RECV_SKB
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/clean linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/clean
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/clean	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/clean	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,7 @@
+#!/bin/bash
+rmmod r8192s_usb
+rmmod ieee80211_rsl
+rmmod ieee80211_crypt_ccmp
+rmmod ieee80211_crypt_tkip
+rmmod ieee80211_crypt_wep
+rmmod ieee80211_crypt
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/efuse/rtl8712_efuse.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/efuse/rtl8712_efuse.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/efuse/rtl8712_efuse.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/efuse/rtl8712_efuse.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,723 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8712_EFUSE_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <rtl8712_efuse.h>
+//------------------------------------------------------------------------------
+static void efuse_reg_ctrl(_adapter *padapter, u8 bPowerOn)
+{
+	u16 	tmpV16 	= 0;			
+	
+	if(_TRUE ==bPowerOn){
+
+		// 1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid
+		tmpV16 = rtw_read16(padapter,REG_SYS_ISO_CTRL);
+		if( ! (tmpV16 & PWC_EV12V ) ){
+			tmpV16 |= PWC_EV12V ;
+			 rtw_write16(padapter,REG_SYS_ISO_CTRL,tmpV16);
+		}
+		// Reset: 0x0000h[28], default valid
+		tmpV16 = rtw_read16(padapter,REG_SYS_FUNC_EN);
+		if( !(tmpV16 & FEN_ELDR) ){
+			tmpV16 |= FEN_ELDR ;
+			rtw_write16(padapter,REG_SYS_FUNC_EN,tmpV16);
+		}
+		
+		// Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid
+		tmpV16 = rtw_read16(padapter,REG_SYS_CLKR);
+		if( (!(tmpV16 & LOADER_CLK_EN) )  ||(!(tmpV16 & ANA8M) ) ){
+			tmpV16 |= (LOADER_CLK_EN |ANA8M ) ;
+			rtw_write16(padapter,REG_SYS_CLKR,tmpV16);
+		}		
+	}
+}
+
+/*
+ * Before write E-Fuse, this function must be called.
+ */
+u8 rtw_efuse_reg_init(_adapter *padapter)
+{
+	efuse_reg_ctrl(padapter, _TRUE);
+	return _TRUE;
+}
+
+void rtw_efuse_reg_uninit(_adapter *padapter)
+{
+	efuse_reg_ctrl(padapter, _FALSE);
+}
+
+//------------------------------------------------------------------------------
+u8 efuse_one_byte_read(_adapter *padapter, u16 addr, u8 *data)
+{
+	u8 tmpidx = 0, bResult;
+
+	// -----------------e-fuse reg ctrl ---------------------------------				
+	rtw_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); //address
+	rtw_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) | (rtw_read8(padapter, EFUSE_CTRL+2)&0xFC));		
+
+	// use default program time 5000 ns
+	rtw_write32(padapter,   REG_EFUSE_CTRL, rtw_read32(padapter,  REG_EFUSE_CTRL)&( ~EF_FLAG));//read cmd
+
+	// wait for complete
+	while (!(0x80 & rtw_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+
+	if (tmpidx < 100) {
+		*data = rtw_read8(padapter, EFUSE_CTRL);
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_info_,("====Read Efuse addr=0x%x value=0x%x=====\n", addr, *data));
+		bResult = _TRUE;
+	} else {
+		*data = 0xff;
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Read Efuse fail!!! addr=0x%x=====\n", addr));
+		bResult = _FALSE;
+	}
+	return bResult;
+}
+//------------------------------------------------------------------------------
+static u8 efuse_one_byte_write(_adapter *padapter, u16 addr, u8 data)
+{
+	u8 tmpidx = 0, bResult;
+
+	// -----------------e-fuse reg ctrl ---------------------------------
+	rtw_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); //address
+	rtw_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) | (rtw_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	rtw_write8(padapter, EFUSE_CTRL, data); //data
+	
+	// use default program time 5000 ns
+	rtw_write32(padapter,REG_EFUSE_CTRL, rtw_read32(padapter,REG_EFUSE_CTRL)|EF_FLAG);//write cmd	
+
+	// wait for complete
+	while ((0x80 &  rtw_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+
+	if (tmpidx < 100) {
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_info_,("====Write Efuse addr=0x%x value=0x%x=====\n", addr, data));
+		bResult = _TRUE;
+	} else {
+		RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Write Efuse fail!! addr=0x%x value=0x%x=====\n", addr, data));
+		bResult = _FALSE;
+	}
+
+	return bResult;	
+}
+//------------------------------------------------------------------------------
+static u8 efuse_one_byte_rw(_adapter *padapter, u8 bRead, u16 addr, u8 *data)
+{
+	u8 tmpidx = 0, tmpv8 = 0, bResult;
+	
+	// -----------------e-fuse reg ctrl ---------------------------------				
+	rtw_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); //address
+	tmpv8 = ((u8)((addr>>8)&0x03)) | (rtw_read8(padapter, EFUSE_CTRL+2)&0xFC);
+	rtw_write8(padapter, EFUSE_CTRL+2, tmpv8);
+
+	if (_TRUE == bRead) {
+		rtw_write8(padapter, EFUSE_CTRL+3,  0x72);//read cmd		
+
+		while (!(0x80 & rtw_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+			tmpidx++;
+
+		if (tmpidx < 100) {		
+			*data = rtw_read8(padapter, EFUSE_CTRL);
+			bResult = _TRUE;
+		} else {
+			*data = 0;
+			RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Read Efuse Fail!! addr=0x%x =====\n", addr));		
+			bResult = _FALSE;
+		}
+	} else {
+		rtw_write8(padapter, EFUSE_CTRL, *data);//data
+		rtw_write8(padapter, EFUSE_CTRL+3, 0xF2);//write cmd
+
+		while ((0x80 & rtw_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+			tmpidx++;
+
+		if (tmpidx < 100) {
+			RT_TRACE(_module_rtl8712_efuse_c_,_drv_info_,("====Write Efuse addr=0x%x value=0x%x =====\n", addr, *data));
+			bResult = _TRUE;
+		} else {
+			RT_TRACE(_module_rtl8712_efuse_c_,_drv_err_,("====Write Efuse Fail!! addr =0x%x value=0x%x =====\n", addr, *data));
+			bResult = _FALSE;
+		}
+	}
+
+	return bResult;	
+}
+//------------------------------------------------------------------------------
+static u8 efuse_is_empty(_adapter *padapter, u8 *empty)
+{
+	u8 value, ret = _TRUE;
+
+	// read one byte to check if E-Fuse is empty
+	if (efuse_one_byte_rw(padapter, _TRUE, 0, &value) == _TRUE) {
+		if (0xFF == value) *empty = _TRUE;
+		else *empty = _FALSE;
+	} else {
+		// read fail
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_emerg_,
+			("efuse_is_empty: fail!!=====\n"));
+		ret = _FALSE;
+	}
+
+	return ret;
+}
+//------------------------------------------------------------------------------
+int rtw_efuse_get_max_phy_size(_adapter *padapter)
+{
+	u16 pre_pg_data_saddr = 507;
+	
+	u16 pre_pg_data_size = 5;
+	u8 pre_pg_data[5];
+	u16 i;
+	padapter->eeprompriv.efuse_phy_max_size = 509 ;	//reserved 3 byte for safe access
+	
+	for(i=0;i <pre_pg_data_size;i++){
+		efuse_one_byte_read(padapter,pre_pg_data_saddr+i,&pre_pg_data[i]);
+	}
+	if(	(pre_pg_data[0]==0x03) && (pre_pg_data[1]==0x00) && (pre_pg_data[2]==0x00) && 
+		(pre_pg_data[3]==0x00) && (pre_pg_data[4]==0x0C) ){
+		padapter->eeprompriv.efuse_phy_max_size = 504;//reserved 3 byte for safe access
+	}
+	printk("%s...eeprompriv.efuse_phy_max_size(%d)\n",__FUNCTION__,padapter->eeprompriv.efuse_phy_max_size);
+	return padapter->eeprompriv.efuse_phy_max_size;
+}
+//------------------------------------------------------------------------------
+static u8 calculate_word_cnts(const u8 word_en)
+{
+	u8 word_cnts = 0;
+	u8 word_idx;
+
+	for (word_idx = 0; word_idx < EFUSE_PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en & BIT(word_idx))) word_cnts++; // 0 : write enable		
+	}
+	return word_cnts;
+}
+//------------------------------------------------------------------------------
+static void pgpacket_copy_data(const u8 word_en, const u8 *sourdata, u8 *targetdata)
+{
+	u8 tmpindex = 0;
+	u8 word_idx, byte_idx;
+
+	for (word_idx = 0; word_idx < EFUSE_PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en&BIT(word_idx))) {	
+			byte_idx = word_idx * 2;
+			targetdata[byte_idx] = sourdata[tmpindex++];
+			targetdata[byte_idx + 1] = sourdata[tmpindex++];
+		}
+	}
+}
+//------------------------------------------------------------------------------
+u16 rtw_efuse_get_current_phy_size(_adapter *padapter)
+{
+	int bContinual = _TRUE;
+
+	u16 efuse_addr = 0;
+	u8 hoffset = 0, hworden = 0;
+	u8 efuse_data, word_cnts = 0;
+
+	while (bContinual && efuse_one_byte_read(padapter, efuse_addr, &efuse_data) &&
+	       (efuse_addr < padapter->eeprompriv.efuse_phy_max_size))
+	{
+		if (efuse_data != 0xFF) {
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;							
+			word_cnts = calculate_word_cnts(hworden);
+			//read next header
+			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
+		} else {
+			bContinual = _FALSE ;			
+		}
+	}
+
+	return efuse_addr;
+}
+//------------------------------------------------------------------------------
+u8 rtw_efuse_pg_packet_read(_adapter *padapter, u8 offset, u8 *data)
+{
+	u8 ReadState = EFUSE_PG_STATE_HEADER;	
+	
+	u8 bContinual = _TRUE;	
+
+	u8 efuse_data,word_cnts=0;
+	u16 efuse_addr = 0;
+	u8 hoffset=0,hworden=0;	
+	u8 tmpidx=0;
+	u8 tmpdata[8];
+	
+	if(data==NULL)	return _FALSE;
+	if(offset>0x0f)	return _FALSE;	
+	
+	_rtw_memset(data,0xFF,sizeof(u8)* EFUSE_PGPKT_DATA_SIZE);	
+	_rtw_memset(tmpdata,0xFF,sizeof(u8)* EFUSE_PGPKT_DATA_SIZE );		
+	
+	while(bContinual && (efuse_addr  < padapter->eeprompriv.efuse_phy_max_size) ){			
+		//-------  Header Read -------------
+		if(ReadState & EFUSE_PG_STATE_HEADER){
+			if(efuse_one_byte_read(padapter,efuse_addr ,&efuse_data)&&(efuse_data!=0xFF)){				
+				hoffset = (efuse_data>>4) & 0x0F;
+				hworden =  efuse_data & 0x0F;									
+				word_cnts = calculate_word_cnts(hworden);
+				
+				if(hoffset==offset){					
+					for(tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++){
+						if(efuse_one_byte_read(padapter,efuse_addr+1+tmpidx ,&efuse_data) ){
+							tmpdata[tmpidx] = efuse_data;						
+						}					
+					}
+					ReadState = EFUSE_PG_STATE_DATA;	
+					
+				}
+				else{//read next header	
+					efuse_addr = efuse_addr + (word_cnts*2)+1;
+					ReadState = EFUSE_PG_STATE_HEADER; 
+				}
+				
+			}
+			else{
+				bContinual = _FALSE;
+			}
+		}		
+		//-------  Data section Read -------------
+		else if(ReadState & EFUSE_PG_STATE_DATA){
+			pgpacket_copy_data(hworden,tmpdata,data);
+			efuse_addr = efuse_addr + (word_cnts*2)+1;
+			ReadState = EFUSE_PG_STATE_HEADER; 
+		}		
+	}			
+	
+	
+	if(	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
+		(data[4]==0xff) &&(data[5]==0xff) && (data[6]==0xff)  && (data[7]==0xff))
+		return _FALSE;
+	else
+		return _TRUE;
+}
+//------------------------------------------------------------------------------
+static u8 pgpacket_write_data(_adapter *padapter, const u16 efuse_addr, const u8 word_en, const u8 *data)
+{		
+	u16 start_addr = efuse_addr;
+
+	u8 badworden = 0x0F;
+
+	u8 word_idx, byte_idx;
+
+	u16 tmpaddr = 0;
+	u8 tmpdata[EFUSE_PGPKT_DATA_SIZE];
+
+
+	_rtw_memset(tmpdata, 0xff, EFUSE_PGPKT_DATA_SIZE);
+
+	for (word_idx = 0; word_idx < EFUSE_PGPKT_DATA_SIZE; word_idx++) {
+		if (!(word_en & BIT(word_idx))) {
+			tmpaddr = start_addr;
+			byte_idx = word_idx * 2;
+			efuse_one_byte_write(padapter, start_addr++, data[byte_idx]);
+			efuse_one_byte_write(padapter, start_addr++, data[byte_idx + 1]);
+
+			efuse_one_byte_read(padapter, tmpaddr, &tmpdata[byte_idx]);
+			efuse_one_byte_read(padapter, tmpaddr + 1, &tmpdata[byte_idx+1]);
+			if ((data[byte_idx] != tmpdata[byte_idx]) || (data[byte_idx+1] != tmpdata[byte_idx+1])) {
+				badworden &= (~BIT(word_idx));
+			}
+		}
+	}
+
+	return badworden;
+}
+
+//------------------------------------------------------------------------------
+u8 rtw_efuse_pg_packet_write(_adapter *padapter, const u8 offset, const u8 word_en, const u8 *data)
+{
+	u8 WriteState = EFUSE_PG_STATE_HEADER;		
+
+	u8 bContinual = _TRUE,bDataEmpty=_TRUE,bResult = _TRUE;
+	u16 efuse_addr = 0;
+	u8 efuse_data;
+
+	u8 pg_header = 0;
+	u16 remain_size = 0,curr_size = 0;
+	u16 tmp_addr=0;
+	
+	u8 tmp_word_cnts=0,target_word_cnts=0;
+	u8 tmp_header,match_word_en,tmp_word_en;
+
+	u8 word_idx;
+
+	PGPKT_STRUCT target_pkt;	
+	PGPKT_STRUCT tmp_pkt;
+	
+	u8 originaldata[sizeof(u8)*8];
+	u8 tmpindex = 0,badworden = 0x0F;
+
+	static int repeat_times = 0;
+
+	if( (curr_size= rtw_efuse_get_current_phy_size(padapter)) >= padapter->eeprompriv.efuse_phy_max_size){
+		return _FALSE;
+	}
+	remain_size = padapter->eeprompriv.efuse_phy_max_size - curr_size;
+
+	
+	
+	target_pkt.offset = offset;
+	target_pkt.word_en= word_en;
+	_rtw_memset(target_pkt.data,0xFF,sizeof(u8)*8);
+	pgpacket_copy_data(word_en,data,target_pkt.data);
+	target_word_cnts = calculate_word_cnts(target_pkt.word_en);	
+	
+	if( remain_size <  (target_word_cnts*2+1)){		
+		return _FALSE; //target_word_cnts + pg header(1 byte)
+	}
+	
+	
+	while( bContinual && (efuse_addr  < padapter->eeprompriv.efuse_phy_max_size) ){
+		
+		if(WriteState==EFUSE_PG_STATE_HEADER){	
+			bDataEmpty=_TRUE;
+			badworden = 0x0F;		
+			//************  so *******************	
+			if( efuse_one_byte_read(padapter,efuse_addr ,&efuse_data) &&(efuse_data!=0xFF)){ 	
+				tmp_header  =  efuse_data;
+				
+				tmp_pkt.offset 	= (tmp_header>>4) & 0x0F;
+				tmp_pkt.word_en 	= tmp_header & 0x0F;					
+				tmp_word_cnts 	= calculate_word_cnts(tmp_pkt.word_en);
+
+				//************  so-1 *******************
+				if(tmp_pkt.offset  != target_pkt.offset){
+					efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+					WriteState = EFUSE_PG_STATE_HEADER;
+				}
+				else{	
+					//************  so-2 *******************
+					for(tmpindex=0 ; tmpindex<(tmp_word_cnts*2) ; tmpindex++){
+						if(efuse_one_byte_read(padapter,(efuse_addr+1+tmpindex) ,&efuse_data)&&(efuse_data != 0xFF)){
+							bDataEmpty = _FALSE;	
+						}
+					}	
+					//************  so-2-1 *******************
+					if(bDataEmpty == _FALSE){						
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet	
+						WriteState=EFUSE_PG_STATE_HEADER;
+					}
+					else{//************  so-2-2 *******************
+						match_word_en = 0x0F;					
+						for(word_idx=0;word_idx<4;word_idx++){
+							if(   !( (target_pkt.word_en&BIT(word_idx))|(tmp_pkt.word_en&BIT(word_idx))  )){
+								 match_word_en &= (~BIT(word_idx));
+							}	
+						}					
+						//************  so-2-2-A *******************
+						if((match_word_en&0x0F)!=0x0F){							
+							badworden = pgpacket_write_data(padapter,efuse_addr+1, tmp_pkt.word_en ,target_pkt.data);
+							
+							//************  so-2-2-A-1 *******************
+							//############################
+							if(0x0F != (badworden&0x0F)){														
+								u8 reorg_offset = offset;
+								u8 reorg_worden=badworden;								
+								rtw_efuse_pg_packet_write(padapter,reorg_offset,reorg_worden,originaldata);	
+							}	
+							//############################						
+
+							tmp_word_en = 0x0F;						
+							for(word_idx=0;word_idx<4;word_idx++){
+								if(  (target_pkt.word_en&BIT(word_idx))^(match_word_en&BIT(word_idx))  ){
+									tmp_word_en &= (~BIT(word_idx));
+								}
+							}				
+							//************  so-2-2-A-2 *******************	
+							if((tmp_word_en&0x0F)!=0x0F){
+								//reorganize other pg packet														
+								efuse_addr = rtw_efuse_get_current_phy_size(padapter);								
+								//===========================
+								target_pkt.offset = offset;
+								target_pkt.word_en= tmp_word_en;					
+								//===========================
+							}else{								
+								bContinual = _FALSE;								
+							}	
+							WriteState=EFUSE_PG_STATE_HEADER;
+							repeat_times++;
+							if(repeat_times>EFUSE_REPROG_THRESHOLD){
+								bContinual = _FALSE;
+								bResult = _FALSE;
+							}
+						}
+						else{//************  so-2-2-B *******************
+							//reorganize other pg packet						
+							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr							
+							//===========================
+							target_pkt.offset = offset;
+							target_pkt.word_en= target_pkt.word_en;					
+							//===========================	
+							WriteState=EFUSE_PG_STATE_HEADER;
+						}
+						
+					}				
+					
+				}				
+				
+			}
+			else	{ //************  s1: header == oxff  *******************	
+				curr_size = rtw_efuse_get_current_phy_size(padapter);
+				remain_size = padapter->eeprompriv.efuse_phy_max_size - curr_size;			
+				
+				if( remain_size <  (target_word_cnts*2+1)) //target_word_cnts + pg header(1 byte)
+				{					
+					bContinual = _FALSE;
+					bResult = _FALSE;	
+				}
+				else{
+					pg_header = ((target_pkt.offset << 4)&0xf0) |target_pkt.word_en;							
+
+					efuse_one_byte_write(padapter,efuse_addr, pg_header);
+					efuse_one_byte_read(padapter,efuse_addr, &tmp_header);		
+			
+					if(tmp_header == pg_header){ //************  s1-1 *******************								
+						WriteState = EFUSE_PG_STATE_DATA;						
+					}
+					else if(tmp_header == 0xFF){//************  s1-3: if Write or read func doesn't work *******************		
+						//efuse_addr doesn't change
+						WriteState = EFUSE_PG_STATE_HEADER;					
+						repeat_times++;
+						if(repeat_times>EFUSE_REPROG_THRESHOLD){
+							bContinual = _FALSE;
+							bResult = _FALSE;
+						}
+					}
+					else{//************  s1-2 : fixed the header procedure *******************							
+						tmp_pkt.offset = (tmp_header>>4) & 0x0F;
+						tmp_pkt.word_en=  tmp_header & 0x0F;					
+						tmp_word_cnts =  calculate_word_cnts(tmp_pkt.word_en);
+																												
+						//************  s1-2-A :cover the exist data *******************
+						_rtw_memset(originaldata,0xff,sizeof(u8)*8);
+						
+						if(rtw_efuse_pg_packet_read( padapter, tmp_pkt.offset,originaldata)){	//check if data exist 											
+							badworden = pgpacket_write_data(padapter,efuse_addr+1,tmp_pkt.word_en,originaldata);	
+							//############################
+							if(0x0F != (badworden&0x0F)){														
+								u8 reorg_offset = tmp_pkt.offset;
+								u8 reorg_worden=badworden;								
+								rtw_efuse_pg_packet_write(padapter,reorg_offset,reorg_worden,originaldata);	
+								efuse_addr = rtw_efuse_get_current_phy_size(padapter);							
+							}
+							//############################
+							else{
+								efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet							
+							}						
+						}
+						 //************  s1-2-B: wrong address*******************
+						else{
+							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet						
+						}	
+						WriteState=EFUSE_PG_STATE_HEADER;	
+						repeat_times++;
+						if(repeat_times>EFUSE_REPROG_THRESHOLD){
+							bContinual = _FALSE;
+							bResult = _FALSE;
+						}
+					}
+				}
+
+			}
+
+		}
+		//write data state
+		else if(WriteState==EFUSE_PG_STATE_DATA) {//************  s1-1  *******************
+			badworden = 0x0f;
+			badworden = pgpacket_write_data(padapter,efuse_addr+1,target_pkt.word_en,target_pkt.data);	
+			if((badworden&0x0F)==0x0F){ //************  s1-1-A *******************
+				bContinual = _FALSE;
+			}
+			else{//reorganize other pg packet //************  s1-1-B *******************
+				efuse_addr = efuse_addr + (2*target_word_cnts) +1;//next pg packet addr				
+						
+				//===========================
+				target_pkt.offset = offset;
+				target_pkt.word_en= badworden;	
+				target_word_cnts = calculate_word_cnts(target_pkt.word_en);
+				//===========================			
+				WriteState=EFUSE_PG_STATE_HEADER;	
+				repeat_times++;
+				if(repeat_times>EFUSE_REPROG_THRESHOLD){
+					bContinual = _FALSE;
+					bResult = _FALSE;
+				}
+			}
+		}
+	}
+
+	return bResult;
+}
+//------------------------------------------------------------------------------
+u8 rtw_efuse_access(_adapter *padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data)
+{
+	int i = 0;
+	u8 res;
+
+	if (start_addr > padapter->eeprompriv.efuse_phy_max_size)
+		return _FALSE;
+
+	if ((bRead == _FALSE) && ((start_addr + cnts) > padapter->eeprompriv.efuse_phy_max_size))
+		return _FALSE;
+
+	if ((_FALSE == bRead) && (rtw_efuse_reg_init(padapter) == _FALSE))
+		return _FALSE;
+
+	//-----------------e-fuse one byte read / write ------------------------------	
+	for (i = 0; i < cnts; i++) {
+		if ((start_addr + i) > padapter->eeprompriv.efuse_phy_max_size) {
+			res = _FALSE;
+			break;
+		}
+		res = efuse_one_byte_rw(padapter, bRead, start_addr + i, data + i);
+//		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("==>rtw_efuse_access addr:0x%02x value:0x%02x\n",data+i,*(data+i)));
+		if ((_FALSE == bRead) && (_FALSE == res)) break;
+	}
+
+	if (_FALSE == bRead) rtw_efuse_reg_uninit(padapter);
+
+	return res;
+}	
+//------------------------------------------------------------------------------
+u8 rtw_efuse_map_read(_adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, ret = _TRUE;
+	u8 pktdata[EFUSE_PGPKT_DATA_SIZE];
+	int i, idx;
+
+	if ((addr + cnts) > EFUSE_MAX_LOGICAL_SIZE)
+		return _FALSE;
+
+	if ((efuse_is_empty(padapter, &offset) == _TRUE) && (offset == _TRUE)) {
+		for (i = 0; i < cnts; i++)
+			data[i] = 0xFF;
+		return ret;
+	}
+
+	offset = (addr >> 3) & 0xF;
+	ret = rtw_efuse_pg_packet_read(padapter, offset, pktdata);
+	i = addr & 0x7;	// pktdata index
+	idx = 0;	// data index
+
+	do {
+		for (; i < EFUSE_PGPKT_DATA_SIZE; i++) {
+			data[idx++] = pktdata[i];
+			if (idx == cnts) return ret;
+		}
+
+		offset++;
+//		if (offset > 0xF) break; // no need to check
+		if (rtw_efuse_pg_packet_read(padapter, offset, pktdata) == _FALSE)
+			ret = _FALSE;
+		i = 0;
+	} while (1);
+
+	return ret;
+}
+//------------------------------------------------------------------------------
+u8 rtw_efuse_map_write(_adapter* padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, word_en, empty;
+	u8 pktdata[EFUSE_PGPKT_DATA_SIZE], newdata[EFUSE_PGPKT_DATA_SIZE];
+	int i, j, idx;
+
+	if ((addr + cnts) > EFUSE_MAX_LOGICAL_SIZE)
+		return _FALSE;
+
+	// check if E-Fuse Clock Enable and E-Fuse Clock is 40M
+	//empty = rtw_read8(padapter, EFUSE_CLK_CTRL);
+	//if (empty != 0x03) {
+	//	RT_TRACE(_module_rtl8712_efuse_c_, _drv_err_,("rtw_efuse_map_write: EFUSE_CLK_CTRL=0x%2x != 0x03", empty));
+	//	return _FALSE;
+	//}
+
+	if (efuse_is_empty(padapter, &empty) == _TRUE) {
+		if (_TRUE == empty)
+			_rtw_memset(pktdata, 0xFF, EFUSE_PGPKT_DATA_SIZE);
+	} else
+		return _FALSE;
+
+	offset = (addr >> 3) & 0xF;
+	if (empty == _FALSE)
+		if (rtw_efuse_pg_packet_read(padapter, offset, pktdata) == _FALSE)
+			return _FALSE;
+
+	word_en = 0xF;
+	_rtw_memset(newdata, 0xFF, EFUSE_PGPKT_DATA_SIZE);
+	i = addr & 0x7;	// pktdata index
+	j = 0;		// newdata index
+	idx = 0;	// data index
+
+	if (i & 0x1) {
+		// odd start
+		if (data[idx] != pktdata[i]) {
+			word_en &= ~BIT(i >> 1);
+			newdata[j++] = pktdata[i - 1];
+			newdata[j++] = data[idx];
+		}
+		i++;
+		idx++;
+	}
+	do {
+		for (; i < EFUSE_PGPKT_DATA_SIZE; i += 2) {
+			if ((cnts - idx) == 1) {
+				if (data[idx] != pktdata[i]) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = pktdata[1 + 1];
+				}
+				idx++;
+				break;
+			} else {
+				if ((data[idx] != pktdata[i]) || (data[idx+1] != pktdata[i+1])) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = data[idx + 1];
+				}
+				idx += 2;
+			}
+			if (idx == cnts) break;
+		}
+
+		if (word_en != 0xF)
+			if (rtw_efuse_pg_packet_write(padapter, offset, word_en, newdata) == _FALSE)
+				return _FALSE;
+
+		if (idx == cnts) break;
+
+		offset++;
+		if (empty == _FALSE)
+			if (rtw_efuse_pg_packet_read(padapter, offset, pktdata) == _FALSE)
+				return _FALSE;
+		i = 0;
+		j = 0;
+		word_en = 0xF;
+		_rtw_memset(newdata, 0xFF, EFUSE_PGPKT_DATA_SIZE);
+	} while (1);
+
+	return _TRUE;
+}
+//------------------------------------------------------------------------------
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/ieee80211.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/ieee80211.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/ieee80211.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/ieee80211.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,646 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _IEEE80211_C
+
+#include <drv_types.h>
+#include <ieee80211.h>
+#include <wifi.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+
+
+//-----------------------------------------------------------
+// for adhoc-master to generate ie and provide supported-rate to fw 
+//-----------------------------------------------------------
+
+static u8 	WIFI_CCKRATES[] = 
+{(IEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK)};
+
+static u8 	WIFI_OFDMRATES[] = 
+{(IEEE80211_OFDM_RATE_6MB),
+ (IEEE80211_OFDM_RATE_9MB),
+ (IEEE80211_OFDM_RATE_12MB),
+ (IEEE80211_OFDM_RATE_18MB),
+ (IEEE80211_OFDM_RATE_24MB),
+ IEEE80211_OFDM_RATE_36MB,
+ IEEE80211_OFDM_RATE_48MB,
+ IEEE80211_OFDM_RATE_54MB};
+
+
+int rtw_get_bit_value_from_ieee_value(u8 val)
+{
+	unsigned char dot11_rate_table[]={2,4,11,22,12,18,24,36,48,72,96,108,0}; // last element must be zero!!
+
+	int i=0;
+	while(dot11_rate_table[i] != 0) {
+		if (dot11_rate_table[i] == val)
+			return BIT(i);
+		i++;
+	}
+	return 0;
+}
+
+uint	rtw_is_cckrates_included(u8 *rate)
+{	
+		u32	i = 0;			
+
+		while(rate[i]!=0)
+		{		
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||		
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )		
+			return _TRUE;	
+			i++;
+		}
+		
+		return _FALSE;
+}
+
+uint	rtw_is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+
+	while(rate[i]!=0)
+	{
+			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+
+			return _FALSE;		
+
+			i++;
+	}
+	
+	return _TRUE;
+
+}
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel)
+{
+	if (channel > 14)
+	{
+		if ((rtw_is_cckrates_included(rate)) == _TRUE)
+			return WIRELESS_INVALID;
+		else
+			return WIRELESS_11A;
+	}	
+	else  // could be pure B, pure G, or B/G
+	{
+		if ((rtw_is_cckratesonly_included(rate)) == _TRUE)	
+			return WIRELESS_11B;
+		else if((rtw_is_cckrates_included(rate)) == _TRUE)
+			return 	WIRELESS_11BG;
+		else
+			return WIRELESS_11G;
+	}
+	
+}
+
+u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source,
+				unsigned int *frlen)
+{
+	_rtw_memcpy((void *)pbuf, (void *)source, len);
+	*frlen = *frlen + len;
+	return (pbuf + len);
+}
+
+// rtw_set_ie will update frame length
+u8 *rtw_set_ie
+(
+	u8 *pbuf, 
+	sint index, 
+	uint len,
+	u8 *source, 
+	uint *frlen //frame length
+)
+{
+_func_enter_;
+	*pbuf = (u8)index;
+
+	*(pbuf + 1) = (u8)len;
+
+	if (len > 0)
+		_rtw_memcpy((void *)(pbuf + 2), (void *)source, len);
+	
+	*frlen = *frlen + (len + 2);
+	
+	return (pbuf + len + 2);
+_func_exit_;	
+}
+
+
+
+/*----------------------------------------------------------------------------
+index: the information element id index, limit is the limit for search
+-----------------------------------------------------------------------------*/
+u8 *rtw_get_ie(u8 *pbuf, sint index, sint *len, sint limit)
+{
+	sint tmp,i;
+	u8 *p;
+_func_enter_;
+	if (limit < 1){
+		_func_exit_;	
+		return NULL;
+	}
+
+	p = pbuf;
+	i = 0;
+	*len = 0;
+	while(1)
+	{
+		if (*p == index)
+		{
+			*len = *(p + 1);
+			return (p);
+		}
+		else
+		{
+			tmp = *(p + 1);
+			p += (tmp + 2);
+			i += (tmp + 2);
+		}
+		if (i >= limit)
+			break;
+	}
+_func_exit_;		
+	return NULL;
+}
+
+void rtw_set_supported_rate(u8* SupportedRates, uint mode) 
+{
+_func_enter_;
+
+	_rtw_memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+	
+	switch (mode)
+	{
+		case WIRELESS_11B:
+			_rtw_memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+			break;
+		
+		case WIRELESS_11G:
+		case WIRELESS_11A:	
+		case WIRELESS_11N:	
+			_rtw_memcpy(SupportedRates, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+			break;
+		
+		case WIRELESS_11BG:
+		case WIRELESS_11GN:
+		case WIRELESS_11BGN:	
+			_rtw_memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+			_rtw_memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+			break;
+	
+	}
+_func_exit_;	
+}
+
+uint	rtw_get_rateset_len(u8	*rateset)
+{
+	uint i = 0;
+_func_enter_;	
+	while(1)
+	{
+		if ((rateset[i]) == 0)
+			break;
+			
+		if (i > 12)
+			break;
+			
+		i++;			
+	}
+_func_exit_;		
+	return i;
+}
+
+int rtw_generate_ie(struct registry_priv *pregistrypriv)
+{
+	int 	sz = 0, rateLen;
+	WLAN_BSSID_EX*	pdev_network = &pregistrypriv->dev_network;
+	u8*	ie = pdev_network->IEs;
+	
+_func_enter_;		
+
+	//timestamp will be inserted by hardware
+	sz += 8;	
+	ie += sz;
+	
+	//beacon interval : 2bytes
+	*(u16*)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);//BCN_INTERVAL;
+	sz += 2; 
+	ie += 2;
+	
+	//capability info
+	*(u16*)ie = 0;
+	
+	*(u16*)ie |= cpu_to_le16(cap_IBSS);
+
+	if(pregistrypriv->preamble == PREAMBLE_SHORT)
+		*(u16*)ie |= cpu_to_le16(cap_ShortPremble);
+	
+	if (pdev_network->Privacy)
+		*(u16*)ie |= cpu_to_le16(cap_Privacy);
+	
+	sz += 2;
+	ie += 2;
+	
+	//SSID
+	ie = rtw_set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength, pdev_network->Ssid.Ssid, &sz);
+	
+	//supported rates
+	rtw_set_supported_rate(pdev_network->SupportedRates, pregistrypriv->wireless_mode) ;
+	
+	rateLen = rtw_get_rateset_len(pdev_network->SupportedRates);
+
+	if (rateLen > 8)
+	{
+		ie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, 8, pdev_network->SupportedRates, &sz);
+		//ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz);
+	}
+	else
+	{
+		ie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, rateLen, pdev_network->SupportedRates, &sz);
+	}
+
+	//DS parameter set
+	ie = rtw_set_ie(ie, _DSSET_IE_, 1, (u8 *)&(pdev_network->Configuration.DSConfig), &sz);
+
+
+	//IBSS Parameter Set
+	
+	ie = rtw_set_ie(ie, _IBSS_PARA_IE_, 2, (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
+
+
+	if (rateLen > 8)
+	{		
+		ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz);
+	}
+	
+		
+	//HT Cap.
+	if((pregistrypriv->wireless_mode&WIRELESS_11N) && (pregistrypriv->ht_enable==_TRUE))
+	{
+		//todo:
+	}
+		
+
+	//pdev_network->IELength =  sz; //update IELength
+
+_func_exit_;		
+
+	//return _SUCCESS;
+	
+	return sz;
+	
+}
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
+{	
+	int len;
+	u16 val16;
+	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};		
+	u8 *pbuf = pie;
+
+	while(1) 
+	{
+		pbuf = rtw_get_ie(pbuf, _WPA_IE_ID_, &len, limit);
+
+		if (pbuf) {
+
+			//check if oui matches...
+			if (_rtw_memcmp((pbuf + 2), wpa_oui_type, sizeof (wpa_oui_type)) == _FALSE) {
+
+				goto check_next_ie;
+			}
+
+			//check version...
+			_rtw_memcpy((u8 *)&val16, (pbuf + 6), sizeof(val16));
+
+			val16 = le16_to_cpu(val16);
+			if (val16 != 0x0001)
+				goto check_next_ie;	
+
+			*wpa_ie_len = *(pbuf + 1);
+
+			return pbuf;
+
+		}
+		else {
+
+			*wpa_ie_len = 0;			
+			return NULL;
+		}
+
+check_next_ie:
+
+		limit = limit - (pbuf - pie) - 2 - len;
+
+		if (limit <= 0)
+			break;
+
+		pbuf += (2 + len);
+		
+	}
+	
+	*wpa_ie_len = 0;
+	
+	return NULL;
+
+}
+
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)
+{	
+
+	return rtw_get_ie(pie, _WPA2_IE_ID_,rsn_ie_len, limit);
+
+}
+
+int rtw_get_wpa_cipher_suite(u8 *s)
+{
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_NONE;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP40;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_TKIP;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_CCMP;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+int rtw_get_wpa2_cipher_suite(u8 *s)
+{
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_NONE;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP40;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_TKIP;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_CCMP;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN) == _TRUE)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+
+int rtw_parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher)
+{
+	int i, ret=_SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (wpa_ie_len <= 0) {
+		/* No WPA IE - fail silently */
+		return _FAIL;
+	}
+
+	
+	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (u8)(wpa_ie_len - 2)) ||
+	   (_rtw_memcmp(wpa_ie+2, WPA_OUI_TYPE, WPA_SELECTOR_LEN) != _TRUE) )
+	{		
+		return _FAIL;
+	}
+
+	pos = wpa_ie;
+
+	pos += 8;
+	left = wpa_ie_len - 8;	
+
+
+	//group_cipher
+	if (left >= WPA_SELECTOR_LEN) {
+
+		*group_cipher = rtw_get_wpa_cipher_suite(pos);
+		
+		pos += WPA_SELECTOR_LEN;
+		left -= WPA_SELECTOR_LEN;
+		
+	} 
+	else if (left > 0)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie length mismatch, %u too much", __FUNCTION__, left));
+		
+		return _FAIL;
+	}
+
+
+	//pairwise_cipher
+	if (left >= 2)
+	{		
+		count = le16_to_cpu(*(u16*)pos);//			
+		pos += 2;
+		left -= 2;
+		
+		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie count botch (pairwise), "
+				   		"count %u left %u", __FUNCTION__, count, left));
+			return _FAIL;
+		}
+		
+		for (i = 0; i < count; i++)
+		{
+			*pairwise_cipher |= rtw_get_wpa_cipher_suite(pos);
+			
+			pos += WPA_SELECTOR_LEN;
+			left -= WPA_SELECTOR_LEN;
+		}
+		
+	} 
+	else if (left == 1)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie too short (for key mgmt)",   __FUNCTION__));
+		return _FAIL;
+	}
+
+	
+	return ret;
+	
+}
+
+int rtw_parse_wpa2_ie(u8* rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwise_cipher)
+{
+	int i, ret=_SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (rsn_ie_len <= 0) {
+		/* No RSN IE - fail silently */
+		return _FAIL;
+	}
+
+
+	if ((*rsn_ie!= _WPA2_IE_ID_) || (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
+	{		
+		return _FAIL;
+	}
+	
+	pos = rsn_ie;
+	pos += 4;
+	left = rsn_ie_len - 4;	
+
+	//group_cipher
+	if (left >= RSN_SELECTOR_LEN) {
+
+		*group_cipher = rtw_get_wpa2_cipher_suite(pos);
+		
+		pos += RSN_SELECTOR_LEN;
+		left -= RSN_SELECTOR_LEN;
+		
+	} else if (left > 0) {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie length mismatch, %u too much", __FUNCTION__, left));
+		return _FAIL;
+	}
+
+	//pairwise_cipher
+	if (left >= 2)
+	{		
+		count = le16_to_cpu(*(u16*)pos);//			
+		pos += 2;
+		left -= 2;
+
+		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie count botch (pairwise), "
+				  		 "count %u left %u", __FUNCTION__, count, left));
+			return _FAIL;
+		}
+		
+		for (i = 0; i < count; i++)
+		{			
+			*pairwise_cipher |= rtw_get_wpa2_cipher_suite(pos);
+			
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+
+	} 
+	else if (left == 1)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie too short (for key mgmt)",  __FUNCTION__));
+		
+		return _FAIL;
+	}
+
+
+	return ret;
+	
+}
+
+int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len)
+{
+	u8 authmode, sec_idx, i;
+	u8 wpa_oui[4]={0x0,0x50,0xf2,0x01};
+	uint 	cnt;
+	
+_func_enter_;
+
+	//Search required WPA or WPA2 IE and copy to sec_ie[ ]
+	
+	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
+	
+	sec_idx=0;
+		
+	while(cnt<in_len)
+	{
+		authmode=in_ie[cnt];
+		
+		if((authmode==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0],4)==_TRUE))
+		{	
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_get_wpa_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));		
+
+				_rtw_memcpy(wpa_ie, &in_ie[cnt],in_ie[cnt+1]+2);
+
+				for(i=0;i<(in_ie[cnt+1]+2);i=i+8){
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",wpa_ie[i],wpa_ie[i+1],wpa_ie[i+2],wpa_ie[i+3],wpa_ie[i+4],wpa_ie[i+5],wpa_ie[i+6],wpa_ie[i+7]));
+				}
+
+				*wpa_len=in_ie[cnt+1]+2;
+				cnt+=in_ie[cnt+1]+2;  //get next
+		}
+		else
+		{
+			if(authmode==_WPA2_IE_ID_)
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n get_rsn_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));		
+
+				_rtw_memcpy(rsn_ie, &in_ie[cnt],in_ie[cnt+1]+2);
+
+				for(i=0;i<(in_ie[cnt+1]+2);i=i+8){
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",rsn_ie[i],rsn_ie[i+1],rsn_ie[i+2],rsn_ie[i+3],rsn_ie[i+4],rsn_ie[i+5],rsn_ie[i+6],rsn_ie[i+7]));
+				}
+
+				*rsn_len=in_ie[cnt+1]+2;
+				cnt+=in_ie[cnt+1]+2;  //get next
+			}
+			else
+			{
+				cnt+=in_ie[cnt+1]+2;   //get next
+			}	
+		}
+		
+	}
+	
+_func_exit_;
+
+	return (*rsn_len+*wpa_len);
+	
+}
+
+int rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)
+{
+	int match;
+	uint cnt;	
+	u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+
+
+	cnt=12;	
+	match=_FALSE;
+	while(cnt<in_len)
+	{
+		eid = in_ie[cnt];
+		
+		if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], wps_oui, 4)==_TRUE))
+		{
+			_rtw_memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+			
+			*wps_ielen = in_ie[cnt+1]+2;
+			
+			cnt+=in_ie[cnt+1]+2;
+
+			match = _TRUE;
+			break;
+		}
+		else
+		{
+			cnt+=in_ie[cnt+1]+2; //goto next	
+		}		
+		
+	}	
+
+	return match;
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/led/rtl8192c_led.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/led/rtl8192c_led.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/led/rtl8192c_led.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/led/rtl8192c_led.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,2706 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#include "drv_types.h"
+
+//================================================================================
+//	Constant.
+//================================================================================
+
+//
+// Default LED behavior.
+//
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA		1000
+#define LED_BLINK_LINK_INTERVAL_ALPHA			500		//500
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180 	//150
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+//================================================================================
+// LED object.
+//================================================================================
+enum _LED_STATE_871x{
+	LED_UNKNOWN = 0,
+	LED_ON = 1,
+	LED_OFF = 2,
+	LED_BLINK_NORMAL = 3,
+	LED_BLINK_SLOWLY = 4,
+	LED_POWER_ON_BLINK = 5,
+	LED_SCAN_BLINK = 6, // LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
+	LED_NO_LINK_BLINK = 7, // LED is blinking during no link state.
+	LED_BLINK_StartToBlink = 8,// Customzied for Sercomm Printer Server case
+	LED_BLINK_WPS = 9,	// LED is blinkg during WPS communication	
+	LED_TXRX_BLINK = 10,
+	LED_BLINK_WPS_STOP = 11,	//for ALPHA	
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	//for BELKIN
+	
+};
+
+//================================================================================
+//	Prototype of protected function.
+//================================================================================
+
+
+static void
+BlinkTimerCallback(
+	unsigned long data
+	);
+
+static void
+BlinkWorkItemCallback(
+	struct work_struct *work
+	);
+
+//================================================================================
+// LED_819xUsb routines. 
+//================================================================================
+
+//
+//	Description:
+//		Initialize an LED_871x object.
+//
+static void
+InitLed871x(
+	_adapter			*padapter,
+	PLED_871x		pLed,
+	LED_PIN_871x	LedPin
+	)
+{
+	pLed->padapter = padapter;
+
+	pLed->LedPin = LedPin;
+
+	pLed->CurrLedState = LED_OFF;
+	pLed->bLedOn = _FALSE;
+
+	pLed->bLedBlinkInProgress = _FALSE;
+	pLed->BlinkTimes = 0;
+	pLed->BlinkingLedState = LED_UNKNOWN;
+
+	_init_timer(&(pLed->BlinkTimer), padapter->pnetdev, BlinkTimerCallback, pLed);
+
+	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
+}
+
+
+//
+//	Description:
+//		DeInitialize an LED_871x object.
+//
+static void
+DeInitLed871x(
+	PLED_871x			pLed
+	)
+{
+	_cancel_timer_ex(&(pLed->BlinkTimer));
+
+	// We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko.
+	pLed->bLedBlinkInProgress = _FALSE;
+}
+
+
+//
+//	Description:
+//		Turn on LED according to LedPin specified.
+//
+static void
+SwLedOn(
+	_adapter			*padapter, 
+	PLED_871x		pLed
+)
+{
+	u8	LedCfg;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+       {
+             return;
+       }
+
+
+	if( 	(BOARD_MINICARD == pHalData->BoardType )||
+		(BOARD_USB_SOLO == pHalData->BoardType)||
+		(BOARD_USB_COMBO == pHalData->BoardType))
+	{
+		LedCfg = rtw_read8(padapter, REG_LEDCFG2);
+		switch(pLed->LedPin)
+		{	
+			case LED_PIN_GPIO0:
+				break;
+
+			case LED_PIN_LED0:
+				rtw_write8(padapter, REG_LEDCFG2, (LedCfg&0xf0)|BIT5|BIT6); // SW control led0 on.
+				break;
+
+			case LED_PIN_LED1:
+				rtw_write8(padapter, REG_LEDCFG2, (LedCfg&0x0f)|BIT5); // SW control led1 on.
+				break;
+
+			default:
+				break;
+	
+		}
+	}
+	else
+	{	
+	switch(pLed->LedPin)
+	{
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			if(pHalData->AntDivCfg)
+			{
+				LedCfg = rtw_read8(padapter, REG_LEDCFG2);
+				rtw_write8(padapter,REG_LEDCFG2, (LedCfg&0xe0)|BIT7|BIT6|BIT5); // SW control led0 on.							
+			}
+			else
+#endif
+			{
+				LedCfg = rtw_read8(padapter, REG_LEDCFG0);
+				rtw_write8(padapter,REG_LEDCFG0, LedCfg&0x70); // SW control led0 on.
+				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED0 0x%lx\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG0)));
+			}
+		break;
+
+		case LED_PIN_LED1:
+				LedCfg = rtw_read8(padapter,(REG_LEDCFG1));
+				rtw_write8(padapter,(REG_LEDCFG1), LedCfg&0x70); // SW control led1 on.
+				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED1 0x%lx\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG0)));
+			
+			break;
+
+		default:
+			break;
+	}
+	}
+	pLed->bLedOn = _TRUE;
+	
+}
+
+
+//
+//	Description:
+//		Turn off LED according to LedPin specified.
+//
+static void
+SwLedOff(
+	_adapter			*padapter, 
+	PLED_871x		pLed
+)
+{
+	u8	LedCfg;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	if((padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+	{
+             return;
+	}
+
+	if( 	(BOARD_MINICARD == pHalData->BoardType )||
+		(BOARD_USB_SOLO == pHalData->BoardType)||
+		(BOARD_USB_COMBO == pHalData->BoardType))
+	{
+		LedCfg = rtw_read8(padapter, REG_LEDCFG2);//0x4E
+
+	switch(pLed->LedPin)
+	{
+
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+				if(BOARD_USB_COMBO == pHalData->BoardType)
+				{
+					LedCfg &= 0x90; // Set to software control.				
+					rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));				
+					LedCfg = rtw_read8(padapter, REG_MAC_PINMUX_CFG);
+					LedCfg &= 0xFE;
+					rtw_write8(padapter, REG_MAC_PINMUX_CFG, (LedCfg|BIT3));									
+				}
+				else
+				{
+			                LedCfg &= 0xf0; // Set to software control.
+					if(padapter->ledpriv.bLedOpenDrain == _TRUE) // Open-drain arrangement for controlling the LED
+						rtw_write8(padapter,  REG_LEDCFG2, (LedCfg|BIT1|BIT5|BIT6));
+					else
+				                rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3|BIT5|BIT6));
+				}
+			break;
+
+		case LED_PIN_LED1:
+			LedCfg &= 0x0f; // Set to software control.
+				rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));
+			break;
+
+		default:
+			break;
+	}
+	}
+	else
+	{
+		switch(pLed->LedPin)
+		{
+			case LED_PIN_GPIO0:
+				break;
+
+			case LED_PIN_LED0:
+
+				#ifdef CONFIG_ANTENNA_DIVERSITY
+				if(pHalData->AntDivCfg)
+				{
+					LedCfg = rtw_read8(padapter, REG_LEDCFG2);
+					LedCfg &= 0xe0; // Set to software control. 			
+					rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3|BIT7|BIT6|BIT5));
+					//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED0 0x%x\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG2)));		
+				}
+				else
+				#endif
+				{				
+					LedCfg = rtw_read8(padapter, REG_LEDCFG0);
+					LedCfg &= 0x70; // Set to software control. 			
+					rtw_write8(padapter, REG_LEDCFG0, (LedCfg|BIT3));
+					//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED0 0x%lx\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG0)));
+				}		
+				break;
+
+			case LED_PIN_LED1:
+				LedCfg = rtw_read8(padapter, (REG_LEDCFG1));
+				LedCfg &= 0x70; // Set to software control.
+				rtw_write8(padapter,  (REG_LEDCFG1), (LedCfg|BIT3));
+				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED1 0x%lx\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG0)));
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	pLed->bLedOn = _FALSE;
+	
+}
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+
+//
+//	Description:
+//		Initialize all LED_871x objects.
+//
+void
+rtw_InitSwLeds(
+	_adapter	*padapter
+	)
+{
+	struct led_priv *pledpriv = &(padapter->ledpriv);
+
+	pledpriv->LedControlHandler = rtw_LedControl871x;
+
+	InitLed871x(padapter, &(pledpriv->SwLed0), LED_PIN_LED0);
+
+	InitLed871x(padapter,&(pledpriv->SwLed1), LED_PIN_LED1);
+}
+
+
+//
+//	Description:
+//		DeInitialize all LED_819xUsb objects.
+//
+void
+rtw_DeInitSwLeds(
+	_adapter	*padapter
+	)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	DeInitLed871x( &(ledpriv->SwLed0) );
+	DeInitLed871x( &(ledpriv->SwLed1) );
+}
+
+
+//
+//	Description:
+//		Implementation of LED blinking behavior.
+//		It toggle off LED and schedule corresponding timer if necessary.
+//
+static void
+SwLedBlink(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 			bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	// Determine if we shall change LED state again.
+	pLed->BlinkTimes--;
+	switch(pLed->CurrLedState)
+	{
+
+	case LED_BLINK_NORMAL: 
+		if(pLed->BlinkTimes == 0)
+		{
+			bStopBlinking = _TRUE;
+		}
+		break;
+		
+	case LED_BLINK_StartToBlink:
+		if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)&&(pmlmepriv->fw_state & WIFI_STATION_STATE) )
+		{
+			bStopBlinking = _TRUE;
+		}
+		if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)&&
+			((pmlmepriv->fw_state & WIFI_ADHOC_STATE) || (pmlmepriv->fw_state & WIFI_ADHOC_MASTER_STATE)) )
+		{
+			bStopBlinking = _TRUE;
+		}
+		else if(pLed->BlinkTimes == 0)
+		{
+			bStopBlinking = _TRUE;
+		}
+		break;
+
+	case LED_BLINK_WPS:
+		if( pLed->BlinkTimes == 0 )
+		{
+			bStopBlinking = _TRUE;
+		}
+		break;
+
+
+	default:
+		bStopBlinking = _TRUE;
+		break;
+			
+	}
+	
+	if(bStopBlinking)
+	{
+		//if( padapter->pwrctrlpriv.cpwm >= PS_STATE_S2)
+		if(0)
+		{
+			SwLedOff(padapter, pLed);
+		}
+		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) && (pLed->bLedOn == _FALSE))
+		{
+			SwLedOn(padapter, pLed);
+		}
+		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) &&  pLed->bLedOn == _TRUE)
+		{
+			SwLedOff(padapter, pLed);
+		}
+
+		pLed->BlinkTimes = 0;
+		pLed->bLedBlinkInProgress = _FALSE;
+	}
+	else
+	{
+		// Assign LED state to toggle.
+		if( pLed->BlinkingLedState == LED_ON ) 
+			pLed->BlinkingLedState = LED_OFF;
+		else 
+			pLed->BlinkingLedState = LED_ON;
+
+		// Schedule a timer to toggle LED state. 
+		switch( pLed->CurrLedState )
+		{
+		case LED_BLINK_NORMAL:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			break;
+		
+		case LED_BLINK_SLOWLY:
+		case LED_BLINK_StartToBlink:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			break;
+
+		case LED_BLINK_WPS:
+			{
+				if( pLed->BlinkingLedState == LED_ON )
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				else
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+			}
+			break;
+
+		default:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			break;
+		}
+	}
+}
+
+
+static void
+SwLedBlink1(
+	PLED_871x			pLed
+	)
+{
+	_adapter				*padapter = pLed->padapter;
+	struct led_priv		*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	struct eeprom_priv	*peeprompriv = &(padapter->eeprompriv);
+	PLED_871x 			pLed1 = &(ledpriv->SwLed1);	
+	u8 				bStopBlinking = _FALSE;
+
+	if(peeprompriv->EEPROMCustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);	
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+
+	if(peeprompriv->EEPROMCustomerID == RT_CID_DEFAULT)
+	{
+		if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+		{
+			if(!pLed1->bSWLedCtrl)
+			{
+				SwLedOn(padapter, pLed1); 	
+				pLed1->bSWLedCtrl = _TRUE;
+			}
+			else if(!pLed1->bLedOn)	
+				SwLedOn(padapter, pLed1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pLed1\n"));
+		}
+		else 
+		{
+			if(!pLed1->bSWLedCtrl)
+			{
+				SwLedOff(padapter, pLed1);
+				pLed1->bSWLedCtrl = _TRUE;
+			}
+			else if(pLed1->bLedOn)
+				SwLedOff(padapter, pLed1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));		
+		}
+	}
+
+	switch(pLed->CurrLedState)
+	{
+		case LED_BLINK_SLOWLY:			
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_NORMAL:
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			break;
+			
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF;
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF;
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->BlinkTimes = 0;
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_WPS_STOP:	//WPS success
+			if(pLed->BlinkingLedState == LED_ON)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				bStopBlinking = _FALSE;
+			}
+			else
+			{
+				bStopBlinking = _TRUE;				
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedWPSBlinkInProgress = _FALSE;	
+			}		
+			break;
+					
+		default:
+			break;
+	}
+
+}
+
+static void
+SwLedBlink2(
+	PLED_871x			pLed
+	)
+{
+	_adapter				*padapter = pLed->padapter;
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	u8 				bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	switch(pLed->CurrLedState)
+	{	
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
+					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 
+					SwLedOff(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
+					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 
+					SwLedOff(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+					
+		default:
+			break;
+	}
+
+}
+
+static void
+SwLedBlink3(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		if(pLed->CurrLedState != LED_BLINK_WPS_STOP)
+			SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}	
+
+	switch(pLed->CurrLedState)
+	{			
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON;				
+					if( !pLed->bLedOn )
+						SwLedOn(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF;									
+					if( pLed->bLedOn )
+						SwLedOff(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+				 	if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON;
+				
+					if( !pLed->bLedOn )
+						SwLedOn(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF;					
+				
+					if( pLed->bLedOn )
+						SwLedOff(padapter, pLed);
+
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_WPS_STOP:	//WPS success
+			if(pLed->BlinkingLedState == LED_ON)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				bStopBlinking = _FALSE;
+			}
+			else
+			{
+				bStopBlinking = _TRUE;				
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn )
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
+				}
+				pLed->bLedWPSBlinkInProgress = _FALSE;	
+			}		
+			break;
+			
+					
+		default:
+			break;
+	}
+
+}
+
+
+static void
+SwLedBlink4(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	PLED_871x 		pLed1 = &(ledpriv->SwLed1);	
+	u8				bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}	
+
+	if(!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
+	{
+		pLed1->BlinkingLedState = LED_OFF;
+		pLed1->CurrLedState = LED_OFF;
+		SwLedOff(padapter, pLed1);
+	}	
+
+	switch(pLed->CurrLedState)
+	{
+		case LED_BLINK_SLOWLY:			
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_StartToBlink:
+			if( pLed->bLedOn )
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;			
+			
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _FALSE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				}
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else 
+				{
+					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				}
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if( pLed->bLedOn )
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;
+
+		case LED_BLINK_WPS_STOP:	//WPS authentication fail
+			if( pLed->bLedOn )			
+				pLed->BlinkingLedState = LED_OFF; 			
+			else			
+				pLed->BlinkingLedState = LED_ON;
+
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			break;
+
+		case LED_BLINK_WPS_STOP_OVERLAP:	//WPS session overlap		
+			pLed->BlinkTimes--;
+			if(pLed->BlinkTimes == 0)
+			{
+				if(pLed->bLedOn)
+				{
+					pLed->BlinkTimes = 1;							
+				}
+				else
+				{
+					bStopBlinking = _TRUE;
+				}
+			}
+
+			if(bStopBlinking)
+			{				
+				pLed->BlinkTimes = 10;			
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			}
+			else
+			{
+				if( pLed->bLedOn )			
+					pLed->BlinkingLedState = LED_OFF;			
+				else			
+					pLed->BlinkingLedState = LED_ON;
+
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;
+
+					
+		default:
+			break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink4 CurrLedState %d\n", pLed->CurrLedState));
+
+
+}
+
+static void
+SwLedBlink5(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	switch(pLed->CurrLedState)
+	{
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 									
+					if(pLed->bLedOn)				
+						SwLedOff(padapter, pLed);
+				}
+				else 
+				{		pLed->CurrLedState = LED_ON;
+						pLed->BlinkingLedState = LED_ON;					
+						if(!pLed->bLedOn)
+							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+	
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if( pLed->BlinkTimes == 0 )
+			{
+				bStopBlinking = _TRUE;
+			}
+			
+			if(bStopBlinking)
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					pLed->CurrLedState = LED_OFF;
+					pLed->BlinkingLedState = LED_OFF; 									
+					if(pLed->bLedOn)
+						SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					pLed->CurrLedState = LED_ON;
+					pLed->BlinkingLedState = LED_ON; 					
+					if(!pLed->bLedOn)
+						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+
+				pLed->bLedBlinkInProgress = _FALSE;	
+			}
+			else
+			{
+				//if( priv->rtllib->eRFPowerState != eRfOn && priv->rtllib->RfOffReason > RF_CHANGE_BY_PS)
+				if(0)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if( pLed->bLedOn )
+						pLed->BlinkingLedState = LED_OFF; 
+					else
+						pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+					
+		default:
+			break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink5 CurrLedState %d\n", pLed->CurrLedState));
+
+
+}
+
+static void
+SwLedBlink6(
+	PLED_871x			pLed
+	)
+{
+	_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 			bStopBlinking = _FALSE;
+
+	// Change LED according to BlinkingLedState specified.
+	if( pLed->BlinkingLedState == LED_ON ) 
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else 
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}	
+
+}
+
+
+//
+//	Description:
+//		Callback function of LED BlinkTimer, 
+//		it just schedules to corresponding BlinkWorkItem.
+//
+void
+BlinkTimerCallback(
+	unsigned long data
+	)
+{
+	PLED_871x	 pLed = (PLED_871x)data;
+	_adapter		*padapter = pLed->padapter;
+
+	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+       {
+             return;
+       }
+
+	_set_workitem(&(pLed->BlinkWorkItem));
+}
+
+
+//
+//	Description:
+//		Callback function of LED BlinkWorkItem.
+//		We dispatch acture LED blink action according to LedStrategy.
+//
+void BlinkWorkItemCallback(struct work_struct *work)
+{
+	PLED_871x	 pLed = container_of(work, LED_871x, BlinkWorkItem);
+	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
+	_adapter		*padapter = pLed->padapter;
+
+	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+       {
+             return;
+       }
+
+	switch(ledpriv->LedStrategy)
+	{
+		case SW_LED_MODE0:
+			SwLedBlink(pLed);
+			break;
+		
+		case SW_LED_MODE1:
+			SwLedBlink1(pLed);
+			break;
+		
+		case SW_LED_MODE2:
+			SwLedBlink2(pLed);
+			break;
+			
+		case SW_LED_MODE3:
+			SwLedBlink3(pLed);
+			break;
+
+		case SW_LED_MODE4:
+			SwLedBlink4(pLed);
+			break;			
+
+		case SW_LED_MODE5:
+			SwLedBlink5(pLed);
+			break;
+
+		case SW_LED_MODE6:
+			SwLedBlink6(pLed);
+			break;
+
+		default:
+			SwLedBlink(pLed);
+			break;
+	}
+}
+
+
+
+//================================================================================
+// Default LED behavior.
+//================================================================================
+
+//
+//	Description:	
+//		Implement each led action for SW_LED_MODE0.
+//		This is default strategy.
+//
+static void
+SwLedControlMode0(
+	_adapter		*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	PLED_871x	pLed = &(ledpriv->SwLed1);
+
+	// Decide led state
+	switch(LedAction)
+	{
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			pLed->bLedBlinkInProgress = _TRUE;
+
+			pLed->CurrLedState = LED_BLINK_NORMAL;
+			pLed->BlinkTimes = 2;
+
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			//mod_timer(&(pLed->BlinkTimer),  jiffies + MSECS(LED_BLINK_NORMAL_INTERVAL));
+		}
+		break;
+
+	case LED_CTL_START_TO_LINK:
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			pLed->bLedBlinkInProgress = _TRUE;
+
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+			pLed->BlinkTimes = 24;
+
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			//mod_timer(&(pLed->BlinkTimer), jiffies + MSECS(LED_BLINK_SLOWLY_INTERVAL));
+		}
+		else
+		{
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+		}	
+		break;
+		
+	case LED_CTL_LINK:
+		pLed->CurrLedState = LED_ON;
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			SwLedOn(padapter, pLed);
+		}
+		break;
+
+	case LED_CTL_NO_LINK:
+		pLed->CurrLedState = LED_OFF;
+		if( pLed->bLedBlinkInProgress == _FALSE )
+		{
+			SwLedOff(padapter, pLed);
+		}
+		break;
+	
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		if(pLed->bLedBlinkInProgress)
+		{
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = _FALSE;
+		}
+		SwLedOff(padapter, pLed);
+		break;
+
+	case LED_CTL_START_WPS:
+		if( pLed->bLedBlinkInProgress == _FALSE || pLed->CurrLedState == LED_ON)
+		{
+			pLed->bLedBlinkInProgress = _TRUE;
+
+			pLed->CurrLedState = LED_BLINK_WPS;
+			pLed->BlinkTimes = 20;
+
+			if( pLed->bLedOn )
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				//mod_timer(&(pLed->BlinkTimer), jiffies + MSECS(LED_BLINK_LONG_INTERVAL));
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				//mod_timer(&(pLed->BlinkTimer), jiffies + MSECS(LED_BLINK_LONG_INTERVAL));
+			}
+		}
+		break;
+
+	case LED_CTL_STOP_WPS:
+		if(pLed->bLedBlinkInProgress)
+		{
+			pLed->CurrLedState = LED_OFF;
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = _FALSE;
+		}
+		break;
+		
+
+	default:
+		break;
+	}
+	
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+	
+}
+
+ //ALPHA, added by chiyoko, 20090106
+static void
+SwLedControlMode1(
+	_adapter		*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv		*ledpriv = &(padapter->ledpriv);
+	PLED_871x			pLed = &(ledpriv->SwLed0);
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	struct sitesurvey_ctrl	*psitesurveyctrl = &(pmlmepriv->sitesurveyctrl);
+
+	if(padapter->eeprompriv.EEPROMCustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_POWER_ON:
+		case LED_CTL_START_TO_LINK:	
+		case LED_CTL_NO_LINK:
+			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedLinkBlinkInProgress = _FALSE;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{	
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+				
+				pLed->bLedNoLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			break;		
+
+		case LED_CTL_LINK:
+			if( pLed->bLedLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{	
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+				pLed->bLedLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_NORMAL;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_SITE_SURVEY:
+			 if((psitesurveyctrl->traffic_busy) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+			 	;		 
+			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			 {
+			 	if(IS_LED_WPS_BLINKING(pLed))
+					return;
+				
+	  			if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					 pLed->bLedLinkBlinkInProgress = _FALSE;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+                            if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+                            {
+                                return; //FIXLZM
+                            }
+                            if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+                            {
+                                _cancel_timer_ex(&(pLed->BlinkTimer));
+                                pLed->bLedNoLinkBlinkInProgress = _FALSE;
+                            }
+                            if( pLed->bLedLinkBlinkInProgress == _TRUE )
+                            {
+                                _cancel_timer_ex(&(pLed->BlinkTimer));
+                                pLed->bLedLinkBlinkInProgress = _FALSE;
+                            }
+                            pLed->bLedBlinkInProgress = _TRUE;
+                            pLed->CurrLedState = LED_TXRX_BLINK;
+                            pLed->BlinkTimes = 2;
+                            if( pLed->bLedOn )
+                                pLed->BlinkingLedState = LED_OFF; 
+                            else
+                                pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:
+			 if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			 {
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					 pLed->bLedLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+
+		
+		case LED_CTL_STOP_WPS:
+			if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedLinkBlinkInProgress == _TRUE )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				 pLed->bLedLinkBlinkInProgress = _FALSE;
+			}
+			if(pLed->bLedBlinkInProgress ==_TRUE)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if(pLed->bLedScanBlinkInProgress ==_TRUE)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+			}
+			else
+			{
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+			}
+			
+			pLed->CurrLedState = LED_BLINK_WPS_STOP;
+			if(pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}					
+			break;		
+
+		case LED_CTL_STOP_WPS_FAIL:			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
+
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;				
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF; 
+			if( pLed->bLedNoLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}						
+			SwLedOff(padapter, pLed);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+ //Arcadyan/Sitecom , added by chiyoko, 20090216
+static void
+SwLedControlMode2(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	 *ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x 		pLed = &(ledpriv->SwLed0);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_SITE_SURVEY:
+			 if(pmlmepriv->sitesurveyctrl.traffic_busy)
+			 	;		 
+			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			 {
+			 	if(IS_LED_WPS_BLINKING(pLed))
+					return;
+			 
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_LINK:
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;			
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:		
+			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			{
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			 }			
+			break;
+			
+		case LED_CTL_STOP_WPS:
+			pLed->bLedWPSBlinkInProgress = _FALSE;			
+			//if( priv->rtllib->eRFPowerState != eRfOn )
+			if(0)
+			{
+				SwLedOff(padapter, pLed);
+			}
+			else
+			{
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+			}
+			break;
+			
+		case LED_CTL_STOP_WPS_FAIL:			
+			pLed->bLedWPSBlinkInProgress = _FALSE;			
+			//if( priv->rtllib->eRFPowerState != eRfOn )
+			if(0)
+			{
+				SwLedOff(padapter, pLed);
+			}
+			else 
+			{
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState)); 				
+			}	
+			break;				
+
+		case LED_CTL_START_TO_LINK: 
+		case LED_CTL_NO_LINK:
+			if(!IS_LED_BLINKING(pLed))
+			{
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+			break;
+			
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+}
+
+  //COREGA, added by chiyoko, 20090316
+static void
+ SwLedControlMode3(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x		pLed = &(ledpriv->SwLed0);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_SITE_SURVEY:
+			if(pmlmepriv->sitesurveyctrl.traffic_busy)
+				;		 
+			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			{
+				if(IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_LINK:
+			if(IS_LED_WPS_BLINKING(pLed))
+				return;
+			
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;			
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:		
+			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			{
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}			
+			break;
+			
+		case LED_CTL_STOP_WPS:			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}						
+			else
+			{
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+			}
+				
+			pLed->CurrLedState = LED_BLINK_WPS_STOP;
+			if(pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			}
+			else
+			{
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}					
+
+			break;
+			
+		case LED_CTL_STOP_WPS_FAIL:			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
+
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;				
+
+		case LED_CTL_START_TO_LINK: 
+		case LED_CTL_NO_LINK:
+			if(!IS_LED_BLINKING(pLed))
+			{
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+			break;
+			
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}			
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+}
+
+
+ //Edimax-Belkin, added by chiyoko, 20090413
+static void
+SwLedControlMode4(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x		pLed = &(ledpriv->SwLed0);
+	PLED_871x		pLed1 = &(ledpriv->SwLed1);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_START_TO_LINK:	
+			if(pLed1->bLedWPSBlinkInProgress)
+			{
+				pLed1->bLedWPSBlinkInProgress = _FALSE;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+		
+				pLed1->BlinkingLedState = LED_OFF;
+				pLed1->CurrLedState = LED_OFF;
+
+				if(pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+				
+			if( pLed->bLedStartToLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+	 			if(pLed->bLedNoLinkBlinkInProgress ==_TRUE)
+				{	
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+	 			}				
+				
+				pLed->bLedStartToLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_StartToBlink;
+				if( pLed->bLedOn )
+				{
+					pLed->BlinkingLedState = LED_OFF;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				}
+				else
+				{
+					pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				}
+			}
+			break;		
+
+		case LED_CTL_LINK:			
+		case LED_CTL_NO_LINK:
+			//LED1 settings
+			if(LedAction == LED_CTL_LINK)
+			{
+				if(pLed1->bLedWPSBlinkInProgress)
+				{
+					pLed1->bLedWPSBlinkInProgress = _FALSE;
+					_cancel_timer_ex(&(pLed1->BlinkTimer));
+			
+					pLed1->BlinkingLedState = LED_OFF;
+					pLed1->CurrLedState = LED_OFF;
+
+					if(pLed1->bLedOn)
+						_set_timer(&(pLed->BlinkTimer), 0);
+				}				
+			}
+			
+			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
+			{
+				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+	 			}
+				
+				pLed->bLedNoLinkBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			break;		
+
+		case LED_CTL_SITE_SURVEY:
+			if((pmlmepriv->sitesurveyctrl.traffic_busy) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+				;		 
+			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			{
+				if(IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+	  		  	if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS_BOTTON:
+			if(pLed1->bLedWPSBlinkInProgress)
+			{
+				pLed1->bLedWPSBlinkInProgress = _FALSE;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			
+				pLed1->BlinkingLedState = LED_OFF;
+				pLed1->CurrLedState = LED_OFF;
+
+				if(pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+				
+			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			{
+				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = _FALSE;
+				}				
+				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if( pLed->bLedOn )
+				{
+					pLed->BlinkingLedState = LED_OFF;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				}
+				else
+				{
+					pLed->BlinkingLedState = LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				}
+			}
+			break;
+		
+		case LED_CTL_STOP_WPS:	//WPS connect success		
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;								
+			}
+
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			break;		
+
+		case LED_CTL_STOP_WPS_FAIL:		//WPS authentication fail			
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
+
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			//LED1 settings
+			if(pLed1->bLedWPSBlinkInProgress)
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			else	
+				pLed1->bLedWPSBlinkInProgress = _TRUE;				
+
+			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
+			if( pLed1->bLedOn )
+				pLed1->BlinkingLedState = LED_OFF; 
+			else
+				pLed1->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+
+			break;				
+
+		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	//WPS session overlap		
+			if(pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;								
+			}
+			
+			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if( pLed->bLedOn )
+				pLed->BlinkingLedState = LED_OFF; 
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			//LED1 settings
+			if(pLed1->bLedWPSBlinkInProgress)
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			else	
+				pLed1->bLedWPSBlinkInProgress = _TRUE;				
+
+			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
+			pLed1->BlinkTimes = 10;
+			if( pLed1->bLedOn )
+				pLed1->BlinkingLedState = LED_OFF; 
+			else
+				pLed1->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			
+			break;
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF; 
+			
+			if( pLed->bLedNoLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = _FALSE;
+			}
+			if( pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = _FALSE;
+			}	
+			if( pLed->bLedStartToLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedStartToLinkBlinkInProgress = _FALSE;
+			}			
+
+			if( pLed1->bLedWPSBlinkInProgress )
+			{
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+				pLed1->bLedWPSBlinkInProgress = _FALSE;
+			}
+
+			pLed1->BlinkingLedState = LED_UNKNOWN;				
+			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pLed1);			
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+
+
+ //Sercomm-Belkin, added by chiyoko, 20090415
+static void
+SwLedControlMode5(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x		pLed = &(ledpriv->SwLed0);
+
+	if(padapter->eeprompriv.EEPROMCustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	
+	switch(LedAction)
+	{		
+		case LED_CTL_POWER_ON:
+		case LED_CTL_NO_LINK:
+		case LED_CTL_LINK: 	//solid blue
+/*
+			if(pLed->CurrLedState == LED_SCAN_BLINK)
+			{
+				return;
+			}	
+			pLed->bLedBlinkInProgress = _FALSE;
+*/
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON; 
+		
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		case LED_CTL_SITE_SURVEY:
+			if((pmlmepriv->sitesurveyctrl.traffic_busy) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+				;		 
+			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			{				
+				if(pLed->bLedBlinkInProgress ==_TRUE)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = _FALSE;
+				}
+				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+		
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK)
+				{
+					return;
+				}			
+				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if( pLed->bLedOn )
+					pLed->BlinkingLedState = LED_OFF; 
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;				
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF; 
+
+			if( pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = _FALSE;
+			}			
+				
+			SwLedOff(padapter, pLed);
+			break;
+			
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+ //WNC-Corega, added by chiyoko, 20090902
+static void
+SwLedControlMode6(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	PLED_871x pLed0 = &(ledpriv->SwLed0);
+	
+	switch(LedAction)
+	{
+		case LED_CTL_POWER_ON:
+		case LED_CTL_LINK:
+		case LED_CTL_NO_LINK:						
+			_cancel_timer_ex(&(pLed0->BlinkTimer));
+			pLed0->CurrLedState = LED_ON;
+			pLed0->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed0->BlinkTimer), 0);			
+			break;
+
+		case LED_CTL_POWER_OFF:
+			SwLedOff(padapter, pLed0);
+			break;
+
+		default:
+			break;
+	}
+		
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("ledcontrol 6 Led %d\n", pLed->CurrLedState));
+}
+
+
+//
+//	Description:	
+//		Dispatch LED action according to pHalData->LedStrategy. 
+//
+void
+rtw_LedControl871x(
+	_adapter				*padapter,
+	LED_CTL_MODE		LedAction
+	)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+       if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
+       {
+             return;
+       }
+
+	if(padapter->hw_init_completed == _FALSE)	return; 
+	
+	if( ledpriv->bRegUseLed == _FALSE)
+		return;
+
+	//if (!priv->up)
+	//	return;
+
+	//if(priv->bInHctTest)
+	//	return;
+	
+	/*if(	priv->rtllib->eRFPowerState != eRfOn && 
+		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX || 
+		 LedAction == LED_CTL_SITE_SURVEY || 
+		 LedAction == LED_CTL_LINK || 
+		 LedAction == LED_CTL_NO_LINK ||
+		 LedAction == LED_CTL_POWER_ON) )*/
+	if(0)
+	{
+		return;
+	}
+	
+	switch(ledpriv->LedStrategy)
+	{
+		case SW_LED_MODE0:
+			//SwLedControlMode0(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE1:
+			SwLedControlMode1(padapter, LedAction);
+			break;
+		case SW_LED_MODE2:
+			SwLedControlMode2(padapter, LedAction);
+                	break;
+
+		case SW_LED_MODE3:
+			SwLedControlMode3(padapter, LedAction);
+			break;	
+
+		case SW_LED_MODE4:
+			SwLedControlMode4(padapter, LedAction);
+			break;			
+
+		case SW_LED_MODE5:
+			SwLedControlMode5(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE6:
+			SwLedControlMode6(padapter, LedAction);
+			break;
+
+		default:
+			break;
+	}
+	
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("LedStrategy:%d, LedAction %d\n", ledpriv->LedStrategy,LedAction));
+}
+
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_cmd.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_cmd.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_cmd.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_cmd.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1952 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_CMD_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <cmd_osdep.h>
+#include <mlme_osdep.h>
+#include <rtw_byteorder.h>
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/smp_lock.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/rtnetlink.h>
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#include <wlan_bssdef.h>
+#endif
+
+
+/*
+Caller and the rtw_cmd_thread can protect cmd_q by spin_lock.
+No irqsave is necessary.
+*/
+
+sint	_rtw_init_cmd_priv (struct	cmd_priv *pcmdpriv)
+{
+	sint res=_SUCCESS;
+	
+_func_enter_;	
+
+	_rtw_init_sema(&(pcmdpriv->cmd_queue_sema), 0);
+	//_rtw_init_sema(&(pcmdpriv->cmd_done_sema), 0);
+	_rtw_init_sema(&(pcmdpriv->terminate_cmdthread_sema), 0);
+	
+	
+	_rtw_init_queue(&(pcmdpriv->cmd_queue));
+	
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+	
+	pcmdpriv->cmd_seq = 1;
+	
+	pcmdpriv->cmd_allocated_buf = _rtw_zmalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+	
+	if (pcmdpriv->cmd_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ( (SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
+		
+	pcmdpriv->rsp_allocated_buf = _rtw_zmalloc(MAX_RSPSZ + 4);
+	
+	if (pcmdpriv->rsp_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	
+	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 - ( (SIZE_PTR)(pcmdpriv->rsp_allocated_buf) & 3);
+
+	pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_done_cnt = pcmdpriv->rsp_cnt = 0;
+
+exit:
+	
+_func_exit_;	  
+
+	return res;
+	
+}	
+
+
+sint _rtw_init_evt_priv(struct evt_priv *pevtpriv)
+{
+	sint res=_SUCCESS;
+
+_func_enter_;	
+
+#ifdef CONFIG_H2CLBK
+	_rtw_init_sema(&(pevtpriv->lbkevt_done), 0);
+	pevtpriv->lbkevt_limit = 0;
+	pevtpriv->lbkevt_num = 0;
+	pevtpriv->cmdevt_parm = NULL;		
+#endif		
+	
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+	pevtpriv->event_seq = 0;
+	pevtpriv->evt_done_cnt = 0;
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+
+	_rtw_init_sema(&(pevtpriv->evt_notify), 0);
+	_rtw_init_sema(&(pevtpriv->terminate_evtthread_sema), 0);
+
+	pevtpriv->evt_allocated_buf = _rtw_zmalloc(MAX_EVTSZ + 4);	
+	if (pevtpriv->evt_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 - ((unsigned int)(pevtpriv->evt_allocated_buf) & 3);
+	
+		
+#ifdef CONFIG_SDIO_HCI
+	pevtpriv->allocated_c2h_mem = _rtw_zmalloc(C2H_MEM_SZ +4); 
+	
+	if (pevtpriv->allocated_c2h_mem == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pevtpriv->c2h_mem = pevtpriv->allocated_c2h_mem +  4\
+	- ( (u32)(pevtpriv->allocated_c2h_mem) & 3);
+#ifdef PLATFORM_OS_XP
+	pevtpriv->pc2h_mdl= IoAllocateMdl((u8 *)pevtpriv->c2h_mem, C2H_MEM_SZ , FALSE, FALSE, NULL);
+	
+	if(pevtpriv->pc2h_mdl == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	MmBuildMdlForNonPagedPool(pevtpriv->pc2h_mdl);
+#endif
+#endif //end of CONFIG_SDIO_HCI
+
+	_rtw_init_queue(&(pevtpriv->evt_queue));
+
+exit:	
+
+#endif //end of CONFIG_EVENT_THREAD_MODE
+
+_func_exit_;		 
+
+	return res;
+}
+
+void _rtw_free_evt_priv (struct	evt_priv *pevtpriv)
+{
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("+_rtw_free_evt_priv \n"));
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	_rtw_free_sema(&(pevtpriv->evt_notify));
+	_rtw_free_sema(&(pevtpriv->terminate_evtthread_sema));
+
+
+	if (pevtpriv->evt_allocated_buf)
+		_rtw_mfree(pevtpriv->evt_allocated_buf, MAX_EVTSZ + 4);
+#endif
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("-_rtw_free_evt_priv \n"));
+
+_func_exit_;	  	
+
+}	
+void _rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
+{
+_func_enter_;
+
+	if(pcmdpriv){
+		_rtw_spinlock_free(&(pcmdpriv->cmd_queue.lock));
+		_rtw_free_sema(&(pcmdpriv->cmd_queue_sema));
+		//_rtw_free_sema(&(pcmdpriv->cmd_done_sema));
+		_rtw_free_sema(&(pcmdpriv->terminate_cmdthread_sema));
+
+		if (pcmdpriv->cmd_allocated_buf)
+			_rtw_mfree(pcmdpriv->cmd_allocated_buf, MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+		
+		if (pcmdpriv->rsp_allocated_buf)
+			_rtw_mfree(pcmdpriv->rsp_allocated_buf, MAX_RSPSZ + 4);
+	}
+_func_exit_;		
+}
+
+/*
+Calling Context:
+
+rtw_enqueue_cmd can only be called between kernel thread, 
+since only spin_lock is used.
+
+ISR/Call-Back functions can't call this sub-function.
+
+*/
+
+sint	_rtw_enqueue_cmd(_queue *queue, struct cmd_obj *obj)
+{
+_func_enter_;
+
+	if (obj == NULL)
+		goto exit;
+
+	_rtw_spinlock(&queue->lock);
+
+	rtw_list_insert_tail(&obj->list, &queue->queue);
+
+	_rtw_spinunlock(&queue->lock);
+	
+exit:	
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+struct	cmd_obj	*_rtw_dequeue_cmd(_queue *queue)
+{
+	struct cmd_obj *obj;
+
+_func_enter_;
+
+	_rtw_spinlock(&(queue->lock));
+
+	if (rtw_is_list_empty(&(queue->queue)))
+		obj = NULL;
+	else
+	{
+		obj = LIST_CONTAINOR(get_next(&(queue->queue)), struct cmd_obj, list);
+		list_delete(&obj->list);
+	}
+	_rtw_spinunlock(&(queue->lock));
+
+_func_exit_;	
+
+	return obj;
+}
+
+sint	_enqueue_cmd_ex(_queue *queue, struct cmd_obj *obj)
+{
+	_irqL irqL;
+	
+_func_enter_;
+
+	if (obj == NULL)
+		goto exit;
+
+	//_rtw_spinlock(&queue->lock);
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	rtw_list_insert_tail(&obj->list, &queue->queue);
+
+	_exit_critical_bh(&queue->lock, &irqL);
+	//_rtw_spinunlock(&queue->lock);
+	
+exit:	
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+struct	cmd_obj	*_dequeue_cmd_ex(_queue *queue)
+{
+	_irqL irqL;
+	struct cmd_obj *obj;
+
+_func_enter_;
+
+	//_rtw_spinlock(&(queue->lock));
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	if (rtw_is_list_empty(&(queue->queue)))
+		obj = NULL;
+	else
+	{
+		obj = LIST_CONTAINOR(get_next(&(queue->queue)), struct cmd_obj, list);
+		list_delete(&obj->list);
+	}
+
+	_exit_critical_bh(&queue->lock, &irqL);
+	//_rtw_spinunlock(&(queue->lock));
+
+_func_exit_;	
+
+	return obj;
+}
+
+u32	rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	u32	res;
+_func_enter_;	
+	res = _rtw_init_cmd_priv (pcmdpriv);
+_func_exit_;	
+	return res;	
+}
+
+u32	rtw_init_evt_priv (struct	evt_priv *pevtpriv)
+{
+	int	res;
+_func_enter_;		
+	res = _rtw_init_evt_priv(pevtpriv);
+_func_exit_;		
+	return res;
+}
+
+void rtw_free_evt_priv (struct	evt_priv *pevtpriv)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("rtw_free_evt_priv\n"));
+	_rtw_free_evt_priv(pevtpriv);
+_func_exit_;		
+}	
+
+void rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("rtw_free_cmd_priv\n"));
+	_rtw_free_cmd_priv(pcmdpriv);
+_func_exit_;	
+}	
+
+u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	int	res;
+	
+_func_enter_;	
+
+	if (obj == NULL)
+		return _FAIL;
+
+	if(pcmdpriv->padapter->hw_init_completed==_FALSE)		
+	{
+		rtw_free_cmd_obj(obj);
+		return _FAIL;
+	}	
+		
+	res = _enqueue_cmd_ex(&pcmdpriv->cmd_queue, obj);
+
+	_rtw_up_sema(&pcmdpriv->cmd_queue_sema);
+	
+_func_exit_;	
+
+	return res;	
+}
+
+u32	rtw_enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	_irqL irqL;
+	_queue *queue;
+	u8 bSkip = _FALSE;
+_func_enter_;
+
+	if (obj == NULL)
+		goto exit;
+
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	if((pcmdpriv->padapter->pwrctrlpriv.bHWPwrPindetect)&&(!pcmdpriv->padapter->registrypriv.usbss_enable))
+	{
+		if(obj->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ) 
+		{
+			struct drvextra_cmd_parm	*pdrvextra_cmd_parm = (struct drvextra_cmd_parm	*)obj->parmbuf;	
+			if(pdrvextra_cmd_parm->ec_id == POWER_SAVING_CTRL_WK_CID)
+			{	
+				//printk("==>enqueue POWER_SAVING_CTRL_WK_CID\n");
+				bSkip = _TRUE;	
+			}
+		}
+	}
+#endif
+	if((pcmdpriv->padapter->hw_init_completed==_FALSE)	&& (bSkip == _FALSE))	
+	{	
+		rtw_free_cmd_obj(obj);
+		return _FAIL;
+	}	
+
+	queue = &pcmdpriv->cmd_queue;
+	
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	rtw_list_insert_tail(&obj->list, &queue->queue);
+
+	_exit_critical_bh(&queue->lock, &irqL);
+
+	_rtw_up_sema(&pcmdpriv->cmd_queue_sema);
+	
+exit:	
+	
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+struct	cmd_obj	*rtw_dequeue_cmd(_queue *queue)
+{
+	struct	cmd_obj	*pcmd;
+_func_enter_;		
+	pcmd = _dequeue_cmd_ex(queue);
+_func_exit_;			
+	return pcmd;
+}
+
+void rtw_cmd_clr_isr(struct	cmd_priv *pcmdpriv)
+{
+_func_enter_;
+	pcmdpriv->cmd_done_cnt++;
+	//_rtw_up_sema(&(pcmdpriv->cmd_done_sema));
+_func_exit_;		
+}
+void rtw_free_cmd_obj(struct cmd_obj *pcmd)
+{
+_func_enter_;
+
+	if((pcmd->cmdcode!=_JoinBss_CMD_) &&(pcmd->cmdcode!= _CreateBss_CMD_))
+	{
+		//free parmbuf in cmd_obj
+		_rtw_mfree((unsigned char*)pcmd->parmbuf, pcmd->cmdsz);
+	}	
+	
+	if(pcmd->rsp!=NULL)
+	{
+		if(pcmd->rspsz!= 0)
+		{
+			//free rsp in cmd_obj
+			_rtw_mfree((unsigned char*)pcmd->rsp, pcmd->rspsz);
+		}	
+	}	
+
+	//free cmd_obj
+	_rtw_mfree((unsigned char*)pcmd, sizeof(struct cmd_obj));
+	
+_func_exit_;		
+}
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+u32 enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj)
+{
+	_irqL irqL;
+	int	res;
+	_queue *queue = &pevtpriv->evt_queue;
+	
+_func_enter_;	
+
+	res = _SUCCESS; 		
+
+	if (obj == NULL) {
+		res = _FAIL;
+		goto exit;
+	}	
+
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	rtw_list_insert_tail(&obj->list, &queue->queue);
+	
+	_exit_critical_bh(&queue->lock, &irqL);
+
+	//evt_notify_isr(pevtpriv);
+
+exit:
+	
+_func_exit_;		
+
+	return res;	
+}
+
+struct evt_obj *dequeue_evt(_queue *queue)
+{
+	_irqL irqL;
+	struct	evt_obj	*pevtobj;
+	
+_func_enter_;		
+
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	if (rtw_is_list_empty(&(queue->queue)))
+		pevtobj = NULL;
+	else
+	{
+		pevtobj = LIST_CONTAINOR(get_next(&(queue->queue)), struct evt_obj, list);
+		list_delete(&pevtobj->list);
+	}
+
+	_exit_critical_bh(&queue->lock, &irqL);
+	
+_func_exit_;			
+
+	return pevtobj;	
+}
+
+void free_evt_obj(struct evt_obj *pevtobj)
+{
+_func_enter_;
+
+	if(pevtobj->parmbuf)
+		_rtw_mfree((unsigned char*)pevtobj->parmbuf, pevtobj->evtsz);
+	
+	_rtw_mfree((unsigned char*)pevtobj, sizeof(struct evt_obj));
+	
+_func_exit_;		
+}
+
+void evt_notify_isr(struct evt_priv *pevtpriv)
+{
+_func_enter_;
+	pevtpriv->evt_done_cnt++;
+	_rtw_up_sema(&(pevtpriv->evt_notify));
+_func_exit_;	
+}
+#endif
+
+
+/*
+u8 rtw_setstandby_cmd(unsigned char  *adapter) 
+*/
+u8 rtw_setstandby_cmd(_adapter *padapter, uint action)
+{
+	struct cmd_obj*			ph2c;
+	struct usb_suspend_parm*	psetusbsuspend;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+
+	u8 ret = _SUCCESS;
+	
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		ret = _FAIL;
+		goto exit;
+		}
+	
+	psetusbsuspend = (struct usb_suspend_parm*)_rtw_zmalloc(sizeof(struct usb_suspend_parm)); 
+	if (psetusbsuspend == NULL) {
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		ret = _FAIL;
+		goto exit;
+	}
+
+	psetusbsuspend->action = action;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetusbsuspend, GEN_CMD_CODE(_SetUsbSuspend));
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+	
+exit:	
+	
+_func_exit_;		
+
+	return ret;
+}
+
+/*
+rtw_sitesurvey_cmd(~)
+	### NOTE:#### (!!!!)
+	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+*/
+u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *pssid)
+{
+	struct cmd_obj*		ph2c;
+	struct sitesurvey_parm*	psurveyPara;
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;	
+	
+#ifdef CONFIG_LPS
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE){
+		lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
+	}
+#endif
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+
+	psurveyPara = (struct sitesurvey_parm*)_rtw_zmalloc(sizeof(struct sitesurvey_parm)); 
+	if (psurveyPara == NULL) {
+		_rtw_mfree((unsigned char*) ph2c, sizeof(struct cmd_obj));
+		return _FAIL;
+	}
+
+	rtw_free_network_queue(padapter,_FALSE);
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("\nflush  network queue\n\n"));
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));
+
+	psurveyPara->bsslimit = cpu_to_le32(48);
+	psurveyPara->scan_mode = cpu_to_le32(pmlmepriv->scan_mode);
+	psurveyPara->ss_ssidlen= cpu_to_le32(0);// pssid->SsidLength;
+	_rtw_memset(psurveyPara->ss_ssid, 0, IW_ESSID_MAX_SIZE + 1);
+	if ((pssid != NULL) && (pssid->SsidLength)) {
+		_rtw_memcpy(psurveyPara->ss_ssid, pssid->Ssid, pssid->SsidLength);
+		psurveyPara->ss_ssidlen = cpu_to_le32(pssid->SsidLength);
+	}
+
+	set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+	_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_SITE_SURVEY);
+
+	pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+
+_func_exit_;		
+
+	return _SUCCESS;
+}
+
+u8 rtw_setdatarate_cmd(_adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj*			ph2c;
+	struct setdatarate_parm*	pbsetdataratepara;
+	struct cmd_priv*		pcmdpriv = &padapter->cmdpriv;
+	u8	res = _SUCCESS;
+
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pbsetdataratepara = (struct setdatarate_parm*)_rtw_zmalloc(sizeof(struct setdatarate_parm)); 
+	if (pbsetdataratepara == NULL) {
+		_rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara, GEN_CMD_CODE(_SetDataRate));
+#ifdef MP_FIRMWARE_OFFLOAD
+	pbsetdataratepara->curr_rateidx = *(u32*)rateset;
+//	_rtw_memcpy(pbsetdataratepara, rateset, sizeof(u32));
+#else
+	pbsetdataratepara->mac_id = 5;
+	_rtw_memcpy(pbsetdataratepara->datarates, rateset, NumRates);
+#endif
+	rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+u8 rtw_setbasicrate_cmd(_adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj*			ph2c;
+	struct setbasicrate_parm*	pssetbasicratepara;
+	struct cmd_priv*		pcmdpriv=&padapter->cmdpriv;
+	u8	res = _SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res= _FAIL;
+		goto exit;
+	}
+	pssetbasicratepara = (struct setbasicrate_parm*)_rtw_zmalloc(sizeof(struct setbasicrate_parm)); 
+
+	if (pssetbasicratepara == NULL) {
+		_rtw_mfree((u8*) ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara, _SetBasicRate_CMD_);
+
+	_rtw_memcpy(pssetbasicratepara->basicrates, rateset, NumRates);	   
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:	
+
+_func_exit_;		
+
+	return res;
+}
+
+
+/*
+unsigned char rtw_setphy_cmd(unsigned char  *adapter) 
+
+1.  be called only after rtw_update_registrypriv_dev_network( ~) or mp testing program
+2.  for AdHoc/Ap mode or mp mode?
+
+*/
+u8 rtw_setphy_cmd(_adapter *padapter, u8 modem, u8 ch)
+{
+	struct cmd_obj*			ph2c;
+	struct setphy_parm*		psetphypara;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+//	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+//	struct registry_priv*		pregistry_priv = &padapter->registrypriv;
+
+	u8	res=_SUCCESS;
+
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	psetphypara = (struct setphy_parm*)_rtw_zmalloc(sizeof(struct setphy_parm)); 
+
+	if(psetphypara==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetphypara, _SetPhy_CMD_);
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("CH=%d, modem=%d", ch, modem));
+
+	psetphypara->modem = modem;
+	psetphypara->rfchannel = ch;
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:	
+_func_exit_;		
+	return res;
+}
+
+//power tracking mechanism setting
+u8 rtw_setptm_cmd(_adapter*padapter, u8 type)
+{
+	struct cmd_obj*			ph2c;
+	struct writePTM_parm*		pwriteptmparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
+	u8	res=_SUCCESS;
+	
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwriteptmparm = (struct writePTM_parm*)_rtw_zmalloc(sizeof(struct writePTM_parm)); 
+
+	if(pwriteptmparm==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetPT));	
+
+	pwriteptmparm->type= type;	
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:
+	
+_func_exit_;	
+
+	return res;
+	
+}
+
+u8 rtw_setfwdig_cmd(_adapter*padapter, u8 type)
+{
+	
+	struct cmd_obj*			ph2c;
+	struct writePTM_parm*		pwriteptmparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
+	u8	res=_SUCCESS;
+	
+_func_enter_;
+	
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwriteptmparm = (struct writePTM_parm*)_rtw_zmalloc(sizeof(struct setdig_parm)); 
+
+	if(pwriteptmparm==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetDIG));	
+
+	pwriteptmparm->type= type;	
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:	
+	
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_setfwra_cmd(_adapter*padapter, u8 type)
+{
+	
+	struct cmd_obj*			ph2c;
+	struct writePTM_parm*		pwriteptmparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
+	u8	res=_SUCCESS;
+	
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwriteptmparm = (struct writePTM_parm*)_rtw_zmalloc(sizeof(struct setra_parm)); 
+
+	if(pwriteptmparm==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetRA));	
+
+	pwriteptmparm->type= type;	
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:	
+
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_setbbreg_cmd(_adapter*padapter, u8 offset, u8 val)
+{	
+	struct cmd_obj*			ph2c;
+	struct writeBB_parm*		pwritebbparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
+	u8	res=_SUCCESS;
+_func_enter_;
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pwritebbparm = (struct writeBB_parm*)_rtw_zmalloc(sizeof(struct writeBB_parm)); 
+
+	if(pwritebbparm==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwritebbparm, GEN_CMD_CODE(_SetBBReg));	
+
+	pwritebbparm->offset = offset;
+	pwritebbparm->value = val;
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:	
+_func_exit_;	
+	return res;
+}
+
+u8 rtw_getbbreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
+{	
+	struct cmd_obj*			ph2c;
+	struct readBB_parm*		prdbbparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+	
+_func_enter_;
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res=_FAIL;
+		goto exit;
+		}
+	prdbbparm = (struct readBB_parm*)_rtw_zmalloc(sizeof(struct readBB_parm)); 
+
+	if(prdbbparm ==NULL){
+		_rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		return _FAIL;
+	}
+
+	_rtw_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_GetBBReg);
+	ph2c->parmbuf = (unsigned char *)prdbbparm;
+	ph2c->cmdsz =  sizeof(struct readBB_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readBB_rsp);
+	
+	prdbbparm ->offset = offset;
+	
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:
+_func_exit_;	
+	return res;
+}
+
+u8 rtw_setrfreg_cmd(_adapter  *padapter, u8 offset, u32 val)
+{	
+	struct cmd_obj*			ph2c;
+	struct writeRF_parm*		pwriterfparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
+	u8	res=_SUCCESS;
+_func_enter_;
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;	
+		goto exit;
+		}
+	pwriterfparm = (struct writeRF_parm*)_rtw_zmalloc(sizeof(struct writeRF_parm)); 
+
+	if(pwriterfparm==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));	
+
+	pwriterfparm->offset = offset;
+	pwriterfparm->value = val;
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:
+_func_exit_;	
+	return res;
+}
+
+u8 rtw_getrfreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
+{	
+	struct cmd_obj*			ph2c;
+	struct readRF_parm*		prdrfparm;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+
+	prdrfparm = (struct readRF_parm*)_rtw_zmalloc(sizeof(struct readRF_parm)); 
+	if(prdrfparm ==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	_rtw_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_GetRFReg);
+	ph2c->parmbuf = (unsigned char *)prdrfparm;
+	ph2c->cmdsz =  sizeof(struct readRF_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readRF_rsp);
+	
+	prdrfparm ->offset = offset;
+	
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:
+
+_func_exit_;	
+
+	return res;
+}
+
+void rtw_getbbrfreg_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{       
+ _func_enter_;  
+		
+	//rtw_free_cmd_obj(pcmd);
+	_rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
+	_rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
+	
+#ifdef CONFIG_MP_INCLUDED	
+	padapter->mppriv.workparam.bcompleted= _TRUE;
+#endif	
+_func_exit_;		
+}
+
+void rtw_readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{
+ _func_enter_;  
+
+	_rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
+	_rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
+	
+#ifdef CONFIG_MP_INCLUDED	
+	padapter->mppriv.workparam.bcompleted= _TRUE;
+#endif
+
+_func_exit_;
+}
+
+u8 rtw_createbss_cmd(_adapter  *padapter)
+{
+	struct cmd_obj*			pcmd;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	WLAN_BSSID_EX		*pdev_network = &padapter->registrypriv.dev_network;
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0){
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for Any SSid:%s\n",pmlmepriv->assoc_ssid.Ssid));		
+	} else {
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+		
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(pcmd==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+
+	_rtw_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _CreateBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)pdev_network;
+	pcmd->cmdsz = get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX*)pdev_network);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;	
+	
+	pdev_network->Length = pcmd->cmdsz;	
+
+#ifdef CONFIG_RTL8712
+	//notes: translate IELength & Length after assign the Length to cmdsz;
+	pdev_network->Length = cpu_to_le32(pcmd->cmdsz);
+	pdev_network->IELength = cpu_to_le32(pdev_network->IELength);
+	pdev_network->Ssid.SsidLength = cpu_to_le32(pdev_network->Ssid.SsidLength);
+#endif
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd);	
+
+exit:
+
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int sz)
+{
+	struct cmd_obj*	pcmd;
+	struct cmd_priv 	*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+	
+_func_enter_;
+			
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(pcmd==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	_rtw_init_listhead(&pcmd->list);
+	pcmd->cmdcode = GEN_CMD_CODE(_CreateBss);
+	pcmd->parmbuf = pbss;
+	pcmd->cmdsz =  sz;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+	
+_func_exit_;	
+
+	return res;	
+}
+
+u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
+{
+	u8 *auth, res=_SUCCESS;
+	uint t_len=0;
+	WLAN_BSSID_EX		*psecnetwork;
+	struct cmd_obj*			pcmd;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv   			*pqospriv= &pmlmepriv->qospriv;
+	struct security_priv *psecuritypriv=&padapter->securitypriv;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->network.InfrastructureMode;
+
+_func_enter_;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0){
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+Join cmd: Any SSid\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+Join cmd: SSid=[%s]\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	//printk ("+Join cmd: SSid=[%s],opt_ant(%d,Ant_%s)\n", pmlmepriv->assoc_ssid.Ssid,pnetwork->network.PhyInfo.Optimum_antenna,
+		//(2==pnetwork->network.PhyInfo.Optimum_antenna)?"A":"B");
+	
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(pcmd==NULL){
+		res=_FAIL;
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
+		goto exit;
+	}
+	/* // for IEs is pointer 
+	t_len = sizeof (ULONG) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + 
+			sizeof (NDIS_802_11_SSID) + sizeof (ULONG) + 
+			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + 
+			sizeof (NDIS_802_11_CONFIGURATION) +	
+			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +   
+			sizeof (NDIS_802_11_RATES_EX)+ sizeof(WLAN_PHY_INFO)+ sizeof (ULONG) + MAX_IE_SZ;
+	*/
+	//for IEs is fix buf size
+	t_len = sizeof(WLAN_BSSID_EX);
+			
+		
+	//for hidden ap to set fw_state here
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != _TRUE)
+	{
+		switch(ndis_network_mode)
+		{
+			case Ndis802_11IBSS:
+				pmlmepriv->fw_state |=WIFI_ADHOC_STATE;
+				break;
+				
+			case Ndis802_11Infrastructure:
+				pmlmepriv->fw_state |= WIFI_STATION_STATE;
+				break;
+				
+			case Ndis802_11APMode:	
+			case Ndis802_11AutoUnknown:
+			case Ndis802_11InfrastructureMax:
+				break;
+                        				
+		}
+	}	
+
+	psecnetwork=(WLAN_BSSID_EX *)&psecuritypriv->sec_bss;
+	if(psecnetwork==NULL)
+	{
+		if(pcmd !=NULL)
+			_rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
+		
+		res=_FAIL;
+		
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd :psecnetwork==NULL!!!\n"));
+		
+		goto exit;
+	}
+
+	_rtw_memset(psecnetwork, 0, t_len);
+	_rtw_memcpy(psecnetwork, &pnetwork->network, get_WLAN_BSSID_EX_sz(&pnetwork->network));
+	
+	auth=&psecuritypriv->authenticator_ie[0];
+	psecuritypriv->authenticator_ie[0]=(unsigned char)psecnetwork->IELength;
+
+	if((psecnetwork->IELength-12) < (256-1)) {
+                _rtw_memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], psecnetwork->IELength-12);
+	} else {
+		_rtw_memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));
+	}
+	  
+	psecnetwork->IELength = 0;
+        // Added by Albert 2009/02/18
+        // If the the driver wants to use the bssid to create the connection.
+        // If not,  we have to copy the connecting AP's MAC address to it so that
+        // the driver just has the bssid information for PMKIDList searching.
+        
+        if ( pmlmepriv->assoc_by_bssid == _FALSE )
+        {
+            _rtw_memcpy( &pmlmepriv->assoc_bssid[ 0 ], &pnetwork->network.MacAddress[ 0 ], ETH_ALEN );
+        }
+
+	psecnetwork->IELength = rtw_restruct_sec_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);
+
+
+	pqospriv->qos_option = 0;
+	
+	if(pregistrypriv->wmm_enable)	
+	{	
+		u32 tmp_len;
+		
+		tmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);	
+
+		if (psecnetwork->IELength != tmp_len)		
+		{
+			psecnetwork->IELength = tmp_len;
+			pqospriv->qos_option = 1; //There is WMM IE in this corresp. beacon
+		}
+		else 
+		{
+			pqospriv->qos_option = 0;//There is no WMM IE in this corresp. beacon
+		}		
+	}	
+
+#ifdef CONFIG_80211N_HT
+	phtpriv->ht_option = 0;
+	if(pregistrypriv->ht_enable)
+	{
+		//	Added by Albert 2010/06/23
+		//	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue.
+		//	Especially for Realtek 8192u SoftAP.
+		if (	( padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_ ) &&
+			( padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_ ) &&
+			( padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_ ))
+		{
+			//rtw_restructure_ht_ie
+			rtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], 
+									pnetwork->network.IELength, &psecnetwork->IELength);			
+		}
+	}
+
+#endif
+		
+	psecuritypriv->supplicant_ie[0]=(u8)psecnetwork->IELength;
+
+	if(psecnetwork->IELength < (256-1))
+	{
+		_rtw_memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], psecnetwork->IELength);
+	}
+	else
+	{
+		_rtw_memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], (256-1));
+	}
+	
+	pcmd->cmdsz = get_WLAN_BSSID_EX_sz(psecnetwork);//get cmdsz before endian conversion
+
+#ifdef CONFIG_RTL8712
+	//wlan_network endian conversion	
+	psecnetwork->Length = cpu_to_le32(psecnetwork->Length);
+	psecnetwork->Ssid.SsidLength= cpu_to_le32(psecnetwork->Ssid.SsidLength);
+	psecnetwork->Privacy = cpu_to_le32(psecnetwork->Privacy);
+	psecnetwork->Rssi = cpu_to_le32(psecnetwork->Rssi);
+	psecnetwork->NetworkTypeInUse = cpu_to_le32(psecnetwork->NetworkTypeInUse);
+	psecnetwork->Configuration.ATIMWindow = cpu_to_le32(psecnetwork->Configuration.ATIMWindow);
+	psecnetwork->Configuration.BeaconPeriod = cpu_to_le32(psecnetwork->Configuration.BeaconPeriod);
+	psecnetwork->Configuration.DSConfig = cpu_to_le32(psecnetwork->Configuration.DSConfig);
+	psecnetwork->Configuration.FHConfig.DwellTime=cpu_to_le32(psecnetwork->Configuration.FHConfig.DwellTime);
+	psecnetwork->Configuration.FHConfig.HopPattern=cpu_to_le32(psecnetwork->Configuration.FHConfig.HopPattern);
+	psecnetwork->Configuration.FHConfig.HopSet=cpu_to_le32(psecnetwork->Configuration.FHConfig.HopSet);
+	psecnetwork->Configuration.FHConfig.Length=cpu_to_le32(psecnetwork->Configuration.FHConfig.Length);	
+	psecnetwork->Configuration.Length = cpu_to_le32(psecnetwork->Configuration.Length);
+	psecnetwork->InfrastructureMode = cpu_to_le32(psecnetwork->InfrastructureMode);
+	psecnetwork->IELength = cpu_to_le32(psecnetwork->IELength);      
+#endif
+
+	_rtw_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _JoinBss_CMD_;//GEN_CMD_CODE(_JoinBss)
+	pcmd->parmbuf = (unsigned char *)psecnetwork;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+	
+_func_exit_;
+
+	return res;
+}
+
+u8 rtw_disassoc_cmd(_adapter*padapter) // for sta_mode
+{
+	struct	cmd_obj*	pdisconnect_cmd;
+	struct	disconnect_parm* pdisconnect;
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct	cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_disassoc_cmd\n"));
+	
+	//if ((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE) {
+
+		pdisconnect_cmd = (struct	cmd_obj*)_rtw_zmalloc(sizeof(struct	cmd_obj));
+		if(pdisconnect_cmd == NULL){
+			res=_FAIL;
+			goto exit;
+			}
+
+		pdisconnect = (struct	disconnect_parm*)_rtw_zmalloc(sizeof(struct	disconnect_parm));
+		if(pdisconnect == NULL) {
+			_rtw_mfree((u8 *)pdisconnect_cmd, sizeof(struct cmd_obj));
+			res= _FAIL;
+			goto exit;
+		}
+		
+		init_h2fwcmd_w_parm_no_rsp(pdisconnect_cmd, pdisconnect, _DisConnect_CMD_);
+		rtw_enqueue_cmd(pcmdpriv, pdisconnect_cmd);
+	//}
+	
+exit:
+
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct	cmd_obj*	ph2c;
+	struct	setopmode_parm* psetop;
+
+	struct	cmd_priv   *pcmdpriv= &padapter->cmdpriv;
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));			
+	if(ph2c==NULL){
+		res= _FALSE;
+		goto exit;
+		}
+	psetop = (struct setopmode_parm*)_rtw_zmalloc(sizeof(struct setopmode_parm)); 
+
+	if(psetop==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res=_FALSE;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);
+	psetop->mode = (u8)networktype;
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key)
+{
+	struct cmd_obj*			ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct set_stakey_rsp		*psetstakey_rsp = NULL;
+	
+	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv 		*psecuritypriv = &padapter->securitypriv;
+	struct sta_info* 			sta = (struct sta_info* )psta;
+	u8	res=_SUCCESS;
+
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if ( ph2c == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm*)_rtw_zmalloc(sizeof(struct set_stakey_parm));
+	if(psetstakey_para==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res=_FAIL;
+		goto exit;
+	}
+
+	psetstakey_rsp = (struct set_stakey_rsp*)_rtw_zmalloc(sizeof(struct set_stakey_rsp)); 
+	if(psetstakey_rsp == NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		_rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
+		res=_FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+	ph2c->rsp = (u8 *) psetstakey_rsp;
+	ph2c->rspsz = sizeof(struct set_stakey_rsp);
+
+	_rtw_memcpy(psetstakey_para->addr, sta->hwaddr,ETH_ALEN);
+	
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+		psetstakey_para->algorithm =(unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
+	else
+		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, _FALSE);
+
+	if (unicast_key == _TRUE) {
+		_rtw_memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
+        } else {
+		_rtw_memcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid-1].skey, 16);
+        }
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:
+
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_setrfintfs_cmd(_adapter  *padapter, u8 mode)
+{	
+	struct cmd_obj*			ph2c;
+	struct setrfintfs_parm*		psetrfintfsparm;	
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	psetrfintfsparm = (struct setrfintfs_parm*)_rtw_zmalloc(sizeof(struct setrfintfs_parm)); 
+	if(psetrfintfsparm==NULL){
+		_rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrfintfsparm, GEN_CMD_CODE(_SetRFIntFs));
+	psetrfintfsparm->rfintfs = mode;
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:
+
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table)
+{
+	struct cmd_obj*			ph2c;
+	struct setratable_parm *	psetrttblparm;	
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	psetrttblparm = (struct setratable_parm*)_rtw_zmalloc(sizeof(struct setratable_parm)); 
+
+	if(psetrttblparm==NULL){
+		_rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
+
+	_rtw_memcpy(psetrttblparm,prate_table,sizeof(struct setratable_parm));
+
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:
+_func_exit_;	
+	return res;
+
+}
+
+u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval)
+{
+	struct cmd_obj*			ph2c;
+	struct getratable_parm *	pgetrttblparm;	
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+		}
+	pgetrttblparm = (struct getratable_parm*)_rtw_zmalloc(sizeof(struct getratable_parm)); 
+
+	if(pgetrttblparm==NULL){
+		_rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+//	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
+
+	_rtw_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_GetRaTable);
+	ph2c->parmbuf = (unsigned char *)pgetrttblparm;
+	ph2c->cmdsz =  sizeof(struct getratable_parm);
+	ph2c->rsp = (u8*)pval;
+	ph2c->rspsz = sizeof(struct getratable_rsp);
+	
+	pgetrttblparm ->rsvd = 0x0;
+	
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:
+_func_exit_;	
+	return res;
+
+}
+
+u8 rtw_gettssi_cmd(_adapter  *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_priv 	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj*			ph2c;	
+	struct readTSSI_parm*	prdtssiparm;
+
+	u8	res=_SUCCESS;
+	
+_func_enter_;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res=_FAIL;
+		goto exit;
+		}
+	
+	prdtssiparm = (struct readTSSI_parm*)_rtw_zmalloc(sizeof(struct readTSSI_parm)); 
+	if(prdtssiparm ==NULL){
+		_rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+		return _FAIL;
+	}
+	
+	_rtw_init_listhead(&ph2c->list);
+	ph2c->cmdcode =GEN_CMD_CODE(_ReadTSSI);
+	ph2c->parmbuf = (unsigned char *)prdtssiparm;
+	ph2c->cmdsz =sizeof(struct readTSSI_parm);;
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readTSSI_rsp);
+	
+	prdtssiparm ->offset = offset;
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:
+
+_func_exit_;	
+
+	return res;
+}
+
+u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr)
+{
+	struct cmd_priv 		*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj*			ph2c;
+	struct set_assocsta_parm	*psetassocsta_para;	
+	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
+
+	u8	res=_SUCCESS;
+
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	psetassocsta_para = (struct set_assocsta_parm*)_rtw_zmalloc(sizeof(struct set_assocsta_parm));
+	if(psetassocsta_para==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		res=_FAIL;
+		goto exit;
+	}
+
+	psetassocsta_rsp = (struct set_stakey_rsp*)_rtw_zmalloc(sizeof(struct set_assocsta_rsp)); 
+	if(psetassocsta_rsp==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		_rtw_mfree((u8 *) psetassocsta_para, sizeof(struct set_assocsta_parm));
+		return _FAIL;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SetAssocSta_CMD_);
+	ph2c->rsp = (u8 *) psetassocsta_rsp;
+	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
+
+	_rtw_memcpy(psetassocsta_para->addr, mac_addr,ETH_ALEN);
+	
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:
+
+_func_exit_;	
+
+	return res;
+ }
+
+u8 rtw_addbareq_cmd(_adapter*padapter, u8 tid, u8 *addr)
+{
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj*		ph2c;
+	struct addBaReq_parm	*paddbareq_parm;
+
+	u8	res=_SUCCESS;
+	
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));	
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	
+	paddbareq_parm = (struct addBaReq_parm*)_rtw_zmalloc(sizeof(struct addBaReq_parm)); 
+	if(paddbareq_parm==NULL){
+		_rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	paddbareq_parm->tid = tid;
+	_rtw_memcpy(paddbareq_parm->addr, addr, ETH_ALEN);
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_AddBAReq));
+
+	//printk("rtw_addbareq_cmd, tid=%d\n", tid);
+
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);	
+	rtw_enqueue_cmd_ex(pcmdpriv, ph2c);
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+}
+
+u8 dynamic_chk_wk_cmd(_adapter*padapter)
+{
+	struct cmd_obj*		ph2c;
+	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;	
+	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+	
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));	
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)_rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
+	if(pdrvextra_cmd_parm==NULL){
+		_rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = DYNAMIC_CHK_WK_CID;
+	pdrvextra_cmd_parm->sz = 0;
+	pdrvextra_cmd_parm->pbuf = NULL;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+	
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);	
+	rtw_enqueue_cmd_ex(pcmdpriv, ph2c);
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+
+}
+
+void rtw_survey_cmd_callback(_adapter*	padapter ,  struct cmd_obj *pcmd)
+{
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	if (pcmd->res != H2C_SUCCESS) {
+		clr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nsurvey_cmd_callback : clr _FW_UNDER_SURVEY "));		
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: MgntActSet_802_11_BSSID_LIST_SCAN Fail ************\n\n."));
+	} 
+
+	// free cmd
+	rtw_free_cmd_obj(pcmd);
+
+_func_exit_;	
+}
+void rtw_disassoc_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{
+	_irqL	irqL;
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	
+_func_enter_;	
+
+	if (pcmd->res != H2C_SUCCESS)
+	{
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		set_fwstate(pmlmepriv, _FW_LINKED);
+		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+				
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ***Error: disconnect_cmd_callback Fail ***\n."));
+
+		goto exit;
+	}
+
+	// free cmd
+	rtw_free_cmd_obj(pcmd);
+	
+exit:
+	
+_func_exit_;	
+}
+
+
+void rtw_joinbss_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;	
+
+	if((pcmd->res != H2C_SUCCESS))
+	{				
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
+		_set_timer(&pmlmepriv->assoc_timer, 1);		
+	}
+	
+	rtw_free_cmd_obj(pcmd);
+	
+_func_exit_;	
+}
+
+void rtw_createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
+{	
+	_irqL irqL;
+	u8 timer_cancelled;
+	struct sta_info *psta = NULL;
+	struct wlan_network *pwlan = NULL;		
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)pcmd->parmbuf;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+
+_func_enter_;	
+
+	if((pcmd->res != H2C_SUCCESS))
+	{	
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n."));
+		_set_timer(&pmlmepriv->assoc_timer, 1 );		
+	}
+	
+	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+
+       //endian_convert
+        pnetwork->Length = le32_to_cpu(pnetwork->Length);
+  	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy =le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);	
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	//pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
+	pnetwork->Configuration.DSConfig =le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);	
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+
+	
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	
+	
+	if((pmlmepriv->fw_state) & WIFI_AP_STATE)
+	{
+		psta = rtw_get_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+		if(!psta)
+		{
+		psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+		if (psta == NULL) 
+		{ 
+			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when rtw_createbss_cmd_callback\n"));
+			goto createbss_cmd_fail ;
+		}
+		}	
+			
+		rtw_indicate_connect( padapter);
+	}
+	else
+	{	
+		pwlan = _rtw_alloc_network(pmlmepriv);
+
+		if ( pwlan == NULL)
+		{
+			pwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);
+			if( pwlan == NULL)
+			{
+				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n Error:  can't get pwlan in rtw_joinbss_event_callback \n"));
+				goto createbss_cmd_fail;
+			}
+			pwlan->last_scanned = rtw_get_current_time();			
+		}	
+		else
+		{
+			rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+		}
+				
+		pnetwork->Length = get_WLAN_BSSID_EX_sz(pnetwork);
+		_rtw_memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
+		//pwlan->fixed = _TRUE;
+
+		//rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+
+		// copy pdev_network information to 	pmlmepriv->cur_network
+		_rtw_memcpy(&tgt_network->network, pnetwork, (get_WLAN_BSSID_EX_sz(pnetwork)));
+
+		// reset DSConfig
+		//tgt_network->network.Configuration.DSConfig = (u32)rtw_ch2freq(pnetwork->Configuration.DSConfig);
+		
+
+		if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+		    pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+
+#if 0		
+		if((pmlmepriv->fw_state) & WIFI_AP_STATE)
+		{
+			psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+
+			if (psta == NULL) { // for AP Mode & Adhoc Master Mode
+				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when rtw_createbss_cmd_callback\n"));
+				goto createbss_cmd_fail ;
+			}
+			
+			rtw_indicate_connect( padapter);
+		}
+		else {
+
+			//rtw_indicate_disconnect(dev);
+		}		
+#endif
+
+		// we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback)
+			
+	}
+
+createbss_cmd_fail:
+	
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+	rtw_free_cmd_obj(pcmd);
+	
+_func_exit_;	
+
+}
+
+
+
+void rtw_setstaKey_cmdrsp_callback(_adapter*	padapter ,  struct cmd_obj *pcmd)
+{
+	
+	struct sta_priv * pstapriv = &padapter->stapriv;
+	struct set_stakey_rsp* psetstakey_rsp = (struct set_stakey_rsp*) (pcmd->rsp);
+	struct sta_info*	psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
+
+_func_enter_;	
+
+	if(psta==NULL)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info \n\n"));
+		goto exit;
+	}
+	
+	//psta->aid = psta->mac_id = psetstakey_rsp->keyid; //CAM_ID(CAM_ENTRY)
+	
+exit:	
+
+	rtw_free_cmd_obj(pcmd);
+	
+_func_exit_;	
+
+}
+void rtw_setassocsta_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{
+	_irqL	irqL;
+	struct sta_priv * pstapriv = &padapter->stapriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;	
+	struct set_assocsta_parm* passocsta_parm = (struct set_assocsta_parm*)(pcmd->parmbuf);
+	struct set_assocsta_rsp* passocsta_rsp = (struct set_assocsta_rsp*) (pcmd->rsp);		
+	struct sta_info*	psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
+
+_func_enter_;	
+	
+	if(psta==NULL)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info \n\n"));
+		goto exit;
+	}
+	
+	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+       if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE))           	
+     	   pmlmepriv->fw_state ^= _FW_UNDER_LINKING;         
+
+       set_fwstate(pmlmepriv, _FW_LINKED);       	   
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	  
+	rtw_free_cmd_obj(pcmd);
+exit:	
+_func_exit_;	  
+}
+
+static void getrttbl_cmd_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
+{
+_func_enter_;	
+	  
+	rtw_free_cmd_obj(pcmd);
+#ifdef CONFIG_MP_INCLUDED
+	padapter->mppriv.workparam.bcompleted=_TRUE;
+#endif
+
+_func_exit_;	  
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_debug.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_debug.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_debug.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_debug.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,446 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#define _RTL871X_DEBUG_C_
+
+
+#include <rtw_debug.h>
+
+#ifdef CONFIG_DEBUG_RTL871X
+
+	u32 GlobalDebugLevel = _drv_info_;
+
+	u64 GlobalDebugComponents = \
+			_module_rtl871x_xmit_c_ |
+			_module_xmit_osdep_c_ |
+			_module_rtl871x_recv_c_ |
+			_module_recv_osdep_c_ |
+			_module_rtl871x_mlme_c_ |
+			_module_mlme_osdep_c_ |
+			_module_rtl871x_sta_mgt_c_ |
+			_module_rtl871x_cmd_c_ |
+			_module_cmd_osdep_c_ |
+			_module_rtl871x_io_c_ |
+			_module_io_osdep_c_ |
+			_module_os_intfs_c_|
+			_module_rtl871x_security_c_|
+			_module_rtl871x_eeprom_c_|
+			_module_hal_init_c_|
+			_module_hci_hal_init_c_|
+			_module_rtl871x_ioctl_c_|
+			_module_rtl871x_ioctl_set_c_|
+			_module_rtl871x_ioctl_query_c_|
+			_module_rtl871x_pwrctrl_c_|
+			_module_hci_intfs_c_|
+			_module_hci_ops_c_|
+			_module_rtl871x_mp_ioctl_c_|
+			_module_hci_ops_os_c_|
+			_module_rtl871x_ioctl_os_c|
+			_module_rtl871x_mp_c_ |
+			_module_rtl8712_cmd_c_|
+			_module_rtl8192c_xmit_c_|
+			_module_rtl8712_efuse_c_|
+			_module_rtl8712_recv_c_;
+
+#endif
+
+#ifdef CONFIG_PROC_DEBUG
+
+int proc_get_write_reg(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	*eof = 1;
+	return 0;
+}
+
+int proc_set_write_reg(struct file *file, const char *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	char tmp[32];
+	u32 addr, val, len;
+
+	if (count < 3)
+	{
+		printk("argument size is less than 3\n");
+		return -EFAULT;
+	}	
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%x %x %x", &addr, &val, &len);
+
+		if (num !=  3) {
+			printk("invalid write_reg parameter!\n");
+			return count;
+		}
+
+		switch(len)
+		{
+			case 1:
+				rtw_write8(padapter, addr, (u8)val);				
+				break;
+			case 2:
+				rtw_write16(padapter, addr, (u16)val);				
+				break;
+			case 4:
+				rtw_write32(padapter, addr, val);				
+				break;
+			default:
+				printk("error write length=%d", len);
+				break;
+		}			
+		
+	}
+	
+	return count;
+	
+}
+
+static u32 proc_get_read_addr=0xeeeeeeee;
+static u32 proc_get_read_len=0x4;
+
+int proc_get_read_reg(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{	
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);	
+	
+	int len = 0;
+
+	if(proc_get_read_addr==0xeeeeeeee)
+	{
+		*eof = 1;
+		return len;
+	}	
+
+	switch(proc_get_read_len)
+	{
+		case 1:			
+			len += snprintf(page + len, count - len, "read8(0x%x)=0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));
+			break;
+		case 2:
+			len += snprintf(page + len, count - len, "read16(0x%x)=0x%x\n", proc_get_read_addr, rtw_read16(padapter, proc_get_read_addr));
+			break;
+		case 4:
+			len += snprintf(page + len, count - len, "read32(0x%x)=0x%x\n", proc_get_read_addr, rtw_read32(padapter, proc_get_read_addr));
+			break;
+		default:
+			len += snprintf(page + len, count - len, "error read length=%d\n", proc_get_read_len);
+			break;
+	}
+
+	*eof = 1;
+	return len;
+
+}
+
+int proc_set_read_reg(struct file *file, const char *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	char tmp[16];
+	u32 addr, len;
+
+	if (count < 2)
+	{
+		printk("argument size is less than 2\n");
+		return -EFAULT;
+	}	
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%x %x", &addr, &len);
+
+		if (num !=  2) {
+			printk("invalid read_reg parameter!\n");
+			return count;
+		}
+
+		proc_get_read_addr = addr;
+		
+		proc_get_read_len = len;
+	}
+	
+	return count;
+
+}
+
+int proc_get_fwstate(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "fwstate=0x%x\n", pmlmepriv->fw_state);
+				
+	*eof = 1;
+	return len;
+}
+
+int proc_get_sec_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);	
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+				
+	*eof = 1;
+	return len;
+}
+
+int proc_get_mlmext_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);	
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
+				
+	*eof = 1;
+	return len;
+}
+
+int proc_get_qos_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "qos_option=%d\n", pmlmepriv->qospriv.qos_option);
+				
+	*eof = 1;
+	return len;
+
+}
+
+int proc_get_ht_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "ht_option=%d\n", pmlmepriv->htpriv.ht_option);
+				
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rf_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);	
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;	
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "cur_ch=%d, cur_bw=%d, cur_ch_offet=%d\n", 
+					pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	
+				
+	*eof = 1;
+	return len;
+
+}
+
+int proc_get_ap_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct sta_info *psta;
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int len = 0;
+
+	psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+	if(psta)
+	{
+		int i;
+		struct recv_reorder_ctrl *preorder_ctrl;
+					
+		len += snprintf(page + len, count - len, "sta's macaddr:" MACSTR "\n", MAC2STR(psta->hwaddr));
+		len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+		len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+		len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+		len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+		len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
+		len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+					
+		for(i=0;i<16;i++)
+		{							
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			if(preorder_ctrl->enable)
+			{
+				len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
+			}
+		}	
+							
+	}
+	else
+	{							
+		len += snprintf(page + len, count - len, "can't get sta's macaddr, cur_network's macaddr:" MACSTR "\n", MAC2STR(cur_network->network.MacAddress));
+	}
+
+	*eof = 1;
+	return len;
+
+}
+
+int proc_get_adapter_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	int len = 0;
+	
+	len += snprintf(page + len, count - len, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
+						padapter->bSurpriseRemoved, padapter->bDriverStopped);
+
+	*eof = 1;
+	return len;
+
+}
+	
+int proc_get_trx_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct recv_priv  *precvpriv = &padapter->recvpriv;
+	int len = 0;
+	
+	len += snprintf(page + len, count - len, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d\n", 
+				pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt);
+						
+	len += snprintf(page + len, count - len, "rx_urb_pending_cn=%d\n", precvpriv->rx_pending_cnt);
+
+
+	*eof = 1;
+	return len;
+
+}
+	
+		
+#ifdef CONFIG_AP_MODE
+
+int proc_get_all_sta_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	_irqL irqL;
+	struct sta_info *psta;
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int i, j;
+	_list	*plist, *phead;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int len = 0;	
+						
+
+	len += snprintf(page + len, count - len, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
+					
+	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+	for(i=0; i< NUM_STA; i++)
+	{
+		phead = &(pstapriv->sta_hash[i]);
+		plist = get_next(phead);
+		
+		while ((end_of_queue_search(phead, plist)) == _FALSE)
+		{
+			psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+
+			plist = get_next(plist);
+
+			//if(extra_arg == psta->aid)
+			{
+				len += snprintf(page + len, count - len, "sta's macaddr:" MACSTR "\n", MAC2STR(psta->hwaddr));
+				len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+				len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+				len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+				len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+				len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
+				len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+				len += snprintf(page + len, count - len, "sleepq_len=%d\n", psta->sleepq_len);
+								
+				for(j=0;j<16;j++)
+				{							
+					preorder_ctrl = &psta->recvreorder_ctrl[j];
+					if(preorder_ctrl->enable)
+					{
+						len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
+					}
+				}		
+									
+			}							
+			
+		}
+		
+	}
+	
+	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+	*eof = 1;
+	return len;
+
+}
+	
+#endif		
+
+	
+#endif
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_eeprom.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_eeprom.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_eeprom.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_eeprom.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,423 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_EEPROM_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+void up_clk(_adapter*	padapter,	 u16 *x)
+{
+_func_enter_;
+	*x = *x | _EESK;
+	rtw_write8(padapter, EE_9346CR, (u8)*x);
+	rtw_udelay_os(CLOCK_RATE);
+
+_func_exit_;
+	
+}
+
+void down_clk(_adapter *	padapter, u16 *x	)
+{
+_func_enter_;
+	*x = *x & ~_EESK;
+	rtw_write8(padapter, EE_9346CR, (u8)*x);
+	rtw_udelay_os(CLOCK_RATE);
+_func_exit_;	
+}
+
+void shift_out_bits(_adapter * padapter, u16 data, u16 count)
+{
+	u16 x,mask;
+_func_enter_;
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	mask = 0x01 << (count - 1);
+	x = rtw_read8(padapter, EE_9346CR);
+
+	x &= ~(_EEDO | _EEDI);
+
+	do
+	{
+		x &= ~_EEDI;
+		if(data & mask)
+			x |= _EEDI;
+		if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+		}
+		rtw_write8(padapter, EE_9346CR, (u8)x);
+		rtw_udelay_os(CLOCK_RATE);
+		up_clk(padapter, &x);
+		down_clk(padapter, &x);
+		mask = mask >> 1;
+	} while(mask);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x &= ~_EEDI;
+	rtw_write8(padapter, EE_9346CR, (u8)x);
+out:	
+_func_exit_;		
+}
+
+u16 shift_in_bits (_adapter * padapter)
+{
+	u16 x,d=0,i;
+_func_enter_;	
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x = rtw_read8(padapter, EE_9346CR);
+
+	x &= ~( _EEDO | _EEDI);
+	d = 0;
+
+	for(i=0; i<16; i++)
+	{
+		d = d << 1;
+		up_clk(padapter, &x);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+		x = rtw_read8(padapter, EE_9346CR);
+
+		x &= ~(_EEDI);
+		if(x & _EEDO)
+		d |= 1;
+
+		down_clk(padapter, &x);
+	}
+out:	
+_func_exit_;		
+
+	return d;
+}
+
+void standby(_adapter *	padapter	)
+{
+	u8   x;
+_func_enter_;	
+	x = rtw_read8(padapter, EE_9346CR);
+
+	x &= ~(_EECS | _EESK);
+	rtw_write8(padapter, EE_9346CR,x);
+
+	rtw_udelay_os(CLOCK_RATE);
+	x |= _EECS;
+	rtw_write8(padapter, EE_9346CR, x);
+	rtw_udelay_os(CLOCK_RATE);
+_func_exit_;		
+}
+
+u16 wait_eeprom_cmd_done(_adapter* padapter)
+{
+	u8 	x;
+	u16	i,res=_FALSE;
+_func_enter_;	
+	standby(padapter );
+	for (i=0; i<200; i++) 
+	{
+		x = rtw_read8(padapter, EE_9346CR);
+		if (x & _EEDO){
+			res=_TRUE;
+			goto exit;
+			}
+		rtw_udelay_os(CLOCK_RATE);
+	}
+exit:	
+_func_exit_;			
+	return res;
+}
+
+void eeprom_clean(_adapter * padapter)
+{
+	u16 x;
+_func_enter_;		
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x = rtw_read8(padapter, EE_9346CR);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	x &= ~(_EECS | _EEDI);
+	rtw_write8(padapter, EE_9346CR, (u8)x);
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	up_clk(padapter, &x);
+		if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	down_clk(padapter, &x);
+out:	
+_func_exit_;			
+}
+
+void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
+{
+	u8 x;
+#ifdef CONFIG_RTL8712
+	u8	tmp8_ori,tmp8_new,tmp8_clk_ori,tmp8_clk_new;
+	tmp8_ori=rtw_read8(padapter, 0x102502f1);
+	tmp8_new=tmp8_ori & 0xf7;
+	if(tmp8_ori != tmp8_new){	
+		rtw_write8(padapter, 0x102502f1, tmp8_new);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x102502f1=====\n"));
+	}
+	tmp8_clk_ori=rtw_read8(padapter,0x10250003);
+	tmp8_clk_new=tmp8_clk_ori|0x20;
+	if(tmp8_clk_new!=tmp8_clk_ori){
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x10250003=====\n"));
+		rtw_write8(padapter, 0x10250003, tmp8_clk_new);
+	}	
+#endif
+_func_enter_;		
+	
+	x = rtw_read8(padapter, EE_9346CR);
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	rtw_write8(padapter, EE_9346CR, x);
+
+	shift_out_bits(padapter, EEPROM_EWEN_OPCODE, 5);
+	
+	if(padapter->EepromAddressSize==8)	//CF+ and SDIO
+		shift_out_bits(padapter, 0, 6);
+	else									//USB
+		shift_out_bits(padapter, 0, 4);
+	
+	standby( padapter);
+
+// Commented out by rcnjko, 2004.0
+//	// Erase this particular word.  Write the erase opcode and register
+//	// number in that order. The opcode is 3bits in length; reg is 6 bits long.
+//	shift_out_bits(Adapter, EEPROM_ERASE_OPCODE, 3);
+//	shift_out_bits(Adapter, reg, Adapter->EepromAddressSize);
+//
+//	if (wait_eeprom_cmd_done(Adapter ) == FALSE) 
+//	{
+//		return;
+//	}
+
+
+	standby(padapter );
+
+	// write the new word to the EEPROM
+
+	// send the write opcode the EEPORM
+	shift_out_bits(padapter, EEPROM_WRITE_OPCODE, 3);
+
+	// select which word in the EEPROM that we are writing to.
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+
+	// write the data to the selected EEPROM word.
+	shift_out_bits(padapter, data, 16);
+
+	if (wait_eeprom_cmd_done(padapter ) == _FALSE) 
+	{
+
+		goto exit;
+	}
+
+	standby(padapter );
+
+	shift_out_bits(padapter, EEPROM_EWDS_OPCODE, 5);
+	shift_out_bits(padapter, reg, 4);
+
+	eeprom_clean(padapter );
+exit:	
+#ifdef CONFIG_RTL8712
+	if(tmp8_clk_new!=tmp8_clk_ori)
+		rtw_write8(padapter, 0x10250003, tmp8_clk_ori);
+	if(tmp8_new!=tmp8_ori)
+		rtw_write8(padapter, 0x102502f1, tmp8_ori);
+
+#endif
+_func_exit_;	
+	return;
+}
+
+u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
+{
+
+	u16 x;
+	u16 data=0;
+#ifdef CONFIG_RTL8712
+	u8	tmp8_ori,tmp8_new,tmp8_clk_ori,tmp8_clk_new;
+	tmp8_ori= rtw_read8(padapter, 0x102502f1);
+	tmp8_new = tmp8_ori & 0xf7;
+	if(tmp8_ori != tmp8_new){	
+		rtw_write8(padapter, 0x102502f1, tmp8_new);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x102502f1=====\n"));
+	}
+	tmp8_clk_ori=rtw_read8(padapter,0x10250003);
+	tmp8_clk_new=tmp8_clk_ori|0x20;
+	if(tmp8_clk_new!=tmp8_clk_ori){
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x10250003=====\n"));
+		rtw_write8(padapter, 0x10250003, tmp8_clk_new);
+	}	
+#endif
+_func_enter_;		
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	// select EEPROM, reset bits, set _EECS
+	x = rtw_read8(padapter, EE_9346CR);
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	rtw_write8(padapter, EE_9346CR, (unsigned char)x);
+
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 6 bits long
+	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+
+	// Now read the data (16 bits) in from the selected EEPROM word
+	data = shift_in_bits(padapter);
+
+	eeprom_clean(padapter);
+out:	
+#ifdef CONFIG_RTL8712
+	if(tmp8_clk_new!=tmp8_clk_ori)
+		rtw_write8(padapter, 0x10250003, tmp8_clk_ori);
+	if(tmp8_new!=tmp8_ori)
+		rtw_write8(padapter, 0x102502f1, tmp8_ori);
+
+#endif
+_func_exit_;		
+	return data;
+
+
+}
+
+
+
+
+//From even offset
+void eeprom_read_sz(_adapter * padapter, u16 reg, u8* data, u32 sz) 
+{
+
+	u16 x, data16;
+	u32 i;
+_func_enter_;		
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+	// select EEPROM, reset bits, set _EECS
+	x = rtw_read8(padapter, EE_9346CR);
+
+	if(padapter->bSurpriseRemoved==_TRUE){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		goto out;
+	}
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	rtw_write8(padapter, EE_9346CR, (unsigned char)x);
+
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 6 bits long
+	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+
+
+	for(i=0; i<sz; i+=2)
+	{
+		data16 = shift_in_bits(padapter);
+		data[i] = data16 & 0xff;
+		data[i+1] = data16 >>8;		
+	}
+
+	eeprom_clean(padapter);
+out:	
+_func_exit_;		
+
+
+
+}
+
+
+//addr_off : address offset of the entry in eeprom (not the tuple number of eeprom (reg); that is addr_off !=reg)
+u8 eeprom_read(_adapter * padapter, u32 addr_off, u8 sz, u8* rbuf)
+{
+	u8 quotient, remainder, addr_2align_odd;
+	u16 reg, stmp , i=0, idx = 0;
+_func_enter_;		
+	reg = (u16)(addr_off >> 1);
+	addr_2align_odd = (u8)(addr_off & 0x1);
+
+	if(addr_2align_odd) //read that start at high part: e.g  1,3,5,7,9,...
+	{
+		stmp = eeprom_read16(padapter, reg);
+		rbuf[idx++] = (u8) ((stmp>>8)&0xff); //return hogh-part of the short
+		reg++; sz--;
+	}
+	
+	quotient = sz >> 1;
+	remainder = sz & 0x1;
+
+	for( i=0 ; i < quotient; i++)
+	{
+		stmp = eeprom_read16(padapter, reg+i);
+		rbuf[idx++] = (u8) (stmp&0xff);
+		rbuf[idx++] = (u8) ((stmp>>8)&0xff);
+	}
+	
+	reg = reg+i;
+	if(remainder){ //end of read at lower part of short : 0,2,4,6,...
+		stmp = eeprom_read16(padapter, reg);
+		rbuf[idx] = (u8)(stmp & 0xff); 
+	}
+_func_exit_;		
+	return _TRUE;
+}
+
+
+
+VOID read_eeprom_content(_adapter *	padapter)
+{
+
+_func_enter_;		
+
+
+_func_exit_;		
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_io.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_io.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_io.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_io.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,409 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#define _RTL871X_IO_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_io.h>
+#include <osdep_intf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/smp_lock.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_ops.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+
+u8 rtw_read8(_adapter *adapter, u32 addr)
+{
+	u8 r_val;
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+	_irqL irqL;
+	_func_enter_;
+	_read8 = pintfhdl->io_ops._read8;
+	_enter_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	r_val = _read8(pintfhdl, addr);
+	_exit_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_func_exit_;
+	return r_val;
+}
+
+u16 rtw_read16(_adapter *adapter, u32 addr)
+{
+	u16 r_val;
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	u16 	(*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+	_irqL irqL;
+	_func_enter_;
+	_read16 = pintfhdl->io_ops._read16;
+	_enter_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	r_val = _read16(pintfhdl, addr);
+	_exit_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_func_exit_;
+	return r_val;
+}
+	
+u32 rtw_read32(_adapter *adapter, u32 addr)
+{
+	u32 r_val;
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	u32 	(*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+	_irqL irqL;
+	_func_enter_;
+	_read32 = pintfhdl->io_ops._read32;
+	_enter_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	r_val = _read32(pintfhdl, addr);
+	_exit_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_func_exit_;
+	return r_val;	
+
+}
+
+void rtw_write8(_adapter *adapter, u32 addr, u8 val)
+{
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	_irqL irqL;
+	_func_enter_;
+	_write8 = pintfhdl->io_ops._write8;
+	_enter_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_write8(pintfhdl, addr, val);
+	_exit_critical_mutex(&pintfhdl->io_mutex, &irqL);
+}
+void rtw_write16(_adapter *adapter, u32 addr, u16 val)
+{
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	_irqL irqL;
+	_func_enter_;
+	_write16 = pintfhdl->io_ops._write16;
+	_enter_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_write16(pintfhdl, addr, val);
+	_exit_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_func_exit_;
+
+}
+void rtw_write32(_adapter *adapter, u32 addr, u32 val)
+{
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	_irqL irqL;
+	_func_enter_;
+	_write32 = pintfhdl->io_ops._write32;
+	_enter_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_write32(pintfhdl, addr, val);	
+	_exit_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_func_exit_;
+
+}
+void writeN(_adapter *adapter, u32 addr ,u32 length , u8 *pdata)
+{
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+        struct	intf_hdl	*pintfhdl = (struct intf_hdl*)(&(pio_priv->intf));
+	void (*_writeN)(struct intf_hdl *pintfhdl, u32 addr,u32 length, u8 *pdata);
+	_irqL irqL;
+	_func_enter_;
+	_writeN = pintfhdl->io_ops._writeN;
+	_enter_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_writeN(pintfhdl, addr,length,pdata);	
+	_exit_critical_mutex(&pintfhdl->io_mutex, &irqL);
+	_func_exit_;
+
+}
+void write8_async(_adapter *adapter, u32 addr, u8 val)
+{
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	void (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	_func_enter_;
+	_write8_async = pintfhdl->io_ops._write8_async;
+	
+	_write8_async(pintfhdl, addr, val);	
+	_func_exit_;
+
+}
+void write16_async(_adapter *adapter, u32 addr, u16 val)
+{
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	void (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	_func_enter_;
+	_write16_async = pintfhdl->io_ops._write16_async;
+	
+	_write16_async(pintfhdl, addr, val);	
+	_func_exit_;
+
+}
+void write32_async(_adapter *adapter, u32 addr, u32 val)
+{
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	void (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	_func_enter_;
+	_write32_async = pintfhdl->io_ops._write32_async;
+	
+	_write32_async(pintfhdl, addr, val);	
+	_func_exit_;
+
+}
+void rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);	
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	
+	_func_enter_;
+
+	if( (adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE))
+	{
+	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
+	     return;
+	}	
+	
+	_read_mem = pintfhdl->io_ops._read_mem;
+	
+	_read_mem(pintfhdl, addr, cnt, pmem);
+	
+	_func_exit_;
+	
+}
+
+void rtw_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{	
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);	
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+
+	_func_enter_;
+	
+	_write_mem = pintfhdl->io_ops._write_mem;
+	
+	_write_mem(pintfhdl, addr, cnt, pmem);
+	
+	_func_exit_;	
+	
+}
+
+void rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{	
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);	
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	
+	_func_enter_;	
+
+	if( (adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE))
+	{
+	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
+	     return;
+	}	
+
+	_read_port = pintfhdl->io_ops._read_port;
+	
+	_read_port(pintfhdl, addr, cnt, pmem);
+	 
+	_func_exit_;
+
+}
+
+void read_port_cancel(_adapter *adapter)
+{
+	void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct intf_hdl *pintfhdl = &(pio_priv->intf);
+	
+	_read_port_cancel = pintfhdl->io_ops._read_port_cancel;
+
+	if(_read_port_cancel)
+		_read_port_cancel(pintfhdl);	
+			
+}
+
+void rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{	
+	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	
+	_func_enter_;	
+	
+	_write_port = pintfhdl->io_ops._write_port;
+	
+	_write_port(pintfhdl, addr, cnt, pmem);
+	
+	 _func_exit_;
+	 
+}
+
+void write_port_cancel(_adapter *adapter)
+{
+	void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct intf_hdl *pintfhdl = &(pio_priv->intf);
+	
+	_write_port_cancel = pintfhdl->io_ops._write_port_cancel;
+
+	if(_write_port_cancel)
+		_write_port_cancel(pintfhdl);	
+
+}
+
+
+void rtw_attrib_read(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem){
+#ifdef CONFIG_SDIO_HCI
+	void (*_attrib_read)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+	
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	
+	_func_enter_;	
+	
+	_attrib_read= pintfhdl->io_ops._attrib_read;
+	
+	_attrib_read(pintfhdl, addr, cnt, pmem);
+	
+	 _func_exit_;
+#endif
+}
+
+void rtw_attrib_write(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem){
+#ifdef CONFIG_SDIO_HCI
+	void (*_attrib_write)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+	
+	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	
+	_func_enter_;	
+	
+	_attrib_write= pintfhdl->io_ops._attrib_write;
+	
+	_attrib_write(pintfhdl, addr, cnt, pmem);
+	
+	 _func_exit_;
+
+#endif
+}
+
+int init_io_priv(_adapter *padapter)
+{	
+	void (*set_intf_ops)(struct _io_ops	*pops);
+	struct io_priv	*piopriv = &padapter->iopriv;
+	struct intf_hdl *pintf = &piopriv->intf;
+
+	piopriv->padapter = padapter;
+	pintf->padapter = padapter;
+	pintf->pintf_dev = &padapter->dvobjpriv;
+	
+	_rtw_mutex_init(&pintf->io_mutex ); 
+	
+#ifdef CONFIG_SDIO_HCI	
+	set_intf_ops = &sdio_set_intf_ops;	
+#endif //END OF CONFIG_SDIO_HCI
+
+
+#ifdef CONFIG_USB_HCI	
+
+	if(padapter->chip_type == RTL8188C_8192C)
+	{
+#ifdef CONFIG_RTL8192C		
+		set_intf_ops = &rtl8192cu_set_intf_ops;
+#endif
+	}
+	else if(padapter->chip_type == RTL8192D)
+	{
+#ifdef CONFIG_RTL8192D
+		set_intf_ops = &rtl8192cu_set_intf_ops;
+#endif		
+	}
+	else
+	{
+		set_intf_ops = NULL;		
+	}
+#endif //END OF CONFIG_USB_HCI
+
+
+	if(set_intf_ops==NULL)
+		return _FAIL;
+
+
+	set_intf_ops(&pintf->io_ops);
+
+	return _SUCCESS;
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_query.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_query.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_query.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_query.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,196 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_IOCTL_QUERY_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_ioctl_query.h>
+#include <wifi.h>
+
+
+#ifdef PLATFORM_WINDOWS
+//
+// Added for WPA2-PSK, by Annie, 2005-09-20.
+//
+u8
+query_802_11_capability(
+	_adapter*		Adapter,
+	u8*			pucBuf,
+	u32 *		pulOutLen
+)
+{
+	static NDIS_802_11_AUTHENTICATION_ENCRYPTION szAuthEnc[] = 
+	{
+		{Ndis802_11AuthModeOpen, Ndis802_11EncryptionDisabled}, 
+		{Ndis802_11AuthModeOpen, Ndis802_11Encryption1Enabled},
+		{Ndis802_11AuthModeShared, Ndis802_11EncryptionDisabled}, 
+		{Ndis802_11AuthModeShared, Ndis802_11Encryption1Enabled},
+		{Ndis802_11AuthModeWPA, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPA, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPAPSK, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPAPSK, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPANone, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPANone, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPA2, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPA2, Ndis802_11Encryption3Enabled},
+		{Ndis802_11AuthModeWPA2PSK, Ndis802_11Encryption2Enabled}, 
+		{Ndis802_11AuthModeWPA2PSK, Ndis802_11Encryption3Enabled}
+	};	
+	static ULONG	ulNumOfPairSupported = sizeof(szAuthEnc)/sizeof(NDIS_802_11_AUTHENTICATION_ENCRYPTION);
+	NDIS_802_11_CAPABILITY * pCap = (NDIS_802_11_CAPABILITY *)pucBuf;
+	u8*	pucAuthEncryptionSupported = (u8*) pCap->AuthenticationEncryptionSupported;
+
+
+	pCap->Length = sizeof(NDIS_802_11_CAPABILITY);
+	if(ulNumOfPairSupported > 1 )
+		pCap->Length += 	(ulNumOfPairSupported-1) * sizeof(NDIS_802_11_AUTHENTICATION_ENCRYPTION);
+	
+	pCap->Version = 2;	
+	pCap->NoOfPMKIDs = NUM_PMKID_CACHE;	
+	pCap->NoOfAuthEncryptPairsSupported = ulNumOfPairSupported;
+
+	if( sizeof (szAuthEnc) <= 240 )		// 240 = 256 - 4*4	// SecurityInfo.szCapability: only 256 bytes in size.
+	{
+		_rtw_memcpy( pucAuthEncryptionSupported, (u8*)szAuthEnc,  sizeof (szAuthEnc) );
+		*pulOutLen = pCap->Length;
+		return _TRUE;
+	}
+	else
+	{
+		*pulOutLen = 0;
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("_query_802_11_capability(): szAuthEnc size is too large.\n"));
+		return _FALSE;
+	}
+}
+
+u8 query_802_11_association_information(	_adapter *padapter,PNDIS_802_11_ASSOCIATION_INFORMATION	pAssocInfo)
+{
+	struct wlan_network *tgt_network;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct	security_priv  *psecuritypriv=&(padapter->securitypriv);
+	WLAN_BSSID_EX	*psecnetwork=(WLAN_BSSID_EX*)&(psecuritypriv->sec_bss);					
+	u8 *	pDest = (u8 *)pAssocInfo + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+	unsigned char i,*auth_ie,*supp_ie;
+
+	//NdisZeroMemory(pAssocInfo, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+	_rtw_memset(pAssocInfo, 0, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+	//pAssocInfo->Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+
+	//------------------------------------------------------
+	// Association Request related information
+	//------------------------------------------------------
+	// Req_1. AvailableRequestFixedIEs
+	if(psecnetwork!=NULL){
+		
+	pAssocInfo->AvailableRequestFixedIEs |= NDIS_802_11_AI_REQFI_CAPABILITIES|NDIS_802_11_AI_REQFI_CURRENTAPADDRESS;
+	pAssocInfo->RequestFixedIEs.Capabilities = (unsigned short)* & psecnetwork->IEs[10];
+	_rtw_memcpy(pAssocInfo->RequestFixedIEs.CurrentAPAddress,
+		& psecnetwork->MacAddress, 6);
+
+	pAssocInfo->OffsetRequestIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+
+	if(check_fwstate( pmlmepriv, _FW_UNDER_LINKING|_FW_LINKED)==_TRUE)
+	{
+		
+		if(psecuritypriv->ndisauthtype>=Ndis802_11AuthModeWPA2)
+			pDest[0] =48;		//RSN Information Element
+		else 
+			pDest[0] =221;	//WPA(SSN) Information Element
+		
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n Adapter->ndisauthtype==Ndis802_11AuthModeWPA)?0xdd:0x30 [%d]",pDest[0]));
+		supp_ie=&psecuritypriv->supplicant_ie[0];
+		for(i=0;i<supp_ie[0];i++)
+		{
+			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("IEs [%d] = 0x%x \n\n", i,supp_ie[i]));
+		}
+
+		i=13;	//0~11 is fixed information element		
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("i= %d tgt_network->network.IELength=%d\n\n", i,(int)psecnetwork->IELength));
+		while((i<supp_ie[0]) && (i<256)){
+			if((unsigned char)supp_ie[i]==pDest[0]){
+						_rtw_memcpy((u8 *)(pDest),
+							&supp_ie[i], 
+							supp_ie[1+i]+2);
+			
+				break;
+			}
+			
+			i=i+supp_ie[i+1]+2;
+			if(supp_ie[1+i]==0)
+				i=i+1;
+			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("iteration i=%d IEs [%d] = 0x%x \n\n", i,i,supp_ie[i+1]));
+			
+		}
+		
+
+		pAssocInfo->RequestIELength += (2 + supp_ie[1+i]);// (2 + psecnetwork->IEs[1+i]+4);
+
+	}
+	
+
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n psecnetwork != NULL,fwstate==_FW_UNDER_LINKING \n"));
+
+	}
+	
+
+	//------------------------------------------------------
+	// Association Response related information
+	//------------------------------------------------------
+
+	if(check_fwstate( pmlmepriv, _FW_LINKED)==_TRUE)
+	{
+		tgt_network =&(pmlmepriv->cur_network);
+		if(tgt_network!=NULL){
+		pAssocInfo->AvailableResponseFixedIEs =
+				NDIS_802_11_AI_RESFI_CAPABILITIES
+				|NDIS_802_11_AI_RESFI_ASSOCIATIONID
+				;
+
+		pAssocInfo->ResponseFixedIEs.Capabilities =(unsigned short)* & tgt_network->network.IEs[10];
+		pAssocInfo->ResponseFixedIEs.StatusCode = 0;
+		pAssocInfo->ResponseFixedIEs.AssociationId =(unsigned short) tgt_network->aid;
+
+		pDest = (u8 *)pAssocInfo + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION)+pAssocInfo->RequestIELength;
+		auth_ie=&psecuritypriv->authenticator_ie[0];
+
+		for(i=0;i<auth_ie[0];i++)
+			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("IEs [%d] = 0x%x \n\n", i,auth_ie[i]));
+
+		i=auth_ie[0]-12;
+		if(i>0){
+			_rtw_memcpy((u8 *)&pDest[0],&auth_ie[1],i);
+			pAssocInfo->ResponseIELength =i; 
+		}
+
+
+		pAssocInfo->OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAssocInfo->RequestIELength;  
+
+
+		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n tgt_network != NULL,fwstate==_FW_LINKED \n"));
+		}
+	}												  	
+	RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n exit query_802_11_association_information \n"));
+_func_exit_;
+
+	return _TRUE;
+}
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_rtl.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_rtl.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_rtl.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_rtl.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1029 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define  _RTL871X_IOCTL_RTL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+#include <wifi.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_set.h>
+#include <rtw_ioctl_query.h>
+#include <rtw_ioctl_rtl.h>
+#include <mp_custom_oid.h>
+#ifdef CONFIG_MP_INCLUDED
+#include <rtw_mp.h>
+#include <rtw_mp_ioctl.h>
+#endif
+
+struct oid_obj_priv oid_rtl_seg_01_01[] =
+{
+	{1, &oid_null_function},										//0x80
+	{1, &oid_null_function},										//0x81
+	{1, &oid_null_function},										//0x82
+	{1, &oid_null_function},										//0x83//OID_RT_SET_SNIFFER_MODE
+	{1, &oid_rt_get_signal_quality_hdl},							//0x84
+	{1, &oid_rt_get_small_packet_crc_hdl},						//0x85
+	{1, &oid_rt_get_middle_packet_crc_hdl},						//0x86
+	{1, &oid_rt_get_large_packet_crc_hdl},						//0x87
+	{1, &oid_rt_get_tx_retry_hdl},								//0x88
+	{1, &oid_rt_get_rx_retry_hdl},								//0x89
+	{1, &oid_rt_pro_set_fw_dig_state_hdl},						//0x8A
+	{1, &oid_rt_pro_set_fw_ra_state_hdl}	,						//0x8B
+	{1, &oid_null_function},										//0x8C
+	{1, &oid_null_function},										//0x8D
+	{1, &oid_null_function},										//0x8E
+	{1, &oid_null_function},										//0x8F
+	{1, &oid_rt_get_rx_total_packet_hdl},							//0x90
+	{1, &oid_rt_get_tx_beacon_ok_hdl},							//0x91
+	{1, &oid_rt_get_tx_beacon_err_hdl},							//0x92
+	{1, &oid_rt_get_rx_icv_err_hdl},								//0x93
+	{1, &oid_rt_set_encryption_algorithm_hdl},					//0x94
+	{1, &oid_null_function},										//0x95
+	{1, &oid_rt_get_preamble_mode_hdl},							//0x96
+	{1, &oid_null_function},										//0x97
+	{1, &oid_rt_get_ap_ip_hdl},									//0x98
+	{1, &oid_rt_get_channelplan_hdl},							//0x99	
+	{1, &oid_rt_set_preamble_mode_hdl},	 						//0x9A
+	{1, &oid_rt_set_bcn_intvl_hdl},								//0x9B
+	{1, &oid_null_function},										//0x9C
+	{1, &oid_rt_dedicate_probe_hdl},								//0x9D
+	{1, &oid_null_function},										//0x9E
+	{1, &oid_null_function},										//0x9F
+	{1, &oid_null_function},										//0xA0
+	{1, &oid_null_function},										//0xA1
+	{1, &oid_null_function},										//0xA2
+	{1, &oid_null_function},										//0xA3
+	{1, &oid_null_function},										//0xA4
+	{1, &oid_null_function},										//0xA5
+	{1, &oid_null_function},										//0xA6
+	{1, &oid_rt_get_total_tx_bytes_hdl},							//0xA7
+	{1, &oid_rt_get_total_rx_bytes_hdl},							//0xA8
+	{1, &oid_rt_current_tx_power_level_hdl},						//0xA9	
+	{1, &oid_rt_get_enc_key_mismatch_count_hdl},	 			//0xAA
+	{1, &oid_rt_get_enc_key_match_count_hdl},					//0xAB
+	{1, &oid_rt_get_channel_hdl},								//0xAC
+	{1, &oid_rt_set_channelplan_hdl},								//0xAD
+	{1, &oid_rt_get_hardware_radio_off_hdl},						//0xAE
+	{1, &oid_null_function},										//0xAF
+	{1, &oid_null_function},										//0xB0
+	{1, &oid_null_function},										//0xB1
+	{1, &oid_null_function},										//0xB2
+	{1, &oid_null_function},										//0xB3
+	{1, &oid_rt_get_key_mismatch_hdl},							//0xB4
+	{1, &oid_null_function},										//0xB5
+	{1, &oid_null_function},										//0xB6
+	{1, &oid_null_function},										//0xB7
+	{1, &oid_null_function},										//0xB8
+	{1, &oid_null_function},										//0xB9	
+	{1, &oid_null_function},	 									//0xBA
+	{1, &oid_rt_supported_wireless_mode_hdl},					//0xBB
+	{1, &oid_rt_get_channel_list_hdl},							//0xBC
+	{1, &oid_rt_get_scan_in_progress_hdl},						//0xBD
+	{1, &oid_null_function},										//0xBE
+	{1, &oid_null_function},										//0xBF
+	{1, &oid_null_function},										//0xC0
+	{1, &oid_rt_forced_data_rate_hdl},							//0xC1
+	{1, &oid_rt_wireless_mode_for_scan_list_hdl},					//0xC2
+	{1, &oid_rt_get_bss_wireless_mode_hdl},						//0xC3
+	{1, &oid_rt_scan_with_magic_packet_hdl},					//0xC4
+	{1, &oid_null_function},										//0xC5
+	{1, &oid_null_function},										//0xC6
+	{1, &oid_null_function},										//0xC7
+	{1, &oid_null_function},										//0xC8
+	{1, &oid_null_function},										//0xC9	
+	{1, &oid_null_function},	 									//0xCA
+	{1, &oid_null_function},										//0xCB
+	{1, &oid_null_function},										//0xCC
+	{1, &oid_null_function},										//0xCD
+	{1, &oid_null_function},										//0xCE
+	{1, &oid_null_function},										//0xCF
+	
+};
+
+struct oid_obj_priv oid_rtl_seg_01_03[] =
+{
+	{1, &oid_rt_ap_get_associated_station_list_hdl},				//0x00
+	{1, &oid_null_function},										//0x01
+	{1, &oid_rt_ap_switch_into_ap_mode_hdl},					//0x02
+	{1, &oid_null_function},										//0x03
+	{1, &oid_rt_ap_supported_hdl},								//0x04
+	{1, &oid_rt_ap_set_passphrase_hdl},							//0x05
+
+};
+
+struct oid_obj_priv oid_rtl_seg_01_11[] =
+{
+	{1, &oid_null_function},					//0xC0	OID_RT_PRO_RX_FILTER	
+	{1, &oid_null_function},					//0xC1	OID_CE_USB_WRITE_REGISTRY
+	{1, &oid_null_function},					//0xC2	OID_CE_USB_READ_REGISTRY
+	{1, &oid_null_function},					//0xC3	OID_RT_PRO_SET_INITIAL_GAIN
+	{1, &oid_null_function},					//0xC4	OID_RT_PRO_SET_BB_RF_STANDBY_MODE
+	{1, &oid_null_function},					//0xC5	OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE
+	{1, &oid_null_function},					//0xC6	OID_RT_PRO_SET_TX_CHARGE_PUMP
+	{1, &oid_null_function},					//0xC7	OID_RT_PRO_SET_RX_CHARGE_PUMP
+	{1, &oid_rt_pro_rf_write_registry_hdl},	//0xC8	
+	{1, &oid_rt_pro_rf_read_registry_hdl},	//0xC9	
+	{1, &oid_null_function}					//0xCA	OID_RT_PRO_QUERY_RF_TYPE
+	
+};
+
+struct oid_obj_priv oid_rtl_seg_03_00[] =
+{
+	{1, &oid_null_function},										//0x00
+	{1, &oid_rt_get_connect_state_hdl},							//0x01
+	{1, &oid_null_function},										//0x02
+	{1, &oid_null_function},										//0x03
+	{1, &oid_rt_set_default_key_id_hdl},							//0x04
+
+	
+};
+
+
+//**************  oid_rtl_seg_01_01 section start ************** 
+
+NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv)
+{
+
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL			oldirql;
+	
+	_func_enter_;
+	
+	if(poid_par_priv->type_of_oid != SET_OID) 
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+			
+	_irqlevel_changed_(&oldirql,LOWER);
+	if(poid_par_priv->information_buf_len >= sizeof(struct setdig_parm))
+	{
+		//DEBUG_ERR(("===> oid_rt_pro_set_fw_dig_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));	
+		if(!rtw_setfwdig_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))			
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+		                   
+	}
+	else{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}  
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv)
+{
+
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL			oldirql;
+	
+	_func_enter_;	
+	if(poid_par_priv->type_of_oid != SET_OID) 
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+					
+	_irqlevel_changed_(&oldirql,LOWER);
+	
+	if(poid_par_priv->information_buf_len >= sizeof(struct setra_parm))
+	{
+		//DEBUG_ERR(("===> oid_rt_pro_set_fw_ra_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));	
+		if(!rtw_setfwra_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))			
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+		                   
+	}
+	else{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}  
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	//DEBUG_ERR(("<**********************oid_rt_get_signal_quality_hdl \n"));
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+#if 0
+		if(pMgntInfo->mAssoc || pMgntInfo->mIbss)
+		{
+			ulInfo = pAdapter->RxStats.SignalQuality;
+			*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		}
+		else
+		{
+			ulInfo = 0xffffffff; // It stands for -1 in 4-byte integer.
+		}
+		break;
+#endif
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+
+NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+		
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_smallpacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_middlepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_largepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_tx_retry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_rx_retry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_rx_total_packet_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
+	{		
+		*(u64 *)poid_par_priv->information_buf = padapter->recvpriv.rx_pkts + padapter->recvpriv.rx_drop;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if(poid_par_priv->information_buf_len>= sizeof(u32))
+	{
+		//_rtw_memcpy(*(uint *)poid_par_priv->information_buf,padapter->recvpriv.rx_icv_err,sizeof(u32));
+		*(uint *)poid_par_priv->information_buf = padapter->recvpriv.rx_icv_err;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	ULONG			preamblemode = 0 ;			
+		
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{		
+		if(padapter->registrypriv.preamble == PREAMBLE_LONG)
+			preamblemode = 0;
+		else if (padapter->registrypriv.preamble == PREAMBLE_AUTO)
+			preamblemode = 1;
+		else if (padapter->registrypriv.preamble == PREAMBLE_SHORT)
+			preamblemode = 2;
+		
+			
+		*(ULONG *)poid_par_priv->information_buf = preamblemode ;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_get_channelplan_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;	
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	*(u16 *)poid_par_priv->information_buf = peeprompriv->channel_plan ;
+
+	return status;
+}
+NDIS_STATUS oid_rt_set_channelplan_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;	
+	
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	
+	peeprompriv->channel_plan = *(u16 *)poid_par_priv->information_buf ;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_preamble_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	ULONG			preamblemode = 0;
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	 
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{		
+		preamblemode = *(ULONG *)poid_par_priv->information_buf ;
+		if( preamblemode == 0)
+			padapter->registrypriv.preamble = PREAMBLE_LONG;
+		else if (preamblemode==1 )
+			padapter->registrypriv.preamble = PREAMBLE_AUTO;
+		else if ( preamblemode==2 )
+			padapter->registrypriv.preamble = PREAMBLE_SHORT;		
+			
+		*(ULONG *)poid_par_priv->information_buf = preamblemode ;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_bcn_intvl_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	return status;
+}
+NDIS_STATUS oid_rt_dedicate_probe_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{		
+		*(u64 *)poid_par_priv->information_buf = padapter->xmitpriv.tx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
+	{
+		//_rtw_memcpy(*(uint *)poid_par_priv->information_buf,padapter->recvpriv.rx_icv_err,sizeof(u32));
+		*(u64 *)poid_par_priv->information_buf = padapter->recvpriv.rx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else
+	{
+		status = NDIS_STATUS_INVALID_LENGTH ;
+	}
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_current_tx_power_level_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	NDIS_802_11_CONFIGURATION		*pnic_Config;
+
+	ULONG   channelnum;
+
+	_func_enter_;
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	if ( (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+		pnic_Config = &pmlmepriv->cur_network.network.Configuration;
+	else
+		pnic_Config = &padapter->registrypriv.dev_network.Configuration;
+
+	channelnum = pnic_Config->DSConfig;
+	*(ULONG *)poid_par_priv->information_buf = channelnum;
+	
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	_func_exit_;
+
+
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_key_mismatch_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_supported_wireless_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+	ULONG 			ulInfo = 0 ;
+	//DEBUG_ERR(("<**********************oid_rt_supported_wireless_mode_hdl \n"));	
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+	if(poid_par_priv->information_buf_len >= sizeof(ULONG)){
+		ulInfo |= 0x0100; //WIRELESS_MODE_B
+		ulInfo |= 0x0200; //WIRELESS_MODE_G
+		ulInfo |= 0x0400; //WIRELESS_MODE_A
+
+		*(ULONG *) poid_par_priv->information_buf = ulInfo;		
+		//DEBUG_ERR(("<===oid_rt_supported_wireless_mode %x\n",ulInfo));	
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	else{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_channel_list_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_scan_in_progress_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+
+NDIS_STATUS oid_rt_forced_data_rate_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+//**************  oid_rtl_seg_01_01 section end ************** 
+
+//**************  oid_rtl_seg_01_03 section start ************** 
+NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+NDIS_STATUS oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	return status;
+}
+NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	return status;
+}
+
+//**************  oid_rtl_seg_01_03 section end ************** 
+
+//****************  oid_rtl_seg_01_11   section start ****************
+NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL			oldirql;
+	_func_enter_;
+	//DEBUG_ERR(("<**********************oid_rt_pro_rf_write_registry_hdl \n"));
+	if(poid_par_priv->type_of_oid != SET_OID) //QUERY_OID
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	
+	_irqlevel_changed_(&oldirql,LOWER);
+	if(poid_par_priv->information_buf_len== (sizeof(unsigned long)*3))
+	{      
+		//RegOffsetValue	- The offset of RF register to write.
+		//RegDataWidth	- The data width of RF register to write.
+		//RegDataValue	- The value to write. 
+		//RegOffsetValue = *((unsigned long*)InformationBuffer);
+		//RegDataWidth = *((unsigned long*)InformationBuffer+1);	   
+		//RegDataValue =  *((unsigned long*)InformationBuffer+2);	
+		if(!rtw_setrfreg_cmd(Adapter, 
+						*(unsigned char*)poid_par_priv->information_buf, 
+						(unsigned long)(*((unsigned long*)poid_par_priv->information_buf+2))))
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+	                   
+	}
+	else{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}   
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL	oldirql;
+	_func_enter_;
+
+	//DEBUG_ERR(("<**********************oid_rt_pro_rf_read_registry_hdl \n"));
+	if(poid_par_priv->type_of_oid != SET_OID) //QUERY_OID
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}	
+	
+	_irqlevel_changed_(&oldirql,LOWER);
+	if(poid_par_priv->information_buf_len== (sizeof(unsigned long)*3))
+	{
+		if(Adapter->mppriv.act_in_progress == _TRUE)
+		{
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+		else
+		{
+			//init workparam
+			Adapter->mppriv.act_in_progress = _TRUE;
+			Adapter->mppriv.workparam.bcompleted= _FALSE;
+			Adapter->mppriv.workparam.act_type = MPT_READ_RF;
+			Adapter->mppriv.workparam.io_offset = *(unsigned long*)poid_par_priv->information_buf;		
+			Adapter->mppriv.workparam.io_value = 0xcccccccc;
+				       
+			//RegOffsetValue	- The offset of RF register to read.
+			//RegDataWidth	- The data width of RF register to read.
+			//RegDataValue	- The value to read. 
+			//RegOffsetValue = *((unsigned long*)InformationBuffer);
+			//RegDataWidth = *((unsigned long*)InformationBuffer+1);	   
+			//RegDataValue =  *((unsigned long*)InformationBuffer+2);	   	 	                   
+			if(!rtw_getrfreg_cmd(Adapter, 
+							*(unsigned char*)poid_par_priv->information_buf, 
+							(unsigned char*)&Adapter->mppriv.workparam.io_value))
+			{
+				status = NDIS_STATUS_NOT_ACCEPTED;
+			}
+		}
+				      		   
+		                   
+	}
+	else	{
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+	_irqlevel_changed_(&oldirql,RAISE);
+	_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_01_11   section end****************	
+
+
+//**************  oid_rtl_seg_03_00 section start **************  
+enum _CONNECT_STATE_{
+	CHECKINGSTATUS,
+	ASSOCIATED,
+	ADHOCMODE,
+	NOTASSOCIATED
+};
+
+NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	ULONG ulInfo;
+		
+	if(poid_par_priv->type_of_oid != QUERY_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}		
+
+	// nStatus==0	CheckingStatus
+	// nStatus==1	Associated
+	// nStatus==2	AdHocMode
+	// nStatus==3	NotAssociated
+	
+	if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+		ulInfo = CHECKINGSTATUS;
+	else if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	
+		ulInfo = ASSOCIATED;
+	else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)== _TRUE)
+		ulInfo = ADHOCMODE;
+	else
+		ulInfo = NOTASSOCIATED ;
+
+	*(ULONG *)poid_par_priv->information_buf = ulInfo;
+	*poid_par_priv->bytes_rw =  poid_par_priv->information_buf_len;
+
+#if 0
+	// Rearrange the order to let the UI still shows connection when scan is in progress
+	RT_TRACE(COMP_OID_QUERY, DBG_LOUD, ("===> Query OID_RT_GET_CONNECT_STATE.\n"));
+	if(pMgntInfo->mAssoc)
+		ulInfo = 1;
+	else if(pMgntInfo->mIbss)
+		ulInfo = 2;
+	else if(pMgntInfo->bScanInProgress)
+		ulInfo = 0;
+	else
+		ulInfo = 3;
+	ulInfoLen = sizeof(ULONG);
+	RT_TRACE(COMP_OID_QUERY, DBG_LOUD, ("<=== Query OID_RT_GET_CONNECT_STATE: %d\n", ulInfo));
+#endif
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv)
+{
+	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
+	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	if(poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	
+	return status;
+}
+//**************  oid_rtl_seg_03_00 section end **************  
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_set.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_set.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_set.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_ioctl_set.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1263 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_IOCTL_SET_C_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_ioctl_set.h>
+#include <hal_init.h>
+
+#ifdef CONFIG_USB_HCI
+#include <usb_osintf.h>
+#include <usb_ops.h>
+#endif
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_osintf.h>
+#endif
+
+
+#define IS_MAC_ADDRESS_BROADCAST(addr) \
+( \
+	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
+)
+
+u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid)
+{
+	u8	 i;
+	u8	ret=_TRUE;
+
+_func_enter_;	
+
+	if (ssid->SsidLength > 32) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));
+		ret= _FALSE;
+		goto exit;
+	}
+
+	for(i = 0; i < ssid->SsidLength; i++)
+	{
+		//wifi, printable ascii code must be supported
+		if(!( (ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e) )){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
+			ret= _FALSE;
+			break;
+		}
+	}
+
+exit:	
+
+_func_exit_;
+
+	return ret;
+}
+
+static u8 do_join(_adapter * padapter)
+{
+	_list	*plist, *phead;
+	u8* pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	_queue	*queue	= &(pmlmepriv->scanned_queue);
+	u8 ret=_TRUE;
+	
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("\n do_join: phead = %p; plist = %p \n\n\n", phead, plist));
+
+	pmlmepriv->cur_network.join_res = -2;
+		
+	pmlmepriv->fw_state |= _FW_UNDER_LINKING;
+
+	pmlmepriv->pscanned = plist;
+
+	pmlmepriv->to_join = _TRUE;
+
+	if(_rtw_queue_empty(queue)== _TRUE)
+	{	
+		if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+	               pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+            		
+		//when set_ssid/set_bssid for do_join(), but scanning queue is empty
+		//we try to issue sitesurvey firstly	
+            		
+		if(pmlmepriv->sitesurveyctrl.traffic_busy==_FALSE)
+		{
+			// submit site_survey_cmd
+			rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("do_join(): site survey if scanned_queue is empty\n."));
+		}
+		
+		//ret=_FALSE;
+		
+		goto exit;
+	}	
+	else 	
+	{	
+		int ret;		
+		if((ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
+		{
+		     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);	 
+		} 
+#if 0
+		else if(ret == 2)
+		{
+			DBG_8712("*****UNDER_LINKED WITH SAME NETWORK, RETURN*****\n");
+
+			if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+	               	pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+			
+		}
+#endif
+		else	
+		{
+			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE)
+			{
+				// submit rtw_createbss_cmd to change to a ADHOC_MASTER
+
+ 				//pmlmepriv->lock has been acquired by caller...
+				WLAN_BSSID_EX    *pdev_network = &(padapter->registrypriv.dev_network);
+
+				pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+				
+				pibss = padapter->registrypriv.dev_network.MacAddress;
+
+				_rtw_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+				_rtw_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+	
+				rtw_update_registrypriv_dev_network(padapter);
+
+				rtw_generate_random_ibss(pibss);
+					
+				if(rtw_createbss_cmd(padapter)!=_SUCCESS)
+				{
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>do_goin: rtw_createbss_cmd status FAIL*** \n "));						
+					return _FALSE;
+				}
+
+			     	pmlmepriv->to_join = _FALSE;
+
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("***Error=> rtw_select_and_join_from_scanned_queue FAIL under STA_Mode*** \n "));						
+
+			}			
+			else
+			{ 
+				// can't associate ; reset under-linking			
+				if(pmlmepriv->fw_state & _FW_UNDER_LINKING)
+				    pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+
+#if 0	
+				if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE))
+				{
+					if(_rtw_memcmp(pmlmepriv->cur_network.network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength))
+					{ 
+						// for funk to do roaming
+						// funk will reconnect, but funk will not sitesurvey before reconnect
+						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("for funk to do roaming"));
+						if(pmlmepriv->sitesurveyctrl.traffic_busy==_FALSE)
+							rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+					}
+				
+				}				
+#endif
+
+				//when set_ssid/set_bssid for do_join(), but there are no desired bss in scanning queue
+				//we try to issue sitesurvey firstly			
+				if(pmlmepriv->sitesurveyctrl.traffic_busy==_FALSE)
+				{
+					//printk("do_join() when   no desired bss in scanning queue \n");
+					rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+				}				
+
+
+			}
+
+		}
+
+	}
+	
+exit:
+	
+_func_exit_;	
+
+	return ret;	
+}
+
+#ifdef PLATFORM_WINDOWS
+u8 pnp_set_power_wakeup(_adapter* padapter)
+{
+	u8 res=_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("==>pnp_set_power_wakeup!!!\n"));
+	
+	res = rtw_setstandby_cmd(padapter, 0);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<==pnp_set_power_wakeup!!!\n"));
+
+_func_exit_;
+	
+	return res;
+}
+
+u8 pnp_set_power_sleep(_adapter* padapter)
+{
+	u8 res=_SUCCESS;	
+	
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("==>pnp_set_power_sleep!!!\n"));
+	//DbgPrint("+pnp_set_power_sleep\n");
+
+	res = rtw_setstandby_cmd(padapter, 1);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<==pnp_set_power_sleep!!!\n"));
+
+_func_exit_;
+
+	return res;
+}
+
+u8 set_802_11_reload_defaults(_adapter * padapter, NDIS_802_11_RELOAD_DEFAULTS reloadDefaults)
+{
+_func_enter_;
+
+	switch( reloadDefaults)
+	{
+		case Ndis802_11ReloadWEPKeys:
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("SetInfo OID_802_11_RELOAD_DEFAULTS : Ndis802_11ReloadWEPKeys\n"));
+			break;
+	}
+
+	// SecClearAllKeys(Adapter);
+	// 8711 CAM was not for En/Decrypt only
+	// so, we can't clear all keys.
+	// should we disable WPAcfg (ox0088) bit 1-2, instead of clear all CAM
+	
+	//TO DO...
+
+_func_exit_;
+	
+	return _TRUE;
+}
+
+u8 set_802_11_test(_adapter* padapter, NDIS_802_11_TEST *test)
+{
+	u8 ret=_TRUE;
+	
+_func_enter_;
+
+	switch(test->Type)
+	{
+		case 1:
+			NdisMIndicateStatus(padapter->hndis_adapter, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, (PVOID)&test->AuthenticationEvent, test->Length - 8);
+			NdisMIndicateStatusComplete(padapter->hndis_adapter);
+			break;
+
+		case 2:
+			NdisMIndicateStatus(padapter->hndis_adapter, NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, (PVOID)&test->RssiTrigger, sizeof(NDIS_802_11_RSSI));
+			NdisMIndicateStatusComplete(padapter->hndis_adapter);
+			break;
+
+		default:
+			ret=_FALSE;
+			break;
+	}
+
+_func_exit_;
+
+	return ret;	
+}
+
+u8	set_802_11_pmkid(_adapter*	padapter, NDIS_802_11_PMKID *pmkid)
+{
+	u8	ret=_SUCCESS;
+
+	return ret;
+}
+
+#endif
+
+u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
+{	
+	_irqL irqL;	
+	u8 status=_TRUE;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+	
+_func_enter_;
+	
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
+		 ("+rtw_set_802_11_bssid: bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]));
+
+	if ((bssid[0]==0x00 && bssid[1]==0x00 && bssid[2]==0x00 && bssid[3]==0x00 && bssid[4]==0x00 &&bssid[5]==0x00) ||
+	    (bssid[0]==0xFF && bssid[1]==0xFF && bssid[2]==0xFF && bssid[3]==0xFF && bssid[4]==0xFF &&bssid[5]==0xFF))
+	{
+		status = _FALSE;
+		return status;
+	}
+		
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
+		 ("\n rtw_set_802_11_bssid: bssid= 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
+		  bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]));
+
+ 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	{
+	        RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("Set BSSID is not allowed under surveying || adhoc master || under linking, fw_state=0x%08x\n",
+			  get_fwstate(pmlmepriv)));
+		status = check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_BSSID;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
+
+		if (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == _TRUE)
+		{		
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE)
+				goto _Abort_Set_BSSID;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+		} else {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("Set BSSID not the same ssid\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_bssid=%02x:%02x:%02x:%02x:%02x:%02x\n", bssid[0],bssid[1],bssid[2],bssid[3],bssid[4],bssid[5]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("cur_bssid=%02x:%02x:%02x:%02x:%02x:%02x\n",
+				pmlmepriv->cur_network.network.MacAddress[0],pmlmepriv->cur_network.network.MacAddress[1],pmlmepriv->cur_network.network.MacAddress[2],
+				pmlmepriv->cur_network.network.MacAddress[3],pmlmepriv->cur_network.network.MacAddress[4],pmlmepriv->cur_network.network.MacAddress[5]));
+
+			rtw_disassoc_cmd(padapter);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE){
+				printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+				rtw_indicate_disconnect(padapter);
+			}
+
+			rtw_free_assoc_resources(padapter);
+
+			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}		
+		}
+	}
+
+	_rtw_memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
+	
+	pmlmepriv->assoc_by_bssid=_TRUE;
+	
+	status = do_join(padapter);
+
+	goto done;
+	
+_Abort_Set_BSSID:
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("rtw_set_802_11_bssid: _Abort_Set_BSSID\n"));
+
+done:
+	
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	
+_func_exit_;
+
+	return status;
+}
+
+u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
+{	
+	_irqL irqL;
+	u8 status = _TRUE;
+
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
+	_queue *queue = &pmlmepriv->scanned_queue;
+
+#ifdef PLATFORM_WINDOWS
+	LARGE_INTEGER	sys_time;
+	u32  diff_time,cur_time ;
+#endif
+
+	
+_func_enter_;
+	
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
+		 ("+rtw_set_802_11_ssid: ssid=[%s] fw_state=0x%08x\n",
+		  ssid->Ssid, get_fwstate(pmlmepriv)));
+
+	if(padapter->hw_init_completed==_FALSE){
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("set_ssid: hw_init_completed==_FALSE=>exit!!!\n"));
+		return _FALSE;
+	}
+		
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("Set SSID is not allowed under surveying || adhoc master || under linking\n"));
+		status = check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_SSID;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
+			 ("set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
+
+		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
+		    (_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == _TRUE))
+		{			
+			if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE))
+			{
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("Set SSID is the same ssid, fw_state=0x%08x\n",
+					  get_fwstate(pmlmepriv)));
+
+				if(rtw_is_same_ibss(padapter, pnetwork) == _FALSE)
+				{				
+					//if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again
+					rtw_disassoc_cmd(padapter);
+
+					if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE){
+						printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+						rtw_indicate_disconnect(padapter);
+					}
+						
+					rtw_free_assoc_resources(padapter);
+
+					if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
+						_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+						set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+					}
+				}
+				else
+				{
+				       goto _Abort_Set_SSID;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+			        }			
+			}			
+#ifdef CONFIG_LPS
+			else {
+				lps_ctrl_wk_cmd(padapter, LPS_CTRL_JOINBSS, 1);
+			}
+#endif
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("Set SSID not the same ssid\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_ssid=[%s] len=0x%x\n", ssid->Ssid, (unsigned int)ssid->SsidLength));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("assoc_ssid=[%s] len=0x%x\n", pmlmepriv->assoc_ssid.Ssid, (unsigned int)pmlmepriv->assoc_ssid.SsidLength));
+
+			rtw_disassoc_cmd(padapter);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE){				
+				printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+				rtw_indicate_disconnect(padapter);
+			}
+			
+			rtw_free_assoc_resources(padapter);
+
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}		
+	}
+
+#ifdef PLATFORM_WINDOWS
+	if (padapter->securitypriv.btkip_countermeasure==_TRUE)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_ssid:padapter->securitypriv.btkip_countermeasure==_TRUE\n"));
+		NdisGetCurrentSystemTime(&sys_time);	
+		cur_time=(u32)(sys_time.QuadPart/10);  // In micro-second.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_ssid:cur_time=0x%x\n",cur_time));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_ssid:psecuritypriv->last_mic_err_time=0x%x\n",padapter->securitypriv.btkip_countermeasure_time));
+		diff_time = cur_time -padapter->securitypriv.btkip_countermeasure_time; // In micro-second.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_ssid:diff_time=0x%x\n",diff_time));
+
+		if (diff_time > 60000000) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_ssid(): countermeasure time >60s.\n"));
+			padapter->securitypriv.btkip_countermeasure=_FALSE;
+		// Update MIC error time.
+			padapter->securitypriv.btkip_countermeasure_time=0;
+		} else {
+			// can't join  in 60 seconds.
+			status = _FALSE;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_ssid(): countermeasure time <60s.\n"));
+			goto _Abort_Set_SSID;
+		}
+	}
+#endif
+
+#ifdef PLATFORM_LINUX
+	if (padapter->securitypriv.btkip_countermeasure == _TRUE) {
+		status = _FALSE;
+            goto _Abort_Set_SSID;
+        }
+#endif
+
+	if (rtw_validate_ssid(ssid) == _FALSE) {
+		status = _FALSE;
+		goto _Abort_Set_SSID;
+	}
+
+	_rtw_memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(NDIS_802_11_SSID));
+	
+	pmlmepriv->assoc_by_bssid=_FALSE;
+	
+	status = do_join(padapter);
+
+	goto done;
+
+_Abort_Set_SSID:
+	
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+		 ("-rtw_set_802_11_ssid: _Abort_Set_SSID: status=%d\n", status));
+
+done:
+	
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	
+_func_exit_;
+
+	return status;
+	
+}
+
+u8 rtw_set_802_11_infrastructure_mode(_adapter* padapter, 
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	_irqL irqL;
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct	wlan_network	*cur_network = &pmlmepriv->cur_network;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE* pold_state = &(cur_network->network.InfrastructureMode);
+	
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_notice_,
+		 ("+rtw_set_802_11_infrastructure_mode: old=%d new=%d fw_state=0x%08x\n",
+		  *pold_state, networktype, pmlmepriv->fw_state));
+	
+	if(*pold_state != networktype)
+	{
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,(" change mode!"));
+		//DBG_871X("change mode, old_mode=%d, new_mode=%d, fw_state=0x%x\n", *pold_state, networktype, pmlmepriv->fw_state);
+
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) ||(*pold_state==Ndis802_11IBSS))
+			rtw_disassoc_cmd(padapter);
+
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)== _TRUE) )
+			rtw_free_assoc_resources(padapter);
+
+
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) || (*pold_state==Ndis802_11Infrastructure) ||(*pold_state==Ndis802_11IBSS))
+		{	
+			printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+			rtw_indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
+		}	
+	
+		if(*pold_state==Ndis802_11APMode)
+		{		
+			//todo: change to other mode from Ndis802_11APMode			
+			cur_network->join_res = -1;
+		}	
+		
+		*pold_state = networktype;
+		//printk("%s , cur_network->network.InfrastructureMode = %d \n",__FUNCTION__,cur_network->network.InfrastructureMode);
+
+				// clear WIFI_STATION_STATE; WIFI_AP_STATE; WIFI_ADHOC_STATE; WIFI_ADHOC_MASTER_STATE
+		//pmlmepriv->fw_state &= 0xffffff87;		
+		_clr_fwstate_(pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE);
+				
+		switch(networktype)
+		{
+			case Ndis802_11IBSS:
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+				break;
+				
+			case Ndis802_11Infrastructure:
+				set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+				break;
+				
+			case Ndis802_11APMode:
+				set_fwstate(pmlmepriv, WIFI_AP_STATE);
+				//rtw_indicate_connect(padapter);
+				break;
+
+			case Ndis802_11AutoUnknown:
+			case Ndis802_11InfrastructureMax:
+				break;                        				
+		}
+
+		//SecClearAllKeys(adapter);
+		
+		//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n",
+		//									pmlmepriv->fw_state ));
+
+		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	}
+
+_func_exit_;
+
+	return _TRUE;
+}
+
+
+u8 rtw_set_802_11_disassociate(_adapter *padapter)
+{
+	_irqL irqL;
+	struct mlme_priv * pmlmepriv = &padapter->mlmepriv;
+
+_func_enter_;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	{
+		
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_DISASSOCIATE: rtw_indicate_disconnect\n"));
+		printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+		rtw_disassoc_cmd(padapter);		
+		rtw_indicate_disconnect(padapter);
+		rtw_free_assoc_resources(padapter);			
+	}
+
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	
+_func_exit_;
+
+	return _TRUE;	
+}
+
+u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter)
+{	
+	_irqL	irqL;
+	struct	mlme_priv		*pmlmepriv= &padapter->mlmepriv;
+	u8	res=_TRUE;
+	
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("+rtw_set_802_11_bssid_list_scan(), fw_state=%x\n", pmlmepriv->fw_state));
+
+	if (padapter == NULL) {
+		res=_FALSE;
+		goto exit;
+	}
+	if (padapter->hw_init_completed==_FALSE){
+		res = _FALSE;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n===rtw_set_802_11_bssid_list_scan:hw_init_completed==_FALSE===\n"));
+		goto exit;
+	}
+	
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
+		(pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE))
+	{
+		// Scan or linking is in progress, do nothing.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", pmlmepriv->fw_state));
+		res = _TRUE;
+
+		if(check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== _TRUE){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n\n"));
+		} else {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###pmlmepriv->sitesurveyctrl.traffic_busy==_TRUE\n\n"));
+		}
+	} else {
+		NDIS_802_11_SSID ssid;
+		
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);		
+		
+		_rtw_memset((unsigned char*)&ssid, 0, sizeof(NDIS_802_11_SSID));
+		
+		res = rtw_sitesurvey_cmd(padapter, &ssid);
+		
+		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	}
+exit:
+	
+_func_exit_;
+
+	return res;	
+}
+
+u8 rtw_set_802_11_authentication_mode(_adapter* padapter, NDIS_802_11_AUTHENTICATION_MODE authmode) 
+{
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	int res;
+	u8 ret;
+	
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_auth.mode(): mode=%x\n", authmode));
+
+	psecuritypriv->ndisauthtype=authmode;
+	
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_authentication_mode:psecuritypriv->ndisauthtype=%d", psecuritypriv->ndisauthtype));
+	
+	if(psecuritypriv->ndisauthtype>3)
+		psecuritypriv->dot11AuthAlgrthm=dot11AuthAlgrthm_8021X;
+	
+	res=rtw_set_auth(padapter,psecuritypriv);
+	
+	if(res==_SUCCESS)
+		ret=_TRUE;
+	else
+		ret=_FALSE;
+	
+_func_exit_;
+
+	return ret;
+}
+
+u8 rtw_set_802_11_add_wep(_adapter* padapter, NDIS_802_11_WEP *wep){
+
+	u8		bdefaultkey;
+	u8		btransmitkey;
+	sint		keyid,res;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	u8		ret=_SUCCESS;
+
+_func_enter_;
+
+	bdefaultkey=(wep->KeyIndex & 0x40000000) > 0 ? _FALSE : _TRUE;   //for ???
+	btransmitkey= (wep->KeyIndex & 0x80000000) > 0 ? _TRUE  : _FALSE;	//for ???
+	keyid=wep->KeyIndex & 0x3fffffff;
+
+	if(keyid>4)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MgntActSet_802_11_ADD_WEP:keyid>4=>fail\n"));
+		ret=_FALSE;
+		goto exit;
+	}
+	
+	switch(wep->KeyLength)
+	{
+		case 5:
+			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:wep->KeyLength=5\n"));
+			break;
+		case 13:
+			psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:wep->KeyLength=13\n"));
+			break;
+		default:
+			psecuritypriv->dot11PrivacyAlgrthm=_NO_PRIVACY_;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:wep->KeyLength!=5 or 13\n"));
+			break;
+	}
+	
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:befor memcpy, wep->KeyLength=0x%x wep->KeyIndex=0x%x  keyid =%x\n",wep->KeyLength,wep->KeyIndex,keyid));
+
+	_rtw_memcpy(&(psecuritypriv->dot11DefKey[keyid].skey[0]),&(wep->KeyMaterial),wep->KeyLength);
+
+	psecuritypriv->dot11DefKeylen[keyid]=wep->KeyLength;
+
+	psecuritypriv->dot11PrivacyKeyIndex=keyid;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_WEP:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x \n",
+		psecuritypriv->dot11DefKey[keyid].skey[0],psecuritypriv->dot11DefKey[keyid].skey[1],psecuritypriv->dot11DefKey[keyid].skey[2],
+		psecuritypriv->dot11DefKey[keyid].skey[3],psecuritypriv->dot11DefKey[keyid].skey[4],psecuritypriv->dot11DefKey[keyid].skey[5],
+		psecuritypriv->dot11DefKey[keyid].skey[6],psecuritypriv->dot11DefKey[keyid].skey[7],psecuritypriv->dot11DefKey[keyid].skey[8],
+		psecuritypriv->dot11DefKey[keyid].skey[9],psecuritypriv->dot11DefKey[keyid].skey[10],psecuritypriv->dot11DefKey[keyid].skey[11],
+		psecuritypriv->dot11DefKey[keyid].skey[12]));
+
+	res=rtw_set_key(padapter,psecuritypriv, keyid);
+	
+	if(res==_FAIL)
+		ret= _FALSE;
+exit:
+	
+_func_exit_;
+
+	return ret;
+	
+}
+
+u8 rtw_set_802_11_remove_wep(_adapter* padapter, u32 keyindex){
+	
+	u8 ret=_SUCCESS;
+	
+_func_enter_;
+
+	if (keyindex >= 0x80000000 || padapter == NULL){
+		
+		ret=_FALSE;
+		goto exit;
+
+	}
+	else 
+	{
+		int res;
+		struct security_priv* psecuritypriv=&(padapter->securitypriv);
+		if( keyindex < 4 ){
+			
+			_rtw_memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
+			
+			res=rtw_set_key(padapter,psecuritypriv,keyindex);
+			
+			psecuritypriv->dot11DefKeylen[keyindex]=0;
+			
+			if(res==_FAIL)
+				ret=_FAIL;
+			
+		}
+		else
+		{			
+			ret=_FAIL;
+		}
+		
+	}
+	
+exit:	
+	
+_func_exit_;
+
+	return ret;
+	
+}
+
+u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
+
+	uint	encryptionalgo;
+	u8 * pbssid;
+	struct sta_info *stainfo;
+	u8	bgroup = _FALSE;
+	u8	bgrouptkey = _FALSE;//can be remove later
+	u8	ret=_SUCCESS;
+	
+_func_enter_;
+
+	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)){
+
+		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, 
+		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_KEY: ((key->KeyIndex & 0x80000000) == 0)[=%d] ",(int)(key->KeyIndex & 0x80000000) == 0));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_KEY:((key->KeyIndex & 0x40000000) > 0)[=%d]" , (int)(key->KeyIndex & 0x40000000) > 0));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActSet_802_11_ADD_KEY: key->KeyIndex=%d \n" ,(int)key->KeyIndex));
+		ret= _FAIL;
+		goto exit;
+	}
+
+	if(key->KeyIndex & 0x40000000)
+	{ 
+		// Pairwise key
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Pairwise key +++++\n"));
+	
+		pbssid=get_bssid(&padapter->mlmepriv);
+		stainfo=rtw_get_stainfo(&padapter->stapriv, pbssid);
+
+		if((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:( stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)\n"));
+			encryptionalgo=stainfo->dot118021XPrivacy;
+		}
+		else{
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: stainfo==NULL)||(Adapter->securitypriv.dot11AuthAlgrthm!=dot11AuthAlgrthm_8021X)\n"));
+			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (encryptionalgo ==%d)!\n",encryptionalgo ));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (Adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",padapter->securitypriv.dot11PrivacyAlgrthm));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (Adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",padapter->securitypriv.dot11AuthAlgrthm));
+
+		if((stainfo!=NULL)){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Set_802_11_ADD_KEY: (stainfo->dot118021XPrivacy ==%d)!\n", stainfo->dot118021XPrivacy));
+		}
+		
+		if(key->KeyIndex & 0x000000FF){
+			// The key index is specified in the lower 8 bits by values of zero to 255.
+			// The key index should be set to zero for a Pairwise key, and the driver should fail with
+			// NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" key->KeyIndex & 0x000000FF.\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// check BSSID
+		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == _TRUE){
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MacAddr_isBcst(key->BSSID)\n"));
+			ret= _FALSE;
+			goto exit;
+		}
+
+		// Check key length for TKIP.
+		//if(encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
+		if((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)){
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
+			ret=_FAIL;
+			goto exit;
+
+		}
+
+		// Check key length for AES.
+		if((encryptionalgo== _AES_)&& (key->KeyLength != 16)) {
+			// For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case.
+			if(key->KeyLength == 32) {
+				key->KeyLength = 16; 
+			} else {
+				ret= _FAIL;
+				goto exit;
+			}
+		}
+
+		// Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko.
+		if(	(encryptionalgo== _WEP40_|| encryptionalgo== _WEP104_) && (key->KeyLength != 5 || key->KeyLength != 13)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));
+			ret=_FAIL;
+			goto exit;
+		}
+
+		bgroup = _FALSE;
+
+		// Check the pairwise key. Added by Annie, 2005-07-06.
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Pairwise Key set]\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+	
+	}
+	else 
+	{	
+		// Group key - KeyIndex(BIT30==0)
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));
+
+
+		// when add wep key through add key and didn't assigned encryption type before
+		if((padapter->securitypriv.ndisauthtype<=3)&&(padapter->securitypriv.dot118021XGrpPrivacy==0))
+		{
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("keylen=%d( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n", key->KeyLength,padapter->securitypriv.dot11PrivacyAlgrthm,padapter->securitypriv.dot118021XGrpPrivacy));
+
+			switch(key->KeyLength)
+			{
+				case 5:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u\n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
+					break;
+				case 13:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u\n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
+					break;
+				default:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u \n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
+					break;
+			}
+			
+			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
+			
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" Adapter->securitypriv.dot11PrivacyAlgrthm=%x\n", padapter->securitypriv.dot11PrivacyAlgrthm));
+			
+		}
+		else 
+		{
+			encryptionalgo=padapter->securitypriv.dot118021XGrpPrivacy;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )encryptionalgo(%x)=padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n", padapter->securitypriv.dot11PrivacyAlgrthm,encryptionalgo,padapter->securitypriv.dot118021XGrpPrivacy,key->KeyLength));
+
+		}
+		
+		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==_TRUE) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == _FALSE)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" IBSS but BSSID is not Broadcast Address.\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// Check key length for TKIP
+		if((encryptionalgo== _TKIP_) && (key->KeyLength != 32)) {
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
+			ret= _FAIL;
+			goto exit;
+
+		} else if(encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32) ) {
+			
+			// Check key length for AES
+			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
+		if((encryptionalgo==  _AES_) && (key->KeyLength == 32) ) {
+			key->KeyLength = 16; 
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength) );
+		}
+
+		if(key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
+			bgrouptkey = _TRUE;
+		}
+
+		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==_TRUE)&&(check_fwstate(&padapter->mlmepriv, _FW_LINKED)==_TRUE))
+		{
+			bgrouptkey = _TRUE;
+		}
+
+		bgroup = _TRUE;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n") );
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Group Key set]\n") );
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n")) ;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength)) ;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+		
+	}	
+
+	// If WEP encryption algorithm, just call rtw_set_802_11_add_wep().
+	if((padapter->securitypriv.dot11AuthAlgrthm !=dot11AuthAlgrthm_8021X)&&(encryptionalgo== _WEP40_  || encryptionalgo== _WEP104_))
+	{
+		u8 ret;		
+		u32 keyindex;		
+		u32 len = FIELD_OFFSET(NDIS_802_11_KEY, KeyMaterial) + key->KeyLength;
+		NDIS_802_11_WEP *wep = &padapter->securitypriv.ndiswep;
+				
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ WEP key +++++\n"));
+
+		wep->Length = len;
+		keyindex = key->KeyIndex&0x7fffffff;
+		wep->KeyIndex = keyindex ;
+		wep->KeyLength = key->KeyLength;
+		
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:Before memcpy \n"));
+
+		_rtw_memcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);	
+		_rtw_memcpy(&(padapter->securitypriv.dot11DefKey[keyindex].skey[0]), key->KeyMaterial, key->KeyLength);
+
+		padapter->securitypriv.dot11DefKeylen[keyindex]=key->KeyLength;		
+		padapter->securitypriv.dot11PrivacyKeyIndex=keyindex;
+		
+		ret = rtw_set_802_11_add_wep(padapter, wep);
+	
+		goto exit;
+		
+	}
+
+	if(key->KeyIndex & 0x20000000){
+		// SetRSC
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
+		if(bgroup == _TRUE)
+		{
+			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
+			_rtw_memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);			
+		} 
+		else 
+		{		
+			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;	
+			_rtw_memcpy(&padapter->securitypriv.dot11Grptxpn, &keysrc, 8);			
+		}
+			
+	}
+
+	// Indicate this key idx is used for TX
+	// Save the key in KeyMaterial
+	if(bgroup == _TRUE) // Group transmit key
+	{
+		int res;
+		
+		if(bgrouptkey == _TRUE)
+		{		
+			padapter->securitypriv.dot118021XGrpKeyid=(u8)key->KeyIndex;
+		}
+		
+		if((key->KeyIndex&0x3) == 0){
+			ret = _FAIL;
+			goto exit;
+		}		
+		
+		_rtw_memset(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex-1) & 0x03)], 0, 16);
+		_rtw_memset(&padapter->securitypriv.dot118021XGrptxmickey, 0, 16);
+		_rtw_memset(&padapter->securitypriv.dot118021XGrprxmickey, 0, 16);
+		
+		if((key->KeyIndex & 0x10000000))
+		{
+			_rtw_memcpy(&padapter->securitypriv.dot118021XGrptxmickey, key->KeyMaterial + 16, 8);
+			_rtw_memcpy(&padapter->securitypriv.dot118021XGrprxmickey, key->KeyMaterial + 24, 8);
+			
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+				padapter->securitypriv.dot118021XGrprxmickey.skey[0],padapter->securitypriv.dot118021XGrprxmickey.skey[1],
+				padapter->securitypriv.dot118021XGrprxmickey.skey[2],padapter->securitypriv.dot118021XGrprxmickey.skey[3],
+				padapter->securitypriv.dot118021XGrprxmickey.skey[4],padapter->securitypriv.dot118021XGrprxmickey.skey[5],
+				padapter->securitypriv.dot118021XGrprxmickey.skey[6],padapter->securitypriv.dot118021XGrprxmickey.skey[7]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));
+
+		}
+		else
+		{
+			_rtw_memcpy(&padapter->securitypriv.dot118021XGrptxmickey, key->KeyMaterial + 24, 8);
+			_rtw_memcpy(&padapter->securitypriv.dot118021XGrprxmickey, key->KeyMaterial + 16, 8);
+			
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+				padapter->securitypriv.dot118021XGrprxmickey.skey[0],padapter->securitypriv.dot118021XGrprxmickey.skey[1],
+				padapter->securitypriv.dot118021XGrprxmickey.skey[2],padapter->securitypriv.dot118021XGrprxmickey.skey[3],
+				padapter->securitypriv.dot118021XGrprxmickey.skey[4],padapter->securitypriv.dot118021XGrprxmickey.skey[5],
+				padapter->securitypriv.dot118021XGrprxmickey.skey[6],padapter->securitypriv.dot118021XGrprxmickey.skey[7]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));
+		
+		}
+
+		//set group key by index
+		_rtw_memcpy(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex-1) & 0x03)], key->KeyMaterial, key->KeyLength);
+		
+		key->KeyIndex=key->KeyIndex & 0x03;
+		
+		padapter->securitypriv.binstallGrpkey=_TRUE;
+		
+		padapter->securitypriv.bcheck_grpkey=_FALSE;
+		
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("reset group key"));
+		
+		res=rtw_set_key(padapter,&padapter->securitypriv, key->KeyIndex);
+
+		if(res==_FAIL)
+			ret= _FAIL;
+
+		goto exit;
+			
+	}
+	else // Pairwise Key
+	{
+		u8 res;
+		
+		pbssid=get_bssid(&padapter->mlmepriv);
+		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
+		
+		if(stainfo!=NULL)
+		{			
+			_rtw_memset( &stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
+			
+			_rtw_memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
+			
+			if(encryptionalgo== _TKIP_)
+			{
+				padapter->securitypriv.busetkipkey=_FALSE;
+				
+				_set_timer(&padapter->securitypriv.tkip_timer, 50);
+				
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n ==========_set_timer\n"));
+				
+				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
+				if((key->KeyIndex & 0x10000000)){
+					_rtw_memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
+					_rtw_memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
+
+				} else {
+					_rtw_memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 24, 8);
+					_rtw_memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 16, 8);
+
+				}
+		
+			}
+			else if(encryptionalgo == _AES_)
+			{		
+	
+			}
+
+		
+			//Set key to CAM through H2C command
+			if(bgrouptkey)//never go to here
+			{
+				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, _FALSE);
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
+			}
+			else{
+				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, _TRUE);
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
+			}
+			
+			if(res ==_FALSE)
+				ret= _FAIL;
+			
+		}
+
+	}
+
+exit:
+	
+_func_exit_;
+
+	return ret;	
+}
+
+u8 rtw_set_802_11_remove_key(_adapter*	padapter, NDIS_802_11_REMOVE_KEY *key){
+	
+	uint				encryptionalgo;
+	u8 * pbssid;
+	struct sta_info *stainfo;
+	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? _FALSE: _TRUE;
+	u8	keyIndex = (u8)key->KeyIndex & 0x03;
+	u8	ret=_SUCCESS;
+	
+_func_enter_;
+
+	if ((key->KeyIndex & 0xbffffffc) > 0) {
+		ret=_FAIL;
+		goto exit;
+	}
+
+	if (bgroup == _TRUE) {
+		encryptionalgo= padapter->securitypriv.dot118021XGrpPrivacy;
+		// clear group key by index
+		//NdisZeroMemory(Adapter->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN);
+		//Adapter->MgntInfo.SecurityInfo.KeyLen[keyIndex] = 0;
+		
+		_rtw_memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex-1], 0, 16);
+		
+		//! \todo Send a H2C Command to Firmware for removing this Key in CAM Entry.
+	
+	} else {
+	
+		pbssid=get_bssid(&padapter->mlmepriv);
+		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
+		if(stainfo !=NULL){
+			encryptionalgo=stainfo->dot118021XPrivacy;
+
+		// clear key by BSSID
+		_rtw_memset(&stainfo->dot118021x_UncstKey, 0, 16);
+		
+		//! \todo Send a H2C Command to Firmware for disable this Key in CAM Entry.
+
+		}
+		else{
+			ret= _FAIL;
+			goto exit;
+		}
+	}
+
+exit:
+	
+_func_exit_;
+
+	return _TRUE;
+	
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mlme.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mlme.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mlme.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mlme.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,3108 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_MLME_C_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/smp_lock.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#endif
+
+
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+#include <hal_init.h>
+#include <mlme_osdep.h>
+#include <sta_info.h>
+#include <wifi.h>
+#include <wlan_bssdef.h>
+#include <rtw_ioctl_set.h>
+
+sint	_rtw_init_mlme_priv (_adapter* padapter)
+{
+	sint	i;
+	u8	*pbuf;
+	struct wlan_network	*pnetwork;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	sint	res=_SUCCESS;
+
+_func_enter_;
+
+	_rtw_memset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));
+	pmlmepriv->nic_hdl = (u8 *)padapter;
+
+	pmlmepriv->pscanned = NULL;
+	pmlmepriv->fw_state = 0;
+	pmlmepriv->cur_network.network.InfrastructureMode = Ndis802_11AutoUnknown;
+	pmlmepriv->scan_mode=SCAN_ACTIVE;// 1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff)
+
+	_rtw_spinlock_init(&(pmlmepriv->lock));	
+	_rtw_init_queue(&(pmlmepriv->free_bss_pool));
+	_rtw_init_queue(&(pmlmepriv->scanned_queue));
+
+	set_scanned_network_val(pmlmepriv, 0);
+	
+	_rtw_memset(&pmlmepriv->assoc_ssid,0,sizeof(NDIS_802_11_SSID));
+
+	pbuf = _rtw_zmalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
+	
+	if (pbuf == NULL){
+		res=_FAIL;
+		goto exit;
+	}
+	pmlmepriv->free_bss_buf = pbuf;
+		
+	pnetwork = (struct wlan_network *)pbuf;
+	
+	for(i = 0; i < MAX_BSS_CNT; i++)
+	{		
+		_rtw_init_listhead(&(pnetwork->list));
+
+		rtw_list_insert_tail(&(pnetwork->list), &(pmlmepriv->free_bss_pool.queue));
+
+		pnetwork++;
+	}
+
+	//pbuf = _rtw_zmalloc(sizeof(struct sitesurvey_ctrl));
+
+	pmlmepriv->sitesurveyctrl.last_rx_pkts=0;
+	pmlmepriv->sitesurveyctrl.last_tx_pkts=0;
+	pmlmepriv->sitesurveyctrl.traffic_busy=_FALSE;
+	
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+
+	rtw_init_mlme_timer(padapter);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}	
+
+static void mfree_mlme_priv_lock (struct mlme_priv *pmlmepriv)
+{
+	_rtw_spinlock_free(&pmlmepriv->lock);
+	_rtw_spinlock_free(&(pmlmepriv->free_bss_pool.lock));
+	_rtw_spinlock_free(&(pmlmepriv->scanned_queue.lock));
+}
+
+static void _free_mlme_priv (struct mlme_priv *pmlmepriv)
+{
+_func_enter_;
+
+	if(pmlmepriv){
+		mfree_mlme_priv_lock (pmlmepriv);
+
+		if (pmlmepriv->free_bss_buf)
+			_rtw_mfree(pmlmepriv->free_bss_buf, MAX_BSS_CNT * sizeof(struct wlan_network));
+	}
+_func_exit_;	
+}
+
+sint	_rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
+{
+	_irqL irqL;
+
+_func_enter_;	
+
+	if (pnetwork == NULL)
+		goto exit;
+	
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	rtw_list_insert_tail(&pnetwork->list, &queue->queue);
+
+	_exit_critical_bh(&queue->lock, &irqL);
+
+exit:	
+
+_func_exit_;		
+
+	return _SUCCESS;
+}
+
+struct	wlan_network *_rtw_dequeue_network(_queue *queue)
+{
+	_irqL irqL;
+
+	struct wlan_network *pnetwork;
+
+_func_enter_;	
+
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	if (_rtw_queue_empty(queue) == _TRUE)
+
+		pnetwork = NULL;
+	
+	else
+	{
+		pnetwork = LIST_CONTAINOR(get_next(&queue->queue), struct wlan_network, list);
+		
+		list_delete(&(pnetwork->list));
+	}
+	
+	_exit_critical_bh(&queue->lock, &irqL);
+
+_func_exit_;		
+
+	return pnetwork;
+}
+
+struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv )//(_queue *free_queue)
+{
+	_irqL	irqL;
+	struct	wlan_network	*pnetwork;	
+	_queue *free_queue = &pmlmepriv->free_bss_pool;
+	_list* plist = NULL;
+	
+_func_enter_;	
+
+	_enter_critical_bh(&free_queue->lock, &irqL);
+	
+	if (_rtw_queue_empty(free_queue) == _TRUE) {
+		pnetwork=NULL;
+		goto exit;
+	}
+	plist = get_next(&(free_queue->queue));
+	
+	pnetwork = LIST_CONTAINOR(plist , struct wlan_network, list);
+	
+	list_delete(&pnetwork->list);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("_rtw_alloc_network: ptr=%p\n", plist));
+	pnetwork->network_type = 0;
+	pnetwork->fixed = _FALSE;
+	pnetwork->last_scanned = rtw_get_current_time();
+	pnetwork->aid=0;	
+	pnetwork->join_res=0;
+	
+	pmlmepriv->num_of_scanned ++;
+	
+exit:
+	_exit_critical_bh(&free_queue->lock, &irqL);
+
+_func_exit_;		
+
+	return pnetwork;	
+}
+
+void _rtw_free_network(struct	mlme_priv *pmlmepriv ,struct wlan_network *pnetwork,u8 isfreeall)
+{
+	u32 curr_time, delta_time;
+	u32 lifetime = SCANQUEUE_LIFETIME;
+	_irqL irqL;	
+	_queue *free_queue = &(pmlmepriv->free_bss_pool);
+	
+_func_enter_;		
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	if (pnetwork->fixed == _TRUE)
+		goto exit;
+
+	curr_time = rtw_get_current_time();	
+
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) || 
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
+		lifetime = 1;
+	
+	if(!isfreeall)
+	{
+#ifdef PLATFORM_WINDOWS
+
+	delta_time = (curr_time -pnetwork->last_scanned)/10;
+
+	if(delta_time  < lifetime*1000000)// unit:usec
+	{
+		goto exit;
+	}
+	
+#endif
+
+#ifdef PLATFORM_LINUX
+
+	delta_time = (curr_time -pnetwork->last_scanned)/HZ;	
+
+	if(delta_time < lifetime)// unit:sec
+	{		
+		goto exit;
+	}
+	
+#endif
+	}
+
+	_enter_critical_bh(&free_queue->lock, &irqL);
+	
+	list_delete(&(pnetwork->list));
+
+	rtw_list_insert_tail(&(pnetwork->list),&(free_queue->queue));
+		
+	pmlmepriv->num_of_scanned --;
+	
+
+	//DBG_871X("_rtw_free_network:SSID=%s\n", pnetwork->network.Ssid.Ssid);
+	
+	_exit_critical_bh(&free_queue->lock, &irqL);
+	
+exit:		
+	
+_func_exit_;			
+
+}
+
+static void _free_network_nolock(struct	mlme_priv *pmlmepriv, struct wlan_network *pnetwork)
+{
+
+	_queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+_func_enter_;		
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	if (pnetwork->fixed == _TRUE)
+		goto exit;
+
+	//_enter_critical(&free_queue->lock, &irqL);
+	
+	list_delete(&(pnetwork->list));
+
+	rtw_list_insert_tail(&(pnetwork->list), get_list_head(free_queue));
+		
+	pmlmepriv->num_of_scanned --;
+	
+	//_exit_critical(&free_queue->lock, &irqL);
+	
+exit:		
+
+_func_exit_;			
+
+}
+
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context... to avoid possible racing condition...
+*/
+struct wlan_network *_rtw_find_network(_queue *scanned_queue, u8 *addr)
+{
+
+	_irqL irqL;
+	_list	*phead, *plist;
+	struct	wlan_network *pnetwork = NULL;
+	u8 zero_addr[ETH_ALEN] = {0,0,0,0,0,0};
+	
+_func_enter_;	
+
+	if(_rtw_memcmp(zero_addr, addr, ETH_ALEN)){
+		pnetwork=NULL;
+		goto exit;
+		}
+	
+	_enter_critical_bh(&scanned_queue->lock, &irqL);
+	
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+	 
+	while (plist != phead)
+       {
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network ,list);
+		
+		if (_rtw_memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)
+                        break;
+
+		plist = get_next(plist);
+        }
+
+	if(plist==phead)
+		pnetwork=NULL;
+
+	_exit_critical_bh(&scanned_queue->lock, &irqL);
+	
+exit:		
+	
+_func_exit_;		
+
+	return pnetwork;
+	
+}
+
+
+void _rtw_free_network_queue(_adapter *padapter,u8 isfreeall)
+{
+	_irqL irqL;
+	_list *phead, *plist;
+	struct wlan_network *pnetwork;
+	struct mlme_priv* pmlmepriv = &padapter->mlmepriv;
+	_queue *scanned_queue = &pmlmepriv->scanned_queue;
+	_queue	*free_queue = &pmlmepriv->free_bss_pool;
+	u8 *mybssid = get_bssid(pmlmepriv);
+
+_func_enter_;	
+	
+
+	_enter_critical_bh(&scanned_queue->lock, &irqL);
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+
+	while (rtw_end_of_queue_search(phead, plist) == _FALSE)
+	{
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		plist = get_next(plist);
+
+		_rtw_free_network(pmlmepriv,pnetwork,isfreeall);
+		
+	}
+
+	_exit_critical_bh(&scanned_queue->lock, &irqL);
+	
+_func_exit_;		
+
+}
+
+
+
+
+sint rtw_if_up(_adapter *padapter)	{
+
+	sint res;
+_func_enter_;		
+
+	if( padapter->bDriverStopped || padapter->bSurpriseRemoved ||
+		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== _FALSE)){		
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));	
+		res=_FALSE;
+	}
+	else
+		res=  _TRUE;
+	
+_func_exit_;
+	return res;
+}
+
+
+void rtw_generate_random_ibss(u8* pibss)
+{
+	u32	curtime = rtw_get_current_time();
+
+_func_enter_;
+	pibss[0] = 0x02;  //in ad-hoc mode bit1 must set to 1
+	pibss[1] = 0x11;
+	pibss[2] = 0x87;
+	pibss[3] = (u8)(curtime & 0xff) ;//p[0];
+	pibss[4] = (u8)((curtime>>8) & 0xff) ;//p[1];
+	pibss[5] = (u8)((curtime>>16) & 0xff) ;//p[2];
+_func_exit_;
+	return;
+}
+u8 *rtw_get_capability_from_ie(u8 *ie)
+{
+	return (ie + 8 + 2);
+}
+
+
+u16 rtw_get_capability(WLAN_BSSID_EX *bss)
+{
+	u16	val;
+_func_enter_;	
+	_rtw_memcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2); 
+_func_exit_;		
+	return le16_to_cpu(val);
+}
+
+u8 *rtw_get_timestampe_from_ie(u8 *ie)
+{
+	return (ie + 0);	
+}
+
+u8 *rtw_get_beacon_interval_from_ie(u8 *ie)
+{
+	return (ie + 8);	
+}
+
+
+int	rtw_init_mlme_priv (_adapter *padapter)//(struct	mlme_priv *pmlmepriv)
+{
+	int	res;
+_func_enter_;	
+	res = _rtw_init_mlme_priv(padapter);// (pmlmepriv);
+_func_exit_;	
+	return res;
+}
+
+void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
+{
+_func_enter_;
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_mlme_priv\n"));
+	_free_mlme_priv (pmlmepriv);
+_func_exit_;	
+}
+
+static int	enqueue_network(_queue *queue, struct wlan_network *pnetwork)
+{
+	int	res;
+_func_enter_;		
+	res = _rtw_enqueue_network(queue, pnetwork);
+_func_exit_;		
+	return res;
+}
+
+
+
+static struct	wlan_network *dequeue_network(_queue *queue)
+{
+	struct wlan_network *pnetwork;
+_func_enter_;		
+	pnetwork = _rtw_dequeue_network(queue);
+_func_exit_;		
+	return pnetwork;
+}
+
+
+static struct	wlan_network *alloc_network(struct	mlme_priv *pmlmepriv )//(_queue	*free_queue)
+{
+	struct	wlan_network	*pnetwork;
+_func_enter_;			
+	pnetwork = _rtw_alloc_network(pmlmepriv);
+_func_exit_;			
+	return pnetwork;
+}
+
+void rtw_free_network(struct mlme_priv *pmlmepriv, struct	wlan_network *pnetwork,u8 is_freeall )//(struct	wlan_network *pnetwork, _queue	*free_queue)
+{
+_func_enter_;		
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
+	_rtw_free_network(pmlmepriv, pnetwork,is_freeall);
+_func_exit_;		
+}
+
+
+static void free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork )
+{
+_func_enter_;		
+	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
+	_free_network_nolock(pmlmepriv, pnetwork);
+_func_exit_;		
+}
+
+
+void rtw_free_network_queue(_adapter* dev,u8 isfreeall)
+{
+_func_enter_;		
+	_rtw_free_network_queue(dev,isfreeall);
+_func_exit_;			
+}
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context... to avoid possible racing condition...
+*/
+static struct	wlan_network *find_network(_queue *scanned_queue, u8 *addr)
+{
+	struct	wlan_network *pnetwork = _rtw_find_network(scanned_queue, addr);
+
+	return pnetwork;
+}
+
+int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork)
+{
+	int ret=_TRUE;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if ( (psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_ ) &&
+		    ( pnetwork->network.Privacy == 0 ) )
+	{
+		ret=_FALSE;
+	}
+	else if((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_ ) &&
+		 ( pnetwork->network.Privacy == 1 ) )
+	{
+		ret=_FALSE;
+	}
+	else
+	{
+		ret=_TRUE;
+	}
+	
+	return ret;
+	
+}
+
+static int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst)
+{
+	 u16 s_cap, d_cap;
+	 
+_func_enter_;	
+
+#ifdef PLATFORM_OS_XP
+	 if ( ((uint)dst) <= 0x7fffffff || 
+	 	((uint)src) <= 0x7fffffff ||
+	 	((uint)&s_cap) <= 0x7fffffff ||
+	 	((uint)&d_cap) <= 0x7fffffff)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n@@@@ error address of dst\n"));
+			
+		KeBugCheckEx(0x87110000, (ULONG_PTR)dst, (ULONG_PTR)src,(ULONG_PTR)&s_cap, (ULONG_PTR)&d_cap);
+
+		return _FALSE;
+	}
+#endif
+
+	_rtw_memcpy((u8 *)&s_cap, rtw_get_capability_from_ie(src->IEs), 2);
+	_rtw_memcpy((u8 *)&d_cap, rtw_get_capability_from_ie(dst->IEs), 2);
+	
+	s_cap = le16_to_cpu(s_cap);
+	d_cap = le16_to_cpu(d_cap);
+	
+_func_exit_;			
+
+	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
+			(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
+			( (_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == _TRUE) &&
+			( (_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == _TRUE) &&
+			((s_cap & WLAN_CAPABILITY_IBSS) == 
+			(d_cap & WLAN_CAPABILITY_IBSS)) &&
+			((s_cap & WLAN_CAPABILITY_BSS) == 
+			(d_cap & WLAN_CAPABILITY_BSS)));
+	
+}
+
+struct	wlan_network	* rtw_get_oldest_wlan_network(_queue *scanned_queue)
+{
+	_list	*plist, *phead;
+
+	
+	struct	wlan_network	*pwlan = NULL;
+	struct	wlan_network	*oldest = NULL;
+_func_enter_;		
+	phead = get_list_head(scanned_queue);
+	
+	plist = get_next(phead);
+
+	while(1)
+	{
+		
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+		
+		pwlan= LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		if(pwlan->fixed!=_TRUE)
+		{		
+			if (oldest == NULL ||time_after(oldest->last_scanned, pwlan->last_scanned))
+				oldest = pwlan;
+		}
+		
+		plist = get_next(plist);
+	}
+_func_exit_;		
+	return oldest;
+	
+}
+
+static void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,_adapter * padapter)
+{
+	u32 last_evm = 0, tmpVal;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+_func_enter_;		
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+		if((0 != pHalData->AntDivCfg) && (!IS_92C_SERIAL(pHalData->VersionID)) )
+		{
+			
+			//printk("update_network=> orgRSSI(%d)(%d),newRSSI(%d)(%d)\n",dst->Rssi,query_rx_pwr_percentage(dst->Rssi),
+			//	src->Rssi,query_rx_pwr_percentage(src->Rssi));
+			//select optimum_antenna for before linked =>For antenna diversity
+			if(dst->Rssi >=  src->Rssi )//keep org parameter
+			{
+				src->Rssi = dst->Rssi;
+				src->PhyInfo.Optimum_antenna = dst->PhyInfo.Optimum_antenna;						
+			}			
+		}
+	
+#endif
+	_rtw_memcpy((u8 *)dst, (u8 *)src, get_WLAN_BSSID_EX_sz(src));
+#ifdef CONFIG_ANTENNA_DIVERSITY
+//	printk("## update_network=> RSSI(%d),Ant_(%s)\n",dst->Rssi,(2==dst->PhyInfo.Optimum_antenna)?"A":"B");
+#endif
+#if 0
+//	printk("update_network: rssi=0x%lx dst->Rssi=%d ,dst->Rssi=0x%lx , src->Rssi=0x%lx",(dst->Rssi+src->Rssi)/2,dst->Rssi,dst->Rssi,src->Rssi);
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) && is_same_network(&(padapter->mlmepriv.cur_network.network), src))
+	{
+	
+	//	printk("b:ssid=%s update_network: src->rssi=0x%d padapter->recvpriv.ui_rssi=%d\n",src->Ssid.Ssid,src->Rssi,padapter->recvpriv.signal);
+		if(padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
+	        {
+	              padapter->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
+	              last_evm = padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index];
+	              padapter->recvpriv.signal_qual_data.total_val -= last_evm;
+	        }
+               	padapter->recvpriv.signal_qual_data.total_val += query_rx_pwr_percentage(src->Rssi);
+
+              	padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = query_rx_pwr_percentage(src->Rssi);
+                if(padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
+                       padapter->recvpriv.signal_qual_data.index = 0;
+
+  //          printk("Total SQ=%d  pattrib->signal_qual= %d\n", padapter->recvpriv.signal_qual_data.total_val, src->Rssi);
+
+                // <1> Showed on UI for user,in percentage.
+              	tmpVal = padapter->recvpriv.signal_qual_data.total_val/padapter->recvpriv.signal_qual_data.total_num;
+                padapter->recvpriv.signal=(u8)tmpVal;//Link quality
+
+		src->Rssi= translate_percentage_to_dbm(padapter->recvpriv.signal) ;
+	}
+	else{
+//	printk("ELSE:ssid=%s update_network: src->rssi=0x%d dst->rssi=%d\n",src->Ssid.Ssid,src->Rssi,dst->Rssi);
+		src->Rssi=(src->Rssi +dst->Rssi)/2;//dBM
+	}	
+
+//	printk("a:update_network: src->rssi=0x%d padapter->recvpriv.ui_rssi=%d\n",src->Rssi,padapter->recvpriv.signal);
+
+#endif
+	
+_func_exit_;		
+}
+
+static void update_current_network(_adapter *adapter, WLAN_BSSID_EX *pnetwork)
+{
+	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);	
+	
+_func_enter_;		
+
+#ifdef PLATFORM_OS_XP
+	if ((unsigned long)(&(pmlmepriv->cur_network.network)) < 0x7ffffff)
+	{		
+		KeBugCheckEx(0x87111c1c, (ULONG_PTR)(&(pmlmepriv->cur_network.network)), 0, 0,0);
+	}
+#endif
+	
+	if ( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)))
+	{
+		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");	
+	//	printk("%s....is_same_network, ssid:%s mode(%d)\n",__FUNCTION__,
+	//	pmlmepriv->cur_network.network.Ssid.Ssid,pmlmepriv->cur_network.network.InfrastructureMode);
+		//if(pmlmepriv->cur_network.network.IELength<= pnetwork->IELength)
+		{
+			update_network(&(pmlmepriv->cur_network.network), pnetwork,adapter);
+		//printk("%s...mode(%d)\n",__FUNCTION__,pmlmepriv->cur_network.network.InfrastructureMode);
+			rtw_update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof (NDIS_802_11_FIXED_IEs), 
+									pmlmepriv->cur_network.network.IELength);
+		}	
+	}	
+	
+_func_exit_;			
+
+}
+
+
+/*
+
+Caller must hold pmlmepriv->lock first.
+
+
+*/
+void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
+{
+	_list	*plist, *phead;
+	
+	ULONG	bssid_ex_sz;
+	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(adapter);
+	_queue	*queue	= &(pmlmepriv->scanned_queue);	
+	struct	wlan_network	*pnetwork = NULL;
+	struct  wlan_network	*oldest = NULL;
+_func_enter_;			
+
+	
+	phead = get_list_head(queue);	
+	plist = get_next(phead);	
+	
+	while(1)
+	{
+		
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+		
+		pnetwork	= LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		if ((unsigned long)(pnetwork) < 0x7ffffff)
+		{
+#ifdef PLATFORM_OS_XP	
+				KeBugCheckEx(0x87111c1c, (ULONG_PTR)pnetwork, 0, 0,0);
+#endif
+		}
+
+		if (is_same_network(&(pnetwork->network), target))
+			break;
+		
+		if ((oldest == ((struct wlan_network *)0)) ||
+		time_after(oldest->last_scanned, pnetwork->last_scanned))
+			oldest = pnetwork;
+		
+		plist = get_next(plist);
+		
+	}
+
+	/* If we didn't find a match, then get a new network slot to initialize
+	 * with this beacon's information */
+	if (rtw_end_of_queue_search(phead,plist)== _TRUE) {
+		
+		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == _TRUE) {
+			/* If there are no more slots, expire the oldest */
+			//list_del_init(&oldest->list);
+			pnetwork = oldest;
+			
+//			printk("update_network: rssi=0x%lx ,pnetwork->network.Rssi=0x%lx , target->Rssi=0x%lx",(pnetwork->network.Rssi+target->Rssi)/2,pnetwork->network.Rssi,target->Rssi);
+
+			//target->Rssi=(pnetwork->network.Rssi+target->Rssi)/2;
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			target->PhyInfo.Optimum_antenna = pHalData->CurAntenna;//optimum_antenna=>For antenna diversity
+#endif
+			_rtw_memcpy(&(pnetwork->network), target,  get_WLAN_BSSID_EX_sz(target));
+			//variable initialize
+			pnetwork->fixed = _FALSE;			
+			pnetwork->last_scanned = rtw_get_current_time();
+
+			pnetwork->network_type = 0;	
+			pnetwork->aid=0;		
+			pnetwork->join_res=0;
+				
+
+		} else {
+			/* Otherwise just pull from the free list */
+			
+			pnetwork = alloc_network(pmlmepriv); // will update scan_time
+
+
+			if(pnetwork==NULL){ 
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n\nsomething wrong here\n\n\n"));
+				goto exit;
+			}
+			
+			bssid_ex_sz = get_WLAN_BSSID_EX_sz(target);
+			target->Length = bssid_ex_sz;
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			target->PhyInfo.Optimum_antenna = pHalData->CurAntenna;
+#endif		
+			_rtw_memcpy(&(pnetwork->network), target, bssid_ex_sz );
+
+			rtw_list_insert_tail(&(pnetwork->list),&(queue->queue)); 
+			
+		}	 
+	} 
+	else {//the same network 
+		/* we have an entry and we are going to update it. But this entry may
+		 * be already expired. In this case we do the same as we found a new 
+		 * net and call the new_net handler
+		 */
+
+		//target.Reserved[0]==1, means that scaned network is a bcn frame.
+		if((pnetwork->network.IELength>target->IELength) && (target->Reserved[0]==1))
+			goto exit;
+	
+		update_network(&(pnetwork->network),target,adapter);
+
+		pnetwork->last_scanned = rtw_get_current_time();
+
+	}
+
+exit:	
+
+_func_exit_;			
+
+}
+
+
+void rtw_add_network(_adapter *adapter, WLAN_BSSID_EX *pnetwork)
+{
+	_irqL irqL;
+	struct	mlme_priv	*pmlmepriv = &(((_adapter *)adapter)->mlmepriv);
+	_queue	*queue	= &(pmlmepriv->scanned_queue);
+
+_func_enter_;		
+
+	_enter_critical_bh(&queue->lock, &irqL);
+	
+	update_current_network(adapter, pnetwork);
+	
+	rtw_update_scanned_network(adapter, pnetwork);
+
+	_exit_critical_bh(&queue->lock, &irqL);
+	
+_func_exit_;		
+}
+
+//select the desired network based on the capability of the (i)bss.
+// check items: (1) security
+//			   (2) network_type
+//			   (3) WMM
+//			   (4) HT
+//                     (5) others
+static int is_desired_network(_adapter *adapter, struct wlan_network *pnetwork)
+{
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct registry_priv	 *pregpriv = &adapter->registrypriv;
+	u32 desired_encmode;
+	u32 privacy;
+
+	u8 wps_ie[512];
+	uint wps_ielen;
+
+	int bselected = _TRUE;
+	
+	desired_encmode = psecuritypriv->ndisencryptstatus;
+	privacy = pnetwork->network.Privacy;
+
+	if(psecuritypriv->wps_phase == _TRUE)
+	{
+		if(rtw_get_wps_ie(pnetwork->network.IEs, pnetwork->network.IELength, wps_ie, &wps_ielen)==_TRUE)
+		{
+			//rtw_disassoc_cmd(adapter);			
+			//rtw_indicate_disconnect(adapter);
+			//rtw_free_assoc_resources(adapter);
+			return _TRUE;
+		}
+		else
+		{	
+			return _FALSE;
+		}	
+	}
+	
+	if (pregpriv->wifi_spec == 1) //for  correct flow of 8021X  to do....
+	{
+		if ((desired_encmode == Ndis802_11EncryptionDisabled) && (privacy != 0))	
+				bselected = _FALSE;
+	}
+	
+
+ 	if ((desired_encmode != Ndis802_11EncryptionDisabled) && (privacy == 0))
+		bselected = _FALSE;
+
+	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+	{
+		if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+			bselected = _FALSE;
+	}	
+		
+
+	return bselected;
+}
+
+/* TODO: Perry : For Power Management */
+void rtw_atimdone_event_callback(_adapter	*adapter , u8 *pbuf)
+{
+
+_func_enter_;		
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("receive atimdone_evet\n"));	
+_func_exit_;			
+	return;	
+}
+
+
+void rtw_survey_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL  irqL;
+	u32 len;
+	WLAN_BSSID_EX *pnetwork;
+	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+
+_func_enter_;		
+
+	pnetwork = (WLAN_BSSID_EX *)pbuf;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_survey_event_callback, ssid=%s\n",  pnetwork->Ssid.Ssid));
+
+#ifdef CONFIG_RTL8712
+        //endian_convert
+ 	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+  	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);	
+	pnetwork->Privacy =le32_to_cpu( pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);	
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
+	pnetwork->Configuration.DSConfig =le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);	
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+#endif	
+
+	len = get_WLAN_BSSID_EX_sz(pnetwork);
+	if(len > (sizeof(WLAN_BSSID_EX)))
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n ****rtw_survey_event_callback: return a wrong bss ***\n"));
+		goto exit;
+	}
+
+
+#ifdef CONFIG_DRVEXT_MODULE
+	update_random_seed((void *)(adapter), pnetwork->IEs);	
+#endif
+
+
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+	// update IBSS_network 's timestamp
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == _TRUE)
+	{
+		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"rtw_survey_event_callback : WIFI_ADHOC_MASTER_STATE \n\n");
+		if(_rtw_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN))
+		{
+			struct wlan_network* ibss_wlan = NULL;
+			
+			_rtw_memcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);
+
+			ibss_wlan = find_network(&pmlmepriv->scanned_queue,  pnetwork->MacAddress);
+			if(ibss_wlan)
+			{
+				_rtw_memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);			
+				goto exit;
+			}
+		}
+	}
+
+	// lock pmlmepriv->lock when you accessing network_q
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _FALSE)
+	{		
+		if( pnetwork->Ssid.Ssid[0] == 0 )
+		{
+			pnetwork->Ssid.SsidLength = 0;
+		}	
+		rtw_add_network(adapter, pnetwork);
+	}
+
+exit:	
+		
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+_func_exit_;		
+
+	return;	
+}
+
+
+
+void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
+{
+	_irqL  irqL;
+	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+	
+#ifdef CONFIG_MLME_EXT	
+
+	mlmeext_surveydone_event_callback(adapter);
+
+#endif
+
+_func_enter_;			
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_surveydone_event_callback: fw_state:%x\n\n", pmlmepriv->fw_state));
+	
+	if  (pmlmepriv->fw_state & _FW_UNDER_SURVEY)
+	{
+		u8 timer_cancelled;
+		
+		_cancel_timer(&pmlmepriv->scan_to_timer, &timer_cancelled);
+		
+		pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;
+	}
+	else {
+	
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("nic status =%x, survey done event comes too late!\n", pmlmepriv->fw_state));	
+	}	
+	
+	if(pmlmepriv->to_join == _TRUE)
+	{
+		if((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE) )
+		{
+			if(check_fwstate(pmlmepriv, _FW_LINKED)==_FALSE)
+			{
+				pmlmepriv->fw_state |= _FW_UNDER_LINKING;	
+				
+		   		if(rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
+		   		{
+		       			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT );	 
+                  		}
+		   		else	
+		  		{
+					WLAN_BSSID_EX    *pdev_network = &(adapter->registrypriv.dev_network); 			
+					u8 *pibss = adapter->registrypriv.dev_network.MacAddress;
+
+					pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;//because don't set assoc_timer
+
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("switching to adhoc master\n"));
+				
+					_rtw_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+					_rtw_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+	
+					rtw_update_registrypriv_dev_network(adapter);
+					rtw_generate_random_ibss(pibss);
+
+                       			pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+			
+					if(rtw_createbss_cmd(adapter)!=_SUCCESS)
+					{
+	                     		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error=>rtw_createbss_cmd status FAIL\n"));						
+					}	
+
+			     		pmlmepriv->to_join = _FALSE;
+		   		}
+		 	}
+		}
+		else
+		{
+			if(rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
+			{
+                             pmlmepriv->fw_state |= _FW_UNDER_LINKING;		
+			     pmlmepriv->to_join = _FALSE;
+	     		     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);	 
+			} 
+			else
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("try_to_join, but select scanning queue fail\n"));
+			}			
+
+		}
+		
+	}
+
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);	
+
+	#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+	{
+		struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
+		
+		if(pmlmeext->sitesurvey_res.bss_cnt == 0)
+			silentreset_for_specific_platform(adapter);						
+	}
+	#endif	
+
+_func_exit_;	
+
+}
+
+static void free_scanqueue(struct	mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+	_queue *free_queue = &pmlmepriv->free_bss_pool;
+	_queue *scan_queue = &pmlmepriv->scanned_queue;
+	_list	*plist, *phead, *ptemp;
+	
+_func_enter_;		
+	
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));
+
+	_enter_critical_bh(&free_queue->lock, &irqL);
+
+	phead = get_list_head(scan_queue);
+	plist = get_next(phead);
+
+	while (plist != phead)
+       {
+		ptemp = get_next(plist);
+		list_delete(plist);
+		rtw_list_insert_tail(plist, &free_queue->queue);
+		plist =ptemp;
+		pmlmepriv->num_of_scanned --;
+        }
+	
+	_exit_critical_bh(&free_queue->lock, &irqL);
+	
+_func_exit_;
+}
+	
+/*
+*rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
+*/
+void rtw_free_assoc_resources(_adapter *adapter )
+{
+	_irqL irqL;
+	struct wlan_network* pwlan = NULL;
+     	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct 	mlme_ext_info *pmlmeinfo = &adapter->mlmeextpriv.mlmext_info;
+   	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	
+_func_enter_;			
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_free_assoc_resources\n"));
+
+	pwlan = find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("tgt_network->network.MacAddress=%02x:%02x:%02x:%02x:%02x:%02x ssid=%s\n",
+		tgt_network->network.MacAddress[0],tgt_network->network.MacAddress[1],
+		tgt_network->network.MacAddress[2],tgt_network->network.MacAddress[3],
+		tgt_network->network.MacAddress[4],tgt_network->network.MacAddress[5], 
+		tgt_network->network.Ssid.Ssid));
+
+	if(check_fwstate( pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE))
+	{
+		struct sta_info* psta;
+		
+		psta = rtw_get_stainfo(&adapter->stapriv, tgt_network->network.MacAddress);
+
+		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		rtw_free_stainfo(adapter,  psta);
+		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		
+	}
+
+	if(check_fwstate( pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
+	{
+		rtw_free_all_stainfo(adapter);
+	}
+
+	if(pwlan)		
+	{
+		pwlan->fixed = _FALSE;
+	}	
+	else
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_assoc_resources : pwlan== NULL \n\n"));
+	}
+
+
+	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (adapter->stapriv.asoc_sta_count== 1))
+		/*||check_fwstate(pmlmepriv, WIFI_STATION_STATE)*/)
+	{
+		free_network_nolock(pmlmepriv, pwlan); 
+	}	
+	pmlmeinfo->key_mask = 0;
+
+_func_exit_;	
+	
+}
+
+/*
+*rtw_indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void rtw_indicate_connect(_adapter *padapter)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	
+_func_enter_;	
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_indicate_connect\n"));
+ 
+	pmlmepriv->to_join = _FALSE;
+#ifdef CONFIG_ANTENNA_DIVERSITY	
+	SwAntDivRestAfterLink(padapter);
+#endif	
+	set_fwstate(pmlmepriv, _FW_LINKED);
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_LINK);
+
+	rtw_os_indicate_connect(padapter);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("-rtw_indicate_connect: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
+ 
+_func_exit_;
+}
+
+
+/*
+*rtw_indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void rtw_indicate_disconnect( _adapter *padapter )
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+
+_func_enter_;	
+	
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_indicate_disconnect\n"));
+
+	if((pmlmepriv->fw_state & _FW_LINKED))
+	{
+	        pmlmepriv->fw_state ^= _FW_LINKED;
+
+		padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);		
+		rtw_os_indicate_disconnect(padapter);
+		
+#ifdef CONFIG_LPS
+		lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 1);
+#endif
+ 	
+	}
+ 	
+_func_exit_;	
+
+}
+
+//Notes:
+//pnetwork : returns from rtw_joinbss_event_callback
+//ptarget_wlan: found from scanned_queue
+//if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist.	
+//if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist.
+//if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan !=NULL).
+//
+void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL,irqL2;
+	int	res;
+	static u8 retry=0;
+	u8 timer_cancelled;
+	struct sta_info *ptarget_sta= NULL, *pcur_sta = NULL;
+   	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+	struct wlan_network 	*pnetwork	= (struct wlan_network *)pbuf;
+	struct wlan_network 	*cur_network = &(pmlmepriv->cur_network);
+	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
+	unsigned int 		the_same_macaddr = _FALSE;	
+#ifdef CONFIG_DRVEXT_MODULE
+	int enable_wpa = 0, enable_wsc = 0;
+	struct drvext_priv *pdrvext = &adapter->drvextpriv;
+#endif
+
+_func_enter_;	
+
+#ifdef CONFIG_RTL8712
+       //endian_convert
+	pnetwork->join_res = le32_to_cpu(pnetwork->join_res);
+	pnetwork->network_type = le32_to_cpu(pnetwork->network_type);
+	pnetwork->network.Length = le32_to_cpu(pnetwork->network.Length);
+	pnetwork->network.Ssid.SsidLength = le32_to_cpu(pnetwork->network.Ssid.SsidLength);
+	pnetwork->network.Privacy =le32_to_cpu( pnetwork->network.Privacy);
+	pnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);
+	pnetwork->network.NetworkTypeInUse =le32_to_cpu(pnetwork->network.NetworkTypeInUse) ;	
+	pnetwork->network.Configuration.ATIMWindow = le32_to_cpu(pnetwork->network.Configuration.ATIMWindow);
+	pnetwork->network.Configuration.BeaconPeriod = le32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);
+	pnetwork->network.Configuration.DSConfig = le32_to_cpu(pnetwork->network.Configuration.DSConfig);
+	pnetwork->network.Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->network.Configuration.FHConfig.DwellTime);
+	pnetwork->network.Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopPattern);
+	pnetwork->network.Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);
+	pnetwork->network.Configuration.FHConfig.Length=le32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);	
+	pnetwork->network.Configuration.Length = le32_to_cpu(pnetwork->network.Configuration.Length);
+	pnetwork->network.InfrastructureMode = le32_to_cpu(pnetwork->network.InfrastructureMode);
+	pnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength );
+#endif
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("joinbss event call back received with res=%d\n", pnetwork->join_res));
+
+	rtw_get_encrypt_decrypt_from_registrypriv(adapter);
+	
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   joinbss event call back  for Any SSid\n"));		
+	}
+	else
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   rtw_joinbss_event_callback for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+	
+	the_same_macaddr = _rtw_memcmp(pnetwork->network.MacAddress, cur_network->network.MacAddress, ETH_ALEN);
+
+	pnetwork->network.Length = get_WLAN_BSSID_EX_sz(&pnetwork->network);
+	if(pnetwork->network.Length > sizeof(WLAN_BSSID_EX))
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n ***joinbss_evt_callback return a wrong bss ***\n\n"));
+		goto ignore_joinbss_callback;
+	}
+		
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_joinbss_event_callback !! _enter_critical \n"));
+
+	if(pnetwork->join_res > 0)
+	{
+		if ((pmlmepriv->fw_state) & _FW_UNDER_LINKING) 
+		{
+			//s1. find ptarget_wlan
+			if((pmlmepriv->fw_state) & _FW_LINKED)
+			{
+				if(the_same_macaddr == _TRUE)
+				{
+					ptarget_wlan = find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);					
+				}
+				else
+				{
+					pcur_wlan = find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+					if(pcur_wlan)	pcur_wlan->fixed = _FALSE;					
+
+					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+					if(pcur_sta){
+						_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						rtw_free_stainfo(adapter,  pcur_sta);
+						_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+					}
+
+					ptarget_wlan = find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE){
+						if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;			
+					}
+				}
+
+			}
+			else
+			{
+				ptarget_wlan = find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE){
+					if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;			
+				}
+			}
+		
+			if(ptarget_wlan == NULL)
+			{			
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't find ptarget_wlan when joinbss_event callback\n"));
+				goto ignore_joinbss_callback;
+			}
+					
+			//s2. find ptarget_sta & update ptarget_sta
+			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			{ 
+				if(the_same_macaddr == _TRUE)
+				{
+					ptarget_sta = rtw_get_stainfo(pstapriv, pnetwork->network.MacAddress);
+					if(ptarget_sta==NULL)
+					{
+						//printk("==> %s #1, call rtw_alloc_stainfo\n",__FUNCTION__);
+						ptarget_sta = rtw_alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
+					}	
+				}
+				else
+				{
+					//printk("==> %s #2, call rtw_alloc_stainfo\n",__FUNCTION__);
+					ptarget_sta = rtw_alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
+				}
+
+				if(ptarget_sta) //update ptarget_sta
+				{
+					ptarget_sta->aid  = pnetwork->join_res;					
+					ptarget_sta->qos_option = 1;//? 
+					ptarget_sta->mac_id=0;
+
+					if(adapter->securitypriv.dot11AuthAlgrthm== dot11AuthAlgrthm_8021X)
+					{						
+						adapter->securitypriv.binstallGrpkey=_FALSE;
+						adapter->securitypriv.busetkipkey=_FALSE;						
+						adapter->securitypriv.bgrpkey_handshake=_FALSE;
+
+						ptarget_sta->ieee8021x_blocked=_TRUE;
+						ptarget_sta->dot118021XPrivacy=adapter->securitypriv.dot11PrivacyAlgrthm;
+						
+						_rtw_memset((u8 *)&ptarget_sta->dot118021x_UncstKey, 0, sizeof (union Keytype));
+						
+						_rtw_memset((u8 *)&ptarget_sta->dot11tkiprxmickey, 0, sizeof (union Keytype));
+						_rtw_memset((u8 *)&ptarget_sta->dot11tkiptxmickey, 0, sizeof (union Keytype));
+						
+						_rtw_memset((u8 *)&ptarget_sta->dot11txpn, 0, sizeof (union pn48));	
+						_rtw_memset((u8 *)&ptarget_sta->dot11rxpn, 0, sizeof (union pn48));	
+					}		
+					
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't allocate stainfo when joinbss_event callback\n"));
+					goto ignore_joinbss_callback;
+				}
+				
+			}
+		
+			//s3. update cur_network & indicate connect
+			if(ptarget_wlan)
+			{			
+
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\nfw_state:%x, BSSID:%x:%x:%x:%x:%x:%x (fw_state=%d)\n",pmlmepriv->fw_state, 
+						pnetwork->network.MacAddress[0], pnetwork->network.MacAddress[1],
+						pnetwork->network.MacAddress[2], pnetwork->network.MacAddress[3],
+						pnetwork->network.MacAddress[4], pnetwork->network.MacAddress[5],
+						pmlmepriv->fw_state));
+
+			
+				_rtw_memcpy(&cur_network->network, &pnetwork->network, pnetwork->network.Length);
+				cur_network->aid = pnetwork->join_res;
+				
+				//update fw_state //will clr _FW_UNDER_LINKING here indirectly
+				switch(pnetwork->network.InfrastructureMode)
+				{
+					case Ndis802_11Infrastructure:						
+							pmlmepriv->fw_state = WIFI_STATION_STATE;
+							break;
+					case Ndis802_11IBSS:		
+							pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+							break;
+					default:
+							pmlmepriv->fw_state = WIFI_NULL_STATE;
+							RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Invalid network_mode\n"));
+							break;
+				}
+
+				rtw_update_protection(adapter, (cur_network->network.IEs) + sizeof (NDIS_802_11_FIXED_IEs), 
+									(cur_network->network.IELength));
+			
+#ifdef CONFIG_80211N_HT			
+				//TODO: update HT_Capability
+				rtw_update_ht_cap(adapter, cur_network->network.IEs, cur_network->network.IELength);
+#endif				
+
+				//indicate connect
+				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+				{
+				
+#ifdef CONFIG_DRVEXT_MODULE
+
+						if (pdrvext->enable_wpa) 
+						{
+							//Added by Albert 2008/10/16 for TKIP countermeasure.					       
+						 	pdrvext->wpa_tkip_mic_error_occur_time = 0;
+						 	pdrvext->wpa_tkip_countermeasure_enable = 0;
+							 _rtw_memset(pdrvext->wpa_tkip_countermeasure_blocked_bssid, 0x00, ETH_ALEN );
+						
+							res = drvext_l2_connect_callback(adapter);
+							
+							 if (res == L2_CONNECTED)
+							 {
+							 	rtw_indicate_connect(adapter);
+						 	 }	
+							 else if (res == L2_DISCONNECTED)
+							 {
+						 		goto select_and_join_new_bss;
+							 }
+							 else if (res == L2_PENDING)
+							 {
+								//DEBUG_ERR(("Going for WPA module\n"));
+								pdrvext->wpasm.rx_replay_counter_set = 0;
+								enable_wpa = 1;								
+							}
+							else if (res == L2_WSC_PENDING)
+							{
+								//DEBUG_ERR(("Going for WSC module\n"));						
+								enable_wsc = 1;								
+						 	}	
+
+
+						}
+						else
+#endif							
+						{
+							printk("%s...call rtw_indicate_connect...\n ",__FUNCTION__);
+							rtw_indicate_connect(adapter);
+						}
+		
+				}
+				else
+				{
+					//adhoc mode will rtw_indicate_connect when rtw_stassoc_event_callback
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("adhoc mode, fw_state:%x", pmlmepriv->fw_state));
+				}
+
+				
+			}
+		
+#ifdef CONFIG_DRVEXT_MODULE
+			if(enable_wpa) 
+			{
+				_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);   				
+				//DEBUG_ERR(("@@ Set Assoc Timer [%x] for WPA@@\n"));
+			}
+			else
+#endif				
+			{
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("Cancle assoc_timer \n"));		
+				_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+			}
+	
+
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_joinbss_event_callback err: fw_state:%x", pmlmepriv->fw_state));	
+			goto ignore_joinbss_callback;
+		}
+				
+	}
+	else if(pnetwork->join_res == -4) 
+	{
+		rtw_reset_securitypriv(adapter);
+		_set_timer(&pmlmepriv->assoc_timer, 1);					
+
+		//rtw_free_assoc_resources(adapter);
+
+		if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _TRUE)
+		{		
+             	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", pmlmepriv->fw_state));
+			pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+		}	
+		
+	}
+	else	//if join_res < 0 (join fails), then try again
+	{
+
+#ifdef CONFIG_DRVEXT_MODULE
+
+select_and_join_new_bss:
+
+		//drvext_assoc_fail_indicate(adapter);
+#endif			
+		res = rtw_select_and_join_from_scanned_queue(pmlmepriv);	
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_select_and_join_from_scanned_queue again! res:%d\n",res));
+		if (res != _SUCCESS || retry>2)
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Set Assoc_Timer = 1; can't find match ssid in scanned_q \n"));
+			
+			_set_timer(&pmlmepriv->assoc_timer, 1);					
+
+			//rtw_free_assoc_resources(adapter);
+
+			if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _TRUE)
+			{		
+                		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", pmlmepriv->fw_state));
+				pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+			}						
+
+			retry = 0;
+			
+		}
+		else
+		{
+			//extend time of assoc_timer
+			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);	
+
+			retry++;
+		}
+		
+	}
+					
+ignore_joinbss_callback:
+
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+	if(pnetwork->join_res > 0)
+	{
+		retry = 0;
+		mlmeext_joinbss_event_callback(adapter);
+
+#ifdef CONFIG_LPS
+		lps_ctrl_wk_cmd(adapter, LPS_CTRL_CONNECT, 0);
+#endif
+	}
+
+#ifdef CONFIG_DRVEXT_MODULE_WSC
+
+	if (enable_wsc)
+	{
+		// here we start registration protocol
+		start_reg_protocol(adapter);
+	}
+	
+#endif	
+
+_func_exit_;	
+
+}
+
+void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL;	
+	struct sta_info *psta;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct stassoc_event *pstassoc	= (struct stassoc_event*)pbuf;
+	struct wlan_network 	*cur_network = &(pmlmepriv->cur_network);
+	struct wlan_network	*ptarget_wlan = NULL;
+_func_enter_;	
+	
+	// to do: 	
+	if(rtw_access_ctrl(&adapter->acl_list, pstassoc->macaddr) == _FALSE)
+		return;
+
+	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);	
+	if( psta != NULL)
+	{
+		//the sta have been in sta_info_queue => do nothing 
+		
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error: rtw_stassoc_event_callback: sta has been in sta_hash_queue \n"));
+		//printk("Error: rtw_stassoc_event_callback: sta has been in sta_hash_queue \n");
+		goto exit; //(between drv has received this event before and  fw have not yet to set key to CAM_ENTRY)
+	}
+
+	psta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);	
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't alloc sta_info when rtw_stassoc_event_callback\n"));
+		goto exit;
+	}	
+	
+	//to do : init sta_info variable
+	psta->qos_option = 0;	
+	psta->mac_id = le32_to_cpu((uint)pstassoc->cam_id);
+	//psta->aid = (uint)pstassoc->cam_id;
+	
+	if(adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
+		psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
+
+	psta->ieee8021x_blocked = _FALSE;		
+	
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	//printk("=== %s, fw_state(%x) asoc_sta_coun(%d)===\n",__FUNCTION__,pmlmepriv->fw_state,adapter->stapriv.asoc_sta_count);
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) || 
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
+	{
+		if(adapter->stapriv.asoc_sta_count== 2)
+		{ 
+			ptarget_wlan = find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+			if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;	
+					
+			// a sta + bc/mc_stainfo (not Ibss_stainfo)
+			printk("%s...call rtw_indicate_connect...\n ",__FUNCTION__);
+			rtw_indicate_connect(adapter);
+		}
+	}
+
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+
+	mlmeext_sta_add_event_callback(adapter, psta);
+	
+#ifdef CONFIG_RTL8711
+	//submit SetStaKey_cmd to tell fw, fw will allocate an CAM entry for this sta	
+	rtw_setstakey_cmd(adapter, (unsigned char*)psta, _FALSE);
+#endif
+		
+exit:
+	
+_func_exit_;	
+
+}
+
+void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	_irqL irqL,irqL2;	
+	struct sta_info *psta;
+	struct wlan_network* pwlan = NULL;
+	WLAN_BSSID_EX    *pdev_network=NULL;
+	u8* pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+	struct 	stadel_event *pstadel	= (struct stadel_event*)pbuf;
+   	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+	
+_func_enter_;	
+
+	mlmeext_sta_del_event_callback(adapter);
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL2);
+
+	if(pmlmepriv->fw_state & WIFI_STATION_STATE)
+	{
+		rtw_free_assoc_resources(adapter);
+		printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+		rtw_indicate_disconnect(adapter);
+	}
+
+	if ( (pmlmepriv->fw_state& WIFI_ADHOC_MASTER_STATE) || 
+	      (pmlmepriv->fw_state& WIFI_ADHOC_STATE))
+	{
+		psta = rtw_get_stainfo(&adapter->stapriv, pstadel->macaddr);
+		
+		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		
+		rtw_free_stainfo(adapter,  psta);
+		
+		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		
+		if(adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
+		{ 
+			//rtw_indicate_disconnect(adapter);//removed@20091105
+			
+			//free old ibss network
+			//pwlan = find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
+			pwlan = find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+			if(pwlan)	
+			{
+				pwlan->fixed = _FALSE;
+				free_network_nolock(pmlmepriv, pwlan); 
+			}
+
+			//re-create ibss
+			pdev_network = &(adapter->registrypriv.dev_network);			
+			pibss = adapter->registrypriv.dev_network.MacAddress;
+
+			_rtw_memcpy(pdev_network, &tgt_network->network, get_WLAN_BSSID_EX_sz(&tgt_network->network));
+			
+			_rtw_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+			_rtw_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+	
+			rtw_update_registrypriv_dev_network(adapter);			
+
+			rtw_generate_random_ibss(pibss);
+			
+			if((pmlmepriv->fw_state & WIFI_ADHOC_STATE))
+			{
+				pmlmepriv->fw_state |= WIFI_ADHOC_MASTER_STATE;
+				pmlmepriv->fw_state ^= WIFI_ADHOC_STATE;
+			}
+
+			if(rtw_createbss_cmd(adapter)!=_SUCCESS)
+			{
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>rtw_stadel_event_callback: rtw_createbss_cmd status FAIL*** \n "));										
+			}
+
+			
+		}
+		
+	}
+	
+	_exit_critical_bh(&pmlmepriv->lock, &irqL2);
+	
+_func_exit_;	
+
+}
+
+
+void rtw_cpwm_event_callback(_adapter *adapter, u8 *pbuf)
+{
+	struct reportpwrstate_parm *preportpwrstate = (struct reportpwrstate_parm *)pbuf;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_cpwm_event_callback !!!\n"));
+#ifdef CONFIG_PWRCTRL
+	preportpwrstate->state |= (u8)(adapter->pwrctrlpriv.cpwm_tog + 0x80);
+	cpwm_int_hdl(adapter, preportpwrstate);
+#endif
+
+_func_exit_;
+
+}
+
+static void rtw_auto_scan_handler(_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	//auto site survey per 60sec
+	if(pmlmepriv->scan_interval >0)
+	{
+		pmlmepriv->scan_interval--;
+		if(pmlmepriv->scan_interval==0)
+		{
+			if( pwrctrlpriv->power_mgnt != PS_MODE_ACTIVE )
+				return;			
+
+/*		
+			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) 
+			{
+				printk("exit %s when _FW_UNDER_SURVEY|_FW_UNDER_LINKING -> \n", __FUNCTION__);
+				return;
+			}
+			
+			if(pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE)
+			{
+				printk("%s exit cause traffic_busy(%x)\n",__FUNCTION__, pmlmepriv->sitesurveyctrl.traffic_busy);
+				return;
+			}
+*/
+
+			DBG_871X("%s\n", __FUNCTION__);
+
+			rtw_set_802_11_bssid_list_scan(padapter);			
+			
+			pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+			
+		}
+		
+	}
+
+}
+
+void _rtw_sitesurvey_ctrl_handler (_adapter *adapter)
+{
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct	sitesurvey_ctrl	*psitesurveyctrl=&pmlmepriv->sitesurveyctrl;
+	struct	registry_priv	*pregistrypriv=&adapter->registrypriv;
+	u64 current_tx_pkts;
+	u64 current_rx_pkts;
+	
+_func_enter_;		
+	
+	current_tx_pkts=(adapter->xmitpriv.tx_pkts)-(psitesurveyctrl->last_tx_pkts);
+	current_rx_pkts=(adapter->recvpriv.rx_pkts)-(psitesurveyctrl->last_rx_pkts);
+
+	psitesurveyctrl->last_tx_pkts=adapter->xmitpriv.tx_pkts;
+	psitesurveyctrl->last_rx_pkts=adapter->recvpriv.rx_pkts;
+
+	if( (current_tx_pkts>pregistrypriv->busy_thresh)||(current_rx_pkts>pregistrypriv->busy_thresh)) 
+	{	
+		//printk("%s traffic_busy = true,Curr_tx(%lld),Curr_rx(%lld)\n",__FUNCTION__,current_tx_pkts,current_rx_pkts);
+		psitesurveyctrl->traffic_busy= _TRUE;
+	}
+	else 
+	{		
+		psitesurveyctrl->traffic_busy= _FALSE;
+	}
+	
+_func_exit_;	
+
+}
+
+void _rtw_join_timeout_handler (_adapter *adapter)
+{
+	_irqL irqL;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+#if 0
+	if (adapter->bDriverStopped == _TRUE){
+		_rtw_up_sema(&pmlmepriv->assoc_terminate);
+		return;
+	}
+#endif	
+
+_func_enter_;		
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n^^^rtw_join_timeout_handler ^^^fw_state=%x\n", pmlmepriv->fw_state));
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("+rtw_join_timeout_handler, fw_state=%x\n", pmlmepriv->fw_state));	
+	
+	if(adapter->bDriverStopped ||adapter->bSurpriseRemoved)
+		return;
+
+	
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+
+	if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _TRUE)
+	{
+		
+                RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("clear _FW_UNDER_LINKING ^^^fw_state=%x\n", pmlmepriv->fw_state));
+		pmlmepriv->fw_state ^= _FW_UNDER_LINKING;                
+
+	}
+
+	if((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE)
+	{
+		rtw_os_indicate_disconnect(adapter);
+		pmlmepriv->fw_state ^= _FW_LINKED;
+	}
+
+	free_scanqueue(pmlmepriv);//???
+	adapter->ledpriv.LedControlHandler(adapter, LED_CTL_NO_LINK);
+ 
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	
+_func_exit_;
+
+}
+
+void rtw_scan_timeout_handler (_adapter *adapter)
+{	
+	_irqL irqL;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("\n^^^rtw_scan_timeout_handler ^^^fw_state=%x\n", pmlmepriv->fw_state));
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	
+	if (pmlmepriv->fw_state & _FW_UNDER_SURVEY)
+	{		
+		pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;
+	}
+	else 
+	{	
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("fw status =%x, rtw_scan_timeout_handler: survey done event comes too late!\n", pmlmepriv->fw_state));	
+	}	
+
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	
+}
+
+
+void dynamic_check_timer_handlder(_adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+
+	if(adapter->hw_init_completed == _FALSE)
+		return;
+
+	if ((adapter->bDriverStopped == _TRUE)||(adapter->bSurpriseRemoved== _TRUE))
+		return;
+
+	if(adapter->net_closed == _TRUE)
+		return;
+
+	dynamic_chk_wk_cmd(adapter);
+
+	//dm_ctrl_wk_cmd(adapter);
+
+	//pbc_polling_wk_cmd(adapter);
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+		_rtw_sitesurvey_ctrl_handler(adapter);
+
+
+	if(pregistrypriv->wifi_spec==1)
+	{	
+		//auto site survey
+		rtw_auto_scan_handler(adapter);
+	}	
+
+
+#ifdef CONFIG_NATIVEAP_MLME
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+		expire_timeout_chk(adapter);
+	}	
+#endif
+	
+}
+
+
+/*
+Calling context:
+The caller of the sub-routine will be in critical section...
+
+The caller must hold the following spinlock
+
+pmlmepriv->lock
+
+
+*/
+int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
+{	
+	_list	*phead;
+	unsigned char *dst_ssid, *src_ssid;
+	_adapter *adapter;	
+	HAL_DATA_TYPE	*pHalData;
+	_queue	*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	struct	wlan_network	*pnetwork_max_rssi = NULL;
+	
+	phead = get_list_head(queue);		
+	adapter = (_adapter *)pmlmepriv->nic_hdl;
+	pHalData = GET_HAL_DATA(adapter);
+	
+       pmlmepriv->pscanned = get_next( phead );
+_func_enter_;	
+
+	while (1)
+	{			
+		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == _TRUE)
+		{
+			if((pmlmepriv->assoc_by_rssi==_TRUE)  && (pnetwork_max_rssi!=NULL))
+			{
+				pnetwork = pnetwork_max_rssi;
+				goto ask_for_joinbss;
+			}				
+		
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(1)rtw_select_and_join_from_scanned_queue return _FAIL\n"));
+			return _FAIL;	
+		}
+
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+		if(pnetwork==NULL){
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(2)rtw_select_and_join_from_scanned_queue return _FAIL:(pnetwork==NULL)\n"));
+			return _FAIL;	
+		}
+
+		
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+		if(pmlmepriv->assoc_by_bssid==_TRUE)
+		{
+			dst_ssid = pnetwork->network.MacAddress;
+			src_ssid = pmlmepriv->assoc_bssid;
+			
+			if(_rtw_memcmp(dst_ssid, src_ssid, ETH_ALEN)==_TRUE)
+			{
+				//remove the condition @ 20081125
+				//if((pmlmepriv->cur_network.network.InfrastructureMode==Ndis802_11AutoUnknown)||
+				//	pmlmepriv->cur_network.network.InfrastructureMode == pnetwork->network.InfrastructureMode)
+				//		goto ask_for_joinbss;
+				
+				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+				{
+					if(is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
+					{
+						//DBG_871X("select_and_join(1): _FW_LINKED and is same network, it needn't join again\n");
+						printk("%s...call rtw_indicate_connect...\n ",__FUNCTION__);
+						rtw_indicate_connect(adapter);//rtw_indicate_connect again
+							
+						return 2;
+					}
+					else
+					{
+						rtw_disassoc_cmd(adapter);
+						printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+						rtw_indicate_disconnect(adapter);
+
+						rtw_free_assoc_resources(adapter);
+
+						goto ask_for_joinbss;
+						
+					}
+				}
+				else
+				{
+					goto ask_for_joinbss;
+				}
+							
+			}
+			
+		}		
+		else if (pmlmepriv->assoc_ssid.SsidLength == 0)
+		{			
+			goto ask_for_joinbss;//anyway, join first selected(dequeued) pnetwork if ssid_len=0				
+		}
+	
+		
+		dst_ssid = pnetwork->network.Ssid.Ssid;
+		src_ssid = pmlmepriv->assoc_ssid.Ssid;
+/*
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			printk("#### dst_ssid=(%s) Opt_Ant_(%s) , cur_Ant(%s)\n", dst_ssid,
+				(2==pnetwork->network.PhyInfo.Optimum_antenna)?"A":"B",
+				(2==pHalData->CurAntenna)?"A":"B");
+#endif
+*/
+		if (((_rtw_memcmp(dst_ssid, src_ssid, pmlmepriv->assoc_ssid.SsidLength)) == _TRUE)&&
+			(pnetwork->network.Ssid.SsidLength==pmlmepriv->assoc_ssid.SsidLength))
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("dst_ssid=%s, src_ssid=%s \n", dst_ssid, src_ssid));
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			printk("#### dst_ssid=(%s) Opt_Ant_(%s) , cur_Ant(%s)\n", dst_ssid,
+				(2==pnetwork->network.PhyInfo.Optimum_antenna)?"A":"B",
+				(2==pHalData->CurAntenna)?"A":"B");
+#endif
+			//remove the condition @ 20081125
+			//if((pmlmepriv->cur_network.network.InfrastructureMode==Ndis802_11AutoUnknown)||
+			//	pmlmepriv->cur_network.network.InfrastructureMode == pnetwork->network.InfrastructureMode)
+			//{
+			//	_rtw_memcpy(pmlmepriv->assoc_bssid, pnetwork->network.MacAddress, ETH_ALEN);
+			//	goto ask_for_joinbss;
+			//}
+
+			if(pmlmepriv->assoc_by_rssi==_TRUE)//if the ssid is the same, select the bss which has the max rssi
+			{
+				if(pnetwork_max_rssi)
+				{
+					if(pnetwork->network.Rssi > pnetwork_max_rssi->network.Rssi)
+						pnetwork_max_rssi = pnetwork;					
+				}
+				else
+				{
+					pnetwork_max_rssi = pnetwork;
+				}				
+				
+			}
+			else if(is_desired_network(adapter, pnetwork) == _TRUE)
+			{
+				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+				{
+#if 0				
+					if(is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
+					{
+						DBG_871X("select_and_join(2): _FW_LINKED and is same network, it needn't join again\n");
+						
+						rtw_indicate_connect(adapter);//rtw_indicate_connect again
+						
+						return 2;
+					}
+					else
+#endif						
+					{
+						rtw_disassoc_cmd(adapter);
+			
+						//rtw_indicate_disconnect(adapter);//
+
+						rtw_free_assoc_resources(adapter);
+
+						goto ask_for_joinbss;						
+					}
+				}
+				else
+				{				
+					goto ask_for_joinbss;
+				}				
+
+			}
+		
+			
+		}
+ 	
+ 	}
+
+_func_exit_;	
+
+     return _FAIL;
+
+ask_for_joinbss:
+	
+_func_exit_;
+
+	return rtw_joinbss_cmd(adapter, pnetwork);
+
+}
+
+
+
+sint rtw_set_auth(_adapter * adapter,struct security_priv *psecuritypriv)
+{
+	struct	cmd_obj* pcmd;
+	struct 	setauth_parm *psetauthparm;
+	struct	cmd_priv	*pcmdpriv=&(adapter->cmdpriv);
+	sint		res=_SUCCESS;
+	
+_func_enter_;	
+
+	pcmd = (struct	cmd_obj*)_rtw_zmalloc(sizeof(struct	cmd_obj));
+	if(pcmd==NULL){
+		res= _FAIL;  //try again
+		goto exit;
+	}
+	
+	psetauthparm=(struct setauth_parm*)_rtw_zmalloc(sizeof(struct setauth_parm));
+	if(psetauthparm==NULL){
+		_rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	_rtw_memset(psetauthparm, 0, sizeof(struct setauth_parm));
+	psetauthparm->mode=(unsigned char)psecuritypriv->dot11AuthAlgrthm;
+	
+	pcmd->cmdcode = _SetAuth_CMD_;
+	pcmd->parmbuf = (unsigned char *)psetauthparm;   
+	pcmd->cmdsz =  (sizeof(struct setauth_parm));  
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+
+	_rtw_init_listhead(&pcmd->list);
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("after enqueue set_auth_cmd, auth_mode=%x\n", psecuritypriv->dot11AuthAlgrthm));
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+
+}
+
+
+sint rtw_set_key(_adapter * adapter,struct security_priv *psecuritypriv,sint keyid)
+{
+	u8 keylen;
+	struct	cmd_obj* pcmd;
+	struct 	setkey_parm *psetkeyparm;
+	struct	cmd_priv	*pcmdpriv=&(adapter->cmdpriv);
+	struct 	mlme_ext_info *pmlmeinfo = &adapter->mlmeextpriv.mlmext_info;
+	sint res=_SUCCESS;
+	
+_func_enter_;
+	
+	pcmd = (struct	cmd_obj*)_rtw_zmalloc(sizeof(struct	cmd_obj));
+	if(pcmd==NULL){
+		res= _FAIL;  //try again
+		goto exit;
+	}
+	psetkeyparm=(struct setkey_parm*)_rtw_zmalloc(sizeof(struct setkey_parm));
+	if(psetkeyparm==NULL){
+		_rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	//_rtw_memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+
+	if(psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X){		
+		psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy;	
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy=%d \n", psetkeyparm->algorithm));
+	}	
+	else{
+		psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm;
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm=%d \n", psetkeyparm->algorithm));
+
+	}
+	psetkeyparm->keyid=(u8)keyid;//0~3
+	pmlmeinfo->key_mask |= BIT(psetkeyparm->keyid);
+#ifdef CONFIG_AUTOSUSPEND
+	if( _TRUE  == adapter->pwrctrlpriv.bInternalAutoSuspend)
+	{
+		adapter->pwrctrlpriv.wepkeymask = pmlmeinfo->key_mask;
+		printk("....AutoSuspend pwrctrlpriv.wepkeymask(%x)\n",adapter->pwrctrlpriv.wepkeymask);
+	}
+#endif
+	printk("==> rtw_set_key algorithm(%x),keyid(%x),key_mask(%x)\n",psetkeyparm->algorithm,psetkeyparm->keyid,pmlmeinfo->key_mask);
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=%d psetkeyparm->keyid=(u8)keyid=%d \n",psetkeyparm->algorithm, keyid));
+
+	switch(psetkeyparm->algorithm){
+		
+		case _WEP40_:
+			keylen=5;
+			_rtw_memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
+			break;
+		case _WEP104_:
+			keylen=13;
+			_rtw_memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
+			break;
+		case _TKIP_:
+			keylen=16;			
+			_rtw_memcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid-1], keylen);
+			psetkeyparm->grpkey=1;
+			break;
+		case _AES_:
+			keylen=16;			
+			_rtw_memcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid-1], keylen);
+			psetkeyparm->grpkey=1;
+			break;
+		default:
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",psecuritypriv->dot11PrivacyAlgrthm));
+			res= _FAIL;
+			goto exit;
+	}
+
+	
+	pcmd->cmdcode = _SetKey_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;   
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));  
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+
+	_rtw_init_listhead(&pcmd->list);
+
+	//_rtw_init_sema(&(pcmd->cmd_sem), 0);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+_func_exit_;
+	return _SUCCESS;
+
+}
+
+
+//adjust IEs for rtw_joinbss_cmd in WMM
+int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len)
+{
+	unsigned	int ielength=0;
+	unsigned int i, j;
+
+	i = 12; //after the fixed IE
+	while(i<in_len)
+	{
+		ielength = initial_out_len;		
+		
+		if(in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
+		{
+
+			//Append WMM IE to the last index of out_ie
+			/*
+			for(j=i; j< i+(in_ie[i+1]+2); j++)
+			{
+				out_ie[ielength] = in_ie[j];				
+				ielength++;
+			}
+			out_ie[initial_out_len+8] = 0x00; //force the QoS Info Field to be zero
+	                */
+                       
+                        for ( j = i; j < i + 9; j++ )
+                        {
+                            out_ie[ ielength] = in_ie[ j ];
+                            ielength++;
+                        } 
+                        out_ie[ initial_out_len + 1 ] = 0x07;
+                        out_ie[ initial_out_len + 6 ] = 0x00;
+                        out_ie[ initial_out_len + 8 ] = 0x00;
+	
+			break;
+		}
+
+		i+=(in_ie[i+1]+2); // to the next IE element
+	}
+	
+	return ielength;
+	
+}
+
+
+//
+// Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.)
+// Added by Annie, 2006-05-07.
+//
+// Search by BSSID,
+// Return Value:
+//		-1 		:if there is no pre-auth key in the  table
+//		>=0		:if there is pre-auth key, and   return the entry id
+//
+//
+
+static int SecIsInPMKIDList(_adapter *Adapter, u8 *bssid)
+{
+	struct security_priv *psecuritypriv=&Adapter->securitypriv;
+	int i=0;
+
+	do
+	{
+		if( ( psecuritypriv->PMKIDList[i].bUsed ) && 
+                    (  _rtw_memcmp( psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN ) == _TRUE ) )
+		{
+			break;
+		}
+		else
+		{	
+			i++;
+			//continue;
+		}
+		
+	}while(i<NUM_PMKID_CACHE);
+
+	if( i == NUM_PMKID_CACHE )
+	{ 
+		i = -1;// Could not find.
+	}
+	else
+	{ 
+		// There is one Pre-Authentication Key for the specific BSSID.
+	}
+
+	return (i);
+	
+}
+
+sint rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
+{
+	u8 authmode, securitytype, match;
+	u8 sec_ie[255], uncst_oui[4], bkup_ie[255];
+	u8 wpa_oui[4]={0x0, 0x50, 0xf2, 0x01};
+	uint 	ielength, cnt, remove_cnt;
+	int iEntry;
+
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct security_priv *psecuritypriv=&adapter->securitypriv;
+	uint 	ndisauthmode=psecuritypriv->ndisauthtype;
+	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
+	
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+		 ("+rtw_restruct_sec_ie: ndisauthmode=%d ndissecuritytype=%d\n",
+		  ndisauthmode, ndissecuritytype));
+	  
+	authmode = 0xFF;//init
+
+	if((ndisauthmode==Ndis802_11AuthModeWPA)||(ndisauthmode==Ndis802_11AuthModeWPAPSK))
+	{
+		authmode=_WPA_IE_ID_;
+		uncst_oui[0]=0x0;
+		uncst_oui[1]=0x50;
+		uncst_oui[2]=0xf2;
+	}
+	if((ndisauthmode==Ndis802_11AuthModeWPA2)||(ndisauthmode==Ndis802_11AuthModeWPA2PSK))
+	{	
+		authmode=_WPA2_IE_ID_;
+		uncst_oui[0]=0x0;
+		uncst_oui[1]=0x0f;
+		uncst_oui[2]=0xac;
+	}
+	
+	switch(ndissecuritytype)
+	{
+		case Ndis802_11Encryption1Enabled:
+		case Ndis802_11Encryption1KeyAbsent:
+				securitytype=_WEP40_;
+				uncst_oui[3]=0x1;
+				break;
+		case Ndis802_11Encryption2Enabled:
+		case Ndis802_11Encryption2KeyAbsent:
+				securitytype=_TKIP_;
+				uncst_oui[3]=0x2;
+				break;
+		case Ndis802_11Encryption3Enabled:
+		case Ndis802_11Encryption3KeyAbsent: 	
+				securitytype=_AES_;
+				uncst_oui[3]=0x4;
+				break;
+		default:
+				securitytype=_NO_PRIVACY_;
+				break;				
+	}
+		
+	//Search required WPA or WPA2 IE and copy to sec_ie[ ]
+	cnt=12;
+	match=_FALSE;
+	while(cnt<in_len)
+	{
+		if(in_ie[cnt]==authmode)
+		{
+			if((authmode==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0], 4)==_TRUE))
+			{
+				_rtw_memcpy(&sec_ie[0], &in_ie[cnt], in_ie[cnt+1]+2);
+				match=_TRUE;
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_restruct_sec_ie: Get WPA IE from %d in_len=%d \n",cnt,in_len));
+				break;
+			}
+			if(authmode==_WPA2_IE_ID_)
+			{
+				_rtw_memcpy(&sec_ie[0], &in_ie[cnt], in_ie[cnt+1]+2);
+				match=_TRUE;
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_restruct_sec_ie: Get WPA2 IE from %d in_len=%d \n",cnt,in_len));
+				break;
+			}	
+			if(((authmode==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0], 4)==_TRUE))||(authmode==_WPA2_IE_ID_))
+			{
+				_rtw_memcpy(&bkup_ie[0], &in_ie[cnt], in_ie[cnt+1]+2);
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_restruct_sec_ie: cnt=%d in_len=%d \n",cnt,in_len));
+			}
+		}
+	
+		cnt += in_ie[cnt+1] + 2; //get next
+	}
+	
+	//restruct WPA IE or WPA2 IE in sec_ie[ ]
+	if(match==_TRUE)
+	{
+		if(sec_ie[0]==_WPA_IE_ID_)
+		{
+			// parsing SSN IE to select required encryption algorithm, and set the bc/mc encryption algorithm
+			while(_TRUE)
+			{
+				if(_rtw_memcmp(&sec_ie[2], &wpa_oui[0], 4) !=_TRUE)//check wpa_oui tag
+				{  	 
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE but doesn't has wpa_oui tag! \n"));
+					match=_FALSE;
+					break;
+				}
+				
+				if((sec_ie[6]!=0x01) ||(sec_ie[7]!= 0x0))
+				{ 	
+					//IE Ver error
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :IE version error (%.2x %.2x != 01 00 )! \n",sec_ie[6],sec_ie[7]));
+					match=_FALSE;
+					break;
+				}
+				
+				if(_rtw_memcmp(&sec_ie[8], &wpa_oui[0], 3) ==_TRUE)
+				{ 
+					//get bc/mc encryption type (group key tyep)
+					switch(sec_ie[11])
+					{
+						case 0x0: //none
+							psecuritypriv->dot118021XGrpPrivacy=_NO_PRIVACY_;
+							break;
+						case 0x1: //WEP_40
+							psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+							break;
+						case 0x2: //TKIP
+							psecuritypriv->dot118021XGrpPrivacy=_TKIP_;
+							break;
+						case 0x3: //AESCCMP
+						case 0x4: 
+							psecuritypriv->dot118021XGrpPrivacy=_AES_;
+							break;
+						case 0x5: //WEP_104	
+							psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+							break;
+					}
+					
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :Multicast error (%.2x %.2x %.2x %.2x != 00 50 F2 xx )! \n",
+									sec_ie[8],sec_ie[9],sec_ie[10],sec_ie[11]));
+					match =_FALSE;
+					break;
+				}
+				
+				if(sec_ie[12]==0x01)
+				{ 
+					//check the unicast encryption type
+					if(_rtw_memcmp(&sec_ie[14], &uncst_oui[0], 4) !=_TRUE)
+					{
+						RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :Unicast error (%.2x %.2x %.2x %.2x != 00 50 F2 %.2x )! \n",
+										sec_ie[14],sec_ie[15],sec_ie[16],sec_ie[17],uncst_oui[3]));
+						match =_FALSE;
+						
+						break;
+						
+					} //else the uncst_oui is match
+				}
+				else//mixed mode, unicast_enc_type > 1
+				{
+					//select the uncst_oui and remove the other uncst_oui
+					cnt=sec_ie[12];
+					remove_cnt=(cnt-1)*4;
+					sec_ie[12]=0x01;
+					_rtw_memcpy(&sec_ie[14], &uncst_oui[0], 4);
+					
+					//remove the other unicast suit
+					_rtw_memcpy(&sec_ie[18], &sec_ie[18+remove_cnt],(sec_ie[1]-18+2-remove_cnt));
+					sec_ie[1]=sec_ie[1]-remove_cnt;
+				}
+				
+				break;				
+			}			
+		}
+
+		if(authmode==_WPA2_IE_ID_)
+		{
+			// parsing RSN IE to select required encryption algorithm, and set the bc/mc encryption algorithm
+			while(_TRUE)
+			{
+				if((sec_ie[2]!=0x01)||(sec_ie[3]!= 0x0))
+				{ 
+					//IE Ver error
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n RSN IE :IE version error (%.2x %.2x != 01 00 )! \n",sec_ie[2],sec_ie[3]));
+					match=_FALSE;
+					break;
+				}
+				
+				if(_rtw_memcmp(&sec_ie[4], &uncst_oui[0], 3) ==_TRUE)
+				{ 
+					//get bc/mc encryption type
+					switch(sec_ie[7])
+					{
+						case 0x1: //WEP_40
+							psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+							break;
+						case 0x2: //TKIP
+							psecuritypriv->dot118021XGrpPrivacy=_TKIP_;
+							break;
+						case 0x4: //AESWRAP
+							psecuritypriv->dot118021XGrpPrivacy=_AES_;
+							break;
+						case 0x5: //WEP_104	
+							psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+							break;
+						default: //none
+							psecuritypriv->dot118021XGrpPrivacy=_NO_PRIVACY_;
+							break;	
+					}
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n RSN IE :Multicast error (%.2x %.2x %.2x %.2x != 00 50 F2 xx )! \n",
+								sec_ie[4],sec_ie[5],sec_ie[6],sec_ie[7]));
+					match=_FALSE;
+					break;
+				}
+				
+				if(sec_ie[8]==0x01)
+				{ 
+					//check the unicast encryption type
+					if(_rtw_memcmp(&sec_ie[10], &uncst_oui[0],4) !=_TRUE)
+					{
+						RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n SSN IE :Unicast error (%.2x %.2x %.2x %.2x != 00 50 F2 xx )! \n",
+									sec_ie[10],sec_ie[11],sec_ie[12],sec_ie[13]));
+
+						match =_FALSE;						
+						break;
+						
+					} //else the uncst_oui is match
+				}
+				else //mixed mode, unicast_enc_type > 1
+				{ 
+					//select the uncst_oui and remove the other uncst_oui
+					cnt=sec_ie[8];
+					remove_cnt=(cnt-1)*4;
+					sec_ie[8]=0x01;
+					_rtw_memcpy( &sec_ie[10] , &uncst_oui[0],4 );
+					
+					//remove the other unicast suit
+					_rtw_memcpy(&sec_ie[14],&sec_ie[14+remove_cnt],(sec_ie[1]-14+2-remove_cnt));
+					sec_ie[1]=sec_ie[1]-remove_cnt;
+				}
+
+				break;				
+			}			
+		}
+
+	}
+
+	//copy fixed ie only
+	_rtw_memcpy(out_ie, in_ie,12);
+	ielength=12;
+		
+	if(psecuritypriv->wps_phase == _TRUE)
+	{
+		//DBG_871X("wps_phase == _TRUE\n");
+
+		_rtw_memcpy(out_ie+ielength, psecuritypriv->wps_ie, psecuritypriv->wps_ie_len);
+		
+		ielength += psecuritypriv->wps_ie_len;
+		psecuritypriv->wps_phase = _FALSE;
+	
+	}
+	else if((authmode==_WPA_IE_ID_)||(authmode==_WPA2_IE_ID_))
+	{		
+		//copy RSN or SSN		
+		if(match ==_TRUE)
+		{		
+			_rtw_memcpy(&out_ie[ielength], &sec_ie[0], sec_ie[1]+2);
+			ielength+=sec_ie[1]+2;
+			
+			if(authmode==_WPA2_IE_ID_)
+			{
+				//the Pre-Authentication bit should be zero, john
+				out_ie[ielength-1]= 0;
+				out_ie[ielength-2]= 0;
+			}
+
+			rtw_report_sec_ie(adapter, authmode, sec_ie);
+	
+#ifdef CONFIG_DRVEXT_MODULE
+			drvext_report_sec_ie(&adapter->drvextpriv, authmode, sec_ie);	
+#endif
+			
+		}
+		
+	}
+	else
+	{
+	
+	}
+	
+	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
+	if(iEntry<0)
+	{
+		return ielength;
+	}
+	else
+	{
+		if(authmode == _WPA2_IE_ID_)
+		{
+			out_ie[ielength]=1;
+			ielength++;
+			out_ie[ielength]=0;	//PMKID count = 0x0100
+			ielength++;
+			_rtw_memcpy(	&out_ie[ielength], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);
+		
+			ielength+=16;
+			out_ie[13]+=18;//PMKID length = 2+16
+		}
+	}
+	
+	//rtw_report_sec_ie(adapter, authmode, sec_ie);
+
+_func_exit_;
+	
+	return ielength;	
+}
+
+void rtw_init_registrypriv_dev_network(	_adapter* adapter)
+{
+	struct registry_priv* pregistrypriv = &adapter->registrypriv;
+	struct eeprom_priv* peepriv = &adapter->eeprompriv;
+	WLAN_BSSID_EX    *pdev_network = &pregistrypriv->dev_network;
+	u8 *myhwaddr = myid(peepriv);
+	
+_func_enter_;
+
+	_rtw_memcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);
+
+	_rtw_memcpy(&pdev_network->Ssid, &pregistrypriv->ssid, sizeof(NDIS_802_11_SSID));
+	
+	pdev_network->Configuration.Length=sizeof(NDIS_802_11_CONFIGURATION);
+	pdev_network->Configuration.BeaconPeriod = 100;	
+	pdev_network->Configuration.FHConfig.Length = 0;
+	pdev_network->Configuration.FHConfig.HopPattern = 0;
+	pdev_network->Configuration.FHConfig.HopSet = 0;
+	pdev_network->Configuration.FHConfig.DwellTime = 0;
+	
+	
+_func_exit_;	
+	
+}
+
+void rtw_update_registrypriv_dev_network(_adapter* adapter) 
+{
+	int sz=0;
+	struct registry_priv* pregistrypriv = &adapter->registrypriv;	
+	WLAN_BSSID_EX    *pdev_network = &pregistrypriv->dev_network;
+	struct	security_priv*	psecuritypriv = &adapter->securitypriv;
+	struct	wlan_network	*cur_network = &adapter->mlmepriv.cur_network;
+	struct	xmit_priv	*pxmitpriv = &adapter->xmitpriv;
+
+_func_enter_;
+
+#if 0
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+	
+	adapter->qospriv.qos_option = pregistrypriv->wmm_enable;
+#endif	
+
+	pdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0) ; // adhoc no 802.1x
+
+	pdev_network->Rssi = 0;
+
+	switch(pregistrypriv->wireless_mode)
+	{
+		case WIRELESS_11B:
+			pdev_network->NetworkTypeInUse = (Ndis802_11DS);
+			break;	
+		case WIRELESS_11G:
+		case WIRELESS_11BG:
+		case WIRELESS_11N:	
+		case WIRELESS_11GN:
+		case WIRELESS_11BGN:	
+			pdev_network->NetworkTypeInUse = (Ndis802_11OFDM24);
+			break;
+		case WIRELESS_11A:
+			pdev_network->NetworkTypeInUse = (Ndis802_11OFDM5);
+			break;
+		default :
+			// TODO
+			break;
+	}
+	
+	pdev_network->Configuration.DSConfig = (pregistrypriv->channel);
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n", pregistrypriv->channel, pdev_network->Configuration.DSConfig));	
+
+	if(cur_network->network.InfrastructureMode == Ndis802_11IBSS)
+			pdev_network->Configuration.ATIMWindow = (0);
+
+	pdev_network->InfrastructureMode = (cur_network->network.InfrastructureMode);
+
+	// 1. Supported rates
+	// 2. IE
+
+	//rtw_set_supported_rate(pdev_network->SupportedRates, pregistrypriv->wireless_mode) ; // will be called in rtw_generate_ie
+	sz = rtw_generate_ie(pregistrypriv);
+
+	pdev_network->IELength = sz;
+
+	pdev_network->Length =get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX  *)pdev_network);
+
+	//notes: translate IELength & Length after assign the Length to cmdsz in rtw_createbss_cmd();
+	//pdev_network->IELength = cpu_to_le32(sz);
+		
+_func_exit_;	
+
+}
+
+void rtw_get_encrypt_decrypt_from_registrypriv(	_adapter* adapter)
+{
+	u16	wpaconfig=0;
+	struct registry_priv* pregistrypriv = &adapter->registrypriv;
+	struct security_priv* psecuritypriv= &adapter->securitypriv;
+_func_enter_;
+
+
+_func_exit_;	
+	
+}
+
+//the fucntion is at passive_level 
+void rtw_joinbss_reset(_adapter *padapter)
+{
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+
+#ifdef CONFIG_80211N_HT	
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+#endif
+
+	//todo: if you want to do something io/reg/hw setting before join_bss, please add code here
+	
+
+
+
+#ifdef CONFIG_80211N_HT
+
+	pmlmepriv->num_FortyMHzIntolerant = 0;
+
+	pmlmepriv->num_sta_no_ht = 0;
+
+	phtpriv->ampdu_enable = _FALSE;//reset to disabled	
+
+	if(phtpriv->ht_option)
+	{
+	
+#ifdef CONFIG_USB_HCI	
+		//validate  usb rx aggregation
+		//rtw_write8(padapter, 0x102500D9, 48);//TH = 48 pages, 6k
+		if(pregpriv->wifi_spec==1)
+		{
+			rtw_write8(padapter, REG_RXDMA_AGG_PG_TH, 1);// TH=1 => means that invalidate usb rx aggregation
+		}
+		else
+		{
+			rtw_write8(padapter, REG_RXDMA_AGG_PG_TH, 48);//TH = 48 pages, 6k
+		}
+		
+#endif
+
+	}
+	else
+	{
+
+#ifdef CONFIG_USB_HCI	
+	//invalidate  usb rx aggregation
+		//rtw_write8(padapter, 0x102500D9, 1);// TH=1 => means that invalidate usb rx aggregation
+		rtw_write8(padapter, REG_RXDMA_AGG_PG_TH, 1);
+#endif
+
+	}
+	
+#endif	
+
+}
+
+
+#ifdef CONFIG_80211N_HT
+
+//the fucntion is >= passive_level 
+unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len)
+{
+	u32 ielen, out_len;
+	unsigned char *p, *pframe;
+	struct ieee80211_ht_cap ht_capie;
+	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv   	*pqospriv= &pmlmepriv->qospriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	phtpriv->ht_option = 0;
+
+	p = rtw_get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);
+
+	if(p && ielen>0)
+	{
+		if(pqospriv->qos_option == 0)
+		{
+			out_len = *pout_len;
+			pframe = rtw_set_ie(out_ie+out_len, _VENDOR_SPECIFIC_IE_, 
+								_WMM_IE_Length_, WMM_IE, pout_len);
+
+			pqospriv->qos_option = 1;
+		}
+
+		out_len = *pout_len;
+
+		_rtw_memset(&ht_capie, 0, sizeof(struct ieee80211_ht_cap));
+
+		ht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |IEEE80211_HT_CAP_SGI_20 |
+							IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_TX_STBC |
+							IEEE80211_HT_CAP_MAX_AMSDU | IEEE80211_HT_CAP_DSSSCCK40;
+		
+		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03) |
+										(IEEE80211_HT_CAP_AMPDU_DENSITY&0x00) ; 
+
+		
+		pframe = rtw_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_, 
+							sizeof(struct ieee80211_ht_cap), (unsigned char*)&ht_capie, pout_len);
+
+
+		//_rtw_memcpy(out_ie+out_len, p, ielen+2);//gtest
+		//*pout_len = *pout_len + (ielen+2);
+
+							
+		phtpriv->ht_option = 1;
+		
+
+		//spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz	
+		pmlmeinfo->assoc_AP_vendor = check_assoc_AP(in_ie, in_len);
+		if(pmlmeinfo->assoc_AP_vendor == ciscoAP)
+		{		
+			p = rtw_get_ie(in_ie+12, _HT_ADD_INFO_IE_, &ielen, in_len-12);
+			if(p && (ielen==sizeof(struct ieee80211_ht_addt_info)))
+			{
+				out_len = *pout_len;		
+				pframe = rtw_set_ie(out_ie+out_len, _HT_ADD_INFO_IE_, ielen, p+2 , pout_len);
+			}	
+	}
+	
+	}
+	
+	return (phtpriv->ht_option);
+	
+}
+
+//the fucntion is > passive_level (in critical_section)
+void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len)
+{	
+	u8 *p, max_ampdu_sz;
+	int i, len;		
+	struct sta_info *bmc_sta, *psta;	
+	struct ieee80211_ht_cap *pht_capie;
+	struct ieee80211_ht_addt_info *pht_addtinfo;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct wlan_network *pcur_network = &(pmlmepriv->cur_network);
+	
+
+	if(!phtpriv->ht_option)
+		return;
+
+
+	//printk("+rtw_update_ht_cap()\n");
+
+	//maybe needs check if ap supports rx ampdu.
+	if((phtpriv->ampdu_enable==_FALSE) &&(pregistrypriv->ampdu_enable==1))
+	{
+		if(pregistrypriv->wifi_spec==1)
+		{
+			phtpriv->ampdu_enable = _FALSE;
+		}
+		else
+		{
+			phtpriv->ampdu_enable = _TRUE;
+		}
+	}
+	else if(pregistrypriv->ampdu_enable==2)
+	{
+		phtpriv->ampdu_enable = _TRUE;
+	}
+	
+
+	
+	//check Max Rx A-MPDU Size 
+	len = 0;
+	p = rtw_get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_CAPABILITY_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
+	if(p && len>0)	
+	{
+		pht_capie = (struct ieee80211_ht_cap *)(p+2);
+		max_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);
+		max_ampdu_sz = 1 << (max_ampdu_sz+3); // max_ampdu_sz (kbytes);
+		
+		//printk("rtw_update_ht_cap(): max_ampdu_sz=%d\n", max_ampdu_sz);
+		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
+		
+	}
+
+	//for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
+	//if A-MPDU Rx is enabled, reseting  rx_ordering_ctrl wstart_b(indicate_seq) to default value=0xffff
+	//todo: check if AP can send A-MPDU packets
+	bmc_sta = rtw_get_bcmc_stainfo(padapter);
+	if(bmc_sta)
+	{
+		for(i=0; i < 16 ; i++)
+		{
+			//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+			preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
+			preorder_ctrl->enable = _FALSE;
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;
+			preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+		}
+	}
+
+	psta = rtw_get_stainfo(&padapter->stapriv, pcur_network->network.MacAddress);
+	if(psta)
+	{
+		for(i=0; i < 16 ; i++)
+		{
+			//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->enable = _FALSE;
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;
+			preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+		}
+	}
+
+	len=0;
+	p = rtw_get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_ADD_INFO_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
+	if(p && len>0)	
+	{
+		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p+2);		
+	}
+
+}
+
+void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	u8 issued;
+	int priority;
+	struct sta_info *psta=NULL;
+	struct ht_priv	*phtpriv;
+	struct pkt_attrib *pattrib =&pxmitframe->attrib;
+ 	struct sta_priv *pstapriv = &padapter->stapriv;	
+	s32 bmcst = IS_MCAST(pattrib->ra);
+
+	if(bmcst)
+		return;
+	
+	priority = pattrib->priority;
+
+	if (pattrib->psta)
+		psta = pattrib->psta;
+	else
+		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
+	
+	if(psta==NULL)
+		return;
+	
+	phtpriv = &psta->htpriv;
+
+	if((phtpriv->ht_option==1) && (phtpriv->ampdu_enable==_TRUE)) 
+	{
+		issued = (phtpriv->agg_enable_bitmap>>priority)&0x1;
+		issued |= (phtpriv->candidate_tid_bitmap>>priority)&0x1;
+
+		if(0==issued)
+		{
+			DBG_871X("issue_addbareq_cmd, p=%d\n", priority);
+			psta->htpriv.candidate_tid_bitmap |= BIT((u8)priority);
+			rtw_addbareq_cmd(padapter,(u8)priority, pattrib->ra);
+		}	
+	}
+	
+}
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mlme_ext.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mlme_ext.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mlme_ext.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mlme_ext.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,3848 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_MLME_EXT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+#include <rtw_mlme_ext.h>
+#include <wlan_bssdef.h>
+#include <mlme_osdep.h>
+#include <recv_osdep.h>
+
+static RT_CHANNEL_PLAN	DefaultChannelPlan[RT_CHANNEL_DOMAIN_MAX] = {
+							{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64,149,153,157,161,165},24},	// RT_CHANNEL_DOMAIN_FCC
+							{{1,2,3,4,5,6,7,8,9,10,11},11},												// RT_CHANNEL_DOMAIN_IC
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},				// RT_CHANNEL_DOMAIN_ETSI
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},										// RT_CHANNEL_DOMAIN_SPAIN
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},										// RT_CHANNEL_DOMAIN_FRANCE
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},			// RT_CHANNEL_DOMAIN_MKK
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},			// RT_CHANNEL_DOMAIN_MKK1
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},										// RT_CHANNEL_DOMAIN_ISRAEL
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},			// RT_CHANNEL_DOMAIN_TELEC
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},				// RT_CHANNEL_DOMAIN_MIC
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},									// RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},										// RT_CHANNEL_DOMAIN_WORLD_WIDE_13
+							{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},				// RT_CHANNEL_DOMAIN_TELEC_NETGEAR
+							{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64,149,153,157,161,165},24},	// RT_CHANNEL_DOMAIN_NCC							
+							};
+
+struct mlme_handler mlme_sta_tbl[]={
+	{WIFI_ASSOCREQ,		"OnAssocReq",	&OnAssocReq},
+	{WIFI_ASSOCRSP,		"OnAssocRsp",	&OnAssocRsp},
+	{WIFI_REASSOCREQ,	"OnReAssocReq",	&OnAssocReq},
+	{WIFI_REASSOCRSP,	"OnReAssocRsp",	&OnAssocRsp},
+	{WIFI_PROBEREQ,		"OnProbeReq",	&OnProbeReq},
+	{WIFI_PROBERSP,		"OnProbeRsp",		&OnProbeRsp},
+
+	/*----------------------------------------------------------
+					below 2 are reserved
+	-----------------------------------------------------------*/
+	{0,					"DoReserved",		&DoReserved},
+	{0,					"DoReserved",		&DoReserved},
+	{WIFI_BEACON,		"OnBeacon",		&OnBeacon},
+	{WIFI_ATIM,			"OnATIM",		&OnAtim},
+	{WIFI_DISASSOC,		"OnDisassoc",		&OnDisassoc},
+	{WIFI_AUTH,			"OnAuth",		&OnAuthClient},
+	{WIFI_DEAUTH,		"OnDeAuth",		&OnDeAuth},
+	{WIFI_ACTION,		"OnAction",		&OnAction},
+};
+
+#ifdef CONFIG_NATIVEAP_MLME
+struct mlme_handler mlme_ap_tbl[]={
+	{WIFI_ASSOCREQ,		"OnAssocReq",	&OnAssocReq},
+	{WIFI_ASSOCRSP,		"OnAssocRsp",	&OnAssocRsp},
+	{WIFI_REASSOCREQ,	"OnReAssocReq",	&OnAssocReq},
+	{WIFI_REASSOCRSP,	"OnReAssocRsp",	&OnAssocRsp},
+	{WIFI_PROBEREQ,		"OnProbeReq",	&OnProbeReq},
+	{WIFI_PROBERSP,		"OnProbeRsp",		&OnProbeRsp},
+
+	/*----------------------------------------------------------
+					below 2 are reserved
+	-----------------------------------------------------------*/
+	{0,					"DoReserved",		&DoReserved},
+	{0,					"DoReserved",		&DoReserved},
+	{WIFI_BEACON,		"OnBeacon",		&OnBeacon},
+	{WIFI_ATIM,			"OnATIM",		&OnAtim},
+	{WIFI_DISASSOC,		"OnDisassoc",		&OnDisassoc},
+	{WIFI_AUTH,			"OnAuth",		&OnAuth},
+	{WIFI_DEAUTH,		"OnDeAuth",		&OnDeAuth},
+	{WIFI_ACTION,		"OnAction",		&OnAction},
+};
+#endif
+
+struct action_handler OnAction_tbl[]={
+	{WLAN_CATEGORY_SPECTRUM_MGMT,	 "ACTION_SPECTRUM_MGMT", &DoReserved},
+	{WLAN_CATEGORY_QOS, "ACTION_QOS", &OnAction_qos},
+	{WLAN_CATEGORY_DLS, "ACTION_DLS", &OnAction_dls},
+	{WLAN_CATEGORY_BACK, "ACTION_BACK", &OnAction_back},
+	{WLAN_CATEGORY_PUBLIC, "ACTION_PUBLIC", &OnAction_public},
+	{WLAN_CATEGORY_RADIO_MEASUREMENT, "ACTION_RADIO_MEASUREMENT", &DoReserved},
+	{WLAN_CATEGORY_FT, "ACTION_FT",	&DoReserved},
+	{WLAN_CATEGORY_HT,	"ACTION_HT",	&OnAction_ht},
+	{WLAN_CATEGORY_SA_QUERY, "ACTION_SA_QUERY", &DoReserved},
+	{WLAN_CATEGORY_WMM, "ACTION_WMM", &OnAction_wmm},	
+};
+
+
+/**************************************************
+OUI definitions for the vendor specific IE
+***************************************************/
+unsigned char	WPA_OUI[] = {0x00, 0x50, 0xf2, 0x01};
+unsigned char WMM_OUI[] = {0x00, 0x50, 0xf2, 0x02};
+unsigned char	WPS_OUI[] = {0x00, 0x50, 0xf2, 0x04};
+
+unsigned char	WMM_INFO_OUI[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
+unsigned char	WMM_PARA_OUI[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
+
+unsigned char WPA_TKIP_CIPHER[4] = {0x00, 0x50, 0xf2, 0x02};
+unsigned char RSN_TKIP_CIPHER[4] = {0x00, 0x0f, 0xac, 0x02};
+
+extern unsigned char REALTEK_96B_IE[];
+
+/********************************************************
+MCS rate definitions
+*********************************************************/
+
+unsigned char	MCS_rate_2R[16] = {0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+unsigned char	MCS_rate_1R[16] = {0xff, 0x00, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+
+/****************************************************************************
+
+Following are the initialization functions for WiFi MLME
+
+*****************************************************************************/
+
+static int init_hw_mlme_ext(_adapter *padapter)
+{
+	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	//set_opmode_cmd(padapter, infra_client_with_mlme);//removed
+
+	set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+	return _SUCCESS;
+}
+
+static void init_mlme_ext_priv_value(struct mlme_ext_priv *pmlmeext)
+{
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	unsigned char default_channel_set[NUM_CHANNELS] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 0};
+	unsigned char	mixed_datarate[NumRates] = {_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_,_9M_RATE_, _12M_RATE_, _18M_RATE_, _24M_RATE_, _36M_RATE_, _48M_RATE_, _54M_RATE_, 0xff};
+	unsigned char	mixed_basicrate[NumRates] ={_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, 0xff,};
+
+	pmlmeext->event_seq = 0;
+	pmlmeext->mgnt_seq = 0;//reset to zero when disconnect at client mode
+
+	pmlmeext->cur_channel = 6;
+	pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+	pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+//	_rtw_memcpy(pmlmeext->channel_set, default_channel_set, NUM_CHANNELS);
+	_rtw_memcpy(pmlmeext->datarate, mixed_datarate, NumRates);
+	_rtw_memcpy(pmlmeext->basicrate, mixed_basicrate, NumRates);
+
+	pmlmeext->sitesurvey_res.state = _FALSE;
+	pmlmeext->sitesurvey_res.channel_idx = 0;
+	pmlmeext->sitesurvey_res.bss_cnt = 0;
+
+	pmlmeinfo->state = WIFI_FW_NULL_STATE;
+	pmlmeinfo->reauth_count = 0;
+	pmlmeinfo->reassoc_count = 0;
+	pmlmeinfo->link_count = 0;
+	pmlmeinfo->auth_seq = 0;
+	pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
+	pmlmeinfo->key_index = 0;
+	pmlmeinfo->key_mask = 0;
+	pmlmeinfo->iv = 0;
+
+	pmlmeinfo->enc_algo = _NO_PRIVACY_;
+	pmlmeinfo->authModeToggle = 0;
+
+	_rtw_memset(pmlmeinfo->chg_txt, 0, 128);
+
+}
+
+static u8 init_channel_set(u8 ChannelPlan, RT_CHANNEL_INFO *channel_set)
+{
+	//_rtw_memcpy(channel_set, default_channel_set, NUM_CHANNELS);
+	u8 index,chanset_size = 11;
+	_rtw_memset(channel_set, 0, sizeof(RT_CHANNEL_INFO)*NUM_CHANNELS);
+
+	if(ChannelPlan >= RT_CHANNEL_DOMAIN_MAX)
+	{
+		printk("channel plan id error \n");
+		return chanset_size;
+	}	
+
+	switch(ChannelPlan)
+	{
+		case RT_CHANNEL_DOMAIN_FCC:
+		case RT_CHANNEL_DOMAIN_IC:	
+			chanset_size = 11;			 
+			break;
+		case RT_CHANNEL_DOMAIN_MKK:
+		case RT_CHANNEL_DOMAIN_MKK1:
+		case RT_CHANNEL_DOMAIN_TELEC:	
+			chanset_size = 14;			 
+			break;
+		case RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN:
+			chanset_size = DefaultChannelPlan[ChannelPlan].Len;			 
+			break;
+		case RT_CHANNEL_DOMAIN_WORLD_WIDE_13:
+			chanset_size = DefaultChannelPlan[ChannelPlan].Len;			 
+			break;
+		case RT_CHANNEL_DOMAIN_ETSI:
+			chanset_size = 13;
+			break;
+		default:
+			chanset_size =11;
+			break;			
+	}
+			
+	for(index=0;index<chanset_size;index++)
+	{
+		channel_set[index].ChannelNum = DefaultChannelPlan[ChannelPlan].Channel[index];
+
+		if(RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) //Channel 1~11 is active, and 12~14 is passive
+		{
+			if(channel_set[index].ChannelNum >= 1 && channel_set[index].ChannelNum <= 11)
+				channel_set[index].ScanType = SCAN_ACTIVE;
+			else if((channel_set[index].ChannelNum  >= 12 && channel_set[index].ChannelNum  <= 14))
+				channel_set[index].ScanType  = SCAN_PASSIVE;			
+		}
+		else if(RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan)// channel 12~13, passive scan
+		{
+			if(channel_set[index].ChannelNum <= 11)
+				channel_set[index].ScanType = SCAN_ACTIVE;
+			else
+				channel_set[index].ScanType = SCAN_PASSIVE;
+		}
+		else
+		{
+			channel_set[index].ScanType = SCAN_ACTIVE;
+		}
+	}
+		
+	return chanset_size;
+}
+
+int	init_mlme_ext_priv(_adapter* padapter)
+{
+	int	res = _SUCCESS;
+	struct registry_priv* pregistrypriv = &padapter->registrypriv;
+	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if(padapter->pwrctrlpriv.bInternalAutoSuspend )
+		return res;
+
+	_rtw_memset((u8 *)pmlmeext, 0, sizeof(struct mlme_ext_priv));
+	pmlmeext->padapter = padapter;
+
+	//fill_fwpriv(padapter, &(pmlmeext->fwpriv));
+
+	init_mlme_ext_priv_value(pmlmeext);
+	pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
+	
+	init_mlme_ext_timer(padapter);
+
+#ifdef CONFIG_AP_MODE
+	init_mlme_ap_info(padapter);	
+#endif
+
+	res = init_hw_mlme_ext(padapter);
+#if 0
+	//update channel_set depends on channel plan
+	switch(pmlmepriv->ChannelPlan)
+	{
+		case RT_CHANNEL_DOMAIN_FCC:
+		case RT_CHANNEL_DOMAIN_IC:	
+			pmlmeext->channel_set[12-1] = 0;
+			pmlmeext->channel_set[13-1] = 0;
+			break;
+		case RT_CHANNEL_DOMAIN_MKK:
+		case RT_CHANNEL_DOMAIN_MKK1:
+		case RT_CHANNEL_DOMAIN_TELEC:	
+			pmlmeext->channel_set[14-1] = 14;
+			pmlmeext->channel_set[15-1] = 0;//the end
+			break;
+		case RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN:
+			pmlmeext->channel_set[12-1] = 0xff;//passive scan
+			pmlmeext->channel_set[13-1] = 0xff;//passive scan
+			pmlmeext->channel_set[14-1] = 0xff;//passive scan
+			pmlmeext->channel_set[15-1] = 0;//the end
+			break;
+		case RT_CHANNEL_DOMAIN_WORLD_WIDE_13:
+			pmlmeext->channel_set[12-1] = 0xff;//passive scan
+			pmlmeext->channel_set[13-1] = 0xff;//passive scan
+			pmlmeext->channel_set[14-1] = 0;//the end
+			break;
+		default:
+			break;			
+	}	
+#else
+	pmlmeext->max_chan_nums = init_channel_set(pmlmepriv->ChannelPlan,pmlmeext->channel_set);
+#endif	
+	pmlmeext->chan_scan_time = SURVEY_TO;
+	pmlmeext->mlmeext_init = _TRUE;
+
+	return res;
+
+}
+
+void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext)
+{
+	_adapter *padapter = pmlmeext->padapter;
+
+	if (!padapter)
+		return;
+
+	if (padapter->bDriverStopped == _TRUE)
+	{
+		_cancel_timer_ex(&pmlmeext->survey_timer);
+		_cancel_timer_ex(&pmlmeext->link_timer);
+		//_cancel_timer_ex(&pmlmeext->ADDBA_timer);
+	}
+	
+	
+}
+
+static void _mgt_dispatcher(_adapter *padapter, struct mlme_handler *ptable, union recv_frame *precv_frame)
+{
+	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	u8 *pframe = precv_frame->u.hdr.rx_data; 
+	uint len = precv_frame->u.hdr.len;
+
+	if(ptable->func)
+        {
+       	 //receive the frames that ra(a1) is my address or ra(a1) is bc address.
+		if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&
+			!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN)) 
+		{
+			return;
+		}
+		
+		ptable->func(padapter, precv_frame);
+        }
+	
+}
+
+void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
+{
+	int index;
+	struct mlme_handler *ptable;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint len = precv_frame->u.hdr.len;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("+mgt_dispatcher: type(0x%x) subtype(0x%x)\n",
+		  GetFrameType(pframe), GetFrameSubType(pframe)));
+
+#if 0
+	{
+		u8 *pbuf;
+		pbuf = GetAddr1Ptr(pframe);
+		printk("A1-%x:%x:%x:%x:%x:%x\n", *pbuf, *(pbuf+1), *(pbuf+2), *(pbuf+3), *(pbuf+4), *(pbuf+5));
+		pbuf = GetAddr2Ptr(pframe);
+		printk("A2-%x:%x:%x:%x:%x:%x\n", *pbuf, *(pbuf+1), *(pbuf+2), *(pbuf+3), *(pbuf+4), *(pbuf+5));
+		pbuf = GetAddr3Ptr(pframe);
+		printk("A3-%x:%x:%x:%x:%x:%x\n", *pbuf, *(pbuf+1), *(pbuf+2), *(pbuf+3), *(pbuf+4), *(pbuf+5));
+	}
+#endif
+
+	if (GetFrameType(pframe) != WIFI_MGT_TYPE)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("mgt_dispatcher: type(0x%x) error!\n", GetFrameType(pframe)));
+		return;
+	}
+
+	//receive the frames that ra(a1) is my address or ra(a1) is bc address.
+	if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&
+		!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))
+	{
+		return;
+	}
+
+	ptable = mlme_sta_tbl;
+
+#if 0
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+		ptable = mlme_sta_tbl;
+#ifdef CONFIG_NATIVEAP_MLME	
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		ptable = mlme_ap_tbl;
+#endif
+	else
+		return;
+
+#endif
+	index = GetFrameSubType(pframe) >> 4;
+
+	if (index > 13)
+	{
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Currently we do not support reserved sub-fr-type=%d\n", index));
+		return;
+	}
+	ptable += index;
+
+#if 0//gtest
+	sa = get_sa(pframe);
+	psta = search_assoc_sta(sa, padapter);
+	// only check last cache seq number for management frame
+	if (psta != NULL) {
+		if (GetRetry(pframe)) {
+			if (GetTupleCache(pframe) == psta->rxcache->nonqos_seq){
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("drop due to decache!\n"));
+				return;
+			}
+		}
+		psta->rxcache->nonqos_seq = GetTupleCache(pframe);
+	}
+#else
+
+	if(GetRetry(pframe))
+	{
+		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("drop due to decache!\n"));
+		//return;
+	}
+#endif
+
+#ifdef CONFIG_AP_MODE
+	switch (GetFrameSubType(pframe)) 
+	{
+		case WIFI_ASSOCREQ:
+		case WIFI_REASSOCREQ:
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+				hostapd_mlme_rx(padapter, precv_frame);
+			break;
+		case WIFI_PROBEREQ:
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+				hostapd_mlme_rx(padapter, precv_frame);
+			else
+				_mgt_dispatcher(padapter, ptable, precv_frame);
+			break;
+		case WIFI_BEACON:			
+			_mgt_dispatcher(padapter, ptable, precv_frame);
+			break;
+		case WIFI_ACTION:
+			//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+			_mgt_dispatcher(padapter, ptable, precv_frame);		
+			break;
+		default:
+			_mgt_dispatcher(padapter, ptable, precv_frame);	
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+				hostapd_mlme_rx(padapter, precv_frame);			
+			break;
+	}
+#else
+
+	_mgt_dispatcher(padapter, ptable, precv_frame);	
+	
+#endif
+
+}
+/****************************************************************************
+
+Following are the callback functions for each subtype of the management frames
+
+*****************************************************************************/
+
+unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
+{
+	unsigned int	ielen;
+	unsigned char	*p;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 	*cur = &(pmlmeinfo->network);
+
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint len = precv_frame->u.hdr.len;
+
+	//DBG_871X("+OnProbeReq\n");
+
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+		return _SUCCESS;
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE && 
+		check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_FALSE)
+	return _SUCCESS;
+	
+	
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&ielen,
+			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
+
+	if (p != NULL)
+	{
+		if ((ielen != 0) && (!_rtw_memcmp((void *)(p+2), (void *)cur->Ssid.Ssid, le32_to_cpu(cur->Ssid.SsidLength))))
+		{
+			return SUCCESS;
+		}
+		
+		issue_probersp(padapter, get_sa(pframe));
+	}
+
+	return _SUCCESS;
+	
+}
+
+unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame)
+{
+	struct sta_info	*psta;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv	*pstapriv = &padapter->stapriv;
+	u8 *pframe = precv_frame->u.hdr.rx_data; 
+	//uint len = precv_frame->u.hdr.len;
+
+	if (pmlmeext->sitesurvey_res.state == _TRUE)
+	{
+		report_survey_event(padapter, precv_frame);
+		//if (_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))				
+		//	pHalData->hal_ops.process_phy_info(padapter, precv_frame);
+		return _SUCCESS;
+	}
+
+	if (_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))
+	{
+		//pHalData->hal_ops.process_phy_info(padapter, precv_frame);
+	
+		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+		{
+			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
+			{
+				psta->sta_stats.rx_pkts++;
+			}
+		}
+	}
+	
+	return _SUCCESS;
+	
+}
+
+unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
+{
+	int cam_idx;
+	struct sta_info	*psta;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv	*pstapriv = &padapter->stapriv;
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint len = precv_frame->u.hdr.len;
+
+	if (pmlmeext->sitesurvey_res.state == _TRUE)
+	{
+		report_survey_event(padapter, precv_frame);
+		//if (_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))	
+		//	pHalData->hal_ops.process_phy_info(padapter, precv_frame);
+
+		return _SUCCESS;
+	}
+
+	if (_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))
+	{
+		//pHalData->hal_ops.process_phy_info(padapter, precv_frame);
+	
+		if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
+		{
+			//check the vendor of the assoc AP
+			pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct ieee80211_hdr_3addr), len-sizeof(struct ieee80211_hdr_3addr));				
+
+			//update TSF Value
+			update_TSF(pmlmeext, pframe, len);
+
+			//start auth
+			start_clnt_auth(padapter);
+			
+			return _SUCCESS;
+		}
+
+		if(((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) && (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+		{
+			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
+			{
+				//update WMM, ERP in the beacon
+				//todo: the timer is used instead of the number of the beacon received
+				if ((psta->sta_stats.rx_pkts & 0xf) == 0)
+				{				
+					//DBG_871X("update_bcn_info\n");
+					update_beacon_info(padapter, pframe, len, psta);
+				}
+				psta->sta_stats.rx_pkts++;
+			}		
+		}
+		else if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+		{
+			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
+			{
+				//update WMM, ERP in the beacon
+				//todo: the timer is used instead of the number of the beacon received
+				if ((psta->sta_stats.rx_pkts & 0xf) == 0)
+				{
+					//DBG_871X("update_bcn_info\n");
+					update_beacon_info(padapter, pframe, len, psta);
+				}
+				psta->sta_stats.rx_pkts++;				
+			}
+			else
+			{	
+					
+				//allocate a new CAM entry for IBSS station
+				if ((cam_idx = allocate_cam_entry(padapter)) == NUM_STA)
+				{
+					goto _END_ONBEACON_;
+				}
+
+				//get supported rate
+				if (update_sta_support_rate(padapter, (pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_), (len - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_), cam_idx) == _FAIL)
+				{
+					pmlmeinfo->FW_sta_info[cam_idx].status = 0;
+					goto _END_ONBEACON_;
+				}
+		
+				//update TSF Value
+				update_TSF(pmlmeext, pframe, len);			
+
+				//report sta add event
+				report_add_sta_event(padapter, GetAddr2Ptr(pframe), cam_idx);
+
+				//pmlmeext->linked_to = LINKED_TO;
+				
+			}				
+
+		}
+
+	}
+
+_END_ONBEACON_:
+
+	return _SUCCESS;
+
+}
+
+unsigned int OnAuthClient(_adapter *padapter, union recv_frame *precv_frame)
+{
+	unsigned int	seq, len, status, algthm, offset;
+	unsigned char	*p;
+	unsigned int	go2asoc = 0;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint pkt_len = precv_frame->u.hdr.len;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	//check A1 matches or not
+	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+
+	if (!(pmlmeinfo->state & WIFI_FW_AUTH_STATE))
+		return _SUCCESS;
+
+	offset = (GetPrivacy(pframe))? 4: 0;
+
+	algthm 	= le16_to_cpu(*(unsigned short *)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + offset));
+	seq 	= le16_to_cpu(*(unsigned short *)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + offset + 2));
+	status 	= le16_to_cpu(*(unsigned short *)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + offset + 4));
+
+	if (status != 0)
+	{
+		DBG_871X("clnt auth fail, status: %d\n", status);
+		goto authclnt_fail;
+	}
+
+	if (seq == 2)
+	{
+		if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+		{
+			 // legendary shared system
+			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _AUTH_IE_OFFSET_, _CHLGETXT_IE_, (int *)&len,
+				pkt_len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_);
+
+			if (p == NULL)
+			{
+				//printk("marc: no challenge text?\n");
+				goto authclnt_fail;
+			}
+
+			_rtw_memcpy((void *)(pmlmeinfo->chg_txt), (void *)(p + 2), len);
+			pmlmeinfo->auth_seq = 3;
+			issue_auth(padapter, NULL, 0);
+
+			return _SUCCESS;
+		}
+		else
+		{
+			// open system
+			go2asoc = 1;
+		}
+	}
+	else if (seq == 4)
+	{
+		if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+		{
+			go2asoc = 1;
+		}
+		else
+		{
+			goto authclnt_fail;
+		}
+	}
+	else
+	{
+		// this is also illegal
+		//printk("marc: clnt auth failed due to illegal seq=%x\n", seq);
+		goto authclnt_fail;
+	}
+
+	if (go2asoc)
+	{
+		start_clnt_assoc(padapter);
+		return _SUCCESS;
+	}
+
+authclnt_fail:
+
+	//pmlmeinfo->state &= ~(WIFI_FW_AUTH_STATE);
+
+	return _FAIL;
+
+}
+
+unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
+{
+	DBG_871X("%s\n", __FUNCTION__);
+	return _SUCCESS;
+}
+
+unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame)
+{
+	uint i;
+	int res;
+	unsigned short	status, caps;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	//WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint pkt_len = precv_frame->u.hdr.len;
+
+	DBG_871X("%s\n", __FUNCTION__);
+	
+	//check A1 matches or not
+	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+
+	if (!(pmlmeinfo->state & (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)))
+		return _SUCCESS;
+
+	
+	 if(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+	 	return _SUCCESS;
+
+
+	 _cancel_timer_ex(&pmlmeext->link_timer);
+
+	 
+	//status
+	if ((status = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 2))) > 0)
+	{
+		DBG_871X("assoc reject, status code: %d\n", status);
+		res = -4;
+		goto report_assoc_result;
+	}
+	
+	//get capabilities
+	caps = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+
+	//set slot time
+	pmlmeinfo->slotTime = (caps & BIT(10))? 9: 20;
+
+	//AID
+	res = pmlmeinfo->aid = (int)(le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 4))&0x3fff);
+
+	//following are moved to join event callback function
+	//to handle HT, WMM, rate adaptive, update MAC reg
+	//for not to handle the synchronous IO in the tasklet
+	for (i = (6 + WLAN_HDR_A3_LEN); i < pkt_len;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + i);
+
+		switch (pIE->ElementID)
+		{
+			case _VENDOR_SPECIFIC_IE_:
+				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6))	//WMM
+				{
+					WMM_param_handler(padapter, pIE);
+				}
+				break;
+
+			case _HT_CAPABILITY_IE_:	//HT caps
+				HT_caps_handler(padapter, pIE);
+				break;
+
+			case _HT_EXTRA_INFO_IE_:	//HT info
+				HT_info_handler(padapter, pIE);
+				break;
+
+			case _ERPINFO_IE_:
+				ERP_IE_handler(padapter, pIE);
+
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	pmlmeinfo->state &= (~WIFI_FW_ASSOC_STATE);
+	pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+
+report_assoc_result:
+
+	report_join_res(padapter, res);
+
+	return _SUCCESS;
+}
+
+unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;	
+	struct sitesurvey_ctrl *psitesurveyctrl=&pmlmepriv->sitesurveyctrl;
+	
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint len = precv_frame->u.hdr.len;
+	unsigned short	reason;
+	//check A3
+	if (!(_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
+		return _SUCCESS;
+	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+	DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
+	
+	psitesurveyctrl->traffic_busy= _FALSE;
+	receive_disconnect(padapter, GetAddr3Ptr(pframe));
+	
+	return _SUCCESS;
+}
+
+unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;	
+	struct sitesurvey_ctrl *psitesurveyctrl=&pmlmepriv->sitesurveyctrl;
+	
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint len = precv_frame->u.hdr.len;
+	unsigned short	reason;
+	//check A3
+	if (!(_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
+		return _SUCCESS;
+	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+	DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
+	psitesurveyctrl->traffic_busy= _FALSE;
+	receive_disconnect(padapter, GetAddr3Ptr(pframe));
+	
+	return _SUCCESS;
+}
+
+unsigned int OnAtim(_adapter *padapter, union recv_frame *precv_frame)
+{
+	DBG_871X("%s\n", __FUNCTION__);
+	return _SUCCESS;
+}
+
+unsigned int OnAction_qos(_adapter *padapter, union recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_dls(_adapter *padapter, union recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
+{
+	u8 *addr;
+	struct sta_info *psta=NULL;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	unsigned char		*frame_body;
+	unsigned char		category, action;
+	unsigned short	tid, status, reason_code;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+					
+	uint len = precv_frame->u.hdr.len;
+
+	//check RA matches or not	
+	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
+		return _SUCCESS;
+
+/*
+	//check A1 matches or not
+	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+*/
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)	
+		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+			return _SUCCESS;
+
+	addr = GetAddr2Ptr(pframe);
+	psta = rtw_get_stainfo(pstapriv, addr);
+
+	if(psta==NULL)
+		return _SUCCESS;
+
+	frame_body = (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
+
+	category = frame_body[0];
+	if (category == WLAN_CATEGORY_BACK)// representing Block Ack
+	{
+		if (!pmlmeinfo->HT_enable)
+		{
+			return _SUCCESS;
+		}
+
+		action = frame_body[1];
+		DBG_871X("%s, action=%d\n", __FUNCTION__, action);
+		switch (action)
+		{
+			case WLAN_ACTION_ADDBA_REQ: //ADDBA request
+
+				_rtw_memcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]), sizeof(struct ADDBA_request));
+				//process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe));
+				process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), addr);
+				
+				if(pmlmeinfo->bAcceptAddbaReq == _TRUE)
+				{
+					issue_action_BA(padapter, addr, WLAN_ACTION_ADDBA_RESP, 0);
+				}
+				else
+				{
+					issue_action_BA(padapter, addr, WLAN_ACTION_ADDBA_RESP, 37);//reject ADDBA Req
+				}
+								
+				break;
+
+			case WLAN_ACTION_ADDBA_RESP: //ADDBA response
+
+				status = frame_body[3] | (frame_body[4] << 8); //endian issue
+				tid = ((frame_body[5] >> 2) & 0x7);
+
+				if (status == 0)
+				{	//successful					
+					psta->htpriv.agg_enable_bitmap |= 1 << tid;					
+					psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);				
+				}
+				else
+				{					
+					psta->htpriv.agg_enable_bitmap &= ~BIT(tid);					
+				}
+
+				//printk("marc: ADDBA RSP: %x\n", pmlmeinfo->agg_enable_bitmap);
+				break;
+
+			case WLAN_ACTION_DELBA: //DELBA
+				if ((frame_body[3] & BIT(3)) == 0)
+				{
+					psta->htpriv.agg_enable_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
+					psta->htpriv.candidate_tid_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
+					
+					reason_code = frame_body[4] | (frame_body[5] << 8);
+				}
+				else if((frame_body[3] & BIT(3)) == 1)
+				{						
+					tid = (frame_body[3] >> 4) & 0x0F;
+				
+					preorder_ctrl =  &psta->recvreorder_ctrl[tid];
+					preorder_ctrl->enable = _FALSE;
+					preorder_ctrl->indicate_seq = 0xffff;
+				}
+				
+				//printk("marc: DELBA: %x(%x)\n", pmlmeinfo->agg_enable_bitmap, reason_code);
+				//todo: how to notify the host while receiving DELETE BA
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	return _SUCCESS;
+}
+
+unsigned int OnAction_public(_adapter *padapter, union recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_ht(_adapter *padapter, union recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_wmm(_adapter *padapter, union recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame)
+{
+	int i;
+	unsigned char	category;
+	struct action_handler *ptable;
+	unsigned char	*frame_body;
+	u8 *pframe = precv_frame->u.hdr.rx_data; 
+
+	frame_body = (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
+	
+	category = frame_body[0];
+	
+	for(i = 0; i < sizeof(OnAction_tbl)/sizeof(struct action_handler); i++)	
+	{
+		ptable = &OnAction_tbl[i];
+		
+		if(category == ptable->num)
+			ptable->func(padapter, precv_frame);
+	
+	}
+
+	return _SUCCESS;
+
+}
+
+unsigned int DoReserved(_adapter *padapter, union recv_frame *precv_frame)
+{
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint len = precv_frame->u.hdr.len;
+
+	//DBG_871X("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe));
+	return _SUCCESS;
+}
+
+struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv)
+{
+	struct xmit_frame			*pmgntframe;
+	struct xmit_buf				*pxmitbuf;
+
+	if ((pmgntframe = rtw_alloc_xmitframe(pxmitpriv)) == NULL)
+	{
+		return NULL;
+	}
+
+	if ((pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv))	== NULL)
+	{
+		//todo: maybe can enqueue
+
+		rtw_free_xmitframe_ex(pxmitpriv, pmgntframe);
+		return NULL;
+	}
+
+	pmgntframe->frame_tag = MGNT_FRAMETAG;
+
+	pmgntframe->pxmitbuf = pxmitbuf;
+
+	pmgntframe->buf_addr = pxmitbuf->pbuf;
+
+	pxmitbuf->priv_data = pmgntframe;
+
+	return pmgntframe;
+
+}
+
+
+/****************************************************************************
+
+Following are some TX fuctions for WiFi MLME
+
+*****************************************************************************/
+
+void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
+{
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+
+	_rtw_memset((u8 *)(pattrib), 0, sizeof(struct pkt_attrib));
+
+	pattrib->hdrlen = 24;
+	pattrib->nr_frags = 1;
+	pattrib->priority = 7;
+	pattrib->mac_id = 0;
+	pattrib->qsel = 0x12;
+
+	pattrib->pktlen = 0;
+
+	pattrib->raid = 6;//b mode
+
+	pattrib->encrypt = _NO_PRIVACY_;
+	pattrib->bswenc = _FALSE;	
+
+	pattrib->qos_en = _FALSE;
+	pattrib->ht_en = _FALSE;
+	pattrib->bwmode = HT_CHANNEL_WIDTH_20;
+	pattrib->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	pattrib->sgi = _FALSE;
+
+	pattrib->seqnum = pmlmeext->mgnt_seq;
+
+}
+
+void dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe)
+{
+	rtw_dump_xframe(padapter, pmgntframe);
+}
+
+void issue_beacon(_adapter *padapter)
+{
+	struct xmit_frame	*pmgntframe;
+	struct pkt_attrib	*pattrib;
+	unsigned char	*pframe;
+	struct ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;
+	unsigned int	rate_len;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+	pattrib->qsel = 0x10;
+	
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+		
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;	
+	
+	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	
+	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	//pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_BEACON);
+	
+	pframe += sizeof(struct ieee80211_hdr_3addr);	
+	pattrib->pktlen = sizeof (struct ieee80211_hdr_3addr);
+	
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	pattrib->pktlen += 8;
+
+	// beacon interval: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	// capability info: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		DBG_871X("ie len=%d\n", cur_network->IELength);
+		pattrib->pktlen += cur_network->IELength - sizeof(NDIS_802_11_FIXED_IEs);
+		_rtw_memcpy(pframe, cur_network->IEs+sizeof(NDIS_802_11_FIXED_IEs), pattrib->pktlen);
+		
+		goto _issue_bcn;
+	}
+
+	//below for ad-hoc mode
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);
+
+	// supported rates...
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pattrib->pktlen);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		u32 ATIMWindow;
+		// IBSS Parameter Set...
+		//ATIMWindow = cur->Configuration.ATIMWindow;
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
+	}	
+
+
+	//todo: ERP IE
+	
+	
+	// EXTERNDED SUPPORTED RATE
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);
+	}
+
+
+	//todo:HT for adhoc
+
+_issue_bcn:
+
+	if ((pattrib->pktlen + TXDESC_SIZE) > 512)
+	{
+		DBG_871X("beacon frame too large\n");
+		return;
+	}
+	
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	DBG_871X("issue bcn_sz=%d\n", pattrib->last_txcmdsz);
+
+	dump_mgntframe(padapter, pmgntframe);
+
+}
+
+void issue_probersp(_adapter *padapter, unsigned char *da)
+{
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;	
+	unsigned int	rate_len;
+	unsigned char					*mac, *bssid;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+
+	//DBG_871X("%s\n", __FUNCTION__);
+	
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+	
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);	
+	
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+		
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;	
+	
+	mac = myid(&(padapter->eeprompriv));
+	bssid = cur_network->MacAddress;
+	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	_rtw_memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, bssid, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(fctrl, WIFI_PROBERSP);
+	
+	pattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);
+	pattrib->pktlen = pattrib->hdrlen;
+	pframe += pattrib->hdrlen;
+
+
+	if(cur_network->IELength>MAX_IE_SZ)
+		return;
+
+#if 0	
+	_rtw_memcpy(pframe, cur_network->IEs, cur_network->IELength);
+	pframe += cur_network->IELength;
+	pattrib->pktlen += cur_network->IELength;
+#else	
+	
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	pattrib->pktlen += 8;
+
+	// beacon interval: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	// capability info: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		DBG_871X("ie len=%d\n", cur_network->IELength);
+		pattrib->pktlen += cur_network->IELength - sizeof(NDIS_802_11_FIXED_IEs);
+		_rtw_memcpy(pframe, cur_network->IEs+sizeof(NDIS_802_11_FIXED_IEs), pattrib->pktlen);
+		
+		goto _issue_probersp;
+	}
+
+	//below for ad-hoc mode
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);
+
+	// supported rates...
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pattrib->pktlen);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		u32 ATIMWindow;
+		// IBSS Parameter Set...
+		//ATIMWindow = cur->Configuration.ATIMWindow;
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
+	}	
+
+
+	//todo: ERP IE
+	
+	
+	// EXTERNDED SUPPORTED RATE
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);
+	}
+
+
+	//todo:HT for adhoc
+
+#endif
+
+_issue_probersp:
+	
+	
+	pattrib->last_txcmdsz = pattrib->pktlen;
+	//DBG_871X("issue probersp_sz=%d\n", pattrib->last_txcmdsz);
+
+	dump_mgntframe(padapter, pmgntframe);
+	
+	return;
+
+}
+
+void issue_probereq(_adapter *padapter, u8 blnbc)
+{
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	unsigned char					*mac;
+	unsigned char					bssrate[NumRates];
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int	bssrate_len = 0;
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("+issue_probereq\n"));
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+	
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	mac = myid(&(padapter->eeprompriv));
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	
+	if ( 0 == blnbc )
+	{
+		//	unicast probe request frame
+		_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+		_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	}
+	else
+	{
+		//	broadcast probe request frame
+		_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+		_rtw_memcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);
+	}
+
+	_rtw_memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_PROBEREQ);
+
+	pframe += sizeof (struct ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof (struct ieee80211_hdr_3addr);
+
+	pframe = rtw_set_ie(pframe, _SSID_IE_, pmlmeext->sitesurvey_res.ss_ssidlen, pmlmeext->sitesurvey_res.ss_ssid, &(pattrib->pktlen));
+
+	get_rate_set(padapter, bssrate, &bssrate_len);
+
+	if (bssrate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
+	}
+	else
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("issuing probe_req, tx_len=%d\n", pattrib->last_txcmdsz));
+
+	dump_mgntframe(padapter, pmgntframe);
+
+	return;
+}
+
+// if psta == NULL, indiate we are station(client) now...
+void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status)
+{
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	unsigned int					val32;
+	unsigned short				val16;
+	int use_shared_key = 0;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_AUTH);
+
+	pframe += sizeof(struct ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
+
+
+	if(psta)// for AP mode
+	{
+	
+                //TODO:
+
+	}
+	else
+	{		
+		_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);
+		_rtw_memcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);
+		_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);
+	
+		
+		// setting auth algo number		
+		val16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)? 1: 0;// 0:OPEN System, 1:Shared key
+		if (val16)	{
+			val16 = cpu_to_le16(val16);	
+			use_shared_key = 1;
+		}	
+		if(pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+		{
+			printk("%s auth_algo= %s auth_seq=%d\n",__FUNCTION__,"SHARED",pmlmeinfo->auth_seq);
+		}
+		else if(pmlmeinfo->auth_algo == dot11AuthAlgrthm_Open)
+		{
+			printk("%s auth_algo= %s auth_seq=%d\n",__FUNCTION__,"OPEN",pmlmeinfo->auth_seq);
+		}
+		else if(pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto)
+		{
+			printk("%s auth_algo= %s auth_seq=%d\n",__FUNCTION__,"AUTO",pmlmeinfo->auth_seq);
+		}else
+		{
+			printk("%s auth_algo= %s(algo:%d) auth_seq=%d\n",__FUNCTION__,"#####",pmlmeinfo->auth_algo,pmlmeinfo->auth_seq);
+		}
+
+		
+		//setting IV for auth seq #3
+		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
+		{
+			printk("==> iv(%d),key_index(%d)\n",pmlmeinfo->iv,pmlmeinfo->key_index);
+			val32 = ((pmlmeinfo->iv++) | (pmlmeinfo->key_index << 30));
+			val32 = cpu_to_le32(val32);
+			pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&val32, &(pattrib->pktlen));
+
+			pattrib->iv_len = 4;
+		}
+
+		printk("==>issue_auth ,auth_algm(0x%02x)\n",val16);
+		pframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
+		
+		// setting auth seq number
+		val16 = pmlmeinfo->auth_seq;
+		val16 = cpu_to_le16(val16);	
+		printk("==> %s set auth_seq_num(%d)\n",__FUNCTION__,val16);
+		pframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+		
+		// setting status code...
+		val16 = status;
+		val16 = cpu_to_le16(val16);	
+		pframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+		// then checking to see if sending challenging text...
+		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
+		{
+			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, pmlmeinfo->chg_txt, &(pattrib->pktlen));
+
+			SetPrivacy(fctrl);
+			
+			pattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);			
+			
+			pattrib->encrypt = _WEP40_;
+
+			pattrib->icv_len = 4;
+			
+			pattrib->pktlen += pattrib->icv_len;			
+			
+		}
+		
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	rtw_wep_encrypt(padapter, (u8 *)pmgntframe);
+
+	dump_mgntframe(padapter, pmgntframe);
+
+	return;
+}
+
+void issue_assocreq(_adapter *padapter)
+{
+	struct xmit_frame					*pmgntframe;
+	struct pkt_attrib					*pattrib;
+	unsigned char							*pframe, *p;
+	struct ieee80211_hdr			*pwlanhdr;
+	unsigned short						*fctrl;
+	unsigned short						val16;
+	unsigned int							i, ie_len;
+	unsigned char							bssrate[NumRates];
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;	
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+	
+	int	bssrate_len = 0;
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ASSOCREQ);
+
+	pframe += sizeof(struct ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
+
+	//caps
+	_rtw_memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	//listen interval
+	//todo: listen interval for power saving
+	val16 = cpu_to_le16(3);
+	_rtw_memcpy(pframe ,(unsigned char *)&val16, 2);
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	//SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_,  pmlmeinfo->network.Ssid.SsidLength, pmlmeinfo->network.Ssid.Ssid, &(pattrib->pktlen));
+
+	//supported rate & extended supported rate
+#if 0
+	get_rate_set(padapter, bssrate, &bssrate_len);
+#else
+	for (bssrate_len = 0; bssrate_len < NumRates; bssrate_len++) {
+		if (pmlmeinfo->network.SupportedRates[bssrate_len] == 0) break;
+		bssrate[bssrate_len] = pmlmeinfo->network.SupportedRates[bssrate_len];
+	}
+#endif
+
+	if (bssrate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
+	}
+	else
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
+	}
+
+	//RSN
+	p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(NDIS_802_11_FIXED_IEs)), _RSN_IE_2_, &ie_len, (pmlmeinfo->network.IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+	if (p != NULL)
+	{
+		pframe = rtw_set_ie(pframe, _RSN_IE_2_, ie_len, (p + 2), &(pattrib->pktlen));
+	}
+
+	//HT caps
+	if(phtpriv->ht_option==1)
+	{
+	p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_CAPABILITY_IE_, &ie_len, (pmlmeinfo->network.IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+	if ((p != NULL) && (!(is_ap_in_tkip(padapter))))
+	{
+		_rtw_memcpy(&(pmlmeinfo->HT_caps), (p + 2), sizeof(struct HT_caps_element));
+
+		//to disable 40M Hz support while gd_bw_40MHz_en = 0
+		if (pregpriv->cbw40_enable == 0)
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info &= (~(BIT(6) | BIT(1)));
+		}
+		else
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info |= BIT(1);
+		}
+
+		//todo: disable SM power save mode
+		pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info |= 0x000c;
+
+		//switch (pregpriv->rf_config)
+		switch(pHalData->rf_type)
+		{
+			case RF_1T1R:
+				pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info |= 0x0100;//RX STBC One spatial stream
+				_rtw_memcpy(pmlmeinfo->HT_caps.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
+				break;
+
+			case RF_2T2R:
+			case RF_1T2R:
+			default:
+				pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info |= 0x0200;//RX STBC two spatial stream
+				_rtw_memcpy(pmlmeinfo->HT_caps.HT_cap_element.MCS_rate, MCS_rate_2R, 16);
+				break;
+		}
+		
+		#ifdef RTL8192C_RECONFIG_TO_1T1R
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info |= 0x0100;//RX STBC One spatial stream
+			_rtw_memcpy(pmlmeinfo->HT_caps.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
+		}
+		#endif
+
+		pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info = cpu_to_le16(pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info);
+		pframe = rtw_set_ie(pframe, _HT_CAPABILITY_IE_, ie_len , (u8 *)(&(pmlmeinfo->HT_caps)), &(pattrib->pktlen));
+		
+	}
+	}
+
+	//vendor specific IE, such as WPA, WMM, WPS
+	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pmlmeinfo->network.IELength;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pmlmeinfo->network.IEs + i);
+
+		switch (pIE->ElementID)
+		{
+			case _VENDOR_SPECIFIC_IE_:
+				if ((_rtw_memcmp(pIE->data, WPA_OUI, 4)) ||
+						(_rtw_memcmp(pIE->data, WMM_OUI, 4)) ||
+						(_rtw_memcmp(pIE->data, WPS_OUI, 4)))
+				{
+					pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, pIE->Length, pIE->data, &(pattrib->pktlen));
+				}
+				break;
+
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	if (pmlmeinfo->assoc_AP_vendor == realtekAP)
+	{
+		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6 , REALTEK_96B_IE, &(pattrib->pktlen));
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+	dump_mgntframe(padapter, pmgntframe);
+
+	return;
+}
+
+void issue_nulldata(_adapter *padapter, unsigned int power_mode)
+{
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X("%s:%d\n", __FUNCTION__, power_mode);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	SetToDs(fctrl);
+	if (power_mode)
+	{
+		SetPwrMgt(fctrl);
+	}
+
+	_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_DATA_NULL);
+
+	pframe += sizeof(struct ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+	dump_mgntframe(padapter, pmgntframe);
+
+	return;
+}
+
+void issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason)
+{
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_DEAUTH);
+
+	pframe += sizeof(struct ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
+
+	reason = cpu_to_le16(reason);
+	pframe = rtw_set_fixed_ie(pframe, _RSON_CODE_ , (unsigned char *)&reason, &(pattrib->pktlen));
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(padapter, pmgntframe);
+}
+
+void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status)
+{
+	static char			dialogToken_to_AP = 0;
+	unsigned char category = WLAN_CATEGORY_BACK;
+	unsigned short	start_seq;
+	unsigned short	BA_para_set;
+	unsigned short	reason_code;
+	unsigned short	BA_timeout_value;
+	unsigned short	BA_starting_seqctrl;
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_info				*psta;
+	struct sta_priv				*pstapriv = &padapter->stapriv;
+
+
+	DBG_871X("%s, category=%d, action=%d, status=%d\n", __FUNCTION__, category, action, status);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	//_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+
+      status = cpu_to_le16(status);
+	
+
+	if (category == 3)
+	{
+		switch (action)
+		{
+			case 0: //ADDBA req
+				do {
+					dialogToken_to_AP++;
+				} while (dialogToken_to_AP == 0);
+				pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken_to_AP), &(pattrib->pktlen));
+
+				BA_para_set = (0x0802 | ((status & 0xf) << 2)); //immediate ack & 32 buffer size
+				//sys_mib.BA_para_set = 0x0802;
+				BA_para_set = cpu_to_le16(BA_para_set);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
+
+				BA_timeout_value = 0;
+				BA_timeout_value = cpu_to_le16(BA_timeout_value);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_timeout_value)), &(pattrib->pktlen));
+
+				//if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
+				if ((psta = rtw_get_stainfo(pstapriv, raddr)) != NULL)
+				{
+					start_seq = (psta->sta_xmitpriv.txseq_tid[status & 0x07]&0xfff) + 1;
+					BA_starting_seqctrl = start_seq << 4;
+				}
+				BA_starting_seqctrl = cpu_to_le16(BA_starting_seqctrl);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_starting_seqctrl)), &(pattrib->pktlen));
+				break;
+
+			case 1: //ADDBA rsp
+				pframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->ADDBA_req.dialog_token), &(pattrib->pktlen));
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&status), &(pattrib->pktlen));
+				BA_para_set = cpu_to_le16((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0800);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(pmlmeinfo->ADDBA_req.BA_para_set)), &(pattrib->pktlen));
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(pmlmeinfo->ADDBA_req.BA_timeout_value)), &(pattrib->pktlen));
+				break;
+			case 2://DELBA
+				BA_para_set = (status & 0x1F) << 3;
+				BA_para_set = cpu_to_le16(BA_para_set);				
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
+
+				reason_code = 37;//Requested from peer STA as it does not want to use the mechanism
+				reason_code = cpu_to_le16(reason_code);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(reason_code)), &(pattrib->pktlen));
+				break;
+			default:
+				break;
+		}
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(padapter, pmgntframe);
+}
+
+static void issue_action_BSSCoexistPacket(_adapter *padapter)
+{	
+	_irqL	irqL;
+	_list		*plist, *phead;
+	unsigned char category, action;
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct	wlan_network	*pnetwork = NULL;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	_queue		*queue	= &(pmlmepriv->scanned_queue);
+	u8 InfoContent[16] = {0};
+	u8 ICS[8][15];
+	
+	if((pmlmepriv->num_FortyMHzIntolerant==0) || (pmlmepriv->num_sta_no_ht==0))
+		return;
+
+	if(_TRUE == pmlmeinfo->bwmode_updated)
+		return;
+	
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+
+	category = WLAN_CATEGORY_PUBLIC;
+	action = ACT_PUBLIC_BSSCOEXIST;
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+
+
+	//
+	if(pmlmepriv->num_FortyMHzIntolerant>0)
+	{
+		u8 iedata=0;
+		
+		iedata |= BIT(2);//20 MHz BSS Width Request
+
+		pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
+		
+	}
+	
+
+	//
+	_rtw_memset(ICS, 0, sizeof(ICS));
+	if(pmlmepriv->num_sta_no_ht>0)
+	{	
+		int i;
+	
+		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+		phead = get_list_head(queue);
+		plist = get_next(phead);
+       
+		while(1)
+		{
+			int len;
+			u8 *p;
+			WLAN_BSSID_EX *pbss_network;
+	
+			if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+				break;		
+
+			pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);      
+		
+			plist = get_next(plist);
+
+			pbss_network = (WLAN_BSSID_EX *)&pnetwork->network;
+
+			p = rtw_get_ie(pbss_network->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, pbss_network->IELength - _FIXED_IE_LENGTH_);
+			if((p==NULL) || (len==0))//non-HT
+			{
+				if((pbss_network->Configuration.DSConfig<=0) || (pbss_network->Configuration.DSConfig>14))
+					continue;
+				
+				ICS[0][pbss_network->Configuration.DSConfig]=1;
+				
+				if(ICS[0][0] == 0)
+					ICS[0][0] = 1;		
+			}		
+	
+		}        
+
+		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+
+		for(i= 0;i<8;i++)
+		{
+			if(ICS[i][0] == 1)
+			{
+				int j, k = 0;
+				
+				InfoContent[k] = i;				
+				//SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent,i);
+				k++;
+				
+				for(j=1;j<=14;j++)
+				{
+					if(ICS[i][j]==1)
+					{
+						if(k<16)
+						{
+							InfoContent[k] = j; //channel number
+							//SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j);
+							k++;
+						}	
+					}	
+				}	
+
+				pframe = rtw_set_ie(pframe, EID_BSSIntolerantChlReport, k, InfoContent, &(pattrib->pktlen));
+				
+			}
+			
+		}
+		
+
+	}
+		
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(padapter, pmgntframe);
+
+}
+
+unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr)
+{
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *psta = NULL;
+//	struct recv_reorder_ctrl *preorder_ctrl;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u16 tid;
+
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)	
+		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+			return _SUCCESS;
+	
+	psta = rtw_get_stainfo(pstapriv, addr);
+	if(psta==NULL)
+		return _SUCCESS;
+
+	//printk("%s:%s\n", __FUNCTION__, (initiator==0)?"RX_DIR":"TX_DIR");
+	
+	if(initiator==0) // recipient
+	{
+		for(tid = 0;tid<MAXTID;tid++)
+		{
+			if(psta->recvreorder_ctrl[tid].enable == _TRUE)
+			{
+				printk("rx agg disable tid(%d)\n",tid);
+				issue_action_BA(padapter, addr, WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F));
+				psta->recvreorder_ctrl[tid].enable = _FALSE;
+				psta->recvreorder_ctrl[tid].indicate_seq = 0xffff;
+			}		
+		}
+	}
+	else if(initiator == 1)// originator
+	{
+		//printk("tx agg_enable_bitmap(0x%08x)\n", psta->htpriv.agg_enable_bitmap);
+		for(tid = 0;tid<MAXTID;tid++)
+		{
+			if(psta->htpriv.agg_enable_bitmap & BIT(tid))
+			{
+				printk("tx agg disable tid(%d)\n",tid);
+				issue_action_BA(padapter, addr, WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F) );
+				psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
+				psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
+				
+			}			
+		}
+	}
+	
+	return _SUCCESS;
+	
+}
+
+
+/****************************************************************************
+
+Following are some utitity fuctions for WiFi MLME
+
+*****************************************************************************/
+
+void site_survey(_adapter *padapter)
+{
+	unsigned char					survey_channel;
+	RT_SCAN_TYPE	ScanType;	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	survey_channel = pmlmeext->channel_set[pmlmeext->sitesurvey_res.channel_idx].ChannelNum;
+	ScanType = pmlmeext->channel_set[pmlmeext->sitesurvey_res.channel_idx].ScanType ;
+
+	if (survey_channel != 0)
+	{
+		//PAUSE 4-AC Queue when site_survey
+		rtw_write8(padapter, REG_TXPAUSE, (rtw_read8(padapter, REG_TXPAUSE)|0x0f));	
+	
+		//SelectChannel(padapter, survey_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		set_channel_bwmode(padapter, survey_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+
+		//send issue_probereq frames while active scan but not in channel 12 & 13
+		//if ((pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) && (survey_channel < 12))
+		//(survey_channel ==  0xff) //passive scan according to channel plan
+		if((pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) && (ScanType == SCAN_ACTIVE))
+		{
+			//todo: to issue two probe req???
+			issue_probereq(padapter, 1);
+			//rtw_msleep_os(SURVEY_TO>>1);
+			issue_probereq(padapter, 1);
+			
+		}
+
+#ifdef CONFIG_ANTENNA_DIVERSITY	
+	//printk("site_survey chan(%d) antenna( %s ).....\n",survey_channel,(pHalData->CurAntenna==2)?"A":"B");
+#endif	
+		_set_timer(&pmlmeext->survey_timer,pmlmeext->chan_scan_time );
+
+	}
+	else
+	{
+#ifdef CONFIG_ANTENNA_DIVERSITY
+		// 20100721:Interrupt scan operation here.
+		// For SW antenna diversity before link, it needs to switch to another antenna and scan again.
+		// It compares the scan result and select beter one to do connection.
+		if(SwAntDivBeforeLink8192C(padapter))
+		{				
+			pmlmeext->sitesurvey_res.bss_cnt = 0;
+			pmlmeext->sitesurvey_res.channel_idx = -1;
+			pmlmeext->chan_scan_time = SURVEY_TO /2;			
+			_set_timer(&pmlmeext->survey_timer, pmlmeext->chan_scan_time);
+			return;
+		}
+		
+#endif	
+		//switch back to the original channel
+		//SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
+		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+
+		//flush 4-AC Queue after site_survey
+		rtw_write8(padapter, REG_TXPAUSE, 0x0);	
+	
+
+		if (is_client_associated_to_ap(padapter) == _TRUE)
+		{
+
+			//issue null data 
+			issue_nulldata(padapter, 0);
+
+			//accept all data frame
+			//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+			rtw_write16(padapter, REG_RXFLTMAP2,0xFFFF);
+
+			//enable update TSF
+			if(IS_NORMAL_CHIP(pHalData->VersionID))
+			{
+				rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));				
+			}
+			else
+			{
+				rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~(BIT(4)|BIT(5))));	
+			}			
+
+			
+		}
+		else if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+		{
+			rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+			
+			//enable update TSF
+			if(IS_NORMAL_CHIP(pHalData->VersionID))			
+				rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));			
+			else			
+				rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~(BIT(4)|BIT(5))));	
+		}
+		else if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+		{
+			rtw_write16(padapter, REG_RXFLTMAP2,0xFFFF);
+		}
+
+
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{
+			if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE){
+				rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_CBSSID_BCN);
+			}
+			else	{		
+			        rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+		}
+		}
+		else
+		{
+			rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_CBSSID_DATA);
+		}	
+
+
+		//config MSR
+		Set_NETYPE0_MSR(padapter, (pmlmeinfo->state & 0x3));
+
+		//turn on dynamic functions
+		Restore_DM_Func_Flag(padapter);
+		//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
+
+		report_surveydone_event(padapter);
+		
+		pmlmeext->chan_scan_time = SURVEY_TO;
+		pmlmeext->sitesurvey_res.state = _FALSE;
+
+#ifdef PLATFORM_LINUX
+		if(rtw_txframes_pending(padapter))	
+		{
+			struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+			tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+		}
+#endif
+
+
+		issue_action_BSSCoexistPacket(padapter);
+
+
+	}
+
+	return;
+
+}
+
+//collect bss info from Beacon and Probe response frames.
+u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid)
+{
+	int							i;
+	unsigned int		len;
+	unsigned char		*p;
+	unsigned short	val16, subtype;
+	u8 *pframe = precv_frame->u.hdr.rx_data;
+	uint packet_len = precv_frame->u.hdr.len;	
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+
+	len = packet_len - sizeof(struct ieee80211_hdr_3addr);
+
+	if (len > MAX_IE_SZ)
+	{
+		//printk("IE too long for survey event\n");
+		return _FAIL;
+	}
+
+	_rtw_memset(bssid, 0, sizeof(WLAN_BSSID_EX));
+
+	subtype = GetFrameSubType(pframe) >> 4;
+
+	if(subtype==WIFI_BEACON)
+		bssid->Reserved[0] = 1;
+		
+	bssid->Length = sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + len;
+
+	//below is to copy the information element
+	bssid->IELength = len;
+	_rtw_memcpy(bssid->IEs, (pframe + sizeof(struct ieee80211_hdr_3addr)), bssid->IELength);
+
+	//get the signal strength
+	//bssid->Rssi = precv_frame->u.hdr.attrib.signal_strength; // 0-100 index.	
+	bssid->Rssi = precv_frame->u.hdr.attrib.RecvSignalPower; // in dBM.raw data	
+	bssid->PhyInfo.SignalQuality = precv_frame->u.hdr.attrib.signal_qual;//in percentage 
+	bssid->PhyInfo.SignalStrength = precv_frame->u.hdr.attrib.signal_strength;//in percentage
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	bssid->PhyInfo.Optimum_antenna = pHalData->CurAntenna;
+#endif
+
+	// checking SSID
+	if ((p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_)) == NULL)
+	{
+		DBG_871X("marc: cannot find SSID for survey event\n");
+	#if 1
+		{//georgia ############3
+			uint i,j=1;			
+			DBG_871X("############################# \n");
+			for(i=0;i<packet_len;i++)
+			{
+				DBG_871X("%02X:", *(pframe+i));
+				if((j++)%8 == 0)	printk("\n");	
+			}
+			DBG_871X("\n############################# \n");	
+		}
+	#endif
+		return _FAIL;
+	}
+
+	
+	if (*(p + 1))
+	{
+		_rtw_memcpy(bssid->Ssid.Ssid, (p + 2), *(p + 1));
+		bssid->Ssid.SsidLength = *(p + 1);
+	}
+	else
+	{
+		bssid->Ssid.SsidLength = 0;
+	}
+
+
+	_rtw_memset(bssid->SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+
+	//checking rate info...
+	i = 0;
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SUPPORTEDRATES_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL)
+	{
+		_rtw_memcpy(bssid->SupportedRates, (p + 2), len);
+		i = len;
+	}
+
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _EXT_SUPPORTEDRATES_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL)
+	{
+		_rtw_memcpy(bssid->SupportedRates + i, (p + 2), len);
+	}
+
+	//todo:
+#if 0
+	if (judge_network_type(bssid->SupportedRates, (len + i)) == WIRELESS_11B)
+	{
+		bssid->NetworkTypeInUse = Ndis802_11DS;
+	}
+	else
+#endif
+	{
+		bssid->NetworkTypeInUse = Ndis802_11OFDM24;
+	}
+
+	// Checking for DSConfig
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+
+	bssid->Configuration.DSConfig = 0;
+	bssid->Configuration.Length = 0;
+
+	if (p)
+	{
+		bssid->Configuration.DSConfig = *(p + 2);
+	}
+
+	_rtw_memcpy(&bssid->Configuration.BeaconPeriod, rtw_get_beacon_interval_from_ie(bssid->IEs), 2);
+
+	bssid->Configuration.BeaconPeriod = le32_to_cpu(bssid->Configuration.BeaconPeriod);
+
+	val16 = rtw_get_capability((WLAN_BSSID_EX *)bssid);
+
+	if (val16 & BIT(0))
+	{
+		bssid->InfrastructureMode = Ndis802_11Infrastructure;
+		_rtw_memcpy(bssid->MacAddress, GetAddr2Ptr(pframe), ETH_ALEN);
+	}
+	else
+	{
+		bssid->InfrastructureMode = Ndis802_11IBSS;
+		_rtw_memcpy(bssid->MacAddress, GetAddr3Ptr(pframe), ETH_ALEN);
+	}
+
+	if (val16 & BIT(4))
+		bssid->Privacy = 1;
+	else
+		bssid->Privacy = 0;
+
+	bssid->Configuration.ATIMWindow = 0;
+
+
+	//20/40 BSS Coexistence check
+	if((pregistrypriv->wifi_spec==1) && (_FALSE == pmlmeinfo->bwmode_updated))
+	{	
+		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+		
+		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+		if(p && len>0)
+		{
+			struct HT_caps_element	*pHT_caps;
+			pHT_caps = (struct HT_caps_element	*)(p + 2);
+			
+			if(pHT_caps->HT_cap_element.HT_caps_info&BIT(14))
+			{				
+				pmlmepriv->num_FortyMHzIntolerant++;
+			}
+		}
+		else
+		{
+			pmlmepriv->num_sta_no_ht++;
+		}
+		
+	}
+	
+	return _SUCCESS;
+
+}
+
+void start_create_ibss(_adapter* padapter)
+{
+	unsigned short	caps;
+	u32	xmitbcnDown, val32;
+	u8	bxmitok = _FALSE;
+	int	retry=0;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	pmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;
+	pmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);
+
+	caps = rtw_get_capability((WLAN_BSSID_EX *)pnetwork);
+
+	if(caps&cap_IBSS)//adhoc master
+	{
+		//set_opmode_cmd(padapter, adhoc);//removed
+
+		rtw_write8(padapter, REG_SECCFG, 0xcf);
+
+		//switch channel
+		//SelectChannel(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+
+		beacon_timing_control(padapter);
+
+		//set msr to WIFI_FW_ADHOC_STATE
+		Set_NETYPE0_MSR(padapter, (pmlmeinfo->state & 0x3));
+
+		do{
+
+			issue_beacon(padapter);
+
+			xmitbcnDown= rtw_read32(padapter, REG_TDECTRL);
+			if(xmitbcnDown & BCN_VALID  ){
+				rtw_write32(padapter,REG_TDECTRL, xmitbcnDown | BCN_VALID  ); // write 1 to clear, Clear by sw
+				bxmitok = _TRUE;
+			}
+			
+		}while((_FALSE == bxmitok) &&((retry++)<100 ));
+
+		if(retry == 100)
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("issuing beacon frame fail....\n"));
+			DBG_871X("@@@@ %s issue_beacon failed...@@@@\n", __FUNCTION__);	
+			report_join_res(padapter, -1);			
+			//pmlmeinfo->state ^= WIFI_FW_ADHOC_STATE;
+		}
+		else
+		{
+			val32 = rtw_read32(padapter, REG_RCR);
+			val32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);
+			rtw_write32(padapter, REG_RCR, val32);
+					
+			report_join_res(padapter, 1);
+			pmlmeinfo->state = WIFI_FW_ADHOC_STATE;
+			pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+			
+		}	
+
+		
+	}
+	else
+	{
+		DBG_871X("start_create_ibss, invalid cap:%x\n", caps);
+		return;
+	}
+
+}
+
+void start_clnt_join(_adapter* padapter)
+{
+	unsigned short	caps;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	pmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;
+	pmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);
+
+	caps = rtw_get_capability((WLAN_BSSID_EX *)pnetwork);
+	if (caps&cap_ESS)
+	{
+		pmlmeinfo->state = WIFI_FW_AUTH_NULL | WIFI_FW_STATION_STATE;
+		
+		//printk("%s==> caps&cap_ESS\n",__FUNCTION__);
+
+		//set_opmode_cmd(padapter, infra_client_with_mlme);//removed
+
+		(pmlmeinfo->auth_algo == dot11AuthAlgrthm_8021X)? rtw_write8(padapter, REG_SECCFG, 0xcc): rtw_write8(padapter, REG_SECCFG, 0xcf);
+
+		//2010-11-05 georgia for test
+	#if ( RTL8192C_WEP_ISSUE==1)		
+		{
+			HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(padapter);
+			struct pwrctrl_priv 	*pwrctrlpriv = &padapter->pwrctrlpriv;
+			if(( pwrctrlpriv->power_mgnt != PS_MODE_ACTIVE )  && IS_92C_SERIAL(pHalData->VersionID)){
+				if (	( padapter->securitypriv.dot11PrivacyAlgrthm == _WEP40_ ) ||
+					( padapter->securitypriv.dot11PrivacyAlgrthm == _WEP104_ )){				
+					//workaround_#1 use sw descryption
+					rtw_write8(padapter, REG_SECCFG, (rtw_read8(padapter, REG_SECCFG)&(~BIT3)));			
+				}			
+			}
+		}		
+	#endif
+
+		//switch channel
+		//SelectChannel(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+
+		//here wait for receiving the beacon to start auth
+		//and enable a timer
+		_set_timer(&(pmlmeext->link_timer), decide_wait_for_beacon_timeout(pmlmeinfo->bcn_interval));
+	}
+	else if (caps&cap_IBSS) //adhoc client
+	{			
+		//printk("%s==> caps&cap_IBSS\n",__FUNCTION__);
+		//set_opmode_cmd(padapter, adhoc);//removed
+
+		rtw_write8(padapter, REG_SECCFG, 0xcf);
+
+		//switch channel
+		//SelectChannel(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+	
+		beacon_timing_control(padapter);
+
+		//set msr to WIFI_FW_ADHOC_STATE
+		Set_NETYPE0_MSR(padapter, (pmlmeinfo->state & 0x3));
+
+		report_join_res(padapter, 1);
+		pmlmeinfo->state = WIFI_FW_ADHOC_STATE;
+		
+
+	}
+	else
+	{
+		//printk("marc: invalid cap:%x\n", caps);
+		return;
+	}
+
+}
+
+void start_clnt_auth(_adapter* padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+	pmlmeinfo->state &= (~WIFI_FW_AUTH_NULL);
+	pmlmeinfo->state |= WIFI_FW_AUTH_STATE;
+
+	pmlmeinfo->auth_seq = 1;
+	pmlmeinfo->reauth_count = 0;
+	pmlmeinfo->reassoc_count = 0;
+	pmlmeinfo->link_count = 0;
+
+	issue_auth(padapter, NULL, 0);
+
+	_set_timer(&pmlmeext->link_timer, REAUTH_TO);
+
+}
+
+
+void start_clnt_assoc(_adapter* padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+	pmlmeinfo->state &= (~(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE));
+	pmlmeinfo->state |= (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE);
+
+	issue_assocreq(padapter);
+
+	_set_timer(&pmlmeext->link_timer, REASSOC_TO);
+}
+
+unsigned int receive_disconnect(_adapter *padapter, unsigned char *MacAddr)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	//check A3
+	if (!(_rtw_memcmp(MacAddr, get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
+		return _SUCCESS;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if (pmlmeinfo->state & WIFI_FW_LINKING_STATE)
+	{
+		report_join_res(padapter, -2);
+	}
+	else if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+	{
+		report_del_sta_event(padapter, MacAddr);
+	}
+
+	return _SUCCESS;
+}
+
+/****************************************************************************
+
+Following are the functions to report events
+
+*****************************************************************************/
+
+void report_survey_event(_adapter *padapter, union recv_frame *precv_frame)
+{
+	struct cmd_obj *pcmd_obj;
+	u8	*pevtcmd;
+	u32 cmdsz;
+	struct survey_event	*psurvey_evt;
+	struct C2HEvent_Header *pc2h_evt_hdr;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	//u8 *pframe = precv_frame->u.hdr.rx_data;
+	//uint len = precv_frame->u.hdr.len;
+
+	if ((pcmd_obj = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct survey_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (u8*)_rtw_zmalloc(cmdsz)) == NULL)
+	{
+		_rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		return;
+	}
+
+	_rtw_init_listhead(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct survey_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_Survey);
+	pc2h_evt_hdr->seq = pmlmeext->event_seq++;
+
+	psurvey_evt = (struct survey_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	if (collect_bss_info(padapter, precv_frame, (WLAN_BSSID_EX *)&psurvey_evt->bss) == _FAIL)
+	{
+		_rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		_rtw_mfree((u8 *)pevtcmd, cmdsz);
+		return;
+	}
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	pmlmeext->sitesurvey_res.bss_cnt++;
+
+	return;
+
+}
+
+void report_surveydone_event(_adapter *padapter)
+{
+	struct cmd_obj *pcmd_obj;
+	u8	*pevtcmd;
+	u32 cmdsz;
+	struct surveydone_event *psurveydone_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &padapter->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct surveydone_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (u8*)_rtw_zmalloc(cmdsz)) == NULL)
+	{
+		_rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		return;
+	}
+
+	_rtw_init_listhead(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct surveydone_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_SurveyDone);
+	pc2h_evt_hdr->seq = pmlmeext->event_seq++;
+
+	psurveydone_evt = (struct surveydone_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	psurveydone_evt->bss_cnt = pmlmeext->sitesurvey_res.bss_cnt;
+
+	DBG_871X("survey done event(0x%x)\n", psurveydone_evt->bss_cnt);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+
+}
+
+void report_join_res(_adapter *padapter, int res)
+{
+	struct cmd_obj *pcmd_obj;
+	u8	*pevtcmd;
+	u32 cmdsz;
+	struct joinbss_event		*pjoinbss_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct joinbss_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (u8*)_rtw_zmalloc(cmdsz)) == NULL)
+	{
+		_rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		return;
+	}
+
+	_rtw_init_listhead(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct joinbss_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_JoinBss);
+	pc2h_evt_hdr->seq = pmlmeext->event_seq++;
+
+	pjoinbss_evt = (struct joinbss_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	_rtw_memcpy((unsigned char *)(&(pjoinbss_evt->network.network)), &(pmlmeinfo->network), sizeof(WLAN_BSSID_EX));
+	pjoinbss_evt->network.join_res 	= pjoinbss_evt->network.aid = res;
+
+	DBG_871X("report_join_res(%d)\n", res);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+
+}
+
+void report_del_sta_event(_adapter *padapter, unsigned char* MacAddr)
+{
+	struct cmd_obj *pcmd_obj;
+	u8	*pevtcmd;
+	u32 cmdsz;
+	struct stadel_event			*pdel_sta_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct stadel_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (u8*)_rtw_zmalloc(cmdsz)) == NULL)
+	{
+		_rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		return;
+	}
+
+	_rtw_init_listhead(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct stadel_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_DelSTA);
+	pc2h_evt_hdr->seq = pmlmeext->event_seq++;
+
+	pdel_sta_evt = (struct stadel_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	_rtw_memcpy((unsigned char *)(&(pdel_sta_evt->macaddr)), MacAddr, ETH_ALEN);
+
+	DBG_871X("rtl8192: delete STA\n");
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+void report_add_sta_event(_adapter *padapter, unsigned char* MacAddr, int cam_idx)
+{
+	struct cmd_obj *pcmd_obj;
+	u8	*pevtcmd;
+	u32 cmdsz;
+	struct stassoc_event		*padd_sta_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct stassoc_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (u8*)_rtw_zmalloc(cmdsz)) == NULL)
+	{
+		_rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		return;
+	}
+
+	_rtw_init_listhead(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct stassoc_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_AddSTA);
+	pc2h_evt_hdr->seq = pmlmeext->event_seq++;
+
+	padd_sta_evt = (struct stassoc_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	_rtw_memcpy((unsigned char *)(&(padd_sta_evt->macaddr)), MacAddr, ETH_ALEN);
+	padd_sta_evt->cam_id = cam_idx;
+
+	DBG_871X("report_add_sta_event: add STA\n");
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+
+/****************************************************************************
+
+Following are the event callback functions
+
+*****************************************************************************/
+
+//for sta/adhoc mode
+static void update_sta_info(_adapter *padapter, struct sta_info *psta)
+{
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	//ERP
+	VCS_update(padapter, psta);
+
+
+	//HT
+	if(pmlmepriv->htpriv.ht_option)
+	{
+		psta->htpriv.ht_option = _TRUE;
+
+		psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
+
+		if (support_short_GI(padapter, &(pmlmeinfo->HT_caps)))
+			psta->htpriv.sgi = _TRUE;
+
+		psta->qos_option = _TRUE;
+		
+	}
+	else
+	{
+		psta->htpriv.ht_option = _FALSE;
+
+		psta->htpriv.ampdu_enable = _FALSE;
+		
+		psta->htpriv.sgi = _FALSE;
+
+		psta->qos_option = _FALSE;//?
+
+	}
+
+	psta->htpriv.bwmode = pmlmeext->cur_bwmode;
+	psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
+
+	psta->htpriv.agg_enable_bitmap = 0x0;//reset
+	psta->htpriv.candidate_tid_bitmap = 0x0;//reset
+	
+
+	//QoS
+	if(pmlmepriv->qospriv.qos_option)
+		psta->qos_option = _TRUE;
+
+
+
+	psta->state = _FW_LINKED;
+
+}
+
+void mlmeext_joinbss_event_callback(_adapter *padapter)
+{
+	u8 SIFS_Time;
+	struct sta_info *psta, *psta_bmc;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	struct sta_priv	*pstapriv = &padapter->stapriv;
+
+
+	//for bc/mc
+	psta_bmc = rtw_get_bcmc_stainfo(padapter);
+	if(psta_bmc)
+	{
+		pmlmeinfo->FW_sta_info[4].psta = psta_bmc;
+
+		//update sta_info for bc/mc
+		psta_bmc->mac_id = 4;
+
+	}
+
+
+	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
+	if (psta)//only for infra. mode
+	{
+		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;//psta->mac_id=0 for infra. mode
+	}
+
+
+	// update IOT-releated issue
+	update_IOT_info(padapter);
+
+
+	//WMM, Update EDCA param
+	WMMOnAssocRsp(padapter);
+
+	//HT
+	HTOnAssocRsp(padapter);
+
+        //update sta_info
+	if (psta) //only for infra. mode
+	{
+		//DBG_871X("set_sta_rate & update_sta_info\n");
+	
+		//set per sta rate after updating HT cap.
+		set_sta_rate(padapter);
+		
+		update_sta_info(padapter, psta);
+	}	
+
+
+	//SET MSR to _HW_STATE_STATION_
+	Set_NETYPE0_MSR(padapter, (pmlmeinfo->state & 0x3));
+
+	rtw_write32(padapter, REG_BSSID,
+					(cur_network->MacAddress[0] | (cur_network->MacAddress[1] << 8)  |
+					(cur_network->MacAddress[2] << 16) | (cur_network->MacAddress[3] << 24)));
+
+	rtw_write32(padapter, (REG_BSSID + 4), (cur_network->MacAddress[4] | (cur_network->MacAddress[5] << 8)));
+
+
+	//update REG_INIRTS_RATE_SEL
+	if (pmlmeinfo->HT_enable)
+	{
+		//network_type = WIRELESS_11N;
+		rtw_write8(padapter, REG_INIRTS_RATE_SEL, 0x0a);
+	}	
+	else if ((cckratesonly_included(cur_network->SupportedRates, rtw_get_rateset_len(cur_network->SupportedRates))) == _TRUE)
+	{
+		//network_type |= WIRELESS_11B;
+		rtw_write8(padapter, REG_INIRTS_RATE_SEL, 0x00);
+	}
+	else if((cckrates_included(cur_network->SupportedRates, rtw_get_rateset_len(cur_network->SupportedRates))) == _TRUE)
+	{
+		//network_type |= WIRELESS_11BG;
+		rtw_write8(padapter, REG_INIRTS_RATE_SEL, 0x03);
+	}
+	else
+	{
+		//network_type |= WIRELESS_11G;
+		rtw_write8(padapter, REG_INIRTS_RATE_SEL, 0x04);
+	}
+			
+	//enable to rx data frame.Accept all data frame
+	//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+	rtw_write16(padapter, REG_RXFLTMAP2,0xFFFF);
+
+	//BCN interval
+	rtw_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);
+
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	{
+           
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{
+			rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+			//enable update TSF
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));
+		}
+		else
+		{
+			rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_CBSSID_DATA);
+			//enable update TSF
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~(BIT(4)|BIT(5))));
+		}
+
+		// correcting TSF
+		correct_TSF(padapter, pmlmeext);
+	
+		//_set_timer(&pmlmeext->link_timer, DISCONNECT_TO);
+		pmlmeext->linked_to = LINKED_TO;
+	}	
+
+	//turn on dynamic functions
+	Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
+
+	
+	//
+	if(pmlmeext->cur_wireless_mode & WIRELESS_11N)
+	{		
+		SIFS_Time = 0x0e;
+	}
+	else
+	{
+		SIFS_Time = 0x0a;
+	}
+
+	// SIFS for OFDM Data ACK
+	rtw_write8(padapter, REG_SIFS_CTX+1, SIFS_Time);
+	// SIFS for OFDM consecutive tx like CTS data!
+	rtw_write8(padapter, REG_SIFS_TRX+1, SIFS_Time);
+		
+	rtw_write8(padapter,REG_SPEC_SIFS+1, SIFS_Time);
+	rtw_write8(padapter,REG_MAC_SPEC_SIFS+1, SIFS_Time);
+
+	// 20100719 Joseph: Revise SIFS setting due to Hardware register definition change.
+	rtw_write8(padapter, REG_R2T_SIFS+1, SIFS_Time);
+	rtw_write8(padapter, REG_T2T_SIFS+1, SIFS_Time);
+
+	
+	DBG_871X("=>%s\n", __FUNCTION__);
+
+}
+
+void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta)
+{
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		if(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)//adhoc master or sta_count>1
+		{
+			//nothing to do
+		}
+		else//adhoc client
+		{			
+			u32	xmitbcnDown;
+			u8	bxmitok = _FALSE;
+			int	retry=0;
+		
+			//update TSF Value
+			//update_TSF(pmlmeext, pframe, len);			
+
+			// correcting TSF
+			correct_TSF(padapter, pmlmeext);
+
+			//start beacon
+			do{
+
+				issue_beacon(padapter);
+
+				xmitbcnDown= rtw_read32(padapter, REG_TDECTRL);
+				if(xmitbcnDown & BCN_VALID ){
+						rtw_write32(padapter,REG_TDECTRL, xmitbcnDown|BCN_VALID); // write 1 to clear, Clear by sw
+						bxmitok = _TRUE;
+					}
+			
+			}while((_FALSE == bxmitok) &&((retry++)<100 ));
+
+			if(retry == 100)
+			{
+				pmlmeinfo->FW_sta_info[psta->mac_id].status = 0;
+					
+				pmlmeinfo->state ^= WIFI_FW_ADHOC_STATE;
+
+				DBG_871X("@@@@ %s issue_beacon failed...@@@@\n", __FUNCTION__);	
+				return;			
+			}
+
+			pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+				
+		}
+
+		rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+		//accept all data frame
+		rtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);
+
+		//enable update TSF
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));
+		
+
+	}
+	
+
+	pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
+
+	//rate radaptive
+	Update_RA_Entry(padapter, psta->mac_id);
+
+	//for bc/mc rate
+	Update_RA_Entry(padapter, 4);
+
+	//update adhoc sta_info
+	update_sta_info(padapter, psta);
+
+	//fixed beacon issue for 8191su.............
+	{
+		rtw_write8(padapter,0x542 ,0x02);
+	}
+
+	pmlmeext->linked_to = LINKED_TO;
+	
+}
+
+void mlmeext_sta_del_event_callback(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv		*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (is_client_associated_to_ap(padapter) || is_IBSS_empty(padapter))
+	{
+		u32 v ;
+		//set_opmode_cmd(padapter, infra_client_with_mlme);	
+
+		//switch to the 20M Hz mode after disconnect
+		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+	
+		//Set RCR to not to receive data frame when NO LINK state
+		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);
+		v= rtw_read32(padapter, REG_RCR);
+		v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );
+		rtw_write16(padapter, REG_RXFLTMAP2,0x00);
+
+		//reset TSF
+		rtw_write8(padapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+
+
+		//disable update TSF
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));
+		}
+		else
+		{
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4)|BIT(5));
+		}
+
+		//SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
+		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+		flush_all_cam_entry(padapter);
+
+
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		
+		//set MSR to no link state
+		Set_NETYPE0_MSR(padapter, _HW_STATE_STATION_);
+		
+		pmlmeext->linked_to = 0;
+		_cancel_timer_ex(&pmlmeext->link_timer);
+
+	}
+
+}
+
+/****************************************************************************
+
+Following are the functions for the timer handlers
+
+*****************************************************************************/
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+extern void rtw_indicate_wx_disassoc_event(_adapter *padapter);
+extern u8 rtw_set_802_11_disassociate(_adapter *padapter);
+extern void cancel_all_timer(_adapter *padapter);
+
+void restore_security_setting(_adapter *padapter)
+{
+	u8 EntryId = 0;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+	struct sta_priv * pstapriv = &padapter->stapriv;
+	struct sta_info *psta;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);	
+	struct mlme_ext_info	*pmlmeinfo = &padapter->mlmeextpriv.mlmext_info;
+
+	(pmlmeinfo->auth_algo == dot11AuthAlgrthm_8021X)
+		? rtw_write8(padapter, REG_SECCFG, 0xcc)
+		: rtw_write8(padapter, REG_SECCFG, 0xcf);
+
+	#if ( RTL8192C_WEP_ISSUE==1)		
+	{
+		HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(padapter);
+		struct pwrctrl_priv 	*pwrctrlpriv = &padapter->pwrctrlpriv;
+		if(( pwrctrlpriv->power_mgnt != PS_MODE_ACTIVE )  && IS_92C_SERIAL(pHalData->VersionID)){
+			if (	( padapter->securitypriv.dot11PrivacyAlgrthm == _WEP40_ ) ||
+				( padapter->securitypriv.dot11PrivacyAlgrthm == _WEP104_ )){				
+				//workaround_#1 use sw descryption
+				rtw_write8(padapter, REG_SECCFG, (rtw_read8(padapter, REG_SECCFG)&(~BIT3)));			
+			}			
+		}
+	}		
+	#endif
+	
+	if (	( padapter->securitypriv.dot11PrivacyAlgrthm == _WEP40_ ) ||
+		( padapter->securitypriv.dot11PrivacyAlgrthm == _WEP104_ ))		
+	{
+
+		for(EntryId=0; EntryId<4; EntryId++)
+		{				
+			rtw_set_key(padapter,&padapter->securitypriv, EntryId);				
+		}	
+
+	}
+	else if((padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_) ||
+		(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_))
+	{
+		psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));				
+		if (psta == NULL) {
+			//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
+		}
+		else
+		{			
+			//pairwise key
+			rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
+			//group key			
+			rtw_set_key(padapter,&padapter->securitypriv,padapter->securitypriv.dot118021XGrpKeyid);
+		}
+	}
+	
+}
+
+void restore_network_status(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX	*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	unsigned short	caps;
+#if 1
+
+	//=======================================================
+	// reset related register of Beacon control 
+	
+	//set MSR to nolink		
+	Set_NETYPE0_MSR(padapter, _HW_STATE_NOLINK_);		
+	// reject all data frame
+	rtw_write16(padapter, REG_RXFLTMAP2,0x00);		
+	//reset TSF
+	rtw_write8(padapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+
+	//disable update TSF
+	if(IS_NORMAL_CHIP(pHalData->VersionID))
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));		
+	else	
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4)|BIT(5));					
+
+	//=======================================================
+	rtw_joinbss_reset(padapter);
+	set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+	//pmlmeinfo->assoc_AP_vendor = maxAP;
+	
+	if (padapter->registrypriv.wifi_spec) {
+		// for WiFi test, follow WMM test plan spec
+		rtw_write32(padapter, REG_EDCA_VO_PARAM, 0x002F431C);
+		rtw_write32(padapter, REG_EDCA_VI_PARAM, 0x005E541C);
+		rtw_write32(padapter, REG_EDCA_BE_PARAM, 0x0000A525);
+		rtw_write32(padapter, REG_EDCA_BK_PARAM, 0x0000A549);
+	
+                // for WiFi test, mixed mode with intel STA under bg mode throughput issue
+	        if (padapter->mlmepriv.htpriv.ht_option == 0)
+		     rtw_write32(padapter, REG_EDCA_BE_PARAM, 0x00004320);
+
+	} else {
+	        rtw_write32(padapter, REG_EDCA_VO_PARAM, 0x002F3217);
+	        rtw_write32(padapter, REG_EDCA_VI_PARAM, 0x005E4317);
+	        rtw_write32(padapter, REG_EDCA_BE_PARAM, 0x00105320);
+	        rtw_write32(padapter, REG_EDCA_BK_PARAM, 0x0000A444);
+	}
+	
+	//disable dynamic functions, such as high power, DIG
+	//Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);	
+#endif
+	mlmeext_joinbss_event_callback(padapter);
+	//restore Sequence No.
+	rtw_write8(padapter,0x4dc,padapter->xmitpriv.nqos_ssn);	
+}
+
+
+u8 registers_checked(_adapter *padapter)
+{
+	u32 regc50,regc58,reg824,reg800;
+	regc50 = rtw_read32(padapter,0xc50);
+	regc58 = rtw_read32(padapter,0xc58);
+	reg824 = rtw_read32(padapter,0x824);
+	reg800 = rtw_read32(padapter,0x800);	
+	if(	((regc50&0xFFFFFF00)!= 0x69543400)||
+		((regc58&0xFFFFFF00)!= 0x69543400)||
+		(((reg824&0xFFFFFF00)!= 0x00390000)&&(((reg824&0xFFFFFF00)!= 0x80390000)))||
+		( ((reg800&0xFFFFFF00)!= 0x03040000)&&((reg800&0xFFFFFF00)!= 0x83040000)))
+	{
+		return _FAIL;
+	}
+	return _SUCCESS;
+}
+void silentreset_for_specific_platform(_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;		
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;	
+	_irqL irqL;
+
+	padapter->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
+
+	if (!netif_queue_stopped(padapter->pnetdev))
+		netif_stop_queue(padapter->pnetdev);
+		
+	cancel_all_timer(padapter);	
+	tasklet_kill(&pxmitpriv->xmit_tasklet);	
+
+	_enter_critical_mutex(&padapter->silentreset_mutex, &irqL);
+	padapter->silent_reset_inprogress = _TRUE;
+	pwrpriv->change_rfpwrstate = rf_off;		
+	ips_enter(padapter);								
+	ips_leave(padapter);
+	if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+	{
+		restore_network_status(padapter);
+		restore_security_setting(padapter);	
+	}
+	
+	if(pmlmepriv->fw_state & _FW_UNDER_SURVEY)			
+		pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;
+	
+	if(pmlmepriv->fw_state & _FW_UNDER_LINKING) 		
+		pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+	
+	
+	padapter->silent_reset_inprogress = _FALSE;
+	_exit_critical_mutex(&padapter->silentreset_mutex, &irqL);
+		
+	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);	
+				
+	if (netif_queue_stopped(padapter->pnetdev))
+		netif_wake_queue(padapter->pnetdev);	
+}
+#endif
+
+
+void _linked_rx_signal_strehgth_display(_adapter *padapter)
+{
+	printk("============ linked status check ===================\n");
+	printk("pathA Rx SNRdb:%d\n",padapter->recvpriv.RxSNRdB[0]);
+	printk("Rx RSSI:%d\n",padapter->recvpriv.rssi);
+	printk("Rx Signal_strength:%d\n",padapter->recvpriv.signal_strength);
+	printk("Rx Signal_qual:%d \n",padapter->recvpriv.signal_qual);
+	printk("============ linked status check ===================\n");
+}
+
+void linked_status_chk(_adapter *padapter)
+{
+	u32	i;
+#ifdef CONFIG_LPS
+        u32 NumTxOkInPeriod, NumRxOkInPeriod;
+	u8	bEnterPS;
+#endif
+	struct sta_info	*psta;
+	static u64		rx_pkt = 0;
+	static u64		tx_cnt = 0;
+	static u32 retry=0;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv	*precvpriv = &(padapter->recvpriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct registry_priv* pregistrypriv = &padapter->registrypriv;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	if (is_client_associated_to_ap(padapter))
+	{
+		if(padapter->halpriv.bRxRSSIDisplay)
+		 	_linked_rx_signal_strehgth_display(padapter);
+		
+		//linked infrastructure client mode
+		if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
+		{
+			/*to monitor whether the AP is alive or not*/
+			if (rx_pkt == psta->sta_stats.rx_pkts)
+			{
+				//	Commented by Albert 2010/07/21
+				//	In this case, there is no any rx packet received by driver.
+				
+			        if(retry<8)// Alter the retry limit to 8 
+				{
+					if(retry==0)
+					{
+						_rtw_memcpy(pmlmeext->sitesurvey_res.ss_ssid, pmlmeinfo->network.Ssid.Ssid, pmlmeinfo->network.Ssid.SsidLength);
+						pmlmeext->sitesurvey_res.ss_ssidlen = pmlmeinfo->network.Ssid.SsidLength;
+						pmlmeext->sitesurvey_res.scan_mode = SCAN_ACTIVE;
+						pmlmeext->sitesurvey_res.state = _FALSE;
+
+						DBG_871X("issue_probereq to check if ap alive, retry=%d\n", retry);
+					
+						#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM	
+						if(_FAIL == registers_checked(padapter))
+							silentreset_for_specific_platform(padapter);						
+						#endif						
+
+						//	In order to know the AP's current state, try to send the probe request 
+						//	to trigger the AP to send the probe response.
+						issue_probereq(padapter, 0);
+						issue_probereq(padapter, 0);
+						issue_probereq(padapter, 0);					
+
+					}
+					
+					retry++;
+					pmlmeext->linked_to = LINKED_TO;
+					
+				}
+				else
+				{				
+                                retry = 0;
+                                DBG_871X("no beacon to call receive_disconnect()\n");
+							
+					receive_disconnect(padapter, pmlmeinfo->network.MacAddress);
+					pmlmeinfo->link_count = 0;
+					return;
+			       }
+		
+			}
+			else
+			{
+				retry = 0;
+				rx_pkt = psta->sta_stats.rx_pkts;
+				//_set_timer(&pmlmeext->link_timer, DISCONNECT_TO);
+				pmlmeext->linked_to = LINKED_TO;
+			}
+
+			/*to send the AP a nulldata if no frame is xmitted in order to keep alive*/
+			if (pmlmeinfo->link_count++ == 0)
+			{
+				tx_cnt = pxmitpriv->tx_pkts;			
+			}
+			else if ((pmlmeinfo->link_count & 0xf) == 0)
+			{
+				//if ( (tx_cnt == pxmitpriv->tx_pkts) && (!padapter->pwrctrlpriv.bFwCurrentInPSMode))
+				if (tx_cnt == pxmitpriv->tx_pkts)
+				{
+	                                DBG_871X("issue nulldata to keep alive\n");
+					issue_nulldata(padapter, 0);
+				}
+
+				tx_cnt = pxmitpriv->tx_pkts;
+			}
+#ifdef CONFIG_LPS
+			//if(pwrctrlpriv->lps_enable){		
+				// check traffic for  powersaving.
+				NumTxOkInPeriod = pxmitpriv->NumTxOkInPeriod;
+				NumRxOkInPeriod = precvpriv->NumRxUnicastOkInPeriod;
+				if( ((NumRxOkInPeriod + NumTxOkInPeriod) > 8 ) ||
+					(NumRxOkInPeriod > 2) )
+				{
+					//printk("Tx = %d, Rx = %d \n",NumTxOkInPeriod,NumRxOkInPeriod);
+					bEnterPS= _FALSE;
+				}
+				else
+				{
+					bEnterPS= _TRUE;
+				}
+				pxmitpriv->NumTxOkInPeriod = 0;
+				precvpriv->NumRxUnicastOkInPeriod = 0;
+
+				// LeisurePS only work in infra mode.
+				if(bEnterPS)
+				{
+					LPS_Enter(padapter);
+				}
+				else
+				{
+					LPS_Leave(padapter);
+				}
+			//}
+#endif
+		} //end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.MacAddress)) != NULL)
+	}
+	else if (is_client_associated_to_ibss(padapter))
+	{
+		//linked IBSS mode
+		//for each assoc list entry to check the rx pkt counter
+		for (i = 6; i < NUM_STA; i++)
+		{
+			if (pmlmeinfo->FW_sta_info[i].status == 1)
+			{
+				psta = pmlmeinfo->FW_sta_info[i].psta;
+
+				if(NULL==psta) continue;
+
+				if (pmlmeinfo->FW_sta_info[i].rx_pkt == psta->sta_stats.rx_pkts)
+				{
+
+					if(pmlmeinfo->FW_sta_info[i].retry<3)
+					{
+						pmlmeinfo->FW_sta_info[i].retry++;
+					}
+					else
+					{
+						pmlmeinfo->FW_sta_info[i].retry = 0;
+						pmlmeinfo->FW_sta_info[i].status = 0;
+						report_del_sta_event(padapter, psta->hwaddr);
+					}	
+				}
+				else
+				{
+					pmlmeinfo->FW_sta_info[i].retry = 0;
+					pmlmeinfo->FW_sta_info[i].rx_pkt = (u32)psta->sta_stats.rx_pkts;
+				}
+				
+			}
+		}
+
+		//_set_timer(&pmlmeext->link_timer, DISCONNECT_TO);
+		pmlmeext->linked_to = LINKED_TO;
+
+	}
+
+}
+
+void survey_timer_hdl(_adapter *padapter)
+{
+	struct cmd_obj	*ph2c;
+	struct sitesurvey_parm	*psurveyPara;	
+	struct cmd_priv					*pcmdpriv=&padapter->cmdpriv;
+	struct mlme_priv				*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv 		*pmlmeext = &padapter->mlmeextpriv;
+
+	//printk("marc: survey timer\n");
+
+	//issue rtw_sitesurvey_cmd
+	if (pmlmeext->sitesurvey_res.state == _TRUE)
+	{
+		pmlmeext->sitesurvey_res.channel_idx++;
+
+		if ((ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+		{
+			goto exit_survey_timer_hdl;
+		}
+
+		if ((psurveyPara = (struct sitesurvey_parm*)_rtw_zmalloc(sizeof(struct sitesurvey_parm))) == NULL)
+		{
+			_rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+			goto exit_survey_timer_hdl;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));
+		rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+	}
+
+
+exit_survey_timer_hdl:
+
+	return;
+}
+
+void link_timer_hdl(_adapter *padapter)
+{
+	static unsigned int		rx_pkt = 0;
+	static u64						tx_cnt = 0;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+
+	if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
+	{
+		DBG_871X("link_timer_hdl:no beacon while connecting\n");
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		report_join_res(padapter, -3);
+	}
+	else if (pmlmeinfo->state & WIFI_FW_AUTH_STATE)
+	{
+		//re-auth timer
+		if (++pmlmeinfo->reauth_count > REAUTH_LIMIT)
+		{
+			if (pmlmeinfo->auth_algo != dot11AuthAlgrthm_Auto)
+			{
+				pmlmeinfo->state = 0;
+				report_join_res(padapter, -1);
+				return;
+			}
+			else
+			{
+				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;
+				pmlmeinfo->reauth_count = 0;
+			}
+		}
+
+		DBG_871X("link_timer_hdl: auth timeout and try again\n");
+		pmlmeinfo->auth_seq = 1;
+		issue_auth(padapter, NULL, 0);
+		_set_timer(&pmlmeext->link_timer, REAUTH_TO);
+	}
+	else if (pmlmeinfo->state & WIFI_FW_ASSOC_STATE)
+	{
+		//re-assoc timer
+		if (++pmlmeinfo->reassoc_count > REASSOC_LIMIT)
+		{
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+			report_join_res(padapter, -2);
+			return;
+		}
+
+		DBG_871X("link_timer_hdl: assoc timeout and try again\n");
+		issue_assocreq(padapter);
+		_set_timer(&pmlmeext->link_timer, REASSOC_TO);
+	}
+#if 0
+	else if (is_client_associated_to_ap(padapter))
+	{
+		//linked infrastructure client mode
+		if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
+		{
+			/*to monitor whether the AP is alive or not*/
+			if (rx_pkt == psta->sta_stats.rx_pkts)
+			{
+				receive_disconnect(padapter, pmlmeinfo->network.MacAddress);
+				return;
+			}
+			else
+			{
+				rx_pkt = psta->sta_stats.rx_pkts;
+				_set_timer(&pmlmeext->link_timer, DISCONNECT_TO);
+			}
+
+			//update the EDCA paramter according to the Tx/RX mode
+			update_EDCA_param(padapter);
+
+			/*to send the AP a nulldata if no frame is xmitted in order to keep alive*/
+			if (pmlmeinfo->link_count++ == 0)
+			{
+				tx_cnt = pxmitpriv->tx_pkts;
+			}
+			else if ((pmlmeinfo->link_count & 0xf) == 0)
+			{
+				if (tx_cnt == pxmitpriv->tx_pkts)
+				{
+					issue_nulldata(padapter, 0);
+				}
+
+				tx_cnt = pxmitpriv->tx_pkts;
+			}
+		} //end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.MacAddress)) != NULL)
+	}
+	else if (is_client_associated_to_ibss(padapter))
+	{
+		//linked IBSS mode
+		//for each assoc list entry to check the rx pkt counter
+		for (i = 6; i < NUM_STA; i++)
+		{
+			if (pmlmeinfo->FW_sta_info[i].status == 1)
+			{
+				psta = pmlmeinfo->FW_sta_info[i].psta;
+
+				if (pmlmeinfo->FW_sta_info[i].rx_pkt == psta->sta_stats.rx_pkts)
+				{
+					pmlmeinfo->FW_sta_info[i].status = 0;
+					report_del_sta_event(padapter, psta->hwaddr);
+				}
+				else
+				{
+					pmlmeinfo->FW_sta_info[i].rx_pkt = psta->sta_stats.rx_pkts;
+				}
+			}
+		}
+
+		_set_timer(&pmlmeext->link_timer, DISCONNECT_TO);
+	}
+#endif
+
+	return;
+}
+
+void addba_timer_hdl(struct sta_info *psta)
+{
+	u8 bitmap;
+	u16 tid;
+	struct ht_priv	*phtpriv;
+
+	if(!psta)
+		return;
+	
+	phtpriv = &psta->htpriv;
+
+	if((phtpriv->ht_option==1) && (phtpriv->ampdu_enable==_TRUE)) 
+	{
+		if(phtpriv->candidate_tid_bitmap)
+			phtpriv->candidate_tid_bitmap=0x0;
+		
+	}
+	
+}
+
+#ifdef CONFIG_AP_MODE
+
+void init_mlme_ap_info(_adapter *padapter)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	pmlmeext->bstart_bss = _FALSE;
+
+}
+
+#endif //end of CONFIG_AP_MODE
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mp.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mp.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mp.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mp.c	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1543 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_MP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <rtw_mp_phy_regdef.h>
+
+#ifdef CONFIG_MP_INCLUDED
+
+static void _init_mp_priv_(struct mp_priv *pmp_priv)
+{
+	pmp_priv->mode = _LOOPBOOK_MODE_;
+
+	pmp_priv->curr_ch = 1;
+	pmp_priv->curr_modem = MIXED_PHY;
+	pmp_priv->curr_rateidx = 0;
+	pmp_priv->curr_txpoweridx = 0x14;
+
+	pmp_priv->antenna_tx = ANTENNA_A;
+	pmp_priv->antenna_rx = ANTENNA_AB;
+
+	pmp_priv->check_mp_pkt = 0;
+
+	pmp_priv->tx_pktcount = 0;
+
+	pmp_priv->rx_pktcount = 0;
+	pmp_priv->rx_crcerrpktcount = 0;
+
+}
+
+#ifdef PLATFORM_WINDOWS
+/*
+void mp_wi_callback(
+	IN NDIS_WORK_ITEM*	pwk_item,
+	IN PVOID			cntx
+	)
+{
+	_adapter* padapter =(_adapter *)cntx;
+	struct mp_priv *pmppriv=&padapter->mppriv;
+	struct mp_wi_cntx	*pmp_wi_cntx=&pmppriv->wi_cntx;
+
+	// Execute specified action.
+	if(pmp_wi_cntx->curractfunc != NULL)
+	{
+		LARGE_INTEGER	cur_time;
+		ULONGLONG start_time, end_time;
+		NdisGetCurrentSystemTime(&cur_time);	// driver version
+		start_time = cur_time.QuadPart/10; // The return value is in microsecond
+
+		pmp_wi_cntx->curractfunc(padapter);
+
+		NdisGetCurrentSystemTime(&cur_time);	// driver version
+		end_time = cur_time.QuadPart/10; // The return value is in microsecond
+
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+			 ("WorkItemActType: %d, time spent: %I64d us\n",
+			  pmp_wi_cntx->param.act_type, (end_time-start_time)));
+	}
+
+	NdisAcquireSpinLock(&(pmp_wi_cntx->mp_wi_lock));
+	pmp_wi_cntx->bmp_wi_progress= _FALSE;
+	NdisReleaseSpinLock(&(pmp_wi_cntx->mp_wi_lock));
+
+	if (pmp_wi_cntx->bmpdrv_unload)
+	{
+		NdisSetEvent(&(pmp_wi_cntx->mp_wi_evt));
+	}
+
+}
+*/
+
+int init_mp_priv (struct mp_priv *pmp_priv)
+{
+	struct wlan_network *pnetwork = &pmp_priv->mp_network;
+	struct mp_wi_cntx *pmp_wi_cntx = &pmp_priv->wi_cntx;
+
+	_init_mp_priv_(pmp_priv);
+
+	pmp_priv->network_macaddr[0] = 0x00;
+	pmp_priv->network_macaddr[1] = 0xE0;
+	pmp_priv->network_macaddr[2] = 0x4C;
+	pmp_priv->network_macaddr[3] = 0x87;
+	pmp_priv->network_macaddr[4] = 0x66;
+	pmp_priv->network_macaddr[5] = 0x55;
+
+	pnetwork->network.MacAddress[0] = 0x00;
+	pnetwork->network.MacAddress[1] = 0xE0;
+	pnetwork->network.MacAddress[2] = 0x4C;
+	pnetwork->network.MacAddress[3] = 0x87;
+	pnetwork->network.MacAddress[4] = 0x66;
+	pnetwork->network.MacAddress[5] = 0x55;
+
+	pnetwork->network.Ssid.SsidLength = 8;
+	_rtw_memcpy(pnetwork->network.Ssid.Ssid, "mp_871x", pnetwork->network.Ssid.SsidLength);
+
+	pmp_priv->rx_testcnt = 0;
+	pmp_priv->rx_testcnt1 = 0;
+	pmp_priv->rx_testcnt2 = 0;
+
+	pmp_priv->tx_testcnt = 0;
+	pmp_priv->tx_testcnt1 = 0;
+
+	pmp_wi_cntx->bmpdrv_unload = _FALSE;
+	pmp_wi_cntx->bmp_wi_progress = _FALSE;
+	pmp_wi_cntx->curractfunc = NULL;
+
+	return _SUCCESS;
+}
+#endif
+
+#ifdef PLATFORM_LINUX
+int init_mp_priv(struct mp_priv *pmp_priv)
+{
+	int i, res;
+	struct mp_xmit_frame *pmp_xmitframe;
+
+	//DBG_871X("+_init_mp_priv\n");
+
+	_init_mp_priv_(pmp_priv);
+
+	_rtw_init_queue(&pmp_priv->free_mp_xmitqueue);
+
+	pmp_priv->pallocated_mp_xmitframe_buf = NULL;
+	pmp_priv->pallocated_mp_xmitframe_buf = _rtw_zmalloc(NR_MP_XMITFRAME * sizeof(struct mp_xmit_frame) + 4);
+	if (pmp_priv->pallocated_mp_xmitframe_buf == NULL) {
+		//ERR_8712("_init_mp_priv, alloc mp_xmitframe_buf fail\n");
+		res = _FAIL;
+		goto _exit_init_mp_priv;
+	}
+
+	pmp_priv->pmp_xmtframe_buf = pmp_priv->pallocated_mp_xmitframe_buf + 4 - ((uint) (pmp_priv->pallocated_mp_xmitframe_buf) & 3);
+
+	pmp_xmitframe = (struct mp_xmit_frame*)pmp_priv->pmp_xmtframe_buf;
+
+	for (i = 0; i < NR_MP_XMITFRAME; i++)
+	{
+		_rtw_init_listhead(&(pmp_xmitframe->list));
+		rtw_list_insert_tail(&(pmp_xmitframe->list), &(pmp_priv->free_mp_xmitqueue.queue));
+
+		pmp_xmitframe->pkt = NULL;
+		pmp_xmitframe->frame_tag = MP_FRAMETAG;
+		pmp_xmitframe->padapter = pmp_priv->papdater;
+
+		pmp_xmitframe++;
+	}
+
+	pmp_priv->free_mp_xmitframe_cnt = NR_MP_XMITFRAME;
+
+	res = _SUCCESS;
+
+_exit_init_mp_priv:
+
+	return res;
+}
+
+int free_mp_priv(struct mp_priv *pmp_priv)
+{
+	int res = 0;
+
+	//DBG_871X("+_free_mp_priv\n");
+
+	if (pmp_priv->pallocated_mp_xmitframe_buf)
+		_rtw_mfree(pmp_priv->pallocated_mp_xmitframe_buf, 0);
+
+	return res;
+}
+#endif
+
+void mp871xinit(_adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	pmppriv->papdater = padapter;
+
+	init_mp_priv(pmppriv);
+}
+
+void _irqlevel_changed_(_irqL *irqlevel, u8 bLower)
+{
+
+#ifdef PLATFORM_OS_XP
+
+	if (bLower == LOWER) {
+		*irqlevel = KeGetCurrentIrql();
+
+		if (*irqlevel > PASSIVE_LEVEL) {
+				KeLowerIrql(PASSIVE_LEVEL);
+			//DEBUG_ERR(("\n <=== KeLowerIrql.\n"));
+		}
+	} else {
+		if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
+			KeRaiseIrql(DISPATCH_LEVEL, irqlevel);
+			//DEBUG_ERR(("\n <=== KeRaiseIrql.\n"));
+		}
+	}
+
+#endif
+
+}
+
+/*
+ * General use
+ */
+static u8 fw_cmd(PADAPTER pAdapter, u32 cmd)
+{
+	int pollingcnts = 50;
+
+	rtw_write32(pAdapter, IOCMD_CTRL_REG, cmd);
+	rtw_usleep_os(100);
+	while ((0 != rtw_read32(pAdapter, IOCMD_CTRL_REG)) && (pollingcnts > 0)) {
+		pollingcnts--;
+		rtw_usleep_os(10);
+	}
+
+	if (pollingcnts == 0) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_, ("!!fw_cmd timeout ........\n"));
+		return _FALSE;
+	}
+
+	return _TRUE;
+}
+
+static void fw_cmd_data(PADAPTER pAdapter, u32 *value, u8 flag)
+{
+	if (flag == 0)	// set
+		rtw_write32(pAdapter, IOCMD_DATA_REG, *value);
+	else		// query
+		*value = rtw_read32(pAdapter, IOCMD_DATA_REG);
+}
+
+/*
+ * Special for bb and rf reg read/write
+ */
+static u32 fw_iocmd_read(PADAPTER pAdapter, IOCMD_STRUCT iocmd)
+{
+	u32 cmd32 = 0, val32 = 0;
+
+	u8 iocmd_class	= iocmd.cmdclass;
+	u16 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+//	RT_TRACE(_module_rtl871x_mp_c_, _drv_alert_, ("fw_iocmd_read = cmd32:%x ........\n",cmd32));
+
+	if (fw_cmd(pAdapter, cmd32))
+		fw_cmd_data(pAdapter, &val32, 1);
+	else
+		val32 = 0;
+
+	return val32;
+}
+
+static u8 fw_iocmd_write(PADAPTER pAdapter, IOCMD_STRUCT iocmd, u32 value)
+{
+	u32 cmd32 = 0;
+
+	u8 iocmd_class	= iocmd.cmdclass;
+	u32 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	fw_cmd_data(pAdapter, &value, 0);
+	rtw_usleep_os(100);
+
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+	return fw_cmd(pAdapter, cmd32);
+}
+
+u32 bb_reg_read(PADAPTER pAdapter, u16 offset)// offset : 0X800~0XFFF
+{
+	u8 shift = offset & 0x0003;	// 4 byte access
+	u16 bb_addr = offset & 0x0FFC;	// 4 byte access
+	u32 bb_val = 0;
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_READ_IDX;
+	bb_val = fw_iocmd_read(pAdapter, iocmd);
+
+	if (shift != 0) {
+		u32 bb_val2 = 0;
+		bb_val >>= (shift * 8);
+		iocmd.value += 4;
+		bb_val2 = fw_iocmd_read(pAdapter, iocmd);
+		bb_val2 <<= ((4 - shift) * 8);
+		bb_val |= bb_val2;
+	}
+
+	return bb_val;
+}
+
+u8 bb_reg_write(PADAPTER pAdapter, u16 offset, u32 value)// offset : 0X800~0XFFF
+{
+	u8 shift = offset & 0x0003;	// 4 byte access
+	u16 bb_addr = offset & 0x0FFC;	// 4 byte access
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_WRITE_IDX;
+
+	if (shift != 0) {
+		u32 oldValue = 0;
+		u32 newValue = value;
+
+		oldValue = bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF >> ((4 - shift) * 8));
+		value = oldValue | (newValue << (shift * 8));
+		if (fw_iocmd_write(pAdapter, iocmd, value) == _FALSE)
+			return _FALSE;
+
+		iocmd.value += 4;
+		oldValue = bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF << (shift * 8));
+		value = oldValue | (newValue >> ((4 - shift) * 8));
+	}
+
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+u32 rf_reg_read(PADAPTER pAdapter, u8 path, u8 offset) // offset : 0x00 ~ 0xFF
+{
+	u16 rf_addr = (path << 8) | offset;
+	u32 rf_data;
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF ;
+	iocmd.value	= rf_addr ;
+	iocmd.index	= IOCMD_RF_READ_IDX;
+
+	rf_data = fw_iocmd_read(pAdapter,iocmd);
+
+	return rf_data;
+}
+
+u8 rf_reg_write(PADAPTER pAdapter, u8 path, u8 offset, u32 value)
+{
+	u16 rf_addr = (path << 8) | offset;
+
+	IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= rf_addr;
+	iocmd.index	= IOCMD_RF_WRIT_IDX;
+
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1) break;
+
+	return i;
+}
+
+u32 get_bb_reg(PADAPTER pAdapter, u16 offset, u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+
+	org_value = bb_reg_read(pAdapter ,offset);
+	bit_shift = bitshift(bitmask);
+//	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("get_bb_reg: org=0x%08x\n", org_value));
+	new_value = (org_value & bitmask) >> bit_shift;
+
+	return new_value;
+}
+
+u8 set_bb_reg(PADAPTER pAdapter, u16 offset, u32 bitmask, u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = bb_reg_read(pAdapter ,offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_,
+			 ("set_bb_reg: offset=0x%04x org=0x%08x new=0x%08x\n",
+			  offset, org_value, new_value));
+	} else {
+		new_value = value;
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_,
+			 ("set_bb_reg: offset=0x%04x value=0x%08x\n",
+			  offset, new_value));
+	}
+
+	return bb_reg_write(pAdapter,offset,new_value);
+}
+
+u32 get_rf_reg(PADAPTER pAdapter, u8 path, u8 offset, u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+	org_value = rf_reg_read(pAdapter, path, offset);
+	bit_shift = bitshift(bitmask);
+	new_value = (org_value & bitmask) >> bit_shift;
+
+	return new_value;
+}
+
+u8 set_rf_reg(PADAPTER pAdapter, u8 path, u8 offset, u32 bitmask, u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = rf_reg_read(pAdapter, path, offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("set_rf_reg: v=0x%08x org=0x%08x new=0x%08x\n", value, org_value, new_value));
+	} else {
+		new_value = value;
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("set_rf_reg: v=0x%08x new=0x%08x\n", value, new_value));
+	}
+
+	return rf_reg_write(pAdapter, path, offset, new_value);
+}
+
+/*
+ * SetChannel
+ * Description
+ *	Use H2C command to change channel,
+ *	not only modify rf register, but also other setting need to be done.
+ */
+void SetChannel(PADAPTER pAdapter)
+{
+#if 1
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetChannel_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetChannel);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+SetChannel: %d\n", pAdapter->mppriv.curr_ch));
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetChannel: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetChannel_parm*)_rtw_zmalloc(sizeof(struct SetChannel_parm));
+ 	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetChannel: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_ch = pAdapter->mppriv.curr_ch;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+#else
+	u32 curr_ch = pAdapter->mppriv.curr_ch;
+	u8 eRFPath;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("+SetChannel: %d\n", curr_ch));
+	for (eRFPath = 0; eRFPath < MAX_RF_PATH_NUMS; eRFPath++) {
+		set_rf_reg(pAdapter, eRFPath, rRfChannel, 0x3FF, curr_ch);
+		rtw_usleep_os(100);
+	}
+#endif
+}
+
+void SetCCKTxPower(PADAPTER pAdapter, u8 TxPower)
+{
+	u16 TxAGC = 0;
+
+	TxAGC = TxPower;
+	set_bb_reg(pAdapter, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-SetCCKTxPower: %d\n", TxPower));
+}
+
+void SetOFDMTxPower(PADAPTER pAdapter, u8 TxPower)
+{
+	u32 TxAGC = 0;
+
+	TxAGC |= ((TxPower<<24)|(TxPower<<16)|(TxPower<<8)|TxPower);
+
+	set_bb_reg(pAdapter, rTxAGC_Rate18_06, bTxAGCRate18_06, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Rate54_24, bTxAGCRate54_24, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs03_Mcs00, bTxAGCRateMCS3_MCS0, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs07_Mcs04, bTxAGCRateMCS7_MCS4, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs11_Mcs08, bTxAGCRateMCS11_MCS8, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs15_Mcs12, bTxAGCRateMCS15_MCS12, TxAGC);
+	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("-SetOFDMTxPower: %d\n", TxPower));
+}
+
+void SetTxPower(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetTxPower_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetTxPower);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("-SetTxPower: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetTxPower_parm*)_rtw_zmalloc(sizeof(struct SetTxPower_parm));
+ 	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("-SetTxPower: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->TxPower = pAdapter->mppriv.curr_txpoweridx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+#else
+
+	u8 TxPower = pAdapter->mppriv.curr_txpoweridx;
+#if 0
+	if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M)
+	{
+		SetCCKTxPower( pAdapter,TxPower);
+	}
+	else if ((pAdapter->mppriv.curr_rateidx>= MPT_RATE_6M) &&
+		 (pAdapter->mppriv.curr_rateidx<= MPT_RATE_MCS15))
+	{
+		SetOFDMTxPower(pAdapter,TxPower);
+	}
+#else
+	SetCCKTxPower(pAdapter, TxPower);
+	SetOFDMTxPower(pAdapter, TxPower);
+#endif
+#endif
+}
+
+void SetTxAGCOffset(PADAPTER pAdapter, u32 ulTxAGCOffset)
+{
+	u32 TxAGCOffset_B, TxAGCOffset_C, TxAGCOffset_D,tmpAGC;
+
+	TxAGCOffset_B = (ulTxAGCOffset&0x000000ff);
+	TxAGCOffset_C = ((ulTxAGCOffset&0x0000ff00)>>8);
+	TxAGCOffset_D = ((ulTxAGCOffset&0x00ff0000)>>16);
+
+	tmpAGC = (TxAGCOffset_D<<8 | TxAGCOffset_C<<4 | TxAGCOffset_B);
+	set_bb_reg(pAdapter, rFPGA0_TxGainStage,
+			(bXBTxAGC|bXCTxAGC|bXDTxAGC), tmpAGC);
+}
+
+void SetDataRate(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+#if 1
+	rtw_setdatarate_cmd(pAdapter, &pAdapter->mppriv.curr_rateidx)
+#else
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct setdatarate_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetDataRate);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetDataRate: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct setdatarate_parm*)_rtw_zmalloc(sizeof(struct setdatarate_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetDataRate: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_rateidx = pAdapter->mppriv.curr_rateidx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+#endif
+#else
+	u8 path = RF_PATH_A;
+	u8 offset = 0x26;
+	u32 value;
+	value = (pAdapter->mppriv.curr_rateidx < 4) ? 0x4440 : 0xF200;
+
+	rf_reg_write(pAdapter, path, offset, value);
+#endif
+}
+
+void SwitchBandwidth(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SwitchBandwidth_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SwitchBandwidth);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchBandwidth: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SwitchBandwidth_parm*)_rtw_zmalloc(sizeof(struct SwitchBandwidth_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchBandwidth: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_bandwidth = pAdapter->mppriv.curr_bandwidth;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+	//3 1.Set MAC register : BWOPMODE  bit2:1 20MhzBW
+	u8 regBwOpMode = 0;
+	u8 Bandwidth = pAdapter->mppriv.curr_bandwidth;
+
+	regBwOpMode = rtw_read8(pAdapter, 0x10250203);
+
+	if (Bandwidth == HT_CHANNEL_WIDTH_20) {
+		regBwOpMode |= BIT(2);
+	} else {
+		regBwOpMode &= ~(BIT(2));
+	}
+	rtw_write8(pAdapter, 0x10250203, regBwOpMode);
+
+	//3 2.Set PHY related register
+	switch (Bandwidth)
+	{
+		/* 20 MHz channel*/
+		case HT_CHANNEL_WIDTH_20:
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x0);
+			set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x0);
+
+			// Use PHY_REG.txt default value. Do not need to change.
+			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
+			// It is set in Tx descriptor for 8192x series
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter1, bMaskDWord, 0x1a1b0000);
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter2, bMaskDWord, 0x090e1317);
+			//PHY_SetBBReg(Adapter, rCCK0_DebugPort, bMaskDWord, 0x00000204);
+			// From SD3 WHChang
+			//PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter1, 0x00300000, 3);
+			set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x58);
+
+			break;
+
+		/* 40 MHz channel*/
+		case HT_CHANNEL_WIDTH_40:
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x1);
+			set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x1);
+
+			// Use PHY_REG.txt default value. Do not need to change.
+			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter1, bMaskDWord, 0x35360000);
+			//PHY_SetBBReg(Adapter, rCCK0_TxFilter2, bMaskDWord, 0x121c252e);
+			//PHY_SetBBReg(Adapter, rCCK0_DebugPort, bMaskDWord, 0x00000409);
+			// From SD3 WHChang
+			//PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter1, 0x00300000, 3);
+
+			// Set Control channel to upper or lower. These settings are required only for 40MHz
+			set_bb_reg(pAdapter, rCCK0_System, bCCKSideBand, (HAL_PRIME_CHNL_OFFSET_DONT_CARE>>1));
+			set_bb_reg(pAdapter, rOFDM1_LSTF, 0xC00, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+
+			set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x18);
+
+			break;
+		default:
+			break;
+	}
+
+	//3 3.Set RF related register
+	switch (Bandwidth)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW, BIT(10)|BIT(11), 0x01);
+			break;
+
+		case HT_CHANNEL_WIDTH_40:
+			set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW, BIT(10)|BIT(11), 0x00);
+			break;
+
+		default:
+			break;
+	}
+#endif
+}
+/*------------------------------Define structure----------------------------*/
+typedef struct _R_ANTENNA_SELECT_OFDM {
+	u32	r_tx_antenna:4;
+	u32	r_ant_l:4;
+	u32	r_ant_non_ht:4;
+	u32	r_ant_ht1:4;
+	u32	r_ant_ht2:4;
+	u32	r_ant_ht_s1:4;
+	u32	r_ant_non_ht_s1:4;
+	u32	OFDM_TXSC:2;
+	u32	Reserved:2;
+}R_ANTENNA_SELECT_OFDM;
+
+typedef struct _R_ANTENNA_SELECT_CCK {
+	u8	r_cckrx_enable_2:2;
+	u8	r_cckrx_enable:2;
+	u8	r_ccktx_enable:4;
+}R_ANTENNA_SELECT_CCK;
+
+void SwitchAntenna(PADAPTER pAdapter)
+{
+//#ifdef MP_FIRMWARE_OFFLOAD
+#if 0
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SwitchAntenna_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SwitchAntenna);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchAntenna: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SwitchAntenna_parm*)_rtw_zmalloc(sizeof(struct SwitchAntenna_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SwitchAntenna: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->antenna_tx = pAdapter->mppriv.antenna_tx;
+	pparm->antenna_rx = pAdapter->mppriv.antenna_rx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+#else
+	u32	ofdm_tx_en_val = 0, ofdm_tx_ant_sel_val = 0;
+	u8	ofdm_rx_ant_sel_val = 0;
+	u8	cck_ant_select_val = 0;
+	u32	cck_ant_sel_val = 0;
+
+	R_ANTENNA_SELECT_CCK *p_cck_txrx;
+
+
+	p_cck_txrx = (R_ANTENNA_SELECT_CCK*)&cck_ant_select_val;
+
+	switch (pAdapter->mppriv.antenna_tx)
+	{
+		case ANTENNA_A:
+			// From SD3 Willis suggestion !!! Set RF A=TX and B as standby
+			set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+			set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 1);
+
+			ofdm_tx_en_val			= 0x3;
+			ofdm_tx_ant_sel_val		= 0x11111111;// Power save
+
+			p_cck_txrx->r_ccktx_enable	= 0x8;
+			break;
+
+		case ANTENNA_B:
+			set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 1);
+			set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+
+			ofdm_tx_en_val			= 0x3;
+			ofdm_tx_ant_sel_val		= 0x22222222;// Power save
+
+			p_cck_txrx->r_ccktx_enable	= 0x4;
+			break;
+
+		case ANTENNA_AB:	// For 8192S
+			set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+			set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+
+			ofdm_tx_en_val			= 0x3;
+			ofdm_tx_ant_sel_val		= 0x3321333;	// Disable Power save
+
+			p_cck_txrx->r_ccktx_enable	= 0xC;
+			break;
+
+		default:
+			break;
+	}
+	set_bb_reg(pAdapter, rFPGA1_TxInfo, 0xffffffff, ofdm_tx_ant_sel_val);	//OFDM Tx
+	set_bb_reg(pAdapter, rFPGA0_TxInfo, 0x0000000f, ofdm_tx_en_val);	//OFDM Tx
+
+	switch (pAdapter->mppriv.antenna_rx)
+	{
+		case ANTENNA_A:
+			ofdm_rx_ant_sel_val		= 0x1;	// A
+			p_cck_txrx->r_cckrx_enable 	= 0x0;	// default: A
+			p_cck_txrx->r_cckrx_enable_2	= 0x0;	// option: A
+			break;
+
+		case ANTENNA_B:
+			ofdm_rx_ant_sel_val		= 0x2;	// B
+			p_cck_txrx->r_cckrx_enable 	= 0x1;	// default: B
+			p_cck_txrx->r_cckrx_enable_2	= 0x1;	// option: B
+			break;
+
+		case ANTENNA_AB:
+			ofdm_rx_ant_sel_val		= 0x3;	// AB
+			p_cck_txrx->r_cckrx_enable 	= 0x0;	// default:A
+			p_cck_txrx->r_cckrx_enable_2	= 0x1;	// option:B
+			break;
+
+		default:
+			break;
+	}
+	set_bb_reg(pAdapter, rOFDM0_TRxPathEnable, 0x0000000f, ofdm_rx_ant_sel_val);	//OFDM Rx
+	set_bb_reg(pAdapter, rOFDM1_TRxPathEnable, 0x0000000f, ofdm_rx_ant_sel_val);	//OFDM Rx
+
+	cck_ant_sel_val = cck_ant_select_val;
+	set_bb_reg(pAdapter, rCCK0_AFESetting, bMaskByte3, cck_ant_sel_val);		//CCK TxRx
+#endif
+
+	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("-SwitchAntenna: finished\n"));
+}
+
+void SetCrystalCap(PADAPTER pAdapter)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetCrystalCap_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetCrystalCap);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetCrystalCap: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetCrystalCap_parm*)_rtw_zmalloc(sizeof(struct SetCrystalCap_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetCrystalCap: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->curr_crystalcap = pAdapter->mppriv.curr_crystalcap;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+#else
+	set_bb_reg(pAdapter, rFPGA0_AnalogParameter1, bXtalCap, pAdapter->mppriv.curr_crystalcap);
+	RT_TRACE(_module_rtl871x_mp_c_, _drv_notice_, ("-SetCrystalCap: %d\n", pAdapter->mppriv.curr_crystalcap));
+#endif
+}
+
+void TriggerRFThermalMeter(PADAPTER pAdapter)
+{
+	set_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);	// 0x24: RF Reg[6:5]
+//	RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("TriggerRFThermalMeter() finished.\n" ));
+}
+
+u32 ReadRFThermalMeter(PADAPTER pAdapter)
+{
+	u32 ThermalValue = 0;
+
+	ThermalValue = get_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, 0x1F);	// 0x24: RF Reg[4:0]
+//	RT_TRACE(_module_rtl871x_mp_c_, _drv_alert_, ("ThermalValue = 0x%x\n", ThermalValue));
+	return ThermalValue;
+}
+
+void GetThermalMeter(PADAPTER pAdapter, u32 *value)
+{
+#if 0
+	fw_cmd(pAdapter, IOCMD_GET_THERMAL_METER);
+	rtw_msleep_os(1000);
+	fw_cmd_data(pAdapter, value, 1);
+	*value &= 0xFF;
+#else
+	TriggerRFThermalMeter(pAdapter);
+	rtw_msleep_os(1000);
+	*value = ReadRFThermalMeter(pAdapter);
+#endif
+}
+
+void SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetSingleCarrierTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetSingleCarrierTx);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleCarrierTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetSingleCarrierTx_parm*)_rtw_zmalloc(sizeof(struct SetSingleCarrierTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleCarrierTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+
+	if (bStart)// Start Single Carrier.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleCarrierTx test start.........\n"));
+		// 1. if OFDM block on?
+		if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);//set OFDM block on
+
+		// 2. set CCK test mode off, set to CCK normal mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+
+		// 3. turn on scramble setting
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+
+		// 4. Turn On Continue Tx and turn off the other test modes.
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	}
+	else// Stop Single Carrier.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleCarrierTx test stop.........\n"));
+		//Turn off all test modes.
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+
+		//Delay 10 ms //delay_ms(10);
+		rtw_msleep_os(10);
+
+		//BB Reset
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+#endif
+}
+
+void SetSingleToneTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetSingleToneTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetSingleToneTx);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleToneTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetSingleToneTx_parm*)_rtw_zmalloc(sizeof(struct SetSingleToneTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleToneTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+	switch (pAdapter->mppriv.antenna_tx)
+	{
+		case ANTENNA_B:
+			pparm->curr_rfpath = RF_PATH_B;
+			break;
+		case ANTENNA_A:
+		default:
+			pparm->curr_rfpath = RF_PATH_A;
+			break;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+	u8 rfPath = pAdapter->mppriv.curr_rfpath;
+
+	switch (pAdapter->mppriv.antenna_tx)
+	{
+		case ANTENNA_B:
+			rfPath = RF_PATH_B;
+			break;
+		case ANTENNA_A:
+		default:
+			rfPath = RF_PATH_A;
+			break;
+	}
+
+	if (bStart)// Start Single Tone.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleToneTx test start.........\n"));
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x0);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x0);
+		//set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMTxDACPhase, 0x1);
+
+		set_rf_reg(pAdapter, rfPath, 0x21, bRFRegOffsetMask, 0xd4000);
+		rtw_usleep_os(100);
+		set_rf_reg(pAdapter, rfPath, 0x00, bRFRegOffsetMask, 0x2001f); // PAD all on.
+		rtw_usleep_os(100);
+	}
+	else// Stop Single Tone.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetSingleToneTx test stop.........\n"));
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x1);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x1);
+		//set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMTxDACPhase, 0x1);
+		set_rf_reg(pAdapter, rfPath, 0x21, bRFRegOffsetMask, 0x54000);
+		rtw_usleep_os(100);
+		set_rf_reg(pAdapter, rfPath, 0x00, bRFRegOffsetMask, 0x30000); // PAD all on.
+		rtw_usleep_os(100);
+	}
+#endif
+}
+
+void SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetCarrierSuppressionTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetCarrierSuppressionTx);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetSingleToneTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetCarrierSuppressionTx_parm*)_rtw_zmalloc(sizeof(struct SetCarrierSuppressionTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetCarrierSuppressionTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+	pparm->curr_rateidx = pAdapter->mppriv.curr_rateidx;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+
+	if (bStart) // Start Carrier Suppression.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCarrierSuppressionTx test start.........\n"));
+		//if(pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M) {
+			// 1. if CCK block on?
+			if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn))
+				set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);//set CCK block on
+
+			//Turn Off All Test Mode
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);    //transmit mode
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x0);  //turn off scramble setting
+
+			//Set CCK Tx Test Rate
+			//PHY_SetBBReg(pAdapter, rCCK0_System, bCCKTxRate, pMgntInfo->ForcedDataRate);
+			set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, 0x0);    //Set FTxRate to 1Mbps
+		}
+	}
+	else// Stop Carrier Suppression.
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCarrierSuppressionTx test stop.........\n"));
+		//if(pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M ) {
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);    //normal mode
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x1);  //turn on scramble setting
+
+			//BB Reset
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+		}
+	}
+	//DbgPrint("\n MPT_ProSetCarrierSupp() is finished. \n");
+#endif
+}
+
+void SetCCKContinuousTx(PADAPTER pAdapter, u8 bStart)
+{
+	u32 cckrate;
+
+	if (bStart)
+	{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCCKContinuousTx test start.........\n"));
+
+		// 1. if CCK block on?
+		if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn))
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);//set CCK block on
+
+		//Turn Off All Test Mode
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		//Set CCK Tx Test Rate
+		#if 0
+		switch(pAdapter->mppriv.curr_rateidx)
+		{
+			case 2:
+				cckrate = 0;
+				break;
+			case 4:
+				cckrate = 1;
+				break;
+			case 11:
+				cckrate = 2;
+				break;
+			case 22:
+				cckrate = 3;
+				break;
+			default:
+				cckrate = 0;
+				break;
+		}
+		#else
+		cckrate  = pAdapter->mppriv.curr_rateidx;
+		#endif
+		set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, cckrate);
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);	//transmit mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x1);	//turn on scramble setting
+	}
+	else{
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetCCKContinuousTx test stop.........\n"));
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);	//normal mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, 0x1);	//turn on scramble setting
+
+		//BB Reset
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+}/* mpt_StartCckContTx */
+
+void SetOFDMContinuousTx(PADAPTER pAdapter, u8 bStart)
+{
+	if (bStart) {
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetOFDMContinuousTx test start.........\n"));
+		// 1. if OFDM block on?
+		if(!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);//set OFDM block on
+
+		// 2. set CCK test mode off, set to CCK normal mode
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+
+		// 3. turn on scramble setting
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+
+		// 4. Turn On Continue Tx and turn off the other test modes.
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	} else {
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetOFDMContinuousTx test stop.........\n"));
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		//Delay 10 ms
+		rtw_msleep_os(10);
+		//BB Reset
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+}/* mpt_StartOfdmContTx */
+
+void SetContinuousTx(PADAPTER pAdapter, u8 bStart)
+{
+#ifdef MP_FIRMWARE_OFFLOAD
+
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetContinuousTx_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetContinuousTx);
+
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetContinuousTx: memory allocate for cmd_obj fail!!!\n"));
+		return;
+	}
+
+	pparm = (struct SetContinuousTx_parm*)_rtw_zmalloc(sizeof(struct SetContinuousTx_parm));
+	if (pparm == NULL) {
+		if (pcmd != NULL)
+			_rtw_mfree((u8*)pcmd, sizeof(struct cmd_obj));
+		RT_TRACE(_module_rtl871x_mp_c_, _drv_err_,
+			 ("SetContinuousTx: memory allocate for parm fail!!!\n"));
+		return;
+	}
+	pparm->bStart = bStart;
+	pparm->CCK_flag = 1;	// CCK
+	pparm->curr_rateidx = pAdapter->mppriv.curr_rateidx;
+	if ((pparm->curr_rateidx >= MPT_RATE_6M) &&
+	    (pparm->curr_rateidx <= MPT_RATE_MCS15))
+		pparm->CCK_flag = 2;	// OFDM
+
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+#else
+	// ADC turn off [bit24-21] adc port0 ~ port1
+	if (bStart) {
+		bb_reg_write(pAdapter, rRx_Wait_CCCA, bb_reg_read(pAdapter, rRx_Wait_CCCA) & 0xFE1FFFFF);
+		rtw_usleep_os(100);
+	}
+	RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("SetContinuousTx #2 rate:%d........\n", pAdapter->mppriv.curr_rateidx));
+	if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M)
+	{
+		SetCCKContinuousTx(pAdapter, bStart);
+	}
+	else if ((pAdapter->mppriv.curr_rateidx >= MPT_RATE_6M) &&
+		 (pAdapter->mppriv.curr_rateidx <= MPT_RATE_MCS15))
+	{
+		SetOFDMContinuousTx(pAdapter, bStart);
+	}
+	// ADC turn on [bit24-21] adc port0 ~ port1
+	if (!bStart) {
+		bb_reg_write(pAdapter, rRx_Wait_CCCA, bb_reg_read(pAdapter, rRx_Wait_CCCA) | 0x01E00000);
+	}
+#endif
+}
+
+void ResetPhyRxPktCount(PADAPTER pAdapter)
+{
+	u32 i, phyrx_set = 0;
+
+	for (i = OFDM_PPDU_BIT; i <= HT_MPDU_FAIL_BIT; i++) {
+		phyrx_set = 0;
+		phyrx_set |= (i << 28);		//select
+		phyrx_set |= 0x08000000;	// set counter to zero
+		rtw_write32(pAdapter, RXERR_RPT, phyrx_set);
+	}
+}
+
+static u32 GetPhyRxPktCounts(PADAPTER pAdapter, u32 selbit)
+{
+	//selection
+	u32 phyrx_set = 0, count = 0;
+	u32 SelectBit;
+
+	SelectBit = selbit << 28;
+	phyrx_set |= (SelectBit & 0xF0000000);
+
+	rtw_write32(pAdapter, RXERR_RPT, phyrx_set);
+
+	//Read packet count
+	count = rtw_read32(pAdapter, RXERR_RPT) & RPTMaxCount;
+
+	return count;
+}
+
+u32 GetPhyRxPktReceived(PADAPTER pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_OK_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_OK_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_OK_BIT);
+
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
+
+u32 GetPhyRxPktCRC32Error(PADAPTER pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_FAIL_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_FAIL_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_FAIL_BIT);
+
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_IQCalibrateBcut()
+ *
+ * Overview:	After all MAC/PHY/RF is configued. We must execute IQ calibration
+ *			to improve RF EVM!!?
+ *
+ * Input:		IN	PADAPTER	pAdapter
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	11/18/2008	MHC		Create. Document from SD3 RFSI Jenyu.
+ *						92S B-cut QFN 68 pin IQ calibration procedure.doc
+ *
+ *---------------------------------------------------------------------------*/
+typedef enum _RF90_RADIO_PATH {
+	RF90_PATH_A = 0,	//Radio Path A
+	RF90_PATH_B = 1,	//Radio Path B
+	RF90_PATH_C = 2,	//Radio Path C
+	RF90_PATH_D = 3,	//Radio Path D
+	RF90_PATH_MAX		//Max RF number 90 support
+}RF90_RADIO_PATH_E, *PRF90_RADIO_PATH_E;
+
+void IQCalibrateBcut(PADAPTER pAdapter)
+{
+	u32	i, reg;
+	u32	old_value;
+	s32	X, Y, TX0[4];
+	u32	TXA[4];
+	u16	calibrate_set[13] = {0};
+	u32	load_value[13];
+
+	RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("@@@@@@ IQCalibrateBcut Start... \n"));
+	// 0. Check QFN68 or 64 92S (Read from EEPROM/EFUSE)
+
+	//
+	// 1. Save e70~ee0 register setting, and load calibration setting
+	//
+	calibrate_set [0] = 0xee0;
+	calibrate_set [1] = 0xedc;
+	calibrate_set [2] = 0xe70;
+	calibrate_set [3] = 0xe74;
+	calibrate_set [4] = 0xe78;
+	calibrate_set [5] = 0xe7c;
+	calibrate_set [6] = 0xe80;
+	calibrate_set [7] = 0xe84;
+	calibrate_set [8] = 0xe88;
+	calibrate_set [9] = 0xe8c;
+	calibrate_set [10] = 0xed0;
+	calibrate_set [11] = 0xed4;
+	calibrate_set [12] = 0xed8;
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Save e70~ee0 register setting\n"));
+	for (i = 0; i < 13; i++)
+	{
+		load_value[i] = get_bb_reg(pAdapter, calibrate_set[i], bMaskDWord);
+		set_bb_reg(pAdapter, calibrate_set[i], bMaskDWord, 0x3fed92fb);
+	}
+
+	//
+	// 2. QFN 68
+	//
+	// For 1T2R IQK only now !!!
+	for (i = 0; i < 10; i++)
+	{
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("IQK -%d\n", i));
+		RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("@@@@@@ IQK -%d\n", i));
+
+		//BB switch to PI mode. If default is PI mode, ignoring 2 commands below.
+		//if (pMgntInfo->bRFSiOrPi == 0)	// SI
+		{
+			set_bb_reg(pAdapter, 0x820, bMaskDWord, 0x01000100);
+			set_bb_reg(pAdapter, 0x828, bMaskDWord, 0x01000100);
+		}
+
+		// IQK
+		// 2. IQ calibration & LO leakage calibration
+		set_bb_reg(pAdapter, 0xc04, bMaskDWord, 0x00a05430);
+
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xc08, bMaskDWord, 0x000800e4);
+
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xe28, bMaskDWord, 0x80800000);
+		rtw_udelay_os(5);
+		//path-A IQ K and LO K gain setting
+		set_bb_reg(pAdapter, 0xe40, bMaskDWord, 0x02140102);
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xe44, bMaskDWord, 0x681604c2);
+		rtw_udelay_os(5);
+		//set LO calibration
+		set_bb_reg(pAdapter, 0xe4c, bMaskDWord, 0x000028d1);
+		rtw_udelay_os(5);
+		//path-B IQ K and LO K gain setting
+		set_bb_reg(pAdapter, 0xe60, bMaskDWord, 0x02140102);
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xe64, bMaskDWord, 0x28160d05);
+		rtw_udelay_os(5);
+		//K idac_I & IQ
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xfb000000);
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xf8000000);
+		rtw_udelay_os(5);
+
+		// delay 2ms
+		rtw_udelay_os(2000);
+
+		//idac_Q setting
+		set_bb_reg(pAdapter, 0xe6c, bMaskDWord, 0x020028d1);
+		rtw_udelay_os(5);
+		//K idac_Q & IQ
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xfb000000);
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xe48, bMaskDWord, 0xf8000000);
+
+		// delay 2ms
+		rtw_udelay_os(2000);
+
+		set_bb_reg(pAdapter, 0xc04, bMaskDWord, 0x00a05433);
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xc08, bMaskDWord, 0x000000e4);
+		rtw_udelay_os(5);
+		set_bb_reg(pAdapter, 0xe28, bMaskDWord, 0x0);
+
+		//f (pMgntInfo->bRFSiOrPi == 0)	// SI
+		{
+			set_bb_reg(pAdapter, 0x820, bMaskDWord, 0x01000000);
+			set_bb_reg(pAdapter, 0x828, bMaskDWord, 0x01000000);
+		}
+
+		reg = get_bb_reg(pAdapter, 0xeac, bMaskDWord);
+
+		// 3.	check fail bit, and fill BB IQ matrix
+		// Readback IQK value and rewrite
+		if (!(reg&(BIT(27)|BIT(28)|BIT(30)|BIT(31))))
+		{
+			old_value = (get_bb_reg(pAdapter, 0xc80, bMaskDWord) & 0x3FF);
+
+			// Calibrate init gain for A path for TX0
+			X = (get_bb_reg(pAdapter, 0xe94, bMaskDWord) & 0x03FF0000)>>16;
+
+			TXA[RF90_PATH_A] = (X * old_value)/0x100;
+
+			reg = get_bb_reg(pAdapter, 0xc80, bMaskDWord);
+			reg = (reg & 0xFFFFFC00) | (u32)TXA[RF90_PATH_A];
+			set_bb_reg(pAdapter, 0xc80, bMaskDWord, reg);
+			rtw_udelay_os(5);
+
+			// Calibrate init gain for C path for TX0
+			Y = ( get_bb_reg(pAdapter, 0xe9C, bMaskDWord) & 0x03FF0000)>>16;
+			TX0[RF90_PATH_C] = ((Y * old_value)/0x100);
+			reg = get_bb_reg(pAdapter, 0xc80, bMaskDWord);
+			reg = (reg & 0xffc0ffff) |((u32) (TX0[RF90_PATH_C]&0x3F)<<16);
+			set_bb_reg(pAdapter, 0xc80, bMaskDWord, reg);
+			reg = get_bb_reg(pAdapter, 0xc94, bMaskDWord);
+			reg = (reg & 0x0fffffff) |(((Y&0x3c0)>>6)<<28);
+			set_bb_reg(pAdapter, 0xc94, bMaskDWord, reg);
+			rtw_udelay_os(5);
+
+			// Calibrate RX A and B for RX0
+			reg = get_bb_reg(pAdapter, 0xc14, bMaskDWord);
+			X = (get_bb_reg(pAdapter, 0xea4, bMaskDWord) & 0x03FF0000)>>16;
+			reg = (reg & 0xFFFFFC00) |X;
+			set_bb_reg(pAdapter, 0xc14, bMaskDWord, reg);
+			Y = (get_bb_reg(pAdapter, 0xeac, bMaskDWord) & 0x003F0000)>>16;
+			reg = (reg & 0xFFFF03FF) |(Y<<10);
+			set_bb_reg(pAdapter, 0xc14, bMaskDWord, reg);
+			rtw_udelay_os(5);
+			old_value = (get_bb_reg(pAdapter, 0xc88, bMaskDWord) & 0x3FF);
+
+			// Calibrate init gain for A path for TX1 !!!!!!
+			X = (get_bb_reg(pAdapter, 0xeb4, bMaskDWord) & 0x03FF0000)>>16;
+			reg = get_bb_reg(pAdapter, 0xc88, bMaskDWord);
+			TXA[RF90_PATH_A] = (X * old_value) / 0x100;
+			reg = (reg & 0xFFFFFC00) | TXA[RF90_PATH_A];
+			set_bb_reg(pAdapter, 0xc88, bMaskDWord, reg);
+			rtw_udelay_os(5);
+
+			// Calibrate init gain for C path for TX1
+			Y = (get_bb_reg(pAdapter, 0xebc, bMaskDWord)& 0x03FF0000)>>16;
+			TX0[RF90_PATH_C] = ((Y * old_value)/0x100);
+			reg = get_bb_reg(pAdapter, 0xc88, bMaskDWord);
+			reg = (reg & 0xffc0ffff) |( (TX0[RF90_PATH_C]&0x3F)<<16);
+			set_bb_reg(pAdapter, 0xc88, bMaskDWord, reg);
+			reg = get_bb_reg(pAdapter, 0xc9c, bMaskDWord);
+			reg = (reg & 0x0fffffff) |(((Y&0x3c0)>>6)<<28);
+			set_bb_reg(pAdapter, 0xc9c, bMaskDWord, reg);
+			rtw_udelay_os(5);
+
+			// Calibrate RX A and B for RX1
+			reg = get_bb_reg(pAdapter, 0xc1c, bMaskDWord);
+			X = (get_bb_reg(pAdapter, 0xec4, bMaskDWord) & 0x03FF0000)>>16;
+			reg = (reg & 0xFFFFFC00) |X;
+			set_bb_reg(pAdapter, 0xc1c, bMaskDWord, reg);
+
+			Y = (get_bb_reg(pAdapter, 0xecc, bMaskDWord) & 0x003F0000)>>16;
+			reg = (reg & 0xFFFF03FF) |Y<<10;
+			set_bb_reg(pAdapter, 0xc1c, bMaskDWord, reg);
+			rtw_udelay_os(5);
+
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PHY_IQCalibrate OK\n"));
+			RT_TRACE(_module_rtl871x_mp_c_,_drv_alert_, ("@@@@@@ PHY_IQCalibrate OK\n"));
+			break;
+		}
+	}
+
+	//
+	// 4. Reload e70~ee0 register setting.
+	//
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Reload e70~ee0 register setting.\n"));
+	for (i = 0; i < 13; i++)
+		set_bb_reg(pAdapter, calibrate_set[i], bMaskDWord, load_value[i]);
+
+	//
+	// 3. QFN64. Not enabled now !!! We must use different gain table for 1T2R.
+	//
+
+}	// PHY_IQCalibrateBcut
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mp_ioctl.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mp_ioctl.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_mp_ioctl.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_mp_ioctl.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,3068 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_MP_IOCTL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <mlme_osdep.h>
+
+#include <rtw_mp.h>
+#include <rtw_mp_ioctl.h>
+#include <rtw_mp_phy_regdef.h>
+
+#ifdef PLATFORM_LINUX
+NDIS_STATUS oid_null_function(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+#endif
+
+//****************  oid_rtl_seg_81_85   section start ****************
+NDIS_STATUS oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid == SET_OID)
+	{
+		if (poid_par_priv->information_buf_len >= sizeof(u8))
+			Adapter->registrypriv.wireless_mode = *(u8*)poid_par_priv->information_buf;
+		else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	}
+	else if (poid_par_priv->type_of_oid == QUERY_OID)
+	{
+		if (poid_par_priv->information_buf_len >= sizeof(u8)) {
+			*(u8*)poid_par_priv->information_buf = Adapter->registrypriv.wireless_mode;
+			*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+			 RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-query Wireless Mode=%d\n", Adapter->registrypriv.wireless_mode));
+		} else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	} else {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//****************  oid_rtl_seg_81_87_80   section start ****************
+NDIS_STATUS oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL oldirql;
+
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_write_bb_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+
+	offset = (u16)(pbbreg->offset) & 0xFFF; //0ffset :0x800~0xfff
+	if (offset < BB_REG_BASE_ADDR) offset |= BB_REG_BASE_ADDR;
+
+	value = pbbreg->value;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_write_bb_reg_hdl: offset=0x%04x value=0x%08x\n",
+		  offset, value));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	bb_reg_write(Adapter, offset, value);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL oldirql;
+
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_read_bb_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+
+	offset = (u16)(pbbreg->offset) & 0xFFF; //0ffset :0x800~0xfff
+	if (offset < BB_REG_BASE_ADDR) offset |= BB_REG_BASE_ADDR;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	value = bb_reg_read(Adapter, offset);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	pbbreg->value = value;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-oid_rt_pro_read_bb_reg_hdl: offset=0x%04x value:0x%08x\n",
+		  offset, value));
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL oldirql;
+
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_write_rf_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	offset = (u8)pbbreg->offset;
+	value = pbbreg->value;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_write_rf_reg_hdl: path=%d offset=0x%02x value=0x%08x\n",
+		  path, offset, value));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+ 	rf_reg_write(Adapter, path, offset, value);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+	_irqL oldirql;
+
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_read_rf_reg_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B) // 1T2R  path_a /path_b
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	offset = (u8)pbbreg->offset;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	value = rf_reg_read(Adapter, path, offset);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	pbbreg->value = value;
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-oid_rt_pro_read_rf_reg_hdl: path=%d offset=0x%02x value=0x%08x\n",
+		  path, offset, value));
+
+_func_exit_;
+
+	return status;
+}
+//****************  oid_rtl_seg_81_87_00   section end****************
+//------------------------------------------------------------------------------
+//This function initializes the DUT to the MP test mode
+int mp_start_test(_adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+	WLAN_BSSID_EX bssid;
+	struct sta_info *psta;
+	unsigned long length;
+
+		_irqL irqL;
+	int res = _SUCCESS;
+
+
+	//3 1. initialize a new WLAN_BSSID_EX
+//	_rtw_memset(&bssid, 0, sizeof(WLAN_BSSID_EX));
+
+	_rtw_memcpy(bssid.MacAddress, pmppriv->network_macaddr, ETH_ALEN);
+	bssid.Ssid.SsidLength = 16;
+	_rtw_memcpy(bssid.Ssid.Ssid, (unsigned char*)"mp_pseudo_adhoc", bssid.Ssid.SsidLength);
+	bssid.InfrastructureMode = Ndis802_11IBSS;
+	bssid.NetworkTypeInUse = Ndis802_11DS;
+	bssid.IELength = 0;
+
+	length = get_WLAN_BSSID_EX_sz(&bssid);
+	if (length % 4)
+		bssid.Length = ((length >> 2) + 1) << 2; //round up to multiple of 4 bytes.
+	else
+		bssid.Length = length;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		goto end_of_mp_start_test;
+
+	//init mp_start_test status
+	pmppriv->prev_fw_state = get_fwstate(pmlmepriv);
+	pmlmepriv->fw_state = WIFI_MP_STATE;
+
+	if (pmppriv->mode == _LOOPBOOK_MODE_) {
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); //append txdesc
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+start mp in Lookback mode\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+start mp in normal mode\n"));
+	}
+
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+	//3 2. create a new psta for mp driver
+	//clear psta in the cur_network, if any
+	psta = rtw_get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);
+	if (psta) rtw_free_stainfo(padapter, psta);
+
+	psta = rtw_alloc_stainfo(&padapter->stapriv, bssid.MacAddress);
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("mp_start_test: Can't alloc sta_info!\n"));
+		res = _FAIL;
+		goto end_of_mp_start_test;
+	}
+
+	//3 3. join psudo AdHoc
+	tgt_network->join_res = 1;
+	tgt_network->aid = psta->aid = 1;
+	_rtw_memcpy(&tgt_network->network, &bssid, length);
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	rtw_os_indicate_connect(padapter);
+	set_fwstate(pmlmepriv, _FW_LINKED); // Set to LINKED STATE for MP TRX Testing
+
+end_of_mp_start_test:
+
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+	return res;
+}
+//------------------------------------------------------------------------------
+//This function change the DUT from the MP test mode into normal mode
+int mp_stop_test(_adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct sta_info *psta;
+
+	_irqL irqL;
+
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE)
+		goto end_of_mp_stop_test;
+
+	//3 1. disconnect psudo AdHoc
+	rtw_indicate_disconnect(padapter);
+//	rtw_os_indicate_disconnect(padapter);
+
+	//3 2. clear psta used in mp test mode.
+//	rtw_free_assoc_resources(padapter);
+	psta = rtw_get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);
+	if (psta) rtw_free_stainfo(padapter, psta);
+
+	//3 3. return to normal state (default:station mode)
+	pmlmepriv->fw_state = pmppriv->prev_fw_state; // WIFI_STATION_STATE;
+
+	//flush the cur_network
+	_rtw_memset(tgt_network, 0, sizeof(struct wlan_network));
+
+end_of_mp_stop_test:
+
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+
+	return _SUCCESS;
+}
+//------------------------------------------------------------------------------
+int mp_start_joinbss(_adapter *padapter, NDIS_802_11_SSID *pssid)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = (struct wlan_network *)&pmppriv->mp_network;
+
+	unsigned char res = _SUCCESS;
+
+#if 1
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE)
+		return _FAIL;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+		return _FAIL;
+
+	_clr_fwstate_(pmlmepriv, _FW_LINKED);
+#else
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE))
+		pmlmepriv->fw_state ^= _FW_LINKED;
+	else
+		return _FAIL;
+#endif
+	res = rtw_setassocsta_cmd(padapter, pmppriv->network_macaddr);
+
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+#if 0
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = &mp_priv->mp_network;
+
+	unsigned char *dst_ssid, *src_ssid;
+	unsigned char res = _SUCCESS;
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
+		pmlmepriv->fw_state ^= _FW_LINKED;
+	else
+		return _FAIL;
+
+	_rtw_memcpy(&padapter->MgntInfo.ssid, pssid, sizeof(NDIS_802_11_SSID));
+	_rtw_memcpy(&pmlmepriv->assoc_ssid, pssid, sizeof(NDIS_802_11_SSID));
+
+	pmlmepriv->cur_network.join_res = -2;
+	pmlmepriv->fw_state |= _FW_UNDER_LINKING;
+
+	dst_ssid = pnetwork->network.Ssid.Ssid;
+	src_ssid = pmlmepriv->assoc_ssid.Ssid;
+	if (_rtw_memcmp(dst_ssid, src_ssid, pmlmepriv->assoc_ssid.SsidLength) == _FALSE)
+		return _FAIL;
+
+	res = rtw_joinbss_cmd((unsigned char*)padapter, pnetwork);
+
+	NdisMSetTimer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+#endif
+
+	return res;
+}
+
+//****************  oid_rtl_seg_81_80_00   section start ****************
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_data_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+//	unsigned char	datarates[NumRates];
+	u32		ratevalue;//4
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+oid_rt_pro_set_data_rate_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	ratevalue = *((u32*)poid_par_priv->information_buf);//4
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_set_data_rate_hdl: data rate idx=%d\n", ratevalue));
+	if (ratevalue >= MPT_RATE_LAST)
+		return NDIS_STATUS_INVALID_DATA;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+#if 0
+	for (i = 0; i< NumRates; i++)
+	{
+		if (ratevalue == mpdatarate[i]) {
+			datarates[i] = mpdatarate[i];
+		} else {
+			datarates[i] = 0xff;
+		}
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("datarate_inx=%d\n", datarates[i]));
+	}
+
+	if (rtw_setdatarate_cmd(Adapter, datarates) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+#else
+	Adapter->mppriv.curr_rateidx = ratevalue;
+	SetDataRate(Adapter);
+#endif
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_start_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		mode;
+	u8		val8;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_start_test_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return  NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	//IQCalibrateBcut(Adapter);
+
+	mode = *((u32*)poid_par_priv->information_buf);
+	Adapter->mppriv.mode = mode;// 1 for loopback
+
+	if (mp_start_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	rtw_write8(Adapter, MSR, 1); // Link in ad hoc network, 0x1025004C
+	rtw_write8(Adapter, RCR, 0); // RCR : disable all pkt, 0x10250048
+	rtw_write8(Adapter, RCR+2, 0x57); // RCR disable Check BSSID, 0x1025004a
+
+	//disable RX filter map , mgt frames will put in RX FIFO 0
+	rtw_write16(Adapter, RXFLTMAP0, 0x0); // 0x10250116
+
+	val8 = rtw_read8(Adapter, EE_9346CR); // 0x1025000A
+	if (!(val8 & _9356SEL))//boot from EFUSE
+	{
+		rtw_efuse_reg_init(Adapter);
+		rtw_efuse_get_max_size(Adapter);
+		rtw_efuse_reg_uninit(Adapter);
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-oid_rt_pro_start_test_hdl: rtw_mp_mode=%d\n", Adapter->mppriv.mode));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_stop_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Set OID_RT_PRO_STOP_TEST\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (mp_stop_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-Set OID_RT_PRO_STOP_TEST\n"));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		Channel;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_channel_direct_call_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	Channel = *((u32*)poid_par_priv->information_buf);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("oid_rt_pro_set_channel_direct_call_hdl: Channel=%d\n", Channel));
+	if (Channel > 14)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_ch = Channel;
+
+#if 0
+	if (rtw_setphy_cmd(Adapter, (unsigned char)Adapter->mppriv.curr_modem, (unsigned char)Channel) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+#else
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetChannel(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+#endif
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		antenna;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_antenna_bb_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	antenna = *((u32*)poid_par_priv->information_buf);
+
+	Adapter->mppriv.antenna_tx = (u16)((antenna & 0xFFFF0000) >> 16);
+	Adapter->mppriv.antenna_rx = (u16)(antenna & 0x0000FFFF);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("tx_ant=0x%04x rx_ant=0x%04x\n",
+		  Adapter->mppriv.antenna_tx, Adapter->mppriv.antenna_rx));
+
+	_irqlevel_changed_(&oldirql,LOWER);
+	SwitchAntenna(Adapter);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		tx_pwr_idx;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_pro_set_tx_power_control_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	tx_pwr_idx = *((u32*)poid_par_priv->information_buf);
+	if (tx_pwr_idx > MAX_TX_PWR_INDEX_N_MODE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_txpoweridx = (u8)tx_pwr_idx;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("oid_rt_pro_set_tx_power_control_hdl: idx=0x%2x\n",
+		  Adapter->mppriv.curr_txpoweridx));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetTxPower(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+//****************  oid_rtl_seg_81_80_20   section start ****************
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid !=QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		*(ULONG*)poid_par_priv->information_buf =  Adapter->mppriv.tx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("===> oid_rt_pro_query_rx_packet_received_hdl.\n"));
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		*(ULONG*)poid_par_priv->information_buf =  Adapter->mppriv.rx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("recv_ok:%d \n",Adapter->mppriv.rx_pktcount));
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("===> oid_rt_pro_query_rx_packet_crc32_error_hdl.\n"));
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		*(ULONG*)poid_par_priv->information_buf =  Adapter->mppriv.rx_crcerrpktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("recv_err:%d \n",Adapter->mppriv.rx_crcerrpktcount));
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+
+NDIS_STATUS oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("===> oid_rt_pro_reset_tx_packet_sent_hdl.\n"));
+	Adapter->mppriv.tx_pktcount = 0;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+	{
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	if (poid_par_priv->information_buf_len == sizeof(ULONG)) {
+		Adapter->mppriv.rx_pktcount = 0;
+		Adapter->mppriv.rx_crcerrpktcount = 0;
+	} else {
+		status = NDIS_STATUS_INVALID_LENGTH;
+	}
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL		oldirql;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	ResetPhyRxPktCount(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_get_phy_rx_packet_received_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len != sizeof(ULONG))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	*(ULONG*)poid_par_priv->information_buf = GetPhyRxPktReceived(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("-oid_rt_get_phy_rx_packet_received_hdl: recv_ok=%d\n", *(ULONG*)poid_par_priv->information_buf));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_get_phy_rx_packet_crc32_error_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+
+	if (poid_par_priv->information_buf_len != sizeof(ULONG))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	*(ULONG*)poid_par_priv->information_buf = GetPhyRxPktCRC32Error(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_get_phy_rx_packet_crc32_error_hdl: recv_err=%d\n", *(ULONG*)poid_par_priv->information_buf));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_modulation_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+OID_RT_PRO_SET_MODULATION\n"));
+	Adapter->mppriv.curr_modem = *((u8*)poid_par_priv->information_buf);
+
+_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_81_80_20   section end ****************
+NDIS_STATUS oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_continuous_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetContinuousTx(Adapter,(u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("+oid_rt_pro_set_single_carrier_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetSingleCarrierTx(Adapter, (u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_set_carrier_suppression_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetCarrierSuppressionTx(Adapter, (u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_trigger_gpio_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;	
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	rtl8192cu_trigger_gpio_0(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+NDIS_STATUS oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32 		bStartTest;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, ("+oid_rt_pro_set_single_tone_tx_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	bStartTest = *((u32*)poid_par_priv->information_buf);
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetSingleToneTx(Adapter,(u8)bStartTest);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_81_80_00   section end ****************
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro8711_join_bss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	PNDIS_802_11_SSID pssid;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = (u32)sizeof(NDIS_802_11_SSID);
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pssid = (PNDIS_802_11_SSID)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (mp_start_joinbss(Adapter, pssid) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = sizeof(NDIS_802_11_SSID);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pRW_Reg 	RegRWStruct;
+	u16		offset;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("+oid_rt_pro_read_register_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RegRWStruct = (pRW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF))
+	{
+		//baseband register
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;  	//0ffset :0x800~0xfff
+
+		RegRWStruct->value = bb_reg_read(Adapter ,offset);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			 ("oid_rt_pro_read_register_hdl: bb offset=0x%04x value=0x%x\n",
+			  offset, RegRWStruct->value));
+	}
+	else
+	{
+		switch (RegRWStruct->width)
+		{
+			case 1:
+				RegRWStruct->value = rtw_read8(Adapter, RegRWStruct->offset);
+				break;
+			case 2:
+				RegRWStruct->value = rtw_read16(Adapter, RegRWStruct->offset);
+				break;
+			case 4:
+				RegRWStruct->value = rtw_read32(Adapter, RegRWStruct->offset);
+				break;
+			default:
+				status = NDIS_STATUS_NOT_ACCEPTED;
+				break;
+		}
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			 ("oid_rt_pro_read_register_hdl: offset:0x%04x value:0x%x\n",
+			  RegRWStruct->offset, RegRWStruct->value));
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	//DEBUG_ERR(("\n <=== Query OID_RT_PRO_READ_REGISTER.
+	//	Add:0x%08x Width:%d Value:0x%08x\n",RegRWStruct->offset,RegRWStruct->width,RegRWStruct->value));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pRW_Reg 	RegRWStruct;
+	u16		offset;
+	u32		value;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("\n ===> Set OID_RT_PRO_WRITE_REGISTER.\n"));
+
+	RegRWStruct = (pRW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF))
+	{
+		//baseband register
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;  	//0ffset :0x800~0xfff
+		value = RegRWStruct->value;
+#if 1
+{
+		u32 oldValue = 0;
+		switch (RegRWStruct->width)
+		{
+			case 1:
+				oldValue = bb_reg_read(Adapter, offset);
+				oldValue &= 0xFFFFFF00;
+				value &= 0x000000FF;
+				value |= oldValue;
+				break;
+			case 2:
+				oldValue = bb_reg_read(Adapter, offset);
+				oldValue &= 0xFFFF0000;
+				value &= 0x0000FFFF;
+				value |= oldValue;
+				break;
+		}
+}
+#else
+// reduce IO access
+		if ( (RegRWStruct->width == 1) ||
+		     (RegRWStruct->width == 2) )
+		{
+			u32 oldValue = 0;
+			u8 shift = offset & 0x3;
+			u32 mask = 0x000000FF;
+
+			if (RegRWStruct->width == 2) {
+				mask = 0x0000FFFF;
+				if (shift == 3)
+					shift = 0;
+			}
+
+			if (shift != 0) {
+				mask <<= (shift * 8);
+				offset &= 0xFFC;
+			}
+
+			oldValue = bb_reg_read(Adapter, offset);
+			oldValue &= ~mask;
+			value = (value << (shift * 8)) & mask;
+			value |= oldValue;
+		}
+#endif
+		bb_reg_write(Adapter, offset, value);
+	}
+	else
+	{
+		switch (RegRWStruct->width)
+		{
+			case 1:
+				rtw_write8(Adapter, RegRWStruct->offset, (unsigned char)RegRWStruct->value);
+				break;
+			case 2:
+				rtw_write16(Adapter, RegRWStruct->offset, (unsigned short)RegRWStruct->value);
+				break;
+			case 4:
+				rtw_write32(Adapter, RegRWStruct->offset, (unsigned int)RegRWStruct->value);
+				break;
+			default:
+				status = NDIS_STATUS_NOT_ACCEPTED;
+				break;
+		}
+
+		//Henry: for maintain the correct HIMR status
+		if ((status == NDIS_STATUS_SUCCESS) &&
+		    (RegRWStruct->offset == HIMR) &&
+		    (RegRWStruct->width == 4))
+			Adapter->ImrContent=RegRWStruct->value;
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("\n <=== Set OID_RT_PRO_WRITE_REGISTER.offset:0x%08x value0x%x\n",RegRWStruct->offset,RegRWStruct->value));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_burst_read_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pBurst_RW_Reg	pBstRwReg;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_burst_read_register_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pBstRwReg = (pBurst_RW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	rtw_read_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len, pBstRwReg->Data);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_pro_burst_read_register_hdl\n"));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_burst_write_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pBurst_RW_Reg	pBstRwReg;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_burst_write_register_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pBstRwReg = (pBurst_RW_Reg)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	rtw_write_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len, pBstRwReg->Data);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_pro_burst_write_register_hdl\n"));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+/*
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+
+	TX_CMD_Desc	*TxCmd_Info;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+Set OID_RT_PRO_WRITE_TXCMD\n"));
+
+	TxCmd_Info=(TX_CMD_Desc*)poid_par_priv->information_buf;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:Addr=%.8X\n", TxCmd_Info->offset));
+  	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:1.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[0]));
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:2.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[1]));
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, (("WRITE_TXCMD:3.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[2]));
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("WRITE_TXCMD:4.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[3]));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	rtw_write32(Adapter, TxCmd_Info->offset + 0, (unsigned int)TxCmd_Info->TxCMD.value[0]);
+	rtw_write32(Adapter, TxCmd_Info->offset + 4, (unsigned int)TxCmd_Info->TxCMD.value[1]);
+
+	_irqlevel_changed_(&oldirql, RAISE);
+*/
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-Set OID_RT_PRO_WRITE_TXCMD: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pEEPROM_RWParam pEEPROM;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+Query OID_RT_PRO_READ16_EEPROM\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pEEPROM = (pEEPROM_RWParam)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	pEEPROM->value = eeprom_read16(Adapter, (u16)(pEEPROM->offset >> 1));
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_,  _drv_notice_,
+		 ("-Query OID_RT_PRO_READ16_EEPROM: offset=0x%x value=0x%x\n",
+		  pEEPROM->offset, pEEPROM->value));
+
+_func_exit_;
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write16_eeprom_hdl (struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	pEEPROM_RWParam pEEPROM;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Set OID_RT_PRO_WRITE16_EEPROM\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pEEPROM = (pEEPROM_RWParam)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	eeprom_write16(Adapter, (u16)(pEEPROM->offset >> 1), pEEPROM->value);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	struct mp_wiparam *pwi_param;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(struct mp_wiparam))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	if (Adapter->mppriv.workparam.bcompleted == _FALSE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pwi_param = (struct mp_wiparam *)poid_par_priv->information_buf;
+
+	_rtw_memcpy(pwi_param, &Adapter->mppriv.workparam, sizeof(struct mp_wiparam));
+	Adapter->mppriv.act_in_progress = _FALSE;
+//	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("rf:%x\n", pwiparam->IoValue));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro8711_pkt_loss_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(uint)*2) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("-oid_rt_pro8711_pkt_loss_hdl: buf_len=%d\n", (int)poid_par_priv->information_buf_len));
+		return NDIS_STATUS_INVALID_LENGTH;
+	}
+
+	if (*(uint*)poid_par_priv->information_buf == 1)//init==1
+		Adapter->mppriv.rx_pktloss = 0;
+
+	*((uint*)poid_par_priv->information_buf+1) = Adapter->mppriv.rx_pktloss;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_rd_attrib_mem_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)( poid_par_priv->adapter_context);
+	struct io_queue *pio_queue = (struct io_queue *)Adapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &pio_queue->intf;
+
+	_irqL	oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+#ifdef CONFIG_SDIO_HCI
+	void (*_attrib_read)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+#endif
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Query OID_RT_RD_ATTRIB_MEM\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+#ifdef CONFIG_SDIO_HCI
+	_irqlevel_changed_(&oldirql, LOWER);
+{
+	u32 *plmem = (u32*)poid_par_priv->information_buf+2;
+	_attrib_read = pintfhdl->io_ops._attrib_read;
+	_attrib_read(pintfhdl, *((u32*)poid_par_priv->information_buf),
+				*((u32*)poid_par_priv->information_buf+1), (u8*)plmem);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+}
+	_irqlevel_changed_(&oldirql, RAISE);
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_wr_attrib_mem_hdl (struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct io_queue *pio_queue = (struct io_queue *)Adapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &pio_queue->intf;
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+#ifdef CONFIG_SDIO_HCI
+	void (*_attrib_write)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+#endif
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+#ifdef CONFIG_SDIO_HCI
+	_irqlevel_changed_(&oldirql, LOWER);
+{
+	u32 *plmem = (u32*)poid_par_priv->information_buf + 2;
+	_attrib_write = pintfhdl->io_ops._attrib_write;
+	_attrib_write(pintfhdl, *(u32*)poid_par_priv->information_buf,
+				*((u32*)poid_par_priv->information_buf+1), (u8*)plmem);
+}
+	_irqlevel_changed_(&oldirql, RAISE);
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+OID_RT_PRO_SET_RF_INTFS\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (rtw_setrfintfs_cmd(Adapter, *(unsigned char*)poid_par_priv->information_buf) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_poll_rx_status_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_rtw_memcpy(poid_par_priv->information_buf, (unsigned char*)&Adapter->mppriv.rxstat, sizeof(struct recv_stat));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	PCFG_DBG_MSG_STRUCT pdbg_msg;
+
+_func_enter_;
+
+//	RT_TRACE(0xffffffffff,_drv_alert_,("===> oid_rt_pro_cfg_debug_message_hdl.\n"));
+
+#if 0//#ifdef CONFIG_DEBUG_RTL871X
+
+	pdbg_msg = (PCFG_DBG_MSG_STRUCT)(poid_par_priv->information_buf);
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		RT_TRACE(0xffffffffff, _drv_alert_,
+			 ("===>Set level :0x%08x, H32:0x%08x L32:0x%08x\n",
+			  pdbg_msg->DebugLevel, pdbg_msg->DebugComponent_H32, pdbg_msg->DebugComponent_L32));
+
+		GlobalDebugLevel = pdbg_msg->DebugLevel;
+		GlobalDebugComponents = (pdbg_msg->DebugComponent_H32 << 32) | pdbg_msg->DebugComponent_L32;
+		RT_TRACE(0xffffffffff, _drv_alert_,
+			 ("===> Set level :0x%08x, component:0x%016x\n",
+			  GlobalDebugLevel, (u32)GlobalDebugComponents));
+	} else {
+		pdbg_msg->DebugLevel = GlobalDebugLevel;
+		pdbg_msg->DebugComponent_H32 = (u32)(GlobalDebugComponents >> 32);
+		pdbg_msg->DebugComponent_L32 = (u32)GlobalDebugComponents;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+		RT_TRACE(0xffffffffff, _drv_alert_,
+			 ("===>Query level:0x%08x H32:0x%08x L32:0x%08x\n",
+			  (u32)pdbg_msg->DebugLevel, (u32)pdbg_msg->DebugComponent_H32, (u32)pdbg_msg->DebugComponent_L32));
+	}
+
+#endif
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+OID_RT_PRO_SET_DATA_RATE_EX\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (rtw_setdatarate_cmd(Adapter, poid_par_priv->information_buf) !=_SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_thermal_meter_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_get_thermal_meter_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (Adapter->mppriv.act_in_progress == _TRUE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	//init workparam
+	Adapter->mppriv.act_in_progress = _TRUE;
+	Adapter->mppriv.workparam.bcompleted = _FALSE;
+	Adapter->mppriv.workparam.act_type = MPT_GET_THERMAL_METER;
+	Adapter->mppriv.workparam.io_offset = 0;
+	Adapter->mppriv.workparam.io_value = 0xFFFFFFFF;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	GetThermalMeter(Adapter, &Adapter->mppriv.workparam.io_value);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+	Adapter->mppriv.workparam.bcompleted = _TRUE;
+	Adapter->mppriv.act_in_progress = _FALSE;
+
+	*(u32*)poid_par_priv->information_buf = Adapter->mppriv.workparam.io_value;
+	*poid_par_priv->bytes_rw = sizeof(u32);
+
+_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_tssi_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_read_tssi_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (Adapter->mppriv.act_in_progress == _TRUE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	//init workparam
+	Adapter->mppriv.act_in_progress = _TRUE;
+	Adapter->mppriv.workparam.bcompleted = _FALSE;
+	Adapter->mppriv.workparam.act_type = MPT_READ_TSSI;
+	Adapter->mppriv.workparam.io_offset = 0;
+	Adapter->mppriv.workparam.io_value = 0xFFFFFFFF;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (!rtw_gettssi_cmd(Adapter,0, (u8*)&Adapter->mppriv.workparam.io_value))
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+oid_rt_pro_set_power_tracking_hdl: type=0x%02x\n",
+		  *((u8*)poid_par_priv->information_buf )));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (!rtw_setptm_cmd(Adapter,*((u8*)poid_par_priv->information_buf )))
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//-----------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32 ratevalue;
+	u8 datarates[NumRates];
+	int i;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+OID_RT_PRO_SET_BASIC_RATE\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	ratevalue = *((u32*)poid_par_priv->information_buf);
+
+	for (i = 0; i < NumRates; i++) {
+		if (ratevalue == mpdatarate[i])
+			datarates[i] = mpdatarate[i];
+		else
+			datarates[i] = 0xff;
+		RT_TRACE(_module_rtl871x_ioctl_c_, _drv_info_, ("basicrate_inx=%d\n", datarates[i]));
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (rtw_setbasicrate_cmd(Adapter, datarates) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-OID_RT_PRO_SET_BASIC_RATE: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	uint pwr_mode, smart_ps;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Set OID_RT_PRO_SET_PWRSTATE\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	struct setratable_parm *prate_table;
+	u8		res;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed  = sizeof(struct setratable_parm);
+	if (poid_par_priv->information_buf_len < sizeof(struct setratable_parm))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	prate_table = (struct setratable_parm*)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	res = rtw_setrttbl_cmd(Adapter, prate_table);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	if (res == _FAIL)
+		status = NDIS_STATUS_FAILURE;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	#if 0
+			struct mp_wi_cntx *pmp_wi_cntx=&(Adapter->mppriv.wi_cntx);
+			u8 res=_SUCCESS;
+			DEBUG_INFO(("===> Set OID_RT_PRO_H2C_GET_RATE_TABLE.\n"));
+
+			if(pmp_wi_cntx->bmp_wi_progress ==_TRUE){
+				DEBUG_ERR(("\n mp workitem is progressing, not allow to set another workitem right now!!!\n"));
+				Status = NDIS_STATUS_NOT_ACCEPTED;
+				break;
+			}
+			else{
+				pmp_wi_cntx->bmp_wi_progress=_TRUE;
+				pmp_wi_cntx->param.bcompleted=_FALSE;
+				pmp_wi_cntx->param.act_type=MPT_GET_RATE_TABLE;
+				pmp_wi_cntx->param.io_offset=0x0;
+				pmp_wi_cntx->param.bytes_cnt=sizeof(struct getratable_rsp);
+				pmp_wi_cntx->param.io_value=0xffffffff;
+
+				res=rtw_getrttbl_cmd(Adapter,(struct getratable_rsp *)pmp_wi_cntx->param.data);
+				*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+				if(res != _SUCCESS)
+				{
+					Status = NDIS_STATUS_NOT_ACCEPTED;
+				}
+			}
+			DEBUG_INFO(("\n <=== Set OID_RT_PRO_H2C_GET_RATE_TABLE.\n"));
+	#endif
+
+_func_exit_;
+
+	return status;
+}
+
+//****************  oid_rtl_seg_87_12_00   section start ****************
+NDIS_STATUS oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	ENCRY_CTRL_STATE encry_mode;
+
+
+	*poid_par_priv->bytes_needed = sizeof(u8);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	if (poid_par_priv->type_of_oid == SET_OID)
+	{
+		encry_mode = *((u8*)poid_par_priv->information_buf);
+		switch (encry_mode)
+		{
+			case HW_CONTROL:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_FALSE;
+				Adapter->registrypriv.software_encrypt=_FALSE;
+				#else
+				psecuritypriv->sw_decrypt = _FALSE;
+				psecuritypriv->sw_encrypt = _FALSE;
+				#endif
+				break;
+			case SW_CONTROL:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_TRUE;
+				Adapter->registrypriv.software_encrypt=_TRUE;
+				#else
+				psecuritypriv->sw_decrypt = _TRUE;
+				psecuritypriv->sw_encrypt = _TRUE;
+				#endif
+				break;
+			case HW_ENCRY_SW_DECRY:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_TRUE;
+				Adapter->registrypriv.software_encrypt=_FALSE;
+				#else
+				psecuritypriv->sw_decrypt = _TRUE;
+				psecuritypriv->sw_encrypt = _FALSE;
+				#endif
+				break;
+			case SW_ENCRY_HW_DECRY:
+				#if 0
+				Adapter->registrypriv.software_decrypt=_FALSE;
+				Adapter->registrypriv.software_encrypt=_TRUE;
+				#else
+				psecuritypriv->sw_decrypt = _FALSE;
+				psecuritypriv->sw_encrypt = _TRUE;
+				#endif
+				break;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_c_, _drv_notice_,
+			 ("-oid_rt_pro_encryption_ctrl_hdl: SET encry_mode=0x%x sw_encrypt=0x%x sw_decrypt=0x%x\n",
+			  encry_mode, psecuritypriv->sw_encrypt, psecuritypriv->sw_decrypt));
+	}
+	else {
+		#if 0
+		if (Adapter->registrypriv.software_encrypt == _FALSE) {
+			if (Adapter->registrypriv.software_decrypt == _FALSE)
+				encry_mode = HW_CONTROL;
+			else
+				encry_mode = HW_ENCRY_SW_DECRY;
+		}
+		else {
+			if (Adapter->registrypriv.software_decrypt == _FALSE)
+				encry_mode = SW_ENCRY_HW_DECRY;
+			else
+				encry_mode = SW_CONTROL;
+		}
+		#else
+
+		if ((psecuritypriv->sw_encrypt == _FALSE) && (psecuritypriv->sw_decrypt == _FALSE))
+			encry_mode = HW_CONTROL;
+		else if ((psecuritypriv->sw_encrypt == _FALSE) && (psecuritypriv->sw_decrypt == _TRUE))
+			encry_mode = HW_ENCRY_SW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == _TRUE) && (psecuritypriv->sw_decrypt == _FALSE))
+			encry_mode = SW_ENCRY_HW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == _TRUE) && (psecuritypriv->sw_decrypt == _TRUE))
+			encry_mode = SW_CONTROL;
+
+		#endif
+
+		*(u8*)poid_par_priv->information_buf =  encry_mode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			 ("-oid_rt_pro_encryption_ctrl_hdl: QUERY encry_mode=0x%x\n",
+			  encry_mode));
+	}
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_add_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL			oldirql;
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info 	*psta = NULL;
+	UCHAR 			*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	macaddr = (UCHAR *) poid_par_priv->information_buf ;
+
+	RT_TRACE(_module_rtl871x_ioctl_c_,_drv_notice_,
+		 ("OID_RT_PRO_ADD_STA_INFO: addr=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  macaddr[0],macaddr[1],macaddr[2],macaddr[3],macaddr[4],macaddr[5]));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	psta = rtw_get_stainfo(&Adapter->stapriv, macaddr);
+
+	if (psta == NULL) { // the sta have been in sta_info_queue => do nothing
+		psta = rtw_alloc_stainfo(&Adapter->stapriv, macaddr);
+
+		if (psta == NULL) {
+			RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("Can't alloc sta_info when OID_RT_PRO_ADD_STA_INFO\n"));
+			status = NDIS_STATUS_FAILURE;
+		}
+	} else { //(between drv has received this event before and  fw have not yet to set key to CAM_ENTRY)
+		RT_TRACE(_module_rtl871x_ioctl_c_, _drv_err_,
+			("Error: OID_RT_PRO_ADD_STA_INFO: sta has been in sta_hash_queue \n"));
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL			irqL;
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info 	*psta = NULL;
+	UCHAR			*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	macaddr = (UCHAR *) poid_par_priv->information_buf ;
+	RT_TRACE(_module_rtl871x_ioctl_c_,_drv_notice_,
+		 ("+OID_RT_PRO_ADD_STA_INFO: addr=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		  macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]));
+
+	psta = rtw_get_stainfo(&Adapter->stapriv, macaddr);
+	if (psta != NULL) {
+		_enter_critical_bh(&(Adapter->stapriv.sta_hash_lock), &irqL);
+		rtw_free_stainfo(Adapter, psta);
+		_exit_critical_bh(&(Adapter->stapriv.sta_hash_lock), &irqL);
+	}
+
+	return status;
+}
+//------------------------------------------------------------------------------
+#include <sdio_osintf.h>
+u32 mp_query_drv_var(_adapter *padapter, u8 offset, u32 var)
+{
+#ifdef CONFIG_SDIO_HCI
+
+	if (offset == 1) {
+		u16 tmp_blk_num;
+		tmp_blk_num = rtw_read16(padapter, SDIO_RX0_RDYBLK_NUM);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("Query Information, mp_query_drv_var  SDIO_RX0_RDYBLK_NUM=0x%x   padapter->dvobjpriv.rxblknum=0x%x\n", tmp_blk_num, padapter->dvobjpriv.rxblknum));
+		if (padapter->dvobjpriv.rxblknum != tmp_blk_num) {
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_, ("Query Information, mp_query_drv_var  call recv rx\n"));
+		//	sd_recv_rxfifo(padapter);
+		}
+	}
+
+#if 0
+	if(offset <=100){  //For setting data rate and query data rate
+		if(offset==100){ //For query data rate
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d): query rate=0x%.2x \n",offset,padapter->registrypriv.tx_rate));
+			var=padapter->registrypriv.tx_rate;
+
+		}
+		else if(offset<0x1d){  //For setting data rate
+			padapter->registrypriv.tx_rate=offset;
+			var=padapter->registrypriv.tx_rate;
+			padapter->registrypriv.use_rate=_TRUE;
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d): set rate=0x%.2x \n",offset,padapter->registrypriv.tx_rate));
+		}
+		else{ //not use the data rate
+			padapter->registrypriv.use_rate=_FALSE;
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d) out of rate range\n",offset));
+		}
+	}
+	else if (offset<=110){  //for setting debug level
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var: offset(%d) for set debug level\n",offset));
+		if(offset==110){ //For query data rate
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var: offset(%d): query dbg level=0x%.2x \n",offset,padapter->registrypriv.dbg_level));
+			padapter->registrypriv.dbg_level=GlobalDebugLevel;
+			var=padapter->registrypriv.dbg_level;
+		}
+		else if(offset<110 && offset>100){
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var: offset(%d): set dbg level=0x%.2x \n",offset,offset-100));
+			padapter->registrypriv.dbg_level=GlobalDebugLevel=offset-100;
+			var=padapter->registrypriv.dbg_level;
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var(_drv_emerg_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_alert_, (" mp_query_drv_var(_drv_alert_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_crit_, (" mp_query_drv_var(_drv_crit_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, (" mp_query_drv_var(_drv_err_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_warning_, (" mp_query_drv_var(_drv_warning_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, (" mp_query_drv_var(_drv_notice_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, (" mp_query_drv_var(_drv_info_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_debug_, (" mp_query_drv_var(_drv_debug_): offset(%d): set dbg level=0x%.2x \n",offset,GlobalDebugLevel));
+
+		}
+	}
+	else if(offset >110 &&offset <116){
+		if(115==offset){
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" mp_query_drv_var(_drv_emerg_): offset(%d): query TRX access type: [tx_block_mode=%x,rx_block_mode=%x]\n",\
+															offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+		}
+		else {
+			switch(offset){
+				case 111:
+					padapter->dvobjpriv.tx_block_mode=1;
+					padapter->dvobjpriv.rx_block_mode=1;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX block/RX block) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				case 112:
+					padapter->dvobjpriv.tx_block_mode=1;
+					padapter->dvobjpriv.rx_block_mode=0;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX block/RX byte) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				case 113:
+					padapter->dvobjpriv.tx_block_mode=0;
+					padapter->dvobjpriv.rx_block_mode=1;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX byte/RX block) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				case 114:
+					padapter->dvobjpriv.tx_block_mode=0;
+					padapter->dvobjpriv.rx_block_mode=0;
+					RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, \
+						(" mp_query_drv_var(_drv_emerg_): offset(%d): SET TRX access type:(TX byte/RX byte) [tx_block_mode=%x,rx_block_mode=%x]\n",\
+						offset,padapter->dvobjpriv.tx_block_mode,padapter->dvobjpriv.rx_block_mode));
+					break;
+				default :
+					break;
+
+			}
+
+		}
+
+	}
+	else if(offset>=127){
+		u64	prnt_dbg_comp;
+		u8   chg_idx;
+		u64	tmp_dbg_comp;
+		chg_idx=offset-0x80;
+		tmp_dbg_comp=BIT(chg_idx);
+		prnt_dbg_comp=padapter->registrypriv.dbg_component= GlobalDebugComponents;
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, (" 1: mp_query_drv_var: offset(%d;0x%x):for dbg conpoment prnt_dbg_comp=0x%.16x GlobalDebugComponents=0x%.16x padapter->registrypriv.dbg_component=0x%.16x\n",offset,offset,prnt_dbg_comp,GlobalDebugComponents,padapter->registrypriv.dbg_component));
+		if(offset==127){
+	//		prnt_dbg_comp=padapter->registrypriv.dbg_component= GlobalDebugComponents;
+			var=(u32)(padapter->registrypriv.dbg_component);
+			RT_TRACE(0xffffffff, _drv_emerg_, ("2: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h) \n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+			prnt_dbg_comp=GlobalDebugComponents;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("2-1: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h)\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+			prnt_dbg_comp=GlobalDebugComponents=padapter->registrypriv.dbg_component;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("2-2: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h)\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+
+		}
+		else{
+			RT_TRACE(0xffffffff, _drv_emerg_, ("3: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h) GlobalDebugComponents=0x%x(l) 0x%x(h) chg_idx=%d\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp,chg_idx));
+			prnt_dbg_comp=GlobalDebugComponents;
+			RT_TRACE(0xffffffff, _drv_emerg_,("3-1: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h) chg_idx=%d\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp,chg_idx));// ("3-1: mp_query_drv_var: offset(%d;0x%x):before set dbg conpoment=0x%x chg_idx=%d or0x%x BIT(chg_idx[%d]=0x%x)\n",offset,offset,prnt_dbg_comp,chg_idx,chg_idx,(chg_idx),tmp_dbg_comp)
+			prnt_dbg_comp=GlobalDebugComponents=padapter->registrypriv.dbg_component;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("3-2: mp_query_drv_var: offset(%d;0x%x):for query dbg conpoment=0x%x(l) 0x%x(h)  GlobalDebugComponents=0x%x(l) 0x%x(h)\n",offset,offset,padapter->registrypriv.dbg_component,prnt_dbg_comp));
+
+			if(GlobalDebugComponents&tmp_dbg_comp){
+				//this bit is already set, now clear it
+				GlobalDebugComponents=GlobalDebugComponents&(~tmp_dbg_comp);
+			}
+			else{
+				//this bit is not set, now set it.
+				GlobalDebugComponents =GlobalDebugComponents|tmp_dbg_comp;
+			}
+			RT_TRACE(0xffffffff, _drv_emerg_, ("4: mp_query_drv_var: offset(%d;0x%x):before set dbg conpoment tmp_dbg_comp=0x%x GlobalDebugComponents=0x%x(l) 0x%x(h)",offset,offset,tmp_dbg_comp,prnt_dbg_comp));
+			prnt_dbg_comp=GlobalDebugComponents;
+			RT_TRACE(0xffffffff, _drv_emerg_, ("4-1: mp_query_drv_var: offset(%d;0x%x):before set dbg conpoment tmp_dbg_comp=0x%x GlobalDebugComponents=0x%x(l) 0x%x(h)",offset,offset,tmp_dbg_comp,prnt_dbg_comp));
+
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_emerg_, ("0: mp_query_drv_var(_module_rtl871x_xmit_c_:0): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,prnt_dbg_comp));
+			RT_TRACE(_module_xmit_osdep_c_, _drv_emerg_, ("1: mp_query_drv_var(_module_xmit_osdep_c_:1): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_emerg_, ("2: mp_query_drv_var(_module_rtl871x_recv_c_:2): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_recv_osdep_c_, _drv_emerg_, ("3: mp_query_drv_var(_module_recv_osdep_c_:3): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_emerg_, ("4: mp_query_drv_var(_module_rtl871x_mlme_c_:4): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_mlme_osdep_c_, _drv_emerg_, (" 5:mp_query_drv_var(_module_mlme_osdep_c_:5): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_emerg_, ("6: mp_query_drv_var(_module_rtl871x_sta_mgt_c_:6): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_cmd_c_, _drv_emerg_, ("7: mp_query_drv_var(_module_rtl871x_cmd_c_:7): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_cmd_osdep_c_, _drv_emerg_, ("8: mp_query_drv_var(_module_cmd_osdep_c_:8): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_io_c_, _drv_emerg_, ("9: mp_query_drv_var(_module_rtl871x_io_c_:9): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_io_osdep_c_, _drv_emerg_, ("10: mp_query_drv_var(_module_io_osdep_c_:10): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_os_intfs_c_, _drv_emerg_, ("11: mp_query_drv_var(_module_os_intfs_c_:11): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_security_c_, _drv_emerg_, ("12: mp_query_drv_var(_module_rtl871x_security_c_:12): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_eeprom_c_, _drv_emerg_, ("13: mp_query_drv_var(_module_rtl871x_eeprom_c_:13): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hal_init_c_, _drv_emerg_, ("14: mp_query_drv_var(_module_hal_init_c_:14): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_hal_init_c_, _drv_emerg_, ("15: mp_query_drv_var(_module_hci_hal_init_c_:15): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_ioctl_c_, _drv_emerg_, ("16: mp_query_drv_var(_module_rtl871x_ioctl_c_:16): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_emerg_, ("17: mp_query_drv_var(_module_rtl871x_ioctl_set_c_:17): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_ioctl_query_c_, _drv_emerg_, ("18: mp_query_drv_var(_module_rtl871x_ioctl_query_c_:18): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_emerg_, ("19: mp_query_drv_var(_module_rtl871x_pwrctrl_c_:19): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_intfs_c_, _drv_emerg_, ("20: mp_query_drv_var(_module_hci_intfs_c_:20): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_ops_c_, _drv_emerg_, ("21: mp_query_drv_var(_module_hci_ops_c_:21): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_osdep_service_c_, _drv_emerg_, ("22: mp_query_drv_var(_module_osdep_service_c_:22): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("23: mp_query_drv_var(_module_rtl871x_mp_ioctl_c_:23): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			RT_TRACE(_module_hci_ops_os_c_, _drv_emerg_, ("24: mp_query_drv_var(_module_hci_ops_os_c_:24): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+			var=(u32)(GlobalDebugComponents);
+			//GlobalDebugComponents=padapter->registrypriv.dbg_component;
+			RT_TRACE(0xffffffff, _drv_emerg_, (" ==mp_query_drv_var(_module_rtl871x_mp_ioctl_c_): offset(%d;0x%x):before set dbg conpoment=0x%x(l) 0x%x(h)\n",offset,offset,GlobalDebugComponents));
+
+		}
+	}
+	else{
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_, ("\n mp_query_drv_var: offset(%d) >110\n",offset));
+	}
+#endif
+#endif
+
+	return var;
+}
+
+NDIS_STATUS oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL oldirql;
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+
+	DR_VARIABLE_STRUCT *pdrv_var;
+
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = sizeof(DR_VARIABLE_STRUCT);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+Query Information, OID_RT_PRO_QUERY_DR_VARIABLE\n"));
+
+	pdrv_var = (struct _DR_VARIABLE_STRUCT_ *)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	pdrv_var->variable = mp_query_drv_var(Adapter, pdrv_var->offset, pdrv_var->variable);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("-oid_rt_pro_query_dr_variable_hdl: offset=0x%x valule=0x%x\n",
+		  pdrv_var->offset, pdrv_var->variable));
+
+	return status;
+}
+
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("oid_rt_pro_rx_packet_type_hdl...................\n"));
+#if 0
+
+	if (poid_par_priv->information_buf_len < sizeof (UCHAR)) {
+		status = NDIS_STATUS_INVALID_LENGTH;
+		*poid_par_priv->bytes_needed = sizeof(UCHAR);
+		return status;
+	}
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		Adapter->mppriv.rx_with_status = *(UCHAR *) poid_par_priv->information_buf;
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_, ("Query Information, OID_RT_PRO_RX_PACKET_TYPE:%d \n",\
+												Adapter->mppriv.rx_with_status));
+
+		//*(u32 *)&Adapter->eeprompriv.mac_addr[0]=rtw_read32(Adapter, 0x10250050);
+		//*(u16 *)&Adapter->eeprompriv.mac_addr[4]=rtw_read16(Adapter, 0x10250054);
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("MAC addr=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x  \n",
+			Adapter->eeprompriv.mac_addr[0],Adapter->eeprompriv.mac_addr[1],Adapter->eeprompriv.mac_addr[2],\
+			Adapter->eeprompriv.mac_addr[3],Adapter->eeprompriv.mac_addr[4],Adapter->eeprompriv.mac_addr[5]));
+
+	}
+	else {
+		*(UCHAR *) poid_par_priv->information_buf = Adapter->mppriv.rx_with_status;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_, ("Query Information, OID_RT_PRO_RX_PACKET_TYPE:%d \n", \
+												Adapter->mppriv.rx_with_status));
+
+		//*(u32 *)&Adapter->eeprompriv.mac_addr[0]=rtw_read32(Adapter, 0x10250050);
+		//*(u16 *)&Adapter->eeprompriv.mac_addr[4]=rtw_read16(Adapter, 0x10250054);
+		RT_TRACE(_module_rtl871x_ioctl_c_,_drv_err_,("MAC addr=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x  \n",
+			Adapter->eeprompriv.mac_addr[0],Adapter->eeprompriv.mac_addr[1],Adapter->eeprompriv.mac_addr[2],\
+			Adapter->eeprompriv.mac_addr[3],Adapter->eeprompriv.mac_addr[4],Adapter->eeprompriv.mac_addr[5]));
+	}
+#endif
+
+	return NDIS_STATUS_SUCCESS;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL oldirql;
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+
+	PEFUSE_ACCESS_STRUCT pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+#if 0
+	u16 i;
+#endif
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(EFUSE_ACCESS_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	pefuse = (PEFUSE_ACCESS_STRUCT)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+
+	_rtw_memset(data, 0xFF, cnts);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		("+oid_rt_pro_read_efuse_hd: buf_len=%ld addr=0x%04x cnts=%d\n",
+		 poid_par_priv->information_buf_len, addr, cnts));
+
+	if ((addr>511) || (cnts<1) || (cnts>512) || (addr+cnts)>EFUSE_MAX_PHYSICAL_SIZE) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("!oid_rt_pro_read_efuse_hdl: parameter error\n"));
+		return NDIS_STATUS_NOT_ACCEPTED;
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	if (rtw_efuse_access(Adapter, _TRUE, addr, cnts, data) == _FALSE)
+		status = NDIS_STATUS_FAILURE;
+	_irqlevel_changed_(&oldirql, RAISE);
+
+#if 0
+	for (i = 0; i < cnts; i++) {
+		*((UCHAR *)poid_par_priv->information_buf+3+i) = tmpdata[i];
+//		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====> Read Efuse returen [ addr =0x%x, value=0x%x ] =====\n", start_addr+i,tmpdata[i]));
+	}
+#endif
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL oldirql;
+	NDIS_STATUS status = NDIS_STATUS_SUCCESS;
+
+	PEFUSE_ACCESS_STRUCT pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pefuse = (PEFUSE_ACCESS_STRUCT)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+		 ("+oid_rt_pro_write_efuse_hdl: buf_len=%ld addr=0x%04x cnts=%d\n",
+		  poid_par_priv->information_buf_len, addr, cnts));
+
+	if ((addr>511) || (cnts<1) || (cnts>512) || (addr+cnts)>rtw_efuse_get_max_size(Adapter)) {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_, ("!oid_rt_pro_write_efuse_hdl: parameter error"));
+		return NDIS_STATUS_NOT_ACCEPTED;
+	}
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	if (rtw_efuse_access(Adapter, _FALSE, addr, cnts, data) == _FALSE)
+		status = NDIS_STATUS_FAILURE;
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	PPGPKT_STRUCT	ppgpkt;
+	u8		tmpidx;
+
+_func_enter_;
+
+//	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_pro_rw_efuse_pgpkt_hdl\n"));
+
+	*poid_par_priv->bytes_rw = 0;
+
+	if (poid_par_priv->information_buf_len < sizeof(PGPKT_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	ppgpkt = (PPGPKT_STRUCT)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+	{
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			("oid_rt_pro_rw_efuse_pgpkt_hdl: Read offset=0x%x\n",\
+			ppgpkt->offset));
+
+		if (rtw_efuse_pg_packet_read(Adapter, ppgpkt->offset, ppgpkt->data) == _TRUE)
+			*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		else
+			status = NDIS_STATUS_FAILURE;
+	} else {
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_,
+			("oid_rt_pro_rw_efuse_pgpkt_hdl: Write offset=0x%x word_en=0x%x\n",\
+			ppgpkt->offset, ppgpkt->word_en));
+
+		if (rtw_efuse_reg_init(Adapter) == _TRUE) {
+			if (rtw_efuse_pg_packet_write(Adapter, ppgpkt->offset, ppgpkt->word_en, ppgpkt->data) == _TRUE)
+				*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+			else
+				status = NDIS_STATUS_FAILURE;
+			rtw_efuse_reg_uninit(Adapter);
+		} else
+			status = NDIS_STATUS_FAILURE;
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("-oid_rt_pro_rw_efuse_pgpkt_hdl: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_efuse_current_size_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len <sizeof(int))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	rtw_efuse_reg_init(Adapter);
+	*(int*)poid_par_priv->information_buf = rtw_efuse_get_current_phy_size(Adapter);
+	rtw_efuse_reg_uninit(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_efuse_max_size_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	*(int*)poid_par_priv->information_buf = rtw_efuse_get_max_size(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("-oid_rt_get_efuse_max_size_hdl: size=%d status=%d\n",
+		  *(int*)poid_par_priv->information_buf, status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("+oid_rt_pro_efuse_hdl\n"));
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+		status = oid_rt_pro_read_efuse_hdl(poid_par_priv);
+	else
+		status = oid_rt_pro_write_efuse_hdl(poid_par_priv);
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_pro_efuse_hdl: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u8		*data;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_pro_efuse_map_hdl\n"));
+
+	*poid_par_priv->bytes_rw = 0;
+
+	if (poid_par_priv->information_buf_len < EFUSE_MAX_LOGICAL_SIZE)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	data = (u8*)poid_par_priv->information_buf;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+	{
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+			("oid_rt_pro_efuse_map_hdl: READ\n"));
+
+		if (rtw_efuse_map_read(Adapter, 0, EFUSE_MAX_LOGICAL_SIZE, data) == _TRUE)
+			*poid_par_priv->bytes_rw = EFUSE_MAX_LOGICAL_SIZE;
+		else {
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_,
+				("oid_rt_pro_efuse_map_hdl: READ fail\n"));
+			status = NDIS_STATUS_FAILURE;
+		}
+	} else {
+		// SET_OID
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+			("oid_rt_pro_efuse_map_hdl: WRITE\n"));
+
+		if (rtw_efuse_reg_init(Adapter) == _TRUE) {
+			if (rtw_efuse_map_write(Adapter, 0, EFUSE_MAX_LOGICAL_SIZE, data) == _TRUE)
+				*poid_par_priv->bytes_rw = EFUSE_MAX_LOGICAL_SIZE;
+			else {
+				RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_err_,
+					("oid_rt_pro_efuse_map_hdl: WRITE fail\n"));
+				status = NDIS_STATUS_FAILURE;
+			}
+			rtw_efuse_reg_uninit(Adapter);
+		} else {
+			RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_emerg_,
+				("oid_rt_pro_efuse_map_hdl: WRITE enable clock fail!\n"));
+			status = NDIS_STATUS_FAILURE;
+		}
+	}
+
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("-oid_rt_pro_efuse_map_hdl: status=%d\n", status));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_bandwidth_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		bandwidth;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_set_bandwidth_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	bandwidth = *((u32*)poid_par_priv->information_buf);//4
+	if (bandwidth != HT_CHANNEL_WIDTH_20)
+		bandwidth = HT_CHANNEL_WIDTH_40;
+
+	Adapter->mppriv.curr_bandwidth = (u8)bandwidth;
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SwitchBandwidth(Adapter);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("-oid_rt_set_bandwidth_hdl: bandwidth=%d\n", Adapter->mppriv.curr_bandwidth));
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_set_crystal_cap_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32		crystal_cap = 0;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len <sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	crystal_cap = *((u32*)poid_par_priv->information_buf);//4
+	if (crystal_cap > 0xf)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_crystalcap = crystal_cap;
+
+	_irqlevel_changed_(&oldirql,LOWER);
+	SetCrystalCap(Adapter);
+	_irqlevel_changed_(&oldirql,RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS  oid_rt_set_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	_irqL		oldirql;
+	u8		rx_pkt_type;
+	u32		rcr_val32;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_notice_, ("+oid_rt_set_rx_packet_type_hdl\n"));
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len < sizeof(u8)) {
+		status = NDIS_STATUS_INVALID_LENGTH;
+		return status;
+	}
+	rx_pkt_type = *((u8*)poid_par_priv->information_buf);//4
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("rx_pkt_type: %x\n",rx_pkt_type ));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+#if 0
+	rcr_val8 = rtw_read8(Adapter, 0x10250048);//RCR
+	rcr_val8 &= ~(RCR_AB|RCR_AM|RCR_APM|RCR_AAP);
+
+	if(rx_pkt_type == RX_PKT_BROADCAST){
+		rcr_val8 |= (RCR_AB | RCR_ACRC32 );
+	}
+	else if(rx_pkt_type == RX_PKT_DEST_ADDR){
+		rcr_val8 |= (RCR_AAP| RCR_AM |RCR_ACRC32);
+	}
+	else if(rx_pkt_type == RX_PKT_PHY_MATCH){
+		rcr_val8 |= (RCR_APM|RCR_ACRC32);
+	}
+	else{
+		rcr_val8 &= ~(RCR_AAP|RCR_APM|RCR_AM|RCR_AB|RCR_ACRC32);
+	}
+	rtw_write8(Adapter, 0x10250048,rcr_val8);
+#else
+	rcr_val32 = rtw_read32(Adapter, RCR);//RCR = 0x10250048
+	rcr_val32 &= ~(RCR_CBSSID|RCR_AB|RCR_AM|RCR_APM|RCR_AAP);
+#if 0
+	if(rx_pkt_type == RX_PKT_BROADCAST){
+		rcr_val32 |= (RCR_AB|RCR_AM|RCR_APM|RCR_AAP|RCR_ACRC32);
+	}
+	else if(rx_pkt_type == RX_PKT_DEST_ADDR){
+		//rcr_val32 |= (RCR_CBSSID|RCR_AAP|RCR_AM|RCR_ACRC32);
+		rcr_val32 |= (RCR_CBSSID|RCR_APM|RCR_ACRC32);
+	}
+	else if(rx_pkt_type == RX_PKT_PHY_MATCH){
+		rcr_val32 |= (RCR_APM|RCR_ACRC32);
+		//rcr_val32 |= (RCR_AAP|RCR_ACRC32);
+	}
+	else{
+		rcr_val32 &= ~(RCR_AAP|RCR_APM|RCR_AM|RCR_AB|RCR_ACRC32);
+	}
+#else
+	switch (rx_pkt_type)
+	{
+		case RX_PKT_BROADCAST :
+			rcr_val32 |= (RCR_AB|RCR_AM|RCR_APM|RCR_AAP|RCR_ACRC32);
+			break;
+		case RX_PKT_DEST_ADDR :
+			rcr_val32 |= (RCR_AB|RCR_AM|RCR_APM|RCR_AAP|RCR_ACRC32);
+			break;
+		case RX_PKT_PHY_MATCH:
+			rcr_val32 |= (RCR_APM|RCR_ACRC32);
+			break;
+		default:
+			rcr_val32 &= ~(RCR_AAP|RCR_APM|RCR_AM|RCR_AB|RCR_ACRC32);
+			break;
+	}
+
+	if (rx_pkt_type == RX_PKT_DEST_ADDR) {
+		Adapter->mppriv.check_mp_pkt = 1;
+	} else {
+		Adapter->mppriv.check_mp_pkt = 0;
+	}
+#endif
+	rtw_write32(Adapter, RCR, rcr_val32);
+
+#endif
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	_irqL		oldirql;
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+
+	u32 		txagc;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	txagc = *(u32*)poid_par_priv->information_buf;
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("oid_rt_pro_set_tx_agc_offset_hdl: 0x%08x\n", txagc));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+	SetTxAGCOffset(Adapter, txagc);
+	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
+NDIS_STATUS oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+
+	NDIS_STATUS		status = NDIS_STATUS_SUCCESS;
+
+	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+	struct mp_priv		*pmppriv = &Adapter->mppriv;
+	u32 			type;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len <sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	type = *(u32*)poid_par_priv->information_buf;
+
+	if (_LOOPBOOK_MODE_ == type) {
+		pmppriv->mode = type;
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); //append txdesc
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("test mode change to loopback mode:0x%08x.\n", pmlmepriv->fw_state));
+	} else if (_2MAC_MODE_ == type){
+		pmppriv->mode = type;
+		_clr_fwstate_(pmlmepriv, WIFI_MP_LPBK_STATE);
+		RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_, ("test mode change to 2mac mode:0x%08x.\n", pmlmepriv->fw_state));
+	} else
+		status = NDIS_STATUS_NOT_ACCEPTED;
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+//Linux
+struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv)
+{
+	_queue *pfree_xmit_queue = &pmp_priv->free_mp_xmitqueue;
+
+	_irqL irqL;
+
+	struct mp_xmit_frame *pxframe=  NULL;
+	_list *plist, *phead;
+
+_func_enter_;
+
+	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+	if (_rtw_queue_empty(pfree_xmit_queue) == _TRUE) {
+		//DEBUG_ERR(("free_mp_xmitframe_cnt:%d\n", pmp_priv->free_mp_xmitframe_cnt));
+		pxframe =  NULL;
+	} else {
+		phead = get_list_head(pfree_xmit_queue);
+		plist = get_next(phead);
+
+		pxframe = LIST_CONTAINOR(plist, struct mp_xmit_frame, list);
+
+		list_delete(&(pxframe->list));
+	}
+
+	if (pxframe !=  NULL)
+		pmp_priv->free_mp_xmitframe_cnt--;
+
+	_exit_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+_func_exit_;
+
+	return pxframe;
+}
+
+int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe)
+{
+	_irqL irqL;
+	_adapter *padapter = pxmitpriv->adapter;
+	 struct mp_priv *pmp_priv = &padapter->mppriv;
+	_queue *pfree_xmit_queue = &pmp_priv->free_mp_xmitqueue;
+
+	if (pmp_xmitframe == NULL)
+		goto exit;
+
+	if ((pmp_xmitframe->frame_tag&0x0f) != MP_FRAMETAG)
+		goto exit;
+
+	list_delete(&pmp_xmitframe->list);
+
+	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+	rtw_list_insert_tail(&(pmp_xmitframe->list), get_list_head(pfree_xmit_queue));
+
+	pmp_priv->free_mp_xmitframe_cnt++;
+
+	_exit_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+exit:
+
+	return _SUCCESS;
+}
+
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv *poid_par_priv)
+{
+#if 0
+	unsigned char *pframe, *pmp_pkt;
+	struct ethhdr *pethhdr;
+	struct pkt_attrib *pattrib;
+	struct ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;
+	int llc_sz, payload_len;
+	struct mp_xmit_frame *pxframe=  NULL;
+	struct mp_xmit_packet *pmp_xmitpkt = (struct mp_xmit_packet*)param;
+	u8 addr3[] = {0x02, 0xE0, 0x4C, 0x87, 0x66, 0x55};
+
+//	printk("+mp_ioctl_xmit_packet_hdl\n");
+
+	pxframe = alloc_mp_xmitframe(&padapter->mppriv);
+	if (pxframe == NULL)
+	{
+		DEBUG_ERR(("Can't alloc pmpframe %d:%s\n", __LINE__, __FILE__));
+		return -1;
+	}
+
+	//mp_xmit_pkt
+	payload_len = pmp_xmitpkt->len - 14;
+	pmp_pkt = (unsigned char*)pmp_xmitpkt->mem;
+	pethhdr = (struct ethhdr *)pmp_pkt;
+
+	//printk("payload_len=%d, pkt_mem=0x%x\n", pmp_xmitpkt->len, (void*)pmp_xmitpkt->mem);
+
+	//printk("pxframe=0x%x\n", (void*)pxframe);
+	//printk("pxframe->mem=0x%x\n", (void*)pxframe->mem);
+
+	//update attribute
+	pattrib = &pxframe->attrib;
+	_rtw_memset((u8 *)(pattrib), 0, sizeof (struct pkt_attrib));
+	pattrib->pktlen = pmp_xmitpkt->len;
+	pattrib->ether_type = ntohs(pethhdr->h_proto);
+	pattrib->hdrlen = 24;
+	pattrib->nr_frags = 1;
+	pattrib->priority = 0;
+#ifndef CONFIG_MP_LINUX
+	if(IS_MCAST(pethhdr->h_dest))
+		pattrib->mac_id = 4;
+	else
+		pattrib->mac_id = 5;
+#else
+	pattrib->mac_id = 5;
+#endif
+
+	//
+	_rtw_memset(pxframe->mem, 0 , WLANHDR_OFFSET);
+	pframe = (u8 *)(pxframe->mem) + WLANHDR_OFFSET;
+
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	SetFrameSubType(pframe, WIFI_DATA);
+
+	_rtw_memcpy(pwlanhdr->addr1, pethhdr->h_dest, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, pethhdr->h_source, ETH_ALEN);
+
+	_rtw_memcpy(pwlanhdr->addr3, addr3, ETH_ALEN);
+
+	pwlanhdr->seq_ctl = 0;
+	pframe += pattrib->hdrlen;
+
+	llc_sz= rtw_put_snap(pframe, pattrib->ether_type);
+	pframe += llc_sz;
+
+	_rtw_memcpy(pframe, (void*)(pmp_pkt+14),  payload_len);
+
+	pattrib->last_txcmdsz = pattrib->hdrlen + llc_sz + payload_len;
+
+	DEBUG_INFO(("issuing mp_xmit_frame, tx_len=%d, ether_type=0x%x\n", pattrib->last_txcmdsz, pattrib->ether_type));
+	xmit_mp_frame(padapter, pxframe);
+
+#endif
+
+	return _SUCCESS;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_set_power_down_hdl(struct oid_par_priv *poid_par_priv)
+{
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	_irqL		oldirql;
+	u8		bpwrup;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != SET_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("\n ===> Setoid_rt_set_power_down_hdl.\n"));
+
+	_irqlevel_changed_(&oldirql, LOWER);
+
+	bpwrup = *(u8 *)poid_par_priv->information_buf;
+	//CALL  the power_down function
+#ifdef PLATFORM_LINUX
+#ifdef CONFIG_SDIO_HCI
+	dev_power_down(Adapter,bpwrup);
+#endif
+#endif
+	_irqlevel_changed_(&oldirql, RAISE);
+
+	//DEBUG_ERR(("\n <=== Query OID_RT_PRO_READ_REGISTER.
+	//	Add:0x%08x Width:%d Value:0x%08x\n",RegRWStruct->offset,RegRWStruct->width,RegRWStruct->value));
+
+_func_exit_;
+
+	return status;
+}
+//------------------------------------------------------------------------------
+NDIS_STATUS oid_rt_get_power_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	NDIS_STATUS	status = NDIS_STATUS_SUCCESS;
+	PADAPTER	Adapter = (PADAPTER)(poid_par_priv->adapter_context);
+//	_irqL		oldirql;
+
+_func_enter_;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len < sizeof(u32)) {
+		status = NDIS_STATUS_INVALID_LENGTH;
+		return status;
+	}
+
+	RT_TRACE(_module_rtl871x_mp_ioctl_c_, _drv_info_,
+		 ("\n ===> oid_rt_get_power_mode_hdl.\n"));
+
+//	_irqlevel_changed_(&oldirql, LOWER);
+	*(int*)poid_par_priv->information_buf = Adapter->registrypriv.low_power ? POWER_LOW : POWER_NORMAL;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+//	_irqlevel_changed_(&oldirql, RAISE);
+
+_func_exit_;
+
+	return status;
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_pwrctrl.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_pwrctrl.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_pwrctrl.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_pwrctrl.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1092 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_PWRCTRL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#ifdef CONFIG_SDIO_HCI
+#ifdef PLATFORM_LINUX
+        #include<linux/mmc/sdio_func.h>
+#endif
+#include <sdio_ops.h>
+#endif
+
+#ifdef CONFIG_IPS
+extern int rtw_ips_pwr_up(_adapter *padapter);
+extern void rtw_ips_pwr_down(_adapter *padapter);
+#endif
+
+
+#ifdef CONFIG_AUTOSUSPEND
+void autosuspend_enter(_adapter* padapter)	
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	pwrpriv->bInternalAutoSuspend = _TRUE;
+	pwrpriv->bips_processing = _TRUE;	
+	
+	printk("==>autosuspend_enter...........\n");	
+	
+	if(rf_off == pwrpriv->change_rfpwrstate )
+	{	
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+		usb_enable_autosuspend(padapter->dvobjpriv.pusbdev);
+		#else
+		padapter->dvobjpriv.pusbdev->autosuspend_disabled = 0;//autosuspend disabled by the user	
+		#endif
+	
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
+			usb_autopm_put_interface(padapter->dvobjpriv.pusbintf);	
+		#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,20))		
+			usb_autopm_enable(padapter->dvobjpriv.pusbintf);
+		#else
+			usb_autosuspend_device(padapter->dvobjpriv.pusbdev, 1);
+		#endif
+	}
+	#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
+	printk("...pm_usage_cnt(%d).....\n",atomic_read(&(padapter->dvobjpriv.pusbintf->pm_usage_cnt)));
+	#else
+	printk("...pm_usage_cnt(%d).....\n",padapter->dvobjpriv.pusbintf->pm_usage_cnt);
+	#endif
+	
+}
+int autoresume_enter(_adapter* padapter)
+{
+	int result = _SUCCESS;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	
+	printk("====> autoresume_enter \n");
+	
+	if(rf_off == pwrpriv->current_rfpwrstate )
+	{			
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))				
+			if (usb_autopm_get_interface( padapter->dvobjpriv.pusbintf) < 0) 
+			{
+				printk( "can't get autopm: %d\n", result);
+				result = _FAIL;
+				goto error_exit;
+			}			
+		#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,20))				
+			usb_autopm_disable(padapter->dvobjpriv.pusbintf);
+		#else
+			usb_autoresume_device(padapter->dvobjpriv.pusbdev, 1);
+		#endif
+
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
+		printk("...pm_usage_cnt(%d).....\n",atomic_read(&(padapter->dvobjpriv.pusbintf->pm_usage_cnt)));
+		#else
+		printk("...pm_usage_cnt(%d).....\n",padapter->dvobjpriv.pusbintf->pm_usage_cnt);
+		#endif	
+	}
+	printk("<==== autoresume_enter \n");
+error_exit:	
+
+	return result;
+}
+#endif
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter )
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(pAdapter);
+	u8	val8;
+	rt_rf_power_state rfpowerstate = rf_off;
+
+	if(pAdapter->pwrctrlpriv.bHWPowerdown)
+	{
+		val8 = rtw_read8(pAdapter, REG_HSISR);
+		printk("pwrdown, 0x5c(BIT7)=%02x\n", val8);
+		rfpowerstate = (val8 & BIT7) ? rf_off: rf_on;				
+	}
+	else // rf on/off
+	{
+		rtw_write8(	pAdapter, REG_MAC_PINMUX_CFG,rtw_read8(pAdapter, REG_MAC_PINMUX_CFG)&~(BIT3));
+		val8 = rtw_read8(pAdapter, REG_GPIO_IO_SEL);
+		printk("GPIO_IN=%02x\n", val8);
+		rfpowerstate = (val8 & BIT3) ? rf_on : rf_off;	
+	}
+	return rfpowerstate;
+}	// HalDetectPwrDownMode
+#endif
+
+
+#ifdef CONFIG_IPS
+
+void ips_enter(_adapter * padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	_enter_pwrlock(&pwrpriv->lock);
+	pwrpriv->ips_enter_cnts++;	
+	printk("==>ips_enter cnts:%d\n",pwrpriv->ips_enter_cnts);
+	
+	pwrpriv->bips_processing = _TRUE;	
+
+	if(rf_off == pwrpriv->change_rfpwrstate )
+	{	
+		printk("==>power_saving_ctrl_wk_hdl change rf to OFF...LED(0x%08x).... \n\n",rtw_read32(padapter,0x4c));
+		rtw_ips_pwr_down(padapter);
+		pwrpriv->current_rfpwrstate = rf_off;
+	}	
+	pwrpriv->bips_processing = _FALSE;	
+	_exit_pwrlock(&pwrpriv->lock);
+	
+}
+
+int ips_leave(_adapter * padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int result = _SUCCESS;
+	sint keyid;
+	_enter_pwrlock(&pwrpriv->lock);
+	if((pwrpriv->current_rfpwrstate == rf_off) &&(!pwrpriv->bips_processing))
+	{
+		pwrpriv->change_rfpwrstate = rf_on;
+		pwrpriv->ips_leave_cnts++;
+		printk("==>ips_leave cnts:%d\n",pwrpriv->ips_leave_cnts);
+
+		result = rtw_ips_pwr_up(padapter);		
+		pwrpriv->bips_processing = _TRUE;
+		pwrpriv->current_rfpwrstate = rf_on;
+
+		if((_WEP40_ == psecuritypriv->dot11PrivacyAlgrthm) ||(_WEP104_ == psecuritypriv->dot11PrivacyAlgrthm))
+		{
+			printk("==>%s,channel(%d),processing(%x)\n",__FUNCTION__,pmlmeext->cur_channel,pwrpriv->bips_processing);
+			set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);			
+			for(keyid=0;keyid<4;keyid++){
+				if(pmlmeinfo->key_mask & BIT(keyid)){
+					result=rtw_set_key(padapter,psecuritypriv, keyid);	
+				}
+			}
+		}
+		
+		printk("==> ips_leave.....LED(0x%08x)...\n",rtw_read32(padapter,0x4c));
+		pwrpriv->bips_processing = _FALSE;
+
+	}
+	_exit_pwrlock(&pwrpriv->lock);
+	return result;
+}
+#endif
+
+
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+extern int rtw_hw_suspend(_adapter *padapter );
+extern int rtw_hw_resume(_adapter *padapter );
+#endif
+void rtw_ps_processor(_adapter*padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	int res;
+	rt_rf_power_state rfpwrstate;
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	if(pwrpriv->bips_processing == _TRUE)	return;		
+	
+	//printk("==> fw report state(0x%x)\n",rtw_read8(padapter,0x1ca));	
+	if(padapter->pwrctrlpriv.bHWPwrPindetect) 
+	{
+	#ifdef CONFIG_AUTOSUSPEND
+		if(padapter->registrypriv.usbss_enable)
+		{
+			if(padapter->net_closed == _TRUE)	return;
+			
+			if(pwrpriv->current_rfpwrstate == rf_on)
+			{
+				rfpwrstate = RfOnOffDetect(padapter);
+				printk("@@@@- #1  %s==> rfstate:%s \n",__FUNCTION__,(rfpwrstate==rf_on)?"rf_on":"rf_off");
+				if(rfpwrstate!= pwrpriv->current_rfpwrstate)
+				{
+					if(rfpwrstate == rf_off)
+					{
+						pwrpriv->change_rfpwrstate = rf_off;
+						
+						pwrpriv->bkeepfwalive = _TRUE;	
+						pwrpriv->brfoffbyhw = _TRUE;						
+						
+						autosuspend_enter(padapter);							
+					}
+				}
+			}			
+		}
+		else
+	#endif
+		{
+			rfpwrstate = RfOnOffDetect(padapter);
+			printk("@@@@- #2  %s==> rfstate:%s \n",__FUNCTION__,(rfpwrstate==rf_on)?"rf_on":"rf_off");
+
+			if(rfpwrstate!= pwrpriv->current_rfpwrstate)
+			{
+				if(rfpwrstate == rf_off)
+				{	
+					pwrpriv->change_rfpwrstate = rf_off;														
+					pwrpriv->brfoffbyhw = _TRUE;
+					padapter->bCardDisableWOHSM = _TRUE;
+					rtw_hw_suspend(padapter );	
+				}
+				else
+				{
+					pwrpriv->change_rfpwrstate = rf_on;
+					rtw_hw_resume(padapter );			
+				}
+				printk("current_rfpwrstate(%s)\n",(pwrpriv->current_rfpwrstate == rf_off)?"rf_off":"rf_on");
+			}
+		}
+		pwrpriv->pwr_state_check_cnts ++;	
+	}
+	
+#endif
+	if( pwrpriv->power_mgnt == PS_MODE_ACTIVE )	return;
+				
+	if(padapter->net_closed == _TRUE)	return;
+
+	if((pwrpriv->current_rfpwrstate == rf_on) && ((pwrpriv->pwr_state_check_cnts%4)==0))
+	{
+		if (	(check_fwstate(pmlmepriv, _FW_LINKED|_FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
+			(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
+			(padapter->net_closed == _TRUE)|| (padapter->bup == _FALSE)	
+		)
+		{
+			return;
+		}
+		printk("==>%s .fw_state(%x)\n",__FUNCTION__,padapter->mlmepriv.fw_state);
+		pwrpriv->change_rfpwrstate = rf_off;
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)	
+#ifdef CONFIG_AUTOSUSPEND
+		if(padapter->registrypriv.usbss_enable)
+		{		
+			if(padapter->pwrctrlpriv.bHWPwrPindetect) 
+				pwrpriv->bkeepfwalive = _TRUE;				
+			
+			padapter->bCardDisableWOHSM = _TRUE;
+			autosuspend_enter(padapter);
+		}		
+		else if(padapter->pwrctrlpriv.bHWPwrPindetect)
+		{
+		}
+		else
+#endif
+#endif	
+		{
+#ifdef CONFIG_IPS	
+			ips_enter(padapter);			
+#endif
+		}
+	}
+
+	
+}
+
+void power_saving_ctrl_wk_hdl(_adapter *padapter, u8 *pbuf, int sz)
+{
+	 rtw_ps_processor(padapter);
+}
+
+u8 rtw_ps_cmd(_adapter*padapter)
+{
+	struct cmd_obj		*ppscmd;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;	
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	
+	u8	res = _SUCCESS;
+_func_enter_;
+	
+	ppscmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));	
+	if(ppscmd==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+		
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)_rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
+	if(pdrvextra_cmd_parm==NULL){
+		_rtw_mfree((unsigned char *)ppscmd, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;	
+	pdrvextra_cmd_parm->pbuf = NULL;
+	printk("==> %s  , enqueue CMD \n",__FUNCTION__);	
+	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+	rtw_enqueue_cmd_ex(pcmdpriv, ppscmd);
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+
+}
+
+#if (!CONFIG_PS_CMD)
+void InactivePSWorkItemCallback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv = container_of(work, struct pwrctrl_priv, InactivePSWorkItem);
+	_adapter *padapter = container_of(pwrpriv, _adapter, pwrctrlpriv);	
+ 	rtw_ps_processor(padapter);
+}
+#endif
+void pwr_state_check_handler(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+	
+	
+//	if(( pwrctrlpriv->power_mgnt == PS_MODE_ACTIVE )
+//		return;	
+
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	//printk("%s...bHWPwrPindetect(%d)\n",__FUNCTION__,padapter->pwrctrlpriv.bHWPwrPindetect);
+	if(padapter->pwrctrlpriv.bHWPwrPindetect)
+	{
+	#if (CONFIG_PS_CMD)
+		rtw_ps_cmd(padapter);		
+	#else
+		_set_workitem(&(pwrpriv->InactivePSWorkItem));	
+	#endif
+		_set_timer(&padapter->pwrctrlpriv.pwr_state_check_timer, padapter->pwrctrlpriv.pwr_state_check_inverval);
+	}	
+	else	
+#endif
+	{
+		if(padapter->net_closed == _TRUE)		return;
+		//printk("%s\n",__FUNCTION__);
+		if (	(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||	
+			(check_fwstate(pmlmepriv, _FW_LINKED|_FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)  ||
+			(padapter->net_closed == _TRUE)|| (padapter->bup == _FALSE)		
+			)
+		{	
+			//other pwr ctrl....	
+			_set_timer(&padapter->pwrctrlpriv.pwr_state_check_timer, padapter->pwrctrlpriv.pwr_state_check_inverval);
+		}
+		else
+		{	
+			if((pwrpriv->current_rfpwrstate == rf_on) &&(_FALSE == pwrpriv->bips_processing))
+			{	
+				pwrpriv->change_rfpwrstate = rf_off;
+				pwrctrlpriv->pwr_state_check_cnts = 0;
+				printk("==>pwr_state_check_handler .fw_state(%x)\n",padapter->mlmepriv.fw_state);
+				#if (CONFIG_PS_CMD)
+				rtw_ps_cmd(padapter);				
+				#else
+				_set_workitem(&(pwrpriv->InactivePSWorkItem));	
+				#endif
+			}
+
+		}
+	}
+	
+}
+
+
+
+
+
+#ifdef CONFIG_LPS
+static void set_rpwm(_adapter * padapter, u8 val8)
+{
+	u8	rpwm;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	if(pwrpriv->rpwm == val8){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("Already set rpwm [%d] ! \n", val8));
+		return;
+	}
+
+	if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE)){
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("set_rpwm=> bDriverStopped or bSurpriseRemoved \n"));
+		return;
+	}
+	rpwm = val8 |pwrpriv->tog;
+
+	pwrpriv->rpwm = val8;
+	
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("set_rpwm: value = %x\n", rpwm));
+
+	rtw_write8(padapter, REG_USB_HRPWM, rpwm);
+	
+	pwrpriv->tog += 0x80;
+
+_func_exit_;
+}
+
+u8 PS_RDY_CHECK(_adapter * padapter)
+{
+	u32 curr_time, delta_time;
+	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	curr_time = rtw_get_current_time();	
+
+	delta_time = curr_time -pwrpriv->DelayLPSLastTimeStamp;
+
+	if(delta_time < LPS_DELAY_TIME)
+	{		
+		return _FALSE;
+	}
+
+	if (	(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE) ||
+		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) )
+		return _FALSE;
+
+	if( (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == _FALSE) )
+	{
+		DBG_8192C("Group handshake still in progress !!!\n");
+		return _FALSE;
+	}
+
+	return _TRUE;
+}
+
+void rtw_set_ps_mode(_adapter * padapter, uint ps_mode, uint smart_ps)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("========= Power Mode is :%d, Smart_PS = %d\n", ps_mode,smart_ps));
+	//printk("========= Power Mode is :%d, Smart_PS = %d\n", ps_mode,smart_ps);
+
+	if(ps_mode > PM_Card_Disable) {
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("ps_mode:%d error\n", ps_mode));
+		return;
+	}
+
+	if(pwrpriv->pwr_mode == ps_mode){
+		return;
+	}
+
+	pwrpriv->pwr_mode = ps_mode;
+
+	if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+	{
+		DBG_8192C("rtw_set_ps_mode(): Busy Traffic , Leave 802.11 power save..\n");
+		set_rpwm(padapter, PS_STATE_S4);
+		set_FwPwrMode_cmd(padapter, ps_mode);
+		pwrpriv->bFwCurrentInPSMode = _FALSE;
+	}
+	else
+	{
+		if(PS_RDY_CHECK(padapter))
+		{
+			DBG_8192C("rtw_set_ps_mode(): Enter 802.11 power save mode...\n");
+			pwrpriv->bFwCurrentInPSMode = _TRUE;
+			set_FwPwrMode_cmd(padapter, ps_mode);
+			set_rpwm(padapter, PS_STATE_S2);
+		//	set_rpwm(padapter, PS_STATE_S3);			
+		}
+		else
+		{
+			pwrpriv->pwr_mode = PS_MODE_ACTIVE;
+		}
+	}
+
+_func_exit_;
+}
+
+
+//
+//	Description:
+//		Enter the leisure power save mode.
+//
+void LPS_Enter(PADAPTER padapter)
+{
+	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+_func_enter_;
+
+	//printk("LeisurePSEnter()...\n");
+	
+	if (	(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE) ||
+		(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) )
+		return;
+
+	if (pwrpriv->bLeisurePs)
+	{
+		// Idle for a while if we connect to AP a while ago.
+		if(pwrpriv->LpsIdleCount >= 2) //  4 Sec 
+		{
+			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			{
+
+				//printk("LeisurePSEnter(): Enter 802.11 power save mode...\n");
+
+				rtw_set_ps_mode(padapter, pwrpriv->power_mgnt, 1);
+			}	
+		}
+		else
+			pwrpriv->LpsIdleCount++;
+	}
+
+_func_exit_;
+}
+
+
+//
+//	Description:
+//		Leave the leisure power save mode.
+//
+void LPS_Leave(PADAPTER padapter)
+{
+	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+_func_enter_;
+
+	//printk("LeisurePSLeave()...\n");
+
+	if (pwrpriv->bLeisurePs)
+	{	
+		if(pwrpriv->pwr_mode != PS_MODE_ACTIVE)
+		{
+			rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0);
+		}
+	}
+
+_func_exit_;
+}
+
+u8 FWLPS_RF_ON(PADAPTER padapter)
+{
+	u32	valRCR;
+	u8	ret;
+
+_func_enter_;
+
+	if(padapter->pwrctrlpriv.current_rfpwrstate == rf_off)
+	{
+		// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
+		// because Fw is unload.
+		ret = _TRUE;
+	}
+	else
+	{
+		valRCR = rtw_read32(padapter, REG_RCR);
+		valRCR &= 0x00070000;
+		if(valRCR)
+			ret = _FALSE;
+		else
+			ret = _TRUE;
+	}
+
+_func_exit_;
+
+	return ret;
+}
+#endif
+
+//
+// Description: Leave all power save mode: LPS, FwLPS, IPS if needed.
+// Move code to function by tynli. 2010.03.26. 
+//
+void LeaveAllPowerSaveMode(IN PADAPTER Adapter)
+{
+	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32 LPSLeaveTimeOut = 10000;
+	//u32 IPSLeaveTimeOut = 10000;
+
+_func_enter_;
+	if(Adapter->bSurpriseRemoved == _TRUE)
+		return;
+	
+	printk("%s.....\n",__FUNCTION__);
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	{ //connect
+#ifdef CONFIG_LPS
+		printk("==> leave LPS.......\n");
+		LPS_Leave(Adapter);
+
+		while( !FWLPS_RF_ON(Adapter) )
+		{
+			rtw_usleep_os(100);
+			LPSLeaveTimeOut--;
+			if(LPSLeaveTimeOut <= 0)
+			{
+				printk("Wait for FW LPS leave too long!!! LPSLeaveTimeOut  = %d\n", LPSLeaveTimeOut );
+				break;
+			}
+		}
+#endif
+	}
+	else
+	{
+
+		printk("==> leave IPS.......\n");
+		if(Adapter->pwrctrlpriv.current_rfpwrstate== rf_off)
+		{				
+			#ifdef CONFIG_AUTOSUSPEND
+			if(Adapter->registrypriv.usbss_enable)
+			{
+				#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+				usb_disable_autosuspend(Adapter->dvobjpriv.pusbdev);
+				#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
+				Adapter->dvobjpriv.pusbdev->autosuspend_disabled = Adapter->bDisableAutosuspend;//autosuspend disabled by the user
+				#endif
+			}
+			else
+			#endif
+			{
+				#ifdef CONFIG_IPS
+				if(_FALSE == ips_leave(Adapter))
+				{
+					printk("======> ips_leave fail.............\n");			
+				}
+				#endif
+			}				
+		}	
+
+	}
+
+_func_exit_;
+}
+
+#ifdef CONFIG_PWRCTRL
+
+/*
+Caller:ISR handler...
+
+This will be called when CPWM interrupt is up.
+
+using to update cpwn of drv; and drv willl make a decision to up or down pwr level
+*/
+void cpwm_int_hdl(_adapter *padapter, struct reportpwrstate_parm *preportpwrstate)
+{
+	struct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);
+	struct cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+
+_func_enter_;
+
+	if(pwrpriv->cpwm_tog == ((preportpwrstate->state)&0x80)){
+		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("cpwm_int_hdl : cpwm_tog = %x this time cpwm=0x%x  toggle bit didn't change !!!\n",pwrpriv->cpwm_tog ,preportpwrstate->state));	
+		goto exit;
+	}
+
+	_enter_pwrlock(&pwrpriv->lock);
+
+	pwrpriv->cpwm = (preportpwrstate->state)&0xf;
+
+	if(pwrpriv->cpwm >= PS_STATE_S2){
+		if(pwrpriv->alives & CMD_ALIVE)
+			_rtw_up_sema(&(pcmdpriv->cmd_queue_sema));
+
+		if(pwrpriv->alives & XMIT_ALIVE)
+			_rtw_up_sema(&(pxmitpriv->xmit_sema));
+	}
+	pwrpriv->cpwm_tog=  (preportpwrstate->state)&0x80;
+	_exit_pwrlock(&pwrpriv->lock);
+exit:
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("cpwm_int_hdl : cpwm = %x !!!\n",pwrpriv->cpwm));
+
+_func_exit_;
+
+}
+
+
+__inline static void	register_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+_func_enter_;
+		pwrctrl->alives |= tag;
+_func_exit_;
+}
+
+__inline static void	unregister_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+_func_enter_;
+
+	if (pwrctrl->alives & tag)
+		pwrctrl->alives ^= tag;
+
+_func_exit_;	
+}
+#endif
+
+
+void	rtw_init_pwrctrl_priv(_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+	struct registry_priv* pregistrypriv = &padapter->registrypriv;
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct registry_priv  *registry_par = &padapter->registrypriv;
+
+_func_enter_;
+
+	_rtw_memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));
+
+#ifdef PLATFORM_WINDOWS
+	pwrctrlpriv->pnp_current_pwr_state=NdisDeviceStateD0;
+#endif
+
+	_init_pwrlock(&pwrctrlpriv->lock);
+	pwrctrlpriv->current_rfpwrstate = rf_on;	
+	pwrctrlpriv->ips_enter_cnts=0;
+	pwrctrlpriv->ips_leave_cnts=0;
+
+	pwrctrlpriv->pwr_state_check_inverval = 2000;
+	pwrctrlpriv->pwr_state_check_cnts = 0;
+	pwrctrlpriv->bInternalAutoSuspend = _FALSE;
+#ifdef CONFIG_AUTOSUSPEND	
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	pwrctrlpriv->pwr_state_check_inverval = (pwrctrlpriv->bHWPwrPindetect) ?1000:2000;	
+	pwrctrlpriv->bkeepfwalive = _FALSE;
+#endif	
+#endif
+	
+	pwrctrlpriv->LpsIdleCount = 0;
+	//pwrctrlpriv->FWCtrlPSMode =padapter->registrypriv.power_mgnt;// PS_MODE_MIN;
+	pwrctrlpriv->power_mgnt =padapter->registrypriv.power_mgnt;// PS_MODE_MIN;
+	pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?_TRUE:_FALSE;
+	
+	pwrctrlpriv->bFwCurrentInPSMode = _FALSE;
+
+	pwrctrlpriv->cpwm = PS_STATE_S4;
+
+	pwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;
+
+	
+	pwrctrlpriv->smart_ps = 0;
+
+	pwrctrlpriv->tog = 0x80;
+#if(!CONFIG_PS_CMD)
+	_init_workitem(&(pwrctrlpriv->InactivePSWorkItem), InactivePSWorkItemCallback, padapter);
+#endif
+#ifdef PLATFORM_LINUX		
+	_init_timer(&(pwrctrlpriv->pwr_state_check_timer), padapter->pnetdev, pwr_state_check_handler, (u8 *)padapter);
+#endif
+
+
+
+_func_exit_;
+
+}
+
+
+void	rtw_free_pwrctrl_priv(_adapter *adapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &adapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_rtw_memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));
+
+	_free_pwrlock(&pwrctrlpriv->lock);
+
+_func_exit_;
+}
+
+
+/*
+Caller: xmit_thread
+
+Check if the fw_pwrstate is okay for xmit.
+If not (cpwm is less than P1 state), then the sub-routine
+will raise the cpwm to be greater than or equal to P1. 
+
+Calling Context: Passive
+
+Return Value:
+
+_SUCCESS: xmit_thread can write fifo/txcmd afterwards.
+_FAIL: xmit_thread can not do anything.
+*/
+sint rtw_register_tx_alive(_adapter *padapter)
+{
+	uint res = _SUCCESS;
+	
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, XMIT_ALIVE);
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rtw_register_tx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	if(pwrctrl->cpwm < PS_STATE_S2){
+		set_rpwm(padapter, PS_STATE_S3);
+		res = _FAIL;
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+	
+_func_exit_;
+
+#endif	/* CONFIG_PWRCTRL */
+
+	return res;	
+
+}
+
+/*
+Caller: rtw_cmd_thread
+
+Check if the fw_pwrstate is okay for issuing cmd.
+If not (cpwm should be is less than P2 state), then the sub-routine
+will raise the cpwm to be greater than or equal to P2. 
+
+Calling Context: Passive
+
+Return Value:
+
+_SUCCESS: rtw_cmd_thread can issue cmds to firmware afterwards.
+_FAIL: rtw_cmd_thread can not do anything.
+*/
+sint rtw_register_cmd_alive(_adapter *padapter)
+{
+	uint res = _SUCCESS;
+	
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, CMD_ALIVE);
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rtw_register_cmd_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	if(pwrctrl->cpwm < PS_STATE_S2){
+		set_rpwm(padapter, PS_STATE_S3);
+		res = _FAIL;
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+_func_exit_;
+#endif
+
+	return res;
+}
+
+
+/*
+Caller: rx_isr
+
+Calling Context: Dispatch/ISR
+
+Return Value:
+
+*/
+sint rtw_register_rx_alive(_adapter *padapter)
+{
+
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, RECV_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rtw_register_rx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+	
+#endif /*CONFIG_PWRCTRL*/
+
+	return _SUCCESS;
+}
+
+
+/*
+Caller: evt_isr or evt_thread
+
+Calling Context: Dispatch/ISR or Passive
+
+Return Value:
+*/
+sint rtw_register_evt_alive(_adapter *padapter)
+{
+
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, EVT_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_info_,("rtw_register_evt_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+
+	return _SUCCESS;
+}
+
+
+/*
+Caller: ISR
+
+If ISR's txdone,
+No more pkts for TX,
+Then driver shall call this fun. to power down firmware again.
+*/
+
+void rtw_unregister_tx_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, XMIT_ALIVE);
+
+	if((pwrctrl->cpwm > PS_STATE_S2) && (pwrctrl->pwr_mode > PS_MODE_ACTIVE)){
+		if(pwrctrl->alives == 0){
+			set_rpwm(padapter, PS_STATE_S0);
+		}
+	}
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rtw_unregister_tx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+	
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+}
+
+/*
+Caller: ISR
+
+If ISR's txdone,
+No more pkts for TX,
+Then driver shall call this fun. to power down firmware again.
+*/
+
+void rtw_unregister_cmd_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, CMD_ALIVE);
+
+	if((pwrctrl->cpwm > PS_STATE_S2) && (pwrctrl->pwr_mode > PS_MODE_ACTIVE)){
+		if((pwrctrl->alives == 0)&&(check_fwstate(&padapter->mlmepriv, _FW_UNDER_LINKING)!=_TRUE)){
+			set_rpwm(padapter, PS_STATE_S0);
+		}
+	}
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rtw_unregister_cmd_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+}
+
+
+/*
+
+Caller: ISR
+
+*/
+void rtw_unregister_rx_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, RECV_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rtw_unregister_rx_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+	
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif
+}
+
+
+void rtw_unregister_evt_alive(_adapter *padapter)
+{
+#ifdef CONFIG_PWRCTRL
+
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+_func_enter_;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, EVT_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("rtw_unregister_evt_alive: cpwm:%d alives:%x\n", pwrctrl->cpwm, pwrctrl->alives));
+	
+	_exit_pwrlock(&pwrctrl->lock);
+
+_func_exit_;
+
+#endif /*CONFIG_PWRCTRL*/
+}
+
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_recv.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_recv.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_recv.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_recv.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,3011 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_RECV_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <mlme_osdep.h>
+#include <ip.h>
+#include <if_ether.h>
+#include <ethernet.h>
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#include <wifi.h>
+#include <circ_buf.h>
+
+
+void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
+{
+
+
+_func_enter_;
+
+	_rtw_memset((u8 *)psta_recvpriv, 0, sizeof (struct sta_recv_priv));
+
+	_rtw_spinlock_init(&psta_recvpriv->lock);
+
+	//for(i=0; i<MAX_RX_NUMBLKS; i++)
+	//	_rtw_init_queue(&psta_recvpriv->blk_strms[i]);
+
+	_rtw_init_queue(&psta_recvpriv->defrag_q);
+
+_func_exit_;
+
+}
+
+sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
+{
+	sint i;
+
+	union recv_frame *precvframe;
+
+	sint	res=_SUCCESS;
+
+_func_enter_;
+
+	 _rtw_memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv));
+
+	_rtw_spinlock_init(&precvpriv->lock);
+
+	_rtw_init_queue(&precvpriv->free_recv_queue);
+	_rtw_init_queue(&precvpriv->recv_pending_queue);
+	_rtw_init_queue(&precvpriv->pending_rx_transfer_buffer_queue);	
+	precvpriv->pending_rx_transfer_buffer_cnt = 0;
+
+	precvpriv->adapter = padapter;
+
+	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
+
+	rtw_os_recv_resource_init(precvpriv, padapter);
+
+	precvpriv->pallocated_frame_buf = _rtw_zmalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+	if(precvpriv->pallocated_frame_buf==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	//_rtw_memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+
+	precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf + RXFRAME_ALIGN_SZ -
+							((SIZE_PTR) (precvpriv->pallocated_frame_buf) &(RXFRAME_ALIGN_SZ-1));
+
+	precvframe = (union recv_frame*) precvpriv->precv_frame_buf;
+
+
+	for(i=0; i < NR_RECVFRAME ; i++)
+	{
+		_rtw_init_listhead(&(precvframe->u.list));
+
+		rtw_list_insert_tail(&(precvframe->u.list), &(precvpriv->free_recv_queue.queue));
+
+		res = rtw_os_recv_resource_alloc(padapter, precvframe);
+
+		precvframe->u.hdr.adapter =padapter;
+		precvframe++;
+
+	}
+
+#ifdef CONFIG_USB_HCI
+
+	precvpriv->rx_pending_cnt=1;
+
+	_rtw_init_sema(&precvpriv->allrxreturnevt, 0);
+
+#endif
+
+
+	res = rtw_init_recv_priv(precvpriv, padapter);
+
+
+exit:
+
+_func_exit_;
+
+	return res;
+
+}
+
+static void mfree_recv_priv_lock(struct recv_priv *precvpriv)
+{
+	_rtw_spinlock_free(&precvpriv->lock);
+	_rtw_free_sema(&precvpriv->recv_sema);
+	_rtw_free_sema(&precvpriv->terminate_recvthread_sema);
+
+	_rtw_spinlock_free(&precvpriv->free_recv_queue.lock);
+	_rtw_spinlock_free(&precvpriv->recv_pending_queue.lock);
+
+	_rtw_spinlock_free(&precvpriv->free_recv_buf_queue.lock);
+
+	_rtw_spinlock_free(&precvpriv->pending_rx_transfer_buffer_queue.lock);
+	
+}
+
+void _rtw_free_recv_priv (struct recv_priv *precvpriv)
+{
+_func_enter_;
+
+	rtw_free_pending_transfer_buffers(precvpriv);
+
+	mfree_recv_priv_lock(precvpriv);
+
+	rtw_os_recv_resource_free(precvpriv);
+
+	if(precvpriv->pallocated_frame_buf)
+		_rtw_mfree(precvpriv->pallocated_frame_buf, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+
+	rtw_free_recv_priv(precvpriv);
+
+_func_exit_;
+
+}
+
+union recv_frame *rtw_alloc_recvframe (_queue *pfree_recv_queue)
+{
+	//_irqL irqL;
+	union recv_frame  *precvframe;
+	_list	*plist, *phead;
+	_adapter *padapter;
+	struct recv_priv *precvpriv;
+_func_enter_;
+
+	//_enter_critical(&pfree_recv_queue->lock, &irqL);
+
+	if(_rtw_queue_empty(pfree_recv_queue) == _TRUE)
+	{
+		precvframe = NULL;
+	}
+	else
+	{
+		phead = get_list_head(pfree_recv_queue);
+
+		plist = get_next(phead);
+
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+
+		list_delete(&precvframe->u.hdr.list);
+		padapter=precvframe->u.hdr.adapter;
+		if(padapter !=NULL){
+			precvpriv=&padapter->recvpriv;
+			if(pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt--;
+		}
+	}
+
+	//_exit_critical(&pfree_recv_queue->lock, &irqL);
+
+_func_exit_;
+
+	return precvframe;
+
+}
+
+void rtw_init_recvframe(union recv_frame *precvframe, struct recv_priv *precvpriv)
+{
+	struct recv_buf *precvbuf = precvframe->u.hdr.precvbuf;
+
+	/* Perry: This can be removed */
+	_rtw_init_listhead(&precvframe->u.hdr.list);
+
+	precvframe->u.hdr.len=0;
+
+
+}
+
+int rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue)
+{
+	//_irqL irqL;
+	_adapter *padapter=precvframe->u.hdr.adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+_func_enter_;
+
+
+#ifdef PLATFORM_WINDOWS
+	rtw_os_read_port(padapter, precvframe->u.hdr.precvbuf);
+#endif
+
+#ifdef PLATFORM_LINUX
+
+	if(precvframe->u.hdr.pkt)
+	{
+		dev_kfree_skb_any(precvframe->u.hdr.pkt);//free skb by driver
+		precvframe->u.hdr.pkt = NULL;
+	}
+
+#ifdef CONFIG_SDIO_HCI
+{
+	_irqL irql;
+	struct recv_buf *precvbuf=precvframe->u.hdr.precvbuf;
+	if(precvbuf !=NULL){
+		_enter_critical_bh(&precvbuf->recvbuf_lock, &irql);
+
+		precvbuf->ref_cnt--;
+		if(precvbuf->ref_cnt == 0 ){
+			_enter_critical_bh(&precvpriv->free_recv_buf_queue.lock, &irqL);
+			list_delete(&(precvbuf->list));
+			rtw_list_insert_tail(&(precvbuf->list), get_list_head(&precvpriv->free_recv_buf_queue));
+			precvpriv->free_recv_buf_queue_cnt++;
+			_exit_critical_bh(&precvpriv->free_recv_buf_queue.lock, &irqL);
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("rtw_os_read_port: precvbuf=0x%p enqueue:precvpriv->free_recv_buf_queue_cnt=%d\n",precvbuf,precvpriv->free_recv_buf_queue_cnt));
+		}
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("rtw_os_read_port: precvbuf=0x%p enqueue:precvpriv->free_recv_buf_queue_cnt=%d\n",precvbuf,precvpriv->free_recv_buf_queue_cnt));
+		_exit_critical_bh(&precvbuf->recvbuf_lock, &irql);
+	}
+}
+#endif
+#endif
+
+	//_enter_critical(&pfree_recv_queue->lock, &irqL);
+
+	list_delete(&(precvframe->u.hdr.list));
+
+	rtw_list_insert_tail(&(precvframe->u.hdr.list), get_list_head(pfree_recv_queue));
+
+	if(padapter !=NULL){
+		if(pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt++;
+	}
+
+      //_exit_critical(&pfree_recv_queue->lock, &irqL);
+
+_func_exit_;
+
+	return _SUCCESS;
+
+}
+
+
+static union recv_frame *dequeue_recvframe (_queue *queue)
+{
+	return rtw_alloc_recvframe(queue);
+}
+
+
+sint rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue)
+{
+	_irqL irqL;
+	_adapter *padapter=precvframe->u.hdr.adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+_func_enter_;
+
+
+	//_rtw_spinlock(&pfree_recv_queue->lock);
+	_enter_critical_bh(&queue->lock, &irqL);
+
+	//_rtw_init_listhead(&(precvframe->u.hdr.list));
+	list_delete(&(precvframe->u.hdr.list));
+
+
+	rtw_list_insert_tail(&(precvframe->u.hdr.list), get_list_head(queue));
+
+	if (padapter != NULL) {
+		if (queue == &precvpriv->free_recv_queue)
+			precvpriv->free_recvframe_cnt++;
+	}
+
+	//_rtw_spinunlock(&pfree_recv_queue->lock);
+	_exit_critical_bh(&queue->lock, &irqL);
+
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+/*
+sint	rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue)
+{
+	return rtw_free_recvframe(precvframe, queue);
+}
+*/
+
+
+
+
+/*
+caller : defrag ; recvframe_chk_defrag in recv_thread  (passive)
+pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
+
+using spinlock to protect
+
+*/
+
+void rtw_free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue)
+{
+	union	recv_frame 	*precvframe;
+	_list	*plist, *phead;
+
+_func_enter_;
+	_rtw_spinlock(&pframequeue->lock);
+
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+
+	while(rtw_end_of_queue_search(phead, plist) == _FALSE)
+	{
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+
+		plist = get_next(plist);
+
+		//list_delete(&precvframe->u.hdr.list); // will do this in rtw_free_recvframe()
+
+		rtw_free_recvframe(precvframe, pfree_recv_queue);
+	}
+
+	_rtw_spinunlock(&pframequeue->lock);
+
+_func_exit_;
+
+}
+
+void rtw_enqueue_rx_transfer_buffer(struct recv_priv *precvpriv, struct rtw_transfer_buffer *transfer_buffer)
+{
+	_irqL irqL;	
+	_queue *ppending_queue = &precvpriv->pending_rx_transfer_buffer_queue;
+	
+	_enter_critical(&ppending_queue->lock, &irqL);
+
+	list_delete(&transfer_buffer->list);	
+
+	rtw_list_insert_tail(&transfer_buffer->list, get_list_head(ppending_queue));
+
+	precvpriv->pending_rx_transfer_buffer_cnt++;
+
+	_exit_critical(&ppending_queue->lock, &irqL);
+
+}
+
+struct rtw_transfer_buffer *rtw_dequeue_rx_transfer_buffer(struct recv_priv *precvpriv)
+{
+	_irqL irqL;	
+	_list	*plist, *phead;
+	struct rtw_transfer_buffer *rx_transfer_buffer=NULL;
+	_queue *ppending_queue = &precvpriv->pending_rx_transfer_buffer_queue;
+
+	_enter_critical(&ppending_queue->lock, &irqL);
+
+	if(_rtw_queue_empty(ppending_queue) == _TRUE)
+	{
+		rx_transfer_buffer = NULL;
+	}
+	else
+	{
+		phead = get_list_head(ppending_queue);
+
+		plist = get_next(phead);
+
+		rx_transfer_buffer = LIST_CONTAINOR(plist, struct rtw_transfer_buffer, list);
+
+		list_delete(&rx_transfer_buffer->list);	
+	
+		precvpriv->pending_rx_transfer_buffer_cnt--;
+		
+	}
+
+	_exit_critical(&ppending_queue->lock, &irqL);
+
+	return rx_transfer_buffer;
+
+}
+
+struct rtw_transfer_buffer *rtw_alloc_transfer_buffer(u32 sz)
+{	
+	SIZE_PTR alignment=0;
+	struct rtw_transfer_buffer *transfer_buffer = NULL;
+
+	transfer_buffer = (struct rtw_transfer_buffer *)_rtw_zmalloc(sizeof(struct rtw_transfer_buffer));
+	if(transfer_buffer==NULL)
+		return NULL;
+
+	_rtw_init_listhead(&transfer_buffer->list);
+
+	transfer_buffer->pallocated_transfer_buf = _rtw_zmalloc(sz);
+	if(transfer_buffer->pallocated_transfer_buf==NULL)
+	{
+		_rtw_mfree((u8*)transfer_buffer, sizeof(struct rtw_transfer_buffer));
+
+		return NULL;
+	}
+
+	alignment = (SIZE_PTR)transfer_buffer->pallocated_transfer_buf & (RECVBUFF_ALIGN_SZ-1);
+	
+	transfer_buffer->transfer_buf = transfer_buffer->pallocated_transfer_buf + (RECVBUFF_ALIGN_SZ - alignment);
+		
+    	
+	transfer_buffer->buffer_len = sz;
+
+	transfer_buffer->transfer_len = 0;	
+	
+	return transfer_buffer;
+	
+}
+
+void rtw_free_transfer_buffer(struct rtw_transfer_buffer *transfer_buffer)
+{
+	if(transfer_buffer)
+	{
+		if(transfer_buffer->pallocated_transfer_buf)
+		{
+			_rtw_mfree(transfer_buffer->pallocated_transfer_buf, transfer_buffer->buffer_len);
+		}
+
+		_rtw_mfree((u8*)transfer_buffer, sizeof(struct rtw_transfer_buffer));
+
+	}
+}
+
+void rtw_free_pending_transfer_buffers(struct recv_priv *precvpriv)
+{
+	struct rtw_transfer_buffer *rx_transfer_buffer=NULL;	
+
+	while (NULL != (rx_transfer_buffer = rtw_dequeue_rx_transfer_buffer(precvpriv)))
+	{
+		rtw_free_transfer_buffer(rx_transfer_buffer);
+	}	
+
+	//check only
+	if(precvpriv->pending_rx_transfer_buffer_cnt!=0)
+	{
+		DBG_871X("%s, !!! pending_rx_transfer_buffer_cnt=%d\n", __FUNCTION__, precvpriv->pending_rx_transfer_buffer_cnt);
+	}	
+}
+
+static sint recvframe_chkmic(_adapter *adapter,  union recv_frame *precvframe){
+
+	sint	i,res=_SUCCESS;
+	u32	datalen;
+	u8	miccode[8];
+	u8	bmic_err=_FALSE;
+	u8	*pframe, *payload,*pframemic;
+	u8	*mickey;
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	*prxattrib=&precvframe->u.hdr.attrib;
+	struct 	security_priv	*psecuritypriv=&adapter->securitypriv;
+
+
+_func_enter_;
+
+	stainfo=rtw_get_stainfo(&adapter->stapriv ,&prxattrib->ta[0]);
+
+	if(prxattrib->encrypt ==_TKIP_)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic:prxattrib->encrypt ==_TKIP_\n"));
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic:da=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+			prxattrib->ra[0],prxattrib->ra[1],prxattrib->ra[2],prxattrib->ra[3],prxattrib->ra[4],prxattrib->ra[5]));
+
+		//calculate mic code
+		if(stainfo!= NULL)
+		{
+			if(IS_MCAST(prxattrib->ra))
+			{
+				mickey=&psecuritypriv->dot118021XGrprxmickey.skey[0];
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic: bcmc key \n"));
+				if(psecuritypriv->binstallGrpkey==_FALSE)
+				{
+					res=_FAIL;
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n"));
+					goto exit;
+				}
+			}
+			else{
+				mickey=&stainfo->dot11tkiprxmickey.skey[0];
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic: unicast key \n"));
+			}
+
+			datalen=precvframe->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len-prxattrib->icv_len-8;//icv_len included the mic code
+			pframe=precvframe->u.hdr.rx_data;
+			payload=pframe+prxattrib->hdrlen+prxattrib->iv_len;
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n prxattrib->iv_len=%d prxattrib->icv_len=%d\n",prxattrib->iv_len,prxattrib->icv_len));
+
+			//rtw_seccalctkipmic(&stainfo->dot11tkiprxmickey.skey[0],pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
+
+			rtw_seccalctkipmic(mickey,pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
+
+			pframemic=payload+datalen;
+
+			bmic_err=_FALSE;
+
+			for(i=0;i<8;i++){
+				if(miccode[i] != *(pframemic+i)){
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",i,miccode[i],i,*(pframemic+i)));
+					bmic_err=_TRUE;
+				}
+			}
+
+			if(bmic_err==_TRUE){
+
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-8)-*(pframemic-1)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+					*(pframemic-8),*(pframemic-7),*(pframemic-6),*(pframemic-5),*(pframemic-4),*(pframemic-3),*(pframemic-2),*(pframemic-1)));
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-16)-*(pframemic-9)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+					*(pframemic-16),*(pframemic-15),*(pframemic-14),*(pframemic-13),*(pframemic-12),*(pframemic-11),*(pframemic-10),*(pframemic-9)));
+
+				{
+					uint i;
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n ======demp packet (len=%d)======\n",precvframe->u.hdr.len));
+					for(i=0;i<precvframe->u.hdr.len;i=i+8){
+						RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x",
+							*(precvframe->u.hdr.rx_data+i),*(precvframe->u.hdr.rx_data+i+1),
+							*(precvframe->u.hdr.rx_data+i+2),*(precvframe->u.hdr.rx_data+i+3),
+							*(precvframe->u.hdr.rx_data+i+4),*(precvframe->u.hdr.rx_data+i+5),
+							*(precvframe->u.hdr.rx_data+i+6),*(precvframe->u.hdr.rx_data+i+7)));
+					}
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n ======demp packet end [len=%d]======\n",precvframe->u.hdr.len));
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n hrdlen=%d, \n",prxattrib->hdrlen));
+				}
+
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("ra=0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x psecuritypriv->binstallGrpkey=%d ",
+					prxattrib->ra[0],prxattrib->ra[1],prxattrib->ra[2],
+					prxattrib->ra[3],prxattrib->ra[4],prxattrib->ra[5],psecuritypriv->binstallGrpkey));
+
+				if(prxattrib->bdecrypted ==_TRUE)
+				{
+					rtw_handle_tkip_mic_err(adapter,(u8)IS_MCAST(prxattrib->ra));
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d ",prxattrib->bdecrypted));
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d ",prxattrib->bdecrypted));
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d ",prxattrib->bdecrypted));
+				}
+
+				res=_FAIL;
+
+			}
+			else{
+				//mic checked ok
+				if((psecuritypriv->bcheck_grpkey ==_FALSE)&&(IS_MCAST(prxattrib->ra)==_TRUE)){
+					psecuritypriv->bcheck_grpkey =_TRUE;
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->bcheck_grpkey =_TRUE"));
+				}
+			}
+
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic: rtw_get_stainfo==NULL!!!\n"));
+		}
+
+		recvframe_pull_tail(precvframe, 8);
+
+	}
+
+exit:
+
+_func_exit_;
+
+	return res;
+
+}
+
+//decrypt and set the ivlen,icvlen of the recv_frame
+static union recv_frame * decryptor(_adapter *padapter,union recv_frame *precv_frame)
+{
+
+	struct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;
+	struct security_priv *psecuritypriv=&padapter->securitypriv;
+	union recv_frame *return_packet=precv_frame;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x\n",prxattrib->bdecrypted,prxattrib->encrypt));
+
+	if((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==_TRUE)))
+	{
+		psecuritypriv->hw_decrypted=_FALSE;
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("prxstat->decrypted==0 psecuritypriv->hw_decrypted=_FALSE\n"));
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("perfrom software decryption! \n"));
+
+		//printk("perfrom software decryption!\n");
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_notice_,("###  software decryption!\n"));
+		switch(prxattrib->encrypt){
+		case _WEP40_:
+		case _WEP104_:
+			rtw_wep_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _TKIP_:
+			rtw_tkip_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _AES_:
+			rtw_aes_decrypt(padapter, (u8 * )precv_frame);
+			break;
+		default:
+				break;
+		}
+	}
+	else if(prxattrib->bdecrypted==1)
+	{
+#if 0
+		if((prxstat->icv==1)&&(prxattrib->encrypt!=_AES_))
+		{
+			psecuritypriv->hw_decrypted=_FALSE;
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->hw_decrypted=_FALSE"));
+
+			rtw_free_recvframe(precv_frame, &padapter->recvpriv.free_recv_queue);
+
+			return_packet=NULL;
+
+		}
+		else
+#endif
+		{
+			psecuritypriv->hw_decrypted=_TRUE;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("### psecuritypriv->hw_decrypted=_TRUE\n"));
+
+		}
+	}
+
+	//recvframe_chkmic(adapter, precv_frame);   //move to recvframme_defrag function
+
+_func_exit_;
+
+	return return_packet;
+
+}
+//###set the security information in the recv_frame
+static union recv_frame * portctrl(_adapter *adapter,union recv_frame * precv_frame)
+{
+	u8   *psta_addr,*ptr;
+	uint  auth_alg;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info * psta;
+	struct	sta_priv *pstapriv ;
+	union recv_frame * prtnframe;
+	u16	ether_type=0;
+	u16  eapol_type = 0x888e;//for Funia BD's WPA issue  
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+
+_func_enter_;
+
+	pstapriv = &adapter->stapriv;
+	ptr=get_recvframe_data(precv_frame);
+	pfhdr=&precv_frame->u.hdr;
+	psta_addr=pfhdr->attrib.ta;
+	psta=rtw_get_stainfo(pstapriv, psta_addr);
+
+	auth_alg=adapter->securitypriv.dot11AuthAlgrthm;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:adapter->securitypriv.dot11AuthAlgrthm= 0x%d\n",adapter->securitypriv.dot11AuthAlgrthm));
+
+	if(auth_alg==2)
+	{
+
+	if ((psta!=NULL) && (psta->ieee8021x_blocked))
+	{
+		//blocked
+		//only accept EAPOL frame
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:psta->ieee8021x_blocked==1\n"));
+
+		prtnframe=precv_frame;
+
+				//get ether_type
+		ptr=ptr+pfhdr->attrib.hdrlen+pfhdr->attrib.iv_len+LLC_HEADER_SIZE;
+		_rtw_memcpy(&ether_type,ptr, 2);
+		ether_type= ntohs((unsigned short )ether_type);
+
+		if (ether_type == eapol_type) {
+			prtnframe=precv_frame;
+		} else {
+			//free this frame
+			rtw_free_recvframe(precv_frame, &adapter->recvpriv.free_recv_queue);
+			prtnframe=NULL;
+		}
+			
+	}
+	else
+	{
+		//allowed
+		//check decryption status, and decrypt the frame if needed
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:psta->ieee8021x_blocked==0\n"));
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:precv_frame->hdr.attrib.privacy=%x\n",precv_frame->u.hdr.attrib.privacy));
+
+		//prxstat=(struct recv_stat *)(precv_frame->u.hdr.rx_head);
+		if(pattrib->bdecrypted==0)
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:prxstat->decrypted=%x\n", pattrib->bdecrypted));
+
+		prtnframe=precv_frame;
+		//check is the EAPOL frame or not (Rekey)
+		if(ether_type == eapol_type){
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type == 0x888e\n"));
+			//check Rekey
+
+			prtnframe=precv_frame;
+		}
+		else{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type = 0x%.4x\n",ether_type));
+		}
+		
+	}
+
+	}
+	else
+	{
+		prtnframe=precv_frame;
+	}
+
+_func_exit_;
+
+		return prtnframe;
+
+}
+
+static sint recv_decache(union recv_frame *precv_frame, u8 bretry, struct stainfo_rxcache *prxcache)
+{
+	sint tid = precv_frame->u.hdr.attrib.priority;
+
+	u16 seq_ctrl = ( (precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
+		(precv_frame->u.hdr.attrib.frag_num & 0xf);
+
+_func_enter_;
+
+	if(tid>15)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_decache, (tid>15)! seq_ctrl=0x%x, tid=0x%x\n", seq_ctrl, tid));
+
+		return _FAIL;
+	}
+
+	if(1)//if(bretry)
+	{
+		if(seq_ctrl == prxcache->tid_rxseq[tid])
+		{
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_decache, seq_ctrl=0x%x, tid=0x%x, tid_rxseq=0x%x\n", seq_ctrl, tid, prxcache->tid_rxseq[tid]));
+
+			return _FAIL;
+		}
+	}
+
+	prxcache->tid_rxseq[tid] = seq_ctrl;
+
+_func_exit_;
+
+	return _SUCCESS;
+
+}
+
+static void process_null_data(_adapter *padapter, union recv_frame *precv_frame)
+{
+#ifdef CONFIG_AP_MODE
+	unsigned char pwrbit;
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *psta=NULL;
+
+	psta = rtw_get_stainfo(pstapriv, pattrib->src);
+
+	pwrbit = GetPwrMgt(ptr);
+
+	if(psta)
+	{
+		if(pwrbit)
+		{
+			psta->state |= WIFI_SLEEP_STATE;
+			pstapriv->sta_dz_bitmap |= BIT(psta->aid-1);
+		}
+		else
+		{
+			if(psta->state & WIFI_SLEEP_STATE)
+			{
+				psta->state ^= WIFI_SLEEP_STATE;
+
+				pstapriv->sta_dz_bitmap &= ~BIT(psta->aid-1);
+				
+				wakeup_sta_to_xmit(padapter, psta);
+
+			}
+		}
+
+	}
+
+#endif
+}
+
+static sint sta2sta_data_frame(
+	_adapter *adapter,
+	union recv_frame *precv_frame,
+	struct sta_info**psta
+)
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	sint ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	struct	sta_priv 		*pstapriv = &adapter->stapriv;
+	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	u8 * sta_addr = NULL;
+
+	sint bmcast = IS_MCAST(pattrib->dst);
+
+_func_enter_;
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+	{
+
+		// filter packets that SA is myself or multicast or broadcast
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself \n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		if( (!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast) ){
+			ret= _FAIL;
+			goto exit;
+		}
+
+		if( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		   _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		   (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) ) {
+			ret= _FAIL;
+			goto exit;
+		}
+
+		sta_addr = pattrib->src;
+
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	{
+		// For Station mode, sa and bssid should always be BSSID, and DA is my mac-address
+		if(!_rtw_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN) )
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("bssid != TA under STATION_MODE; drop pkt\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		sta_addr = pattrib->bssid;
+
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+		if (bmcast)
+		{
+			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
+			if (!IS_MCAST(pattrib->bssid)){
+					ret= _FAIL;
+					goto exit;
+			}
+		}
+		else // not mc-frame
+		{
+			// For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
+			if(!_rtw_memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {
+				ret= _FAIL;
+				goto exit;
+			}
+
+			sta_addr = pattrib->src;
+		}
+
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	{
+		_rtw_memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		sta_addr = mybssid;
+	}
+	else
+	{
+		ret  = _FAIL;
+	}
+
+
+
+	if(bmcast)
+		*psta = rtw_get_bcmc_stainfo(adapter);
+	else
+		*psta = rtw_get_stainfo(pstapriv, sta_addr); // get ap_info
+
+	if (*psta == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under sta2sta_data_frame ; drop pkt\n"));
+#ifdef CONFIG_MP_INCLUDED
+		if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		adapter->mppriv.rx_pktloss++;
+#endif
+		ret= _FAIL;
+		goto exit;
+	}
+
+exit:
+_func_exit_;
+	return ret;
+
+}
+
+
+static sint ap2sta_data_frame(
+	_adapter *adapter,
+	union recv_frame *precv_frame,
+	struct sta_info**psta )
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	sint ret = _SUCCESS;
+	struct	sta_priv 		*pstapriv = &adapter->stapriv;
+	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+
+	sint bmcast = IS_MCAST(pattrib->dst);
+
+_func_enter_;
+
+	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+#ifndef CONFIG_DRVEXT_MODULE
+		&& (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+#endif
+		)
+	{
+
+		// if NULL-frame, drop packet
+		if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" NULL frame \n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		//drop QoS-SubType Data, including QoS NULL, excluding QoS-Data
+		if( (GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE )== WIFI_QOS_DATA_TYPE)
+		{
+			if(GetFrameSubType(ptr)&(BIT(4)|BIT(5)|BIT(6)))
+			{
+				ret= _FAIL;
+				goto exit;
+			}
+
+		}
+
+		// filter packets that SA is myself or multicast or broadcast
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself \n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// da should be for me
+		if((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" ap2sta_data_frame:  compare DA fail; DA= %x:%x:%x:%x:%x:%x \n",
+					pattrib->dst[0],
+					pattrib->dst[1],
+					pattrib->dst[2],
+					pattrib->dst[3],
+					pattrib->dst[4],
+					pattrib->dst[5]));
+
+			ret= _FAIL;
+			goto exit;
+		}
+
+
+		// check BSSID
+		if( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" ap2sta_data_frame:  compare BSSID fail ; BSSID=%x:%x:%x:%x:%x:%x\n",
+				pattrib->bssid[0],
+				pattrib->bssid[1],
+				pattrib->bssid[2],
+				pattrib->bssid[3],
+				pattrib->bssid[4],
+				pattrib->bssid[5]));
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("mybssid= %x:%x:%x:%x:%x:%x\n",
+				mybssid[0],
+				mybssid[1],
+				mybssid[2],
+				mybssid[3],
+				mybssid[4],
+				mybssid[5]));
+
+			ret= _FAIL;
+			goto exit;
+		}
+
+		if(bmcast)
+			*psta = rtw_get_bcmc_stainfo(adapter);
+		else
+			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get ap_info
+
+		if (*psta == NULL) {
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("ap2sta: can't get psta under STATION_MODE ; drop pkt\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+	}
+	else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) &&
+		     (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
+	{
+		_rtw_memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		//
+		_rtw_memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
+
+
+		*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+		if (*psta == NULL) {
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under MP_MODE ; drop pkt\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+
+	}
+	else
+	{
+		ret = _FAIL;
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+
+}
+
+static sint sta2ap_data_frame(
+	_adapter *adapter,
+	union recv_frame *precv_frame,
+	struct sta_info**psta )
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+	struct	sta_priv 		*pstapriv = &adapter->stapriv;
+	struct	security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	unsigned char *mybssid  = get_bssid(pmlmepriv);	
+	sint ret=_SUCCESS;
+
+_func_enter_;
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+			//For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR
+			if(!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))
+			{
+					ret= _FAIL;
+					goto exit;
+				}
+
+			*psta = rtw_get_stainfo(pstapriv, pattrib->src);
+
+			if (*psta == NULL)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under AP_MODE; drop pkt\n"));
+				ret= _FAIL;
+				goto exit;
+			}
+
+			// if NULL-frame, drop packet
+			if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" NULL frame \n"));
+
+				process_null_data(adapter, precv_frame);
+
+				ret= _FAIL;
+				goto exit;
+			}
+
+			//drop QoS-SubType Data, including QoS NULL, excluding QoS-Data
+			if( (GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE )== WIFI_QOS_DATA_TYPE)
+			{
+				if(GetFrameSubType(ptr)&(BIT(4)|BIT(5)|BIT(6)))
+				{
+					ret= _FAIL;
+					goto exit;
+				}
+			}
+
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+
+}
+
+static sint validate_recv_ctrl_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("+validate_recv_ctrl_frame\n"));
+	//DBG_871X("+validate_recv_ctrl_frame\n");
+
+	return _FAIL;
+}
+
+static sint validate_recv_mgnt_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_, ("+validate_recv_mgnt_frame\n"));
+
+#if 0
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+#ifdef CONFIG_NATIVEAP_MLME		
+	        mgt_dispatcher(adapter, precv_frame);
+#else
+		hostapd_mlme_rx(adapter, precv_frame);
+#endif	
+	}
+	else
+	{
+		mgt_dispatcher(adapter, precv_frame);
+	}
+#endif
+
+	mgt_dispatcher(adapter, precv_frame);
+
+	return _SUCCESS;
+
+}
+
+
+static sint validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+	int res;
+	u8 bretry;
+	u8 *psa, *pda, *pbssid;
+	struct sta_info *psta = NULL;
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib	*pattrib = & precv_frame->u.hdr.attrib;
+	struct sta_priv 	*pstapriv = &adapter->stapriv;
+	struct security_priv	*psecuritypriv = &adapter->securitypriv;	
+	sint ret = _SUCCESS;
+
+_func_enter_;
+
+	bretry = GetRetry(ptr);
+	pda = get_da(ptr);
+	psa = get_sa(ptr);
+	pbssid = get_hdr_bssid(ptr);
+
+	if(pbssid == NULL){
+		ret= _FAIL;
+		goto exit;
+	}
+
+	_rtw_memcpy(pattrib->dst, pda, ETH_ALEN);
+	_rtw_memcpy(pattrib->src, psa, ETH_ALEN);
+
+	_rtw_memcpy(pattrib->bssid, pbssid, ETH_ALEN);
+
+	switch(pattrib->to_fr_ds)
+	{
+		case 0:
+			_rtw_memcpy(pattrib->ra, pda, ETH_ALEN);
+			_rtw_memcpy(pattrib->ta, psa, ETH_ALEN);
+			res= sta2sta_data_frame(adapter, precv_frame, &psta);
+			break;
+
+		case 1:
+			_rtw_memcpy(pattrib->ra, pda, ETH_ALEN);
+			_rtw_memcpy(pattrib->ta, pbssid, ETH_ALEN);
+			res= ap2sta_data_frame(adapter, precv_frame, &psta);
+			break;
+
+		case 2:
+			_rtw_memcpy(pattrib->ra, pbssid, ETH_ALEN);
+			_rtw_memcpy(pattrib->ta, psa, ETH_ALEN);
+			res= sta2ap_data_frame(adapter, precv_frame, &psta);
+			break;
+
+		case 3:
+			_rtw_memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
+			_rtw_memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
+			res=_FAIL;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" case 3\n"));
+			break;
+
+		default:
+			res=_FAIL;
+			break;
+
+	}
+
+	if( (!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst))){
+		adapter->recvpriv.NumRxUnicastOkInPeriod++;
+	}
+
+	if(res==_FAIL){
+		//RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,(" after to_fr_ds_chk; res = fail \n"));
+		ret= res;
+		goto exit;
+	}
+
+
+	if(psta==NULL){
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" after to_fr_ds_chk; psta==NULL \n"));
+		ret= _FAIL;
+		goto exit;
+	}
+	
+	//psta->rssi = prxcmd->rssi;
+	//psta->signal_quality= prxcmd->sq;
+	precv_frame->u.hdr.psta = psta;
+		
+
+	pattrib->amsdu=0;
+	//parsing QC field
+	if(pattrib->qos == 1)
+	{
+		pattrib->priority = GetPriority((ptr + 24));
+		pattrib->ack_policy =GetAckpolicy((ptr + 24));
+		pattrib->amsdu = GetAMsdu((ptr + 24));
+		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 32 : 26;
+	}
+	else
+	{
+		pattrib->priority=0;
+		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 30 : 24;
+	}
+
+
+	if(pattrib->order)//HT-CTRL 11n
+	{
+		pattrib->hdrlen += 4;
+	}
+
+	precv_frame->u.hdr.preorder_ctrl = &psta->recvreorder_ctrl[pattrib->priority];
+
+	// decache, drop duplicate recv packets
+	if(recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("decache : drop pkt\n"));
+		ret= _FAIL;
+		goto exit;
+	}
+
+	if(pattrib->privacy){
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("validate_recv_data_frame:pattrib->privacy=%x\n", pattrib->privacy));
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n ^^^^^^^^^^^IS_MCAST(pattrib->ra(0x%02x))=%d^^^^^^^^^^^^^^^6\n", pattrib->ra[0],IS_MCAST(pattrib->ra)));
+
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, IS_MCAST(pattrib->ra));
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n pattrib->encrypt=%d\n",pattrib->encrypt));
+
+		SET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len, pattrib->encrypt);
+	}
+	else
+	{
+		pattrib->encrypt = 0;
+		pattrib->iv_len = pattrib->icv_len = 0;
+	}
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+
+static sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
+{
+	//shall check frame subtype, to / from ds, da, bssid
+
+	//then call check if rx seq/frag. duplicated.
+
+	u8 type;
+	u8 subtype;
+	sint retval = _SUCCESS;
+
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(adapter);	
+
+	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
+
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	u8  ver =(unsigned char) (*ptr)&0x3 ;
+ 
+_func_enter_;
+
+
+
+
+	//add version chk
+	if(ver!=0){
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail! (ver!=0)\n"));
+		retval= _FAIL;
+		goto exit;
+	}
+
+	type =  GetFrameType(ptr);
+	subtype = GetFrameSubType(ptr); //bit(7)~bit(2)
+
+	pattrib->to_fr_ds = get_tofr_ds(ptr);
+
+	pattrib->frag_num = GetFragNum(ptr);
+	pattrib->seq_num = GetSequence(ptr);
+
+	pattrib->pw_save = GetPwrMgt(ptr);
+	pattrib->mfrag = GetMFrag(ptr);
+	pattrib->mdata = GetMData(ptr);
+	pattrib->privacy = GetPrivacy(ptr);
+	pattrib->order = GetOrder(ptr);
+#if 0
+
+if(pHalData->bDumpRxPkt ==1){
+	int i;
+	DBG_871X("############################# \n");
+	
+	for(i=0; i<64;i=i+8)
+		DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
+		*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
+	DBG_871X("############################# \n");
+}
+else if(pHalData->bDumpRxPkt ==2){
+	if(type== WIFI_MGT_TYPE){
+		int i;
+		DBG_871X("############################# \n");
+
+		for(i=0; i<64;i=i+8)
+			DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
+			*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
+		DBG_871X("############################# \n");
+	}
+}
+else if(pHalData->bDumpRxPkt ==3){
+	if(type== WIFI_DATA_TYPE){
+		int i;
+		DBG_871X("############################# \n");
+		
+		for(i=0; i<64;i=i+8)
+			DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
+			*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
+		DBG_871X("############################# \n");
+	}
+}
+
+#endif
+	switch (type)
+	{
+		case WIFI_MGT_TYPE: //mgnt
+			retval = validate_recv_mgnt_frame(adapter, precv_frame);
+			if (retval == _FAIL)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_mgnt_frame fail\n"));
+			}
+			retval = _FAIL; // only data frame return _SUCCESS
+			break;
+		case WIFI_CTRL_TYPE: //ctrl
+			retval = validate_recv_ctrl_frame(adapter, precv_frame);
+			if (retval == _FAIL)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_ctrl_frame fail\n"));
+			}
+			break;
+		case WIFI_DATA_TYPE: //data			
+			pattrib->qos = (subtype & BIT(7))? 1:0;
+			retval = validate_recv_data_frame(adapter, precv_frame);
+			if (retval == _FAIL)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail\n"));
+			}
+			break;
+		default:
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail! type=0x%x\n", type));
+			retval = _FAIL;
+			break;
+	}
+
+exit:
+
+_func_exit_;
+
+	return retval;
+}
+
+
+//remove the wlanhdr and add the eth_hdr
+#if 1
+static sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
+{
+	sint	rmv_len;
+	u16	eth_type, len;
+	u8	bsnaphdr;
+	u8	*psnap_type;
+	struct ieee80211_snap_hdr	*psnap;
+	
+	sint ret=_SUCCESS;
+	_adapter			*adapter =precvframe->u.hdr.adapter;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	u8	*ptr = get_recvframe_data(precvframe) ; // point to frame_ctrl field
+	struct rx_pkt_attrib *pattrib = & precvframe->u.hdr.attrib;
+
+_func_enter_;
+
+	if(pattrib->encrypt){
+		recvframe_pull_tail(precvframe, pattrib->icv_len);	
+	}
+
+	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
+	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
+	/* convert hdr + possible LLC headers into Ethernet header */
+	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
+	if((_rtw_memcmp(psnap, rfc1042_header, SNAP_SIZE) &&
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == _FALSE) && 
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==_FALSE) )||
+		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		 _rtw_memcmp(psnap, bridge_tunnel_header, SNAP_SIZE)){
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+		bsnaphdr = _TRUE;
+	}
+	else {
+		/* Leave Ethernet header part of hdr and full payload */
+		bsnaphdr = _FALSE;
+	}
+
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
+	len = precvframe->u.hdr.len - rmv_len;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", pattrib->hdrlen,  pattrib->iv_len));
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))	   	
+	{
+		ptr += rmv_len ;	
+		*ptr = 0x87;
+		*(ptr+1) = 0x12;
+
+		eth_type = 0x8712;
+		// append rx status for mp test packets
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);
+		_rtw_memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr+=24;
+	}
+	else {
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+ (bsnaphdr?2:0)));
+	}
+
+	_rtw_memcpy(ptr, pattrib->dst, ETH_ALEN);
+	_rtw_memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	if(!bsnaphdr) {
+		len = htons(len);
+		_rtw_memcpy(ptr+12, &len, 2);
+	}
+
+_func_exit_;	
+	return ret;
+
+}
+
+#else
+
+sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
+{
+	sint rmv_len;
+	u16 eth_type;
+	u8	bsnaphdr;
+	u8	*psnap_type;
+	struct ieee80211_snap_hdr	*psnap;
+
+	sint ret=_SUCCESS;
+	_adapter	*adapter =precvframe->u.hdr.adapter;
+	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	u8* ptr = get_recvframe_data(precvframe) ; // point to frame_ctrl field
+	struct rx_pkt_attrib *pattrib = & precvframe->u.hdr.attrib;
+	struct _vlan *pvlan = NULL;
+
+_func_enter_;
+
+	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
+	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
+	if (psnap->dsap==0xaa && psnap->ssap==0xaa && psnap->ctrl==0x03)
+	{
+		if (_rtw_memcmp(psnap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN))
+			bsnaphdr=_TRUE;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;	
+		else if (_rtw_memcmp(psnap->oui, SNAP_HDR_APPLETALK_DDP, WLAN_IEEE_OUI_LEN) &&
+			_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_DDP, 2) )
+			bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK;
+		else if (_rtw_memcmp( psnap->oui, oui_8021h, WLAN_IEEE_OUI_LEN))
+			bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_TUNNEL;
+		else {
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("drop pkt due to invalid frame format!\n"));
+			ret= _FAIL;
+			goto exit;
+		}
+
+	} else
+		bsnaphdr=_FALSE;//wlan_pkt_format = WLAN_PKT_FORMAT_OTHERS;
+
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n", pattrib->hdrlen,  pattrib->iv_len));
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	{
+		ptr += rmv_len ;
+		*ptr = 0x87;
+		*(ptr+1) = 0x12;
+
+		//back to original pointer
+		ptr -= rmv_len;
+	}
+
+	ptr += rmv_len ;
+
+	_rtw_memcpy(&eth_type, ptr, 2);
+	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+	ptr +=2;
+
+	if(pattrib->encrypt){
+		recvframe_pull_tail(precvframe, pattrib->icv_len);
+	}
+
+	if(eth_type == 0x8100) //vlan
+	{
+		pvlan = (struct _vlan *) ptr;
+
+		//eth_type = get_vlan_encap_proto(pvlan);
+		//eth_type = pvlan->h_vlan_encapsulated_proto;//?
+		rmv_len += 4;
+		ptr+=4;
+	}
+
+	if(eth_type==0x0800)//ip
+	{
+		//struct iphdr*  piphdr = (struct iphdr*) ptr;
+		//__u8 tos = (unsigned char)(pattrib->priority & 0xff);
+
+		//piphdr->tos = tos;
+
+		//if (piphdr->protocol == 0x06)
+		//{
+		//	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("@@@===recv tcp len:%d @@@===\n", precvframe->u.hdr.len));
+		//}
+	}
+	else if(eth_type==0x8712)// append rx status for mp test packets
+	{
+		//ptr -= 16;
+		//_rtw_memcpy(ptr, get_rxmem(precvframe), 16);
+	}
+	else
+	{
+#ifdef PLATFORM_OS_XP
+		NDIS_PACKET_8021Q_INFO VlanPriInfo;
+		UINT32 UserPriority = precvframe->u.hdr.attrib.priority;
+		UINT32 VlanID = (pvlan!=NULL ? get_vlan_id(pvlan) : 0 );
+
+		VlanPriInfo.Value =          // Get current value.
+				NDIS_PER_PACKET_INFO_FROM_PACKET(precvframe->u.hdr.pkt, Ieee8021QInfo);
+
+		VlanPriInfo.TagHeader.UserPriority = UserPriority;
+		VlanPriInfo.TagHeader.VlanId =  VlanID ;
+
+		VlanPriInfo.TagHeader.CanonicalFormatId = 0; // Should be zero.
+		VlanPriInfo.TagHeader.Reserved = 0; // Should be zero.
+		NDIS_PER_PACKET_INFO_FROM_PACKET(precvframe->u.hdr.pkt, Ieee8021QInfo) = VlanPriInfo.Value;
+#endif
+	}
+
+	if(eth_type==0x8712)// append rx status for mp test packets
+	{
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);
+		_rtw_memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr+=24;
+	}
+	else
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2));
+
+	_rtw_memcpy(ptr, pattrib->dst, ETH_ALEN);
+	_rtw_memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	eth_type = htons((unsigned short)eth_type) ;
+	_rtw_memcpy(ptr+12, &eth_type, 2);
+
+exit:
+
+_func_exit_;
+
+	return ret;
+}
+#endif
+
+static void count_rx_stats(_adapter *padapter, union recv_frame *prframe)
+{
+	int sz;
+	struct sta_info *psta = NULL;
+	struct stainfo_stats *pstats = NULL;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	sz = get_recvframe_len(prframe);
+	precvpriv->rx_bytes += sz;
+
+	psta = prframe->u.hdr.psta;
+
+	if(psta)
+	{
+		pstats = &psta->sta_stats;
+
+		pstats->rx_pkts++;
+		pstats->rx_bytes += sz;
+	}
+
+
+}
+
+
+//perform defrag
+static union recv_frame * recvframe_defrag(_adapter *adapter,_queue *defrag_q)
+{
+	_list	 *plist, *phead;
+	u8	*data,wlanhdr_offset;
+	u8	curfragnum;
+	struct recv_frame_hdr *pfhdr,*pnfhdr;
+	union recv_frame* prframe, *pnextrframe;
+	_queue	*pfree_recv_queue;
+
+_func_enter_;
+
+	curfragnum=0;
+	pfree_recv_queue=&adapter->recvpriv.free_recv_queue;
+
+	phead = get_list_head(defrag_q);
+	plist = get_next(phead);
+	prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+	pfhdr=&prframe->u.hdr;
+	list_delete(&(prframe->u.list));
+
+	if(curfragnum!=pfhdr->attrib.frag_num)
+	{
+		//the first fragment number must be 0
+		//free the whole queue
+		rtw_free_recvframe(prframe, pfree_recv_queue);
+		rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+
+		return NULL;
+	}
+
+	curfragnum++;
+
+	plist= get_list_head(defrag_q);
+
+	plist = get_next(plist);
+
+	data=get_recvframe_data(prframe);
+
+	while(rtw_end_of_queue_search(phead, plist) == _FALSE)
+	{
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame , u);
+		pnfhdr=&pnextrframe->u.hdr;
+
+
+		//check the fragment sequence  (2nd ~n fragment frame)
+
+		if(curfragnum!=pnfhdr->attrib.frag_num)
+		{
+			//the fragment number must be increasing  (after decache)
+			//release the defrag_q & prframe
+			rtw_free_recvframe(prframe, pfree_recv_queue);
+			rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+			return NULL;
+		}
+
+		curfragnum++;
+
+		//copy the 2nd~n fragment frame's payload to the first fragment
+		//get the 2nd~last fragment frame's payload
+
+		wlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;
+
+		recvframe_pull(pnextrframe, wlanhdr_offset);
+
+		//append  to first fragment frame's tail (if privacy frame, pull the ICV)
+		recvframe_pull_tail(prframe, pfhdr->attrib.icv_len);
+
+		//memcpy
+		_rtw_memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
+
+		recvframe_put(prframe, pnfhdr->len);
+
+		pfhdr->attrib.icv_len=pnfhdr->attrib.icv_len;
+		plist = get_next(plist);
+
+	};
+
+	//free the defrag_q queue and return the prframe
+	rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Performance defrag!!!!!\n"));
+
+_func_exit_;
+
+	return prframe;
+}
+
+
+//check if need to defrag, if needed queue the frame to defrag_q
+static union recv_frame * recvframe_chk_defrag(_adapter *padapter,union recv_frame* precv_frame)
+{
+	u8	ismfrag;
+	u8	fragnum;
+	u8	*psta_addr;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info * psta;
+	struct	sta_priv *pstapriv ;
+	_list	 *phead;
+	union recv_frame* prtnframe=NULL;
+	_queue *pfree_recv_queue, *pdefrag_q;
+
+_func_enter_;
+
+	pstapriv = &padapter->stapriv;
+
+	pfhdr=&precv_frame->u.hdr;
+
+	pfree_recv_queue=&padapter->recvpriv.free_recv_queue;
+
+	//need to define struct of wlan header frame ctrl
+	ismfrag= pfhdr->attrib.mfrag;
+	fragnum=pfhdr->attrib.frag_num;
+
+	psta_addr=pfhdr->attrib.ta;
+	psta=rtw_get_stainfo(pstapriv, psta_addr);
+	if (psta==NULL)
+		pdefrag_q = NULL;
+	else
+		pdefrag_q=&psta->sta_recvpriv.defrag_q;
+
+	if ((ismfrag==0) && (fragnum==0))
+	{
+		prtnframe = precv_frame;//isn't a fragment frame
+	}
+
+	if (ismfrag==1)
+	{
+		//0~(n-1) fragment frame
+		//enqueue to defraf_g
+		if(pdefrag_q != NULL)
+		{
+			if(fragnum==0)
+			{
+				//the first fragment
+				if(_rtw_queue_empty(pdefrag_q) == _FALSE)
+				{
+					//free current defrag_q
+					rtw_free_recvframe_queue(pdefrag_q, pfree_recv_queue);
+				}
+			}
+
+
+			//Then enqueue the 0~(n-1) fragment into the defrag_q
+
+			//_rtw_spinlock(&pdefrag_q->lock);
+			phead = get_list_head(pdefrag_q);
+			rtw_list_insert_tail(&pfhdr->list, phead);
+			//_rtw_spinunlock(&pdefrag_q->lock);
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Enqueuq: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
+
+			prtnframe=NULL;
+
+		}
+		else
+		{
+			//can't find this ta's defrag_queue, so free this recv_frame
+			rtw_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe=NULL;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag, fragnum));
+		}
+
+	}
+
+	if((ismfrag==0)&&(fragnum!=0))
+	{
+		//the last fragment frame
+		//enqueue the last fragment
+		if(pdefrag_q != NULL)
+		{
+			//_rtw_spinlock(&pdefrag_q->lock);
+			phead = get_list_head(pdefrag_q);
+			rtw_list_insert_tail(&pfhdr->list,phead);
+			//_rtw_spinunlock(&pdefrag_q->lock);
+
+			//call recvframe_defrag to defrag
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("defrag: ismfrag = %d, fragnum= %d\n", ismfrag, fragnum));
+			precv_frame = recvframe_defrag(padapter, pdefrag_q);
+			prtnframe=precv_frame;
+
+		}
+		else
+		{
+			//can't find this ta's defrag_queue, so free this recv_frame
+			rtw_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe=NULL;
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
+		}
+
+	}
+
+
+	if((prtnframe!=NULL)&&(prtnframe->u.hdr.attrib.privacy))
+	{
+		//after defrag we must check tkip mic code
+		if(recvframe_chkmic(padapter,  prtnframe)==_FAIL)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic(padapter,  prtnframe)==_FAIL\n"));
+			rtw_free_recvframe(prtnframe,pfree_recv_queue);
+			prtnframe=NULL;
+		}
+	}
+
+_func_exit_;
+
+	return prtnframe;
+
+}
+
+
+static int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
+{
+
+#ifdef PLATFORM_LINUX	//for amsdu TP improvement,Creator: Thomas 
+	int	a_len, padding_len;
+	u16	eth_type, nSubframe_Length;	
+	u8	nr_subframes, i;
+	unsigned char *data_ptr, *pdata;
+	struct rx_pkt_attrib *pattrib;
+	_pkt *sub_skb,*subframes[MAX_SUBFRAME_COUNT];
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int	ret = _SUCCESS;
+
+	nr_subframes = 0;
+
+	pattrib = &prframe->u.hdr.attrib;
+
+	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
+	
+	if(prframe->u.hdr.attrib.iv_len >0)
+	{
+		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
+	}
+
+	a_len = prframe->u.hdr.len;
+
+	pdata = prframe->u.hdr.rx_data;
+
+	while(a_len > ETH_HLEN) {
+		
+		/* Offset 12 denote 2 mac address */
+		nSubframe_Length = *((u16*)(pdata + 12));
+		//==m==>change the length order
+		nSubframe_Length = (nSubframe_Length>>8) + (nSubframe_Length<<8);
+		//ntohs(nSubframe_Length);
+
+		if( a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length) ) {
+			printk("nRemain_Length is %d and nSubframe_Length is : %d\n",a_len,nSubframe_Length);
+			goto exit;
+		}
+
+		/* move the data point to data content */
+		pdata += ETH_HLEN;
+		a_len -= ETH_HLEN;
+
+		/* Allocate new skb for releasing to upper layer */
+#ifdef CONFIG_SKB_COPY
+		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+		skb_reserve(sub_skb, 12);
+		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+		_rtw_memcpy(data_ptr, pdata, nSubframe_Length);
+#else
+		sub_skb = skb_clone(prframe->u.hdr.pkt, GFP_ATOMIC);
+		sub_skb->data = pdata;
+		sub_skb->len = nSubframe_Length;
+		sub_skb->tail = sub_skb->data + nSubframe_Length;
+#endif
+
+		//sub_skb->dev = padapter->pnetdev;
+		subframes[nr_subframes++] = sub_skb;
+		if(nr_subframes >= MAX_SUBFRAME_COUNT) {
+			printk("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+			break;
+		}
+
+		pdata += nSubframe_Length;
+		a_len -= nSubframe_Length;
+		if(a_len != 0) {
+			padding_len = 4 - ((nSubframe_Length + ETH_HLEN) & (4-1));
+			if(padding_len == 4) {
+				padding_len = 0;
+			}
+
+			if(a_len < padding_len) {
+				goto exit;
+			}
+			pdata += padding_len;
+			a_len -= padding_len;
+		}
+	}
+
+	for(i=0; i<nr_subframes; i++){
+		sub_skb = subframes[i];
+		/* convert hdr + possible LLC headers into Ethernet header */
+		eth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];
+		if (sub_skb->len >= 8 &&
+			((_rtw_memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) &&
+			  eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+			 _rtw_memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) )) {
+			/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+			skb_pull(sub_skb, SNAP_SIZE);
+			_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+			_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+		} else {
+			u16 len;
+			/* Leave Ethernet header part of hdr and full payload */
+			len = htons(sub_skb->len);
+			_rtw_memcpy(skb_push(sub_skb, 2), &len, 2);
+			_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+			_rtw_memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+		}
+
+		/* Indicat the packets to upper layer */
+		if (sub_skb) {
+			//_rtw_memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
+
+			sub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);
+			sub_skb->dev = padapter->pnetdev;
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+			if ( (pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1) ) {
+				sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+			} else {
+				sub_skb->ip_summed = CHECKSUM_NONE;
+			}
+#else /* !CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX */
+			sub_skb->ip_summed = CHECKSUM_NONE;
+#endif
+
+			netif_rx(sub_skb);
+		}
+	}
+
+exit:
+
+	prframe->u.hdr.len=0;
+	rtw_free_recvframe(prframe, pfree_recv_queue);//free this recv_frame
+	
+	return ret;
+#else
+	_irqL irql;
+	unsigned char *ptr, *pdata, *pbuf, *psnap_type;
+	union recv_frame *pnrframe, *pnrframe_new;
+	int a_len, mv_len, padding_len;
+	u16 eth_type, type_len;
+	u8 bsnaphdr;
+	struct ieee80211_snap_hdr	*psnap;
+	struct _vlan *pvlan;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int ret = _SUCCESS;
+#ifdef PLATFORM_WINDOWS
+	struct recv_buf *precvbuf = prframe->u.hdr.precvbuf;
+#endif
+	a_len = prframe->u.hdr.len - prframe->u.hdr.attrib.hdrlen;
+
+	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
+
+	if(prframe->u.hdr.attrib.iv_len >0)
+	{
+		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
+	}
+
+	pdata = prframe->u.hdr.rx_data;
+
+	prframe->u.hdr.len=0;
+
+	pnrframe = prframe;
+
+
+	do{
+
+		mv_len=0;
+		pnrframe->u.hdr.rx_data = pnrframe->u.hdr.rx_tail = pdata;
+		ptr = pdata;
+
+
+		_rtw_memcpy(pnrframe->u.hdr.attrib.dst, ptr, ETH_ALEN);
+		ptr+=ETH_ALEN;
+		_rtw_memcpy(pnrframe->u.hdr.attrib.src, ptr, ETH_ALEN);
+		ptr+=ETH_ALEN;
+
+		_rtw_memcpy(&type_len, ptr, 2);
+		type_len= ntohs((unsigned short )type_len);
+		ptr +=2;
+		mv_len += ETH_HLEN;
+
+		recvframe_put(pnrframe, type_len+ETH_HLEN);//update tail;
+
+		if(pnrframe->u.hdr.rx_data >= pnrframe->u.hdr.rx_tail || type_len<8)
+		{
+			//panic("pnrframe->u.hdr.rx_data >= pnrframe->u.hdr.rx_tail || type_len<8\n");
+
+			rtw_free_recvframe(pnrframe, pfree_recv_queue);
+
+			goto exit;
+		}
+
+		psnap=(struct ieee80211_snap_hdr *)(ptr);
+		psnap_type=ptr+SNAP_SIZE;
+		if (psnap->dsap==0xaa && psnap->ssap==0xaa && psnap->ctrl==0x03)
+		{
+			if ( _rtw_memcmp(psnap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN))
+			{
+				bsnaphdr=_TRUE;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;
+			}
+			else if (_rtw_memcmp(psnap->oui, SNAP_HDR_APPLETALK_DDP, WLAN_IEEE_OUI_LEN) &&
+					_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_DDP, 2) )
+			{
+				bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK;
+			}
+			else if (_rtw_memcmp( psnap->oui, oui_8021h, WLAN_IEEE_OUI_LEN))
+			{
+				bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_TUNNEL;
+			}
+			else
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("drop pkt due to invalid frame format!\n"));
+
+				//KeBugCheckEx(0x87123333, 0xe0, 0x4c, 0x87, 0xdd);
+
+				//panic("0x87123333, 0xe0, 0x4c, 0x87, 0xdd\n");
+
+				rtw_free_recvframe(pnrframe, pfree_recv_queue);
+
+				goto exit;
+			}
+
+		}
+		else
+		{
+			bsnaphdr=_FALSE;//wlan_pkt_format = WLAN_PKT_FORMAT_OTHERS;
+		}
+
+		ptr += (bsnaphdr?SNAP_SIZE:0);
+		_rtw_memcpy(&eth_type, ptr, 2);
+		eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+
+		mv_len+= 2+(bsnaphdr?SNAP_SIZE:0);
+		ptr += 2;//now move to iphdr;
+
+		pvlan = NULL;
+		if(eth_type == 0x8100) //vlan
+		{
+			pvlan = (struct _vlan *)ptr;
+			ptr+=4;
+			mv_len+=4;
+		}
+
+		if(eth_type==0x0800)//ip
+		{
+			struct iphdr*  piphdr = (struct iphdr*)ptr;
+
+
+			if (piphdr->protocol == 0x06)
+			{
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("@@@===recv tcp len:%d @@@===\n", pnrframe->u.hdr.len));
+			}
+		}
+#ifdef PLATFORM_OS_XP
+		else
+		{
+			NDIS_PACKET_8021Q_INFO VlanPriInfo;
+			UINT32 UserPriority = pnrframe->u.hdr.attrib.priority;
+			UINT32 VlanID = (pvlan!=NULL ? get_vlan_id(pvlan) : 0 );
+
+			VlanPriInfo.Value =          // Get current value.
+					NDIS_PER_PACKET_INFO_FROM_PACKET(pnrframe->u.hdr.pkt, Ieee8021QInfo);
+
+			VlanPriInfo.TagHeader.UserPriority = UserPriority;
+			VlanPriInfo.TagHeader.VlanId =  VlanID;
+
+			VlanPriInfo.TagHeader.CanonicalFormatId = 0; // Should be zero.
+			VlanPriInfo.TagHeader.Reserved = 0; // Should be zero.
+			NDIS_PER_PACKET_INFO_FROM_PACKET(pnrframe->u.hdr.pkt, Ieee8021QInfo) = VlanPriInfo.Value;
+
+		}
+#endif
+
+		pbuf = recvframe_pull(pnrframe, (mv_len-sizeof(struct ethhdr)));
+
+		_rtw_memcpy(pbuf, pnrframe->u.hdr.attrib.dst, ETH_ALEN);
+		_rtw_memcpy(pbuf+ETH_ALEN, pnrframe->u.hdr.attrib.src, ETH_ALEN);
+
+		eth_type = htons((unsigned short)eth_type) ;
+		_rtw_memcpy(pbuf+12, &eth_type, 2);
+
+		padding_len = (4) - ((type_len + ETH_HLEN)&(4-1));
+
+		a_len -= (type_len + ETH_HLEN + padding_len) ;
+
+
+#if 0
+
+	if(a_len > ETH_HLEN)
+	{
+		pnrframe_new = rtw_alloc_recvframe(pfree_recv_queue);
+		if(pnrframe_new)
+		{
+			_pkt *pskb_copy;
+			unsigned int copy_len  = pnrframe->u.hdr.len;
+
+			_rtw_init_listhead(&pnrframe_new->u.hdr.list);
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+			pskb_copy = dev_alloc_skb(copy_len+64);
+	#else
+			pskb_copy = netdev_alloc_skb(padapter->pnetdev, copy_len + 64);
+	#endif
+			if(pskb_copy==NULL)
+			{
+				printk("amsdu_to_msdu:can not all(ocate memory for skb copy\n");
+			}
+
+			pnrframe_new->u.hdr.pkt = pskb_copy;
+
+			_rtw_memcpy(pskb_copy->data, pnrframe->u.hdr.rx_data, copy_len);
+
+			pnrframe_new->u.hdr.rx_data = pnrframe->u.hdr.rx_data;
+			pnrframe_new->u.hdr.rx_tail = pnrframe->u.hdr.rx_data + copy_len;
+
+
+			if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+			{
+				rtw_recv_indicatepkt(padapter, pnrframe_new);//indicate this recv_frame
+			}
+			else
+			{
+				rtw_free_recvframe(pnrframe_new, pfree_recv_queue);//free this recv_frame
+			}
+
+		}
+		else
+		{
+			printk("amsdu_to_msdu:can not allocate memory for pnrframe_new\n");
+		}
+
+	}
+	else
+	{
+		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+		{
+			rtw_recv_indicatepkt(padapter, pnrframe);//indicate this recv_frame
+		}
+		else
+		{
+			rtw_free_recvframe(pnrframe, pfree_recv_queue);//free this recv_frame
+		}
+
+		pnrframe = NULL;
+
+	}
+
+#else
+
+		//padding_len = (4) - ((type_len + ETH_HLEN)&(4-1));
+
+		//a_len -= (type_len + ETH_HLEN + padding_len) ;
+
+		pnrframe_new = NULL;
+
+
+		if(a_len > ETH_HLEN)
+		{
+			pnrframe_new = rtw_alloc_recvframe(pfree_recv_queue);
+
+			if(pnrframe_new)
+			{
+
+
+				//pnrframe_new->u.hdr.precvbuf = precvbuf;//precvbuf is assigned before call rtw_init_recvframe()
+				//rtw_init_recvframe(pnrframe_new, precvpriv);
+				{
+						_pkt *pskb = pnrframe->u.hdr.pkt;
+						_rtw_init_listhead(&pnrframe_new->u.hdr.list);
+
+						pnrframe_new->u.hdr.len=0;
+
+#ifdef PLATFORM_LINUX
+						if(pskb)
+						{
+							pnrframe_new->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);
+						}
+#endif
+
+				}
+
+				pdata += (type_len + ETH_HLEN + padding_len);
+				pnrframe_new->u.hdr.rx_head = pnrframe_new->u.hdr.rx_data = pnrframe_new->u.hdr.rx_tail = pdata;
+				pnrframe_new->u.hdr.rx_end = pdata + a_len + padding_len;//
+
+#ifdef PLATFORM_WINDOWS
+				pnrframe_new->u.hdr.precvbuf=precvbuf;
+				_enter_critical_bh(&precvbuf->recvbuf_lock, &irql);
+				precvbuf->ref_cnt++;
+				_exit_critical_bh(&precvbuf->recvbuf_lock, &irql);
+#endif
+
+			}
+			else
+			{
+				//panic("pnrframe_new=%x\n", pnrframe_new);
+			}
+		}
+
+
+		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE) )
+		{
+			rtw_recv_indicatepkt(padapter, pnrframe);//indicate this recv_frame
+		}
+		else
+		{
+			rtw_free_recvframe(pnrframe, pfree_recv_queue);//free this recv_frame
+		}
+
+
+		pnrframe = NULL;
+		if(pnrframe_new)
+		{
+			pnrframe = pnrframe_new;
+		}
+
+
+#endif
+
+	}while(pnrframe);
+
+exit:
+
+	return ret;
+#endif
+
+}
+
+
+static int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)
+{
+	u8	wsize = preorder_ctrl->wsize_b;
+	u16	wend = (preorder_ctrl->indicate_seq + wsize -1) & 0xFFF;//% 4096;
+
+	// Rx Reorder initialize condition.
+	if (preorder_ctrl->indicate_seq == 0xFFFF)
+	{
+		preorder_ctrl->indicate_seq = seq_num;
+
+		//DbgPrint("check_indicate_seq, 1st->indicate_seq=%d\n", precvpriv->indicate_seq);
+	}
+
+	//DbgPrint("enter->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+
+	// Drop out the packet which SeqNum is smaller than WinStart
+	if( SN_LESS(seq_num, preorder_ctrl->indicate_seq) )
+	{
+		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
+
+		//DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+
+		return _FALSE;
+	}
+
+	//
+	// Sliding window manipulation. Conditions includes:
+	// 1. Incoming SeqNum is equal to WinStart =>Window shift 1
+	// 2. Incoming SeqNum is larger than the WinEnd => Window shift N
+	//
+	if( SN_EQUAL(seq_num, preorder_ctrl->indicate_seq) )
+	{
+		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
+	}
+	else if(SN_LESS(wend, seq_num))
+	{
+		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
+		//DbgPrint("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+
+		// boundary situation, when seq_num cross 0xFFF
+		if(seq_num >= (wsize - 1))
+			preorder_ctrl->indicate_seq = seq_num + 1 -wsize;
+		else
+			preorder_ctrl->indicate_seq = 0xFFF - (wsize - (seq_num + 1)) + 1;
+	}
+
+	//DbgPrint("exit->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+
+	return _TRUE;
+}
+
+
+static int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, union recv_frame *prframe)
+{
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+	_list	*phead, *plist;
+	union recv_frame *pnextrframe;
+	struct rx_pkt_attrib *pnextattrib;
+
+	//DbgPrint("+enqueue_reorder_recvframe()\n");
+
+	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//_rtw_spinlock_ex(&ppending_recvframe_queue->lock);
+
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+
+	while(rtw_end_of_queue_search(phead, plist) == _FALSE)
+	{
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pnextattrib = &pnextrframe->u.hdr.attrib;
+
+		if(SN_LESS(pnextattrib->seq_num, pattrib->seq_num))
+		{
+			plist = get_next(plist);
+		}
+		else if( SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
+		{
+			//Duplicate entry is found!! Do not insert current entry.
+			//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
+
+			//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+			return _FALSE;
+		}
+		else
+		{
+			break;
+		}
+
+		//DbgPrint("enqueue_reorder_recvframe():while\n");
+
+	}
+
+
+	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//_rtw_spinlock_ex(&ppending_recvframe_queue->lock);
+
+	list_delete(&(prframe->u.hdr.list));
+
+	rtw_list_insert_tail(&(prframe->u.hdr.list), plist);
+
+	//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
+	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+
+	//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
+	return _TRUE;
+
+}
+
+
+static int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced)
+{
+//	_irqL irql;
+	//u8 bcancelled;
+	_list	*phead, *plist;
+	union recv_frame *prframe;
+	struct rx_pkt_attrib *pattrib;
+	//u8 index = 0;
+	int bPktInBuf = _FALSE;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+	//DbgPrint("+recv_indicatepkts_in_order\n");
+
+	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//_rtw_spinlock_ex(&ppending_recvframe_queue->lock);
+
+	phead = 	get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+
+#if 0
+	// Check if there is any other indication thread running.
+	if(pTS->RxIndicateState == RXTS_INDICATE_PROCESSING)
+		return;
+#endif
+
+	// Handling some condition for forced indicate case.
+	if(bforced==_TRUE)
+	{
+		if(rtw_is_list_empty(phead))
+		{
+			// _exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+			//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
+			return _TRUE;
+		}
+	
+		 prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+	        pattrib = &prframe->u.hdr.attrib;	
+		preorder_ctrl->indicate_seq = pattrib->seq_num;		
+	}
+
+	// Prepare indication list and indication.
+	// Check if there is any packet need indicate.
+	while(!rtw_is_list_empty(phead))
+	{
+		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pattrib = &prframe->u.hdr.attrib;
+
+		if(!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num))
+		{
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+				 ("recv_indicatepkts_in_order: indicate=%d seq=%d amsdu=%d\n",
+				  preorder_ctrl->indicate_seq, pattrib->seq_num, pattrib->amsdu));
+
+#if 0
+			// This protect buffer from overflow.
+			if(index >= REORDER_WIN_SIZE)
+			{
+				RT_ASSERT(FALSE, ("IndicateRxReorderList(): Buffer overflow!! \n"));
+				bPktInBuf = TRUE;
+				break;
+			}
+#endif
+
+			plist = get_next(plist);
+			list_delete(&(prframe->u.hdr.list));
+
+			if(SN_EQUAL(preorder_ctrl->indicate_seq, pattrib->seq_num))
+			{
+				preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
+			}
+
+#if 0
+			index++;
+			if(index==1)
+			{
+				//Cancel previous pending timer.
+				//PlatformCancelTimer(Adapter, &pTS->RxPktPendingTimer);
+				if(bforced!=_TRUE)
+				{
+					//printk("_cancel_timer(&preorder_ctrl->reordering_ctrl_timer, &bcancelled);\n");
+					_cancel_timer(&preorder_ctrl->reordering_ctrl_timer, &bcancelled);
+				}
+			}
+#endif
+
+			//Set this as a lock to make sure that only one thread is indicating packet.
+			//pTS->RxIndicateState = RXTS_INDICATE_PROCESSING;
+
+			// Indicate packets
+			//RT_ASSERT((index<=REORDER_WIN_SIZE), ("RxReorderIndicatePacket(): Rx Reorder buffer full!! \n"));
+
+
+			//indicate this recv_frame
+			//DbgPrint("recv_indicatepkts_in_order, indicate_seq=%d, seq_num=%d\n", precvpriv->indicate_seq, pattrib->seq_num);
+			if(!pattrib->amsdu)
+			{
+				//printk("recv_indicatepkts_in_order, amsdu!=1, indicate_seq=%d, seq_num=%d\n", preorder_ctrl->indicate_seq, pattrib->seq_num);
+
+				if ((padapter->bDriverStopped == _FALSE) &&
+				    (padapter->bSurpriseRemoved == _FALSE))
+				{
+					rtw_recv_indicatepkt(padapter, prframe);		//indicate this recv_frame
+				}
+			}
+			else if(pattrib->amsdu==1)
+			{
+				if(amsdu_to_msdu(padapter, prframe)!=_SUCCESS)
+				{
+					rtw_free_recvframe(prframe, &precvpriv->free_recv_queue);
+				}
+			}
+			else
+			{
+				//error condition;
+			}
+
+
+			//Update local variables.
+			bPktInBuf = _FALSE;
+
+		}
+		else
+		{
+			bPktInBuf = _TRUE;
+			break;
+		}
+
+		//DbgPrint("recv_indicatepkts_in_order():while\n");
+
+	}
+
+	//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
+	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+/*
+	//Release the indication lock and set to new indication step.
+	if(bPktInBuf)
+	{
+		// Set new pending timer.
+		//pTS->RxIndicateState = RXTS_INDICATE_REORDER;
+		//PlatformSetTimer(Adapter, &pTS->RxPktPendingTimer, pHTInfo->RxReorderPendingTime);
+		//printk("_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME)\n");
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+	}
+	else
+	{
+		//pTS->RxIndicateState = RXTS_INDICATE_IDLE;
+	}
+*/
+	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+
+	//return _TRUE;
+	return bPktInBuf;
+
+}
+
+
+static int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
+{
+	_irqL irql;
+	int retval = _SUCCESS;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
+	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+	if(!pattrib->amsdu)
+	{
+		//s1.
+		wlanhdr_to_ethhdr(prframe);
+
+		if(pattrib->qos !=1 /*|| pattrib->priority!=0 || IS_MCAST(pattrib->ra)*/)
+		{
+			if ((padapter->bDriverStopped == _FALSE) &&
+			    (padapter->bSurpriseRemoved == _FALSE))
+			{
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_indicatepkt_reorder -recv_func rtw_recv_indicatepkt\n" ));
+
+				rtw_recv_indicatepkt(padapter, prframe);
+				return _SUCCESS;
+
+			}
+			
+			return _FAIL;
+		
+		}
+
+		if (preorder_ctrl->enable == _FALSE)
+		{
+			//indicate this recv_frame			
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+			
+			rtw_recv_indicatepkt(padapter, prframe);		
+			
+			preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+			
+			return _SUCCESS;	
+		}			
+
+#ifndef CONFIG_RECV_REORDERING_CTRL
+		//indicate this recv_frame
+		rtw_recv_indicatepkt(padapter, prframe);
+		return _SUCCESS;
+#endif
+
+	}
+	else if(pattrib->amsdu==1) //temp filter -> means didn't support A-MSDUs in a A-MPDU
+	{
+	        if (preorder_ctrl->enable == _FALSE)
+		{
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+
+			retval = amsdu_to_msdu(padapter, prframe);
+
+			preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+
+			return retval;
+		}
+	}
+	else
+	{
+
+	}
+
+	_enter_critical_bh(&ppending_recvframe_queue->lock, &irql);
+
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+		 ("recv_indicatepkt_reorder: indicate=%d seq=%d\n",
+		  preorder_ctrl->indicate_seq, pattrib->seq_num));
+
+	//s2. check if winstart_b(indicate_seq) needs to been updated
+	if(!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
+	{
+		//pHTInfo->RxReorderDropCounter++;
+		//ReturnRFDList(Adapter, pRfd);
+		//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("RxReorderIndicatePacket() ==> Packet Drop!!\n"));
+		//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+		//return _FAIL;
+		goto _err_exit;
+	}
+
+
+	//s3. Insert all packet into Reorder Queue to maintain its ordering.
+	if(!enqueue_reorder_recvframe(preorder_ctrl, prframe))
+	{
+		//DbgPrint("recv_indicatepkt_reorder, enqueue_reorder_recvframe fail!\n");
+		//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+		//return _FAIL;
+		goto _err_exit;
+	}
+
+
+	//s4.
+	// Indication process.
+	// After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
+	// with the SeqNum smaller than latest WinStart and buffer other packets.
+	//
+	// For Rx Reorder condition:
+	// 1. All packets with SeqNum smaller than WinStart => Indicate
+	// 2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
+	//
+
+	//recv_indicatepkts_in_order(padapter, preorder_ctrl, _TRUE);
+	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, _FALSE)==_TRUE)
+	{
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);	
+	}
+	else
+	{
+		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+
+
+	return _SUCCESS;
+
+_err_exit:
+
+        _exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+
+	return _FAIL;
+}
+
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext)
+{
+	_irqL irql;
+	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
+	_adapter *padapter = preorder_ctrl->padapter;
+	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+
+	if(padapter->bDriverStopped ||padapter->bSurpriseRemoved)
+	{
+		return;
+	}
+
+	//printk("+rtw_reordering_ctrl_timeout_handler()=>\n");
+
+	_enter_critical_bh(&ppending_recvframe_queue->lock, &irql);
+
+	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, _TRUE)==_TRUE)
+	{
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);		
+	}
+
+	_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+
+}
+
+
+static int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe)
+{
+	int retval = _SUCCESS;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+#ifdef CONFIG_80211N_HT
+
+	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
+
+	if(phtpriv->ht_option==1) //B/G/N Mode
+	{
+		//prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority];
+
+		if(recv_indicatepkt_reorder(padapter, prframe)!=_SUCCESS)// including perform A-MPDU Rx Ordering Buffer Control
+		{
+			if ((padapter->bDriverStopped == _FALSE) &&
+			    (padapter->bSurpriseRemoved == _FALSE))
+			{
+				retval = _FAIL;
+				return retval;
+			}
+		}
+	}
+	else //B/G mode
+#endif
+	{
+		retval=wlanhdr_to_ethhdr (prframe);
+		if(retval != _SUCCESS)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("wlanhdr_to_ethhdr: drop pkt \n"));
+			return retval;
+		}
+
+		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+		{
+			//indicate this recv_frame
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func rtw_recv_indicatepkt\n" ));
+			rtw_recv_indicatepkt(padapter, prframe);
+
+
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n" ));
+
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+			retval = _FAIL;
+			return retval;
+		}
+
+	}
+
+	return retval;
+
+}
+ 
+
+static int recv_func(_adapter *padapter, void *pcontext)
+{
+	struct rx_pkt_attrib *pattrib;
+	union recv_frame *prframe, *orig_prframe;
+	int retval = _SUCCESS;
+	_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+
+	prframe = (union recv_frame *)pcontext;
+	orig_prframe = prframe;
+
+	pattrib = &prframe->u.hdr.attrib;
+
+#ifdef CONFIG_MP_INCLUDED
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))//&&(padapter->mppriv.check_mp_pkt == 0))
+	{
+		if (pattrib->crc_err == 1)
+			padapter->mppriv.rx_crcerrpktcount++;
+		else
+			padapter->mppriv.rx_pktcount++;
+
+		if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == _FALSE) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("MP - Not in loopback mode , drop pkt \n"));
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+			goto _exit_recv_func;
+		}
+	}
+#endif
+
+	//check the frame crtl field and decache
+	retval = validate_recv_frame(padapter, prframe);
+	if (retval != _SUCCESS)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_, ("recv_func: validate_recv_frame fail! drop pkt\n"));
+		rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+		goto _exit_recv_func;
+	}
+	// DATA FRAME
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_RX);
+
+	//pHalData->hal_ops.process_phy_info(padapter, prframe);
+
+	prframe = decryptor(padapter, prframe);
+	if (prframe == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("decryptor: drop pkt\n"));
+		retval = _FAIL;
+		goto _exit_recv_func;
+	}
+
+	prframe = recvframe_chk_defrag(padapter, prframe);
+	if (prframe == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chk_defrag: drop pkt\n"));
+		goto _exit_recv_func;
+	}
+
+	prframe=portctrl(padapter, prframe);
+	if(prframe==NULL)	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("portctrl: drop pkt \n"));
+		retval = _FAIL;
+		goto _exit_recv_func;		
+	}	
+
+	count_rx_stats(padapter, prframe);
+
+#ifdef CONFIG_80211N_HT
+
+	retval = process_recv_indicatepkts(padapter, prframe);
+	if (retval != _SUCCESS)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recv_func: process_recv_indicatepkts fail! \n"));
+		rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+		goto _exit_recv_func;
+	}
+
+#else
+
+	if (!pattrib->amsdu)
+	{
+		retval = wlanhdr_to_ethhdr (prframe);
+		if (retval != _SUCCESS)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("wlanhdr_to_ethhdr: drop pkt \n"));
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+			goto _exit_recv_func;
+		}
+
+		if ((padapter->bDriverStopped == _FALSE) && (padapter->bSurpriseRemoved == _FALSE))
+		{
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@ recv_func: recv_func rtw_recv_indicatepkt\n" ));
+			//indicate this recv_frame
+			rtw_recv_indicatepkt(padapter, prframe);
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_func: rtw_free_recvframe\n" ));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_debug_, ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+			retval = _FAIL;
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue); //free this recv_frame
+		}
+
+	}
+	else if(pattrib->amsdu==1)
+	{
+
+		retval = amsdu_to_msdu(padapter, prframe);
+		if(retval != _SUCCESS)
+		{
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue);
+			goto _exit_recv_func;
+		}
+	}
+	else
+	{
+
+	}
+#endif
+
+
+_exit_recv_func:
+
+	return retval;
+}
+
+
+s32 rtw_recv_entry(union recv_frame *precvframe)
+{
+	_adapter *padapter;
+	struct recv_priv *precvpriv;
+	struct	mlme_priv	*pmlmepriv ;
+	struct dvobj_priv *pdev;
+	struct recv_stat *prxstat;
+	u8 *phead, *pdata, *ptail,*pend;
+
+	_queue *pfree_recv_queue, *ppending_recv_queue;
+	u8 blk_mode = _FALSE;
+	s32 ret=_SUCCESS;
+	struct intf_hdl * pintfhdl;
+
+_func_enter_;
+
+//	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+rtw_recv_entry\n"));
+
+	padapter = precvframe->u.hdr.adapter;
+	pintfhdl = &padapter->iopriv.intf;
+
+	pdev=&padapter->dvobjpriv;	
+	pmlmepriv = &padapter->mlmepriv;
+	precvpriv = &padapter->recvpriv;
+	pfree_recv_queue = &precvpriv->free_recv_queue;
+	ppending_recv_queue = &precvpriv->recv_pending_queue;
+
+	phead = precvframe->u.hdr.rx_head;
+	pdata = precvframe->u.hdr.rx_data;
+	ptail = precvframe->u.hdr.rx_tail;
+	pend = precvframe->u.hdr.rx_end;
+	prxstat = (struct recv_stat *)phead;
+
+	//padapter->ledpriv.LedControlHandler(padapter, LED_CTL_RX);
+
+#ifdef CONFIG_SDIO_HCI
+	if (precvpriv->free_recvframe_cnt <= 1)
+		goto _recv_entry_drop;
+#endif
+
+#ifdef CONFIG_RECV_THREAD_MODE
+	if (_rtw_queue_empty(ppending_recv_queue) == _TRUE)
+	{
+		//enqueue_recvframe_usb(precvframe, ppending_recv_queue);//enqueue to recv_pending_queue
+	 	rtw_enqueue_recvframe(precvframe, ppending_recv_queue);
+		_rtw_up_sema(&precvpriv->recv_sema);
+	}
+	else
+	{
+		//enqueue_recvframe_usb(precvframe, ppending_recv_queue);//enqueue to recv_pending_queue
+		rtw_enqueue_recvframe(precvframe, ppending_recv_queue);
+	}
+#else
+	if ((ret = recv_func(padapter, precvframe)) == _FAIL)
+	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("rtw_recv_entry: recv_func return fail!!!\n"));
+		goto _recv_entry_drop;
+	}
+#endif
+
+	precvpriv->rx_pkts++;
+
+_func_exit_;
+
+	return ret;
+
+_recv_entry_drop:
+
+
+	precvpriv->rx_drop++;
+
+#ifdef CONFIG_MP_INCLUDED
+	padapter->mppriv.rx_pktloss = precvpriv->rx_drop;
+#endif
+
+	//RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("_recv_entry_drop\n"));
+
+_func_exit_;
+
+	return ret;
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_rf.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_rf.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_rf.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_rf.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,525 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_RF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+
+#define _A_BAND		BIT(1)
+
+
+#define channel2freq(starting_freq, channel) \
+	((starting_freq + (5 * channel)))
+
+u32 rtw_ch2freq(u32 ch)
+{
+	u32 starting_freq;
+	
+	if (ch <= 14)
+		starting_freq = 2412;
+		
+	else if (ch >= 180)
+		starting_freq = 4000;
+	
+	else 
+		starting_freq = 5000;
+		
+	return channel2freq(starting_freq, ch);
+		
+}
+
+u32 rtw_freq2ch(u32 freq)
+{
+	u32 starting_freq;
+	
+	if (freq > 5000)
+	
+		starting_freq = 5000;
+	
+	else if (freq > 4000)
+			
+		starting_freq = 4000;
+		
+	else
+	{
+		starting_freq = 2412;
+		return ((freq - starting_freq)/5 + 1);
+	}	
+		
+	return ((freq - starting_freq)/5);
+
+}
+
+
+static void set_channelset_a(_adapter  *padapter, struct regulatory_class *reg_class, u8 index, u8 channel_set)
+{
+
+	struct eeprom_priv* peeprompriv = &padapter->eeprompriv;
+
+	reg_class->channel_set[index] = channel_set;
+	
+	reg_class->modem = OFDM_PHY;	
+
+	reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_a[channel_set];
+	
+	
+}
+
+
+static void set_channelset_bg(_adapter  *padapter, struct regulatory_class *reg_class, u8 index, u8 channel_set)
+{
+	struct eeprom_priv* peeprompriv = &padapter->eeprompriv;
+
+	reg_class->channel_set[index] = channel_set;
+	
+	reg_class->modem = MIXED_PHY;	
+
+	switch(channel_set)
+	{	
+		case 1:
+		case 2:
+		case 3:
+			reg_class->channel_cck_power[index] = peeprompriv->tx_power_b[1];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[1];
+			break;
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+		case 8:
+			reg_class->channel_cck_power[index] =   peeprompriv->tx_power_b[6];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[6];
+			break;
+		case 9:
+		case 10:
+		case 11:
+		case 12:
+		case 13:
+			reg_class->channel_cck_power[index] = peeprompriv->tx_power_b[11];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[11];
+			break;
+		case 14:
+			reg_class->channel_cck_power[index] = peeprompriv->tx_power_b[14];					
+			reg_class->channel_ofdm_power[index] = peeprompriv->tx_power_g[14];
+			break;
+		default:
+			break;
+			
+	}
+	
+}
+
+		
+
+/*! \init_phyinfo:
+	Init data for country information element and regulatory classes.
+
+	If you need to add the additional countries/regions:
+	1.) Please add the case in the switch-case options for each necessary country/region.
+	2.) For each country/region, you can add 1~NUM_REGULATORYS regulatory class(es).
+	     (Driver's NUM_REGULATORYS must have the same value with FW corres. value)
+	3.) For each regulatory class, you need to supply these items:
+		- Channel starting frequency (MHz):
+		   psetphyinfopara->class_sets[class_index].starting_freq
+		- Channel sets:
+		   For each channel set, please call ->
+		   a.) 802.11b/g 
+			 set_channelset_bg(adapter, &psetphyinfopara->class_sets[class_index], channel_set_index, channel_set);
+		   b.) 802.11a
+			 set_channelset_a(adapter, &psetphyinfopara->class_sets[class_index], channel_set_index, channel_set);			 
+  		- Channel spacing (MHz):  
+         	   psetphyinfopara->class_sets[class_index].channel_spacing
+         	- Transmit power limit (dBm):   
+  		   psetphyinfopara->class_sets[class_index].txpower_limit
+*/     	   	  
+static void init_phyinfo(_adapter  *adapter, struct setphyinfo_parm* psetphyinfopara)
+{
+
+	struct eeprom_priv* peeprompriv = &adapter->eeprompriv;
+	unsigned long country_string = (unsigned long)(peeprompriv->country_string[0])<<16 | (unsigned long)(peeprompriv->country_string[1])<<8 | (peeprompriv->country_string[2]);
+
+	switch(country_string)
+	{
+	
+		case USA:
+
+			/***** Regulatory domain for 802.11b/g *****/
+
+			//Regulatory domain in 802.11 b/g -> class_sets[0]
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 0, 1);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 1, 2);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 2, 3);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 3, 4);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 4, 5);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 5, 6);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 6, 7);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 7, 8);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 8, 9);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 9, 10);					
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 10, 11);
+
+
+			/***** Regulatory domain for 802.11A *****/
+			if(peeprompriv->sys_config & _A_BAND) //if A band exists in EEPROM setting
+			{
+			//Regulatory class 1-> class_sets[1]
+			psetphyinfopara->class_sets[1].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 0, 36);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 1, 40);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 2, 44);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 3, 48);		
+			psetphyinfopara->class_sets[1].channel_spacing = 20;
+			psetphyinfopara->class_sets[1].txpower_limit = 16;
+
+			//Regulatory class 2 -> class_sets[2]
+			psetphyinfopara->class_sets[2].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 0, 52);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 1, 56);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 2, 60);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 3, 64);		
+			psetphyinfopara->class_sets[2].channel_spacing = 20;
+			psetphyinfopara->class_sets[2].txpower_limit = 23;
+
+			//Regulatory class 3 -> class_sets[3]
+			psetphyinfopara->class_sets[3].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 0, 149);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 1, 153);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 2, 157);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 3, 161);		
+			psetphyinfopara->class_sets[3].channel_spacing = 20;
+			psetphyinfopara->class_sets[3].txpower_limit = 29;			
+			}
+				
+			break;
+			
+		case EUROPE:
+			
+			/***** Regulatory domain for 802.11b/g *****/
+
+			//Regulatory domain in 802.11 b/g -> class_sets[0]
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 0, 1);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 1, 2);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 2, 3);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 3, 4);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 4, 5);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 5, 6);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 6, 7);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 7, 8);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 8, 9);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 9, 10);					
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 10, 11);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 11, 12);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 12, 13);			
+
+
+			/***** Regulatory domain for 802.11a *****/
+		
+			if(peeprompriv->sys_config & _A_BAND) //if A band exists in EEPROM setting
+			{
+			//Regulatory class 1-> class_sets[1]
+			psetphyinfopara->class_sets[1].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 0, 36);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 1, 40);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 2, 44);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 3, 48);		
+			psetphyinfopara->class_sets[1].channel_spacing = 20;
+			psetphyinfopara->class_sets[1].txpower_limit = 23;
+
+			//Regulatory class 2 -> class_sets[2]
+			psetphyinfopara->class_sets[2].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 0, 52);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 1, 56);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 2, 60);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 3, 64);		
+			psetphyinfopara->class_sets[2].channel_spacing = 20;
+			psetphyinfopara->class_sets[2].txpower_limit = 23;
+
+			//Regulatory class 3 -> class_sets[3]
+			psetphyinfopara->class_sets[3].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 0, 100);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 1, 104);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 2, 108);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 3, 112);		
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 4, 116);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 5, 120);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 6, 124);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 7, 128);	
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 8, 132);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 9, 136);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 10, 140);			
+			psetphyinfopara->class_sets[3].channel_spacing = 20;
+			psetphyinfopara->class_sets[3].txpower_limit = 30;			
+			}	
+			
+			break;
+			
+		case JAPAN:
+			
+			/***** Regulatory domain for 802.11b/g *****/
+
+			//Regulatory domain in 802.11 b/g -> class_sets[0]
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 0, 1);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 1, 2);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 2, 3);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 3, 4);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 4, 5);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 5, 6);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 6, 7);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 7, 8);			
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 8, 9);		
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 9, 10);					
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 10, 11);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 11, 12);
+			set_channelset_bg(adapter, &psetphyinfopara->class_sets[0], 12, 13);			
+
+
+			/***** Regulatory domain for 802.11a *****/
+			if(peeprompriv->sys_config & _A_BAND) //if A band exists in EEPROM setting
+			{		
+			//Regulatory class 1-> class_sets[1]
+			psetphyinfopara->class_sets[1].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 0, 34);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 1, 38);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 2, 42);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[1], 3, 46);		
+			psetphyinfopara->class_sets[1].channel_spacing = 20;
+			psetphyinfopara->class_sets[1].txpower_limit = 22;
+
+			//Regulatory class 2 -> class_sets[2]
+			psetphyinfopara->class_sets[2].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[2], 2, 16);			
+			psetphyinfopara->class_sets[2].channel_spacing = 20;
+			psetphyinfopara->class_sets[2].txpower_limit = 24;
+
+			//Regulatory class 3 -> class_sets[3]
+			psetphyinfopara->class_sets[3].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[3], 2, 16);			
+			psetphyinfopara->class_sets[3].channel_spacing = 20;
+			psetphyinfopara->class_sets[3].txpower_limit = 24;			
+
+			//Regulatory class 4 -> class_sets[4]
+			psetphyinfopara->class_sets[4].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[4], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[4], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[4], 2, 16);			
+			psetphyinfopara->class_sets[4].channel_spacing = 20;
+			psetphyinfopara->class_sets[4].txpower_limit = 24;				
+
+			//Regulatory class 5 -> class_sets[5]
+			psetphyinfopara->class_sets[5].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[5], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[5], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[5], 2, 16);			
+			psetphyinfopara->class_sets[5].channel_spacing = 20;
+			psetphyinfopara->class_sets[5].txpower_limit = 24;
+
+			//Regulatory class 6 -> class_sets[6]
+			psetphyinfopara->class_sets[6].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[6], 0, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[6], 1, 12);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[6], 2, 16);			
+			psetphyinfopara->class_sets[6].channel_spacing = 20;
+			psetphyinfopara->class_sets[6].txpower_limit = 22;
+
+			//Regulatory class 7 -> class_sets[7]
+			psetphyinfopara->class_sets[7].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[7], 3, 195);			
+			psetphyinfopara->class_sets[7].channel_spacing = 20;
+			psetphyinfopara->class_sets[7].txpower_limit = 24;
+
+			//Regulatory class 8 -> class_sets[8]
+			psetphyinfopara->class_sets[8].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[8], 3, 196);			
+			psetphyinfopara->class_sets[8].channel_spacing = 20;
+			psetphyinfopara->class_sets[8].txpower_limit = 24;
+
+			//Regulatory class 9 -> class_sets[9]
+			psetphyinfopara->class_sets[9].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[9], 3, 196);			
+			psetphyinfopara->class_sets[9].channel_spacing = 20;
+			psetphyinfopara->class_sets[9].txpower_limit = 24;
+
+			//Regulatory class 10 -> class_sets[9]
+			psetphyinfopara->class_sets[10].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[10], 3, 196);			
+			psetphyinfopara->class_sets[10].channel_spacing = 20;
+			psetphyinfopara->class_sets[10].txpower_limit = 24;
+
+			//Regulatory class 11 -> class_sets[11]
+			psetphyinfopara->class_sets[11].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 0, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 1, 188);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 2, 192);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[11], 3, 196);			
+			psetphyinfopara->class_sets[11].channel_spacing = 20;
+			psetphyinfopara->class_sets[11].txpower_limit = 22;
+
+			//Regulatory class 12 -> class_sets[12]
+			psetphyinfopara->class_sets[12].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[12], 3, 11);			
+			psetphyinfopara->class_sets[12].channel_spacing = 10;
+			psetphyinfopara->class_sets[12].txpower_limit = 24;
+
+			//Regulatory class 13 -> class_sets[13]
+			psetphyinfopara->class_sets[13].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[13], 3, 11);			
+			psetphyinfopara->class_sets[13].channel_spacing = 10;
+			psetphyinfopara->class_sets[13].txpower_limit = 24;
+
+			//Regulatory class 14 -> class_sets[14]
+			psetphyinfopara->class_sets[14].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[14], 3, 11);			
+			psetphyinfopara->class_sets[14].channel_spacing = 10;
+			psetphyinfopara->class_sets[14].txpower_limit = 24;		
+	
+			//Regulatory class 15 -> class_sets[15]
+			psetphyinfopara->class_sets[15].starting_freq = 5000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 0, 7);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 1, 8);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 2, 9);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[15], 3, 11);			
+			psetphyinfopara->class_sets[15].channel_spacing = 10;
+			psetphyinfopara->class_sets[15].txpower_limit = 24;		
+
+			//Regulatory class 16 -> class_sets[16]
+			psetphyinfopara->class_sets[16].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[16], 5, 189);			
+			psetphyinfopara->class_sets[16].channel_spacing = 10;
+			psetphyinfopara->class_sets[16].txpower_limit = 24;		
+
+			//Regulatory class 17 -> class_sets[17]
+			psetphyinfopara->class_sets[17].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[17], 5, 189);			
+			psetphyinfopara->class_sets[17].channel_spacing = 10;
+			psetphyinfopara->class_sets[17].txpower_limit = 24;		
+
+			//Regulatory class 18 -> class_sets[18]
+			psetphyinfopara->class_sets[18].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[18], 5, 189);			
+			psetphyinfopara->class_sets[18].channel_spacing = 10;
+			psetphyinfopara->class_sets[18].txpower_limit = 24;		
+
+			//Regulatory class 19 -> class_sets[19]
+			psetphyinfopara->class_sets[19].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[19], 5, 189);			
+			psetphyinfopara->class_sets[19].channel_spacing = 10;
+			psetphyinfopara->class_sets[19].txpower_limit = 24;		
+
+			//Regulatory class 20 -> class_sets[20]
+			psetphyinfopara->class_sets[20].starting_freq = 4000; 
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 0, 183);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 1, 184);
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 2, 185);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 3, 187);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 4, 188);			
+			set_channelset_a(adapter, &psetphyinfopara->class_sets[20], 5, 189);			
+			psetphyinfopara->class_sets[20].channel_spacing = 10;
+			psetphyinfopara->class_sets[20].txpower_limit = 17;		
+			}
+			
+			break;
+			
+		default:
+		
+			RT_TRACE(_module_hal_init_c_,_drv_err_,("Country string in EEPROM has not been defined."));
+			break;
+			
+	}
+
+}
+
+
+static u8 writephyinfo_fw(_adapter *padapter, u32 addr)
+{
+	u32	i;
+	u32 *tmpWrite;
+	struct setphyinfo_parm*	psetphyinfopara;
+
+	psetphyinfopara = (struct setphyinfo_parm*)_rtw_zmalloc(sizeof(struct setphyinfo_parm)); 
+
+	if(psetphyinfopara==NULL){
+		return _FAIL;
+	}
+
+	//_rtw_memset((unsigned char *)psetphyinfopara, 0, sizeof (struct setphyinfo_parm));
+	
+	init_phyinfo(padapter, psetphyinfopara);
+
+	tmpWrite = (u32 *)psetphyinfopara;
+
+	for(i = 0; i < sizeof(struct setphyinfo_parm); i = i + sizeof(u32)) 
+	{
+		rtw_write32(padapter, addr+i, *tmpWrite);
+		tmpWrite++;
+	}
+
+	_rtw_mfree((unsigned char *) psetphyinfopara, sizeof(struct	setphyinfo_parm));
+	
+	return _SUCCESS;
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_security.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_security.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_security.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_security.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1935 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define  _RTL871X_SECURITY_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+
+
+
+#ifdef PLATFORM_LINUX
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/smp_lock.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#endif
+
+
+//=====WEP related===== 
+
+#define CRC32_POLY 0x04c11db7
+
+struct arc4context
+{
+	u32 x;
+	u32 y;
+	u8 state[256];
+};
+
+
+static void arcfour_init(struct arc4context 	*parc4ctx, u8 * key,u32	key_len)
+{
+	u32	t, u;
+	u32	keyindex;
+	u32	stateindex;
+	u8 * state;
+	u32	counter;
+_func_enter_;
+	state = parc4ctx->state;
+	parc4ctx->x = 0;
+	parc4ctx->y = 0;
+	for (counter = 0; counter < 256; counter++)
+		state[counter] = (u8)counter;
+	keyindex = 0;
+	stateindex = 0;
+	for (counter = 0; counter < 256; counter++)
+	{
+		t = state[counter];
+		stateindex = (stateindex + key[keyindex] + t) & 0xff;
+		u = state[stateindex];
+		state[stateindex] = (u8)t;
+		state[counter] = (u8)u;
+		if (++keyindex >= key_len)
+			keyindex = 0;
+	}
+_func_exit_;	
+}
+static u32 arcfour_byte(	struct arc4context	*parc4ctx)
+{
+	u32 x;
+	u32 y;
+	u32 sx, sy;
+	u8 * state;
+_func_enter_;
+	state = parc4ctx->state;
+	x = (parc4ctx->x + 1) & 0xff;
+	sx = state[x];
+	y = (sx + parc4ctx->y) & 0xff;
+	sy = state[y];
+	parc4ctx->x = x;
+	parc4ctx->y = y;
+	state[y] = (u8)sx;
+	state[x] = (u8)sy;
+_func_exit_;	
+	return state[(sx + sy) & 0xff];
+}
+              
+           
+static void arcfour_encrypt(	struct arc4context	*parc4ctx, 
+	u8 * dest,
+	u8 * src, 
+	u32 len)
+{
+	u32	i;
+_func_enter_;	
+	for (i = 0; i < len; i++)
+		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
+_func_exit_;		
+}
+
+static sint bcrc32initialized = 0;
+static u32 crc32_table[256];
+
+
+static u8 crc32_reverseBit( u8 data)
+{
+	return( (u8)((data<<7)&0x80) | ((data<<5)&0x40) | ((data<<3)&0x20) | ((data<<1)&0x10) | ((data>>1)&0x08) | ((data>>3)&0x04) | ((data>>5)&0x02) | ((data>>7)&0x01) );
+}
+
+static void crc32_init(void)
+{
+_func_enter_;	
+	if (bcrc32initialized == 1) 
+		goto exit;
+	else{
+		sint i, j;
+		u32 c;
+		u8 *p=(u8 *)&c, *p1;
+		u8 k;
+
+		c = 0x12340000;
+
+		for (i = 0; i < 256; ++i) 
+		{
+			k = crc32_reverseBit((u8)i);
+			for (c = ((u32)k) << 24, j = 8; j > 0; --j){
+				c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY : (c << 1);
+			}
+			p1 = (u8 *)&crc32_table[i];
+
+			p1[0] = crc32_reverseBit(p[3]);
+			p1[1] = crc32_reverseBit(p[2]);
+			p1[2] = crc32_reverseBit(p[1]);
+			p1[3] = crc32_reverseBit(p[0]);
+		}
+		bcrc32initialized= 1;
+	}
+exit:	
+_func_exit_;			
+}
+
+static u32 getcrc32(u8 *buf, sint len)
+{
+	u8 *p;
+	u32  crc;
+_func_enter_;	
+	if (bcrc32initialized == 0) crc32_init();
+
+	crc = 0xffffffff;       /* preload shift register, per CRC-32 spec */
+
+	for (p = buf; len > 0; ++p, --len) 
+	{
+		crc = crc32_table[ (crc ^ *p) & 0xff] ^ (crc >> 8);
+	}
+_func_exit_;				
+	return ~crc;    /* transmit complement, per CRC-32 spec */
+}
+
+
+/*
+	Need to consider the fragment  situation
+*/
+void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
+{																	// exclude ICV
+	
+	unsigned char	crc[4];
+	struct arc4context	 mycontext;
+
+	sint 			curfragnum,length;
+	u32	keylength;
+
+	u8	*pframe, *payload,*iv;    //,*wepkey
+	u8	wepkey[16];
+	struct	pkt_attrib	 *pattrib = &((struct xmit_frame*)pxmitframe)->attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+	
+_func_enter_;	
+
+	
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return;
+
+#if USB_TX_AGGREGATION_92C
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_SIZE +
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
+#else
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
+#endif
+	
+	//start to encrypt each fragment
+	if((pattrib->encrypt==_WEP40_)||(pattrib->encrypt==_WEP104_))
+	{
+		keylength=psecuritypriv->dot11DefKeylen[psecuritypriv->dot11PrivacyKeyIndex];
+
+		for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++)
+		{
+			iv=pframe+pattrib->hdrlen;
+			_rtw_memcpy(&wepkey[0], iv, 3);
+			_rtw_memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);
+			payload=pframe+pattrib->iv_len+pattrib->hdrlen;
+
+			if((curfragnum+1)==pattrib->nr_frags)
+			{	//the last fragment
+			
+				length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+			
+				*((unsigned long *)crc)=cpu_to_le32(getcrc32(payload,length));
+
+				arcfour_init(&mycontext, wepkey,3+keylength);
+				arcfour_encrypt(&mycontext, payload, payload, length);
+				arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+			}
+			else
+			{
+			length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+				*((unsigned long *)crc)=cpu_to_le32(getcrc32(payload,length));
+				arcfour_init(&mycontext, wepkey,3+keylength);
+				arcfour_encrypt(&mycontext, payload, payload, length);
+				arcfour_encrypt(&mycontext, payload+length, crc, 4);
+	
+			pframe+=pxmitpriv->frag_len;
+			pframe=(u8 *)RND4((SIZE_PTR)(pframe));
+
+			}
+			
+		}		
+						
+	}
+	
+_func_exit_;						
+
+}
+
+void rtw_wep_decrypt(_adapter  *padapter, u8 *precvframe)
+{								
+	// exclude ICV
+	u8	crc[4];
+	struct arc4context	 mycontext;
+	sint 	length;
+	u32	keylength;
+	u8	*pframe, *payload,*iv,wepkey[16];
+	u8	 keyindex;
+	struct	rx_pkt_attrib	 *prxattrib = &(((union recv_frame*)precvframe)->u.hdr.attrib);
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+
+_func_enter_;	
+
+	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
+	
+	//start to decrypt recvframe
+	if((prxattrib->encrypt==_WEP40_)||(prxattrib->encrypt==_WEP104_))
+	{
+		//printk("#### rx data,to perform sw rtw_wep_decrypt\n");
+		iv=pframe+prxattrib->hdrlen;
+		keyindex=(iv[3]&0x3);
+		keylength=psecuritypriv->dot11DefKeylen[keyindex];
+		_rtw_memcpy(&wepkey[0], iv, 3);
+		_rtw_memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);	
+		length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+
+		payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
+		
+		//decrypt payload include icv
+		arcfour_init(&mycontext, wepkey,3+keylength);
+		arcfour_encrypt(&mycontext, payload, payload,  length);
+				
+		//calculate icv and compare the icv
+		*((unsigned long *)crc)=le32_to_cpu(getcrc32(payload,length-4));
+		
+		if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
+		{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
+						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
+		}	
+						
+	}
+	
+_func_exit_;		
+
+	return;
+	
+}
+
+//3 		=====TKIP related=====
+
+static u32 secmicgetuint32( u8 * p )
+// Convert from Byte[] to Us4Byte32 in a portable way
+{
+	s32 i;
+	u32 res = 0;
+_func_enter_;		
+	for( i=0; i<4; i++ )
+	{
+		res |= ((u32)(*p++)) << (8*i);
+	}
+_func_exit_;		
+	return res;
+}
+
+static void secmicputuint32( u8 * p, u32 val )
+// Convert from Us4Byte32 to Byte[] in a portable way
+{
+	long i;
+_func_enter_;			
+	for( i=0; i<4; i++ )
+	{
+		*p++ = (u8) (val & 0xff);
+		val >>= 8;
+	}
+_func_exit_;		
+}
+
+static void secmicclear(struct mic_data *pmicdata)
+{
+// Reset the state to the empty message.
+_func_enter_;	
+	pmicdata->L = pmicdata->K0;
+	pmicdata->R = pmicdata->K1;
+	pmicdata->nBytesInM = 0;
+	pmicdata->M = 0;
+_func_exit_;	
+}
+
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key )
+{
+	// Set the key
+_func_enter_;		
+	pmicdata->K0 = secmicgetuint32( key );
+	pmicdata->K1 = secmicgetuint32( key + 4 );
+	// and reset the message
+	secmicclear(pmicdata);
+_func_exit_;		
+}
+
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b )
+{
+_func_enter_;	
+	// Append the byte to our word-sized buffer
+	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
+	pmicdata->nBytesInM++;
+	// Process the word if it is full.
+	if( pmicdata->nBytesInM >= 4 )
+	{
+		pmicdata->L ^= pmicdata->M;
+		pmicdata->R ^= ROL32( pmicdata->L, 17 );
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) | ((pmicdata->L & 0x00ff00ff) << 8);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROL32( pmicdata->L, 3 );
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROR32( pmicdata->L, 2 );
+		pmicdata->L += pmicdata->R;
+		// Clear the buffer
+		pmicdata->M = 0;
+		pmicdata->nBytesInM = 0;
+	}
+_func_exit_;			
+}
+
+void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes )
+{
+_func_enter_;	
+	// This is simple
+	while( nbytes > 0 )
+	{
+		rtw_secmicappendbyte(pmicdata, *src++ );
+		nbytes--;
+	}
+_func_exit_;			
+}
+
+void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst )
+{
+_func_enter_;	
+	// Append the minimum padding
+	rtw_secmicappendbyte(pmicdata, 0x5a );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	// and then zeroes until the length is a multiple of 4
+	while( pmicdata->nBytesInM != 0 )
+	{
+		rtw_secmicappendbyte(pmicdata, 0 );
+	}
+	// The appendByte function has already computed the result.
+	secmicputuint32( dst, pmicdata->L );
+	secmicputuint32( dst+4, pmicdata->R );
+	// Reset to the empty message.
+	secmicclear(pmicdata);
+_func_exit_;		
+}
+
+
+void rtw_seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code, u8 pri)
+{
+
+	struct mic_data	micdata;
+	u8 priority[4]={0x0,0x0,0x0,0x0};
+_func_enter_;		
+	rtw_secmicsetkey(&micdata, key);
+	priority[0]=pri;
+	
+	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
+	if(header[1]&1){   //ToDS==1
+			rtw_secmicappend(&micdata, &header[16], 6);  //DA
+		if(header[1]&2)  //From Ds==1
+			rtw_secmicappend(&micdata, &header[24], 6);
+		else
+			rtw_secmicappend(&micdata, &header[10], 6);		
+	}	
+	else{	//ToDS==0
+		rtw_secmicappend(&micdata, &header[4], 6);   //DA
+		if(header[1]&2)  //From Ds==1
+			rtw_secmicappend(&micdata, &header[16], 6);
+		else
+			rtw_secmicappend(&micdata, &header[10], 6);
+
+	}
+	rtw_secmicappend(&micdata, &priority[0], 4);
+
+	
+	rtw_secmicappend(&micdata, data, data_len);
+
+	rtw_secgetmic(&micdata,mic_code);
+_func_exit_;	
+}
+
+
+
+
+/* macros for extraction/creation of unsigned char/unsigned short values  */
+#define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))
+#define   Lo8(v16)   ((u8)( (v16)       & 0x00FF))
+#define   Hi8(v16)   ((u8)(((v16) >> 8) & 0x00FF))
+#define  Lo16(v32)   ((u16)( (v32)       & 0xFFFF))
+#define  Hi16(v32)   ((u16)(((v32) >>16) & 0xFFFF))
+#define  Mk16(hi,lo) ((lo) ^ (((u16)(hi)) << 8))
+
+/* select the Nth 16-bit word of the temporal key unsigned char array TK[]   */
+#define  TK16(N)     Mk16(tk[2*(N)+1],tk[2*(N)])
+
+/* S-box lookup: 16 bits --> 16 bits */
+#define _S_(v16)     (rtw_Sbox1[0][Lo8(v16)] ^ rtw_Sbox1[1][Hi8(v16)])
+
+/* fixed algorithm "parameters" */
+#define PHASE1_LOOP_CNT   8    /* this needs to be "big enough"     */
+#define TA_SIZE           6    /*  48-bit transmitter address       */
+#define TK_SIZE          16    /* 128-bit temporal key              */
+#define P1K_SIZE         10    /*  80-bit Phase1 key                */
+#define RC4_KEY_SIZE     16    /* 128-bit RC4KEY (104 bits unknown) */
+
+
+/* 2-unsigned char by 2-unsigned char subset of the full AES S-box table */
+const unsigned short rtw_Sbox1[2][256]=       /* Sbox for hash (can be in ROM)     */
+{ {
+   0xC6A5,0xF884,0xEE99,0xF68D,0xFF0D,0xD6BD,0xDEB1,0x9154,
+   0x6050,0x0203,0xCEA9,0x567D,0xE719,0xB562,0x4DE6,0xEC9A,
+   0x8F45,0x1F9D,0x8940,0xFA87,0xEF15,0xB2EB,0x8EC9,0xFB0B,
+   0x41EC,0xB367,0x5FFD,0x45EA,0x23BF,0x53F7,0xE496,0x9B5B,
+   0x75C2,0xE11C,0x3DAE,0x4C6A,0x6C5A,0x7E41,0xF502,0x834F,
+   0x685C,0x51F4,0xD134,0xF908,0xE293,0xAB73,0x6253,0x2A3F,
+   0x080C,0x9552,0x4665,0x9D5E,0x3028,0x37A1,0x0A0F,0x2FB5,
+   0x0E09,0x2436,0x1B9B,0xDF3D,0xCD26,0x4E69,0x7FCD,0xEA9F,
+   0x121B,0x1D9E,0x5874,0x342E,0x362D,0xDCB2,0xB4EE,0x5BFB,
+   0xA4F6,0x764D,0xB761,0x7DCE,0x527B,0xDD3E,0x5E71,0x1397,
+   0xA6F5,0xB968,0x0000,0xC12C,0x4060,0xE31F,0x79C8,0xB6ED,
+   0xD4BE,0x8D46,0x67D9,0x724B,0x94DE,0x98D4,0xB0E8,0x854A,
+   0xBB6B,0xC52A,0x4FE5,0xED16,0x86C5,0x9AD7,0x6655,0x1194,
+   0x8ACF,0xE910,0x0406,0xFE81,0xA0F0,0x7844,0x25BA,0x4BE3,
+   0xA2F3,0x5DFE,0x80C0,0x058A,0x3FAD,0x21BC,0x7048,0xF104,
+   0x63DF,0x77C1,0xAF75,0x4263,0x2030,0xE51A,0xFD0E,0xBF6D,
+   0x814C,0x1814,0x2635,0xC32F,0xBEE1,0x35A2,0x88CC,0x2E39,
+   0x9357,0x55F2,0xFC82,0x7A47,0xC8AC,0xBAE7,0x322B,0xE695,
+   0xC0A0,0x1998,0x9ED1,0xA37F,0x4466,0x547E,0x3BAB,0x0B83,
+   0x8CCA,0xC729,0x6BD3,0x283C,0xA779,0xBCE2,0x161D,0xAD76,
+   0xDB3B,0x6456,0x744E,0x141E,0x92DB,0x0C0A,0x486C,0xB8E4,
+   0x9F5D,0xBD6E,0x43EF,0xC4A6,0x39A8,0x31A4,0xD337,0xF28B,
+   0xD532,0x8B43,0x6E59,0xDAB7,0x018C,0xB164,0x9CD2,0x49E0,
+   0xD8B4,0xACFA,0xF307,0xCF25,0xCAAF,0xF48E,0x47E9,0x1018,
+   0x6FD5,0xF088,0x4A6F,0x5C72,0x3824,0x57F1,0x73C7,0x9751,
+   0xCB23,0xA17C,0xE89C,0x3E21,0x96DD,0x61DC,0x0D86,0x0F85,
+   0xE090,0x7C42,0x71C4,0xCCAA,0x90D8,0x0605,0xF701,0x1C12,
+   0xC2A3,0x6A5F,0xAEF9,0x69D0,0x1791,0x9958,0x3A27,0x27B9,
+   0xD938,0xEB13,0x2BB3,0x2233,0xD2BB,0xA970,0x0789,0x33A7,
+   0x2DB6,0x3C22,0x1592,0xC920,0x8749,0xAAFF,0x5078,0xA57A,
+   0x038F,0x59F8,0x0980,0x1A17,0x65DA,0xD731,0x84C6,0xD0B8,
+   0x82C3,0x29B0,0x5A77,0x1E11,0x7BCB,0xA8FC,0x6DD6,0x2C3A,
+  },
+ 
+
+  {  /* second half of table is unsigned char-reversed version of first! */
+   0xA5C6,0x84F8,0x99EE,0x8DF6,0x0DFF,0xBDD6,0xB1DE,0x5491,
+   0x5060,0x0302,0xA9CE,0x7D56,0x19E7,0x62B5,0xE64D,0x9AEC,
+   0x458F,0x9D1F,0x4089,0x87FA,0x15EF,0xEBB2,0xC98E,0x0BFB,
+   0xEC41,0x67B3,0xFD5F,0xEA45,0xBF23,0xF753,0x96E4,0x5B9B,
+   0xC275,0x1CE1,0xAE3D,0x6A4C,0x5A6C,0x417E,0x02F5,0x4F83,
+   0x5C68,0xF451,0x34D1,0x08F9,0x93E2,0x73AB,0x5362,0x3F2A,
+   0x0C08,0x5295,0x6546,0x5E9D,0x2830,0xA137,0x0F0A,0xB52F,
+   0x090E,0x3624,0x9B1B,0x3DDF,0x26CD,0x694E,0xCD7F,0x9FEA,
+   0x1B12,0x9E1D,0x7458,0x2E34,0x2D36,0xB2DC,0xEEB4,0xFB5B,
+   0xF6A4,0x4D76,0x61B7,0xCE7D,0x7B52,0x3EDD,0x715E,0x9713,
+   0xF5A6,0x68B9,0x0000,0x2CC1,0x6040,0x1FE3,0xC879,0xEDB6,
+   0xBED4,0x468D,0xD967,0x4B72,0xDE94,0xD498,0xE8B0,0x4A85,
+   0x6BBB,0x2AC5,0xE54F,0x16ED,0xC586,0xD79A,0x5566,0x9411,
+   0xCF8A,0x10E9,0x0604,0x81FE,0xF0A0,0x4478,0xBA25,0xE34B,
+   0xF3A2,0xFE5D,0xC080,0x8A05,0xAD3F,0xBC21,0x4870,0x04F1,
+   0xDF63,0xC177,0x75AF,0x6342,0x3020,0x1AE5,0x0EFD,0x6DBF,
+   0x4C81,0x1418,0x3526,0x2FC3,0xE1BE,0xA235,0xCC88,0x392E,
+   0x5793,0xF255,0x82FC,0x477A,0xACC8,0xE7BA,0x2B32,0x95E6,
+   0xA0C0,0x9819,0xD19E,0x7FA3,0x6644,0x7E54,0xAB3B,0x830B,
+   0xCA8C,0x29C7,0xD36B,0x3C28,0x79A7,0xE2BC,0x1D16,0x76AD,
+   0x3BDB,0x5664,0x4E74,0x1E14,0xDB92,0x0A0C,0x6C48,0xE4B8,
+   0x5D9F,0x6EBD,0xEF43,0xA6C4,0xA839,0xA431,0x37D3,0x8BF2,
+   0x32D5,0x438B,0x596E,0xB7DA,0x8C01,0x64B1,0xD29C,0xE049,
+   0xB4D8,0xFAAC,0x07F3,0x25CF,0xAFCA,0x8EF4,0xE947,0x1810,
+   0xD56F,0x88F0,0x6F4A,0x725C,0x2438,0xF157,0xC773,0x5197,
+   0x23CB,0x7CA1,0x9CE8,0x213E,0xDD96,0xDC61,0x860D,0x850F,
+   0x90E0,0x427C,0xC471,0xAACC,0xD890,0x0506,0x01F7,0x121C,
+   0xA3C2,0x5F6A,0xF9AE,0xD069,0x9117,0x5899,0x273A,0xB927,
+   0x38D9,0x13EB,0xB32B,0x3322,0xBBD2,0x70A9,0x8907,0xA733,
+   0xB62D,0x223C,0x9215,0x20C9,0x4987,0xFFAA,0x7850,0x7AA5,
+   0x8F03,0xF859,0x8009,0x171A,0xDA65,0x31D7,0xC684,0xB8D0,
+   0xC382,0xB029,0x775A,0x111E,0xCB7B,0xFCA8,0xD66D,0x3A2C,
+  }
+};
+ 
+ /*
+**********************************************************************
+* Routine: Phase 1 -- generate P1K, given TA, TK, IV32
+*
+* Inputs:
+*     tk[]      = temporal key                         [128 bits]
+*     ta[]      = transmitter's MAC address            [ 48 bits]
+*     iv32      = upper 32 bits of IV                  [ 32 bits]
+* Output:
+*     p1k[]     = Phase 1 key                          [ 80 bits]
+*
+* Note:
+*     This function only needs to be called every 2**16 packets,
+*     although in theory it could be called every packet.
+*
+**********************************************************************
+*/
+static void phase1(u16 *p1k,const u8 *tk,const u8 *ta,u32 iv32)
+{
+	sint  i;
+_func_enter_;
+	/* Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     */
+	p1k[0]      = Lo16(iv32);
+	p1k[1]      = Hi16(iv32);
+	p1k[2]      = Mk16(ta[1],ta[0]); /* use TA[] as little-endian */
+	p1k[3]      = Mk16(ta[3],ta[2]);
+	p1k[4]      = Mk16(ta[5],ta[4]);
+
+	/* Now compute an unbalanced Feistel cipher with 80-bit block */
+	/* size on the 80-bit block P1K[], using the 128-bit key TK[] */
+	for (i=0; i < PHASE1_LOOP_CNT ;i++)
+	{                 /* Each add operation here is mod 2**16 */
+      		p1k[0] += _S_(p1k[4] ^ TK16((i&1)+0));
+		p1k[1] += _S_(p1k[0] ^ TK16((i&1)+2));
+		p1k[2] += _S_(p1k[1] ^ TK16((i&1)+4));
+		p1k[3] += _S_(p1k[2] ^ TK16((i&1)+6));
+		p1k[4] += _S_(p1k[3] ^ TK16((i&1)+0));
+		p1k[4] +=  (unsigned short)i;                    /* avoid "slide attacks" */
+        }
+_func_exit_;
+}
+ 
+
+/*
+**********************************************************************
+* Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
+*
+* Inputs:
+*     tk[]      = Temporal key                         [128 bits]
+*     p1k[]     = Phase 1 output key                   [ 80 bits]
+*     iv16      = low 16 bits of IV counter            [ 16 bits]
+* Output:
+*     rc4key[]  = the key used to encrypt the packet   [128 bits]
+*
+* Note:
+*     The value {TA,IV32,IV16} for Phase1/Phase2 must be unique
+*     across all packets using the same key TK value. Then, for a
+*     given value of TK[], this TKIP48 construction guarantees that
+*     the final RC4KEY value is unique across all packets.
+*
+* Suggested implementation optimization: if PPK[] is "overlaid"
+*     appropriately on RC4KEY[], there is no need for the final
+*     for loop below that copies the PPK[] result into RC4KEY[].
+*
+**********************************************************************
+*/
+static void phase2(u8 *rc4key,const u8 *tk,const u16 *p1k,u16 iv16)
+{
+	sint  i;
+	u16 PPK[6];                          /* temporary key for mixing    */
+_func_enter_;
+	/* Note: all adds in the PPK[] equations below are mod 2**16         */
+	for (i=0;i<5;i++) PPK[i]=p1k[i];      /* first, copy P1K to PPK      */
+		PPK[5]  =  p1k[4] +iv16;             /* next,  add in IV16          */
+
+	/* Bijective non-linear mixing of the 96 bits of PPK[0..5]           */
+	PPK[0] +=    _S_(PPK[5] ^ TK16(0));   /* Mix key in each "round"     */
+	PPK[1] +=    _S_(PPK[0] ^ TK16(1));
+	PPK[2] +=    _S_(PPK[1] ^ TK16(2));
+	PPK[3] +=    _S_(PPK[2] ^ TK16(3));
+	PPK[4] +=    _S_(PPK[3] ^ TK16(4));
+	PPK[5] +=    _S_(PPK[4] ^ TK16(5));   /* Total # S-box lookups == 6  */
+
+	/* Final sweep: bijective, "linear". Rotates kill LSB correlations   */
+	PPK[0] +=  RotR1(PPK[5] ^ TK16(6));
+	PPK[1] +=  RotR1(PPK[0] ^ TK16(7));   /* Use all of TK[] in Phase2   */
+	PPK[2] +=  RotR1(PPK[1]);
+	PPK[3] +=  RotR1(PPK[2]);
+	PPK[4] +=  RotR1(PPK[3]);
+	PPK[5] +=  RotR1(PPK[4]);
+	/* Note: At this point, for a given key TK[0..15], the 96-bit output */
+	/*       value PPK[0..5] is guaranteed to be unique, as a function   */
+	/*       of the 96-bit "input" value   {TA,IV32,IV16}. That is, P1K  */
+	/*       is now a keyed permutation of {TA,IV32,IV16}.               */
+
+	/* Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   */
+	rc4key[0] = Hi8(iv16);                /* RC4KEY[0..2] is the WEP IV  */
+	rc4key[1] =(Hi8(iv16) | 0x20) & 0x7F; /* Help avoid weak (FMS) keys  */
+	rc4key[2] = Lo8(iv16);
+	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
+	 
+
+	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       */
+	for (i=0;i<6;i++)
+	{
+		rc4key[4+2*i] = Lo8(PPK[i]);
+		rc4key[5+2*i] = Hi8(PPK[i]);
+	}
+_func_exit_;	
+}
+
+
+//The hlen isn't include the IV
+u32	rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
+{																	// exclude ICV
+	u16	pnl;
+	u32	pnh;
+	u8	rc4key[16];
+	u8   ttkey[16];
+	u8	crc[4];
+	struct arc4context mycontext;
+	sint 			curfragnum,length;
+	u32	prwskeylen;
+
+	u8	*pframe, *payload,*iv,*prwskey;
+	union pn48 dot11txpn;
+	struct	sta_info		*stainfo;
+	struct	pkt_attrib	 *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+	//struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+	u32	res=_SUCCESS;
+_func_enter_;
+
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return _FAIL;
+
+#if USB_TX_AGGREGATION_92C
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_SIZE +
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
+#else
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
+#endif
+
+	//4 start to encrypt each fragment
+	if(pattrib->encrypt==_TKIP_){
+
+		if(pattrib->psta)
+		{
+			stainfo = pattrib->psta;
+		}
+		else
+		{
+		stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
+		}	
+		
+		if (stainfo!=NULL){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo!=NULL!!!\n"));
+			prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			prwskeylen=16;
+
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+				iv=pframe+pattrib->hdrlen;
+				payload=pframe+pattrib->iv_len+pattrib->hdrlen;
+				
+				GET_TKIP_PN(iv, dot11txpn);
+
+				pnl=(u16)(dot11txpn.val);
+				pnh=(u32)(dot11txpn.val>>16);
+
+				phase1((u16 *)&ttkey[0],prwskey,&pattrib->ta[0],pnh);
+
+				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);	
+
+				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+					RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("pattrib->iv_len =%x, pattrib->icv_len =%x\n", pattrib->iv_len,pattrib->icv_len));
+					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
+
+					arcfour_init(&mycontext, rc4key,16);
+					arcfour_encrypt(&mycontext, payload, payload, length);
+					arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
+					arcfour_init(&mycontext,rc4key,16);
+					arcfour_encrypt(&mycontext, payload, payload, length);
+					arcfour_encrypt(&mycontext, payload+length, crc, 4);
+	
+				pframe+=pxmitpriv->frag_len;
+				pframe=(u8 *)RND4((SIZE_PTR)(pframe));
+
+				}
+			}
+
+
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+_func_exit_;	
+	return res;
+				
+}
+
+
+//The hlen isn't include the IV
+u32 rtw_tkip_decrypt(_adapter *padapter, u8 *precvframe)
+{																	// exclude ICV
+	u16 pnl;
+	u32 pnh;
+	u8   rc4key[16];
+	u8   ttkey[16];
+	u8	crc[4];
+	struct arc4context mycontext;
+	sint 			length;
+	u32	prwskeylen;
+
+	u8	*pframe, *payload,*iv,*prwskey;
+	union pn48 dot11txpn;
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	 *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+//	struct	recv_priv		*precvpriv=&padapter->recvpriv;
+	u32		res=_SUCCESS;
+
+_func_enter_;
+
+	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
+	
+	//4 start to decrypt recvframe
+	if(prxattrib->encrypt==_TKIP_){
+
+		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
+		if (stainfo!=NULL){
+
+			if(IS_MCAST(prxattrib->ra))
+			{
+				DBG_871X("rx bc/mc packets, to perform sw rtw_tkip_decrypt\n");
+				prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid-1].skey;
+				prwskeylen=16;
+			}
+			else
+			{
+			        RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_decrypt: stainfo!=NULL!!!\n"));
+				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+				prwskeylen=16;
+			}
+			
+			iv=pframe+prxattrib->hdrlen;
+			payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
+			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+				
+			GET_TKIP_PN(iv, dot11txpn);
+
+			pnl=(u16)(dot11txpn.val);
+			pnh=(u32)(dot11txpn.val>>16);
+
+			phase1((u16 *)&ttkey[0],prwskey,&prxattrib->ta[0],pnh);
+			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);	
+
+			//4 decrypt payload include icv
+					
+			arcfour_init(&mycontext, rc4key,16);
+			arcfour_encrypt(&mycontext, payload, payload, length);
+
+			*((u32 *)crc)=le32_to_cpu(getcrc32(payload,length-4));
+
+			if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
+			{
+			    RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
+						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
+				res=_FAIL;
+			}
+						
+		
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_decrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+_func_exit_;	
+	return res;
+				
+}
+
+
+//3			=====AES related=====
+
+
+
+#define MAX_MSG_SIZE	2048
+/*****************************/
+/******** SBOX Table *********/
+/*****************************/
+
+static    u8 sbox_table[256] =
+    {
+        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
+        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
+        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
+        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
+        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
+        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+    };
+
+/*****************************/
+/**** Function Prototypes ****/
+/*****************************/
+
+static void bitwise_xor(u8 *ina, u8 *inb, u8 *out);
+static void construct_mic_iv(
+                        u8 *mic_header1,
+                        sint qc_exists,
+                        sint a4_exists,
+                        u8 *mpdu,
+                        uint payload_length,
+                        u8 * pn_vector);
+static void construct_mic_header1(
+                        u8 *mic_header1,
+                        sint header_length,
+                        u8 *mpdu);
+static void construct_mic_header2(
+                    u8 *mic_header2,
+                    u8 *mpdu,
+                    sint a4_exists,
+                    sint qc_exists);
+static void construct_ctr_preload(
+                        u8 *ctr_preload,
+                        sint a4_exists,
+                        sint qc_exists,
+                        u8 *mpdu,
+                        u8 *pn_vector,
+                        sint c);
+static void xor_128(u8 *a, u8 *b, u8 *out);
+static void xor_32(u8 *a, u8 *b, u8 *out);
+static u8 sbox(u8 a);
+static void next_key(u8 *key, sint round);
+static void byte_sub(u8 *in, u8 *out);
+static void shift_row(u8 *in, u8 *out);
+static void mix_column(u8 *in, u8 *out);
+void add_round_key( u8 *shiftrow_in,
+                    u8 *mcol_in,
+                    u8 *block_in,
+                    sint round,
+                    u8 *out);
+static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext);
+
+
+/****************************************/
+/* aes128k128d()                        */
+/* Performs a 128 bit AES encrypt with  */
+/* 128 bit data.                        */
+/****************************************/
+static void xor_128(u8 *a, u8 *b, u8 *out)
+{
+    sint i;
+_func_enter_;	
+    for (i=0;i<16; i++)
+    {
+        out[i] = a[i] ^ b[i];
+    }
+_func_exit_;		
+}
+
+
+static void xor_32(u8 *a, u8 *b, u8 *out)
+{
+    sint i;
+_func_enter_;		
+    for (i=0;i<4; i++)
+    {
+        out[i] = a[i] ^ b[i];
+    }
+_func_exit_;		
+}
+
+
+static u8 sbox(u8 a)
+{
+    return sbox_table[(sint)a];
+}
+
+
+static void next_key(u8 *key, sint round)
+{
+    u8 rcon;
+    u8 sbox_key[4];
+    u8 rcon_table[12] =
+    {
+        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+        0x1b, 0x36, 0x36, 0x36
+    };
+_func_enter_;		
+    sbox_key[0] = sbox(key[13]);
+    sbox_key[1] = sbox(key[14]);
+    sbox_key[2] = sbox(key[15]);
+    sbox_key[3] = sbox(key[12]);
+
+    rcon = rcon_table[round];
+
+    xor_32(&key[0], sbox_key, &key[0]);
+    key[0] = key[0] ^ rcon;
+
+    xor_32(&key[4], &key[0], &key[4]);
+    xor_32(&key[8], &key[4], &key[8]);
+    xor_32(&key[12], &key[8], &key[12]);
+_func_exit_;		
+}
+
+
+static void byte_sub(u8 *in, u8 *out)
+{
+    sint i;
+_func_enter_;			
+    for (i=0; i< 16; i++)
+    {
+        out[i] = sbox(in[i]);
+    }
+_func_exit_;	
+}
+
+
+static void shift_row(u8 *in, u8 *out)
+{
+_func_enter_;	
+    out[0] =  in[0];
+    out[1] =  in[5];
+    out[2] =  in[10];
+    out[3] =  in[15];
+    out[4] =  in[4];
+    out[5] =  in[9];
+    out[6] =  in[14];
+    out[7] =  in[3];
+    out[8] =  in[8];
+    out[9] =  in[13];
+    out[10] = in[2];
+    out[11] = in[7];
+    out[12] = in[12];
+    out[13] = in[1];
+    out[14] = in[6];
+    out[15] = in[11];
+_func_exit_;		
+}
+
+
+static void mix_column(u8 *in, u8 *out)
+{
+    sint i;
+    u8 add1b[4];
+    u8 add1bf7[4];
+    u8 rotl[4];
+    u8 swap_halfs[4];
+    u8 andf7[4];
+    u8 rotr[4];
+    u8 temp[4];
+    u8 tempb[4];
+_func_enter_;	
+    for (i=0 ; i<4; i++)
+    {
+        if ((in[i] & 0x80)== 0x80)
+            add1b[i] = 0x1b;
+        else
+            add1b[i] = 0x00;
+    }
+
+    swap_halfs[0] = in[2];    /* Swap halfs */
+    swap_halfs[1] = in[3];
+    swap_halfs[2] = in[0];
+    swap_halfs[3] = in[1];
+
+    rotl[0] = in[3];        /* Rotate left 8 bits */
+    rotl[1] = in[0];
+    rotl[2] = in[1];
+    rotl[3] = in[2];
+
+    andf7[0] = in[0] & 0x7f;
+    andf7[1] = in[1] & 0x7f;
+    andf7[2] = in[2] & 0x7f;
+    andf7[3] = in[3] & 0x7f;
+
+    for (i = 3; i>0; i--)    /* logical shift left 1 bit */
+    {
+        andf7[i] = andf7[i] << 1;
+        if ((andf7[i-1] & 0x80) == 0x80)
+        {
+            andf7[i] = (andf7[i] | 0x01);
+        }
+    }
+    andf7[0] = andf7[0] << 1;
+    andf7[0] = andf7[0] & 0xfe;
+
+    xor_32(add1b, andf7, add1bf7);
+
+    xor_32(in, add1bf7, rotr);
+
+    temp[0] = rotr[0];         /* Rotate right 8 bits */
+    rotr[0] = rotr[1];
+    rotr[1] = rotr[2];
+    rotr[2] = rotr[3];
+    rotr[3] = temp[0];
+
+    xor_32(add1bf7, rotr, temp);
+    xor_32(swap_halfs, rotl,tempb);
+    xor_32(temp, tempb, out);
+_func_exit_;		
+}
+
+
+static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
+{
+    sint round;
+    sint i;
+    u8 intermediatea[16];
+    u8 intermediateb[16];
+    u8 round_key[16];
+_func_enter_;	
+    for(i=0; i<16; i++) round_key[i] = key[i];
+
+    for (round = 0; round < 11; round++)
+    {
+        if (round == 0)
+        {
+            xor_128(round_key, data, ciphertext);
+            next_key(round_key, round);
+        }
+        else if (round == 10)
+        {
+            byte_sub(ciphertext, intermediatea);
+            shift_row(intermediatea, intermediateb);
+            xor_128(intermediateb, round_key, ciphertext);
+        }
+        else    /* 1 - 9 */
+        {
+            byte_sub(ciphertext, intermediatea);
+            shift_row(intermediatea, intermediateb);
+            mix_column(&intermediateb[0], &intermediatea[0]);
+            mix_column(&intermediateb[4], &intermediatea[4]);
+            mix_column(&intermediateb[8], &intermediatea[8]);
+            mix_column(&intermediateb[12], &intermediatea[12]);
+            xor_128(intermediatea, round_key, ciphertext);
+            next_key(round_key, round);
+        }
+    }
+_func_exit_;	
+}
+
+
+/************************************************/
+/* construct_mic_iv()                           */
+/* Builds the MIC IV from header fields and PN  */
+/************************************************/
+static void construct_mic_iv(
+                        u8 *mic_iv,
+                        sint qc_exists,
+                        sint a4_exists,
+                        u8 *mpdu,
+                        uint payload_length,
+                        u8 *pn_vector
+                        )
+{
+    sint i;
+_func_enter_;	
+    mic_iv[0] = 0x59;
+    if (qc_exists && a4_exists) mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
+    if (qc_exists && !a4_exists) mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
+    if (!qc_exists) mic_iv[1] = 0x00;
+    for (i = 2; i < 8; i++)
+        mic_iv[i] = mpdu[i + 8];                    /* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
+    #ifdef CONSISTENT_PN_ORDER
+        for (i = 8; i < 14; i++)
+            mic_iv[i] = pn_vector[i - 8];           /* mic_iv[8:13] = PN[0:5] */
+    #else
+        for (i = 8; i < 14; i++)
+            mic_iv[i] = pn_vector[13 - i];          /* mic_iv[8:13] = PN[5:0] */
+    #endif
+    mic_iv[14] = (unsigned char) (payload_length / 256);
+    mic_iv[15] = (unsigned char) (payload_length % 256);
+_func_exit_;		
+}
+
+
+/************************************************/
+/* construct_mic_header1()                      */
+/* Builds the first MIC header block from       */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header1(
+                        u8 *mic_header1,
+                        sint header_length,
+                        u8 *mpdu
+                        )
+{
+_func_enter_;	
+    mic_header1[0] = (u8)((header_length - 2) / 256);
+    mic_header1[1] = (u8)((header_length - 2) % 256);
+    mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
+    mic_header1[3] = mpdu[1] & 0xc7;    /* Mute retry, more data and pwr mgt bits */
+    mic_header1[4] = mpdu[4];       /* A1 */
+    mic_header1[5] = mpdu[5];
+    mic_header1[6] = mpdu[6];
+    mic_header1[7] = mpdu[7];
+    mic_header1[8] = mpdu[8];
+    mic_header1[9] = mpdu[9];
+    mic_header1[10] = mpdu[10];     /* A2 */
+    mic_header1[11] = mpdu[11];
+    mic_header1[12] = mpdu[12];
+    mic_header1[13] = mpdu[13];
+    mic_header1[14] = mpdu[14];
+    mic_header1[15] = mpdu[15];
+_func_exit_;	
+}
+
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header2(
+                u8 *mic_header2,
+                u8 *mpdu,
+                sint a4_exists,
+                sint qc_exists
+                )
+{
+    sint i;
+_func_enter_;	
+    for (i = 0; i<16; i++) mic_header2[i]=0x00;
+
+    mic_header2[0] = mpdu[16];    /* A3 */
+    mic_header2[1] = mpdu[17];
+    mic_header2[2] = mpdu[18];
+    mic_header2[3] = mpdu[19];
+    mic_header2[4] = mpdu[20];
+    mic_header2[5] = mpdu[21];
+
+    //mic_header2[6] = mpdu[22] & 0xf0;   /* SC */
+    mic_header2[6] = 0x00;
+    mic_header2[7] = 0x00; /* mpdu[23]; */
+
+
+    if (!qc_exists && a4_exists)
+    {
+        for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+
+    }
+
+    if (qc_exists && !a4_exists)
+    {
+        mic_header2[8] = mpdu[24] & 0x0f; /* mute bits 15 - 4 */
+        mic_header2[9] = mpdu[25] & 0x00;
+    }
+
+    if (qc_exists && a4_exists)
+    {
+        for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+
+        mic_header2[14] = mpdu[30] & 0x0f;
+        mic_header2[15] = mpdu[31] & 0x00;
+    }
+
+_func_exit_;	
+}
+
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_ctr_preload(
+                        u8 *ctr_preload,
+                        sint a4_exists,
+                        sint qc_exists,
+                        u8 *mpdu,
+                        u8 *pn_vector,
+                        sint c
+                        )
+{
+    sint i = 0;
+_func_enter_;		
+    for (i=0; i<16; i++) ctr_preload[i] = 0x00;
+    i = 0;
+
+    ctr_preload[0] = 0x01;                                  /* flag */
+    if (qc_exists && a4_exists) 
+		ctr_preload[1] = mpdu[30] & 0x0f;   /* QoC_Control */
+    if (qc_exists && !a4_exists) 
+		ctr_preload[1] = mpdu[24] & 0x0f;
+
+    for (i = 2; i < 8; i++)
+        ctr_preload[i] = mpdu[i + 8];                       /* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
+    #ifdef CONSISTENT_PN_ORDER
+      for (i = 8; i < 14; i++)
+            ctr_preload[i] =    pn_vector[i - 8];           /* ctr_preload[8:13] = PN[0:5] */
+    #else
+      for (i = 8; i < 14; i++)
+            ctr_preload[i] =    pn_vector[13 - i];          /* ctr_preload[8:13] = PN[5:0] */
+    #endif
+    ctr_preload[14] =  (unsigned char) (c / 256); /* Ctr */
+    ctr_preload[15] =  (unsigned char) (c % 256);
+_func_exit_;		
+}
+
+
+/************************************/
+/* bitwise_xor()                    */
+/* A 128 bit, bitwise exclusive or  */
+/************************************/
+static void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
+{
+    sint i;
+_func_enter_;		
+    for (i=0; i<16; i++)
+    {
+        out[i] = ina[i] ^ inb[i];
+    }
+_func_exit_;		
+}
+
+
+static sint aes_cipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+//	/*static*/ unsigned char	message[MAX_MSG_SIZE];
+	uint	qc_exists, a4_exists, i, j, payload_remainder,
+		num_blocks, payload_index;
+
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+//	uint	offset = 0;
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+	
+_func_enter_;		
+	frsubtype=frsubtype>>4;
+
+
+	_rtw_memset((void *)mic_iv, 0, 16);
+	_rtw_memset((void *)mic_header1, 0, 16);
+	_rtw_memset((void *)mic_header2, 0, 16);
+	_rtw_memset((void *)ctr_preload, 0, 16);
+	_rtw_memset((void *)chain_buffer, 0, 16);
+	_rtw_memset((void *)aes_out, 0, 16);
+	_rtw_memset((void *)padded_buffer, 0, 16);
+
+	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if (
+		(frtype == WIFI_DATA_CFACK) ||
+		(frtype == WIFI_DATA_CFPOLL)||
+		(frtype == WIFI_DATA_CFACKPOLL))
+		{
+			qc_exists = 1;
+					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+		}
+	else if (
+		(frsubtype == 0x08) ||
+		(frsubtype == 0x09)||
+		(frsubtype == 0x0a)||
+		(frsubtype == 0x0b))
+		{
+			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+			qc_exists = 1;
+		}
+	else
+		qc_exists = 0;
+
+	pn_vector[0]=pframe[hdrlen];
+	pn_vector[1]=pframe[hdrlen+1];
+	pn_vector[2]=pframe[hdrlen+4];
+	pn_vector[3]=pframe[hdrlen+5];
+	pn_vector[4]=pframe[hdrlen+6];
+	pn_vector[5]=pframe[hdrlen+7];
+	
+	construct_mic_iv(
+                        mic_iv,
+                        qc_exists,
+                        a4_exists,
+                        pframe,	 //message,
+                        plen,
+                        pn_vector
+                        );
+
+    construct_mic_header1(
+                            mic_header1,
+                            hdrlen,
+                            pframe	//message
+                            );
+    construct_mic_header2(
+                            mic_header2,
+                            pframe,	//message,
+                            a4_exists,
+                            qc_exists
+                            );
+
+
+	payload_remainder = plen % 16;
+    num_blocks = plen / 16;
+
+    /* Find start of payload */
+    payload_index = (hdrlen + 8);
+
+    /* Calculate MIC */
+    aes128k128d(key, mic_iv, aes_out);
+    bitwise_xor(aes_out, mic_header1, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+    bitwise_xor(aes_out, mic_header2, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++)
+    {
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+
+        payload_index += 16;
+        aes128k128d(key, chain_buffer, aes_out);
+    }
+
+    /* Add on the final payload block if it needs padding */
+    if (payload_remainder > 0)
+    {
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index++];//padded_buffer[j] = message[payload_index++];
+        }
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        aes128k128d(key, chain_buffer, aes_out);
+
+    }
+
+    for (j = 0 ; j < 8; j++) mic[j] = aes_out[j];
+
+    /* Insert MIC into payload */
+    for (j = 0; j < 8; j++)
+    	pframe[payload_index+j] = mic[j];	//message[payload_index+j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,	//message,
+                                pn_vector,
+                                i+1);
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,	//message,
+                                pn_vector,
+                                num_blocks+1);
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index+j];//padded_buffer[j] = message[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    /* Encrypt the MIC */
+    construct_ctr_preload(
+                        ctr_preload,
+                        a4_exists,
+                        qc_exists,
+                        pframe,	//message,
+                        pn_vector,
+                        0);
+
+    for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+    for (j = 0; j < 8; j++)
+    {
+        padded_buffer[j] = pframe[j+hdrlen+8+plen];//padded_buffer[j] = message[j+hdrlen+8+plen];
+    }
+
+    aes128k128d(key, ctr_preload, aes_out);
+    bitwise_xor(aes_out, padded_buffer, chain_buffer);
+    for (j=0; j<8;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
+_func_exit_;		
+	return _SUCCESS;
+}
+
+
+
+
+u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
+{	// exclude ICV
+
+
+	/*static*/ 
+//	unsigned char	message[MAX_MSG_SIZE];
+
+    	/* Intermediate Buffers */
+	sint 	curfragnum,length;
+	u32	prwskeylen;
+	u8	*pframe,*prwskey;	//, *payload,*iv
+	struct	sta_info		*stainfo;
+	struct	pkt_attrib	 *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+//	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+
+//	uint	offset = 0;
+	u32 res=_SUCCESS;
+_func_enter_;		
+
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return _FAIL;
+
+#if USB_TX_AGGREGATION_92C
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_SIZE +
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
+#else
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
+#endif
+
+	//4 start to encrypt each fragment
+	if((pattrib->encrypt==_AES_)){
+
+		if(pattrib->psta)
+		{
+			stainfo = pattrib->psta;
+		}
+		else
+		{
+		stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
+		}	
+		
+		if (stainfo!=NULL){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo!=NULL!!!\n"));
+			prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			prwskeylen=16;
+	
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+			
+				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+				
+					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+				
+					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
+				pframe+=pxmitpriv->frag_len;
+				pframe=(u8*)RND4((SIZE_PTR)(pframe));
+
+				}
+			}
+
+
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+
+
+
+_func_exit_;
+		return res;
+}
+
+static sint aes_decipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+	static u8	message[MAX_MSG_SIZE];
+	uint	qc_exists, a4_exists, i, j, payload_remainder,
+			num_blocks, payload_index;
+
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+    /* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+
+
+//	uint	offset = 0;
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+_func_enter_;			
+	frsubtype=frsubtype>>4;
+
+
+	_rtw_memset((void *)mic_iv, 0, 16);
+	_rtw_memset((void *)mic_header1, 0, 16);
+	_rtw_memset((void *)mic_header2, 0, 16);
+	_rtw_memset((void *)ctr_preload, 0, 16);
+	_rtw_memset((void *)chain_buffer, 0, 16);
+	_rtw_memset((void *)aes_out, 0, 16);
+	_rtw_memset((void *)padded_buffer, 0, 16);
+
+	//start to decrypt the payload
+
+	num_blocks = (plen-8) / 16; //(plen including llc, payload_length and mic )
+
+	payload_remainder = (plen-8) % 16;
+
+	pn_vector[0]  = pframe[hdrlen];
+	pn_vector[1]  = pframe[hdrlen+1];
+	pn_vector[2]  = pframe[hdrlen+4];
+	pn_vector[3]  = pframe[hdrlen+5];
+	pn_vector[4]  = pframe[hdrlen+6];
+	pn_vector[5]  = pframe[hdrlen+7];
+
+	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if (
+		(frtype == WIFI_DATA_CFACK) ||
+		(frtype == WIFI_DATA_CFPOLL)||
+		(frtype == WIFI_DATA_CFACKPOLL))
+		{
+			qc_exists = 1;
+					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+		}
+	else if (
+		(frsubtype == 0x08) ||
+		(frsubtype == 0x09)||
+		(frsubtype == 0x0a)||
+		(frsubtype == 0x0b))
+		{
+			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+				 
+					hdrlen += 2;
+			}
+			qc_exists = 1;
+		}
+	else
+		qc_exists = 0;
+
+
+	// now, decrypt pframe with hdrlen offset and plen long
+
+	payload_index = hdrlen + 8; // 8 is for extiv
+	
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,
+                                pn_vector,
+                                i+1
+                            );
+
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+
+        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,
+                                pn_vector,
+                                num_blocks+1
+                            );
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];
+    }
+
+	//start to calculate the mic	
+
+	_rtw_memcpy((void *)message, pframe, (hdrlen +plen+8)); //8 is for ext iv len
+
+
+	pn_vector[0]=pframe[hdrlen];
+	pn_vector[1]=pframe[hdrlen+1];
+	pn_vector[2]=pframe[hdrlen+4];
+	pn_vector[3]=pframe[hdrlen+5];
+	pn_vector[4]=pframe[hdrlen+6];
+	pn_vector[5]=pframe[hdrlen+7];
+
+
+	
+	construct_mic_iv(
+                        mic_iv,
+                        qc_exists,
+                        a4_exists,
+                        message,
+                        plen-8,
+                        pn_vector
+                        );
+
+    construct_mic_header1(
+                            mic_header1,
+                            hdrlen,
+                            message
+                            );
+    construct_mic_header2(
+                            mic_header2,
+                            message,
+                            a4_exists,
+                            qc_exists
+                            );
+
+
+	payload_remainder = (plen-8) % 16;
+    num_blocks = (plen-8) / 16;
+
+    /* Find start of payload */
+    payload_index = (hdrlen + 8);
+
+    /* Calculate MIC */
+    aes128k128d(key, mic_iv, aes_out);
+    bitwise_xor(aes_out, mic_header1, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+    bitwise_xor(aes_out, mic_header2, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++)
+    {
+        bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+
+        payload_index += 16;
+        aes128k128d(key, chain_buffer, aes_out);
+    }
+
+    /* Add on the final payload block if it needs padding */
+    if (payload_remainder > 0)
+    {
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = message[payload_index++];
+        }
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        aes128k128d(key, chain_buffer, aes_out);
+
+    }
+
+    for (j = 0 ; j < 8; j++) mic[j] = aes_out[j];
+
+    /* Insert MIC into payload */
+    for (j = 0; j < 8; j++)
+    	message[payload_index+j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                message,
+                                pn_vector,
+                                i+1);
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+        for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                message,
+                                pn_vector,
+                                num_blocks+1);
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = message[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    /* Encrypt the MIC */
+    construct_ctr_preload(
+                        ctr_preload,
+                        a4_exists,
+                        qc_exists,
+                        message,
+                        pn_vector,
+                        0);
+
+    for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+    for (j = 0; j < 8; j++)
+    {
+        padded_buffer[j] = message[j+hdrlen+8+plen-8];
+    }
+
+    aes128k128d(key, ctr_preload, aes_out);
+    bitwise_xor(aes_out, padded_buffer, chain_buffer);
+    for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
+
+	//compare the mic
+	for(i=0;i<8;i++){
+		if(pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i])
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x) \n",
+						i,pframe[hdrlen+8+plen-8+i],message[hdrlen+8+plen-8+i]));
+	}
+_func_exit_;	
+	return _SUCCESS;
+}
+
+u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
+{	// exclude ICV
+
+
+	/*static*/ 
+//	unsigned char	message[MAX_MSG_SIZE];
+
+
+    	/* Intermediate Buffers */
+
+
+	sint 		length;
+	u32	prwskeylen;
+	u8	*pframe,*prwskey;	//, *payload,*iv
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	 *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+//	struct	recv_priv		*precvpriv=&padapter->recvpriv;
+	u32	res=_SUCCESS;
+_func_enter_;	 
+	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
+	//4 start to encrypt each fragment
+	if((prxattrib->encrypt==_AES_)){
+
+		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
+		if (stainfo!=NULL){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo!=NULL!!!\n"));
+
+			if(IS_MCAST(prxattrib->ra))
+			{
+				DBG_871X("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
+				prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid-1].skey;
+				prwskeylen=16;
+			}
+			else
+			{
+				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			        prwskeylen=16;
+			}
+	
+			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+				
+			aes_decipher(prwskey,prxattrib->hdrlen,pframe, length);
+
+
+		}
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
+			res=_FAIL;
+		}
+						
+	}
+_func_exit_;		
+	return res;
+}
+
+
+
+#ifdef PLATFORM_WINDOWS
+void rtw_use_tkipkey_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	)
+#endif
+#ifdef PLATFORM_LINUX
+void rtw_use_tkipkey_handler(void *FunctionContext)
+#endif
+{
+        _adapter *padapter = (_adapter *)FunctionContext;
+
+
+_func_enter_;			
+
+	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler ^^^\n"));
+	
+/*
+	if(padapter->bDriverStopped ||padapter->bSurpriseRemoved){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler (padapter->bDriverStopped %d)(padapter->bSurpriseRemoved %d)^^^\n",padapter->bDriverStopped,padapter->bSurpriseRemoved));
+
+		return;
+	}
+	*/
+	
+	padapter->securitypriv.busetkipkey=_TRUE;
+
+	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n",padapter->securitypriv.busetkipkey));
+
+_func_exit_;	
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_sta_mgt.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_sta_mgt.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_sta_mgt.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_sta_mgt.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,558 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_STA_MGT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#include <sta_info.h>
+
+
+static void _init_stainfo(struct sta_info *psta)
+{
+
+_func_enter_;
+
+	_rtw_memset((u8 *)psta, 0, sizeof (struct sta_info));
+
+	 _rtw_spinlock_init(&psta->lock);
+	_rtw_init_listhead(&psta->list);
+	_rtw_init_listhead(&psta->hash_list);
+	//_rtw_init_listhead(&psta->asoc_list);
+	//_rtw_init_listhead(&psta->sleep_list);
+	//_rtw_init_listhead(&psta->wakeup_list);	
+
+	_rtw_init_queue(&psta->sleep_q);
+	psta->sleepq_len = 0;
+
+	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
+	
+#ifdef CONFIG_NATIVEAP_MLME	
+	_rtw_init_listhead(&psta->asoc_list);
+	_rtw_init_listhead(&psta->auth_list);
+#endif	
+	
+_func_exit_;	
+
+}
+
+
+
+
+u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
+{
+	struct sta_info *psta;
+	s32 i;
+	
+_func_enter_;	
+
+	pstapriv->pallocated_stainfo_buf = _rtw_zmalloc (sizeof(struct sta_info) * NUM_STA+ 4);
+	if(!pstapriv->pallocated_stainfo_buf)
+		return _FAIL;
+
+	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 - 
+		((SIZE_PTR)(pstapriv->pallocated_stainfo_buf ) & 3);
+
+	_rtw_init_queue(&pstapriv->free_sta_queue);
+
+	_rtw_spinlock_init(&pstapriv->sta_hash_lock);
+	
+	//_rtw_init_queue(&pstapriv->asoc_q);
+	pstapriv->asoc_sta_count = 0;
+	_rtw_init_queue(&pstapriv->sleep_q);
+	_rtw_init_queue(&pstapriv->wakeup_q);
+
+	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
+
+		
+	for(i = 0; i < NUM_STA; i++)
+	{
+		_init_stainfo(psta);
+
+		_rtw_init_listhead(&(pstapriv->sta_hash[i]));
+
+		rtw_list_insert_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));
+
+		psta++;
+	}
+
+#ifdef CONFIG_NATIVEAP_MLME	
+	_rtw_init_listhead(&pstapriv->asoc_list);
+	_rtw_init_listhead(&pstapriv->auth_list);
+	//pstapriv->auth_to = ???;
+	//pstapriv->assoc_to = ???;
+	//pstapriv->expire_to = ???;
+#endif
+	
+_func_exit_;		
+
+	return _SUCCESS;
+	
+}
+
+static void	_free_sta_xmit_priv_lock(struct sta_xmit_priv *psta_xmitpriv)
+{
+_func_enter_;
+
+	_rtw_spinlock_free(&psta_xmitpriv->lock);
+
+	_rtw_spinlock_free(&(psta_xmitpriv->be_q.sta_pending.lock));
+	_rtw_spinlock_free(&(psta_xmitpriv->bk_q.sta_pending.lock));
+	_rtw_spinlock_free(&(psta_xmitpriv->vi_q.sta_pending.lock));
+	_rtw_spinlock_free(&(psta_xmitpriv->vo_q.sta_pending.lock));
+_func_exit_;	
+}
+
+static void	_free_sta_recv_priv_lock(struct sta_recv_priv *psta_recvpriv)
+{
+_func_enter_;	
+
+	_rtw_spinlock_free(&psta_recvpriv->lock);
+
+	_rtw_spinlock_free(&(psta_recvpriv->defrag_q.lock));
+
+_func_exit_;
+
+}
+
+static void mfree_stainfo(struct sta_info *psta)
+{
+_func_enter_;
+
+	if(&psta->lock != NULL)
+		 _rtw_spinlock_free(&psta->lock);
+
+	_free_sta_xmit_priv_lock(&psta->sta_xmitpriv);
+	_free_sta_recv_priv_lock(&psta->sta_recvpriv);
+	
+_func_exit_;	
+}
+
+
+// this function is used to free the memory of lock || sema for all stainfos
+static void mfree_all_stainfo(struct sta_priv *pstapriv )
+{
+	_irqL	 irqL;
+	_list	*plist, *phead;
+	struct sta_info *psta = NULL;
+	
+_func_enter_;	
+
+	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+	phead = get_list_head(&pstapriv->free_sta_queue);
+	plist = get_next(phead);
+		
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	{
+		psta = LIST_CONTAINOR(plist, struct sta_info ,list);
+		plist = get_next(plist);
+
+		mfree_stainfo(psta);
+	}
+	
+	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+_func_exit_;	
+
+}
+
+
+static void mfree_sta_priv_lock(struct	sta_priv *pstapriv)
+{
+	 mfree_all_stainfo(pstapriv); //be done before free sta_hash_lock
+
+	_rtw_spinlock_free(&pstapriv->free_sta_queue.lock);
+
+	_rtw_spinlock_free(&pstapriv->sta_hash_lock);
+	_rtw_spinlock_free(&pstapriv->wakeup_q.lock);
+	_rtw_spinlock_free(&pstapriv->sleep_q.lock);
+
+}
+
+u32	_rtw_free_sta_priv(struct	sta_priv *pstapriv)
+{
+_func_enter_;
+	if(pstapriv){
+		mfree_sta_priv_lock(pstapriv);
+
+		_rtw_mfree(pstapriv->pallocated_stainfo_buf, sizeof(struct sta_info)*NUM_STA+4);		
+	}
+	
+_func_exit_;
+	return _SUCCESS;
+}
+
+
+//struct	sta_info *rtw_alloc_stainfo(_queue *pfree_sta_queue, unsigned char *hwaddr)
+struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr) 
+{	
+	uint tmp_aid;
+	s32	index;
+	_list	*phash_list;
+	struct sta_info	*psta;
+	_queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int i = 0;
+	u16  wRxSeqInitialValue = 0xffff;
+	
+_func_enter_;	
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+	
+	_rtw_spinlock(&(pfree_sta_queue->lock));
+
+	if (_rtw_queue_empty(pfree_sta_queue) == _TRUE)
+	{
+		psta = NULL;
+	}
+	else
+	{
+		psta = LIST_CONTAINOR(get_next(&pfree_sta_queue->queue), struct sta_info, list);
+		
+		list_delete(&(psta->list));
+		
+		tmp_aid = psta->aid;	
+	
+		_init_stainfo(psta);
+
+		_rtw_memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
+
+		index = wifi_mac_hash(hwaddr);
+
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("rtw_alloc_stainfo: index  = %x", index));
+
+		if(index >= NUM_STA){
+			RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("ERROR=> rtw_alloc_stainfo: index >= NUM_STA"));
+			psta= NULL;	
+			goto exit;
+		}
+		phash_list = &(pstapriv->sta_hash[index]);
+
+		_rtw_spinlock(&(pstapriv->sta_hash_lock));
+
+		rtw_list_insert_tail(&psta->hash_list, phash_list);
+
+		pstapriv->asoc_sta_count ++ ;
+
+		_rtw_spinunlock(&(pstapriv->sta_hash_lock));
+
+// Commented by Albert 2009/08/13
+// For the SMC router, the sequence number of first packet of WPS handshake will be 0.
+// In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable.
+// So, we initialize the tid_rxseq variable as the 0xffff.
+
+		for( i = 0; i < 16; i++ )
+		{
+                     _rtw_memcpy( &psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2 );
+		}
+
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("alloc number_%d stainfo  with hwaddr = %x %x %x %x %x %x  \n", 
+		pstapriv->asoc_sta_count , hwaddr[0], hwaddr[1], hwaddr[2],hwaddr[3],hwaddr[4],hwaddr[5]));
+
+		init_addba_retry_timer(pstapriv->padapter, psta);
+
+		//for A-MPDU Rx reordering buffer control
+		for(i=0; i < 16 ; i++)
+		{
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+
+			preorder_ctrl->padapter = pstapriv->padapter;
+		
+			preorder_ctrl->enable = _FALSE;
+		
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;       
+			//preorder_ctrl->wsize_b = (NR_RECVBUFF-2);
+			preorder_ctrl->wsize_b = 64;//64;
+
+			_rtw_init_queue(&preorder_ctrl->pending_recvframe_queue);
+
+			rtw_init_recv_timer(preorder_ctrl);
+		}
+
+	}
+	
+exit:
+
+	_rtw_spinunlock(&(pfree_sta_queue->lock));
+	
+_func_exit_;	
+
+	return psta;
+
+
+}
+
+
+// using pstapriv->sta_hash_lock to protect
+u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
+{	
+	int i;
+	_irqL irqL0;
+	_queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct	sta_xmit_priv	*pstaxmitpriv;
+	struct	xmit_priv	*pxmitpriv= &padapter->xmitpriv;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	
+
+_func_enter_;	
+	
+	if (psta == NULL)
+		goto exit;
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+
+
+	pstaxmitpriv = &psta->sta_xmitpriv;
+	
+	//list_delete(&psta->sleep_list);
+	
+	//list_delete(&psta->wakeup_list);
+	
+	_enter_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
+
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->vo_q.tx_pending));
+
+	_exit_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
+	
+
+	_enter_critical_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
+
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->vi_q.tx_pending));
+
+	_exit_critical_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
+
+
+	_enter_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
+
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->bk_q.tx_pending));
+
+	_exit_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
+
+	_enter_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
+
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
+
+	list_delete(&(pstaxmitpriv->be_q.tx_pending));
+
+	_exit_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
+	
+	
+	list_delete(&psta->hash_list);
+	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
+	pstapriv->asoc_sta_count --;
+	
+	
+	// re-init sta_info; 20061114
+	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
+
+	_cancel_timer_ex(&psta->addba_retry_timer);
+
+	//for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer
+	for(i=0; i < 16 ; i++)
+	{
+		preorder_ctrl = &psta->recvreorder_ctrl[i];
+		
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);		
+	}
+
+	_rtw_spinlock(&(pfree_sta_queue->lock));
+	// insert into free_sta_queue; 20061114
+	rtw_list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
+	_rtw_spinunlock(&(pfree_sta_queue->lock));
+	
+
+exit:	
+	
+_func_exit_;	
+
+	return _SUCCESS;
+	
+}
+
+// free all stainfo which in sta_hash[all]
+void rtw_free_all_stainfo(_adapter *padapter)
+{
+	_irqL	 irqL;
+	_list	*plist, *phead;
+	s32	index;
+	struct sta_info *psta = NULL;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info* pbcmc_stainfo =rtw_get_bcmc_stainfo( padapter);
+	
+_func_enter_;	
+
+	if(pstapriv->asoc_sta_count==1)
+		goto exit;
+
+	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+	for(index=0; index< NUM_STA; index++)
+	{
+		phead = &(pstapriv->sta_hash[index]);
+		plist = get_next(phead);
+		
+		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+		{
+			psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
+
+			plist = get_next(plist);
+
+			if(pbcmc_stainfo!=psta)					
+				rtw_free_stainfo(padapter , psta);
+			
+		}
+	}
+	
+	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	
+exit:	
+	
+_func_exit_;	
+
+}
+
+/* any station allocated can be searched by hash list */
+struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+
+	_irqL	 irqL;
+
+	_list	*plist, *phead;
+
+	struct sta_info *psta = NULL;
+	
+	u32	index;
+
+_func_enter_;
+
+	if(hwaddr==NULL)
+		return NULL;
+		
+
+	index = wifi_mac_hash(hwaddr);
+
+	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	
+	phead = &(pstapriv->sta_hash[index]);
+	plist = get_next(phead);
+
+
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	{
+	
+		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+		
+		if ((_rtw_memcmp(psta->hwaddr,hwaddr, ETH_ALEN))== _TRUE) 
+		{ // if found the matched address
+			break;
+		}
+		psta=NULL;
+		plist = get_next(plist);
+	}
+
+	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+_func_exit_;	
+	return psta;
+	
+}
+
+u32 rtw_init_bcmc_stainfo(_adapter* padapter)
+{
+
+	struct sta_info 	*psta;
+	struct tx_servq	*ptxservq;
+	u32 res=_SUCCESS;
+	NDIS_802_11_MAC_ADDRESS	bcast_addr= {0xff,0xff,0xff,0xff,0xff,0xff};
+	
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	_queue	*pstapending = &padapter->xmitpriv.bm_pending; 
+	
+_func_enter_;
+
+	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
+	
+	if(psta==NULL){
+		res=_FAIL;
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("rtw_alloc_stainfo fail"));
+		goto exit;
+	}
+	
+	ptxservq= &(psta->sta_xmitpriv.be_q);
+
+/*
+	_enter_critical(&pstapending->lock, &irqL0);
+
+	if (rtw_is_list_empty(&ptxservq->tx_pending))
+		rtw_list_insert_tail(&ptxservq->tx_pending, get_list_head(pstapending));
+
+	_exit_critical(&pstapending->lock, &irqL0);
+*/
+	
+exit:
+_func_exit_;		
+	return _SUCCESS;
+
+}
+
+
+struct sta_info* rtw_get_bcmc_stainfo(_adapter* padapter)
+{
+	struct sta_info 	*psta;
+	struct sta_priv 	*pstapriv = &padapter->stapriv;
+	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+_func_enter_;
+	 psta = rtw_get_stainfo(pstapriv, bc_addr);
+_func_exit_;		 
+	return psta;
+
+}
+
+
+u8 rtw_access_ctrl(struct wlan_acl_pool* pacl_list, u8 * mac_addr)
+{
+	return _TRUE;
+}
+
+
+
+
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_wlan_util.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_wlan_util.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_wlan_util.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_wlan_util.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,2142 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_WLAN_UTIL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+
+unsigned int EDCAParam[maxAP][3] =
+{          // UL			DL
+	{0x5ea322, 0x00a630, 0x00a44f}, //atheros AP
+	{0x5ea32b, 0x5ea42b, 0x5e4322}, //broadcom AP
+	{0x3ea430, 0x00a630, 0x3ea44f}, //cisco AP
+	{0x5ea44f, 0x00a44f, 0x5ea42b}, //marvell AP
+	{0x5ea422, 0x00a44f, 0x00a44f}, //ralink AP
+	//{0x5ea44f, 0x5ea44f, 0x5ea44f}, //realtek AP
+	{0xa44f, 0x5ea44f, 0x5e431c}, //realtek AP
+	{0x5ea42b, 0xa630, 0x5e431c}, //airgocap AP
+	{0x5ea42b, 0x5ea42b, 0x5ea42b}, //unknown AP
+//	{0x5e4322, 0x00a44f, 0x5ea44f}, //unknown AP
+};
+
+unsigned char ARTHEROS_OUI1[] = {0x00, 0x03, 0x7f};
+unsigned char ARTHEROS_OUI2[] = {0x00, 0x13, 0x74};
+
+unsigned char BROADCOM_OUI1[] = {0x00, 0x10, 0x18};
+unsigned char BROADCOM_OUI2[] = {0x00, 0x0a, 0xf7};
+unsigned char BROADCOM_OUI3[] = {0x00, 0x05, 0xb5};
+
+unsigned char CISCO_OUI[] = {0x00, 0x40, 0x96};
+unsigned char MARVELL_OUI[] = {0x00, 0x50, 0x43};
+unsigned char RALINK_OUI[] = {0x00, 0x0c, 0x43};
+unsigned char REALTEK_OUI[] = {0x00, 0xe0, 0x4c};
+unsigned char AIRGOCAP_OUI[] = {0x00, 0x0a, 0xf5};
+
+unsigned char REALTEK_96B_IE[] = {0x00, 0xe0, 0x4c, 0x02, 0x01, 0x20};
+
+extern unsigned char	MCS_rate_2R[16];
+extern unsigned char	MCS_rate_1R[16];
+extern unsigned char WPA_OUI[];
+extern unsigned char WPA_TKIP_CIPHER[4];
+extern unsigned char RSN_TKIP_CIPHER[4];
+
+#define R2T_PHY_DELAY	(0)
+
+//#define WAIT_FOR_BCN_TO_MIN	(3000)
+#define WAIT_FOR_BCN_TO_MIN	(6000)
+#define WAIT_FOR_BCN_TO_MAX	(20000)
+
+
+int cckrates_included(unsigned char *rate, int ratelen)
+{
+	int	i;
+	
+	for(i = 0; i < ratelen; i++)
+	{
+		if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+			   (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
+		return _TRUE;	
+	}
+
+	return _FALSE;
+
+}
+
+int cckratesonly_included(unsigned char *rate, int ratelen)
+{
+	int	i;
+	
+	for(i = 0; i < ratelen; i++)
+	{
+		if  ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+			   (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+		return _FALSE;	
+	}
+	
+	return _TRUE;
+}
+
+unsigned char networktype_to_raid(unsigned char network_type)
+{
+	unsigned char raid;
+
+	switch(network_type)
+	{
+		case WIRELESS_11B:
+			raid = 6;
+			break;
+		case WIRELESS_11G:
+			raid = 5;
+			break;
+		case WIRELESS_11BG:
+			raid = 4;
+			break;
+		case WIRELESS_11N:
+			raid = 3;
+			break;
+		case WIRELESS_11GN:
+			raid = 1;
+			break;
+		case WIRELESS_11BGN:
+			raid = 0;
+			break;
+		default:
+			raid = 4;
+			break;	
+
+	}
+
+	return raid;
+	
+}
+
+int judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen)
+{
+	int network_type = 0;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	if (pmlmeinfo->HT_enable)
+	{
+		network_type = WIRELESS_11N;
+	}
+	
+	if ((cckratesonly_included(rate, ratelen)) == _TRUE)
+	{
+		network_type |= WIRELESS_11B;
+	}
+	else if((cckrates_included(rate, ratelen)) == _TRUE)
+	{
+		network_type |= WIRELESS_11BG;
+	}
+	else
+	{
+		network_type |= WIRELESS_11G;
+	}
+		
+	return 	network_type;
+}
+
+unsigned char ratetbl_val_2wifirate(unsigned char rate)
+{
+	unsigned char val = 0;
+
+	switch (rate & 0x7f) 
+	{
+		case 0:
+			val = IEEE80211_CCK_RATE_1MB;
+			break;
+
+		case 1:
+			val = IEEE80211_CCK_RATE_2MB;
+			break;
+
+		case 2:
+			val = IEEE80211_CCK_RATE_5MB;
+			break;
+
+		case 3:
+			val = IEEE80211_CCK_RATE_11MB;
+			break;
+			
+		case 4:
+			val = IEEE80211_OFDM_RATE_6MB;
+			break;
+
+		case 5:
+			val = IEEE80211_OFDM_RATE_9MB;
+			break;
+
+		case 6:
+			val = IEEE80211_OFDM_RATE_12MB;
+			break;
+			
+		case 7:
+			val = IEEE80211_OFDM_RATE_18MB;
+			break;
+
+		case 8:
+			val = IEEE80211_OFDM_RATE_24MB;
+			break;
+			
+		case 9:
+			val = IEEE80211_OFDM_RATE_36MB;
+			break;
+
+		case 10:
+			val = IEEE80211_OFDM_RATE_48MB;
+			break;
+		
+		case 11:
+			val = IEEE80211_OFDM_RATE_54MB;
+			break;
+
+	}
+
+	return val;
+
+}
+
+int is_basicrate(_adapter *padapter, unsigned char rate)
+{
+	int i;
+	unsigned char val;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	
+	for(i = 0; i < NumRates; i++)
+	{
+		val = pmlmeext->basicrate[i];
+
+		if ((val != 0xff) && (val != 0xfe))
+		{
+			if (rate == ratetbl_val_2wifirate(val))
+			{
+				return _TRUE;
+			}
+		}
+	}
+	
+	return _FALSE;
+}
+
+
+unsigned int ratetbl2rateset(_adapter *padapter, unsigned char *rateset)
+{
+	int i;
+	unsigned char rate;
+	unsigned int	len = 0;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	for (i = 0; i < NumRates; i++)
+	{
+		rate = pmlmeext->datarate[i];
+
+		switch (rate)
+		{
+			case 0xff:
+				return len;
+				
+			case 0xfe:
+				continue;
+				
+			default:
+				rate = ratetbl_val_2wifirate(rate);
+
+				if (is_basicrate(padapter, rate) == _TRUE)
+				{
+					rate |= IEEE80211_BASIC_RATE_MASK;
+				}
+				
+				rateset[len] = rate;
+				len++;
+				break;
+		}
+	}
+	return len;
+}
+
+
+void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len)
+{
+	unsigned char supportedrates[NumRates];
+
+	_rtw_memset(supportedrates, 0, NumRates);
+	*bssrate_len = ratetbl2rateset(padapter, supportedrates);
+	_rtw_memcpy(pbssrate, supportedrates, *bssrate_len);
+}
+
+void Save_DM_Func_Flag(_adapter *padapter)
+{
+	struct dm_priv *pdmpriv = &padapter->dmpriv;
+	pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
+}
+
+void Restore_DM_Func_Flag(_adapter *padapter)
+{
+	struct dm_priv *pdmpriv = &padapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	
+	pdmpriv->DMFlag = pdmpriv->DMFlag_tmp;
+
+	if(pdmpriv->DMFlag&DYNAMIC_FUNC_DIG)
+	{
+		PHY_SetBBReg(padapter, rOFDM0_XAAGCCore1, 0x7f, pDigTable->CurIGValue);
+		PHY_SetBBReg(padapter, rOFDM0_XBAGCCore1, 0x7f, pDigTable->CurIGValue);
+	}
+	
+}
+
+void Switch_DM_Func(_adapter *padapter, u8 mode, u8 enable)
+{
+	struct dm_priv *pdmpriv = &padapter->dmpriv;
+
+	if(enable == _TRUE)
+	{
+		pdmpriv->DMFlag |= mode;
+	}
+	else
+	{
+		pdmpriv->DMFlag &= mode;
+	}
+
+#if 0
+	u8 val8;
+
+	val8 = rtw_read8(padapter, FW_DYNAMIC_FUN_SWITCH);
+
+	if(enable == _TRUE)
+	{
+		rtw_write8(padapter, FW_DYNAMIC_FUN_SWITCH, (val8 | mode));
+	}
+	else
+	{
+		rtw_write8(padapter, FW_DYNAMIC_FUN_SWITCH, (val8 & mode));
+	}
+#endif
+
+}
+
+void Set_NETYPE1_MSR(_adapter *padapter, u8 type)
+{
+	u8 val8;
+	
+	val8 = rtw_read8(padapter, MSR)&0x03;
+
+	rtw_write8(padapter, MSR, (val8|(type<<2)));
+
+
+}
+void Set_NETYPE0_MSR(_adapter *padapter, u8 type)
+{
+	u8 val8;
+	
+	val8 = rtw_read8(padapter, MSR)&0x0c;
+
+	rtw_write8(padapter, MSR, (val8|type));
+
+}
+
+
+void SelectChannel(_adapter *padapter, unsigned char channel)
+{
+	unsigned int scanMode;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	
+	scanMode = (pmlmeext->sitesurvey_res.state == _TRUE)? 1: 0;//todo:
+
+	if(pHalData->hal_ops.set_channel_handler)
+		pHalData->hal_ops.set_channel_handler(padapter, channel);	
+	
+}
+
+void SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char channel_offset)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	if(pHalData->hal_ops.set_bwmode_handler)
+		pHalData->hal_ops.set_bwmode_handler(padapter, (HT_CHANNEL_WIDTH)bwmode, channel_offset);
+
+}
+
+void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)
+{
+	if((bwmode == HT_CHANNEL_WIDTH_20)||(channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE))
+	{
+		SelectChannel(padapter, channel);
+	}
+	else		
+	{
+		//switch to the proper channel
+		if (channel_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+		{
+			SelectChannel(padapter, channel + 2);
+		}
+		else
+		{
+			SelectChannel(padapter, channel - 2);
+		}
+	}	
+
+	
+	SetBWMode(padapter, bwmode, channel_offset);
+	
+}
+
+int get_bsstype(unsigned short capability)
+{
+	if (capability & BIT(0))
+	{
+		return WIFI_FW_AP_STATE;
+	}
+	else if (capability & BIT(1))
+	{
+		return WIFI_FW_ADHOC_STATE;
+	}
+	else
+	{
+		return 0;		
+	}
+}
+
+__inline u8 *get_my_bssid(WLAN_BSSID_EX *pnetwork)
+{	
+	return (pnetwork->MacAddress); 
+}
+
+u16 get_beacon_interval(WLAN_BSSID_EX *bss)
+{
+	unsigned short val;
+	_rtw_memcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->IEs), 2);
+	return le16_to_cpu(val);	
+
+}
+
+int is_client_associated_to_ap(_adapter *padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))
+	{
+		return _TRUE;
+	}
+	else
+	{
+		return _FAIL;
+	}
+}
+
+int is_client_associated_to_ibss(_adapter *padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
+	{
+		return _TRUE;
+	}
+	else
+	{
+		return _FAIL;
+	}
+}
+
+int is_IBSS_empty(_adapter *padapter)
+{
+	unsigned int i;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	for (i = 6; i < NUM_STA; i++)
+	{
+		if (pmlmeinfo->FW_sta_info[i].status == 1)
+		{
+			return _FAIL;
+		}
+	}
+	
+	return _TRUE;
+	
+}
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
+{
+	if ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)
+	{
+		return WAIT_FOR_BCN_TO_MIN;
+	} 
+	else if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)
+	{
+		return WAIT_FOR_BCN_TO_MAX;
+	}	
+	else
+	{
+		return ((bcn_interval << 2));
+	}
+}
+
+void CAM_mark_invalid(
+	PADAPTER     	Adapter,	
+	u8 			ucIndex
+)
+{
+	u32 ulCommand=0;
+	u32 ulContent=0;
+	u32 ulEncAlgo=CAM_AES;
+
+	// keyid must be set in config field
+	ulContent |= (ucIndex&3) | ((u16)(ulEncAlgo)<<2);
+
+	ulContent |= CAM_VALID;
+	// polling bit, and No Write enable, and address
+	ulCommand= CAM_CONTENT_COUNT*ucIndex;
+	ulCommand= ulCommand | CAM_POLLINIG |CAM_WRITE;
+	// write content 0 is equall to mark invalid
+	rtw_write32(Adapter, WCAMI, ulContent);  //delay_ms(40);
+	//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_mark_invalid(): WRITE A4: %lx \n",ulContent));
+	rtw_write32(Adapter, RWCAM, ulCommand);  //delay_ms(40);
+	//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_mark_invalid(): WRITE A0: %lx \n",ulCommand));
+	
+}
+
+void CAM_empty_entry(
+	PADAPTER     	Adapter,	
+	u8 			ucIndex
+)
+{
+	u32 ulCommand=0;
+	u32 ulContent=0;
+	u8 i;	
+	u32 ulEncAlgo=CAM_AES;
+
+	
+	for(i=0;i<CAM_CONTENT_COUNT;i++)
+	{
+		// filled id in CAM config 2 byte
+		if( i == 0)
+		{
+			ulContent |=(ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
+			ulContent |= CAM_VALID;
+							
+		}
+		else
+		{
+			ulContent = 0;			
+		}
+		// polling bit, and No Write enable, and address
+		ulCommand= CAM_CONTENT_COUNT*ucIndex+i;
+		ulCommand= ulCommand | CAM_POLLINIG|CAM_WRITE;
+		// write content 0 is equall to mark invalid
+		rtw_write32(Adapter, WCAMI, ulContent);  //delay_ms(40);
+		//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A4: %lx \n",ulContent));
+		rtw_write32(Adapter, RWCAM, ulCommand);  //delay_ms(40);
+		//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A0: %lx \n",ulCommand));
+		
+	}
+
+	
+}
+
+void invalidate_cam_all(_adapter *padapter)
+{
+	rtw_write32(padapter, RWCAM, BIT(31)|BIT(30));
+}
+
+void write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
+{
+	unsigned int	i, j, val, addr, cmd;
+
+	addr = entry << 3;
+
+	for (j = 0; j < 6; j++)
+	{	
+		switch (j)
+		{
+			case 0:
+				val = (ctrl | (mac[0] << 16) | (mac[1] << 24) );
+				break;
+				
+			case 1:
+				val = (mac[2] | ( mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
+				break;
+			
+			default:
+				i = (j - 2) << 2;
+				val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
+				break;
+				
+		}
+
+		rtw_write32(padapter, WCAMI, val);
+		
+		cmd = CAM_POLLINIG | CAM_WRITE | (addr + j);
+		rtw_write32(padapter, RWCAM, cmd);
+		
+		//printk("%s=> cam write: %x, %x\n",__FUNCTION__, cmd, val);
+		
+	}
+
+}
+
+
+static u32 _ReadCAM(_adapter *padapter ,u32 addr)
+{
+	u32 count = 0, cmd;
+	cmd = CAM_POLLINIG |addr ;
+	rtw_write32(padapter, RWCAM, cmd);
+
+	do{
+		if(0 == (rtw_read32(padapter,REG_CAMCMD) & CAM_POLLINIG)){
+			break;
+		}
+	}while(count++ < 100);		
+
+	return rtw_read32(padapter,REG_CAMREAD);	
+}
+void read_cam(_adapter *padapter ,u8 entry)
+{
+	u32	j,count = 0, addr, cmd;
+	addr = entry << 3;
+
+	printk("********* DUMP CAM Entry_#%02d***************\n",entry);
+	for (j = 0; j < 6; j++)
+	{	
+		cmd = _ReadCAM(padapter ,addr+j);
+		printk("offset:0x%02x => 0x%08x \n",addr+j,cmd);
+	}
+	printk("*********************************\n");
+}
+int allocate_cam_entry(_adapter *padapter)
+{
+	unsigned int cam_idx;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	for (cam_idx = 6; cam_idx < NUM_STA; cam_idx++)
+	{
+		if (pmlmeinfo->FW_sta_info[cam_idx].status == 0)
+		{
+			pmlmeinfo->FW_sta_info[cam_idx].status = 1;
+			pmlmeinfo->FW_sta_info[cam_idx].retry = 0;
+			break;
+		}
+	}
+	
+	return cam_idx;
+}
+
+void flush_all_cam_entry(_adapter *padapter)
+{	
+	u32	cam_cfg;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+#if 0
+	unsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	unsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00};
+
+	for (i = 0; i < NUM_STA; i++)
+	{
+		write_cam(padapter, i, 0, null_sta, null_key);
+	}
+#else
+	cam_cfg = rtw_read32(padapter, RWCAM);
+	cam_cfg |= SECCAM_CLR;
+	rtw_write32(padapter, RWCAM, cam_cfg);	
+#endif
+	_rtw_memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
+}
+
+int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE)
+{
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);	
+	
+	if(pmlmepriv->qospriv.qos_option==0)
+	{
+		pmlmeinfo->WMM_enable = 0;
+		return _FAIL;
+	}	
+	
+	if (pregpriv->wifi_spec == 1)
+	{
+		if (pmlmeinfo->WMM_enable == 1)
+		{
+			//todo: compare the parameter set count & decide wheher to update or not
+			return _FAIL;
+		}
+		else
+		{
+			pmlmeinfo->WMM_enable = 1;
+			_rtw_memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
+			return _TRUE;
+		}
+	}
+	else
+	{
+		pmlmeinfo->WMM_enable = 0;
+		return _FAIL;
+	}
+	
+}
+
+void WMMOnAssocRsp(_adapter *padapter)
+{	
+	unsigned char		ACI, ACM, AIFS, ECWMin, ECWMax;
+	unsigned short	TXOP;
+	unsigned int		acParm, i;
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	if (pmlmeinfo->WMM_enable == 0)
+		return;
+	
+	for (i = 0; i < 4; i++)  
+	{
+		ACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;
+		ACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;
+
+		//AIFS = AIFSN * slot time + SIFS - r2t phy delay
+		AIFS = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 0x0f) * (pmlmeinfo->slotTime) + 10 - R2T_PHY_DELAY;
+		
+		ECWMin = (pmlmeinfo->WMM_param.ac_param[i].CW & 0x0f);
+		ECWMax = (pmlmeinfo->WMM_param.ac_param[i].CW & 0xf0) >> 4;
+		TXOP = le16_to_cpu(pmlmeinfo->WMM_param.ac_param[i].TXOP_limit);
+		
+		acParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);
+				
+		switch (ACI)
+		{
+			case 0x0:
+				rtw_write32(padapter, REG_EDCA_BE_PARAM, acParm);
+				break;
+								
+			case 0x1:
+				rtw_write32(padapter, REG_EDCA_BK_PARAM, acParm);
+				break;
+								
+			case 0x2:
+				rtw_write32(padapter, REG_EDCA_VI_PARAM, acParm);
+				break;
+								
+			case 0x3:
+				rtw_write32(padapter, REG_EDCA_VO_PARAM, acParm);
+				break;							
+		}
+		
+		DBG_871X("WMM(%x): %x, %x\n", ACI, ACM, acParm);
+	}
+	
+	return;	
+}
+
+static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	unsigned char	 new_bwmode;
+	unsigned char  new_ch_offset;
+	struct HT_info_element	 *pHT_info;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+
+	if(!pIE)
+		return;
+
+	pHT_info = (struct HT_info_element *)pIE->data;
+
+	if(pHT_info->infos[0] & BIT(2))
+	{
+		new_bwmode = HT_CHANNEL_WIDTH_40;
+		switch (pHT_info->infos[0] & 0x3)
+		{
+			case 1:
+				new_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				break;
+			
+			case 3:
+				new_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				break;
+				
+			default:
+				new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+				break;
+		}
+	}
+	else
+	{
+		new_bwmode = HT_CHANNEL_WIDTH_20;
+		new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	}	
+
+	
+	if((new_bwmode!= pmlmeext->cur_bwmode) || (new_ch_offset!=pmlmeext->cur_ch_offset))
+	{
+		pmlmeinfo->bwmode_updated = _TRUE;
+		
+		pmlmeext->cur_bwmode = new_bwmode;
+		pmlmeext->cur_ch_offset = new_ch_offset;
+	}
+	else
+	{
+		pmlmeinfo->bwmode_updated = _FALSE;
+	}
+		
+
+	if(_TRUE == pmlmeinfo->bwmode_updated)
+	{
+		struct sta_info *psta;
+		WLAN_BSSID_EX 	*cur_network = &(pmlmeinfo->network);
+		struct sta_priv	*pstapriv = &padapter->stapriv;
+	
+		//set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+		
+		//update ap's stainfo
+		psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
+		if(psta)
+		{
+			struct ht_priv	*phtpriv_sta = &psta->htpriv;
+			
+			if(phtpriv_sta->ht_option)
+			{				
+				// bwmode				
+				phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
+				phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;		
+			}
+			else
+			{
+				phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
+				phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+			}
+			
+		}
+
+		//pmlmeinfo->bwmode_updated = _FALSE;//bwmode_updated done, reset it!
+		
+	}	
+
+}
+
+void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	unsigned int	i;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	//struct registry_priv 	*pregpriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;	
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+
+	if(phtpriv->ht_option == 0)	return;
+	
+	pmlmeinfo->HT_caps_enable = 1;
+	
+	for (i = 0; i < (pIE->Length); i++)
+	{
+		if (i != 2)
+		{
+			//	Commented by Albert 2010/07/12
+			//	Got the endian issue here.
+			pmlmeinfo->HT_caps.HT_cap[i] &= (pIE->data[i]);
+		}
+		else
+		{
+			if ((pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para & 0x3) > (pIE->data[i] & 0x3))
+			{
+				pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para &= 0x03;
+				pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para |= (pIE->data[i] & 0x3);
+			}
+					
+			if ((pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para & 0x1c) > (pIE->data[i] & 0x1c))
+			{
+				pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para &= 0x1c;
+				pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para |= (pIE->data[i] & 0x1c);
+			}
+		}
+	}
+
+	//	Commented by Albert 2010/07/12
+	//	Have to handle the endian issue after copying.
+	//	HT_ext_caps didn't be used yet.	
+	pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info = le16_to_cpu( pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info );
+	pmlmeinfo->HT_caps.HT_cap_element.HT_ext_caps = le16_to_cpu( pmlmeinfo->HT_caps.HT_cap_element.HT_ext_caps );
+	
+	//update the MCS rates
+	for (i = 0; i < 16; i++)
+	{
+		//if (pregpriv->rf_config & RF_1T1R)
+		if((pHalData->rf_type == RF_1T1R) || (pHalData->rf_type == RF_1T2R))
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+		}
+		else
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
+		}
+		#ifdef RTL8192C_RECONFIG_TO_1T1R
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+		}
+		#endif
+	}
+	
+	return;
+}
+
+void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;	
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+
+	if(phtpriv->ht_option == 0)	return;
+	
+
+	if(pIE->Length > sizeof(struct HT_info_element))
+		return;
+	
+	pmlmeinfo->HT_info_enable = 1;
+	_rtw_memcpy(&(pmlmeinfo->HT_info), pIE->data, pIE->Length);
+	
+	return;
+}
+
+void _update_ampdu_factor(_adapter *padapter,unsigned char max_AMPDU_len)
+{
+	u8	RegToSet_Normal[4]={0x41,0xa8,0x72, 0xb9};
+	u8	RegToSet_BT[4]={0x31,0x74,0x42, 0x97};
+	u8	FactorToSet;
+	u8	*pRegToSet;
+	u8	index = 0;
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	 *pbtpriv = &(padapter->halpriv.bt_coexist);
+			
+	if((pbtpriv->BT_Coexist) &&(pbtpriv->BT_CoexistType == BT_CSR_BC4) )
+		pRegToSet = RegToSet_BT; // 0x97427431;
+	else
+#endif
+		pRegToSet = RegToSet_Normal; // 0xb972a841;		
+
+	FactorToSet =max_AMPDU_len;
+	if(FactorToSet <= 3)
+	{
+		FactorToSet = (1<<(FactorToSet + 2));
+		if(FactorToSet>0xf)
+			FactorToSet = 0xf;
+
+		for(index=0; index<4; index++)
+		{
+			if((pRegToSet[index] & 0xf0) > (FactorToSet<<4))
+				pRegToSet[index] = (pRegToSet[index] & 0x0f) | (FactorToSet<<4);
+		
+			if((pRegToSet[index] & 0x0f) > FactorToSet)
+				pRegToSet[index] = (pRegToSet[index] & 0xf0) | (FactorToSet);
+			
+			rtw_write8(padapter, (REG_AGGLEN_LMT+index), pRegToSet[index]);
+		}	
+		//RT_TRACE(_Comp, _Level, Fmt)(COMP_MLME, DBG_LOUD, ("Set HW_VAR_AMPDU_FACTOR: %#x\n", FactorToSet));
+	}
+}
+
+void HTOnAssocRsp(_adapter *padapter)
+{
+	unsigned char		max_AMPDU_len;
+	unsigned char		min_MPDU_spacing;
+	unsigned char		FactorLevel[18] = {2, 4, 4, 7, 7, 13, 13, 13, 2, 7, 7, 13, 13, 15, 15, 15, 15, 0};
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))
+	{
+		pmlmeinfo->HT_enable = 1;
+	}
+	else
+	{
+		pmlmeinfo->HT_enable = 0;
+		return;
+	}
+	
+	//handle A-MPDU parameter field
+	/* 	
+		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
+		AMPDU_para [4:2]:Min MPDU Start Spacing	
+	*/
+	max_AMPDU_len = pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para & 0x03;	
+	
+	min_MPDU_spacing = (pmlmeinfo->HT_caps.HT_cap_element.AMPDU_para & 0x1c) >> 2;	
+	rtw_write8(padapter, REG_AMPDU_MIN_SPACE, (rtw_read8(padapter, REG_AMPDU_MIN_SPACE) & 0xf8) | min_MPDU_spacing);
+#if 0	//for 92su
+	max_AMPDU_len = (1 << (max_AMPDU_len + 2));
+	
+	if (max_AMPDU_len > 0x0f)
+	{
+		max_AMPDU_len = 0x0f;
+	}
+	
+	for (i = 0; i < 17; i++)
+	{
+		if (FactorLevel[i] > max_AMPDU_len)
+		{
+			FactorLevel[i] = max_AMPDU_len;
+		}
+	}
+	
+	for (i = 0; i < 8; i++)
+	{
+		value = (FactorLevel[2*i] | (FactorLevel[2*i+1] << 4));
+		//rtw_write8(padapter, (AGGLEN_LMT_L + i), value);//todo
+	}
+
+	value = (FactorLevel[16] | (FactorLevel[17] << 4));
+	//rtw_write8(padapter, AGGLEN_LMT_H, value);//todo
+#else //for 92cu
+	_update_ampdu_factor(padapter,max_AMPDU_len);
+#endif
+
+	if ((pregpriv->cbw40_enable) &&
+		(pmlmeinfo->HT_caps.HT_cap_element.HT_caps_info & BIT(1)) && 
+		(pmlmeinfo->HT_info.infos[0] & BIT(2)))
+	{
+		//switch to the 40M Hz mode accoring to the AP
+		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
+		switch ((pmlmeinfo->HT_info.infos[0] & 0x3))
+		{
+			case 1:
+				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				break;
+			
+			case 3:
+				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				break;
+				
+			default:
+				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+				break;
+		}
+		
+		//SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
+		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+	}
+	
+
+	//
+	// Config current HT Protection mode.
+	//
+	pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;
+	
+}
+
+void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if(pIE->Length>1)
+		return;
+	
+	pmlmeinfo->ERP_enable = 1;
+	_rtw_memcpy(&(pmlmeinfo->ERP_IE), pIE->data, pIE->Length);
+}
+
+void VCS_update(_adapter *padapter, struct sta_info *psta)
+{
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	switch (pregpriv->vrtl_carrier_sense)/* 0:off 1:on 2:auto */
+	{
+		case 0: //off
+			psta->rtsen = 0;
+			psta->cts2self = 0;
+			break;
+			
+		case 1: //on
+			if (pregpriv->vcs_type == 1) /* 1:RTS/CTS 2:CTS to self */
+			{
+				psta->rtsen = 1;
+				psta->cts2self = 0;
+			}
+			else
+			{
+				psta->rtsen = 0;
+				psta->cts2self = 1;
+			}
+			break;
+			
+		case 2: //auto
+		default:
+			if ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1)))
+			{
+				if (pregpriv->vcs_type == 1)
+				{
+					psta->rtsen = 1;
+					psta->cts2self = 0;
+				}
+				else
+				{
+					psta->rtsen = 0;
+					psta->cts2self = 1;
+				}
+			}
+			else
+			{
+				psta->rtsen = 0;
+				psta->cts2self = 0;
+			}	
+			break;
+	}
+}
+
+void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)
+{
+	unsigned int i;
+	unsigned int len;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+		
+	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
+	
+	for (i = 0; i < len;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
+		
+		switch (pIE->ElementID)
+		{
+#if 0			
+			case _VENDOR_SPECIFIC_IE_:		
+				//todo: to update WMM paramter set while receiving beacon			
+				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6))	//WMM
+				{
+					(WMM_param_handler(padapter, pIE))? WMMOnAssocRsp(padapter): 0;
+				}				
+				break;
+#endif								
+
+			case _HT_EXTRA_INFO_IE_:	//HT info				
+				//HT_info_handler(padapter, pIE);
+				bwmode_update_check(padapter, pIE);
+				break;
+				
+			case _ERPINFO_IE_:
+				ERP_IE_handler(padapter, pIE);
+				VCS_update(padapter, psta);
+				break;
+				
+			default:
+				break;
+		}
+		
+		i += (pIE->Length + 2);
+	}
+	
+}
+
+unsigned int is_ap_in_tkip(_adapter *padapter)
+{
+	u32 i;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+
+	if (rtw_get_capability((WLAN_BSSID_EX *)cur_network) & WLAN_CAPABILITY_PRIVACY)
+	{
+		for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pmlmeinfo->network.IELength;)
+		{
+			pIE = (PNDIS_802_11_VARIABLE_IEs)(pmlmeinfo->network.IEs + i);
+		
+			switch (pIE->ElementID)
+			{
+				case _VENDOR_SPECIFIC_IE_:
+					if ((_rtw_memcmp(pIE->data, WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4))) 
+					{
+						return _TRUE;
+					}
+					break;
+				
+				case _RSN_IE_2_:
+					if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4)) 
+					{
+						return _TRUE;
+					}
+					
+				default:
+					break;
+			}
+		
+		i += (pIE->Length + 2);
+		}
+		
+		return _FALSE;
+	}
+	else
+	{
+		return _FALSE;
+	}
+	
+}
+
+int wifirate2_ratetbl_inx(unsigned char rate)
+{
+	int	inx = 0;
+	rate = rate & 0x7f;
+
+	switch (rate) 
+	{
+		case 54*2:
+			inx = 11;
+			break;
+
+		case 48*2:
+			inx = 10;
+			break;
+
+		case 36*2:
+			inx = 9;
+			break;
+
+		case 24*2:
+			inx = 8;
+			break;
+			
+		case 18*2:
+			inx = 7;
+			break;
+
+		case 12*2:
+			inx = 6;
+			break;
+
+		case 9*2:
+			inx = 5;
+			break;
+			
+		case 6*2:
+			inx = 4;
+			break;
+
+		case 11*2:
+			inx = 3;
+			break;
+		case 11:
+			inx = 2;
+			break;
+
+		case 2*2:
+			inx = 1;
+			break;
+		
+		case 1*2:
+			inx = 0;
+			break;
+
+	}
+	return inx;	
+}
+
+unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz)
+{
+	unsigned int i, num_of_rate;
+	unsigned int mask = 0;
+	
+	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
+		
+	for (i = 0; i < num_of_rate; i++)
+	{
+		if ((*(ptn + i)) & 0x80)
+		{
+			mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
+		}
+	}
+	return mask;
+}
+
+unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz)
+{
+	unsigned int i, num_of_rate;
+	unsigned int mask = 0;
+	
+	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
+		
+	for (i = 0; i < num_of_rate; i++)
+	{
+		mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
+	}
+
+	return mask;
+}
+
+unsigned int update_MSC_rate(struct HT_caps_element *pHT_caps)
+{
+	unsigned int mask = 0;
+	
+	mask = ((pHT_caps->HT_cap_element.MCS_rate[0] << 12) | (pHT_caps->HT_cap_element.MCS_rate[1] << 20));
+						
+	return mask;
+}
+
+int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps)
+{
+	unsigned char					bit_offset;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	if (!(pmlmeinfo->HT_enable))
+		return _FAIL;
+	
+	if ((pmlmeinfo->assoc_AP_vendor == ralinkAP))
+		return _FAIL;
+		
+	bit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40)? 6: 5;
+	
+	if (pHT_caps->HT_cap_element.HT_caps_info & (0x1 << bit_offset))
+	{
+		return _SUCCESS;
+	}
+	else
+	{
+		return _FAIL;
+	}		
+}
+
+unsigned char get_highest_rate_idx(u32 mask)
+{
+	int i;
+	unsigned char rate_idx=0;
+
+	for(i=27; i>=0; i--)
+	{
+		if(mask & BIT(i))
+		{
+			rate_idx = i;
+			break;
+		}
+	}
+
+	return rate_idx;
+}
+
+unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
+{
+	int i, mcs_rate;
+	
+	mcs_rate = (pHT_caps->HT_cap_element.MCS_rate[0] | (pHT_caps->HT_cap_element.MCS_rate[1] << 8));
+	
+	for (i = 15; i >= 0; i--)
+	{
+		if (mcs_rate & (0x1 << i))
+		{
+			break;
+		}
+	}
+	
+	return i;
+}
+
+unsigned int  _update_92cu_basic_rate(_adapter *padapter, unsigned int mask)
+{
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	 *pbtpriv = &(padapter->halpriv.bt_coexist);
+#endif
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);	
+
+	unsigned int BrateCfg = 0;
+#ifdef CONFIG_BT_COEXIST
+	if(	(pbtpriv->BT_Coexist) &&	(pbtpriv->BT_CoexistType == BT_CSR_BC4)	)
+	{
+		BrateCfg = mask  & 0x151;
+		//printk("BT temp disable cck 2/5.5/11M, (0x%x = 0x%x)\n", REG_RRSR, BrateCfg & 0x151);
+	}
+	else
+#endif
+	{
+		if(pHalData->VersionID != VERSION_TEST_CHIP_88C)
+			BrateCfg = mask  & 0x15F;
+		else	//for 88CU 46PING setting, Disable CCK 2M, 5.5M, Others must tuning
+			BrateCfg = mask  & 0x159;
+	}
+
+	BrateCfg |= 0x01; // default enable 1M ACK rate					
+
+	return BrateCfg;
+}
+
+void _update_response_rate(_adapter *padapter,unsigned int mask)
+{
+	u8	RateIndex = 0;
+	// Set RRSR rate table.
+	rtw_write8(padapter, REG_RRSR, mask&0xff);
+	rtw_write8(padapter,REG_RRSR+1, (mask>>8)&0xff);
+
+	// Set RTS initial rate
+	while(mask > 0x1)
+	{
+		mask = (mask>> 1);
+		RateIndex++;
+	}
+	rtw_write8(padapter, REG_INIRTS_RATE_SEL, RateIndex);
+}
+void Update_RA_Entry(_adapter *padapter, unsigned int mac_id)
+{
+	//volatile unsigned int result;
+	u32 init_rate=0;
+	unsigned char		networkType, raid;	
+	unsigned int		mask;
+	unsigned char		shortGIrate = _FALSE;
+	int		supportRateNum = 0;
+	struct sta_info *psta;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	 *pbtpriv = &(padapter->halpriv.bt_coexist);
+#endif
+	
+	if (mac_id >= NUM_STA) // 
+	{
+		return;
+	}
+		
+	switch (mac_id)
+	{
+		case 4: //for broadcast/multicast
+			supportRateNum = rtw_get_rateset_len(cur_network->SupportedRates);
+			networkType = judge_network_type(padapter, cur_network->SupportedRates, supportRateNum) & 0xf;
+			raid = networktype_to_raid(networkType);
+			
+			mask = update_basic_rate(cur_network->SupportedRates, supportRateNum);
+
+			//mask = _update_92cu_basic_rate(padapter,mask);
+			//_update_response_rate(padapter,mask);
+			
+			mask |= ((raid<<28)&0xf0000000);
+			
+			break;
+			
+		case 0: //for sta mode
+			supportRateNum = rtw_get_rateset_len(cur_network->SupportedRates);
+			networkType = judge_network_type(padapter, cur_network->SupportedRates, supportRateNum) & 0xf;
+			pmlmeext->cur_wireless_mode = networkType;
+			raid = networktype_to_raid(networkType);
+						
+			mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
+			mask |= (pmlmeinfo->HT_enable)? update_MSC_rate(&(pmlmeinfo->HT_caps)): 0;
+			mask |= ((raid<<28)&0xf0000000);
+			
+			if (support_short_GI(padapter, &(pmlmeinfo->HT_caps)))
+			{
+				shortGIrate = _TRUE;
+			}
+			
+			break;
+			
+		default: //for each sta in IBSS
+			supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
+			networkType = judge_network_type(padapter, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum) & 0xf;
+			pmlmeext->cur_wireless_mode = networkType;
+			raid = networktype_to_raid(networkType);
+			
+			mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
+			mask |= ((raid<<28)&0xf0000000);
+
+			//todo: support HT in IBSS
+			
+			break;
+	}
+	
+#ifdef CONFIG_BT_COEXIST
+	if( (pbtpriv->BT_Coexist) &&
+		(pbtpriv->BT_CoexistType == BT_CSR_BC4) &&
+		(pbtpriv->BT_CUR_State) &&
+		(pbtpriv->BT_Ant_isolation) &&
+		((pbtpriv->BT_Service==BT_SCO)||
+		(pbtpriv->BT_Service==BT_Busy)) )
+		mask &= 0xffffcfc0;
+	else		
+#endif
+		mask &=0xffffffff;
+	
+	
+	init_rate = get_highest_rate_idx(mask)&0x3f;
+	if (shortGIrate==_TRUE)
+		init_rate |= BIT(6);
+
+	
+	if(pHalData->fw_ractrl == _TRUE)
+	{
+		u8 arg = 0;
+
+		arg = (mac_id)&0x1f;
+		
+		arg |= BIT(7);
+		
+		if (shortGIrate==_TRUE)
+			arg |= BIT(5);
+
+		DBG_871X("update raid entry, init_rate=0x%x, mask=0x%x, arg=0x%x\n", init_rate, mask, arg);
+
+		set_raid_cmd(padapter, mask, arg);	
+		
+		rtw_write8(padapter, (REG_INIDATA_RATE_SEL+mac_id), (u8)init_rate);	
+	}
+	else
+	{
+		rtw_write8(padapter, (REG_INIDATA_RATE_SEL+(mac_id)), (u8)init_rate);		
+	}
+
+
+	//set ra_id
+	psta = pmlmeinfo->FW_sta_info[mac_id].psta;
+	if(psta)
+	{
+		psta->raid = raid;
+		psta->init_rate = init_rate;
+	}	
+		
+}
+
+void enable_rate_adaptive(_adapter *padapter)
+{
+	Update_RA_Entry(padapter, 4);//for bmc sta_info
+	Update_RA_Entry(padapter, 0);//for sta mode
+	
+	return;
+}
+
+void set_sta_rate(_adapter *padapter)
+{
+	//rate adaptive	
+	enable_rate_adaptive(padapter);
+}
+
+unsigned char check_assoc_AP(u8 *pframe, uint len)
+{
+	unsigned int	i;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+
+	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < len;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + i);
+		
+		switch (pIE->ElementID)
+		{
+			case _VENDOR_SPECIFIC_IE_:
+				if ((_rtw_memcmp(pIE->data, ARTHEROS_OUI1, 3)) || (_rtw_memcmp(pIE->data, ARTHEROS_OUI2, 3)))
+				{
+					DBG_871X("link to Artheros AP\n");
+					return atherosAP;
+				}
+				else if ((_rtw_memcmp(pIE->data, BROADCOM_OUI1, 3))
+							|| (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3))
+							|| (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3)))
+				{
+					DBG_871X("link to Broadcom AP\n");
+					return broadcomAP;
+				}
+				else if (_rtw_memcmp(pIE->data, MARVELL_OUI, 3))
+				{
+					DBG_871X("link to Marvell AP\n");
+					return marvellAP;
+				}
+				else if (_rtw_memcmp(pIE->data, RALINK_OUI, 3))
+				{
+					DBG_871X("link to Ralink AP\n");
+					return ralinkAP;
+				}
+				else if (_rtw_memcmp(pIE->data, CISCO_OUI, 3))
+				{
+					DBG_871X("link to Cisco AP\n");
+					return ciscoAP;
+				}
+				else if (_rtw_memcmp(pIE->data, REALTEK_OUI, 3))
+				{
+					DBG_871X("link to Realtek 96B\n");
+					return realtekAP;
+				}
+				else if (_rtw_memcmp(pIE->data, AIRGOCAP_OUI,3))
+				{
+					DBG_871X("link to Airgo Cap\n");
+					return airgocapAP;
+				}
+				else
+				{
+					break;
+				}
+						
+			default:
+				break;
+		}
+				
+		i += (pIE->Length + 2);
+	}
+	
+	DBG_871X("link to new AP\n");
+	return unknownAP;
+}
+
+void update_IOT_info(_adapter *padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	switch (pmlmeinfo->assoc_AP_vendor)
+	{
+		case marvellAP:
+			pmlmeinfo->turboMode_cts2self = 1;
+			pmlmeinfo->turboMode_rtsen = 0;
+			break;
+		
+		case ralinkAP:
+			pmlmeinfo->turboMode_cts2self = 0;
+			pmlmeinfo->turboMode_rtsen = 1;
+			//disable high power			
+			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), _FALSE);
+			break;
+		case realtekAP:
+			rtw_write16(padapter, 0x4cc, 0xffff);
+			rtw_write16(padapter, 0x546, 0x01c0);			
+			break;
+		default:
+			pmlmeinfo->turboMode_cts2self = 0;
+			pmlmeinfo->turboMode_rtsen = 1;
+			break;	
+	}
+	
+}
+
+
+void fire_write_MAC_cmd(_adapter *padapter, unsigned int addr, unsigned int value)
+{
+#if 0
+	struct cmd_obj					*ph2c;
+	struct reg_rw_parm			*pwriteMacPara;
+	struct cmd_priv					*pcmdpriv = &(padapter->cmdpriv);
+
+	if ((ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}	
+
+	if ((pwriteMacPara = (struct reg_rw_parm*)_rtw_zmalloc(sizeof(struct reg_rw_parm))) == NULL) 
+	{		
+		_rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		return;
+	}
+	
+	pwriteMacPara->rw = 1;
+	pwriteMacPara->addr = addr;
+	pwriteMacPara->value = value;
+	
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteMacPara, GEN_CMD_CODE(_Write_MACREG));
+	rtw_enqueue_cmd(pcmdpriv, ph2c);
+#endif	
+}
+
+void update_EDCA_param(_adapter *padapter)
+{
+	unsigned int 				trafficIndex;
+	unsigned int		edca_param;
+	static unsigned int	prv_traffic_idx = 3;
+	static u64	tx_bytes = 0;
+	static u64	rx_bytes = 0;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv			*precvpriv = &(padapter->recvpriv);
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	 	*pbtpriv = &(padapter->halpriv.bt_coexist);	
+	unsigned char 			bbtchange = _FALSE;
+#endif
+	
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	//associated AP
+	if ((pregpriv->wifi_spec == 1) || (pmlmeinfo->HT_enable == 0))
+	{
+		return;
+	}
+	
+	if (pmlmeinfo->assoc_AP_vendor >= maxAP)
+	{
+		return;
+	}
+	
+	tx_bytes = pxmitpriv->tx_bytes - tx_bytes;
+	rx_bytes = precvpriv->rx_bytes - rx_bytes;
+	
+	//traffic, TX or RX
+	if((pmlmeinfo->assoc_AP_vendor == ralinkAP)||(pmlmeinfo->assoc_AP_vendor == atherosAP))
+	{
+		if (tx_bytes > (rx_bytes << 2))
+		{ // Uplink TP is present.
+			trafficIndex = UP_LINK; 
+		}
+		else
+		{ // Balance TP is present.
+			trafficIndex = DOWN_LINK;
+		}	
+	}
+	else
+	{
+		if (rx_bytes > (tx_bytes << 2))
+		{ // Downlink TP is present.
+			trafficIndex = DOWN_LINK;
+		}
+		else
+		{ // Balance TP is present.
+			trafficIndex = UP_LINK;
+		}
+	}
+
+#ifdef CONFIG_BT_COEXIST
+	if(pbtpriv->BT_Coexist)
+	{
+		if( (pbtpriv->BT_EDCA[UP_LINK]!=0) ||  (pbtpriv->BT_EDCA[DOWN_LINK]!=0))
+		{
+			bbtchange = _TRUE;		
+		}
+	}
+#endif
+
+
+
+	
+	if (prv_traffic_idx != trafficIndex)
+	{
+
+#if 0			
+#ifdef CONFIG_BT_COEXIST
+		if(_TRUE == bbtchange)		
+			rtw_write32(padapter, REG_EDCA_BE_PARAM, pbtpriv->BT_EDCA[trafficIndex]);		
+		else
+#endif
+		//adjust EDCA parameter for BE queue
+		//fire_write_MAC_cmd(padapter, EDCA_BE_PARAM, EDCAParam[pmlmeinfo->assoc_AP_vendor][trafficIndex]);
+		rtw_write32(padapter, REG_EDCA_BE_PARAM, EDCAParam[pmlmeinfo->assoc_AP_vendor][trafficIndex]);
+
+#else
+		if((pmlmeinfo->assoc_AP_vendor == ciscoAP) && (pmlmeext->cur_wireless_mode & WIRELESS_11N))
+		{			
+			edca_param = EDCAParam[pmlmeinfo->assoc_AP_vendor][trafficIndex];
+		}
+		else
+		{
+			edca_param = EDCAParam[unknownAP][trafficIndex];
+		}
+
+#ifdef CONFIG_BT_COEXIST
+		if(_TRUE == bbtchange)		
+			edca_param = pbtpriv->BT_EDCA[trafficIndex];					
+#endif
+
+		rtw_write32(padapter, REG_EDCA_BE_PARAM, edca_param);
+#endif
+		prv_traffic_idx = trafficIndex;
+	}
+	
+//exit_update_EDCA_param:	
+
+	tx_bytes = pxmitpriv->tx_bytes;
+	rx_bytes = precvpriv->rx_bytes;
+	
+	return;
+}
+
+int update_sta_support_rate(_adapter *padapter, u8* pvar_ie, uint var_ie_len, int cam_idx)
+{
+	unsigned int	ie_len;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	int	supportRateNum = 0;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	pIE = (PNDIS_802_11_VARIABLE_IEs)rtw_get_ie(pvar_ie, _SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
+	if (pIE == NULL)
+	{
+		return _FAIL;
+	}
+	
+	_rtw_memcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);
+	supportRateNum = ie_len;
+				
+	pIE = (PNDIS_802_11_VARIABLE_IEs)rtw_get_ie(pvar_ie, _EXT_SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
+	if (pIE)
+	{
+		_rtw_memcpy((pmlmeinfo->FW_sta_info[cam_idx].SupportedRates + supportRateNum), pIE->data, ie_len);
+	}
+
+	return _SUCCESS;
+	
+}
+
+void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr)
+{
+	struct sta_info *psta;
+	u16 tid, start_seq, param;	
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct sta_priv *pstapriv = &padapter->stapriv;	
+	struct ADDBA_request	*preq = (struct ADDBA_request*)paddba_req;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	psta = rtw_get_stainfo(pstapriv, addr);
+
+	if(psta)
+	{
+		start_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;
+			
+		param = le16_to_cpu(preq->BA_para_set);
+		tid = (param>>2)&0x0f;
+		
+		preorder_ctrl = &psta->recvreorder_ctrl[tid];
+
+		preorder_ctrl->indicate_seq = start_seq;
+		
+		preorder_ctrl->enable =(pmlmeinfo->bAcceptAddbaReq == _TRUE)? _TRUE :_FALSE;
+	}
+
+}
+
+void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
+{	
+	u8* pIE;
+	u32 *pbuf;
+		
+	pIE = pframe + sizeof(struct ieee80211_hdr_3addr);
+	pbuf = (u32*)pIE;
+
+	pmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));
+	
+	pmlmeext->TSFValue = pmlmeext->TSFValue << 32;
+
+	pmlmeext->TSFValue |= le32_to_cpu(*pbuf);
+}
+
+void correct_TSF(_adapter *padapter, struct mlme_ext_priv *pmlmeext)
+{
+	u64 tsf;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);	
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 isNormalChip = IS_NORMAL_CHIP(pHalData->VersionID);
+
+	tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
+
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{				
+		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
+		//rtw_write8(padapter, REG_TXPAUSE, (rtw_read8(padapter, REG_TXPAUSE)|BIT(6)));
+		StopTxBeacon(padapter);
+		
+	}
+
+	//disable related TSF function
+	rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(3)));
+				
+	rtw_write32(padapter, REG_TSFTR, (u32)(tsf));
+	rtw_write32(padapter, REG_TSFTR+4, (u32)(tsf>>32) );
+
+	//enable related TSF function
+	rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(3));
+	
+				
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		//pHalData->RegTxPause  &= (~STOP_BCNQ);
+		//rtw_write8(padapter, REG_TXPAUSE, (rtw_read8(padapter, REG_TXPAUSE)&(~BIT(6))));
+		ResumeTxBeacon(padapter);
+		
+	}
+
+}
+void _update_related_bcn_reg(_adapter *padapter)
+{
+	u32 value32;
+	rtw_write8(padapter, REG_SLOT, 0x09);
+
+	value32 =rtw_read32(padapter, REG_TCR); 
+	value32 &= ~TSFRST;
+	rtw_write32(padapter,  REG_TCR, value32); 
+
+	value32 |= TSFRST;
+	rtw_write32(padapter, REG_TCR, value32); 
+
+	// NOTE: Fix test chip's bug (about contention windows's randomness)
+	rtw_write8(padapter,  REG_RXTSF_OFFSET_CCK, 0x50);
+	rtw_write8(padapter, REG_RXTSF_OFFSET_OFDM, 0x50);
+	rtw_write8(padapter, REG_BCN_CTRL,0x12);
+}
+void beacon_timing_control(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	//reset TSF, enable update TSF, correcting TSF On Beacon 
+	
+	//REG_BCN_INTERVAL
+	//REG_BCNDMATIM
+	//REG_ATIMWND
+	//REG_TBTT_PROHIBIT
+	//REG_DRVERLYINT
+	//REG_BCN_MAX_ERR	
+	//REG_BCNTCFG //(0x510)
+	//REG_DUAL_TSF_RST
+	//REG_BCN_CTRL //(0x550) 
+
+	//BCN interval
+	rtw_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);
+	rtw_write8(padapter, REG_BCNDMATIM, 0x02); // 2ms
+	rtw_write8(padapter, REG_ATIMWND, 0x0a); // 10ms
+	rtw_write8(padapter, REG_DRVERLYINT, 0x05);// 5ms
+	rtw_write16(padapter, REG_TBTT_PROHIBIT, 0x6404);	
+		
+	
+	rtw_write8(padapter, REG_BCN_MAX_ERR, 0xff);	
+
+	_update_related_bcn_reg(padapter);
+	
+	if(IS_NORMAL_CHIP( pHalData->VersionID)){
+		rtw_write16(padapter, REG_BCNTCFG, 0x660F);
+	}
+	else{		
+		rtw_write16(padapter, REG_BCNTCFG, 0x66FF);
+	}
+
+	
+	rtw_write8(padapter, REG_BCN_CTRL, BIT(4)|EN_BCN_FUNCTION|BIT(1));
+
+	rtw_write8(padapter, REG_RD_CTRL+1, 0x6f);
+
+	ResumeTxBeacon(padapter);
+
+	//rtw_write8(padapter, 0x422, rtw_read8(padapter, 0x422)|BIT(6));
+	
+	//rtw_write8(padapter, 0x541, 0xff);
+
+	//rtw_write8(padapter, 0x542, rtw_read8(padapter, 0x541)|BIT(0));
+
+	rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(1));	
+
+
+#if 0
+	//reset TSF	
+	rtw_write8(padapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+
+	//enable TSF Function	
+	rtw_write8(padapter, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+	
+	//enable update TSF
+	if(IS_NORMAL_CHIP(pHalData->VersionID))
+	{		
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));
+	}
+	else
+	{
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~(BIT(4)|BIT(5))));
+	}
+
+
+	//notes://set "Set_NETYPE0_MSR" change to sta_mode -> will stop DMA beacon;
+	
+
+	rtw_write16(padapter, BCNITV, pmlmeinfo->bcn_interval);
+	rtw_write16(padapter, BCNDMATIM, 0x0800);
+	rtw_write16(padapter, DRVERLYINT, 0x0050);
+	rtw_write16(padapter, ATIMWND, 0x000a);
+	rtw_write8(padapter, BCNERRTH, 0xa);
+	
+#if 0	
+	rtl_outb(0xb026007A, 0x04);
+	value16 = ((bcn_interval - 3) * 1024) / 32;
+	rtl_outw(0xb026007C, value16);
+#endif
+	
+	pmlmeinfo->slotTime = 20;
+	rtw_write8(padapter, SLOT, 20);
+	
+	//reset TSF timer
+	rtw_write32(padapter, TCR, (rtw_read32(padapter, TCR) & 0xFDFF));
+	rtw_write32(padapter, TCR, (rtw_read32(padapter, TCR) | BIT(9)));
+#endif
+
+}
+
+void ResumeTxBeacon(_adapter *padapter)
+{
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);	
+
+	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
+	// which should be read from register to a global variable.
+
+	 if(IS_NORMAL_CHIP(pHalData->VersionID))
+	 {
+		rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
+		pHalData->RegFwHwTxQCtrl |= BIT6;
+		rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0xff);
+		pHalData->RegReg542 |= BIT0;
+		rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
+	 }
+	 else
+	 {
+		pHalData->RegTxPause = rtw_read8(padapter, REG_TXPAUSE);
+		rtw_write8(padapter, REG_TXPAUSE, pHalData->RegTxPause & (~BIT6));
+	 }
+	 
+}
+
+void StopTxBeacon(_adapter *padapter)
+{
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
+
+	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
+	// which should be read from register to a global variable.
+
+ 	if(IS_NORMAL_CHIP(pHalData->VersionID))
+	 {
+		rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
+		pHalData->RegFwHwTxQCtrl &= (~BIT6);
+		rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0x64);
+		pHalData->RegReg542 &= ~(BIT0);
+		rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
+	 }
+	 else
+	 {
+		pHalData->RegTxPause = rtw_read8(padapter, REG_TXPAUSE);
+		rtw_write8(padapter, REG_TXPAUSE, pHalData->RegTxPause | BIT6);
+	 }
+
+	 //todo: CheckFwRsvdPageContent(Adapter);  // 2010.06.23. Added by tynli.
+
+}
+
+unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame)
+{
+	unsigned short				ATIMWindow;
+	unsigned char					*pframe;
+	struct tx_desc 				*ptxdesc;
+	struct ieee80211_hdr 	*pwlanhdr;
+	unsigned short				*fctrl;
+	unsigned int					rate_len, len = 0;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	
+	_rtw_memset(beacon_frame, 0, 256);
+	
+	pframe = beacon_frame + TXDESC_SIZE;
+	
+	pwlanhdr = (struct ieee80211_hdr *)pframe;	
+	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	
+	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+	
+	SetFrameSubType(pframe, WIFI_BEACON);
+	
+	pframe += sizeof(struct ieee80211_hdr_3addr);	
+	len = sizeof(struct ieee80211_hdr_3addr);
+
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	len += 8;
+
+	// beacon interval: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
+	pframe += 2;
+	len += 2;
+
+	// capability info: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+	pframe += 2;
+	len += 2;
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &len);
+
+	// supported rates...
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &len);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &len);
+
+	// IBSS Parameter Set...
+	//ATIMWindow = cur->Configuration.ATIMWindow;
+	ATIMWindow = 0;
+	pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &len);
+
+	//todo: ERP IE
+	
+	// EXTERNDED SUPPORTED RATE
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &len);
+	}
+
+	if ((len + TXDESC_SIZE) > 256)
+	{
+		//printk("marc: beacon frame too large\n");
+		return 0;
+	}
+
+	//fill the tx descriptor
+	ptxdesc = (struct tx_desc *)beacon_frame;
+	
+	//offset 0	
+	ptxdesc->txdw0 |= cpu_to_le32(len & 0x0000ffff); 
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) << OFFSET_SHT) & 0x00ff0000); //default = 32 bytes for TX Desc
+	
+	//offset 4	
+	ptxdesc->txdw1 |= cpu_to_le32((0x10 << QSEL_SHT) & 0x00001f00);
+	
+	//offset 8		
+	ptxdesc->txdw2 |= cpu_to_le32(BMC);
+	ptxdesc->txdw2 |= cpu_to_le32(BK);
+
+	//offset 16		
+	ptxdesc->txdw4 = 0x80000000;
+	
+	//offset 20
+	ptxdesc->txdw5 = 0x00000000; //1M	
+	
+	return (len + TXDESC_SIZE);
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_xmit.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_xmit.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/core/rtw_xmit.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/core/rtw_xmit.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,2172 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL871X_XMIT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_byteorder.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+#include <circ_buf.h>
+#include <ip.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#include <if_ether.h>
+#endif
+
+
+#ifdef  PLATFORM_LINUX
+#include <linux/rtnetlink.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+
+static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
+static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+
+
+static void _init_txservq(struct tx_servq *ptxservq)
+{
+_func_enter_;
+	_rtw_init_listhead(&ptxservq->tx_pending);
+	_rtw_init_queue(&ptxservq->sta_pending);
+	ptxservq->qcnt = 0;
+_func_exit_;		
+}
+
+
+void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
+{	
+	
+_func_enter_;
+
+	_rtw_memset((unsigned char *)psta_xmitpriv, 0, sizeof (struct sta_xmit_priv));
+
+	_rtw_spinlock_init(&psta_xmitpriv->lock);
+	
+	//for(i = 0 ; i < MAX_NUMBLKS; i++)
+	//	_init_txservq(&(psta_xmitpriv->blk_q[i]));
+
+	_init_txservq(&psta_xmitpriv->be_q);
+	_init_txservq(&psta_xmitpriv->bk_q);
+	_init_txservq(&psta_xmitpriv->vi_q);
+	_init_txservq(&psta_xmitpriv->vo_q);
+	_rtw_init_listhead(&psta_xmitpriv->legacy_dz);
+	_rtw_init_listhead(&psta_xmitpriv->apsd);
+	
+_func_exit_;	
+
+}
+
+s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
+{
+	int i;
+	struct xmit_buf *pxmitbuf;
+	struct xmit_frame *pxframe;
+	sint	res=_SUCCESS;   
+
+_func_enter_;   	
+
+	_rtw_memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
+	
+	_rtw_spinlock_init(&pxmitpriv->lock);
+	_rtw_init_sema(&pxmitpriv->xmit_sema, 0);
+	_rtw_init_sema(&pxmitpriv->terminate_xmitthread_sema, 0);
+
+	/* 
+	Please insert all the queue initializaiton using _rtw_init_queue below
+	*/
+
+	pxmitpriv->adapter = padapter;
+	
+	//for(i = 0 ; i < MAX_NUMBLKS; i++)
+	//	_rtw_init_queue(&pxmitpriv->blk_strms[i]);
+	
+	_rtw_init_queue(&pxmitpriv->be_pending);
+	_rtw_init_queue(&pxmitpriv->bk_pending);
+	_rtw_init_queue(&pxmitpriv->vi_pending);
+	_rtw_init_queue(&pxmitpriv->vo_pending);
+	_rtw_init_queue(&pxmitpriv->bm_pending);
+
+	//_rtw_init_queue(&pxmitpriv->legacy_dz_queue);
+	//_rtw_init_queue(&pxmitpriv->apsd_queue);
+
+	_rtw_init_queue(&pxmitpriv->free_xmit_queue);
+
+
+	/*	
+	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME, 
+	and initialize free_xmit_frame below.
+	Please also apply  free_txobj to link_up all the xmit_frames...
+	*/
+
+	pxmitpriv->pallocated_frame_buf = _rtw_zmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+	
+	if (pxmitpriv->pallocated_frame_buf  == NULL){
+		pxmitpriv->pxmit_frame_buf =NULL;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_frame fail!\n"));	
+		res= _FAIL;
+		goto exit;
+	}
+	pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -
+							((SIZE_PTR) (pxmitpriv->pallocated_frame_buf) &3);
+
+	pxframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
+
+
+	for (i = 0; i < NR_XMITFRAME; i++)
+	{
+		_rtw_init_listhead(&(pxframe->list));
+
+		pxframe->padapter = padapter;
+		pxframe->frame_tag = NULL_FRAMETAG;
+
+		pxframe->pkt = NULL;		
+
+             pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+ 
+		rtw_list_insert_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.queue));
+
+		pxframe++;
+	}
+
+	pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;
+
+	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
+
+
+	//init xmit_buf
+	_rtw_init_queue(&pxmitpriv->free_xmitbuf_queue);
+	_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);
+
+	pxmitpriv->pallocated_xmitbuf = _rtw_zmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);	
+	if (pxmitpriv->pallocated_xmitbuf  == NULL){
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_buf fail!\n"));
+		res= _FAIL;
+		goto exit;
+	}
+
+	pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -
+							((SIZE_PTR) (pxmitpriv->pallocated_xmitbuf) &3);
+
+	pxmitbuf = (struct xmit_buf*)pxmitpriv->pxmitbuf;
+
+	for (i = 0; i < NR_XMITBUFF; i++)
+	{
+		_rtw_init_listhead(&pxmitbuf->list);
+
+		pxmitbuf->priv_data = NULL;
+		pxmitbuf->padapter = padapter;
+
+		pxmitbuf->pallocated_buf = _rtw_zmalloc(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ);
+		if (pxmitbuf->pallocated_buf == NULL)
+		{
+			res = _FAIL;
+			goto exit;
+		}
+
+		pxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -((SIZE_PTR) (pxmitbuf->pallocated_buf) &(XMITBUF_ALIGN_SZ-1));
+
+		rtw_os_xmit_resource_alloc(padapter, pxmitbuf);
+
+		pxmitbuf->flags = XMIT_VO_QUEUE;
+
+		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));
+
+		pxmitbuf++;
+	}
+
+	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
+
+
+
+#ifdef CONFIG_USB_HCI
+
+	rtw_alloc_hwxmits(padapter);
+	rtw_init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
+
+	pxmitpriv->txirp_cnt=1;
+
+	_rtw_init_sema(&(pxmitpriv->tx_retevt), 0);
+
+	//per AC pending irp
+	pxmitpriv->beq_cnt = 0;
+	pxmitpriv->bkq_cnt = 0;
+	pxmitpriv->viq_cnt = 0;
+	pxmitpriv->voq_cnt = 0;
+
+#ifdef PLATFORM_LINUX
+	tasklet_init(&pxmitpriv->xmit_tasklet,
+	     (void(*)(unsigned long))xmit_tasklet,
+	     (unsigned long)padapter);
+#endif
+
+#endif
+
+exit:
+
+_func_exit_;	
+
+	return _SUCCESS;
+}
+
+static void  mfree_xmit_priv_lock (struct xmit_priv *pxmitpriv)
+{
+	_rtw_spinlock_free(&pxmitpriv->lock);
+	_rtw_free_sema(&pxmitpriv->xmit_sema);
+	_rtw_free_sema(&pxmitpriv->terminate_xmitthread_sema);
+
+	_rtw_spinlock_free(&pxmitpriv->be_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->bk_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->vi_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->vo_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->bm_pending.lock);
+
+	//_rtw_spinlock_free(&pxmitpriv->legacy_dz_queue.lock);
+	//_rtw_spinlock_free(&pxmitpriv->apsd_queue.lock);
+
+	_rtw_spinlock_free(&pxmitpriv->free_xmit_queue.lock);
+	_rtw_spinlock_free(&pxmitpriv->free_xmitbuf_queue.lock);
+	_rtw_spinlock_free(&pxmitpriv->pending_xmitbuf_queue.lock);
+}
+
+
+void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv)
+{
+       int i;
+      _adapter *padapter = pxmitpriv->adapter;
+	struct xmit_frame	*pxmitframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+
+ _func_enter_;   
+ 
+	mfree_xmit_priv_lock(pxmitpriv);
+ 
+ 	if(pxmitpriv->pxmit_frame_buf==NULL)
+		goto out;
+	
+	for(i=0; i<NR_XMITFRAME; i++)
+	{	
+		rtw_os_xmit_complete(padapter, pxmitframe);		
+
+		pxmitframe++;
+	}		
+	
+	for(i=0; i<NR_XMITBUFF; i++)
+	{
+		rtw_os_xmit_resource_free(padapter, pxmitbuf);
+
+		if(pxmitbuf->pallocated_buf)
+			_rtw_mfree(pxmitbuf->pallocated_buf, MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ);
+		
+		pxmitbuf++;
+	}
+
+	
+	if(pxmitpriv->pallocated_frame_buf)
+		_rtw_mfree(pxmitpriv->pallocated_frame_buf, NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+	
+
+	if(pxmitpriv->pallocated_xmitbuf)
+		_rtw_mfree(pxmitpriv->pallocated_xmitbuf, NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
+
+
+	rtw_free_hwxmits(padapter);
+
+out:	
+
+_func_exit_;		
+
+}
+
+static void update_attrib_vcs_info(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	u32	sz;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	struct sta_info	*psta = pattrib->psta;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+
+	if (pattrib->nr_frags != 1)
+	{
+		sz = padapter->xmitpriv.frag_len;
+	}
+	else //no frag
+	{
+		sz = pattrib->last_txcmdsz;
+	}
+
+	// (1) RTS_Threshold is compared to the MPDU, not MSDU.
+	// (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame.
+	//		Other fragments are protected by previous fragment.
+	//		So we only need to check the length of first fragment.
+	if(pmlmeext->cur_wireless_mode < WIRELESS_11N )
+	{
+		if(sz > padapter->registrypriv.rts_thresh)
+		{
+			pattrib->vcs_mode = RTS_CTS;
+		}
+		else
+		{
+			if(psta->rtsen)
+				pattrib->vcs_mode = RTS_CTS;
+			else if(psta->cts2self)
+				pattrib->vcs_mode = CTS_TO_SELF;
+			else
+				pattrib->vcs_mode = NONE_VCS;
+		}
+	}
+	else
+	{
+		while (_TRUE)
+		{
+#if 0 //Todo
+			//check IOT action
+			if(pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF)
+			{
+				pattrib->vcs_mode = CTS_TO_SELF;
+				pattrib->rts_rate = MGN_24M;
+				break;
+			}
+			else if(pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS|HT_IOT_ACT_PURE_N_MODE))
+			{
+				pattrib->vcs_mode = RTS_CTS;
+				pattrib->rts_rate = MGN_24M;
+				break;
+			}
+#endif
+			//check ERP protection
+			if(psta->rtsen || psta->cts2self)
+			{
+				if(psta->rtsen)
+					pattrib->vcs_mode = RTS_CTS;
+				else if(psta->cts2self)
+					pattrib->vcs_mode = CTS_TO_SELF;
+
+				break;
+			}
+
+			//check HT op mode
+			if(pattrib->ht_en)
+			{
+				u8 HTOpMode = pmlmeinfo->HT_protection;
+				if((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||
+					(!pmlmeext->cur_bwmode && HTOpMode == 3) )
+				{
+					pattrib->vcs_mode = RTS_CTS;
+					break;
+				}
+			}
+
+			//check rts
+			if(sz > padapter->registrypriv.rts_thresh)
+			{
+				pattrib->vcs_mode = RTS_CTS;
+				break;
+			}
+
+			//to do list: check MIMO power save condition.
+
+			//check AMPDU aggregation for TXOP
+			if(pattrib->ampdu_en==_TRUE)
+			{
+				pattrib->vcs_mode = RTS_CTS;
+				break;
+			}
+
+			pattrib->vcs_mode = NONE_VCS;
+			break;
+		}
+	}
+}
+
+static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)
+{
+	//
+	if(psta->rtsen)	
+		pattrib->vcs_mode = RTS_CTS;	
+	else if(psta->cts2self)	
+		pattrib->vcs_mode = CTS_TO_SELF;	
+	else
+		pattrib->vcs_mode = NONE_VCS;
+
+	
+	//qos_en, ht_en, init rate, ,bw, ch_offset, sgi
+	pattrib->qos_en = psta->qos_option;
+	pattrib->ht_en = psta->htpriv.ht_option;
+	pattrib->raid = psta->raid;
+	pattrib->bwmode = psta->htpriv.bwmode;
+	pattrib->ch_offset = psta->htpriv.ch_offset;
+	pattrib->sgi= psta->htpriv.sgi;
+	pattrib->ampdu_en = _FALSE;
+	
+	if(pattrib->ht_en && psta->htpriv.ampdu_enable)
+	{
+		if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
+			pattrib->ampdu_en = _TRUE;
+	}	
+	
+}
+
+static void set_qos(struct pkt_file *ppktfile, struct pkt_attrib *pattrib)
+{
+	struct ethhdr etherhdr;
+	struct iphdr ip_hdr;
+	s32 UserPriority = 0;
+
+
+	_rtw_open_pktfile(ppktfile->pkt, ppktfile);
+	_rtw_pktfile_read(ppktfile, (unsigned char*)&etherhdr, ETH_HLEN);
+
+	// get UserPriority from IP hdr
+	if (pattrib->ether_type == 0x0800) {
+		_rtw_pktfile_read(ppktfile, (u8*)&ip_hdr, sizeof(ip_hdr));
+//		UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3;
+		UserPriority = ip_hdr.tos >> 5;
+	} else if (pattrib->ether_type == 0x888e) {
+		// "When priority processing of data frames is supported,
+		// a STA's SME should send EAPOL-Key frames at the highest priority."
+		UserPriority = 7;
+	}
+	
+	pattrib->priority = UserPriority;
+	//printk("%s,priority(%x)\n",__FUNCTION__,pattrib->priority);
+	pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
+	pattrib->subtype = WIFI_QOS_DATA_TYPE;
+}
+
+static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattrib)
+{
+	uint i;
+	struct pkt_file pktfile;
+	struct sta_info *psta = NULL;
+	struct ethhdr etherhdr;
+
+	sint bmcast;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv= &pmlmepriv->qospriv;
+	sint res = _SUCCESS;
+
+ _func_enter_;
+
+	_rtw_open_pktfile(pkt, &pktfile);
+	i = _rtw_pktfile_read(&pktfile, (u8*)&etherhdr, ETH_HLEN);
+
+	pattrib->ether_type = ntohs(etherhdr.h_proto);
+
+
+	_rtw_memcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);
+	_rtw_memcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);
+
+	pattrib->pctrl = 0;
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	}
+	else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		_rtw_memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	}
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
+	}
+#ifdef CONFIG_MP_INCLUDED
+	else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	{
+		//firstly, filter packet not belongs to mp
+		if (pattrib->ether_type != 0x8712) {
+			res = _FAIL;
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+				 ("IN WIFI_MP_STATE but the ether_type(0x%x) != 0x8712!!!\n",
+				 pattrib->ether_type));
+			goto exit;
+		}
+
+		//for mp storing the txcmd per packet,
+		//according to the info of txcmd to update pattrib
+		i = _rtw_pktfile_read(&pktfile, (u8*)&txdesc, TXDESC_SIZE);//get MP_TXDESC_SIZE bytes txcmd per packet
+
+		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);		 
+
+		pattrib->pctrl = 1;
+	}
+#endif
+
+	pattrib->pktlen = pktfile.pkt_len;	// rtw_xmitframe_coalesce() overwirte this!
+
+	if (ETH_P_IP == pattrib->ether_type)
+	{
+		// The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time 
+		// to prevent DHCP protocol fail
+		u8 tmp[24];
+		_rtw_pktfile_read(&pktfile, &tmp[0], 24);
+		pattrib->dhcp_pkt = 0;
+		if (pktfile.pkt_len > 282) {//MINIMUM_DHCP_PACKET_SIZE) {
+			if (ETH_P_IP == pattrib->ether_type) {// IP header
+				if (((tmp[21] == 68) && (tmp[23] == 67)) ||
+					((tmp[21] == 67) && (tmp[23] == 68))) {
+					// 68 : UDP BOOTP client
+					// 67 : UDP BOOTP server
+					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("======================update_attrib: get DHCP Packet \n"));
+					// Use low rate to send DHCP packet.
+					//if(pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) 
+					//{
+					//	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee);//0xc;//ofdm 6m
+					//	tcb_desc->bTxDisableRateFallBack = _FALSE;
+					//}
+					//else
+					//	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate; 
+					//RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate)); 
+					pattrib->dhcp_pkt = 1;
+				}
+			}
+		}
+	}
+
+#ifdef CONFIG_LPS
+	// If EAPOL , ARP , OR DHCP packet, driver must be in active mode.
+	if ( (pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1) )
+	{
+		lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);
+	}
+#endif
+
+	bmcast = IS_MCAST(pattrib->ra);
+	
+	// get sta_info
+	if (bmcast) {
+		psta = rtw_get_bcmc_stainfo(padapter);
+		pattrib->mac_id = 4;		
+	} else {
+#ifdef CONFIG_MP_INCLUDED
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		{
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			//padapter->mppriv.tx_pktcount++;
+			pattrib->mac_id = 5;			
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+				 ("update_attrib: [MP]xmit pkt:%d\n", padapter->mppriv.tx_pktcount));
+		}
+		else
+#endif
+		{
+			psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+			if (psta == NULL)	{ // if we cannot get psta => drrp the pkt
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail \n"));
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nra:%x:%x:%x:%x:%x:%x\n", 
+				pattrib->ra[0], pattrib->ra[1],
+				pattrib->ra[2], pattrib->ra[3],
+				pattrib->ra[4], pattrib->ra[5]));
+				res =_FAIL;
+				goto exit;
+			}
+
+
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+				pattrib->mac_id = 0;				
+			} else {
+				pattrib->mac_id = psta->mac_id;
+			}
+				
+		}
+
+	}
+
+	if (psta) {
+		
+		pattrib->psta = psta;	
+		
+	} else {
+		// if we cannot get psta => drrp the pkt
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+			 ("\nra:%x:%x:%x:%x:%x:%x\n",
+			  pattrib->ra[0], pattrib->ra[1], pattrib->ra[2],
+			  pattrib->ra[3], pattrib->ra[4], pattrib->ra[5]));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pattrib->ack_policy = 0;
+	// get ether_hdr_len
+	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4 ): 14; //vlan tag
+
+	if (pqospriv->qos_option) {
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) && psta->qos_option) 
+			set_qos(&pktfile, pattrib);
+		else
+			set_qos(&pktfile, pattrib);
+	} else {
+		pattrib->hdrlen = WLAN_HDR_A3_LEN;
+		pattrib->subtype = WIFI_DATA_TYPE;	
+		pattrib->priority = 0;
+	}
+	//pattrib->priority = 5; //force to used VI queue, for testing
+
+	if (psta->ieee8021x_blocked == _TRUE)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n psta->ieee8021x_blocked == _TRUE \n"));
+
+		pattrib->encrypt = 0;
+
+		if((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE))
+		{
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npsta->ieee8021x_blocked == _TRUE pattrib->ether_type(%.4x) != 0x888\n",pattrib->ether_type));
+			res = _FAIL;
+			goto exit;
+		}
+	}
+	else
+	{
+		/*
+		if((psecuritypriv->ndisauthtype>2 && (psecuritypriv->ndisauthtype!=5)&&(psecuritypriv->ndisauthtype!=3)&&(psecuritypriv->ndisauthtype!=6) )&&(psecuritypriv->bgrpkey_handshake==_FALSE))
+		{
+			if(pattrib->ether_type== 0x888e){
+				psecuritypriv->bgrpkey_handshake=_TRUE;
+
+			}
+			else{
+				DbgPrint("\npsecuritypriv->bgrpkey_handshake==_FALSE\n");
+				res =_FAIL;
+				goto exit;
+			}
+		}
+		*/
+
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
+
+		//pattrib->key_idx = psecuritypriv->dot11PrivacyKeyIndex;
+
+		switch(psecuritypriv->dot11AuthAlgrthm)
+		{
+			case dot11AuthAlgrthm_Open:
+			case dot11AuthAlgrthm_Shared:
+			case dot11AuthAlgrthm_Auto:				
+				pattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;
+				break;
+			case dot11AuthAlgrthm_8021X:
+				if(bmcast)					
+					pattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;	
+				else
+					pattrib->key_idx = 0;
+				break;
+			default:
+				pattrib->key_idx = 0;
+				break;
+		}
+		
+			
+	}
+
+	switch (pattrib->encrypt)
+	{
+		case _WEP40_:
+		case _WEP104_:
+			pattrib->iv_len = 4;
+			pattrib->icv_len = 4;
+			break;
+
+		case _TKIP_:
+			pattrib->iv_len = 8;
+			pattrib->icv_len = 4;
+			
+			if(padapter->securitypriv.busetkipkey==_FAIL)
+			{
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npadapter->securitypriv.busetkipkey(%d)==_FAIL drop packet\n", padapter->securitypriv.busetkipkey));
+				res =_FAIL;
+				goto exit;
+			}
+					
+			break;			
+		case _AES_:
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n pattrib->encrypt=%d  (_AES_)\n",pattrib->encrypt));
+			pattrib->iv_len = 8;
+			pattrib->icv_len = 8;
+			break;
+			
+		default:
+			pattrib->iv_len = 0;
+			pattrib->icv_len = 0;
+			break;
+	}
+	//printk("##### update_attrib: encrypt=%d  securitypriv.sw_encrypt=%d IV_LEN(%d)\n",pattrib->encrypt, padapter->securitypriv.sw_encrypt,pattrib->iv_len);
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+		 ("update_attrib: encrypt=%d  securitypriv.sw_encrypt=%d\n",
+		  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
+
+	if (pattrib->encrypt &&
+	    ((padapter->securitypriv.sw_encrypt == _TRUE) || (psecuritypriv->hw_decrypted == _FALSE)))
+	{
+		pattrib->bswenc = _TRUE;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,
+			 ("update_attrib: encrypt=%d securitypriv.hw_decrypted=%d bswenc=_TRUE\n",
+			  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
+	} else {
+		pattrib->bswenc = _FALSE;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("update_attrib: bswenc=_FALSE\n"));
+	}
+
+
+#ifdef CONFIG_MP_INCLUDED
+	//if in MP_STATE, update pkt_attrib from mp_txcmd, and overwrite some settings above.
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) {
+		pattrib->priority = (txdesc.txdw1 >> QSEL_SHT) & 0x1f;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+			 ("update_attrib: [MP]priority=0x%x\n", pattrib->priority));
+	}
+#endif
+
+
+	set_tx_chksum_offload(pkt, pattrib);
+	
+	update_attrib_phy_info(pattrib, psta);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
+	sint 			curfragnum,length;
+	u8	*pframe, *payload,mic[8];
+	struct	mic_data		micdata;
+	struct	sta_info		*stainfo;
+	struct	qos_priv   *pqospriv= &(padapter->mlmepriv.qospriv);	
+	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+	u8 priority[4]={0x0,0x0,0x0,0x0};
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if(pattrib->psta)
+	{
+		stainfo = pattrib->psta;
+	}
+	else
+	{
+		stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
+	}	
+
+	
+
+_func_enter_;
+
+	if(pattrib->encrypt ==_TKIP_)//if(psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_) 
+	{
+		//encode mic code
+		if(stainfo!= NULL){
+			u8 null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
+
+#if USB_TX_AGGREGATION_92C
+			pframe = pxmitframe->buf_addr + TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);
+#else
+			pframe = pxmitframe->buf_addr + TXDESC_OFFSET;
+#endif
+			
+			if(bmcst)
+			{
+				if(_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey.skey, null_key, 16)==_TRUE){
+					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
+					//rtw_msleep_os(10);
+					return _FAIL;
+				}				
+				//start to calculate the mic code
+				rtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey.skey);
+			}
+			else
+			{
+				if(_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==_TRUE){
+					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
+					//rtw_msleep_os(10);
+					return _FAIL;
+				}
+				//start to calculate the mic code
+				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
+			}
+			
+			if(pframe[1]&1){   //ToDS==1
+				rtw_secmicappend(&micdata, &pframe[16], 6);  //DA
+				if(pframe[1]&2)  //From Ds==1
+					rtw_secmicappend(&micdata, &pframe[24], 6);
+				else
+				rtw_secmicappend(&micdata, &pframe[10], 6);		
+			}	
+			else{	//ToDS==0
+				rtw_secmicappend(&micdata, &pframe[4], 6);   //DA
+				if(pframe[1]&2)  //From Ds==1
+					rtw_secmicappend(&micdata, &pframe[16], 6);
+				else
+					rtw_secmicappend(&micdata, &pframe[10], 6);
+
+			}
+
+                    if(pqospriv->qos_option==1)
+				priority[0]=(u8)pxmitframe->attrib.priority;
+
+			
+			rtw_secmicappend(&micdata, &priority[0], 4);
+	
+			payload=pframe;
+
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+				payload=(u8 *)RND4((SIZE_PTR)(payload));
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("===curfragnum=%d, pframe= 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
+					curfragnum,*payload, *(payload+1),*(payload+2),*(payload+3),*(payload+4),*(payload+5),*(payload+6),*(payload+7)));
+
+				payload=payload+pattrib->hdrlen+pattrib->iv_len;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d pattrib->hdrlen=%d pattrib->iv_len=%d",curfragnum,pattrib->hdrlen,pattrib->iv_len));
+				if((curfragnum+1)==pattrib->nr_frags){
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-( (psecuritypriv->sw_encrypt) ? pattrib->icv_len : 0);
+					rtw_secmicappend(&micdata, payload,length);
+					payload=payload+length;
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-( (psecuritypriv->sw_encrypt) ? pattrib->icv_len : 0);
+					rtw_secmicappend(&micdata, payload, length);
+					payload=payload+length+pattrib->icv_len;
+					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d length=%d pattrib->icv_len=%d",curfragnum,length,pattrib->icv_len));
+				}
+			}
+			rtw_secgetmic(&micdata,&(mic[0]));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: before add mic code!!!\n"));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: pattrib->last_txcmdsz=%d!!!\n",pattrib->last_txcmdsz));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: mic[0]=0x%.2x ,mic[1]=0x%.2x ,mic[2]=0x%.2x ,mic[3]=0x%.2x \n\
+  mic[4]=0x%.2x ,mic[5]=0x%.2x ,mic[6]=0x%.2x ,mic[7]=0x%.2x !!!!\n",
+				mic[0],mic[1],mic[2],mic[3],mic[4],mic[5],mic[6],mic[7]));
+			//add mic code  and add the mic code length in last_txcmdsz
+
+			_rtw_memcpy(payload, &(mic[0]),8);
+			pattrib->last_txcmdsz+=8;
+			
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("\n ========last pkt========\n"));
+			payload=payload-pattrib->last_txcmdsz+8;
+			for(curfragnum=0;curfragnum<pattrib->last_txcmdsz;curfragnum=curfragnum+8)
+					RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,(" %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x ",
+					*(payload+curfragnum), *(payload+curfragnum+1), *(payload+curfragnum+2),*(payload+curfragnum+3),
+					*(payload+curfragnum+4),*(payload+curfragnum+5),*(payload+curfragnum+6),*(payload+curfragnum+7)));
+			}
+			else{
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: rtw_get_stainfo==NULL!!!\n"));
+			}
+	}
+	
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+static s32 xmitframe_swencrypt(_adapter *padapter, struct xmit_frame *pxmitframe){
+
+	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
+	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
+	
+_func_enter_;
+
+	//if((psecuritypriv->sw_encrypt)||(pattrib->bswenc))	
+	if(pattrib->bswenc)
+	{
+		//printk("start xmitframe_swencrypt\n");
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("### xmitframe_swencrypt\n"));
+		
+		switch(pattrib->encrypt){
+		case _WEP40_:
+		case _WEP104_:
+			//printk("### xmitframe_swencrypt WEP ###########\n");
+			rtw_wep_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _TKIP_:
+			rtw_tkip_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _AES_:
+			rtw_aes_encrypt(padapter, (u8 * )pxmitframe);
+			break;
+		default:
+				break;
+		}
+
+	} else {
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_notice_,("### xmitframe_hwencrypt\n"));
+	}
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+s32 rtw_make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
+{
+	u16 *qc;
+
+	struct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+
+//#ifdef CONFIG_PWRCTRL
+//	struct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);
+//#endif
+
+	sint res = _SUCCESS;
+	u16 *fctrl = &pwlanhdr->frame_ctl;
+
+_func_enter_;
+
+	_rtw_memset(hdr, 0, WLANHDR_OFFSET);
+
+	SetFrameSubType(fctrl, pattrib->subtype);
+
+	if (pattrib->subtype & WIFI_DATA_TYPE)
+	{
+		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == _TRUE)) {
+			//to_ds = 1, fr_ds = 0;
+			SetToDs(fctrl);
+			_rtw_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
+		}
+		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == _TRUE) ) {
+			//to_ds = 0, fr_ds = 1;
+			SetFrDs(fctrl);
+			_rtw_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
+		}
+		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+			_rtw_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
+		}
+#ifdef CONFIG_MP_INCLUDED
+		else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) {
+			_rtw_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
+		}
+#endif
+		else {
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));
+			res = _FAIL;
+			goto exit;
+		}
+
+/*#ifdef CONFIG_PWRCTRL
+		if (pwrpriv->cpwm >= FW_PWR1 && !(padapter->mlmepriv.sitesurveyctrl.traffic_busy))
+			SetPwrMgt(fctrl);
+#else
+		if ((get_fwstate(pmlmepriv)) & WIFI_SLEEP_STATE)
+			SetPwrMgt(fctrl);
+#endif*/
+
+		if (pattrib->encrypt)
+			SetPrivacy(fctrl);
+
+		if (pqospriv->qos_option)
+		{
+			qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
+
+			if (pattrib->priority)
+				SetPriority(qc, pattrib->priority);
+
+			SetAckpolicy(qc, pattrib->ack_policy);
+		}
+
+		//TODO: fill HT Control Field
+
+
+
+		//Update Seq Num will be handled by f/w
+		{
+			struct sta_info *psta;
+
+			sint bmcst = IS_MCAST(pattrib->ra);
+
+			if (pattrib->psta) {
+				psta = pattrib->psta;
+			} else {
+				if(bmcst) {
+					psta = rtw_get_bcmc_stainfo(padapter);
+				} else {
+					psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
+				}
+			}
+
+			if(psta)
+			{
+				psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
+				psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
+
+				pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
+
+				SetSeqNum(hdr, pattrib->seqnum);
+			}
+		}
+	}
+	else
+	{
+
+	}
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+s32 rtw_txframes_pending(_adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	return ((_rtw_queue_empty(&pxmitpriv->be_pending) == _FALSE) || 
+			 (_rtw_queue_empty(&pxmitpriv->bk_pending) == _FALSE) || 
+			 (_rtw_queue_empty(&pxmitpriv->vi_pending) == _FALSE) ||
+			 (_rtw_queue_empty(&pxmitpriv->vo_pending) == _FALSE));
+}
+
+s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib)
+{	
+	struct sta_info *psta;
+	struct tx_servq *ptxservq;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;	
+	int priority = pattrib->priority;
+
+	psta = pattrib->psta;
+	
+	switch(priority) 
+	{
+			case 1:
+			case 2:
+				ptxservq = &(psta->sta_xmitpriv.bk_q);				
+				break;
+			case 4:
+			case 5:
+				ptxservq = &(psta->sta_xmitpriv.vi_q);				
+				break;
+			case 6:
+			case 7:
+				ptxservq = &(psta->sta_xmitpriv.vo_q);							
+				break;
+			case 0:
+			case 3:
+			default:
+				ptxservq = &(psta->sta_xmitpriv.be_q);							
+			break;
+	
+	}	
+
+	return ptxservq->qcnt;	
+}
+
+/*
+
+This sub-routine will perform all the following:
+
+1. remove 802.3 header.
+2. create wlan_header, based on the info in pxmitframe
+3. append sta's iv/ext-iv
+4. append LLC
+5. move frag chunk from pframe to pxmitframe->mem
+6. apply sw-encrypt, if necessary. 
+
+*/
+s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe)
+{
+	struct pkt_file pktfile;
+
+	s32 frg_inx, frg_len, mpdu_len, llc_sz, mem_sz;
+
+	SIZE_PTR addr;
+
+	u8 *pframe, *mem_start, *ptxdesc;
+
+	struct sta_info		*psta;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+
+	u8 *pbuf_start;
+
+	s32 bmcst = IS_MCAST(pattrib->ra);
+	s32 res = _SUCCESS;
+
+_func_enter_;
+
+	if (pattrib->psta) {
+		psta = pattrib->psta;
+	} else {	
+		if(bmcst) {
+			psta = rtw_get_bcmc_stainfo(padapter);
+		} else {
+			psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
+	        }
+	}
+
+	if(psta==NULL)
+		return _FAIL;
+
+	if (pxmitframe->buf_addr == NULL)
+		return _FAIL;
+
+	pbuf_start = pxmitframe->buf_addr;
+	ptxdesc = pbuf_start;
+#if USB_TX_AGGREGATION_92C
+	mem_start = pbuf_start + TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);
+#else
+	mem_start = pbuf_start + TXDESC_OFFSET;
+#endif
+
+	if (rtw_make_wlanhdr(padapter, mem_start, pattrib) == _FAIL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+	_rtw_open_pktfile(pkt, &pktfile);
+	_rtw_pktfile_read(&pktfile, NULL, pattrib->pkt_hdrlen);
+
+	
+#ifdef CONFIG_MP_INCLUDED
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	{	
+		//truncate TXDESC_SIZE bytes txcmd if at mp mode for 871x
+		if (pattrib->ether_type == 0x8712)
+			_rtw_pktfile_read(&pktfile, NULL, TXDESC_SIZE);
+	}
+#endif
+
+	pattrib->pktlen = pktfile.pkt_len;
+
+	frg_inx = 0;
+	frg_len = pxmitpriv->frag_len - 4;//2346-4 = 2342
+
+	while (1)
+	{
+		llc_sz = 0;
+
+		mpdu_len = frg_len;
+
+		pframe = mem_start;
+
+		SetMFrag(mem_start);
+
+		pframe += pattrib->hdrlen;
+		mpdu_len -= pattrib->hdrlen;
+
+		//adding icv, if necessary...
+		if (pattrib->iv_len)
+		{
+			//if (check_fwstate(pmlmepriv, WIFI_MP_STATE))
+			//	psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			//else
+			//	psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+
+			if (psta != NULL)
+			{
+				switch(pattrib->encrypt)
+				{
+					case _WEP40_:
+					case _WEP104_:
+							WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);	
+						break;
+					case _TKIP_:			
+						if(bmcst)
+							TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+						else
+							TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
+						break;			
+					case _AES_:
+						if(bmcst)
+							AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+						else
+							AES_IV(pattrib->iv, psta->dot11txpn, 0);
+						break;
+				}
+			}
+
+			_rtw_memcpy(pframe, pattrib->iv, pattrib->iv_len);
+			//printk("%s pattrib->encrypt(%d) pattrib->iv_len(%d)\n",__FUNCTION__,pattrib->encrypt,pattrib->iv_len);
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,
+				 ("rtw_xmitframe_coalesce: keyid=%d pattrib->iv[3]=%.2x pframe=%.2x %.2x %.2x %.2x\n",
+				  padapter->securitypriv.dot11PrivacyKeyIndex, pattrib->iv[3], *pframe, *(pframe+1), *(pframe+2), *(pframe+3)));
+
+			pframe += pattrib->iv_len;
+
+			mpdu_len -= pattrib->iv_len;
+		}
+
+		if (frg_inx == 0) {
+			llc_sz = rtw_put_snap(pframe, pattrib->ether_type);
+			pframe += llc_sz;
+			mpdu_len -= llc_sz;
+		}
+
+		if ((pattrib->icv_len >0) && (pattrib->bswenc)) {
+			mpdu_len -= pattrib->icv_len;
+		}
+
+
+		if (bmcst) {
+			// don't do fragment to broadcat/multicast packets
+			mem_sz = _rtw_pktfile_read(&pktfile, pframe, pattrib->pktlen);
+		} else {
+			mem_sz = _rtw_pktfile_read(&pktfile, pframe, mpdu_len);
+		}
+
+		pframe += mem_sz;
+
+		if ((pattrib->icv_len >0 )&& (pattrib->bswenc)) {
+			_rtw_memcpy(pframe, pattrib->icv, pattrib->icv_len); 
+			pframe += pattrib->icv_len;
+		}
+
+		frg_inx++;
+
+		if (bmcst || (rtw_endofpktfile(&pktfile) == _TRUE))
+		{
+			pattrib->nr_frags = frg_inx;
+
+			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags==1)? llc_sz:0) + 
+					((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;
+			
+			ClearMFrag(mem_start);
+			
+#ifdef CONFIG_SDIO_HCI
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("coalesce: pattrib->last_txcmdsz=%d pxmitframe->pxmitbuf->phead=0x%p  pxmitframe->pxmitbuf->ptail=0x%p pxmitframe->pxmitbuf->len=%d\n", pattrib->last_txcmdsz, pxmitframe->pxmitbuf->phead, pxmitframe->pxmitbuf->ptail, pxmitframe->pxmitbuf->len));
+			pxmitframe->pxmitbuf->ptail = pxmitframe->buf_addr + _RND512(pframe-pxmitframe->buf_addr);
+			pxmitframe->pxmitbuf->len += pxmitframe->pxmitbuf->ptail - pxmitframe->buf_addr;//(pframe-mem_start);
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("coalesce: [2] pattrib->last_txcmdsz=%d pxmitframe->pxmitbuf->ptail=0x%p pxmitframe->pxmitbuf->len=%d\n", pattrib->last_txcmdsz, pxmitframe->pxmitbuf->ptail, pxmitframe->pxmitbuf->len));
+#endif
+
+			break;
+
+		} else {
+		
+#ifdef CONFIG_SDIO_HCI
+			pxmitframe->pxmitbuf->ptail = pxmitframe->buf_addr + _RND512(pframe-pxmitframe->buf_addr);
+			pxmitframe->pxmitbuf->len += pxmitframe->pxmitbuf->ptail - pxmitframe->buf_addr;
+                    pframe=pxmitframe->pxmitbuf->ptail;
+#endif
+		}
+
+		addr = (SIZE_PTR)(pframe);
+		
+		mem_start = (unsigned char *)RND4(addr) + TXDESC_OFFSET;
+		_rtw_memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);		
+	}
+
+	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic(padapter, pxmitframe)==_FAIL\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+#ifdef CONFIG_SDIO_HCI
+	fillin_txdesc(padapter, pxmitframe);
+#endif
+
+	xmitframe_swencrypt(padapter, pxmitframe);
+	
+	if(!bmcst)
+		update_attrib_vcs_info(padapter, pxmitframe);
+	
+exit:	
+	
+_func_exit_;	
+
+	return res;
+}
+
+/* Logical Link Control(LLC) SubNetwork Attachment Point(SNAP) header
+ * IEEE LLC/SNAP header contains 8 octets
+ * First 3 octets comprise the LLC portion
+ * SNAP portion, 5 octets, is divided into two fields:
+ *	Organizationally Unique Identifier(OUI), 3 octets,
+ *	type, defined by that organization, 2 octets.
+ */
+s32 rtw_put_snap(u8 *data, u16 h_proto)
+{
+	struct ieee80211_snap_hdr *snap;
+	u8 *oui;
+
+_func_enter_;
+
+	snap = (struct ieee80211_snap_hdr *)data;
+	snap->dsap = 0xaa;
+	snap->ssap = 0xaa;
+	snap->ctrl = 0x03;
+
+	if (h_proto == 0x8137 || h_proto == 0x80f3)
+		oui = P802_1H_OUI;
+	else
+		oui = RFC1042_OUI;
+	
+	snap->oui[0] = oui[0];
+	snap->oui[1] = oui[1];
+	snap->oui[2] = oui[2];
+
+	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+
+_func_exit_;
+
+	return SNAP_SIZE + sizeof(u16);
+}
+
+void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len)
+{
+
+	uint	protection;
+	u8	*perp;
+	sint	 erp_len;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct	registry_priv *pregistrypriv = &padapter->registrypriv;
+	
+_func_enter_;
+	
+	switch(pxmitpriv->vcs_setting)
+	{
+		case DISABLE_VCS:
+			pxmitpriv->vcs = NONE_VCS;
+			break;
+	
+		case ENABLE_VCS:
+			break;
+	
+		case AUTO_VCS:
+		default:
+			perp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
+			if(perp == NULL)
+			{
+				pxmitpriv->vcs = NONE_VCS;
+			}
+			else
+			{
+				protection = (*(perp + 2)) & BIT(1);
+				if (protection)
+				{
+					if(pregistrypriv->vcs_type == RTS_CTS)
+						pxmitpriv->vcs = RTS_CTS;
+					else
+						pxmitpriv->vcs = CTS_TO_SELF;
+				}
+				else
+					pxmitpriv->vcs = NONE_VCS;
+			}
+
+			break;			
+	
+	}
+
+_func_exit_;
+
+}
+
+struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	_irqL irqL;
+	struct xmit_buf *pxmitbuf =  NULL;
+	_list *plist, *phead;
+	_queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+_func_enter_;
+
+	//printk("+rtw_alloc_xmitbuf\n");
+
+	_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
+
+	if(_rtw_queue_empty(pfree_xmitbuf_queue) == _TRUE) {
+		pxmitbuf = NULL;
+	} else {
+
+		phead = get_list_head(pfree_xmitbuf_queue);
+
+		plist = get_next(phead);
+
+		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
+
+		list_delete(&(pxmitbuf->list));
+	}
+
+	if (pxmitbuf !=  NULL)
+	{
+		pxmitpriv->free_xmitbuf_cnt--;
+
+		//printk("alloc, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt);
+
+		pxmitbuf->priv_data = NULL;
+#ifdef CONFIG_SDIO_HCI
+		pxmitbuf->len = 0;
+		pxmitbuf->phead = pxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->pbuf;
+		pxmitbuf->pend = pxmitbuf->pbuf + MAX_XMITBUF_SZ;
+#endif
+	}
+
+	_exit_critical(&pfree_xmitbuf_queue->lock, &irqL);
+
+_func_exit_;
+
+	return pxmitbuf;
+}
+
+s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	_irqL irqL;
+	_queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;		
+	
+_func_enter_;	
+
+	//printk("+rtw_free_xmitbuf\n");
+
+	if(pxmitbuf==NULL)
+	{		
+		return _FAIL;
+	}
+	
+	_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
+	
+	list_delete(&pxmitbuf->list);	
+	
+	rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
+
+	pxmitpriv->free_xmitbuf_cnt++;
+	//printk("FREE, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt);
+		
+	_exit_critical(&pfree_xmitbuf_queue->lock, &irqL);	
+
+_func_exit_;	 
+
+	return _SUCCESS;	
+} 
+
+/*
+Calling context:
+1. OS_TXENTRY
+2. RXENTRY (rx_thread or RX_ISR/RX_CallBack)
+
+If we turn on USE_RXTHREAD, then, no need for critical section.
+Otherwise, we must use _enter/_exit critical to protect free_xmit_queue...
+
+Must be very very cautious...
+
+*/
+
+struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv)//(_queue *pfree_xmit_queue)
+{
+	/*
+		Please remember to use all the osdep_service api,
+		and lock/unlock or _enter/_exit critical to protect 
+		pfree_xmit_queue
+	*/
+
+	_irqL irqL;
+	struct xmit_frame *pxframe = NULL;
+	_list *plist, *phead;
+	_queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+	_adapter *padapter = pxmitpriv->adapter;
+
+_func_enter_;
+
+	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+	if (_rtw_queue_empty(pfree_xmit_queue) == _TRUE) {
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
+		pxframe =  NULL;
+	} else {
+		phead = get_list_head(pfree_xmit_queue);
+
+		plist = get_next(phead);
+
+		pxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+
+		list_delete(&(pxframe->list));
+	}
+
+	if (pxframe !=  NULL)
+	{
+		pxmitpriv->free_xmitframe_cnt--;
+
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
+
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+
+		pxframe->attrib.psta = NULL;
+
+		pxframe->frame_tag = DATA_FRAMETAG;
+
+#ifdef CONFIG_USB_HCI
+		pxframe->pkt = NULL;
+#endif //#ifdef CONFIG_USB_HCI
+
+#if USB_TX_AGGREGATION_92C
+		pxframe->agg_num = 0;
+		pxframe->pkt_offset = 1;
+#endif
+
+#ifdef PLATFORM_LINUX
+		if(pxmitpriv->free_xmitframe_cnt==1)
+		{
+			if (!netif_queue_stopped(padapter->pnetdev))
+		       	netif_stop_queue(padapter->pnetdev);		
+		}
+#endif
+
+	}
+
+	_exit_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+_func_exit_;
+
+	return pxframe;
+}
+
+s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
+{	
+	_irqL irqL;
+	_queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;		
+	_adapter *padapter = pxmitpriv->adapter;
+	_pkt *pndis_pkt = NULL;
+
+_func_enter_;	
+
+	if (pxmitframe == NULL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("======rtw_free_xmitframe():pxmitframe==NULL!!!!!!!!!!\n"));
+		goto exit;
+	}
+
+	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+	list_delete(&pxmitframe->list);	
+
+	if (pxmitframe->pkt){
+		pndis_pkt = pxmitframe->pkt;
+		pxmitframe->pkt = NULL;
+	}
+
+	rtw_list_insert_tail(&pxmitframe->list, get_list_head(pfree_xmit_queue));
+
+	pxmitpriv->free_xmitframe_cnt++;
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
+
+	_exit_critical_bh(&pfree_xmit_queue->lock, &irqL);
+
+
+	if(pndis_pkt)		
+		os_pkt_complete(padapter, pndis_pkt);
+
+exit:
+
+_func_exit_;
+
+	return _SUCCESS;
+}
+
+s32 rtw_free_xmitframe_ex(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
+{	
+			
+_func_enter_;	
+
+	if(pxmitframe==NULL){
+		goto exit;
+	}
+
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe_ex()\n"));
+	
+	rtw_free_xmitframe(pxmitpriv, pxmitframe);	  
+
+exit:
+	
+_func_exit_;	 
+
+	return _SUCCESS;	
+} 
+
+void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue)
+{
+	_irqL irqL;
+	_list	*plist, *phead;
+	struct	xmit_frame 	*pxmitframe;
+
+_func_enter_;	
+
+	_enter_critical_bh(&(pframequeue->lock), &irqL);
+
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+	
+	while (rtw_end_of_queue_search(phead, plist) == _FALSE)
+	{
+			
+		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+
+		plist = get_next(plist); 
+		
+		rtw_free_xmitframe(pxmitpriv,pxmitframe);
+			
+	}
+	_exit_critical_bh(&(pframequeue->lock), &irqL);
+
+_func_exit_;
+}
+
+s32 xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	if (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL)
+	{
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+			 ("xmitframe_enqueue: drop xmit pkt for classifier fail\n"));
+//		pxmitframe->pkt = NULL;
+		return _FAIL;
+	}
+
+	return _SUCCESS;
+}
+
+static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, _queue *pframe_queue)
+{
+	_list	*xmitframe_plist, *xmitframe_phead;
+	struct	xmit_frame	*pxmitframe=NULL;
+	_adapter *padapter = pxmitpriv->adapter;
+
+	xmitframe_phead = get_list_head(pframe_queue);
+	xmitframe_plist = get_next(xmitframe_phead);
+
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+	{
+		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = get_next(xmitframe_plist);
+
+/*
+#ifdef RTK_DMP_PLATFORM
+#if USB_TX_AGGREGATION_92C
+		if((ptxservq->qcnt>0) && (ptxservq->qcnt<=2))
+		{
+			pxmitframe = NULL;
+
+			tasklet_schedule(&pxmitpriv->xmit_tasklet);
+
+			break;
+		}
+#endif
+#endif
+*/
+		list_delete(&pxmitframe->list);
+
+#ifdef CONFIG_AP_MODE
+		if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe)==_FALSE)
+#endif
+		{
+			//rtw_list_insert_tail(&pxmitframe->list, &phwxmit->pending);
+
+			ptxservq->qcnt--;
+			phwxmit->txcmdcnt++;
+
+			break;
+		}
+
+	}
+
+	return pxmitframe;
+}
+
+struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, u8 flags)
+{
+	_irqL irqL0;
+	_list *sta_plist, *sta_phead;
+	struct hw_xmit *phwxmit;
+	struct tx_servq *ptxservq = NULL;
+	_queue *pframe_queue = NULL;
+	struct xmit_frame *pxmitframe = NULL;
+	_adapter *padapter = pxmitpriv->adapter;
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;	
+	struct hw_xmit *phwxmit_i = pxmitpriv->hwxmits;
+	sint entry = pxmitpriv->hwxmit_entry;
+	u8 inx[XMIT_QUEUE_ENTRY];
+	int i;
+	
+#ifdef CONFIG_USB_HCI
+	int j, tmp, acirp_cnt[4];
+#endif
+
+_func_enter_;
+
+	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
+
+	if(pregpriv->wifi_spec==1)
+	{
+#if 0
+		if(flags<XMIT_QUEUE_ENTRY)
+		{
+			//priority exchange according to the completed xmitbuf flags.
+			inx[flags] = 0;
+			inx[0] = flags;
+		}
+#endif	
+	
+#ifdef CONFIG_USB_HCI
+		//entry indx: 0->vo, 1->vi, 2->be, 3->bk.
+		acirp_cnt[0] = pxmitpriv->voq_cnt;
+		acirp_cnt[1] = pxmitpriv->viq_cnt;
+		acirp_cnt[2] = pxmitpriv->beq_cnt;
+		acirp_cnt[3] = pxmitpriv->bkq_cnt;
+
+		for(i=0; i<4; i++)
+		{
+			for(j=i+1; j<4; j++)
+			{
+				if(acirp_cnt[j]<acirp_cnt[i])
+				{
+					tmp = acirp_cnt[i];
+					acirp_cnt[i] = acirp_cnt[j];
+					acirp_cnt[j] = tmp;
+
+					tmp = inx[i];
+					inx[i] = inx[j];
+					inx[j] = tmp;
+				}
+			}
+		}
+#endif
+
+	}
+
+
+	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+
+	for(i = 0; i < entry; i++) 
+	{
+		phwxmit = phwxmit_i + inx[i];
+
+		//_enter_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+		sta_phead = get_list_head(phwxmit->sta_queue);
+		sta_plist = get_next(sta_phead);
+
+		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == _FALSE)
+		{
+
+			ptxservq= LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
+
+			pframe_queue = &ptxservq->sta_pending;
+
+			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
+
+			if(pxmitframe)
+			{
+				phwxmit->accnt--;
+
+				//Remove sta node when there is no pending packets.
+				if(_rtw_queue_empty(pframe_queue)) //must be done after get_next and before break
+					list_delete(&ptxservq->tx_pending);
+
+				//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+				goto exit;
+			}
+
+			sta_plist = get_next(sta_plist);
+
+		}
+
+		//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
+
+	}
+
+exit:
+
+	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+
+_func_exit_;
+
+	return pxmitframe;
+}
+
+__inline static struct tx_servq *get_sta_pending
+	(_adapter *padapter, _queue **ppstapending, struct sta_info *psta, sint up)
+{
+	struct tx_servq *ptxservq;
+	struct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;
+	
+_func_enter_;	
+
+#ifdef CONFIG_RTL8711
+
+	if(IS_MCAST(psta->hwaddr))
+	{
+		ptxservq = &(psta->sta_xmitpriv.be_q); // we will use be_q to queue bc/mc frames in BCMC_stainfo
+		*ppstapending = &padapter->xmitpriv.bm_pending; 
+	}
+	else
+#endif		
+	{
+		switch (up) 
+		{
+			case 1:
+			case 2:
+				ptxservq = &(psta->sta_xmitpriv.bk_q);
+				*ppstapending = &padapter->xmitpriv.bk_pending;
+				(phwxmits+3)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : BK \n"));
+				break;
+
+			case 4:
+			case 5:
+				ptxservq = &(psta->sta_xmitpriv.vi_q);
+				*ppstapending = &padapter->xmitpriv.vi_pending;
+				(phwxmits+1)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : VI\n"));
+				break;
+
+			case 6:
+			case 7:
+				ptxservq = &(psta->sta_xmitpriv.vo_q);
+				*ppstapending = &padapter->xmitpriv.vo_pending;
+				(phwxmits+0)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : VO \n"));			
+				break;
+
+			case 0:
+			case 3:
+			default:
+				ptxservq = &(psta->sta_xmitpriv.be_q);
+				*ppstapending = &padapter->xmitpriv.be_pending;
+				(phwxmits+2)->accnt++;
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("get_sta_pending : BE \n"));				
+			break;
+			
+		}
+
+	}
+
+_func_exit_;
+
+	return ptxservq;			
+}
+
+/*
+ * Will enqueue pxmitframe to the proper queue,
+ * and indicate it to xx_pending list.....
+*/
+s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	//_irqL irqL0;
+	_queue *pstapending;
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	sint bmcst = IS_MCAST(pattrib->ra);
+	sint res = _SUCCESS;
+
+_func_enter_;
+
+	if (pattrib->psta) {
+		psta = pattrib->psta;		
+	} else {
+		if (bmcst) {
+			psta = rtw_get_bcmc_stainfo(padapter);
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_xmit_classifier: rtw_get_bcmc_stainfo\n"));
+		} else {
+#ifdef CONFIG_MP_INCLUDED
+			if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+				psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			else
+#endif
+				psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+		}
+	}
+
+	if (psta == NULL) {
+		res = _FAIL;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("rtw_xmit_classifier: psta == NULL\n"));
+		goto exit;
+	}
+
+	ptxservq = get_sta_pending(padapter, &pstapending, psta, pattrib->priority);
+
+	//_enter_critical(&pstapending->lock, &irqL0);
+
+	if (rtw_is_list_empty(&ptxservq->tx_pending)) {
+		rtw_list_insert_tail(&ptxservq->tx_pending, get_list_head(pstapending));
+	}
+
+	//_enter_critical(&ptxservq->sta_pending.lock, &irqL1);
+
+	rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));
+	ptxservq->qcnt++;
+
+	//_exit_critical(&ptxservq->sta_pending.lock, &irqL1);
+
+	//_exit_critical(&pstapending->lock, &irqL0);
+
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
+void rtw_alloc_hwxmits(_adapter *padapter)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	pxmitpriv->hwxmit_entry = XMIT_QUEUE_ENTRY;
+
+	pxmitpriv->hwxmits = (struct hw_xmit *)_rtw_zmalloc(sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry);	
+	
+	hwxmits = pxmitpriv->hwxmits;
+
+	if(pxmitpriv->hwxmit_entry == 5)
+	{
+		pxmitpriv->bmc_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
+	
+		pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
+
+       	pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
+	
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+
+      		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
+		
+	}	
+	else if(pxmitpriv->hwxmit_entry == 4)
+	{
+
+       	pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
+
+       	pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vi_pending;
+
+		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
+	
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+	}
+	else
+	{
+		
+
+	}
+	
+
+}
+
+void rtw_free_hwxmits(_adapter *padapter)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	hwxmits = pxmitpriv->hwxmits;
+	if(hwxmits)
+	_rtw_mfree((u8 *)hwxmits, (sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry));
+}
+
+void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry)
+{
+	sint i;
+_func_enter_;	
+	for(i = 0; i < entry; i++, phwxmit++)
+	{
+		_rtw_spinlock_init(&phwxmit->xmit_lock);
+		_rtw_init_listhead(&phwxmit->pending);		
+		phwxmit->txcmdcnt = 0;
+		phwxmit->accnt = 0;
+	}
+_func_exit_;	
+}
+
+/*
+ * The main transmit(tx) entry
+ *
+ * Return
+ *	1	enqueue
+ *	0	success, hardware will handle this xmit frame(packet)
+ *	<0	fail
+ */
+s32 rtw_xmit(_adapter *padapter, _pkt *pkt)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct xmit_frame *pxmitframe = NULL;
+
+	s32 res;
+
+
+	pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
+	if (pxmitframe == NULL) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: no more pxmitframe\n"));
+		return -1;
+	}
+
+	res = update_attrib(padapter, pkt, &pxmitframe->attrib);
+	if (res == _FAIL) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: update attrib fail\n"));
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+		return -1;
+	}
+	pxmitframe->pkt = pkt;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_TX);
+
+	if (hal_xmit(padapter, pxmitframe) == _FALSE)
+		return 1;
+
+	return 0;
+}
+
+#ifdef CONFIG_AP_MODE
+
+sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	_irqL irqL;
+	sint ret=_FALSE;
+	struct sta_info *psta=NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if(pattrib->psta)
+	{
+		psta = pattrib->psta;
+	}
+	else
+	{
+		psta=rtw_get_stainfo(pstapriv, pattrib->ra);
+	}
+
+	if(psta==NULL)
+		return ret;
+
+	if(bmcst)
+	{
+#if 0	
+		if(pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode, then enqueue.
+		{
+			_enter_critical(&psta->sleep_q.lock, &irqL);	
+			
+			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+			
+			psta->sleepq_len++;
+			
+			//todo: mark tim bitmap, then issue this bc/mc frame after BCN on DTIM count=0;
+			
+			_exit_critical(&psta->sleep_q.lock, &irqL);
+
+			ret = _TRUE;
+		}
+#endif
+		return ret;
+	}
+	
+
+	if(psta->state&WIFI_SLEEP_STATE)
+	{
+		if(pstapriv->sta_dz_bitmap&BIT(psta->aid-1))	
+		{			
+			_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+			
+			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+			
+			psta->sleepq_len++;
+
+			pstapriv->tim_bitmap |= BIT(psta->aid-1);
+			
+			_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
+
+			ret = _TRUE;
+		}
+	}
+
+	return ret;
+	
+}
+
+void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
+{	 
+	_irqL irqL;	 
+	_list	*xmitframe_plist, *xmitframe_phead;
+	struct xmit_frame *pxmitframe=NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+
+	xmitframe_phead = get_list_head(&psta->sleep_q);
+	xmitframe_plist = get_next(xmitframe_phead);
+
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+	{			
+		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = get_next(xmitframe_plist);
+
+		list_delete(&pxmitframe->list);
+
+		if(hal_xmit(padapter, pxmitframe) == _TRUE)
+		{		
+			rtw_os_xmit_complete(padapter, pxmitframe);
+		}		
+	}
+
+	pstapriv->tim_bitmap &= ~BIT(psta->aid-1);
+
+	_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
+	
+}
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/hal_init.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/hal_init.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/hal_init.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/hal_init.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#define _HAL_INIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_byteorder.h>
+
+#include <hal_init.h>
+
+#ifdef CONFIG_SDIO_HCI
+	#include <sdio_hal.h>
+#ifdef PLATFORM_LINUX
+	#include <linux/mmc/sdio_func.h>
+#endif
+#elif defined(CONFIG_USB_HCI)
+	#include <usb_hal.h>
+#endif	
+
+
+uint	 rtw_hal_init(_adapter *padapter) 
+{
+	uint	status = _SUCCESS;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	
+	padapter->hw_init_completed=_FALSE;	
+	
+	status = pHalData->hal_ops.hal_init(padapter);
+
+	if(status == _SUCCESS){
+		padapter->hw_init_completed = _TRUE;
+	}
+	else{
+	 	padapter->hw_init_completed = _FALSE;
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail\n"));
+	}
+
+	RT_TRACE(_module_hal_init_c_,_drv_err_,("-rtl871x_hal_init:status=0x%x\n",status));
+
+	return status;
+
+}	
+
+uint	 rtw_hal_deinit(_adapter *padapter)
+{
+	uint	status = _SUCCESS;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	
+_func_enter_;
+
+	status = pHalData->hal_ops.hal_deinit(padapter);
+
+	if(status == _SUCCESS){
+		padapter->hw_init_completed = _FALSE;
+	}
+	else
+	{
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("\n rtw_hal_deinit: hal_init fail\n"));
+	}
+	
+_func_exit_;
+	
+	return status;
+	
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,3437 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// Description:
+//
+// This file is for 92CE/92CU dynamic mechanism only
+//
+//
+//============================================================
+
+//============================================================
+// include files
+//============================================================
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_byteorder.h>
+
+#include <hal_init.h>
+//#include <linux/math64.h>
+
+#include "Hal8192CPhyReg.h"
+#include "Hal8192CPhyCfg.h"
+#include "rtl8192c_dm.h"
+
+//============================================================
+// Global var
+//============================================================
+/*
+static u32 edca_setting_DL[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MARVELL		92U_AP		SELF_AP
+{ 0xa44f, 		0x5ea44f, 	0x5e4322, 		0x5ea42b, 		0xa44f, 		0xa630, 		0xa630,		0xa44f,		0x5e4322,	0x5ea42b};
+
+static u32 edca_setting_DL_GMode[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MARVELL		92U_AP		SELF_AP
+{ 0x4322, 		0xa44f, 		0x5e4322,		0xa42b, 			0x5e4322, 	0x4322, 		0xa430,		0xa44f,		0x5e4322,	0x5ea42b};
+
+static u32 edca_setting_UL[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MARVELL		92U_AP		SELF_AP
+{ 0x5e4322, 		0xa44f, 		0x5e4322,		0x5ea32b,  		0x5ea422, 	0x5ea322,	0x5e4322,	0x5ea44f,	0x5e4322,	0x5e4322};
+*/
+
+#define	OFDM_TABLE_SIZE 	37
+#define	CCK_TABLE_SIZE		33
+
+static u32 OFDMSwingTable[OFDM_TABLE_SIZE] = {
+	0x7f8001fe, // 0, +6.0dB
+	0x788001e2, // 1, +5.5dB
+	0x71c001c7, // 2, +5.0dB
+	0x6b8001ae, // 3, +4.5dB
+	0x65400195, // 4, +4.0dB
+	0x5fc0017f, // 5, +3.5dB
+	0x5a400169, // 6, +3.0dB
+	0x55400155, // 7, +2.5dB
+	0x50800142, // 8, +2.0dB
+	0x4c000130, // 9, +1.5dB
+	0x47c0011f, // 10, +1.0dB
+	0x43c0010f, // 11, +0.5dB
+	0x40000100, // 12, +0dB
+	0x3c8000f2, // 13, -0.5dB
+	0x390000e4, // 14, -1.0dB
+	0x35c000d7, // 15, -1.5dB
+	0x32c000cb, // 16, -2.0dB
+	0x300000c0, // 17, -2.5dB
+	0x2d4000b5, // 18, -3.0dB
+	0x2ac000ab, // 19, -3.5dB
+	0x288000a2, // 20, -4.0dB
+	0x26000098, // 21, -4.5dB
+	0x24000090, // 22, -5.0dB
+	0x22000088, // 23, -5.5dB
+	0x20000080, // 24, -6.0dB
+	0x1e400079, // 25, -6.5dB
+	0x1c800072, // 26, -7.0dB
+	0x1b00006c, // 27. -7.5dB
+	0x19800066, // 28, -8.0dB
+	0x18000060, // 29, -8.5dB
+	0x16c0005b, // 30, -9.0dB
+	0x15800056, // 31, -9.5dB
+	0x14400051, // 32, -10.0dB
+	0x1300004c, // 33, -10.5dB
+	0x12000048, // 34, -11.0dB
+	0x11000044, // 35, -11.5dB
+	0x10000040, // 36, -12.0dB
+};
+
+static u8 CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
+{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	// 0, +0dB
+{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 1, -0.5dB
+{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 2, -1.0dB
+{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 3, -1.5dB
+{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB 
+{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 5, -2.5dB
+{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 6, -3.0dB
+{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 7, -3.5dB
+{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB 
+{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 9, -4.5dB
+{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB 
+{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 11, -5.5dB
+{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB 
+{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 13, -6.5dB
+{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB 
+{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 15, -7.5dB
+{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 17, -8.5dB
+{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB 
+{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 19, -9.5dB
+{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 20, -10.0dB
+{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 21, -10.5dB
+{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 22, -11.0dB
+{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	// 23, -11.5dB
+{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	// 24, -12.0dB
+{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	// 25, -12.5dB
+{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	// 26, -13.0dB
+{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	// 27, -13.5dB
+{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	// 28, -14.0dB
+{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	// 29, -14.5dB
+{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	// 30, -15.0dB
+{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	// 31, -15.5dB
+{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}	// 32, -16.0dB
+};
+
+static u8 CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8]= {
+{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB	
+{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB 
+{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB  
+{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 3, -1.5dB
+{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB  
+{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 5, -2.5dB
+{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB  
+{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB  
+{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB  
+{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 9, -4.5dB
+{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB  
+{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 11, -5.5dB
+{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB  
+{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB 
+{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB  
+{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 15, -7.5dB
+{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 17, -8.5dB
+{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB  
+{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 19, -9.5dB
+{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 20, -10.0dB
+{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 21, -10.5dB
+{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 22, -11.0dB
+{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 23, -11.5dB
+{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 24, -12.0dB
+{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	// 25, -12.5dB
+{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 26, -13.0dB
+{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 27, -13.5dB
+{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 28, -14.0dB
+{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 29, -14.5dB
+{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 30, -15.0dB
+{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 31, -15.5dB
+{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	// 32, -16.0dB
+};	
+
+/*-----------------------------------------------------------------------------
+ * Function:	dm_DIGInit()
+ *
+ * Overview:	Set DIG scheme init value.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *
+ *---------------------------------------------------------------------------*/
+void	dm_DIGInit(
+	IN	PADAPTER	pAdapter
+)
+{	
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	
+
+	pDigTable->Dig_Enable_Flag = _TRUE;
+	pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;
+	
+	pDigTable->CurIGValue = 0x20;
+	pDigTable->PreIGValue = 0x0;
+
+	pDigTable->CurSTAConnectState = pDigTable->PreSTAConnectState = DIG_STA_DISCONNECT;
+	pDigTable->CurMultiSTAConnectState = DIG_MultiSTA_DISCONNECT;
+
+	pDigTable->RssiLowThresh 	= DM_DIG_THRESH_LOW;
+	pDigTable->RssiHighThresh 	= DM_DIG_THRESH_HIGH;
+
+	pDigTable->FALowThresh	= DM_FALSEALARM_THRESH_LOW;
+	pDigTable->FAHighThresh	= DM_FALSEALARM_THRESH_HIGH;
+
+	
+	pDigTable->rx_gain_range_max = DM_DIG_MAX;
+	pDigTable->rx_gain_range_min = DM_DIG_MIN;
+
+	pDigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
+	pDigTable->BackoffVal_range_max = DM_DIG_BACKOFF_MAX;
+	pDigTable->BackoffVal_range_min = DM_DIG_BACKOFF_MIN;
+
+	pDigTable->PreCCKPDState = CCK_PD_STAGE_MAX;
+	pDigTable->CurCCKPDState = CCK_PD_STAGE_LowRssi;
+	
+	pDigTable->ForbiddenIGI = DM_DIG_MIN;
+	pDigTable->LargeFAHit = 0;
+	pDigTable->Recover_cnt = 0;
+	
+}
+
+
+u8 dm_initial_gain_MinPWDB(
+	IN	PADAPTER	pAdapter
+	)
+{
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	
+	int	Rssi_val_min = 0;
+	
+	if((pDigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT) &&
+		(pDigTable->CurSTAConnectState == DIG_STA_CONNECT) )
+	{
+		if(pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
+			Rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
+					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;		
+		else
+			Rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
+	}
+	else if(pDigTable->CurSTAConnectState == DIG_STA_CONNECT || 
+			pDigTable->CurSTAConnectState == DIG_STA_BEFORE_CONNECT) 
+		Rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
+	else if(pDigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT)
+		Rssi_val_min = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+/*
+	if(pMgntInfo->BtInfo.BtOperationOn)
+	{
+		if(pHalData->BT_EntryMinUndecoratedSmoothedPWDB)
+		{
+			//To avoid select wrong rssi with in IBSS mode, it'll cause the BT TP degression to half.
+			//if( (!Rssi_val_min) ||
+				//(pHalData->BT_EntryMinUndecoratedSmoothedPWDB < Rssi_val_min) )
+			{
+				Rssi_val_min = pHalData->BT_EntryMinUndecoratedSmoothedPWDB;
+				RTPRINT(FDM, DM_BT30, ("BT min rssi STA mode, rssi = %ld\n", Rssi_val_min));
+			}
+		}
+	}
+*/
+	return (u8)Rssi_val_min;
+}
+
+
+VOID 
+dm_FalseAlarmCounterStatistics(
+	IN	PADAPTER	Adapter
+	)
+{
+	u32 ret_value;
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;	
+	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pdmpriv->FalseAlmCnt);
+	
+	ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter1, bMaskDWord);
+       FalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);	
+
+       ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter2, bMaskDWord);
+	FalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);
+	FalseAlmCnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);
+	ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter3, bMaskDWord);
+	FalseAlmCnt->Cnt_Mcs_fail = (ret_value&0xffff);	
+	ret_value = PHY_QueryBBReg(Adapter, rOFDM0_FrameSync, bMaskDWord);
+	FalseAlmCnt->Cnt_Fast_Fsync = (ret_value&0xffff);
+	FalseAlmCnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);
+
+	FalseAlmCnt->Cnt_Ofdm_fail = 	FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal +
+								FalseAlmCnt->Cnt_Crc8_fail + FalseAlmCnt->Cnt_Mcs_fail+
+								FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail;
+	
+	//hold cck counter
+	PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, BIT(14), 1);
+	
+	ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterLower, bMaskByte0);
+	FalseAlmCnt->Cnt_Cck_fail = ret_value;
+
+	ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterUpper, bMaskByte3);
+	FalseAlmCnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
+	
+	FalseAlmCnt->Cnt_all = (	FalseAlmCnt->Cnt_Parity_Fail +
+						FalseAlmCnt->Cnt_Rate_Illegal +
+						FalseAlmCnt->Cnt_Crc8_fail +
+						FalseAlmCnt->Cnt_Mcs_fail +
+						FalseAlmCnt->Cnt_Cck_fail);	
+	
+	//reset false alarm counter registers
+	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 1);
+	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 0);
+	//reset cck counter
+	PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 0);
+	//enable cck counter
+	PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 2);
+
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Parity_Fail = %ld, Cnt_Rate_Illegal = %ld, Cnt_Crc8_fail = %ld, Cnt_Mcs_fail = %ld\n", 
+	//			FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal, FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail) );	
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Ofdm_fail = %ld, Cnt_Cck_fail = %ld, Cnt_all = %ld\n", 
+	//			FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_all) );		
+}
+
+
+VOID
+DM_Write_DIG(
+	IN	PADAPTER	pAdapter
+	)
+{
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CurIGValue = 0x%lx, PreIGValue = 0x%lx, BackoffVal = %d\n", 
+	//			DM_DigTable.CurIGValue, DM_DigTable.PreIGValue, DM_DigTable.BackoffVal));
+
+	if( pDigTable->Dig_Enable_Flag == _FALSE)
+	{
+		//RT_TRACE(	COMP_DIG, DBG_LOUD, ("DIG is disabled\n"));
+		pDigTable->PreIGValue = 0x17;
+		return;
+	}
+	
+	if(pDigTable->PreIGValue != pDigTable->CurIGValue)
+	{
+		// Set initial gain.
+		//PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, bMaskByte0, pDigTable->CurIGValue);
+		//PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, bMaskByte0, pDigTable->CurIGValue);	
+		PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, pDigTable->CurIGValue);
+		PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, pDigTable->CurIGValue);
+		
+		pDigTable->PreIGValue = pDigTable->CurIGValue;
+	}
+}
+
+
+VOID 
+dm_CtrlInitGainByFA(
+	IN	PADAPTER	pAdapter
+)	
+{
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pdmpriv->FalseAlmCnt);
+
+	u8	value_IGI = pDigTable->CurIGValue;
+	
+	if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH0)	
+		value_IGI --;
+	else if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH1)	
+		value_IGI += 0;
+	else if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH2)	
+		value_IGI ++;
+	else if(FalseAlmCnt->Cnt_all >= DM_DIG_FA_TH2)	
+		value_IGI +=2;
+	
+	if(value_IGI > DM_DIG_FA_UPPER)			
+		value_IGI = DM_DIG_FA_UPPER;
+	else if(value_IGI < DM_DIG_FA_LOWER)		
+		value_IGI = DM_DIG_FA_LOWER;
+
+	if(FalseAlmCnt->Cnt_all > 10000)
+		value_IGI = 0x32;
+	
+	pDigTable->CurIGValue = value_IGI;
+	
+	DM_Write_DIG(pAdapter);
+	
+}
+
+
+VOID 
+dm_CtrlInitGainByRssi(
+	IN	PADAPTER	pAdapter
+)	
+{
+
+	u32 isBT;
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pdmpriv->FalseAlmCnt);
+	
+#if 0
+	//Test Program
+	u1Byte	value_IGI = DM_DigTable.CurIGValue;
+	DM_DigTable.Rssi_val_min = 0x20;
+	RT_TRACE(COMP_DIG, DBG_LOUD, ("dm_DIG()=>\n"));
+	if(DM_DigTable.CurIGValue <= 0x24)
+		pAdapter->FalseAlmCnt.Cnt_all = 12000;
+	else if(DM_DigTable.CurIGValue <= 0x28)
+		pAdapter->FalseAlmCnt.Cnt_all = 20;
+	else if(DM_DigTable.CurIGValue <= 0x30)
+		pAdapter->FalseAlmCnt.Cnt_all = 0;
+	else
+		pAdapter->FalseAlmCnt.Cnt_all = 0;
+#endif
+	//modify DIG upper bound
+	if((pDigTable->Rssi_val_min + 20) > DM_DIG_MAX )
+		pDigTable->rx_gain_range_max = DM_DIG_MAX;
+	else
+		pDigTable->rx_gain_range_max = pDigTable->Rssi_val_min + 20;
+
+	//modify DIG lower bound, deal with abnorally large false alarm
+	if(FalseAlmCnt->Cnt_all > 10000)
+	{
+	//	RT_TRACE(COMP_DIG, DBG_LOUD, ("dm_DIG(): Abnornally false alarm case. \n"));
+
+		pDigTable->LargeFAHit++;
+		if(pDigTable->ForbiddenIGI < pDigTable->CurIGValue)
+		{
+			pDigTable->ForbiddenIGI = pDigTable->CurIGValue;
+			pDigTable->LargeFAHit = 1;
+		}
+
+		if(pDigTable->LargeFAHit >= 3)
+		{
+			if((pDigTable->ForbiddenIGI+1) >pDigTable->rx_gain_range_max)
+				pDigTable->rx_gain_range_min = pDigTable->rx_gain_range_max;
+			else
+				pDigTable->rx_gain_range_min = (pDigTable->ForbiddenIGI + 1);
+			pDigTable->Recover_cnt = 3600; //3600=2hr
+		}
+
+	}
+	else
+	{
+		//Recovery mechanism for IGI lower bound
+		if(pDigTable->Recover_cnt != 0)
+			pDigTable->Recover_cnt --;
+		else
+		{
+			if(pDigTable->LargeFAHit == 0 )
+			{
+				if((pDigTable->ForbiddenIGI -1) < DM_DIG_MIN)
+				{
+					pDigTable->ForbiddenIGI = DM_DIG_MIN;
+					pDigTable->rx_gain_range_min = DM_DIG_MIN;
+				}
+				else
+				{
+					pDigTable->ForbiddenIGI --;
+					pDigTable->rx_gain_range_min = (pDigTable->ForbiddenIGI + 1);
+				}
+			}
+			else if(pDigTable->LargeFAHit == 3 )
+			{
+				pDigTable->LargeFAHit = 0;
+			}
+		}
+	}
+
+/*	
+	RT_TRACE(	COMP_DIG, DBG_LOUD, ("DM_DigTable.ForbiddenIGI = 0x%x, DM_DigTable.LargeFAHit = 0x%x\n",
+		DM_DigTable.ForbiddenIGI, DM_DigTable.LargeFAHit));
+	RT_TRACE(	COMP_DIG, DBG_LOUD, ("DM_DigTable.rx_gain_range_max = 0x%x, DM_DigTable.rx_gain_range_min = 0x%x\n",
+		DM_DigTable.rx_gain_range_max, DM_DigTable.rx_gain_range_min));
+*/	
+#if 0	
+	if(pAdapter->FalseAlmCnt.Cnt_all < DM_DIG_FA_TH0)	
+		value_IGI --;
+	else if(pAdapter->FalseAlmCnt.Cnt_all < DM_DIG_FA_TH1)	
+		value_IGI += 0;
+	else if(pAdapter->FalseAlmCnt.Cnt_all < DM_DIG_FA_TH2)	
+		value_IGI ++;
+	else if(pAdapter->FalseAlmCnt.Cnt_all >= DM_DIG_FA_TH2)	
+		value_IGI +=2;
+	//Check initial gain by upper/lower bound
+	if(value_IGI > DM_DigTable.rx_gain_range_max)
+		value_IGI = DM_DigTable.rx_gain_range_max;
+	else if(value_IGI < DM_DigTable.rx_gain_range_min)
+		value_IGI = DM_DigTable.rx_gain_range_min;
+
+	DM_DigTable.CurIGValue = value_IGI;
+#endif		
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+	if(FalseAlmCnt->Cnt_all < 250)
+	{
+#endif
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Enter DIG by SS mode\n"));
+	isBT = rtw_read8(pAdapter, 0x4fd) & 0x01;
+	if(!isBT){
+		if(FalseAlmCnt->Cnt_all > pDigTable->FAHighThresh)
+		{
+			if((pDigTable->BackoffVal -2) < pDigTable->BackoffVal_range_min)
+				pDigTable->BackoffVal = pDigTable->BackoffVal_range_min;
+			else
+				pDigTable->BackoffVal -= 2; 
+		}	
+		else if(FalseAlmCnt->Cnt_all < pDigTable->FALowThresh)
+		{
+			if((pDigTable->BackoffVal+2) > pDigTable->BackoffVal_range_max)
+				pDigTable->BackoffVal = pDigTable->BackoffVal_range_max;
+			else
+				pDigTable->BackoffVal +=2;
+		}	
+	}
+	else
+		pDigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
+		
+	if((pDigTable->Rssi_val_min+10-pDigTable->BackoffVal) > pDigTable->rx_gain_range_max)
+		pDigTable->CurIGValue = pDigTable->rx_gain_range_max;
+	else if((pDigTable->Rssi_val_min+10-pDigTable->BackoffVal) < pDigTable->rx_gain_range_min)
+		pDigTable->CurIGValue = pDigTable->rx_gain_range_min;
+	else
+		pDigTable->CurIGValue = pDigTable->Rssi_val_min+10-pDigTable->BackoffVal;
+
+/*		RT_TRACE(	COMP_DIG, DBG_LOUD, ("RSSI = 0x%x, BackoffVal %d\n", 
+				DM_DigTable.Rssi_val_min, DM_DigTable.BackoffVal));
+				*/
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+	}
+#endif
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+	else
+	{
+	//	RT_TRACE(	COMP_DIG, DBG_LOUD, ("Enter DIG by FA mode\n")); 
+	//	RT_TRACE(	COMP_DIG, DBG_LOUD, ("RSSI = 0x%x", DM_DigTable.Rssi_val_min));
+
+		//Adjust initial gain by false alarm
+		if(FalseAlmCnt->Cnt_all > 1000)
+			pDigTable->CurIGValue = pDigTable->PreIGValue+2;
+		else if (FalseAlmCnt->Cnt_all > 750)
+			pDigTable->CurIGValue = pDigTable->PreIGValue+1;
+		else if(FalseAlmCnt->Cnt_all < 500)
+			pDigTable->CurIGValue = pDigTable->PreIGValue-1;	
+
+		//Check initial gain by upper/lower bound
+		if(pDigTable->CurIGValue > pDigTable->rx_gain_range_max)
+			pDigTable->CurIGValue = pDigTable->rx_gain_range_max;
+		else if(pDigTable->CurIGValue < pDigTable->rx_gain_range_min)
+			pDigTable->CurIGValue = pDigTable->rx_gain_range_min;
+			
+	}
+#endif
+
+	DM_Write_DIG(pAdapter);
+
+}
+
+
+VOID
+dm_initial_gain_Multi_STA(
+	IN	PADAPTER	pAdapter)
+{
+	
+	struct mlme_priv *pmlmepriv = &(pAdapter->mlmepriv);
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	int 	rssi_strength =  pdmpriv->EntryMinUndecoratedSmoothedPWDB;	
+	BOOLEAN	 bMulti_STA = _FALSE;
+
+	 if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+	 {
+		bMulti_STA = _TRUE;
+	 }
+
+	 //todo: AP Mode
+		
+	
+	if((bMulti_STA == _FALSE) 
+		|| (pDigTable->CurSTAConnectState != DIG_STA_DISCONNECT))
+	{
+		pdmpriv->initial_gain_Multi_STA_binitialized = _FALSE;
+		pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;
+		return;
+	}	
+	else if(pdmpriv->initial_gain_Multi_STA_binitialized == _FALSE)
+	{
+		pdmpriv->initial_gain_Multi_STA_binitialized = _TRUE;
+		pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_0;
+		pDigTable->CurIGValue = 0x20;
+		DM_Write_DIG(pAdapter);
+	}
+
+	// Initial gain control by ap mode 
+	if(pDigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT)
+	{
+		if (	(rssi_strength < pDigTable->RssiLowThresh) 	&& 
+			(pDigTable->Dig_Ext_Port_Stage != DIG_EXT_PORT_STAGE_1))
+		{					
+			// Set to dig value to 0x20 for Luke's opinion after disable dig
+			if(pDigTable->Dig_Ext_Port_Stage == DIG_EXT_PORT_STAGE_2)
+			{
+				pDigTable->CurIGValue = 0x20;
+				DM_Write_DIG(pAdapter);				
+			}	
+			pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_1;	
+		}	
+		else if (rssi_strength > pDigTable->RssiHighThresh)
+		{
+			pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_2;
+			dm_CtrlInitGainByFA(pAdapter);
+		} 
+	}	
+	else if(pDigTable->Dig_Ext_Port_Stage != DIG_EXT_PORT_STAGE_0)
+	{
+		pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_0;
+		pDigTable->CurIGValue = 0x20;
+		DM_Write_DIG(pAdapter);
+	}
+
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CurMultiSTAConnectState = %x Dig_Ext_Port_Stage %x\n", 
+	//			DM_DigTable.CurMultiSTAConnectState, DM_DigTable.Dig_Ext_Port_Stage));
+}
+
+
+VOID 
+dm_initial_gain_STA(
+	IN	PADAPTER	pAdapter)
+{
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("PreSTAConnectState = %x, CurSTAConnectState = %x\n", 
+	//			DM_DigTable.PreSTAConnectState, DM_DigTable.CurSTAConnectState));
+
+
+	if(pDigTable->PreSTAConnectState == pDigTable->CurSTAConnectState||
+	   pDigTable->CurSTAConnectState == DIG_STA_BEFORE_CONNECT ||
+	   pDigTable->CurSTAConnectState == DIG_STA_CONNECT)
+	{
+		// beforeconnect -> beforeconnect or  connect -> connect
+		// (dis)connect -> beforeconnect
+		// disconnect -> connecct or beforeconnect -> connect
+		if(pDigTable->CurSTAConnectState != DIG_STA_DISCONNECT)
+		{
+			pDigTable->Rssi_val_min = dm_initial_gain_MinPWDB(pAdapter);
+			dm_CtrlInitGainByRssi(pAdapter);
+		}	
+	}
+	else	
+	{		
+		// connect -> disconnect or beforeconnect -> disconnect
+		pDigTable->Rssi_val_min = 0;
+		pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;
+		pDigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
+		pDigTable->CurIGValue = 0x20;
+		//pDigTable->PreIGValue = 0;	
+		DM_Write_DIG(pAdapter);
+	}
+
+}
+
+
+void dm_CCK_PacketDetectionThresh(
+	IN	PADAPTER	pAdapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pdmpriv->FalseAlmCnt);
+	
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+
+	if(pDigTable->CurSTAConnectState == DIG_STA_CONNECT)
+	{
+		pDigTable->Rssi_val_min = dm_initial_gain_MinPWDB(pAdapter);
+		if(pDigTable->PreCCKPDState == CCK_PD_STAGE_LowRssi)
+		{
+			if(pDigTable->Rssi_val_min <= 25)
+				pDigTable->CurCCKPDState = CCK_PD_STAGE_LowRssi;
+			else
+				pDigTable->CurCCKPDState = CCK_PD_STAGE_HighRssi;
+		}
+		else{
+			if(pDigTable->Rssi_val_min <= 20)
+				pDigTable->CurCCKPDState = CCK_PD_STAGE_LowRssi;
+			else
+				pDigTable->CurCCKPDState = CCK_PD_STAGE_HighRssi;
+		}
+	}
+	else
+		pDigTable->CurCCKPDState=CCK_PD_STAGE_MAX;
+	
+	if(pDigTable->PreCCKPDState != pDigTable->CurCCKPDState)
+	{
+
+		if((pDigTable->CurCCKPDState == CCK_PD_STAGE_LowRssi)||
+			(pDigTable->CurCCKPDState == CCK_PD_STAGE_MAX))
+		{
+			PHY_SetBBReg(pAdapter, rCCK0_CCA, bMaskByte2, 0x83);
+				
+			//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
+			//if(IS_92C_SERIAL(pHalData->VersionID))
+				//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , bMaskByte2, 0xd7);
+		}
+		else
+		{
+			PHY_SetBBReg(pAdapter, rCCK0_CCA, bMaskByte2, 0xcd);
+			//PHY_SetBBReg(pAdapter,rCCK0_System, bMaskByte1, 0x47);
+			//if(IS_92C_SERIAL(pHalData->VersionID))
+				//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , bMaskByte2, 0xd3);
+		}
+		pDigTable->PreCCKPDState = pDigTable->CurCCKPDState;
+
+	}
+	
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CCKPDStage=%x\n",DM_DigTable.CurCCKPDState));
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("is92C=%x\n",IS_92C_SERIAL(pHalData->VersionID)));
+	
+}
+
+
+void dm_1R_CCA(
+	IN	PADAPTER	pAdapter)
+{	
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+
+	if(pDigTable->CurSTAConnectState == DIG_STA_CONNECT)
+	{
+		pDigTable->Rssi_val_min = dm_initial_gain_MinPWDB(pAdapter);
+		if(pDigTable->PreCCAState == CCA_2R)
+		{
+			if(pDigTable->Rssi_val_min >= 35)
+				pDigTable->CurCCAState = CCA_1R;
+			else
+				pDigTable->CurCCAState = CCA_2R;
+			
+		}
+		else{
+			if(pDigTable->Rssi_val_min <= 30)
+				pDigTable->CurCCAState = CCA_2R;
+			else
+				pDigTable->CurCCAState = CCA_1R;
+		}
+	}
+	else
+		pDigTable->CurCCAState=CCA_MAX;
+	
+	if(pDigTable->PreCCAState != pDigTable->CurCCAState)
+	{
+		if(pDigTable->CurCCAState == CCA_1R)
+		{
+			PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x13);
+			PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20);			
+		}
+		else
+		{
+			PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x33);
+			PHY_SetBBReg(pAdapter,0xe70, bMaskByte3, 0x63);
+		}
+		pDigTable->PreCCAState = pDigTable->CurCCAState;
+	}
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CCAStage=%x\n",DM_DigTable.CurCCAState));
+}
+
+
+static	void
+dm_CtrlInitGainByTwoPort(
+	IN	PADAPTER	pAdapter)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(pAdapter);
+	struct mlme_priv *pmlmepriv = &(pAdapter->mlmepriv);
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE)
+		return;
+	/*
+	if(pMgntInfo->BtInfo.BtOperationOn)
+	{
+		// Decide the current status and if modify initial gain or not
+		if(pMgntInfo->bJoinInProgress || pMgntInfo->BtInfo.bBTConnectInProgress)
+			DM_DigTable.CurSTAConnectState = DIG_STA_BEFORE_CONNECT;
+		else
+			DM_DigTable.CurSTAConnectState = DIG_STA_CONNECT;
+	}
+	else*/
+	{
+		// Decide the current status and if modify initial gain or not
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
+		{
+			pDigTable->CurSTAConnectState = DIG_STA_BEFORE_CONNECT;
+		}	
+		else if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) 
+		{
+			pDigTable->CurSTAConnectState = DIG_STA_CONNECT;
+		}	
+		else
+		{
+			pDigTable->CurSTAConnectState = DIG_STA_DISCONNECT;
+		}
+	}	
+		
+	dm_initial_gain_STA(pAdapter);			
+	dm_initial_gain_Multi_STA(pAdapter);		
+	dm_CCK_PacketDetectionThresh(pAdapter);
+		
+	pDigTable->PreSTAConnectState = pDigTable->CurSTAConnectState;
+	
+	
+}
+
+
+void dm_DIG(
+	IN	PADAPTER	pAdapter)
+{
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+	
+	//RTPRINT(FDM, DM_Monitor, ("dm_DIG() ==>\n"));
+	
+	if(pdmpriv->bDMInitialGainEnable == _FALSE)
+		return;
+	
+	//if(pDigTable->Dig_Enable_Flag == _FALSE)
+	//	return;
+	
+	if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
+		return;
+	
+	//RTPRINT(FDM, DM_Monitor, ("dm_DIG() progress \n"));
+
+	dm_CtrlInitGainByTwoPort(pAdapter);
+	
+	//RTPRINT(FDM, DM_Monitor, ("dm_DIG() <==\n"));
+}
+
+void dm_SavePowerIndex(IN	PADAPTER	Adapter)
+{
+	u8			index;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+	
+	for(index = 0; index< 6; index++)
+		pHalData->PowerIndex_backup[index] = rtw_read8(Adapter, Power_Index_REG[index]);
+}
+
+void dm_RestorePowerIndex(IN	PADAPTER	Adapter)
+{
+	u8			index;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+	
+	for(index = 0; index< 6; index++)
+		rtw_write8(Adapter, Power_Index_REG[index], pHalData->PowerIndex_backup[index]);
+}
+
+void dm_WritePowerIndex(
+		IN	PADAPTER	Adapter, 
+		IN 	u8		Value)
+{
+	u8			index;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+	
+	for(index = 0; index< 6; index++)
+		rtw_write8(Adapter, Power_Index_REG[index], Value);
+}
+
+void dm_InitDynamicTxPower(IN	PADAPTER	Adapter)
+{
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+#if DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE					
+	if( BOARD_USB_High_PA == pHalData->BoardType)
+	{
+		dm_SavePowerIndex(Adapter);
+		pdmpriv->bDynamicTxPowerEnable = _TRUE;
+	}		
+	else	
+#else		
+		pdmpriv->bDynamicTxPowerEnable = _FALSE;
+#endif	
+
+	pdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;
+	pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+}
+
+
+void dm_DynamicTxPower(IN	PADAPTER	Adapter)
+{
+	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;	
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	int	UndecoratedSmoothedPWDB;
+
+	if(pdmpriv->bDynamicTxPowerEnable != _TRUE)
+		return;
+
+	// If dynamic high power is disabled.
+	if(  !(pdmpriv->DMFlag & DYNAMIC_FUNC_HP) )		
+	{
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		return;
+	}
+
+	// STA not connected and AP not connected
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&	
+		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+		//the LastDTPlvl should reset when disconnect, 
+		//otherwise the tx power level wouldn't change when disconnect and connect again.
+		// Maddest 20091220.
+		pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
+		return;
+	}
+	
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
+	{
+		//todo: AP Mode
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+		{
+			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+		else
+		{
+			UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
+			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+	}
+	else // associated entry pwdb
+	{	
+		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+	}
+		
+	if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+	{
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
+	}
+	else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+		(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+	{
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+	}
+	else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+	{
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
+	}
+
+	if( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
+	{
+		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192S() Channel = %d \n" , pHalData->CurrentChannel));
+		
+		//set_channel_bwmode(Adapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+		PHY_SetTxPowerLevel8192C(Adapter, pmlmeext->cur_channel);
+
+		if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Normal) // HP1 -> Normal  or HP2 -> Normal
+			dm_RestorePowerIndex(Adapter);
+		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
+			dm_WritePowerIndex(Adapter, 0x14);
+		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
+			dm_WritePowerIndex(Adapter, 0x10);		
+	}
+	
+	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
+	
+}
+
+
+VOID
+DM_ChangeDynamicInitGainThresh(
+	IN	PADAPTER	pAdapter,
+	IN	u32		DM_Type,
+	IN	u32		DM_Value)
+{
+	struct dm_priv *pdmpriv = &pAdapter->dmpriv;
+	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+
+	if (DM_Type == DIG_TYPE_THRESH_HIGH)
+	{
+		pDigTable->RssiHighThresh = DM_Value;		
+	}
+	else if (DM_Type == DIG_TYPE_THRESH_LOW)
+	{
+		pDigTable->RssiLowThresh = DM_Value;
+	}
+	else if (DM_Type == DIG_TYPE_ENABLE)
+	{
+		pDigTable->Dig_Enable_Flag = _TRUE;
+	}	
+	else if (DM_Type == DIG_TYPE_DISABLE)
+	{
+		pDigTable->Dig_Enable_Flag = _FALSE;
+	}	
+	else if (DM_Type == DIG_TYPE_BACKOFF)
+	{
+		if(DM_Value > 30)
+			DM_Value = 30;
+		pDigTable->BackoffVal = (u8)DM_Value;
+	}
+	else if(DM_Type == DIG_TYPE_RX_GAIN_MIN)
+	{
+		if(DM_Value == 0)
+			DM_Value = 0x1;
+		pDigTable->rx_gain_range_min = (u8)DM_Value;
+	}
+	else if(DM_Type == DIG_TYPE_RX_GAIN_MAX)
+	{
+		if(DM_Value > 0x50)
+			DM_Value = 0x50;
+		pDigTable->rx_gain_range_max = (u8)DM_Value;
+	}
+}	/* DM_ChangeDynamicInitGainThresh */
+
+
+VOID PWDB_Monitor(
+	IN	PADAPTER	Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	//u8		i;
+	int	tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
+
+	if(check_fwstate(&Adapter->mlmepriv, _FW_LINKED) != _TRUE)
+		return;
+
+#if 0 //todo:
+	for(i = 0; i < ASSOCIATE_ENTRY_NUM; i++)
+	{
+		if(Adapter->MgntInfo.NdisVersion == RT_NDIS_VERSION_6_2)
+		{
+			if(ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)))
+				pEntry = AsocEntry_EnumStation(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE), i);
+			else
+				pEntry = AsocEntry_EnumStation(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, TRUE), i);
+		}
+		else
+		{
+			pEntry = AsocEntry_EnumStation(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, TRUE), i);	
+		}
+
+		if(pEntry!=NULL)
+		{
+			if(pEntry->bAssociated)
+			{
+				RTPRINT_ADDR(FDM, DM_PWDB, ("pEntry->MacAddr ="), pEntry->MacAddr);
+				RTPRINT(FDM, DM_PWDB, ("pEntry->rssi = 0x%x(%d)\n", 
+					pEntry->rssi_stat.UndecoratedSmoothedPWDB,
+					pEntry->rssi_stat.UndecoratedSmoothedPWDB));
+				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+					tmpEntryMinPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+					tmpEntryMaxPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+#endif
+
+	if(tmpEntryMaxPWDB != 0)	// If associated entry is found
+	{
+		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;		
+	}
+	else
+	{
+		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
+	}
+	
+	if(tmpEntryMinPWDB != 0xff) // If associated entry is found
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;		
+	}
+	else
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
+	}
+
+	if(pHalData->fw_ractrl == _TRUE)
+	{		
+		u32 param = (u32)(pdmpriv->UndecoratedSmoothedPWDB<<16);
+
+		//printk("######## RSSI(%d) ##############\n",pdmpriv->UndecoratedSmoothedPWDB);
+		param |= 0;//macid=0 for sta mode;
+		set_rssi_cmd(Adapter, (u8*)&param);
+	}
+
+}
+
+
+void
+DM_InitEdcaTurbo(
+	IN	PADAPTER	Adapter
+	)
+{
+#if 0
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	pHalData->bCurrentTurboEDCA = _FALSE;
+	pHalData->bIsAnyNonBEPkts = _FALSE;
+	pHalData->bIsCurRDLState = _FALSE;
+#endif	
+}	// DM_InitEdcaTurbo
+
+
+void
+dm_CheckEdcaTurbo(
+	IN	PADAPTER	Adapter
+	)
+{
+	//update the EDCA paramter according to the Tx/RX mode
+	update_EDCA_param(Adapter);
+}	
+
+#define		index_mapping_HP_NUM	15	
+//091212 chiyokolin
+static	VOID
+dm_TXPowerTrackingCallback_ThermalMeter_92C(
+            IN PADAPTER	Adapter)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	u8			ThermalValue = 0, delta, delta_LCK, delta_IQK,TimeOut = 100;
+	int 			ele_A, ele_D, TempCCk, X, value32;
+	int			Y, ele_C;
+	s8			OFDM_index[2], CCK_index, OFDM_index_old[2], CCK_index_old;
+	int i = 0,CCKSwingNeedUpdate = 0;
+	BOOLEAN			is2T;
+	//PMPT_CONTEXT	pMptCtx = &(Adapter->MptCtx);	
+	//u8	*TxPwrLevel = pMptCtx->TxPwrLevel;//???
+	u8	OFDM_min_index = 6, rf; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur
+	
+	pdmpriv->TXPowerTrackingCallbackCnt++;	//cosa add for debug
+	pdmpriv->bTXPowerTrackingInit = _TRUE;
+
+	if(pHalData->CurrentChannel == 14 && !pHalData->bCCKinCH14)
+		pHalData->bCCKinCH14 = _TRUE;
+	else if(pHalData->CurrentChannel != 14 && pHalData->bCCKinCH14)
+		pHalData->bCCKinCH14 = _FALSE;
+
+	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("===>dm_TXPowerTrackingCallback_ThermalMeter_92C\n"));
+
+	ThermalValue = (u8)PHY_QueryRFReg(Adapter, RF90_PATH_A, RF_T_METER, 0x1f);	// 0x24: RF Reg[4:0]	
+
+	/*
+
+	printk("\n\nReadback Thermal Meter = 0x%x pre thermal meter 0x%x EEPROMthermalmeter 0x%x\n",\
+			 ThermalValue,pdmpriv->ThermalValue,  pEEPROM->EEPROMThermalMeter);
+
+	*/
+
+	PHY_APCalibrate(Adapter, (ThermalValue - pEEPROM->EEPROMThermalMeter));//notes:EEPROMThermalMeter is a fixed value from efuse/eeprom
+
+//	if(!pHalData->TxPowerTrackControl)
+//		return;
+
+	if(pHalData->rf_type == RF_1T1R)
+	{
+		rf = 1;
+		is2T = _FALSE;
+	}	
+	else
+	{
+		rf = 2;
+		is2T = _TRUE;
+	}	
+	
+	if(ThermalValue)
+	{
+//		if(!pHalData->ThermalValue)
+		{
+			//Query OFDM path A default setting 		
+			ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord)&0xffc00000;
+			for(i=0; i<OFDM_TABLE_SIZE; i++)	//find the index
+			{
+				if(ele_D == (OFDMSwingTable[i]&0xffc00000))
+				{
+					OFDM_index_old[0] = (s8)i;
+					//printk("Initial pathA ele_D reg0x%x = 0x%x, OFDM_index=0x%x\n", rOFDM0_XATxIQImbalance, ele_D, OFDM_index_old[0]);
+					break;
+				}
+			}
+
+			//Query OFDM path B default setting 
+			if(is2T)
+			{
+				ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord)&0xffc00000;
+				for(i=0; i<OFDM_TABLE_SIZE; i++)	//find the index
+				{
+					if(ele_D == (OFDMSwingTable[i]&0xffc00000))
+					{
+						OFDM_index_old[1] = (s8)i;
+						//printk("Initial pathB ele_D reg0x%x = 0x%x, OFDM_index=0x%x\n",rOFDM0_XBTxIQImbalance, ele_D, OFDM_index_old[1]);
+						break;
+					}
+				}
+			}
+
+			//Query CCK default setting From 0xa24
+			TempCCk = PHY_QueryBBReg(Adapter, rCCK0_TxFilter2, bMaskDWord)&0x3f3f3f3f;
+			for(i=0 ; i<CCK_TABLE_SIZE ; i++)
+			{
+				if(pHalData->bCCKinCH14)
+				{
+					if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==_TRUE)
+					{
+						CCK_index_old =(s8)i;
+						//printk("Initial reg0x%x = 0x%x, CCK_index=0x%x, ch 14 %d\n", rCCK0_TxFilter2, TempCCk, CCK_index_old, pHalData->bCCKinCH14);
+						break;
+					}
+				}
+				else
+				{
+					if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==_TRUE)
+					{
+						CCK_index_old =(s8)i;
+						//printk("Initial reg0x%x = 0x%x, CCK_index=0x%x, ch14 %d\n", rCCK0_TxFilter2, TempCCk, CCK_index_old, pHalData->bCCKinCH14);
+						break;
+					}			
+				}
+			}	
+
+			if(!pdmpriv->ThermalValue)
+			{
+				pdmpriv->ThermalValue = pEEPROM->EEPROMThermalMeter;
+				pdmpriv->ThermalValue_LCK = ThermalValue;				
+				pdmpriv->ThermalValue_IQK = ThermalValue;								
+				
+				for(i = 0; i < rf; i++)
+					pdmpriv->OFDM_index[i] = OFDM_index_old[i];
+				
+				pdmpriv->CCK_index = CCK_index_old;
+				//printk("==>init_value , ThermalValue = 0x%x,CCK_Index = 0x%x\n",pdmpriv->ThermalValue,pdmpriv->CCK_index);
+			}			
+		}
+		
+		delta = (ThermalValue > pdmpriv->ThermalValue)?(ThermalValue - pdmpriv->ThermalValue):(pdmpriv->ThermalValue - ThermalValue);
+		delta_LCK = (ThermalValue > pdmpriv->ThermalValue_LCK)?(ThermalValue - pdmpriv->ThermalValue_LCK):(pdmpriv->ThermalValue_LCK - ThermalValue);
+		delta_IQK = (ThermalValue > pdmpriv->ThermalValue_IQK)?(ThermalValue - pdmpriv->ThermalValue_IQK):(pdmpriv->ThermalValue_IQK - ThermalValue);
+
+		/*
+		printk("Readback Thermal Meter = 0x%x EEPROMthermalmeter 0x%x delta 0x%x delta_LCK 0x%x delta_IQK 0x%x\n", \
+				ThermalValue, pEEPROM->EEPROMThermalMeter, delta, delta_LCK, delta_IQK);
+
+		*/
+
+
+		if(delta_LCK > 1)
+		{
+			pdmpriv->ThermalValue_LCK = ThermalValue;
+			PHY_LCCalibrate(Adapter);
+		}
+		
+		if(delta > 0 && pdmpriv->TxPowerTrackControl)
+		{
+			if(ThermalValue > pdmpriv->ThermalValue)
+			{ 
+				for(i = 0; i < rf; i++)
+				 	pdmpriv->OFDM_index[i] -= delta;
+				
+				pdmpriv->CCK_index -= delta;
+			}
+			else
+			{
+				for(i = 0; i < rf; i++)			
+					pdmpriv->OFDM_index[i] += delta;
+				
+				pdmpriv->CCK_index += delta;
+			}
+
+	/*		
+			if(is2T)
+			{
+				printk("temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n", 
+					pdmpriv->OFDM_index[0], pdmpriv->OFDM_index[1], pdmpriv->CCK_index);			
+			}
+			else
+			{
+				//printk("temp OFDM_A_index=0x%x, CCK_index=0x%x\n",pdmpriv->OFDM_index[0], pdmpriv->CCK_index);			
+			}
+	*/		
+			
+			if(ThermalValue > pEEPROM->EEPROMThermalMeter)
+			{
+				for(i = 0; i < rf; i++)			
+					OFDM_index[i] = pdmpriv->OFDM_index[i]+1;
+				
+				CCK_index = pdmpriv->CCK_index+1;			
+			}
+			else
+			{
+				for(i = 0; i < rf; i++)			
+					OFDM_index[i] = pdmpriv->OFDM_index[i];
+				
+				CCK_index = pdmpriv->CCK_index;						
+			}
+
+#if 0 //todo:
+			for(i = 0; i < rf; i++)
+			{
+				if(TxPwrLevel[i] >=0 && TxPwrLevel[i] <=26)
+				{
+					if(ThermalValue > pEEPROM->EEPROMThermalMeter)
+					{
+						if (delta < 5)
+							OFDM_index[i] -= 1;					
+						else 
+							OFDM_index[i] -= 2;					
+					}
+					else if(delta > 5 && ThermalValue < pEEPROM->EEPROMThermalMeter)
+					{
+						OFDM_index[i] += 1;
+					}
+				}
+				else if (TxPwrLevel[i] >= 27 && TxPwrLevel[i] <= 32 && ThermalValue > pEEPROM->EEPROMThermalMeter)
+				{
+					if (delta < 5)
+						OFDM_index[i] -= 1;					
+					else 
+						OFDM_index[i] -= 2;								
+				}
+				else if (TxPwrLevel[i] >= 32 && TxPwrLevel[i] <= 38 && ThermalValue > pEEPROM->EEPROMThermalMeter && delta > 5)
+				{
+					OFDM_index[i] -= 1;								
+				}
+			}
+
+			{
+				if(TxPwrLevel[i] >=0 && TxPwrLevel[i] <=26)
+				{
+					if(ThermalValue > pEEPROM->EEPROMThermalMeter)
+					{
+						if (delta < 5)
+							CCK_index -= 1; 				
+						else 
+							CCK_index -= 2; 				
+					}
+					else if(delta > 5 && ThermalValue < pEEPROM->EEPROMThermalMeter)
+					{
+						CCK_index += 1;
+					}
+				}
+				else if (TxPwrLevel[i] >= 27 && TxPwrLevel[i] <= 32 && ThermalValue > pEEPROM->EEPROMThermalMeter)
+				{
+					if (delta < 5)
+						CCK_index -= 1; 				
+					else 
+						CCK_index -= 2; 							
+				}
+				else if (TxPwrLevel[i] >= 32 && TxPwrLevel[i] <= 38 && ThermalValue > pEEPROM->EEPROMThermalMeter && delta > 5)
+				{
+					CCK_index -= 1; 							
+				}
+			}
+#endif
+
+			for(i = 0; i < rf; i++)
+			{
+				if(OFDM_index[i] > OFDM_TABLE_SIZE-1)
+					OFDM_index[i] = OFDM_TABLE_SIZE-1;
+				else if (OFDM_index[i] < OFDM_min_index)
+					OFDM_index[i] = OFDM_min_index;
+			}
+						
+			if(CCK_index > CCK_TABLE_SIZE-1)
+				CCK_index = CCK_TABLE_SIZE-1;
+			else if (CCK_index < 0)
+				CCK_index = 0;		
+
+	/*		
+			if(is2T)
+			{
+				printk("new OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n", OFDM_index[0], OFDM_index[1], CCK_index);
+			}
+			else
+			{
+				//printk("new OFDM_A_index=0x%x, CCK_index=0x%x\n",	OFDM_index[0], CCK_index);			
+			}
+	*/
+			
+		}
+		else if (delta == 0)
+		{
+			//return;
+		}
+
+		if(pdmpriv->TxPowerTrackControl && delta != 0)
+		{
+			//Adujst OFDM Ant_A according to IQK result
+			ele_D = (OFDMSwingTable[(u8)OFDM_index[0]] & 0xFFC00000)>>22;
+			//X = (PHY_QueryBBReg(Adapter, 0xe94, bMaskDWord) >> 16) & 0x3FF;
+			//Y = (PHY_QueryBBReg(Adapter, 0xe9c, bMaskDWord) >> 16) & 0x3FF;		
+			X = pHalData->RegE94;
+			Y = pHalData->RegE9C;		
+if(X != 0)
+			{
+				if ((X & 0x00000200) != 0)
+					X = X | 0xFFFFFC00;
+				ele_A = ((X * ele_D)>>8)&0x000003FF;
+					
+				//new element C = element D x Y
+				if ((Y & 0x00000200) != 0)
+					Y = Y | 0xFFFFFC00;
+				ele_C = ((Y * ele_D)>>8)&0x000003FF;
+				
+				//wirte new elements A, C, D to regC80 and regC94, element B is always 0
+				value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
+				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
+				
+				value32 = (ele_C&0x000003C0)>>6;
+				PHY_SetBBReg(Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
+
+				value32 = ((X * ele_D)>>7)&0x01;
+				PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT31, value32);
+
+				value32 = ((Y * ele_D)>>7)&0x01;
+				PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT29, value32);
+				
+			}
+			else
+			{
+				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable[OFDM_index[0]]);				
+				PHY_SetBBReg(Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
+				PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT31|BIT29, 0x00);			
+			}
+
+			//RTPRINT(FINIT, INIT_IQK, ("TxPwrTracking path A: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x\n", X, Y, ele_A, ele_C, ele_D));		
+
+			//Adjust CCK according to IQK result
+			if(!pHalData->bCCKinCH14){
+				rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0]);
+				rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1]);
+				rtw_write8(Adapter, 0xa24, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][2]);
+				rtw_write8(Adapter, 0xa25, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][3]);
+				rtw_write8(Adapter, 0xa26, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][4]);
+				rtw_write8(Adapter, 0xa27, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][5]);
+				rtw_write8(Adapter, 0xa28, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][6]);
+				rtw_write8(Adapter, 0xa29, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][7]);		
+
+/*
+				printk("Adjust CCK_index=0x%02x 0xa22=0x%02x, 0xa23=0x%02x,0xa24=0x%02x,0xa25=0x%02x,0xa26=0x%02x,0xa27=0x%02x,0xa28=0x%02x,0xa29=0x%02x\n", 
+					CCK_index,CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0],CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1],
+					CCKSwingTable_Ch1_Ch13[(u8)CCK_index][2],CCKSwingTable_Ch1_Ch13[(u8)CCK_index][3],
+					CCKSwingTable_Ch1_Ch13[(u8)CCK_index][4],CCKSwingTable_Ch1_Ch13[(u8)CCK_index][5],
+					CCKSwingTable_Ch1_Ch13[(u8)CCK_index][6],CCKSwingTable_Ch1_Ch13[(u8)CCK_index][7]);
+*/					
+			}
+			else{
+				rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch14[(u8)CCK_index][0]);
+				rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch14[(u8)CCK_index][1]);
+				rtw_write8(Adapter, 0xa24, CCKSwingTable_Ch14[(u8)CCK_index][2]);
+				rtw_write8(Adapter, 0xa25, CCKSwingTable_Ch14[(u8)CCK_index][3]);
+				rtw_write8(Adapter, 0xa26, CCKSwingTable_Ch14[(u8)CCK_index][4]);
+				rtw_write8(Adapter, 0xa27, CCKSwingTable_Ch14[(u8)CCK_index][5]);
+				rtw_write8(Adapter, 0xa28, CCKSwingTable_Ch14[(u8)CCK_index][6]);
+				rtw_write8(Adapter, 0xa29, CCKSwingTable_Ch14[(u8)CCK_index][7]);	
+			}		
+
+			if(is2T)
+			{						
+				ele_D = (OFDMSwingTable[(u8)OFDM_index[1]] & 0xFFC00000)>>22;
+				
+				//new element A = element D x X
+				//X = (PHY_QueryBBReg(Adapter, 0xeb4, bMaskDWord) >> 16) & 0x3FF;
+				//Y = (PHY_QueryBBReg(Adapter, 0xebc, bMaskDWord) >> 16) & 0x3FF;
+				X = pHalData->RegEB4;
+				Y = pHalData->RegEBC;
+				
+				if(X != 0){
+					if ((X & 0x00000200) != 0)	//consider minus
+						X = X | 0xFFFFFC00;
+					ele_A = ((X * ele_D)>>8)&0x000003FF;
+					
+					//new element C = element D x Y
+					if ((Y & 0x00000200) != 0)
+						Y = Y | 0xFFFFFC00;
+					ele_C = ((Y * ele_D)>>8)&0x00003FF;
+					
+					//wirte new elements A, C, D to regC88 and regC9C, element B is always 0
+					value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
+					PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
+
+					value32 = (ele_C&0x000003C0)>>6;
+					PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, value32);	
+					
+					value32 = ((X * ele_D)>>7)&0x01;
+					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT27, value32);
+
+					value32 = ((Y * ele_D)>>7)&0x01;
+					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT25, value32);
+
+				}
+				else{
+					PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable[OFDM_index[1]]);										
+					PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);	
+					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT27|BIT25, 0x00);				
+				}
+/*
+				printk("TxPwrTracking path B: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x\n", \
+											X, Y, ele_A, ele_C, ele_D);			
+*/
+			}
+
+
+			/*
+
+			printk("TxPwrTracking 0xc80 = 0x%x, 0xc94 = 0x%x RF 0x24 = 0x%x\n", \
+					PHY_QueryBBReg(Adapter, 0xc80, bMaskDWord),\
+					PHY_QueryBBReg(Adapter, 0xc94, bMaskDWord), \
+					PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x24, bMaskDWord));
+			*/
+
+		}
+		
+		if(delta_IQK > 3)
+		{
+			pdmpriv->ThermalValue_IQK = ThermalValue;
+			PHY_IQCalibrate(Adapter,_FALSE);
+		}
+
+		//update thermal meter value
+		//if(pdmpriv->TxPowerTrackControl)
+		//	Adapter->HalFunc.SetHalDefVarHandler(Adapter, HAL_DEF_THERMAL_VALUE, &ThermalValue);//???
+		pdmpriv->ThermalValue = ThermalValue;
+			
+	}
+
+	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("<===dm_TXPowerTrackingCallback_ThermalMeter_92C\n"));
+	
+	pdmpriv->TXPowercount = 0;
+
+}
+
+
+static	VOID
+dm_InitializeTXPowerTracking_ThermalMeter(
+	IN	PADAPTER		Adapter)
+{	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+
+	//pMgntInfo->bTXPowerTracking = _TRUE;
+	pdmpriv->TXPowercount = 0;
+	pdmpriv->bTXPowerTrackingInit = _FALSE;
+	pdmpriv->ThermalValue = 0;
+	
+#if	(MP_DRIVER != 1)	//for mp driver, turn off txpwrtracking as default
+	pdmpriv->TxPowerTrackControl = _TRUE;
+#endif
+	
+	MSG_8192C("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
+}
+
+
+VOID
+DM_InitializeTXPowerTracking(
+	IN	PADAPTER		Adapter)
+{
+	dm_InitializeTXPowerTracking_ThermalMeter(Adapter);	
+}	
+
+//
+//	Description:
+//		- Dispatch TxPower Tracking direct call ONLY for 92s.
+//		- We shall NOT schedule Workitem within PASSIVE LEVEL, which will cause system resource
+//		   leakage under some platform.
+//
+//	Assumption:
+//		PASSIVE_LEVEL when this routine is called.
+//
+//	Added by Roger, 2009.06.18.
+//
+VOID
+DM_TXPowerTracking92CDirectCall(
+            IN	PADAPTER		Adapter)
+{	
+	dm_TXPowerTrackingCallback_ThermalMeter_92C(Adapter);
+}
+
+VOID
+dm_CheckTXPowerTracking_ThermalMeter(
+	IN	PADAPTER		Adapter)
+{	
+	//HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;	
+	//u1Byte					TxPowerCheckCnt = 5;	//10 sec
+
+	//if(!pMgntInfo->bTXPowerTracking /*|| (!pHalData->TxPowerTrackControl && pHalData->bAPKdone)*/)
+	if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_SS))
+	{
+		return;
+	}
+
+	if(!pdmpriv->TM_Trigger)		//at least delay 1 sec
+	{
+		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
+		PHY_SetRFReg(Adapter, RF90_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Trigger 92C Thermal Meter!!\n"));
+		
+		pdmpriv->TM_Trigger = 1;
+		return;
+		
+	}
+	else
+	{
+		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Schedule TxPowerTracking direct call!!\n"));		
+		DM_TXPowerTracking92CDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
+		pdmpriv->TM_Trigger = 0;
+	}
+
+}
+
+
+VOID
+dm_CheckTXPowerTracking(
+	IN	PADAPTER		Adapter)
+{
+	dm_CheckTXPowerTracking_ThermalMeter(Adapter);
+}
+
+#ifdef CONFIG_BT_COEXIST
+BOOLEAN BT_BTStateChange(PADAPTER Adapter)
+{
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	struct btcoexist_priv	 *pbtpriv = &(Adapter->halpriv.bt_coexist);
+	struct registry_priv  *registry_par = &Adapter->registrypriv;
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	
+	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+	
+	u32 		Polling, Ratio_Tx, Ratio_PRI;
+	u32 			BT_Tx, BT_PRI;
+	u8			BT_State;
+
+	u8			CurServiceType;
+	
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)	
+		return _FALSE;
+	
+	BT_State = rtw_read8(Adapter, 0x4fd);
+/*
+	temp = PlatformEFIORead4Byte(Adapter, 0x488);
+	BT_Tx = (u2Byte)(((temp<<8)&0xff00)+((temp>>8)&0xff));
+	BT_PRI = (u2Byte)(((temp>>8)&0xff00)+((temp>>24)&0xff));
+
+	temp = PlatformEFIORead4Byte(Adapter, 0x48c);
+	Polling = ((temp<<8)&0xff000000) + ((temp>>8)&0x00ff0000) + 
+			((temp<<8)&0x0000ff00) + ((temp>>8)&0x000000ff);
+	
+*/
+	BT_Tx = rtw_read32(Adapter, 0x488);
+	
+	printk("Ratio 0x488  =%x\n", BT_Tx);
+	BT_Tx =BT_Tx & 0x00ffffff;
+	//RTPRINT(FBT, BT_TRACE, ("Ratio BT_Tx  =%x\n", BT_Tx));
+
+	BT_PRI = rtw_read32(Adapter, 0x48c);
+	
+	printk("Ratio 0x48c  =%x\n", BT_PRI);
+	BT_PRI =BT_PRI & 0x00ffffff;
+	//RTPRINT(FBT, BT_TRACE, ("Ratio BT_PRI  =%x\n", BT_PRI));
+
+
+	Polling = rtw_read32(Adapter, 0x490);
+	//RTPRINT(FBT, BT_TRACE, ("Ratio 0x490  =%x\n", Polling));
+
+
+	if(BT_Tx==0xffffffff && BT_PRI==0xffffffff && Polling==0xffffffff && BT_State==0xff)
+		return _FALSE;
+
+	BT_State &= BIT0;
+
+	if(BT_State != pbtpriv->BT_CUR_State)
+	{
+		pbtpriv->BT_CUR_State = BT_State;
+	
+		if(registry_par->bt_sco == 3)
+		{
+			pdmpriv->BT_ServiceTypeCnt = 0;
+		
+			pbtpriv->BT_Service = BT_Idle;
+
+			printk("BT_%s\n", BT_State?"ON":"OFF");
+
+			BT_State = BT_State | 
+					((pbtpriv->BT_Ant_isolation==1)?0:BIT1) |BIT2;
+
+			rtw_write8(Adapter, 0x4fd, BT_State);
+			printk("BT set 0x4fd to %x\n", BT_State);
+		}
+		
+		return _TRUE;
+	}
+	printk("bRegBT_Sco =  %d\n",registry_par->bt_sco);
+
+	Ratio_Tx = BT_Tx*1000/Polling;
+	Ratio_PRI = BT_PRI*1000/Polling;
+
+	pbtpriv->Ratio_Tx=Ratio_Tx;
+	pbtpriv->Ratio_PRI=Ratio_PRI;
+	
+	printk("Ratio_Tx=%d\n", Ratio_Tx);
+	printk("Ratio_PRI=%d\n", Ratio_PRI);
+
+	
+	if(BT_State && registry_par->bt_sco==3)
+	{
+		printk("bt_sco  ==3 Follow Counter\n");
+//		if(BT_Tx==0xffff && BT_PRI==0xffff && Polling==0xffffffff)
+//		{
+//			ServiceTypeCnt = 0;
+//			return FALSE;
+//		}
+//		else
+		{
+		/*
+			Ratio_Tx = BT_Tx*1000/Polling;
+			Ratio_PRI = BT_PRI*1000/Polling;
+
+			pHalData->bt_coexist.Ratio_Tx=Ratio_Tx;
+			pHalData->bt_coexist.Ratio_PRI=Ratio_PRI;
+			
+			RTPRINT(FBT, BT_TRACE, ("Ratio_Tx=%d\n", Ratio_Tx));
+			RTPRINT(FBT, BT_TRACE, ("Ratio_PRI=%d\n", Ratio_PRI));
+
+		*/	
+			if((Ratio_Tx < 30)  && (Ratio_PRI < 30)) 
+			  	CurServiceType = BT_Idle;
+			else if((Ratio_PRI > 110) && (Ratio_PRI < 250))
+				CurServiceType = BT_SCO;
+			else if((Ratio_Tx >= 200)&&(Ratio_PRI >= 200))
+				CurServiceType = BT_Busy;
+			else if((Ratio_Tx >=350) && (Ratio_Tx < 500))
+				CurServiceType = BT_OtherBusy;
+			else if(Ratio_Tx >=500)
+				CurServiceType = BT_PAN;
+			else
+				CurServiceType=BT_OtherAction;
+		}
+
+/*		if(pHalData->bt_coexist.bStopCount)
+		{
+			ServiceTypeCnt=0;
+			pHalData->bt_coexist.bStopCount=FALSE;
+		}
+*/
+//		if(CurServiceType == BT_OtherBusy)
+		{
+			pdmpriv->BT_ServiceTypeCnt=2;
+			pdmpriv->BT_LastServiceType=CurServiceType;
+		}
+#if 0
+		else if(CurServiceType == LastServiceType)
+		{
+			if(ServiceTypeCnt<3)
+				ServiceTypeCnt++;
+		}
+		else
+		{
+			ServiceTypeCnt = 0;
+			LastServiceType = CurServiceType;
+		}
+#endif
+
+		if(pdmpriv->BT_ServiceTypeCnt==2)
+		{
+			pbtpriv->BT_Service = pdmpriv->BT_LastServiceType;
+			BT_State = BT_State | 
+					((pbtpriv->BT_Ant_isolation==1)?0:BIT1) |
+					//((pbtpriv->BT_Service==BT_SCO)?0:BIT2);
+					((pbtpriv->BT_Service!=BT_Idle)?0:BIT2);
+
+			//if(pbtpriv->BT_Service==BT_Busy)
+			//	BT_State&= ~(BIT2);
+
+			if(pbtpriv->BT_Service==BT_SCO)
+			{
+				printk("BT TYPE Set to  ==> BT_SCO\n");
+			}
+			else if(pbtpriv->BT_Service==BT_Idle)
+			{
+				printk("BT TYPE Set to  ==> BT_Idle\n");
+			}
+			else if(pbtpriv->BT_Service==BT_OtherAction)
+			{
+				printk("BT TYPE Set to  ==> BT_OtherAction\n");
+			}
+			else if(pbtpriv->BT_Service==BT_Busy)
+			{
+				printk("BT TYPE Set to  ==> BT_Busy\n");
+			}
+			else if(pbtpriv->BT_Service==BT_PAN)
+			{
+				printk("BT TYPE Set to  ==> BT_PAN\n");
+			}
+			else
+			{
+				printk("BT TYPE Set to ==> BT_OtherBusy\n");
+			}
+				
+			//Add interrupt migration when bt is not in idel state (no traffic).
+			//suggestion by Victor.
+			if(pbtpriv->BT_Service!=BT_Idle)//EDCA_VI_PARAM modify
+			{
+			
+				rtw_write16(Adapter, 0x504, 0x0ccc);
+				rtw_write8(Adapter, 0x506, 0x54);
+				rtw_write8(Adapter, 0x507, 0x54);
+			
+			}
+			else
+			{
+				rtw_write8(Adapter, 0x506, 0x00);
+				rtw_write8(Adapter, 0x507, 0x00);			
+			}
+				
+			rtw_write8(Adapter, 0x4fd, BT_State);
+			printk("BT_SCO set 0x4fd to %x\n", BT_State);
+			return _TRUE;
+		}
+	}
+
+	return _FALSE;
+
+}
+
+BOOLEAN
+BT_WifiConnectChange(
+	IN	PADAPTER	Adapter
+	)
+{
+	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+//	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;	
+
+	//if(!pMgntInfo->bMediaConnect || MgntRoamingInProgress(pMgntInfo))
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)	
+	{
+		pdmpriv->BT_bMediaConnect = _FALSE;
+	}
+	else
+	{
+		if(!pdmpriv->BT_bMediaConnect)
+		{
+			pdmpriv->BT_bMediaConnect = _TRUE;
+			return _TRUE;
+		}
+		pdmpriv->BT_bMediaConnect = _TRUE;
+	}
+
+	return _FALSE;
+}
+
+#define BT_RSSI_STATE_NORMAL_POWER	BIT0
+#define BT_RSSI_STATE_AMDPU_OFF		BIT1
+#define BT_RSSI_STATE_SPECIAL_LOW	BIT2
+#define BT_RSSI_STATE_BG_EDCA_LOW	BIT3
+
+s32 GET_UNDECORATED_AVERAGE_RSSI(PADAPTER	Adapter)	
+{
+	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
+	struct dm_priv 		*pdmpriv = &Adapter->dmpriv;
+	s32 	average_rssi;
+	
+	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
+	{	
+		average_rssi = 	pdmpriv->EntryMinUndecoratedSmoothedPWDB;	
+	}
+	else
+	{
+		average_rssi = 	pdmpriv->UndecoratedSmoothedPWDB;
+	}
+	return average_rssi;
+}
+u8
+BT_RssiStateChange(
+	IN	PADAPTER	Adapter
+	)
+{
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_priv	 *pmlmepriv = &(Adapter->mlmepriv);
+	struct btcoexist_priv	 *pbtpriv = &(Adapter->halpriv.bt_coexist);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	//PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+	s32			UndecoratedSmoothedPWDB;
+	u8			CurrBtRssiState = 0x00;
+
+	//if(pMgntInfo->bMediaConnect)	// Default port
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	
+	{
+		UndecoratedSmoothedPWDB = GET_UNDECORATED_AVERAGE_RSSI(Adapter);
+	}
+	else // associated entry pwdb
+	{
+		if(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0)
+			UndecoratedSmoothedPWDB = 100;	// No any RSSI information. Assume to be MAX.
+		else
+			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	}
+
+	// Check RSSI to determine HighPower/NormalPower state for BT coexistence.
+	if(UndecoratedSmoothedPWDB >= 67)
+		CurrBtRssiState &= (~BT_RSSI_STATE_NORMAL_POWER);
+	else if(UndecoratedSmoothedPWDB < 62)
+		CurrBtRssiState |= BT_RSSI_STATE_NORMAL_POWER;
+
+	// Check RSSI to determine AMPDU setting for BT coexistence.
+	if(UndecoratedSmoothedPWDB >= 40)
+		CurrBtRssiState &= (~BT_RSSI_STATE_AMDPU_OFF);
+	else if(UndecoratedSmoothedPWDB <= 32)
+		CurrBtRssiState |= BT_RSSI_STATE_AMDPU_OFF;
+
+	// Marked RSSI state. It will be used to determine BT coexistence setting later.
+	if(UndecoratedSmoothedPWDB < 35)
+		CurrBtRssiState |=  BT_RSSI_STATE_SPECIAL_LOW;
+	else
+		CurrBtRssiState &= (~BT_RSSI_STATE_SPECIAL_LOW);
+
+	// Check BT state related to BT_Idle in B/G mode.
+	if(UndecoratedSmoothedPWDB < 15)
+		CurrBtRssiState |=  BT_RSSI_STATE_BG_EDCA_LOW;
+	else
+		CurrBtRssiState &= (~BT_RSSI_STATE_BG_EDCA_LOW);
+	
+	if(CurrBtRssiState != pbtpriv->BtRssiState)
+	{
+		pbtpriv->BtRssiState = CurrBtRssiState;
+		return _TRUE;
+	}
+	else
+	{
+		return _FALSE;
+	}
+}
+
+void dm_BTCoexist(PADAPTER Adapter )
+{
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_priv	 		*pmlmepriv = &(Adapter->mlmepriv);
+	struct mlme_ext_info		*pmlmeinfo = &Adapter->mlmeextpriv.mlmext_info;
+	struct mlme_ext_priv		*pmlmeext = &Adapter->mlmeextpriv;
+
+	struct btcoexist_priv	 		*pbtpriv = &(Adapter->halpriv.bt_coexist);
+	//PMGNT_INFO				pMgntInfo = &Adapter->MgntInfo;
+	//PRT_HIGH_THROUGHPUT		pHTInfo = GET_HT_INFO(pMgntInfo);
+	
+	//PRX_TS_RECORD	pRxTs = NULL;
+	u8			BT_gpio_mux;
+
+	BOOLEAN		bWifiConnectChange, bBtStateChange,bRssiStateChange;
+
+	if(pbtpriv->bCOBT == _FALSE)		return;
+	if( (pbtpriv->BT_Coexist) &&((pbtpriv->BT_CoexistType == BT_CSR_BC4) ||(pbtpriv->BT_CoexistType == BT_CSR_BC8)) && (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _FALSE)	)
+	{
+		bWifiConnectChange = BT_WifiConnectChange(Adapter);
+		bBtStateChange	= BT_BTStateChange(Adapter);
+		bRssiStateChange 	= BT_RssiStateChange(Adapter);
+		
+		printk("bWifiConnectChange %d, bBtStateChange  %d,bRssiStateChange  %d\n",
+			bWifiConnectChange,bBtStateChange,bRssiStateChange);
+
+		// add by hpfan for debug message
+		BT_gpio_mux = rtw_read8(Adapter, REG_GPIO_MUXCFG);
+		printk("BTCoexit Reg_0x40 (%2x)\n", BT_gpio_mux);
+
+		if( bWifiConnectChange ||bBtStateChange  ||bRssiStateChange )
+		{
+			if(pbtpriv->BT_CUR_State)
+			{
+				
+				// Do not allow receiving A-MPDU aggregation.
+				if(pbtpriv->BT_Ampdu)// 0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU.
+				{
+			
+					if(pmlmeinfo->assoc_AP_vendor == ciscoAP)	
+					{
+						if(pbtpriv->BT_Service!=BT_Idle)
+						{
+							if(pmlmeinfo->bAcceptAddbaReq)
+							{
+								printk("BT_Disallow AMPDU \n");	
+								pmlmeinfo->bAcceptAddbaReq = _FALSE;
+								send_delba(Adapter,0, get_my_bssid(&(pmlmeinfo->network)));
+							}
+						}
+						else
+						{
+							if(!pmlmeinfo->bAcceptAddbaReq)
+							{
+								printk("BT_Allow AMPDU  RSSI >=40\n");	
+								pmlmeinfo->bAcceptAddbaReq = _TRUE;
+							}
+						}
+					}
+					else
+					{
+						if(!pmlmeinfo->bAcceptAddbaReq)
+						{
+							printk("BT_Allow AMPDU BT Idle\n");	
+							pmlmeinfo->bAcceptAddbaReq = _TRUE;
+						}
+					}
+				}
+				
+#if 0
+				else if((pHalData->bt_coexist.BT_Service==BT_SCO) || (pHalData->bt_coexist.BT_Service==BT_Busy))
+				{				
+					if(pHalData->bt_coexist.BtRssiState & BT_RSSI_STATE_AMDPU_OFF)
+					{
+						if(pMgntInfo->bBT_Ampdu && pHTInfo->bAcceptAddbaReq)
+						{
+							RTPRINT(FBT, BT_TRACE, ("BT_Disallow AMPDU RSSI <=32\n"));	
+							pHTInfo->bAcceptAddbaReq = FALSE;
+							if(GetTs(Adapter, (PTS_COMMON_INFO*)(&pRxTs), pMgntInfo->Bssid, 0, RX_DIR, FALSE))
+								TsInitDelBA(Adapter, (PTS_COMMON_INFO)pRxTs, RX_DIR);
+						}
+					}
+					else
+					{
+						if(pMgntInfo->bBT_Ampdu && !pHTInfo->bAcceptAddbaReq)
+						{
+							RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU  RSSI >=40\n"));	
+							pHTInfo->bAcceptAddbaReq = TRUE;
+						}
+					}
+				}
+				else
+				{
+					if(pMgntInfo->bBT_Ampdu && !pHTInfo->bAcceptAddbaReq)
+					{
+						RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU BT not in SCO or BUSY\n"));	
+						pHTInfo->bAcceptAddbaReq = TRUE;
+					}
+				}
+#endif
+
+				if(pbtpriv->BT_Ant_isolation)
+				{			
+					printk("BT_IsolationLow\n");
+
+// 20100427 Joseph: Do not adjust Rate adaptive for BT coexist suggested by SD3.
+#if 0
+					RTPRINT(FBT, BT_TRACE, ("BT_Update Rate table\n"));
+					if(pMgntInfo->bUseRAMask)
+					{
+						// 20100407 Joseph: Fix rate adaptive modification for BT coexist.
+						// This fix is not complete yet. It shall also consider VWifi and Adhoc case,
+						// which connect with multiple STAs.
+						Adapter->HalFunc.UpdateHalRAMaskHandler(
+												Adapter,
+												FALSE,
+												0,
+												NULL,
+												NULL,
+												pMgntInfo->RateAdaptive.RATRState,
+												RAMask_Normal);
+					}
+					else
+					{
+						Adapter->HalFunc.UpdateHalRATRTableHandler(
+									Adapter, 
+									&pMgntInfo->dot11OperationalRateSet,
+									pMgntInfo->dot11HTOperationalRateSet,NULL);
+					}
+#endif
+
+					// 20100415 Joseph: Modify BT coexist mechanism suggested by Yaying.
+					// Now we only enable HW BT coexist when BT in "Busy" state.
+					if(1)//pMgntInfo->LinkDetectInfo.NumRecvDataInPeriod >= 20)
+					{
+						if((pmlmeinfo->assoc_AP_vendor == ciscoAP)	&&
+							pbtpriv->BT_Service==BT_OtherAction)
+						{
+							printk("BT_Turn ON Coexist\n");
+							rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);	
+						}
+						else
+						{
+							if((pbtpriv->BT_Service==BT_Busy) &&
+								(pbtpriv->BtRssiState & BT_RSSI_STATE_NORMAL_POWER))
+							{
+								printk("BT_Turn ON Coexist\n");
+								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);
+							}
+							else if((pbtpriv->BT_Service==BT_OtherAction) &&
+									(pbtpriv->BtRssiState & BT_RSSI_STATE_SPECIAL_LOW))
+							{
+								printk("BT_Turn ON Coexist\n");
+								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);	
+							}
+							else if(pbtpriv->BT_Service==BT_PAN)
+							{
+								printk("BT_Turn ON Coexist\n");
+								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0x00);	
+							}
+							else
+							{
+								printk("BT_Turn OFF Coexist\n");
+								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0x00);
+							}
+						}
+					}
+					else
+					{
+						printk("BT: There is no Wifi traffic!! Turn off Coexist\n");
+						rtw_write8(Adapter, REG_GPIO_MUXCFG, 0x00);
+					}
+
+					if(1)//pMgntInfo->LinkDetectInfo.NumRecvDataInPeriod >= 20)
+					{
+						if(pbtpriv->BT_Service==BT_PAN)
+						{
+							printk("BT_Turn ON Coexist(Reg0x44 = 0x10100)\n");
+							rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x10100);	
+						}
+						else
+						{
+							printk("BT_Turn OFF Coexist(Reg0x44 = 0x0)\n");
+							rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x0);	
+						}
+					}
+					else
+					{
+						printk("BT: There is no Wifi traffic!! Turn off Coexist(Reg0x44 = 0x0)\n");
+						rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x0);	
+					}
+
+					// 20100430 Joseph: Integrate the BT coexistence EDCA tuning here.
+					if(pbtpriv->BtRssiState & BT_RSSI_STATE_NORMAL_POWER)
+					{
+						if(pbtpriv->BT_Service==BT_OtherBusy)
+						{
+							//pbtpriv->BtEdcaUL = 0x5ea72b;
+							//pbtpriv->BtEdcaDL = 0x5ea72b;
+							pbtpriv->BT_EDCA[UP_LINK] = 0x5ea72b;
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea72b;							
+							
+							printk("BT in BT_OtherBusy state Tx (%d) >350 parameter(0x%x) = 0x%x\n", pbtpriv->Ratio_Tx ,REG_EDCA_BE_PARAM, 0x5ea72b);
+						}
+						else if(pbtpriv->BT_Service==BT_Busy)
+						{
+							//pbtpriv->BtEdcaUL = 0x5eb82f;
+							//pbtpriv->BtEdcaDL = 0x5eb82f;
+
+							pbtpriv->BT_EDCA[UP_LINK] = 0x5eb82f;
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5eb82f;							
+							
+							printk("BT in BT_Busy state parameter(0x%x) = 0x%x\n", REG_EDCA_BE_PARAM, 0x5eb82f);		
+						}
+						else if(pbtpriv->BT_Service==BT_SCO)
+						{
+							if(pbtpriv->Ratio_Tx>160)
+							{
+								//pbtpriv->BtEdcaUL = 0x5ea72f;
+								//pbtpriv->BtEdcaDL = 0x5ea72f;
+								pbtpriv->BT_EDCA[UP_LINK] = 0x5ea72f;
+								pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea72f;							
+								printk("BT in BT_SCO state Tx (%d) >160 parameter(0x%x) = 0x%x\n",pbtpriv->Ratio_Tx, REG_EDCA_BE_PARAM, 0x5ea72f);
+							}
+							else
+							{
+								//pbtpriv->BtEdcaUL = 0x5ea32b;
+								//pbtpriv->BtEdcaDL = 0x5ea42b;
+
+								pbtpriv->BT_EDCA[UP_LINK] = 0x5ea32b;
+								pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea42b;						
+								
+								printk("BT in BT_SCO state Tx (%d) <160 parameter(0x%x) = 0x%x\n", pbtpriv->Ratio_Tx,REG_EDCA_BE_PARAM, 0x5ea32f);
+							}									
+						}
+						else
+						{
+							// BT coexistence mechanism does not control EDCA parameter.
+							//pbtpriv->BtEdcaUL = 0;
+							//pbtpriv->BtEdcaDL = 0;
+
+							pbtpriv->BT_EDCA[UP_LINK] = 0;
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0;							
+							printk("BT in  State  %d  and parameter(0x%x) use original setting.\n",pbtpriv->BT_Service, REG_EDCA_BE_PARAM);
+						}
+
+						if((pbtpriv->BT_Service!=BT_Idle) &&
+							(pmlmeext->cur_wireless_mode  == WIRELESS_MODE_G) &&
+							(pbtpriv->BtRssiState & BT_RSSI_STATE_BG_EDCA_LOW))
+						{
+							//pbtpriv->BtEdcaUL = 0x5eb82b;
+							//pbtpriv->BtEdcaDL = 0x5eb82b;
+
+							pbtpriv->BT_EDCA[UP_LINK] = 0x5eb82b;
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5eb82b;							
+							
+							printk("BT set parameter(0x%x) = 0x%x\n", REG_EDCA_BE_PARAM, 0x5eb82b);		
+						}
+					}
+					else
+					{
+						// BT coexistence mechanism does not control EDCA parameter.
+						//pbtpriv->BtEdcaUL = 0;
+						//pbtpriv->BtEdcaDL = 0;
+
+						pbtpriv->BT_EDCA[UP_LINK] = 0;
+						pbtpriv->BT_EDCA[DOWN_LINK] = 0;					
+					}
+
+					// 20100415 Joseph: Set RF register 0x1E and 0x1F for BT coexist suggested by Yaying.
+					if(pbtpriv->BT_Service!=BT_Idle)
+					{
+						printk("BT Set RfReg0x1E[7:4] = 0x%x \n", 0xf);
+						PHY_SetRFReg(Adapter, PathA, 0x1e, 0xf0, 0xf);
+						//RTPRINT(FBT, BT_TRACE, ("BT Set RfReg0x1E[7:4] = 0x%x \n", 0xf));
+						//PHY_SetRFReg(Adapter, PathA, 0x1f, 0xf0, 0xf);
+					}
+					else
+					{
+						printk("BT Set RfReg0x1E[7:4] = 0x%x \n",pbtpriv->BtRfRegOrigin1E);
+						PHY_SetRFReg(Adapter, PathA, 0x1e, 0xf0, pbtpriv->BtRfRegOrigin1E);
+						//RTPRINT(FBT, BT_TRACE, ("BT Set RfReg0x1F[7:4] = 0x%x \n", pHalData->bt_coexist.BtRfRegOrigin1F));
+						//PHY_SetRFReg(Adapter, PathA, 0x1f, 0xf0, pHalData->bt_coexist.BtRfRegOrigin1F);
+					}	
+				}
+				else
+				{
+					printk("BT_IsolationHigh\n");
+					// Do nothing.
+				}			
+			}
+			else
+			{
+			
+				if(pbtpriv->BT_Ampdu && !pmlmeinfo->bAcceptAddbaReq)
+				{
+					printk("BT_Allow AMPDU bt is off\n");	
+					pmlmeinfo->bAcceptAddbaReq = _TRUE;
+				}
+			
+				printk("BT_Turn OFF Coexist bt is off \n");
+				rtw_write8(Adapter, REG_GPIO_MUXCFG, 0x00);
+
+				printk("BT Set RfReg0x1E[7:4] = 0x%x \n", pbtpriv->BtRfRegOrigin1E);
+				PHY_SetRFReg(Adapter, PathA, 0x1e, 0xf0, pbtpriv->BtRfRegOrigin1E);
+				//RTPRINT(FBT, BT_TRACE, ("BT Set RfReg0x1F[7:4] = 0x%x \n", pHalData->bt_coexist.BtRfRegOrigin1F));
+				//PHY_SetRFReg(Adapter, PathA, 0x1f, 0xf0, pHalData->bt_coexist.BtRfRegOrigin1F);
+
+				// BT coexistence mechanism does not control EDCA parameter since BT is disabled.
+				//pbtpriv->BtEdcaUL = 0;
+				//pbtpriv->BtEdcaDL = 0;
+				pbtpriv->BT_EDCA[UP_LINK] = 0;
+				pbtpriv->BT_EDCA[DOWN_LINK] = 0;				
+				
+
+// 20100427 Joseph: Do not adjust Rate adaptive for BT coexist suggested by SD3.
+#if 0
+				RTPRINT(FBT, BT_TRACE, ("BT_Update Rate table\n"));
+				if(pMgntInfo->bUseRAMask)
+				{
+					// 20100407 Joseph: Fix rate adaptive modification for BT coexist.
+					// This fix is not complete yet. It shall also consider VWifi and Adhoc case,
+					// which connect with multiple STAs.
+					Adapter->HalFunc.UpdateHalRAMaskHandler(
+											Adapter,
+											FALSE,
+											0,
+											NULL,
+											NULL,
+											pMgntInfo->RateAdaptive.RATRState,
+											RAMask_Normal);
+				}
+				else
+				{
+					Adapter->HalFunc.UpdateHalRATRTableHandler(
+								Adapter, 
+								&pMgntInfo->dot11OperationalRateSet,
+								pMgntInfo->dot11HTOperationalRateSet,NULL);
+				}
+#endif
+			}
+		}
+	}
+}
+
+void dm_InitBtCoexistDM(	PADAPTER	Adapter)
+{
+	//HAL_DATA_TYPE* pHalData = GET_HAL_DATA(Adapter);
+	struct btcoexist_priv	 *pbtpriv = &(Adapter->halpriv.bt_coexist);
+
+	if( !pbtpriv->BT_Coexist ) return;
+	
+	pbtpriv->BtRfRegOrigin1E = (u8)PHY_QueryRFReg(Adapter, PathA, 0x1e, 0xf0);
+	pbtpriv->BtRfRegOrigin1F = (u8)PHY_QueryRFReg(Adapter, PathA, 0x1f, 0xf0);
+}
+
+void set_dm_bt_coexist(_adapter *padapter, u8 bStart)
+{
+	struct mlme_ext_info	*pmlmeinfo = &padapter->mlmeextpriv.mlmext_info;
+	struct btcoexist_priv	 *pbtpriv = &(padapter->halpriv.bt_coexist);
+	pbtpriv->bCOBT = bStart;
+	send_delba(padapter,0, get_my_bssid(&(pmlmeinfo->network)));
+	send_delba(padapter,1, get_my_bssid(&(pmlmeinfo->network)));
+	
+}
+
+void issue_delete_ba(_adapter *padapter, u8 dir)
+{
+	struct mlme_ext_info		*pmlmeinfo = &padapter->mlmeextpriv.mlmext_info;
+	printk("issue_delete_ba : %s...\n",(dir==0)?"RX_DIR":"TX_DIR");
+	send_delba(padapter,dir, get_my_bssid(&(pmlmeinfo->network)));
+}
+
+#endif
+//
+// Initialize GPIO setting registers
+//
+void dm_InitGPIOSetting(IN PADAPTER	Adapter)
+{
+	u8	tmp1byte;	
+	
+	tmp1byte =rtw_read8(Adapter, REG_GPIO_MUXCFG);
+	tmp1byte &= (GPIOSEL_GPIO | ~GPIOSEL_ENBT);
+	rtw_write8(Adapter,  REG_GPIO_MUXCFG, tmp1byte);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	dm_CheckRfCtrlGPIO()
+ *
+ * Overview:	Copy 8187B template for 9xseries.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	01/10/2008	MHC		Create Version 0.  
+ *
+ *---------------------------------------------------------------------------*/
+VOID
+dm_CheckRfCtrlGPIO(
+	IN	PADAPTER	Adapter
+	)
+{
+#if 0
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+
+#if ( (HAL_CODE_BASE == RTL8190) || \
+ 	 ((HAL_CODE_BASE == RTL8192) && (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)))
+	//return;
+#endif
+	
+	// Walk around for DTM test, we will not enable HW - radio on/off because r/w
+	// page 1 register before Lextra bus is enabled cause system fails when resuming
+	// from S4. 20080218, Emily
+	if(Adapter->bInHctTest)
+		return;
+
+//#if ((HAL_CODE_BASE == RTL8192_S) )
+	//Adapter->HalFunc.GPIOChangeRFHandler(Adapter, GPIORF_POLLING);
+//#else
+	PlatformScheduleWorkItem( &(pHalData->GPIOChangeRFWorkItem) );
+//#endif
+
+#endif
+}	/* dm_CheckRfCtrlGPIO */
+
+VOID
+dm_InitRateAdaptiveMask(
+	IN	PADAPTER	Adapter	
+	)
+{
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	PRATE_ADAPTIVE	pRA = (PRATE_ADAPTIVE)&pdmpriv->RateAdaptive;
+	
+	pRA->RATRState = DM_RATR_STA_INIT;
+	pRA->PreRATRState = DM_RATR_STA_INIT;
+
+	if (pdmpriv->DM_Type == DM_Type_ByDriver)
+		pdmpriv->bUseRAMask = _TRUE;
+	else
+		pdmpriv->bUseRAMask = _FALSE;	
+}
+
+#if 0
+VOID
+AP_InitRateAdaptiveState(
+	IN	PADAPTER	Adapter	,
+	IN	PRT_WLAN_STA  pEntry
+	)
+{
+	PRATE_ADAPTIVE	pRA = (PRATE_ADAPTIVE)&pEntry->RateAdaptive;
+
+	pRA->RATRState = DM_RATR_STA_INIT;
+	pRA->PreRATRState = DM_RATR_STA_INIT;
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+ * Function:	dm_RefreshRateAdaptiveMask()
+ *
+ * Overview:	Update rate table mask according to rssi
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	05/27/2009	hpfan	Create Version 0.  
+ *
+ *---------------------------------------------------------------------------*/
+VOID
+dm_RefreshRateAdaptiveMask(	IN	PADAPTER	pAdapter)
+{
+#if 0
+	if(pAdapter->bDriverStopped)
+	{
+		RT_TRACE(COMP_RATR, DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
+		return;
+	}
+
+	if(!pMgntInfo->bUseRAMask)
+	{
+		RT_TRACE(COMP_RATR, DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
+		return;
+	}
+
+	// if default port is connected, update RA table for default port (infrastructure mode only)
+	if(pAdapter->MgntInfo.mAssoc && (!ACTING_AS_AP(pAdapter)))
+	{
+		
+		// decide rastate according to rssi
+		switch (pRA->PreRATRState)
+		{
+			case DM_RATR_STA_HIGH:
+				HighRSSIThreshForRA = 50;
+				LowRSSIThreshForRA = 20;
+				break;
+			
+			case DM_RATR_STA_MIDDLE:
+				HighRSSIThreshForRA = 55;
+				LowRSSIThreshForRA = 20;
+				break;
+			
+			case DM_RATR_STA_LOW:
+				HighRSSIThreshForRA = 50;
+				LowRSSIThreshForRA = 25;
+				break;
+
+			default:
+				HighRSSIThreshForRA = 50;
+				LowRSSIThreshForRA = 20;
+				break;
+		}
+
+		if(pHalData->UndecoratedSmoothedPWDB > (s4Byte)HighRSSIThreshForRA)
+			pRA->RATRState = DM_RATR_STA_HIGH;
+		else if(pHalData->UndecoratedSmoothedPWDB > (s4Byte)LowRSSIThreshForRA)
+			pRA->RATRState = DM_RATR_STA_MIDDLE;
+		else
+			pRA->RATRState = DM_RATR_STA_LOW;
+
+		if(pRA->PreRATRState != pRA->RATRState)
+		{
+			RT_PRINT_ADDR(COMP_RATR, DBG_LOUD, ("Target AP addr : "), pMgntInfo->Bssid);
+			RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI = %ld\n", pHalData->UndecoratedSmoothedPWDB));
+			RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI_LEVEL = %d\n", pRA->RATRState));
+			RT_TRACE(COMP_RATR, DBG_LOUD, ("PreState = %d, CurState = %d\n", pRA->PreRATRState, pRA->RATRState));
+			pAdapter->HalFunc.UpdateHalRAMaskHandler(
+									pAdapter,
+									FALSE,
+									0,
+									NULL,
+									NULL,
+									pRA->RATRState,
+									RAMask_Normal);
+			pRA->PreRATRState = pRA->RATRState;
+		}
+	}
+
+	//
+	// The following part configure AP/VWifi/IBSS rate adaptive mask.
+	//
+	if(ACTING_AS_AP(pAdapter) || ACTING_AS_IBSS(pAdapter))
+	{
+		pTargetAdapter = pAdapter;
+	}
+	else
+	{
+		pTargetAdapter = ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, FALSE);
+		if(!ACTING_AS_AP(pTargetAdapter))
+			pTargetAdapter = NULL;
+	}
+
+	// if extension port (softap) is started, updaet RA table for more than one clients associate
+	if(pTargetAdapter != NULL)
+	{
+		int	i;
+		PRT_WLAN_STA	pEntry;
+		PRATE_ADAPTIVE     pEntryRA;
+
+		for(i = 0; i < ASSOCIATE_ENTRY_NUM; i++)
+		{
+			if(	pTargetAdapter->MgntInfo.AsocEntry[i].bUsed && pTargetAdapter->MgntInfo.AsocEntry[i].bAssociated)
+			{
+				pEntry = pTargetAdapter->MgntInfo.AsocEntry+i;
+				pEntryRA = &pEntry->RateAdaptive;
+
+				switch (pEntryRA->PreRATRState)
+				{
+					case DM_RATR_STA_HIGH:
+					{
+						HighRSSIThreshForRA = 50;
+						LowRSSIThreshForRA = 20;
+					}
+					break;
+					
+					case DM_RATR_STA_MIDDLE:
+					{
+						HighRSSIThreshForRA = 55;
+						LowRSSIThreshForRA = 20;
+					}
+					break;
+					
+					case DM_RATR_STA_LOW:
+					{
+						HighRSSIThreshForRA = 50;
+						LowRSSIThreshForRA = 25;
+					}
+					break;
+
+					default:
+					{
+						HighRSSIThreshForRA = 50;
+						LowRSSIThreshForRA = 20;
+					}
+				}
+
+				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB > (s4Byte)HighRSSIThreshForRA)
+					pEntryRA->RATRState = DM_RATR_STA_HIGH;
+				else if(pEntry->rssi_stat.UndecoratedSmoothedPWDB > (s4Byte)LowRSSIThreshForRA)
+					pEntryRA->RATRState = DM_RATR_STA_MIDDLE;
+				else
+					pEntryRA->RATRState = DM_RATR_STA_LOW;
+
+				if(pEntryRA->PreRATRState != pEntryRA->RATRState)
+				{
+					RT_PRINT_ADDR(COMP_RATR, DBG_LOUD, ("AsocEntry addr : "), pEntry->MacAddr);
+					RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI = %ld\n", pEntry->rssi_stat.UndecoratedSmoothedPWDB));
+					RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI_LEVEL = %d\n", pEntryRA->RATRState));
+					RT_TRACE(COMP_RATR, DBG_LOUD, ("PreState = %d, CurState = %d\n", pEntryRA->PreRATRState, pEntryRA->RATRState));
+					pAdapter->HalFunc.UpdateHalRAMaskHandler(
+											pTargetAdapter,
+											FALSE,
+											pEntry->AID+1,
+											pEntry->MacAddr,
+											pEntry,
+											pEntryRA->RATRState,
+											RAMask_Normal);
+					pEntryRA->PreRATRState = pEntryRA->RATRState;
+				}
+
+			}
+		}	
+	}
+#endif	
+}
+
+VOID
+dm_CheckProtection(
+	IN	PADAPTER	Adapter
+	)
+{
+#if 0
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	u1Byte			CurRate, RateThreshold;
+
+	if(pMgntInfo->pHTInfo->bCurBW40MHz)
+		RateThreshold = MGN_MCS1;
+	else
+		RateThreshold = MGN_MCS3;
+
+	if(Adapter->TxStats.CurrentInitTxRate <= RateThreshold)
+	{
+		pMgntInfo->bDmDisableProtect = TRUE;
+		DbgPrint("Forced disable protect: %x\n", Adapter->TxStats.CurrentInitTxRate);
+	}
+	else
+	{
+		pMgntInfo->bDmDisableProtect = FALSE;
+		DbgPrint("Enable protect: %x\n", Adapter->TxStats.CurrentInitTxRate);
+	}
+#endif
+}
+
+VOID
+dm_CheckStatistics(
+	IN	PADAPTER	Adapter
+	)
+{
+#if 0
+	if(!Adapter->MgntInfo.bMediaConnect)
+		return;
+
+	//2008.12.10 tynli Add for getting Current_Tx_Rate_Reg flexibly.
+	Adapter->HalFunc.GetHwRegHandler( Adapter, HW_VAR_INIT_TX_RATE, (pu1Byte)(&Adapter->TxStats.CurrentInitTxRate) );
+
+	// Calculate current Tx Rate(Successful transmited!!)
+
+	// Calculate current Rx Rate(Successful received!!)
+	
+	//for tx tx retry count
+	Adapter->HalFunc.GetHwRegHandler( Adapter, HW_VAR_RETRY_COUNT, (pu1Byte)(&Adapter->TxStats.NumTxRetryCount) );
+#endif	
+}
+
+void dm_CheckPbcGPIO(_adapter *padapter)
+{	
+	u8 tmp1byte;
+
+	tmp1byte = rtw_read8(padapter, GPIO_IO_SEL);
+	tmp1byte |= (HAL_8192C_HW_GPIO_WPS_BIT);
+	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	//enable GPIO[2] as output mode
+
+	tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
+	rtw_write8(padapter,  GPIO_IN, tmp1byte);		//reset the floating voltage level
+
+	tmp1byte = rtw_read8(padapter, GPIO_IO_SEL);
+	tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
+	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	//enable GPIO[2] as input mode
+
+	tmp1byte =rtw_read8(padapter, GPIO_IN);
+	
+	if (tmp1byte == 0xff)
+		return ;
+
+	if (tmp1byte&HAL_8192C_HW_GPIO_WPS_BIT)
+	{
+		
+                // Here we only set bPbcPressed to true
+                // After trigger PBC, the variable will be set to false		
+                printk("CheckPbcGPIO - PBC is pressed (%x)\n",tmp1byte);
+                
+                if ( padapter->pid == 0 )
+                {	//	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver.
+			return;
+                }
+#ifdef RTK_DMP_PLATFORM
+		kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_NET_PBC);
+		//kobject_hotplug(&dev->class_dev.kobj, KOBJ_NET_PBC);
+#else
+
+#ifdef PLATFORM_LINUX
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		   kill_pid(find_vpid(padapter->pid), SIGUSR1, 1);
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,26))
+		   kill_proc(padapter->pid, SIGUSR1, 1);
+#endif
+
+#endif
+
+#endif
+        }
+
+}
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+// Add new function to reset the state of antenna diversity before link.
+u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
+{
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	SWAT_T *pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+	
+	// Condition that does not need to use antenna diversity.
+	if(IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))
+	{
+		//printk("SwAntDivBeforeLink8192C(): No AntDiv Mechanism.\n");
+		return _FALSE;
+	}
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	
+	{
+		pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		return _FALSE;
+	}
+	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
+/*	
+	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
+	{
+	
+	
+		RT_TRACE(COMP_SWAS, DBG_LOUD, 
+				("SwAntDivCheckBeforeLink8192C(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
+				pMgntInfo->RFChangeInProgress,
+				pHalData->eRFPowerState));
+	
+		pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		
+		return FALSE;
+	}
+*/	
+	
+	if(pDM_SWAT_Table->SWAS_NoLink_State == 0){
+		//switch channel
+		pDM_SWAT_Table->SWAS_NoLink_State = 1;
+		pDM_SWAT_Table->CurAntenna = (pDM_SWAT_Table->CurAntenna==Antenna_A)?Antenna_B:Antenna_A;
+	
+		//PHY_SetRFPath(Adapter,pDM_SWAT_Table->CurAntenna);		
+		
+		antenna_select_cmd(Adapter, pDM_SWAT_Table->CurAntenna, 0);
+		printk("%s change antenna to ANT_( %s ).....\n",__FUNCTION__,(GET_HAL_DATA(Adapter)->CurAntenna==Antenna_A)?"A":"B");		
+		return _TRUE;
+	}
+	else
+	{
+		pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		return _FALSE;
+	}
+		
+
+
+}
+
+
+//
+// 20100514 Luke/Joseph:
+// Add new function to reset antenna diversity state after link.
+//
+void
+SwAntDivRestAfterLink(
+	IN	PADAPTER	Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	SWAT_T	*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
+	if(IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))	
+		return;
+	printk("======>   SwAntDivRestAfterLink <========== \n");
+	pHalData->RSSI_cnt_A= 0;
+	pHalData->RSSI_cnt_B= 0;
+	pHalData->RSSI_test = _FALSE;
+	
+	pDM_SWAT_Table->try_flag = 0xff;
+	pDM_SWAT_Table->RSSI_Trying = 0;	
+	pDM_SWAT_Table->SelectAntennaMap=0xAA;
+    	pDM_SWAT_Table->CurAntenna = pHalData->CurAntenna;
+    	pDM_SWAT_Table->PreAntenna = pHalData->CurAntenna;
+		
+	pdmpriv->lastTxOkCnt=0;
+	pdmpriv->lastRxOkCnt=0;
+
+	pdmpriv->TXByteCnt_A=0;
+	pdmpriv->TXByteCnt_B=0;
+	pdmpriv->RXByteCnt_A=0;
+	pdmpriv->RXByteCnt_B=0;
+	pdmpriv->DoubleComfirm=0;	
+	pdmpriv->TrafficLoad = TRAFFIC_LOW;
+	
+}
+
+
+//
+// 20100514 Luke/Joseph:
+// Add new function for antenna diversity after link.
+// This is the main function of antenna diversity after link.
+// This function is called in HalDmWatchDog() and dm_SW_AntennaSwitchCallback().
+// HalDmWatchDog() calls this function with SWAW_STEP_PEAK to initialize the antenna test.
+// In SWAW_STEP_PEAK, another antenna and a 500ms timer will be set for testing.
+// After 500ms, dm_SW_AntennaSwitchCallback() calls this function to compare the signal just
+// listened on the air with the RSSI of original antenna.
+// It chooses the antenna with better RSSI.
+// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting 
+// penalty to get next try.
+//
+VOID
+dm_SW_AntennaSwitch(
+	PADAPTER		Adapter,
+	u8			Step
+)
+{
+	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	SWAT_T	*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
+	s32			curRSSI=100, RSSI_A, RSSI_B;
+	u64			curTxOkCnt, curRxOkCnt;
+	u64			CurByteCnt, PreByteCnt;	
+	u8			nextAntenna;
+	u8			Score_A=0, Score_B=0;
+	u8			i;
+
+	// Condition that does not need to use antenna diversity.
+	if(IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))
+	{
+		//RT_TRACE(COMP_SWAS, DBG_LOUD, ("dm_SW_AntennaSwitch(): No AntDiv Mechanism.\n"));
+		return;
+	}
+
+	
+	if (check_fwstate(&Adapter->mlmepriv, _FW_LINKED)	==_FALSE)
+		return;
+#if 0 //to do
+	// Radio off: Status reset to default and return.
+	if(pHalData->eRFPowerState==eRfOff)
+	{
+		SwAntDivRestAfterLink(Adapter);
+		return;
+	}
+#endif
+	//printk("\n............................ %s.........................\n",__FUNCTION__);
+	// Handling step mismatch condition.
+	// Peak step is not finished at last time. Recover the variable and check again.
+	if( Step != pDM_SWAT_Table->try_flag	)
+	{
+		SwAntDivRestAfterLink(Adapter);
+	}
+
+
+	if(pDM_SWAT_Table->try_flag == 0xff)
+	{
+#if 0
+		// Select RSSI checking target
+		if(pMgntInfo->mAssoc && !ACTING_AS_AP(Adapter))
+		{
+			// Target: Infrastructure mode AP.
+			pHalData->RSSI_target = NULL;
+			RT_TRACE(COMP_SWAS, DBG_LOUD, ("dm_SW_AntennaSwitch(): RSSI_target is DEF AP!\n"));
+		}
+		else
+		{
+			u1Byte			index = 0;
+			PRT_WLAN_STA	pEntry = NULL;
+			PADAPTER		pTargetAdapter = NULL;
+		
+			if(	pMgntInfo->mIbss || ACTING_AS_AP(Adapter) )
+			{
+				// Target: AP/IBSS peer.
+				pTargetAdapter = Adapter;
+			}
+			else if(ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)))
+			{
+				// Target: VWIFI peer.
+				pTargetAdapter = ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE);
+			}
+
+			if(pTargetAdapter != NULL)
+			{
+				for(index=0; index<ASSOCIATE_ENTRY_NUM; index++)
+				{
+					pEntry = AsocEntry_EnumStation(pTargetAdapter, index);
+					if(pEntry != NULL)
+					{
+						if(pEntry->bAssociated)
+							break;			
+					}
+				}
+			}
+
+			if(pEntry == NULL)
+			{
+				SwAntDivRestAfterLink(Adapter);
+				RT_TRACE(COMP_SWAS, DBG_LOUD, ("dm_SW_AntennaSwitch(): No Link.\n"));
+				return;
+			}
+			else
+			{
+				pHalData->RSSI_target = pEntry;
+				RT_TRACE(COMP_SWAS, DBG_LOUD, ("dm_SW_AntennaSwitch(): RSSI_target is PEER STA\n"));
+			}
+		}
+				
+			
+#endif
+		
+		pHalData->RSSI_cnt_A= 0;
+		pHalData->RSSI_cnt_B= 0;
+		pDM_SWAT_Table->try_flag = 0;
+		//printk("dm_SW_AntennaSwitch(): Set try_flag to 0 prepare for peak!\n");
+		return;
+	}
+	else
+	{		
+		curTxOkCnt = Adapter->xmitpriv.tx_bytes - pdmpriv->lastTxOkCnt;
+		curRxOkCnt = Adapter->recvpriv.rx_bytes - pdmpriv->lastRxOkCnt;
+	
+		pdmpriv->lastTxOkCnt = Adapter->xmitpriv.tx_bytes ;
+		pdmpriv->lastRxOkCnt = Adapter->recvpriv.rx_bytes ;
+	
+		if(pDM_SWAT_Table->try_flag == 1)
+		{
+			if(pDM_SWAT_Table->CurAntenna == Antenna_A)
+			{
+				pdmpriv->TXByteCnt_A += curTxOkCnt;
+				pdmpriv->RXByteCnt_A += curRxOkCnt;
+				//printk("#####  TXByteCnt_A(%lld) , RXByteCnt_A(%lld) ####\n",pdmpriv->TXByteCnt_A,pdmpriv->RXByteCnt_A);
+			}
+			else
+			{
+				pdmpriv->TXByteCnt_B += curTxOkCnt;
+				pdmpriv->RXByteCnt_B += curRxOkCnt;
+				//printk("#####  TXByteCnt_B(%lld) , RXByteCnt_B(%lld) ####\n",pdmpriv->TXByteCnt_B,pdmpriv->RXByteCnt_B);
+			}
+		
+			nextAntenna = (pDM_SWAT_Table->CurAntenna == Antenna_A)? Antenna_B : Antenna_A;
+			pDM_SWAT_Table->RSSI_Trying--;
+			//printk("RSSI_Trying = %d\n",pDM_SWAT_Table->RSSI_Trying);
+			
+			if(pDM_SWAT_Table->RSSI_Trying == 0)
+			{
+				CurByteCnt = (pDM_SWAT_Table->CurAntenna == Antenna_A)? (pdmpriv->TXByteCnt_A+pdmpriv->RXByteCnt_A) : (pdmpriv->TXByteCnt_B+pdmpriv->RXByteCnt_B);
+				PreByteCnt = (pDM_SWAT_Table->CurAntenna == Antenna_A)? (pdmpriv->TXByteCnt_B+pdmpriv->RXByteCnt_B) : (pdmpriv->TXByteCnt_A+pdmpriv->RXByteCnt_A);
+
+				//printk("CurByteCnt = %lld\n", CurByteCnt);
+				//printk("PreByteCnt = %lld\n",PreByteCnt);		
+				
+				if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)
+				{
+					PreByteCnt = PreByteCnt*9;	//normalize:Cur=90ms:Pre=10ms					
+				}
+				else if(pdmpriv->TrafficLoad == TRAFFIC_LOW)
+				{					
+					//CurByteCnt = CurByteCnt/2;
+					CurByteCnt = CurByteCnt>>1;//normalize:100ms:50ms					
+				}
+
+
+				//printk("After DIV=>CurByteCnt = %lld\n", CurByteCnt);
+				//printk("PreByteCnt = %lld\n",PreByteCnt);		
+
+				if(pHalData->RSSI_cnt_A > 0)
+					RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
+				else
+					RSSI_A = 0;
+				if(pHalData->RSSI_cnt_B > 0)
+					RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
+				else
+					RSSI_B = 0;
+				
+				curRSSI = (pDM_SWAT_Table->CurAntenna == Antenna_A)? RSSI_A : RSSI_B;
+				pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->CurAntenna == Antenna_A)? RSSI_B : RSSI_A;
+				//printk("Luke:PreRSSI = %d, CurRSSI = %d\n",pDM_SWAT_Table->PreRSSI, curRSSI);
+				//printk("SWAS: preAntenna= %s, curAntenna= %s \n", 
+				//(pDM_SWAT_Table->PreAntenna == Antenna_A?"A":"B"), (pDM_SWAT_Table->CurAntenna == Antenna_A?"A":"B"));
+				//printk("Luke:RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
+					//RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B);
+			}
+
+		}
+		else
+		{
+		
+			if(pHalData->RSSI_cnt_A > 0)
+				RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
+			else
+				RSSI_A = 0;
+			if(pHalData->RSSI_cnt_B > 0)
+				RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
+			else
+				RSSI_B = 0;
+			curRSSI = (pDM_SWAT_Table->CurAntenna == Antenna_A)? RSSI_A : RSSI_B;
+			pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->PreAntenna == Antenna_A)? RSSI_A : RSSI_B;
+			//printk("Ekul:PreRSSI = %d, CurRSSI = %d\n", pDM_SWAT_Table->PreRSSI, curRSSI);
+			//printk("SWAS: preAntenna= %s, curAntenna= %s \n", 
+			//(pDM_SWAT_Table->PreAntenna == Antenna_A?"A":"B"), (pDM_SWAT_Table->CurAntenna == Antenna_A?"A":"B"));
+
+			//printk("Ekul:RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
+			//	RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B);
+			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Ekul:curTxOkCnt = %d\n", curTxOkCnt));
+			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Ekul:curRxOkCnt = %d\n", curRxOkCnt));
+		}
+
+		//1 Trying State
+		if((pDM_SWAT_Table->try_flag == 1)&&(pDM_SWAT_Table->RSSI_Trying == 0))
+		{
+
+			if(pDM_SWAT_Table->TestMode == TP_MODE)
+			{
+				printk("SWAS: TestMode = TP_MODE\n");
+				//printk("TRY:CurByteCnt = %lld\n", CurByteCnt);
+				//printk("TRY:PreByteCnt = %lld\n",PreByteCnt);		
+				if(CurByteCnt < PreByteCnt)
+				{
+					if(pDM_SWAT_Table->CurAntenna == Antenna_A)
+						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
+					else
+						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
+				}
+				else
+				{
+					if(pDM_SWAT_Table->CurAntenna == Antenna_A)
+						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
+					else
+						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
+				}
+				for (i= 0; i<8; i++)
+				{
+					if(((pDM_SWAT_Table->SelectAntennaMap>>i)&BIT0) == 1)
+						Score_A++;
+					else
+						Score_B++;
+				}
+				//printk("SelectAntennaMap=%x\n ",pDM_SWAT_Table->SelectAntennaMap);
+				//printk("Score_A=%d, Score_B=%d\n", Score_A, Score_B);
+				
+				if(pDM_SWAT_Table->CurAntenna == Antenna_A)
+				{
+					nextAntenna = (Score_A > Score_B)?Antenna_A:Antenna_B;
+				}
+				else
+				{
+					nextAntenna = (Score_B > Score_A)?Antenna_B:Antenna_A;
+				}
+				//RT_TRACE(COMP_SWAS, DBG_LOUD, ("nextAntenna=%s\n",(nextAntenna==Antenna_A)?"A":"B"));
+				//RT_TRACE(COMP_SWAS, DBG_LOUD, ("preAntenna= %s, curAntenna= %s \n", 
+					//(DM_SWAT_Table.PreAntenna == Antenna_A?"A":"B"), (DM_SWAT_Table.CurAntenna == Antenna_A?"A":"B")));
+
+				if(nextAntenna != pDM_SWAT_Table->CurAntenna)
+				{
+					printk("SWAS: Switch back to another antenna\n");
+				}
+				else
+				{
+					printk("SWAS: current anntena is good\n");
+				}	
+			}
+
+			if(pDM_SWAT_Table->TestMode == RSSI_MODE)
+			{	
+				printk("SWAS: TestMode = RSSI_MODE\n");
+				pDM_SWAT_Table->SelectAntennaMap=0xAA;
+				if(curRSSI < pDM_SWAT_Table->PreRSSI) //Current antenna is worse than previous antenna
+				{
+					printk("SWAS: Switch back to another antenna\n");
+					nextAntenna = (pDM_SWAT_Table->CurAntenna == Antenna_A)? Antenna_B : Antenna_A;
+				}
+				else // current anntena is good
+				{
+					nextAntenna = pDM_SWAT_Table->CurAntenna;
+					//printk("SWAS: current anntena is good\n");
+				}
+			}
+			pDM_SWAT_Table->try_flag = 0;
+			pHalData->RSSI_test = _FALSE;
+			pHalData->RSSI_sum_A = 0;
+			pHalData->RSSI_cnt_A = 0;
+			pHalData->RSSI_sum_B = 0;
+			pHalData->RSSI_cnt_B = 0;
+			pdmpriv->TXByteCnt_A = 0;
+			pdmpriv->TXByteCnt_B = 0;
+			pdmpriv->RXByteCnt_A = 0;
+			pdmpriv->RXByteCnt_B = 0;
+			
+		}
+
+		//1 Normal State
+		else if(pDM_SWAT_Table->try_flag == 0)
+		{
+			if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)
+			{
+				if(((curTxOkCnt+curRxOkCnt)>>1) > 1875000)
+					pdmpriv->TrafficLoad = TRAFFIC_HIGH;
+				else
+					pdmpriv->TrafficLoad = TRAFFIC_LOW;
+			}
+			else if(pdmpriv->TrafficLoad == TRAFFIC_LOW)
+				{
+				if(((curTxOkCnt+curRxOkCnt)>>1) > 1875000)
+					pdmpriv->TrafficLoad = TRAFFIC_HIGH;
+				else
+					pdmpriv->TrafficLoad = TRAFFIC_LOW;
+			}
+			if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)
+				pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
+			//printk("Normal:TrafficLoad = %lld\n", curTxOkCnt+curRxOkCnt);
+
+			//Prepare To Try Antenna		
+			nextAntenna = (pDM_SWAT_Table->CurAntenna == Antenna_A)? Antenna_B : Antenna_A;
+			pDM_SWAT_Table->try_flag = 1;
+			pHalData->RSSI_test = _TRUE;
+			if((curRxOkCnt+curTxOkCnt) > 1000)
+			{
+				pDM_SWAT_Table->RSSI_Trying = 4;
+				pDM_SWAT_Table->TestMode = TP_MODE;
+			}
+			else
+			{
+				pDM_SWAT_Table->RSSI_Trying = 2;
+				pDM_SWAT_Table->TestMode = RSSI_MODE;
+
+			}
+			//printk("SWAS: Normal State -> Begin Trying! TestMode=%s\n",(pDM_SWAT_Table->TestMode == TP_MODE)?"TP":"RSSI");
+			
+			
+			pHalData->RSSI_sum_A = 0;
+			pHalData->RSSI_cnt_A = 0;
+			pHalData->RSSI_sum_B = 0;
+			pHalData->RSSI_cnt_B = 0;
+		}
+	}
+
+	//1 4.Change TRX antenna
+	if(nextAntenna != pDM_SWAT_Table->CurAntenna)
+	{
+		printk("@@@@@@@@ SWAS: Change TX Antenna!\n ");		
+		antenna_select_cmd(Adapter, nextAntenna, 1);
+	}
+
+	//1 5.Reset Statistics
+	pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+	pDM_SWAT_Table->CurAntenna = nextAntenna;
+	pDM_SWAT_Table->PreRSSI = curRSSI;
+	
+
+	//1 6.Set next timer
+
+	if(pDM_SWAT_Table->RSSI_Trying == 0)
+		return;
+
+	if(pDM_SWAT_Table->RSSI_Trying%2 == 0)
+	{
+		if(pDM_SWAT_Table->TestMode == TP_MODE)
+		{
+			if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)
+			{
+				_set_timer(&pdmpriv->SwAntennaSwitchTimer,10 ); //ms
+				//printk("dm_SW_AntennaSwitch(): Test another antenna for 10 ms\n");
+			}
+			else if(pdmpriv->TrafficLoad == TRAFFIC_LOW)
+			{
+				_set_timer(&pdmpriv->SwAntennaSwitchTimer, 50 ); //ms
+				//printk("dm_SW_AntennaSwitch(): Test another antenna for 50 ms\n");
+			}
+		}
+		else
+		{
+			_set_timer(&pdmpriv->SwAntennaSwitchTimer, 500 ); //ms
+			//printk("dm_SW_AntennaSwitch(): Test another antenna for 500 ms\n");
+		}
+	}
+	else
+	{
+		if(pDM_SWAT_Table->TestMode == TP_MODE)
+		{
+			if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)			
+				_set_timer(&pdmpriv->SwAntennaSwitchTimer,90 ); //ms			
+			else if(pdmpriv->TrafficLoad == TRAFFIC_LOW)
+				_set_timer(&pdmpriv->SwAntennaSwitchTimer,100 ); //ms
+		}
+		else
+		{
+			_set_timer(&pdmpriv->SwAntennaSwitchTimer,500 ); //ms
+			//printk("dm_SW_AntennaSwitch(): Test another antenna for 500 ms\n");
+		}
+	}
+
+//	RT_TRACE(COMP_SWAS, DBG_LOUD, ("SWAS: -----The End-----\n "));
+}
+
+//
+// 20100514 Luke/Joseph:
+// Callback function for 500ms antenna test trying.
+//
+void dm_SW_AntennaSwitchCallback(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+
+	if(padapter->net_closed == _TRUE)
+			return;
+	// Only 
+	dm_SW_AntennaSwitch(padapter, SWAW_STEP_DETERMINE);
+}
+
+
+//
+// 20100722
+// This function is used to gather the RSSI information for antenna testing.
+// It selects the RSSI of the peer STA that we want to know.
+//
+void SwAntDivRSSICheck(_adapter *padapter ,u32 RxPWDBAll)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);	
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+	struct dm_priv *pdmpriv = &padapter->dmpriv;
+	SWAT_T	*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
+
+	if(IS_92C_SERIAL(pHalData->VersionID) ||pHalData->AntDivCfg==0)
+		return;
+	
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)		
+	{			
+		if(pDM_SWAT_Table->CurAntenna == Antenna_A)
+		{			
+			pHalData->RSSI_sum_A += RxPWDBAll;
+			pHalData->RSSI_cnt_A++;
+		}
+		else
+		{
+			pHalData->RSSI_sum_B+= RxPWDBAll;
+			pHalData->RSSI_cnt_B++;
+		
+		}
+		//printk("%s Ant_(%s),RSSI_sum(%d),RSSI_cnt(%d)\n",__FUNCTION__,(2==pHalData->CurAntenna)?"A":"B",pHalData->RSSI_sum,pHalData->RSSI_cnt);
+	}
+	
+}
+
+
+VOID
+dm_SW_AntennaSwitchInit(
+	IN	PADAPTER	Adapter
+	)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	SWAT_T	*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
+	
+	pHalData->RSSI_sum_A = 0;	
+	pHalData->RSSI_sum_B = 0;
+	pHalData->RSSI_cnt_A = 0;
+	pHalData->RSSI_cnt_B = 0;
+	
+	pDM_SWAT_Table->CurAntenna = pHalData->CurAntenna;
+	pDM_SWAT_Table->PreAntenna = pHalData->CurAntenna;
+	pDM_SWAT_Table->try_flag = 0xff;
+	pDM_SWAT_Table->PreRSSI = 0;
+	pDM_SWAT_Table->bTriggerAntennaSwitch = 0;	
+	pDM_SWAT_Table->SelectAntennaMap=0xAA;
+	
+	// Move the timer initialization to InitializeVariables function.
+	//PlatformInitializeTimer(Adapter, &pMgntInfo->SwAntennaSwitchTimer, (RT_TIMER_CALL_BACK)dm_SW_AntennaSwitchCallback, NULL, "SwAntennaSwitchTimer");	
+}
+
+#endif
+//============================================================
+// functions
+//============================================================
+
+void init_dm_priv(_adapter *padapter)
+{
+	struct dm_priv *pdmpriv = &padapter->dmpriv;
+	_rtw_memset(pdmpriv, 0, sizeof(struct dm_priv));
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	_init_timer(&(pdmpriv->SwAntennaSwitchTimer),  padapter->pnetdev , dm_SW_AntennaSwitchCallback, padapter);
+#endif
+}
+
+void
+rtl8192c_InitHalDm(
+	IN	PADAPTER	Adapter
+	)
+{
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	pdmpriv->DM_Type = DM_Type_ByDriver;	
+	pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
+	pdmpriv->UndecoratedSmoothedPWDB = (-1);
+	
+	//.1 DIG INIT
+	pdmpriv->bDMInitialGainEnable = _TRUE;
+	pdmpriv->DMFlag |= DYNAMIC_FUNC_DIG;
+	dm_DIGInit(Adapter);
+
+	//.2 DynamicTxPower INIT
+	pdmpriv->DMFlag |= DYNAMIC_FUNC_HP;
+	dm_InitDynamicTxPower(Adapter);
+
+	//.3
+	//DM_InitEdcaTurbo(Adapter);//moved to  linked_status_chk()
+
+	//.4 RateAdaptive INIT
+	dm_InitRateAdaptiveMask(Adapter);
+
+
+	//.5 Tx Power Tracking Init.
+	pdmpriv->DMFlag |= DYNAMIC_FUNC_SS;
+	DM_InitializeTXPowerTracking(Adapter);
+
+#if DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE
+	dm_InitGPIOSetting(Adapter);
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+	pdmpriv->DMFlag |= DYNAMIC_FUNC_BT;
+	dm_InitBtCoexistDM(Adapter);
+#endif
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	dm_SW_AntennaSwitchInit(Adapter);
+#endif
+
+	pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
+
+
+//..............static variable init.......................
+	pdmpriv->initial_gain_Multi_STA_binitialized = _FALSE;
+	pdmpriv->TM_Trigger = 0;
+	pdmpriv->BT_ServiceTypeCnt = 0;
+	pdmpriv->BT_LastServiceType = BT_Idle;
+	pdmpriv->BT_bMediaConnect = _FALSE;
+	
+}
+
+VOID
+rtl8192c_HalDmWatchDog(
+	IN	PADAPTER	Adapter
+	)
+{
+	BOOLEAN		bFwCurrentInPSMode = _FALSE;
+	BOOLEAN		bFwPSAwake = _TRUE;
+
+#ifdef CONFIG_LPS
+	bFwCurrentInPSMode = Adapter->pwrctrlpriv.bFwCurrentInPSMode;
+	bFwPSAwake = FWLPS_RF_ON(Adapter);
+#endif
+
+
+	// Stop dynamic mechanism if RF is OFF.	
+	//if(rfState == eRfOn)
+	if( (Adapter->hw_init_completed == _TRUE) 
+		&& ((!bFwCurrentInPSMode) && bFwPSAwake)
+#ifdef CONFIG_IPS
+		&& (rf_on == Adapter->pwrctrlpriv.current_rfpwrstate)
+#endif
+	)
+	{
+
+//printk(".......%s.....\n",__FUNCTION__);
+		//
+		// Calculate Tx/Rx statistics.
+		//
+		dm_CheckStatistics(Adapter);
+
+		//
+		// For PWDB monitor and record some value for later use.
+		//
+		PWDB_Monitor(Adapter);
+		
+		//
+		// Dynamic Initial Gain mechanism.
+		//
+		dm_DIG(Adapter);
+		dm_FalseAlarmCounterStatistics(Adapter);
+		//
+		// Dynamic Tx Power mechanism.
+		//
+		dm_DynamicTxPower(Adapter);
+
+		//
+		// Tx Power Tracking.
+		//
+		dm_CheckTXPowerTracking(Adapter);
+
+		//
+		// Rate Adaptive by Rx Signal Strength mechanism.
+		//
+		dm_RefreshRateAdaptiveMask(Adapter);
+
+#ifdef CONFIG_BT_COEXIST
+		//BT-Coexist
+		dm_BTCoexist(Adapter);
+#endif
+
+		// EDCA turbo		
+		dm_CheckEdcaTurbo(Adapter);
+
+		//
+		// Dynamically switch RTS/CTS protection.
+		//
+		//dm_CheckProtection(Adapter);
+		
+#if DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE	
+		dm_CheckPbcGPIO(Adapter);				// Add by hpfan 2008-03-11	
+#endif
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+		//
+		// Software Antenna diversity
+		//
+		dm_SW_AntennaSwitch(Adapter, SWAW_STEP_PEAK);
+#endif
+
+		
+	}
+
+#if 0
+	// Check GPIO to determine current RF on/off and Pbc status.
+	// Not enable for 92CU now!!!
+#if 0// DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE
+	if(Adapter->HalFunc.GetInterfaceSelectionHandler(Adapter)==INTF_SEL1_MINICARD)
+
+	{
+#endif
+		// Check Hardware Radio ON/OFF or not	
+		if(Adapter->MgntInfo.PowerSaveControl.bGpioRfSw)
+		{
+			RTPRINT(FPWR, PWRHW, ("dm_CheckRfCtrlGPIO \n"));
+			dm_CheckRfCtrlGPIO(Adapter);
+		}
+#if 0//DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE
+	}
+	else if(Adapter->HalFunc.GetInterfaceSelectionHandler(Adapter)==INTF_SEL0_USB)
+	{
+		dm_CheckPbcGPIO(Adapter);				// Add by hpfan 2008-03-11
+	}
+#endif
+#endif
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,6217 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+
+     (c) Copyright 2008, RealTEK Technologies Inc. All Rights Reserved.
+
+ Module:	hal8192sphy.c	
+
+ Note:		Merge 92SE/SU PHY config as below
+			1. BB register R/W API
+ 			2. RF register R/W API
+ 			3. Initial BB/RF/MAC config by reading BB/MAC/RF txt.
+ 			3. Power setting API
+ 			4. Channel switch API
+ 			5. Initial gain switch API.
+ 			6. Other BB/MAC/RF API.
+ 			
+ Function:	PHY: Extern function, phy: local function
+ 		 
+ Export:	PHY_FunctionName
+
+ Abbrev:	NONE
+
+ History:
+	Data		Who		Remark	
+	08/08/2008  MHC    	1. Port from 9x series phycfg.c
+						2. Reorganize code arch and ad description.
+						3. Collect similar function.
+						4. Seperate extern/local API.
+	08/12/2008	MHC		We must merge or move USB PHY relative function later.
+	10/07/2008	MHC		Add IQ calibration for PHY.(Only 1T2R mode now!!!)
+	11/06/2008	MHC		Add TX Power index PG file to config in 0xExx register
+						area to map with EEPROM/EFUSE tx pwr index.
+	
+******************************************************************************/
+#define _HAL_8192C_PHYCFG_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_byteorder.h>
+
+#include <hal_init.h>
+
+#include "Hal8192CPhyReg.h"
+#include "Hal8192CPhyCfg.h"
+#include "HalRf.h"
+
+
+/*---------------------------Define Local Constant---------------------------*/
+/* Channel switch:The size of command tables for switch channel*/
+#define MAX_PRECMD_CNT 16
+#define MAX_RFDEPENDCMD_CNT 16
+#define MAX_POSTCMD_CNT 16
+
+#define MAX_DOZE_WAITING_TIMES_9x 64
+
+/*---------------------------Define Local Constant---------------------------*/
+
+
+/*------------------------Define global variable-----------------------------*/
+
+/*------------------------Define local variable------------------------------*/
+
+
+/*--------------------Define export function prototype-----------------------*/
+// Please refer to header file
+/*--------------------Define export function prototype-----------------------*/
+
+
+/*---------------------Define local function prototype-----------------------*/
+/* RF serial read/write by firmware 3wire. */
+static	u32	phy_FwRFSerialRead(	IN	PADAPTER			Adapter,
+									IN	RF90_RADIO_PATH_E	eRFPath,
+									IN	u32				Offset	);
+static	void	phy_FwRFSerialWrite(	IN	PADAPTER			Adapter,
+										IN	RF90_RADIO_PATH_E	eRFPath,
+										IN	u32				Offset,
+										IN	u32				Data	);
+
+/* RF serial read/write */
+static	u32	phy_RFSerialRead(	IN	PADAPTER			Adapter,
+									IN	RF90_RADIO_PATH_E	eRFPath,
+									IN	u32				Offset	);
+static	void	phy_RFSerialWrite(	IN	PADAPTER			Adapter,
+									IN	RF90_RADIO_PATH_E	eRFPath,
+									IN	u32				Offset,
+									IN	u32				Data	);
+
+static	u32	phy_CalculateBitShift(u32 BitMask	);
+
+// Initialize relative setting
+static	int	phy_BB8190_Config_HardCode(IN	PADAPTER	Adapter	);
+static	int	phy_BB8192C_Config_ParaFile(IN	PADAPTER	Adapter	);
+
+/* MAC config */
+static	int	phy_ConfigMACWithParaFile(	IN	PADAPTER	Adapter,
+												IN	u8* 	pFileName);
+static	int	phy_ConfigMACWithHeaderFile(IN	PADAPTER		Adapter);
+/* BB config */
+static	int	phy_ConfigBBWithParaFile(	IN	PADAPTER	Adapter,
+												IN	u8* 	pFileName);
+static	int	phy_ConfigBBWithHeaderFile(	IN	PADAPTER	Adapter,
+												IN	u8 		ConfigType);
+static	int	phy_ConfigBBWithPgParaFile(	IN	PADAPTER	Adapter,
+												IN	u8* 	pFileName);
+static	int	phy_ConfigBBWithPgHeaderFile(	
+												IN	PADAPTER	Adapter,
+												IN	u8 		ConfigType);
+static	int	phy_SetBBtoDiffRFWithParaFile(	
+												IN	PADAPTER	Adapter,
+												IN	u8* 		pFileName);
+static	int	phy_SetBBtoDiffRFWithHeaderFile(	
+												IN	PADAPTER	Adapter,
+												IN	u8 		ConfigType);
+/*Initialize Register definition*/
+static	void	phy_InitBBRFRegisterDefinition(	IN	PADAPTER		Adapter	);
+
+/* Channel switch related */
+#if 0
+static	BOOLEAN	phy_SetSwChnlCmdArray(	SwChnlCmd*		CmdTable,
+										u4Byte			CmdTableIdx,
+										u4Byte			CmdTableSz,
+										SwChnlCmdID		CmdID,
+										u4Byte			Para1,
+										u4Byte			Para2,
+										u4Byte			msDelay	);
+static	BOOLEAN	phy_SwChnlStepByStep(	IN	PADAPTER	Adapter,
+										IN	u1Byte		channel,
+										IN	u1Byte		*stage,
+										IN	u1Byte		*step,
+										OUT u4Byte		*delay	);
+#endif
+// We should not call this function directly
+static	void	phy_FinishSwChnlNow(	IN	PADAPTER	Adapter,
+										IN	u8		channel		);
+
+
+static	u8	phy_DbmToTxPwrIdx(	IN	PADAPTER		Adapter,
+									IN	WIRELESS_MODE	WirelessMode,
+									IN	int			PowerInDbm	);
+
+						
+#if 0
+BOOLEAN
+phy_SetRFPowerState8192SE(
+	IN	PADAPTER			Adapter,
+	IN	RT_RF_POWER_STATE	eRFPowerState
+	);
+
+BOOLEAN
+phy_SetRFPowerState8192CU(
+	IN	PADAPTER			Adapter,
+	IN	RT_RF_POWER_STATE	eRFPowerState
+	);
+#endif
+
+#if DEV_BUS_TYPE==DEV_BUS_PCI_INTERFACE
+static	VOID
+phy_CheckEphySwitchReady(
+	IN	PADAPTER			Adapter
+	);
+#endif
+						
+int
+PHY_ConfigRFExternalPA(
+	IN	PADAPTER			Adapter,
+	RF90_RADIO_PATH_E		eRFPath
+);						
+
+VOID
+phy_ConfigBBExternalPA(
+	IN	PADAPTER			Adapter
+);
+
+VOID
+phy_SetRTL8192CERfSleep(
+	IN	PADAPTER			Adapter
+);
+
+VOID
+phy_SetRTL8192CERfOn(
+	IN	PADAPTER			Adapter
+);
+
+				
+/*----------------------------Function Body----------------------------------*/
+//
+// 1. BB register R/W API
+//
+/**
+* Function:	PHY_QueryBBReg
+*
+* OverView:	Read "sepcific bits" from BB register
+*
+* Input:
+*			PADAPTER		Adapter,
+*			u4Byte			RegAddr,		//The target address to be readback
+*			u4Byte			BitMask		//The target bit position in the target address
+*										//to be readback	
+* Output:	None
+* Return:		u4Byte			Data			//The readback register value
+* Note:		This function is equal to "GetRegSetting" in PHY programming guide
+*/
+u32
+PHY_QueryBBReg(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask
+	)
+{	
+  	u32	ReturnValue = 0, OriginalValue, BitShift;
+	u16	BBWaitCounter = 0;
+
+#if (DISABLE_BB_RF == 1)
+	return 0;
+#endif
+
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("--->PHY_QueryBBReg(): RegAddr(%#lx), BitMask(%#lx)\n", RegAddr, BitMask));
+
+	OriginalValue = rtw_read32(Adapter, RegAddr);
+	BitShift = phy_CalculateBitShift(BitMask);
+	ReturnValue = (OriginalValue & BitMask) >> BitShift;
+
+	//RTPRINT(FPHY, PHY_BBR, ("BBR MASK=0x%lx Addr[0x%lx]=0x%lx\n", BitMask, RegAddr, OriginalValue));
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_QueryBBReg(): RegAddr(%#lx), BitMask(%#lx), OriginalValue(%#lx)\n", RegAddr, BitMask, OriginalValue));
+
+	return (ReturnValue);
+
+}
+
+
+/**
+* Function:	PHY_SetBBReg
+*
+* OverView:	Write "Specific bits" to BB register (page 8~) 
+*
+* Input:
+*			PADAPTER		Adapter,
+*			u4Byte			RegAddr,		//The target address to be modified
+*			u4Byte			BitMask		//The target bit position in the target address
+*										//to be modified	
+*			u4Byte			Data			//The new register value in the target bit position
+*										//of the target address			
+*
+* Output:	None
+* Return:		None
+* Note:		This function is equal to "PutRegSetting" in PHY programming guide
+*/
+
+VOID
+PHY_SetBBReg(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+	)
+{
+	HAL_DATA_TYPE	*pHalData		= GET_HAL_DATA(Adapter);
+	u16			BBWaitCounter	= 0;
+	u32			OriginalValue, BitShift;
+
+#if (DISABLE_BB_RF == 1)
+	return;
+#endif
+
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("--->PHY_SetBBReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx)\n", RegAddr, BitMask, Data));
+
+	if(BitMask!= bMaskDWord){//if not "double word" write
+		OriginalValue = rtw_read32(Adapter, RegAddr);
+		BitShift = phy_CalculateBitShift(BitMask);
+		Data = (((OriginalValue) & (~BitMask)) | (Data << BitShift));
+	}
+
+	rtw_write32(Adapter, RegAddr, Data);
+
+	//RTPRINT(FPHY, PHY_BBW, ("BBW MASK=0x%lx Addr[0x%lx]=0x%lx\n", BitMask, RegAddr, Data));
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_SetBBReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx)\n", RegAddr, BitMask, Data));
+	
+}
+
+
+//
+// 2. RF register R/W API
+//
+/**
+* Function:	PHY_QueryRFReg
+*
+* OverView:	Query "Specific bits" to RF register (page 8~) 
+*
+* Input:
+*			PADAPTER		Adapter,
+*			RF90_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
+*			u4Byte			RegAddr,		//The target address to be read
+*			u4Byte			BitMask		//The target bit position in the target address
+*										//to be read	
+*
+* Output:	None
+* Return:		u4Byte			Readback value
+* Note:		This function is equal to "GetRFRegSetting" in PHY programming guide
+*/
+u32
+PHY_QueryRFReg(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask
+	)
+{
+	u32 Original_Value, Readback_Value, BitShift;	
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	//u8	RFWaitCounter = 0;
+
+#if (DISABLE_BB_RF == 1)
+	return 0;
+#endif
+	
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("--->PHY_QueryRFReg(): RegAddr(%#lx), eRFPath(%#x), BitMask(%#lx)\n", RegAddr, eRFPath,BitMask));
+	
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+	//PlatformAcquireMutex(&pHalData->mxRFOperate);
+#else
+	//PlatformAcquireSpinLock(Adapter, RT_RF_OPERATE_SPINLOCK);
+#endif
+
+	
+	Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
+	
+	BitShift =  phy_CalculateBitShift(BitMask);
+	Readback_Value = (Original_Value & BitMask) >> BitShift;	
+
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+	//PlatformReleaseMutex(&pHalData->mxRFOperate);
+#else
+	//PlatformReleaseSpinLock(Adapter, RT_RF_OPERATE_SPINLOCK);
+#endif
+
+
+	//RTPRINT(FPHY, PHY_RFR, ("RFR-%d MASK=0x%lx Addr[0x%lx]=0x%lx\n", eRFPath, BitMask, RegAddr, Original_Value));//BitMask(%#lx),BitMask,
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_QueryRFReg(): RegAddr(%#lx), eRFPath(%#x),  Original_Value(%#lx)\n", 
+	//				RegAddr, eRFPath, Original_Value));
+	
+	return (Readback_Value);
+}
+
+/**
+* Function:	PHY_SetRFReg
+*
+* OverView:	Write "Specific bits" to RF register (page 8~) 
+*
+* Input:
+*			PADAPTER		Adapter,
+*			RF90_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
+*			u4Byte			RegAddr,		//The target address to be modified
+*			u4Byte			BitMask		//The target bit position in the target address
+*										//to be modified	
+*			u4Byte			Data			//The new register Data in the target bit position
+*										//of the target address			
+*
+* Output:	None
+* Return:		None
+* Note:		This function is equal to "PutRFRegSetting" in PHY programming guide
+*/
+VOID
+PHY_SetRFReg(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask,
+	IN	u32				Data
+	)
+{
+
+	//HAL_DATA_TYPE	*pHalData		= GET_HAL_DATA(Adapter);
+	//u1Byte			RFWaitCounter	= 0;
+	u32 			Original_Value, BitShift;
+
+#if (DISABLE_BB_RF == 1)
+	return;
+#endif
+	
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("--->PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n", 
+	//	RegAddr, BitMask, Data, eRFPath));
+	//RTPRINT(FINIT, INIT_RF, ("PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n", 
+	//	RegAddr, BitMask, Data, eRFPath));
+
+
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+	//PlatformAcquireMutex(&pHalData->mxRFOperate);
+#else
+	//PlatformAcquireSpinLock(Adapter, RT_RF_OPERATE_SPINLOCK);
+#endif
+
+	
+	// RF data is 12 bits only
+	if (BitMask != bRFRegOffsetMask) 
+	{
+		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
+		BitShift =  phy_CalculateBitShift(BitMask);
+		Data = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
+	}
+		
+	phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
+	
+
+
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+	//PlatformReleaseMutex(&pHalData->mxRFOperate);
+#else
+	//PlatformReleaseSpinLock(Adapter, RT_RF_OPERATE_SPINLOCK);
+#endif
+	
+	//PHY_QueryRFReg(Adapter,eRFPath,RegAddr,BitMask);
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n", 
+	//		RegAddr, BitMask, Data, eRFPath));
+
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_FwRFSerialRead()
+ *
+ * Overview:	We support firmware to execute RF-R/W.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	01/21/2008	MHC		Create Version 0.  
+ *
+ *---------------------------------------------------------------------------*/
+static	u32
+phy_FwRFSerialRead(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset	)
+{
+	u32		retValue = 0;		
+	//RT_ASSERT(FALSE,("deprecate!\n"));
+	return	(retValue);
+
+}	/* phy_FwRFSerialRead */
+
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_FwRFSerialWrite()
+ *
+ * Overview:	We support firmware to execute RF-R/W.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	01/21/2008	MHC		Create Version 0.  
+ *
+ *---------------------------------------------------------------------------*/
+static	VOID
+phy_FwRFSerialWrite(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u32				Data	)
+{
+	//RT_ASSERT(FALSE,("deprecate!\n"));
+}
+
+
+/**
+* Function:	phy_RFSerialRead
+*
+* OverView:	Read regster from RF chips 
+*
+* Input:
+*			PADAPTER		Adapter,
+*			RF90_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
+*			u4Byte			Offset,		//The target address to be read			
+*
+* Output:	None
+* Return:		u4Byte			reback value
+* Note:		Threre are three types of serial operations: 
+*			1. Software serial write
+*			2. Hardware LSSI-Low Speed Serial Interface 
+*			3. Hardware HSSI-High speed
+*			serial write. Driver need to implement (1) and (2).
+*			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
+*/
+static	u32
+phy_RFSerialRead(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset
+	)
+{
+	u32						retValue = 0;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+	BB_REGISTER_DEFINITION_T	*pPhyReg = &pHalData->PHYRegDef[eRFPath];
+	u32						NewOffset;
+	u32 						tmplong,tmplong2;
+	u8					RfPiEnable=0;
+#if 0
+	if(pHalData->RFChipID == RF_8225 && Offset > 0x24) //36 valid regs
+		return	retValue;
+	if(pHalData->RFChipID == RF_8256 && Offset > 0x2D) //45 valid regs
+		return	retValue;
+#endif
+	//
+	// Make sure RF register offset is correct 
+	//
+	Offset &= 0x3f;
+
+	//
+	// Switch page for 8256 RF IC
+	//
+	NewOffset = Offset;
+
+	// 2009/06/17 MH We can not execute IO for power save or other accident mode.
+	//if(RT_CANNOT_IO(Adapter))
+	//{
+	//	RTPRINT(FPHY, PHY_RFR, ("phy_RFSerialRead return all one\n"));
+	//	return	0xFFFFFFFF;
+	//}
+
+	// For 92S LSSI Read RFLSSIRead
+	// For RF A/B write 0x824/82c(does not work in the future) 
+	// We must use 0x824 for RF A and B to execute read trigger
+	tmplong = PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord);
+	if(eRFPath == RF90_PATH_A)
+		tmplong2 = tmplong;
+	else
+	tmplong2 = PHY_QueryBBReg(Adapter, pPhyReg->rfHSSIPara2, bMaskDWord);
+	
+	tmplong2 = (tmplong2 & (~bLSSIReadAddress)) | (NewOffset<<23) | bLSSIReadEdge;	//T65 RF
+	
+	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord, tmplong&(~bLSSIReadEdge));	
+	rtw_udelay_os(10);// PlatformStallExecution(1000);
+	
+	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, bMaskDWord, tmplong2);	
+	rtw_udelay_os(100);//PlatformStallExecution(1000);
+	
+	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord, tmplong|bLSSIReadEdge);	
+	rtw_udelay_os(10);//PlatformStallExecution(1000);
+
+	if(eRFPath == RF90_PATH_A)
+		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter1, BIT8);
+	else if(eRFPath == RF90_PATH_B)
+		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XB_HSSIParameter1, BIT8);
+	
+	if(RfPiEnable)
+	{	// Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF
+		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi, bLSSIReadBackData);
+	
+		//RTPRINT(FINIT, INIT_RF, ("Readback from RF-PI : 0x%x\n", retValue));
+	}
+	else
+	{	//Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF
+		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);
+		
+		//RTPRINT(FINIT, INIT_RF,("Readback from RF-SI : 0x%x\n", retValue));
+	}
+	//RTPRINT(FPHY, PHY_RFR, ("RFR-%d Addr[0x%lx]=0x%lx\n", eRFPath, pPhyReg->rfLSSIReadBack, retValue));
+	
+	return retValue;	
+		
+}
+
+
+
+/**
+* Function:	phy_RFSerialWrite
+*
+* OverView:	Write data to RF register (page 8~) 
+*
+* Input:
+*			PADAPTER		Adapter,
+*			RF90_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
+*			u4Byte			Offset,		//The target address to be read			
+*			u4Byte			Data			//The new register Data in the target bit position
+*										//of the target to be read			
+*
+* Output:	None
+* Return:		None
+* Note:		Threre are three types of serial operations: 
+*			1. Software serial write
+*			2. Hardware LSSI-Low Speed Serial Interface 
+*			3. Hardware HSSI-High speed
+*			serial write. Driver need to implement (1) and (2).
+*			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
+ *
+ * Note: 		  For RF8256 only
+ *			 The total count of RTL8256(Zebra4) register is around 36 bit it only employs 
+ *			 4-bit RF address. RTL8256 uses "register mode control bit" (Reg00[12], Reg00[10]) 
+ *			 to access register address bigger than 0xf. See "Appendix-4 in PHY Configuration
+ *			 programming guide" for more details. 
+ *			 Thus, we define a sub-finction for RTL8526 register address conversion
+ *		       ===========================================================
+ *			 Register Mode		RegCTL[1]		RegCTL[0]		Note
+ *								(Reg00[12])		(Reg00[10])
+ *		       ===========================================================
+ *			 Reg_Mode0				0				x			Reg 0 ~15(0x0 ~ 0xf)
+ *		       ------------------------------------------------------------------
+ *			 Reg_Mode1				1				0			Reg 16 ~30(0x1 ~ 0xf)
+ *		       ------------------------------------------------------------------
+ *			 Reg_Mode2				1				1			Reg 31 ~ 45(0x1 ~ 0xf)
+ *		       ------------------------------------------------------------------
+ *
+ *	2008/09/02	MH	Add 92S RF definition
+ *	
+ *
+ *
+*/
+static	VOID
+phy_RFSerialWrite(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u32				Data
+	)
+{
+	u32						DataAndAddr = 0;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+	BB_REGISTER_DEFINITION_T	*pPhyReg = &pHalData->PHYRegDef[eRFPath];
+	u32						NewOffset;
+	
+#if 0
+	//<Roger_TODO> We should check valid regs for RF_6052 case.
+	if(pHalData->RFChipID == RF_8225 && Offset > 0x24) //36 valid regs
+		return;
+	if(pHalData->RFChipID == RF_8256 && Offset > 0x2D) //45 valid regs
+		return;
+#endif
+
+	// 2009/06/17 MH We can not execute IO for power save or other accident mode.
+	//if(RT_CANNOT_IO(Adapter))
+	//{
+	//	RTPRINT(FPHY, PHY_RFW, ("phy_RFSerialWrite stop\n"));
+	//	return;
+	//}
+
+	Offset &= 0x3f;
+
+	//
+	// Shadow Update
+	//
+	PHY_RFShadowWrite(Adapter, eRFPath, Offset, Data);	
+
+	//
+	// Switch page for 8256 RF IC
+	//
+	NewOffset = Offset;
+
+	//
+	// Put write addr in [5:0]  and write data in [31:16]
+	//
+	//DataAndAddr = (Data<<16) | (NewOffset&0x3f);
+	DataAndAddr = ((NewOffset<<20) | (Data&0x000fffff)) & 0x0fffffff;	// T65 RF
+
+	//
+	// Write Operation
+	//
+	PHY_SetBBReg(Adapter, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);
+	//RTPRINT(FPHY, PHY_RFW, ("RFW-%d Addr[0x%lx]=0x%lx\n", eRFPath, pPhyReg->rf3wireOffset, DataAndAddr));
+
+}
+
+/**
+* Function:	phy_CalculateBitShift
+*
+* OverView:	Get shifted position of the BitMask
+*
+* Input:
+*			u4Byte		BitMask,	
+*
+* Output:	none
+* Return:		u4Byte		Return the shift bit bit position of the mask
+*/
+static	u32
+phy_CalculateBitShift(
+	u32 BitMask
+	)
+{
+	u32 i;
+
+	for(i=0; i<=31; i++)
+	{
+		if ( ((BitMask>>i) &  0x1 ) == 1)
+			break;
+	}
+
+	return (i);
+}
+
+
+//
+// 3. Initial MAC/BB/RF config by reading MAC/BB/RF txt.
+//
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_MACConfig8192C
+ *
+ * Overview:	Condig MAC by header file or parameter file.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ *  When		Who		Remark
+ *  08/12/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+extern	int
+PHY_MACConfig8192C(
+	IN	PADAPTER	Adapter
+	)
+{
+	int		rtStatus = _SUCCESS;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+#if DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE
+	u8			pszMACRegFile[] = RTL819X_PHY_MACREG;
+#else
+	u8			sz88CMACRegFile[] = RTL8188C_PHY_MACREG;
+	u8			sz92CMACRegFile[] = RTL8192C_PHY_MACREG;
+	
+	u8			*pszMACRegFile;
+
+	if(IS_92C_SERIAL(pHalData->VersionID)){
+		pszMACRegFile = (u8*)&sz92CMACRegFile;
+	}
+	else{
+		pszMACRegFile = (u8*)&sz88CMACRegFile;
+	}
+#endif
+
+	//
+	// Config MAC
+	//
+#ifdef CONFIG_EMBEDDED_FWIMG
+	rtStatus = phy_ConfigMACWithHeaderFile(Adapter);
+#else
+	
+	// Not make sure EEPROM, add later
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Read MACREG.txt\n"));
+	rtStatus = phy_ConfigMACWithParaFile(Adapter, pszMACRegFile);
+#endif
+	
+	#if 0 
+	//this switching setting cause some 8192cu hw have redownload fw fail issue
+	//improve 2-stream TX EVM by Jenyu
+	if(IS_NORMAL_CHIP(pHalData->VersionID) && IS_92C_SERIAL(pHalData->VersionID))
+		rtw_write8(Adapter, 0x14,0x71);
+	#endif
+	
+	return rtStatus;
+
+}
+
+
+int
+PHY_BBConfig8192C(
+	IN	PADAPTER	Adapter
+	)
+{
+	int	rtStatus = _SUCCESS;
+	u8		PathMap = 0, index = 0, rf_num = 0;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32	RegVal;
+
+	phy_InitBBRFRegisterDefinition(Adapter);
+
+	// Enable BB and RF
+	RegVal = rtw_read16(Adapter, REG_SYS_FUNC_EN);
+	rtw_write16(Adapter, REG_SYS_FUNC_EN, (u16)(RegVal|BIT13|BIT0|BIT1));
+
+	// 20090923 Joseph: Advised by Steven and Jenyu. Power sequence before init RF.
+	rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x83);
+	rtw_write8(Adapter, REG_AFE_PLL_CTRL+1, 0xdb);
+	rtw_write8(Adapter, REG_RF_CTRL, RF_EN|RF_RSTB|RF_SDMRSTB);
+
+#if DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE
+	rtw_write8(Adapter, REG_SYS_FUNC_EN, FEN_USBA | FEN_USBD | FEN_BB_GLB_RSTn | FEN_BBRSTB);
+#else
+	rtw_write8(Adapter, REG_SYS_FUNC_EN, FEN_PPLL|FEN_PCIEA|FEN_DIO_PCIE|FEN_USBA|FEN_BB_GLB_RSTn|FEN_BBRSTB);
+#endif
+	//To Fix MAC loopback mode fail. Suggested by SD4 Johnny. 2010.03.23.
+	rtw_write8(Adapter, REG_LDOHCI12_CTRL, 0x0f);	
+	rtw_write8(Adapter, 0x15, 0xe9);
+	rtw_write8(Adapter, REG_AFE_XTAL_CTRL+1, 0x80);
+
+	//
+	// Config BB and AGC
+	//
+	rtStatus = phy_BB8192C_Config_ParaFile(Adapter);
+#if 0	
+	switch(Adapter->MgntInfo.bRegHwParaFile)
+	{
+		case 0:
+			phy_BB8190_Config_HardCode(Adapter);
+			break;
+
+		case 1:
+			rtStatus = phy_BB8192C_Config_ParaFile(Adapter);
+			break;
+
+		case 2:
+			// Partial Modify. 
+			phy_BB8190_Config_HardCode(Adapter);
+			phy_BB8192C_Config_ParaFile(Adapter);
+			break;
+
+		default:
+			phy_BB8190_Config_HardCode(Adapter);
+			break;
+	}
+#endif	
+#if 0
+	// Check BB/RF confiuration setting.
+	// We only need to configure RF which is turned on.
+	PathMap = (u1Byte)(PHY_QueryBBReg(Adapter, rFPGA0_TxInfo, 0xf) |
+				PHY_QueryBBReg(Adapter, rOFDM0_TRxPathEnable, 0xf));
+	pHalData->RF_PathMap = PathMap;
+	for(index = 0; index<4; index++)
+	{
+		if((PathMap>>index)&0x1)
+			rf_num++;
+	}
+
+	if((GET_RF_TYPE(Adapter) ==RF_1T1R && rf_num!=1) ||
+		(GET_RF_TYPE(Adapter)==RF_1T2R && rf_num!=2) ||
+		(GET_RF_TYPE(Adapter)==RF_2T2R && rf_num!=2) ||
+		(GET_RF_TYPE(Adapter)==RF_2T2R_GREEN && rf_num!=2) ||
+		(GET_RF_TYPE(Adapter)==RF_2T4R && rf_num!=4))
+	{
+		RT_TRACE(
+			COMP_INIT, 
+			DBG_LOUD, 
+			("PHY_BBConfig8192C: RF_Type(%x) does not match RF_Num(%x)!!\n", pHalData->rf_type, rf_num));
+	}
+#endif
+
+	return rtStatus;
+}
+
+
+extern	int
+PHY_RFConfig8192C(
+	IN	PADAPTER	Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	int		rtStatus = _SUCCESS;
+
+	//
+	// RF config
+	//
+	rtStatus = PHY_RF6052_Config(Adapter);
+#if 0	
+	switch(pHalData->rf_chip)
+	{
+		case RF_6052:
+			rtStatus = PHY_RF6052_Config(Adapter);
+			break;
+		case RF_8225:
+			rtStatus = PHY_RF8225_Config(Adapter);
+			break;
+		case RF_8256:			
+			rtStatus = PHY_RF8256_Config(Adapter);
+			break;
+		case RF_8258:
+			break;
+		case RF_PSEUDO_11N:
+			rtStatus = PHY_RF8225_Config(Adapter);
+			break;
+		default: //for MacOs Warning: "RF_TYPE_MIN" not handled in switch
+			break;
+	}
+#endif
+	return rtStatus;
+}
+
+
+#ifdef RTL8192C_RECONFIG_TO_1T1R
+void	PHY_Reconfig_To_1T1R(_adapter *padapter)
+{
+	printk("###### %s #######\n",__FUNCTION__);
+	//BB (path B off)
+	PHY_SetBBReg(padapter, 0xc04, 0x000000ff, 0x11);
+	PHY_SetBBReg(padapter, 0xd04, 0x0000000f, 0x1);
+	PHY_SetBBReg(padapter, 0x90C, 0x000000ff, 0x11);
+	PHY_SetBBReg(padapter, 0x90C, 0x00f00000, 0x1);
+	PHY_SetBBReg(padapter, 0x88c, 0x00C00000, 0x11);
+
+	//ADDA (path-B off)
+	PHY_SetBBReg(padapter, 0x85C, bMaskDWord, 0x00db25a4);	
+	PHY_SetBBReg(padapter, 0xe6c, bMaskDWord, 0x20db25a4);
+	PHY_SetBBReg(padapter, 0xe70, bMaskDWord, 0x20db25a4);
+	PHY_SetBBReg(padapter, 0xe74, bMaskDWord, 0x041b25a4);	
+	PHY_SetBBReg(padapter, 0xe78, bMaskDWord, 0x041b25a4);	
+	PHY_SetBBReg(padapter, 0xe7c, bMaskDWord, 0x041b25a4);
+	PHY_SetBBReg(padapter, 0xe80, bMaskDWord, 0x041b25a4);
+	PHY_SetBBReg(padapter, 0xe84, bMaskDWord, 0x63db25a4);
+	PHY_SetBBReg(padapter, 0xe88, bMaskDWord, 0x041b25a4);
+	PHY_SetBBReg(padapter, 0xe8c, bMaskDWord, 0x20db25a4);
+	PHY_SetBBReg(padapter, 0xed0, bMaskDWord, 0x20db25a4);
+	PHY_SetBBReg(padapter, 0xed4, bMaskDWord, 0x20db25a4);
+	PHY_SetBBReg(padapter, 0xed8, bMaskDWord, 0x20db25a4);
+	PHY_SetBBReg(padapter, 0xedc, bMaskDWord, 0x001b25a4);
+	PHY_SetBBReg(padapter, 0xee0, bMaskDWord, 0x001b25a4);
+	PHY_SetBBReg(padapter, 0xeec, bMaskDWord, 0x24db25a4);
+
+	//RF
+	//path B to standby mode
+	PHY_SetBBReg(padapter, 0x844, bMaskDWord, 0x00010000);
+	
+}
+#endif
+
+VOID
+phy_BB8192C_Config_1T(
+	IN PADAPTER Adapter
+	)
+{
+#if 0
+	//for path - A
+	PHY_SetBBReg(Adapter, rFPGA0_TxInfo, 0x3, 0x1);
+	PHY_SetBBReg(Adapter, rFPGA1_TxInfo, 0x0303, 0x0101);
+	PHY_SetBBReg(Adapter, 0xe74, 0x0c000000, 0x1);
+	PHY_SetBBReg(Adapter, 0xe78, 0x0c000000, 0x1);
+	PHY_SetBBReg(Adapter, 0xe7c, 0x0c000000, 0x1);
+	PHY_SetBBReg(Adapter, 0xe80, 0x0c000000, 0x1);
+	PHY_SetBBReg(Adapter, 0xe88, 0x0c000000, 0x1);
+#endif
+	//for path - B
+	PHY_SetBBReg(Adapter, rFPGA0_TxInfo, 0x3, 0x2);
+	PHY_SetBBReg(Adapter, rFPGA1_TxInfo, 0x300033, 0x200022);
+
+	// 20100519 Joseph: Add for 1T2R config. Suggested by Kevin, Jenyu and Yunan.
+	PHY_SetBBReg(Adapter, rCCK0_AFESetting, bMaskByte3, 0x45);
+	PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x23);
+	PHY_SetBBReg(Adapter, rOFDM0_AGCParameter1, 0x30, 0x1);	// B path first AGC
+	
+	PHY_SetBBReg(Adapter, 0xe74, 0x0c000000, 0x2);
+	PHY_SetBBReg(Adapter, 0xe78, 0x0c000000, 0x2);
+	PHY_SetBBReg(Adapter, 0xe7c, 0x0c000000, 0x2);
+	PHY_SetBBReg(Adapter, 0xe80, 0x0c000000, 0x2);
+	PHY_SetBBReg(Adapter, 0xe88, 0x0c000000, 0x2);
+
+	
+}
+
+// Joseph test: new initialize order!!
+// Test only!! This part need to be re-organized.
+// Now it is just for 8256.
+static	int
+phy_BB8190_Config_HardCode(
+	IN	PADAPTER	Adapter
+	)
+{
+	//RT_ASSERT(FALSE, ("This function is not implement yet!! \n"));
+	return _SUCCESS;
+}
+
+static	int
+phy_BB8192C_Config_ParaFile(
+	IN	PADAPTER	Adapter
+	)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	int			rtStatus = _SUCCESS;
+
+	u8				szBBRegPgFile[] = RTL819X_PHY_REG_PG;
+	
+	u8				sz88CBBRegFile[] = RTL8188C_PHY_REG;	
+	u8				sz88CAGCTableFile[] = RTL8188C_AGC_TAB;
+
+	u8				sz92CBBRegFile[] = RTL8192C_PHY_REG;	
+	u8				sz92CAGCTableFile[] = RTL8192C_AGC_TAB;
+	
+	u8                             *pszBBRegFile, *pszAGCTableFile;
+	
+	//RT_TRACE(COMP_INIT, DBG_TRACE, ("==>phy_BB8192S_Config_ParaFile\n"));
+
+	if(IS_92C_SERIAL(pHalData->VersionID)){
+		pszBBRegFile=(u8*)&sz92CBBRegFile ;
+		pszAGCTableFile =(u8*)&sz92CAGCTableFile;
+	}
+	else{
+		pszBBRegFile=(u8*)&sz88CBBRegFile ;
+		pszAGCTableFile =(u8*)&sz88CAGCTableFile;
+	}
+
+	//
+	// 1. Read PHY_REG.TXT BB INIT!!
+	// We will seperate as 88C / 92C according to chip version
+	//
+#ifdef CONFIG_EMBEDDED_FWIMG
+	rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_PHY_REG);	
+#else	
+	// No matter what kind of CHIP we always read PHY_REG.txt. We must copy different 
+	// type of parameter files to phy_reg.txt at first.	
+	rtStatus = phy_ConfigBBWithParaFile(Adapter,pszBBRegFile);
+#endif
+
+	if(rtStatus != _SUCCESS){
+		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg Fail!!"));
+		goto phy_BB8190_Config_ParaFile_Fail;
+	}
+
+	// 20100318 Config 2T2R to 1T2R if necessary.
+	//
+	if(pHalData->rf_type== RF_1T2R)
+	{
+		phy_BB8192C_Config_1T(Adapter);
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("phy_BB8192S_Config_ParaFile():Config to 1T!!\n"));
+	}
+
+	//
+	// 2. If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt
+	//
+	if (pEEPROM->bAutoload== _SUCCESS)
+	{
+		pHalData->pwrGroupCnt = 0;
+
+#ifdef CONFIG_EMBEDDED_FWIMG
+		rtStatus = phy_ConfigBBWithPgHeaderFile(Adapter, BaseBand_Config_PHY_REG);
+#else
+		rtStatus = phy_ConfigBBWithPgParaFile(Adapter, (u8*)&szBBRegPgFile);
+#endif
+	}
+	
+	if(rtStatus != _SUCCESS){
+		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():BB_PG Reg Fail!!"));
+		goto phy_BB8190_Config_ParaFile_Fail;
+	}
+
+	//
+	// 3. BB AGC table Initialization
+	//
+#ifdef CONFIG_EMBEDDED_FWIMG
+	rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_AGC_TAB);
+#else
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("phy_BB8192S_Config_ParaFile AGC_TAB.txt\n"));
+	rtStatus = phy_ConfigBBWithParaFile(Adapter, pszAGCTableFile);
+#endif
+
+	if(rtStatus != _SUCCESS){
+		//RT_TRACE(COMP_FPGA, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():AGC Table Fail\n"));
+		goto phy_BB8190_Config_ParaFile_Fail;
+	}
+
+	// Check if the CCK HighPower is turned ON.
+	// This is used to calculate PWDB.
+	pHalData->bCckHighPower = (BOOLEAN)(PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2, 0x200));
+	
+phy_BB8190_Config_ParaFile_Fail:
+
+	return rtStatus;
+}
+
+
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigMACWithParaFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write 
+ *
+ * Input:      	PADAPTER		Adapter
+ *			ps1Byte 			pFileName			
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *			
+ * Note: 		The format of MACPHY_REG.txt is different from PHY and RF. 
+ *			[Register][Mask][Value]
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigMACWithParaFile(
+	IN	PADAPTER		Adapter,
+	IN	u8* 			pFileName
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	int		rtStatus = _SUCCESS;
+
+	return rtStatus;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigMACWithHeaderFile()
+ *
+ * Overview:    This function read BB parameters from Header file we gen, and do register
+ *			  Read/Write 
+ *
+ * Input:      	PADAPTER		Adapter
+ *			ps1Byte 			pFileName			
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *			
+ * Note: 		The format of MACPHY_REG.txt is different from PHY and RF. 
+ *			[Register][Mask][Value]
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigMACWithHeaderFile(
+	IN	PADAPTER		Adapter
+)
+{
+	u32					i = 0;
+	u32					ArrayLength = 0;
+	u32*					ptrArray;	
+	//HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+
+	//2008.11.06 Modified by tynli.
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Read Rtl819XMACPHY_Array\n"));
+	ArrayLength = MAC_2T_ArrayLength;
+	ptrArray = (u32*)&Rtl819XMAC_Array[0];	
+
+	for(i = 0 ;i < ArrayLength;i=i+2){ // Add by tynli for 2 column
+		rtw_write8(Adapter, ptrArray[i], (u8)ptrArray[i+1]);
+	}
+	
+	return _SUCCESS;
+	
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigBBWithParaFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write 
+ *
+ * Input:      	PADAPTER		Adapter
+ *			ps1Byte 			pFileName			
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *	2008/11/06	MH	For 92S we do not support silent reset now. Disable 
+ *					parameter file compare!!!!!!??
+ *			
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithParaFile(
+	IN	PADAPTER		Adapter,
+	IN	u8* 			pFileName
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	int		rtStatus = _SUCCESS;
+
+	return rtStatus;	
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_SetBBtoDiffRFWithParaFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write 
+ *
+ * Input:      	PADAPTER		Adapter
+ *			ps1Byte 			pFileName			
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *
+ * 2008/11/10	tynli	
+ * 2009/07/29	tynli (porting from 92SE branch) Add copy parameter file to buffer for silent reset
+ *			
+ *---------------------------------------------------------------------------*/
+static	int
+phy_SetBBtoDiffRFWithParaFile(
+	IN	PADAPTER		Adapter,
+	IN	u8* 			pFileName
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	int		rtStatus = _SUCCESS;
+
+
+	return rtStatus;	
+}
+
+//****************************************
+// The following is for High Power PA
+//****************************************
+VOID
+phy_ConfigBBExternalPA(
+	IN	PADAPTER			Adapter
+)
+{
+#if (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u16 i=0;
+	u32 temp=0;
+
+	if(!pHalData->ExternalPA)
+	{
+		return;
+	}
+
+	DBG_8192C("external PA, BB Setting\n");
+	
+	PHY_SetBBReg(Adapter, 0xee8, BIT28, 1);
+	temp = PHY_QueryBBReg(Adapter, 0x860, bMaskDWord);
+	temp |= (BIT26|BIT21|BIT10|BIT5);
+	PHY_SetBBReg(Adapter, 0x860, bMaskDWord, temp);
+	PHY_SetBBReg(Adapter, 0x870, BIT10, 0);
+	PHY_SetBBReg(Adapter, 0xc80, bMaskDWord, 0x20000080);
+	PHY_SetBBReg(Adapter, 0xc88, bMaskDWord, 0x40000100);
+#endif
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigBBWithHeaderFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write 
+ *
+ * Input:      	PADAPTER		Adapter
+ *			u1Byte 			ConfigType     0 => PHY_CONFIG
+ *										 1 =>AGC_TAB
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *			
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithHeaderFile(
+	IN	PADAPTER		Adapter,
+	IN	u8 			ConfigType
+)
+{
+	int i;
+	u32*	Rtl819XPHY_REGArray_Table;
+	u32*	Rtl819XAGCTAB_Array_Table;
+	u16	PHY_REGArrayLen, AGCTAB_ArrayLen;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	//
+	// 2009.11.24. Modified by tynli.
+	//
+	if(IS_92C_SERIAL(pHalData->VersionID))
+	{
+		AGCTAB_ArrayLen = AGCTAB_2TArrayLength;
+		Rtl819XAGCTAB_Array_Table = (u32*)Rtl819XAGCTAB_2TArray;
+#if DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE
+		if(pHalData->BoardType == BOARD_MINICARD )
+		{
+			PHY_REGArrayLen = PHY_REG_2T_mCardArrayLength;
+			Rtl819XPHY_REGArray_Table = (u32*)Rtl819XPHY_REG_2T_mCardArray;			
+		}
+		else
+#endif
+		{
+			PHY_REGArrayLen = PHY_REG_2TArrayLength;
+			Rtl819XPHY_REGArray_Table = (u32*)Rtl819XPHY_REG_2TArray;
+		}
+	
+	}
+	else
+	{
+		AGCTAB_ArrayLen = AGCTAB_1TArrayLength;
+		Rtl819XAGCTAB_Array_Table = (u32*)Rtl819XAGCTAB_1TArray;
+		
+#if DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE
+		if(pHalData->BoardType == BOARD_MINICARD )
+		{
+			PHY_REGArrayLen = PHY_REG_1T_mCardArrayLength;
+			Rtl819XPHY_REGArray_Table = (u32*)Rtl819XPHY_REG_1T_mCardArray;			
+		}
+		else if(pHalData->BoardType == BOARD_USB_High_PA)
+		{
+			AGCTAB_ArrayLen = AGCTAB_1T_HPArrayLength;
+			Rtl819XAGCTAB_Array_Table =(u32*) Rtl819XAGCTAB_1T_HPArray;
+			PHY_REGArrayLen = PHY_REG_1T_HPArrayLength;
+			Rtl819XPHY_REGArray_Table = (u32*)Rtl819XPHY_REG_1T_HPArray;			
+		}
+		else
+#endif
+		{
+		        PHY_REGArrayLen = PHY_REG_1TArrayLength;
+		        Rtl819XPHY_REGArray_Table = (u32*)Rtl819XPHY_REG_1TArray;
+		}
+
+	}
+
+	if(ConfigType == BaseBand_Config_PHY_REG)
+	{
+		for(i=0;i<PHY_REGArrayLen;i=i+2)
+		{
+			if (Rtl819XPHY_REGArray_Table[i] == 0xfe)
+				rtw_mdelay_os(50);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfd)
+				rtw_mdelay_os(5);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfc)
+				rtw_mdelay_os(1);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfb)
+				rtw_udelay_os(50);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfa)
+				rtw_udelay_os(5);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xf9)
+				rtw_udelay_os(1);
+			PHY_SetBBReg(Adapter, Rtl819XPHY_REGArray_Table[i], bMaskDWord, Rtl819XPHY_REGArray_Table[i+1]);		
+
+			// Add 1us delay between BB/RF register setting.
+			rtw_udelay_os(1);
+
+			//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx \n",Rtl819XPHY_REGArray_Table[i], Rtl819XPHY_REGArray_Table[i+1]));
+		}
+		// for External PA
+		phy_ConfigBBExternalPA(Adapter);
+
+	}
+	else if(ConfigType == BaseBand_Config_AGC_TAB)
+	{
+		for(i=0;i<AGCTAB_ArrayLen;i=i+2)
+		{
+			PHY_SetBBReg(Adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);		
+
+			// Add 1us delay between BB/RF register setting.
+			rtw_udelay_os(1);
+			
+			//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XAGCTAB_Array_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx \n",Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]));
+		}
+	}
+	
+	return _SUCCESS;
+	
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_SetBBtoDiffRFWithHeaderFile()
+ *
+ * Overview:    This function 
+ *			
+ *
+ * Input:      	PADAPTER		Adapter
+ *			u1Byte 			ConfigType     0 => PHY_CONFIG
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ * When			Who		Remark
+ * 2008/11/10	tynli
+ *			
+ *---------------------------------------------------------------------------*/
+static	int
+phy_SetBBtoDiffRFWithHeaderFile(
+	IN	PADAPTER		Adapter,
+	IN	u8			ConfigType
+)
+{
+#if 0 //Marked by tynli. 2009.11.24. CE does not need this function.
+
+	int i;
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	pu4Byte 			Rtl819XPHY_REGArraytoXTXR_Table;
+	u2Byte			PHY_REGArraytoXTXRLen;
+	
+	if(GET_RF_TYPE(Adapter) == RF_1T1R)
+	{
+		Rtl819XPHY_REGArraytoXTXR_Table = Rtl819XPHY_REG_to1T1R_Array;
+		PHY_REGArraytoXTXRLen = PHY_ChangeTo_1T1RArrayLength;
+		RT_TRACE(COMP_INIT, DBG_LOUD, ("phy_SetBBtoDiffRFWithHeaderFile: Set to 1T1R..\n"));
+	} 
+	else if(GET_RF_TYPE(Adapter) == RF_1T2R)
+	{
+		Rtl819XPHY_REGArraytoXTXR_Table = Rtl819XPHY_REG_to1T2R_Array;
+		PHY_REGArraytoXTXRLen = PHY_ChangeTo_1T2RArrayLength;
+		RT_TRACE(COMP_INIT, DBG_LOUD, ("phy_SetBBtoDiffRFWithHeaderFile: Set to 1T2R..\n"));
+	}
+//	else if(pHalData->RF_Type == RF_2T2R || pHalData->RF_Type == RF_2T2R_GREEN)
+//	{
+//		Rtl819XPHY_REGArraytoXTXR_Table = Rtl819XPHY_REG_to2T2R_Array;
+//		PHY_REGArraytoXTXRLen = PHY_ChangeTo_2T2RArrayLength;
+//	}
+	else
+	{
+		return RT_STATUS_FAILURE;
+	}
+
+	if(ConfigType == BaseBand_Config_PHY_REG)
+	{
+		for(i=0;i<PHY_REGArraytoXTXRLen;i=i+3)
+		{
+			if (Rtl819XPHY_REGArraytoXTXR_Table[i] == 0xfe)
+				delay_ms(50);
+			else if (Rtl819XPHY_REGArraytoXTXR_Table[i] == 0xfd)
+				delay_ms(5);
+			else if (Rtl819XPHY_REGArraytoXTXR_Table[i] == 0xfc)
+				delay_ms(1);
+			else if (Rtl819XPHY_REGArraytoXTXR_Table[i] == 0xfb)
+				PlatformStallExecution(50);
+			else if (Rtl819XPHY_REGArraytoXTXR_Table[i] == 0xfa)
+				PlatformStallExecution(5);
+			else if (Rtl819XPHY_REGArraytoXTXR_Table[i] == 0xf9)
+				PlatformStallExecution(1);
+			PHY_SetBBReg(Adapter, Rtl819XPHY_REGArraytoXTXR_Table[i], Rtl819XPHY_REGArraytoXTXR_Table[i+1], Rtl819XPHY_REGArraytoXTXR_Table[i+2]);		
+			RT_TRACE(COMP_INIT, DBG_TRACE, 
+			("The Rtl819XPHY_REGArraytoXTXR_Table[0] is %lx Rtl819XPHY_REGArraytoXTXR_Table[1] is %lx Rtl819XPHY_REGArraytoXTXR_Table[2] is %lx \n",
+			Rtl819XPHY_REGArraytoXTXR_Table[i],Rtl819XPHY_REGArraytoXTXR_Table[i+1], Rtl819XPHY_REGArraytoXTXR_Table[i+2]));
+		}
+	}
+	else {
+		RT_TRACE(COMP_INIT, DBG_LOUD, ("phy_SetBBtoDiffRFWithHeaderFile(): ConfigType != BaseBand_Config_PHY_REG\n"));
+	}
+#endif	// #if 0	
+	return _SUCCESS;
+}
+
+
+VOID
+storePwrIndexDiffRateOffset(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	if(RegAddr == rTxAGC_A_Rate18_06)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][0] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0]));
+	}
+	if(RegAddr == rTxAGC_A_Rate54_24)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][1] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][1] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][1]));
+	}
+	if(RegAddr == rTxAGC_A_CCK1_Mcs32)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][6] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6]));
+	}
+	if(RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0xffffff00)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][7] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7]));
+	}	
+	if(RegAddr == rTxAGC_A_Mcs03_Mcs00)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][2] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2]));
+	}
+	if(RegAddr == rTxAGC_A_Mcs07_Mcs04)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][3] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][3] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][3]));
+	}
+	if(RegAddr == rTxAGC_A_Mcs11_Mcs08)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][4] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][4] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][4]));
+	}
+	if(RegAddr == rTxAGC_A_Mcs15_Mcs12)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][5] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][5] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][5]));
+	}
+	if(RegAddr == rTxAGC_B_Rate18_06)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][8] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][8] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][8]));
+	}
+	if(RegAddr == rTxAGC_B_Rate54_24)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][9] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][9] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][9]));
+	}
+	if(RegAddr == rTxAGC_B_CCK1_55_Mcs32)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][14] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][14] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][14]));
+	}
+	if(RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0x000000ff)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][15] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15]));
+	}	
+	if(RegAddr == rTxAGC_B_Mcs03_Mcs00)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][10] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10]));
+	}
+	if(RegAddr == rTxAGC_B_Mcs07_Mcs04)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][11] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][11] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][11]));
+	}
+	if(RegAddr == rTxAGC_B_Mcs11_Mcs08)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][12] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][12] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][12]));
+	}
+	if(RegAddr == rTxAGC_B_Mcs15_Mcs12)
+	{
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][13] = Data;
+		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][13] = 0x%lx\n", pHalData->pwrGroupCnt,
+		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][13]));
+		pHalData->pwrGroupCnt++;
+	}
+}
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ConfigBBWithPgParaFile
+ *
+ * Overview:	
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/06/2008 	MHC		Create Version 0.
+ * 2009/07/29	tynli		(porting from 92SE branch)2009/03/11 Add copy parameter file to buffer for silent reset
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithPgParaFile(
+	IN	PADAPTER		Adapter,
+	IN	u8* 			pFileName)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	int		rtStatus = _SUCCESS;
+
+
+	return rtStatus;
+	
+}	/* phy_ConfigBBWithPgParaFile */
+
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ConfigBBWithPgHeaderFile
+ *
+ * Overview:	Config PHY_REG_PG array 
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/06/2008 	MHC		Add later!!!!!!.. Please modify for new files!!!!
+ * 11/10/2008	tynli		Modify to mew files.
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithPgHeaderFile(
+	IN	PADAPTER		Adapter,
+	IN	u8 			ConfigType)
+{
+	int i;
+	u32*	Rtl819XPHY_REGArray_Table_PG;
+	u16	PHY_REGArrayPGLen;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	// Default: pHalData->rf_type = RF_2T2R.
+	
+	PHY_REGArrayPGLen = PHY_REG_Array_PGLength;
+	Rtl819XPHY_REGArray_Table_PG = (u32*)Rtl819XPHY_REG_Array_PG;
+
+#if DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE
+	if(pHalData->BoardType == BOARD_MINICARD )
+	{
+		PHY_REGArrayPGLen = PHY_REG_Array_PG_mCardLength;
+		Rtl819XPHY_REGArray_Table_PG = (u32*)Rtl819XPHY_REG_Array_PG_mCard;
+	}
+	else if(pHalData->BoardType ==BOARD_USB_High_PA )
+	{
+		PHY_REGArrayPGLen = PHY_REG_Array_PG_HPLength;
+		Rtl819XPHY_REGArray_Table_PG = (u32*)Rtl819XPHY_REG_Array_PG_HP;		
+	}
+#endif		
+			
+
+	if(ConfigType == BaseBand_Config_PHY_REG)
+	{
+		for(i=0;i<PHY_REGArrayPGLen;i=i+3)
+		{
+			if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfe)
+				rtw_mdelay_os(50);
+			else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfd)
+				rtw_mdelay_os(5);
+			else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfc)
+				rtw_mdelay_os(1);
+			else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfb)
+				rtw_udelay_os(50);
+			else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfa)
+				rtw_udelay_os(5);
+			else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xf9)
+				rtw_udelay_os(1);
+			storePwrIndexDiffRateOffset(Adapter, Rtl819XPHY_REGArray_Table_PG[i], 
+				Rtl819XPHY_REGArray_Table_PG[i+1], 
+				Rtl819XPHY_REGArray_Table_PG[i+2]);
+			//PHY_SetBBReg(Adapter, Rtl819XPHY_REGArray_Table_PG[i], Rtl819XPHY_REGArray_Table_PG[i+1], Rtl819XPHY_REGArray_Table_PG[i+2]);		
+			//RT_TRACE(COMP_SEND, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table_PG[0] is %lx Rtl819XPHY_REGArray_Table_PG[1] is %lx \n",Rtl819XPHY_REGArray_Table_PG[i], Rtl819XPHY_REGArray_Table_PG[i+1]));
+		}
+	}
+	else
+	{
+
+		//RT_TRACE(COMP_SEND, DBG_LOUD, ("phy_ConfigBBWithPgHeaderFile(): ConfigType != BaseBand_Config_PHY_REG\n"));
+	}
+	
+	return _SUCCESS;
+	
+}	/* phy_ConfigBBWithPgHeaderFile */
+
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_ConfigRFWithParaFile()
+ *
+ * Overview:    This function read RF parameters from general file format, and do RF 3-wire
+ *
+ * Input:      	PADAPTER			Adapter
+ *			ps1Byte 				pFileName			
+ *			RF90_RADIO_PATH_E	eRFPath
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *			
+ * Note:		Delay may be required for RF configuration
+ *---------------------------------------------------------------------------*/
+int
+PHY_ConfigRFWithParaFile(
+	IN	PADAPTER			Adapter,
+	IN	u8* 				pFileName,
+	RF90_RADIO_PATH_E		eRFPath
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	int	rtStatus = _SUCCESS;
+
+
+	return rtStatus;
+	
+}
+
+//****************************************
+// The following is for High Power PA
+//****************************************
+#define HighPowerRadioAArrayLen 22
+//This is for High power PA
+u32 Rtl8192S_HighPower_RadioA_Array[HighPowerRadioAArrayLen] = {
+0x013,0x00029ea4,
+0x013,0x00025e74,
+0x013,0x00020ea4,
+0x013,0x0001ced0,
+0x013,0x00019f40,
+0x013,0x00014e70,
+0x013,0x000106a0,
+0x013,0x0000c670,
+0x013,0x000082a0,
+0x013,0x00004270,
+0x013,0x00000240,
+};
+
+int
+PHY_ConfigRFExternalPA(
+	IN	PADAPTER			Adapter,
+	RF90_RADIO_PATH_E		eRFPath
+)
+{
+	int	rtStatus = _SUCCESS;
+#if (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u16 i=0;
+
+	if(!pHalData->ExternalPA)
+	{
+		return rtStatus;
+	}
+	
+	DBG_8192C("external PA, RF Setting\n");
+
+	//add for SU High Power PA
+	for(i = 0;i<HighPowerRadioAArrayLen; i=i+2)
+	{
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("External PA, write RF 0x%x=0x%x\n", Rtl8192S_HighPower_RadioA_Array[i], Rtl8192S_HighPower_RadioA_Array[i+1]));
+		PHY_SetRFReg(Adapter, eRFPath, Rtl8192S_HighPower_RadioA_Array[i], bRFRegOffsetMask, Rtl8192S_HighPower_RadioA_Array[i+1]);
+	}
+#endif
+	return rtStatus;
+}
+//****************************************
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_ConfigRFWithHeaderFile()
+ *
+ * Overview:    This function read RF parameters from general file format, and do RF 3-wire
+ *
+ * Input:      	PADAPTER			Adapter
+ *			ps1Byte 				pFileName			
+ *			RF90_RADIO_PATH_E	eRFPath
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *			
+ * Note:		Delay may be required for RF configuration
+ *---------------------------------------------------------------------------*/
+int
+PHY_ConfigRFWithHeaderFile(
+	IN	PADAPTER			Adapter,
+	RF90_RADIO_PATH_E		eRFPath
+)
+{
+
+	int			i;
+	int	rtStatus = _SUCCESS;
+	u32*		Rtl819XRadioA_Array_Table;
+	u32*		Rtl819XRadioB_Array_Table;
+	u16		RadioA_ArrayLen,RadioB_ArrayLen;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	//
+	// 2009.11.24. Modified by tynli.
+	//
+	if(IS_92C_SERIAL(pHalData->VersionID))
+	{
+		RadioA_ArrayLen = RadioA_2TArrayLength;
+		Rtl819XRadioA_Array_Table=(u32*)Rtl819XRadioA_2TArray;
+
+		RadioB_ArrayLen = RadioB_2TArrayLength;
+		Rtl819XRadioB_Array_Table = (u32*)Rtl819XRadioB_2TArray;
+			
+	}
+	else//8188
+	{
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)		
+		if( BOARD_MINICARD == pHalData->BoardType )
+		{
+			RadioA_ArrayLen = RadioA_1T_mCardArrayLength;
+			Rtl819XRadioA_Array_Table=(u32*)Rtl819XRadioA_1T_mCardArray;
+			RadioB_ArrayLen = RadioB_1T_mCardArrayLength;	
+			Rtl819XRadioB_Array_Table = (u32*)Rtl819XRadioB_1T_mCardArray;			
+		}
+		else if( BOARD_USB_High_PA == pHalData->BoardType )
+		{
+			RadioA_ArrayLen = RadioA_1T_HPArrayLength;
+			Rtl819XRadioA_Array_Table=(u32*)Rtl819XRadioA_1T_HPArray;
+		}
+
+		else
+#endif				
+		{
+			
+			RadioA_ArrayLen = RadioA_1TArrayLength;
+			Rtl819XRadioA_Array_Table=(u32*)Rtl819XRadioA_1TArray;
+
+			RadioB_ArrayLen = RadioB_1TArrayLength;
+			Rtl819XRadioB_Array_Table = (u32*)Rtl819XRadioB_1TArray;
+		}
+
+	}
+
+	switch(eRFPath){
+		case RF90_PATH_A:
+			for(i = 0;i<RadioA_ArrayLen; i=i+2)
+			{
+				if(Rtl819XRadioA_Array_Table[i] == 0xfe)
+					rtw_mdelay_os(50);
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfd)
+					rtw_mdelay_os(5);
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfc)
+					rtw_mdelay_os(1);
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfb)
+					rtw_udelay_os(50);
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfa)
+					rtw_udelay_os(5);
+				else if (Rtl819XRadioA_Array_Table[i] == 0xf9)
+					rtw_udelay_os(1);
+				else
+				{
+					PHY_SetRFReg(Adapter, eRFPath, Rtl819XRadioA_Array_Table[i], bRFRegOffsetMask, Rtl819XRadioA_Array_Table[i+1]);
+					// Add 1us delay between BB/RF register setting.
+					rtw_udelay_os(1);
+				}
+			}			
+			//Add for High Power PA
+			PHY_ConfigRFExternalPA(Adapter, eRFPath);
+			break;
+		case RF90_PATH_B:
+			for(i = 0;i<RadioB_ArrayLen; i=i+2)
+			{
+				if(Rtl819XRadioB_Array_Table[i] == 0xfe)
+				{ // Deay specific ms. Only RF configuration require delay.												
+#if (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+					rtw_mdelay_os(1000);
+#else
+					rtw_mdelay_os(50);
+#endif
+				}
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfd)
+					rtw_mdelay_os(5);
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfc)
+					rtw_mdelay_os(1);
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfb)
+					rtw_udelay_os(50);
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfa)
+					rtw_udelay_os(5);
+				else if (Rtl819XRadioB_Array_Table[i] == 0xf9)
+					rtw_udelay_os(1);
+				else
+				{
+					PHY_SetRFReg(Adapter, eRFPath, Rtl819XRadioB_Array_Table[i], bRFRegOffsetMask, Rtl819XRadioB_Array_Table[i+1]);
+					// Add 1us delay between BB/RF register setting.
+					rtw_udelay_os(1);
+				}	
+			}			
+			break;
+		case RF90_PATH_C:
+			break;
+		case RF90_PATH_D:
+			break;
+	}
+	
+	return _SUCCESS;
+
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_CheckBBAndRFOK()
+ *
+ * Overview:    This function is write register and then readback to make sure whether
+ *			  BB[PHY0, PHY1], RF[Patha, path b, path c, path d] is Ok
+ *
+ * Input:      	PADAPTER			Adapter
+ *			HW90_BLOCK_E		CheckBlock
+ *			RF90_RADIO_PATH_E	eRFPath		// it is used only when CheckBlock is HW90_BLOCK_RF
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: PHY is OK
+ *			
+ * Note:		This function may be removed in the ASIC
+ *---------------------------------------------------------------------------*/
+int
+PHY_CheckBBAndRFOK(
+	IN	PADAPTER			Adapter,
+	IN	HW90_BLOCK_E		CheckBlock,
+	IN	RF90_RADIO_PATH_E	eRFPath
+	)
+{
+	int			rtStatus = _SUCCESS;
+
+	u32				i, CheckTimes = 4,ulRegRead;
+
+	u32				WriteAddr[4];
+	u32				WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};
+
+	// Initialize register address offset to be checked
+	WriteAddr[HW90_BLOCK_MAC] = 0x100;
+	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
+	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
+	WriteAddr[HW90_BLOCK_RF] = 0x3;
+	
+	for(i=0 ; i < CheckTimes ; i++)
+	{
+
+		//
+		// Write Data to register and readback
+		//
+		switch(CheckBlock)
+		{
+		case HW90_BLOCK_MAC:
+			//RT_ASSERT(FALSE, ("PHY_CheckBBRFOK(): Never Write 0x100 here!"));
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PHY_CheckBBRFOK(): Never Write 0x100 here!\n"));
+			break;
+			
+		case HW90_BLOCK_PHY0:
+		case HW90_BLOCK_PHY1:
+			rtw_write32(Adapter, WriteAddr[CheckBlock], WriteData[i]);
+			ulRegRead = rtw_read32(Adapter, WriteAddr[CheckBlock]);
+			break;
+
+		case HW90_BLOCK_RF:
+			// When initialization, we want the delay function(delay_ms(), delay_us() 
+			// ==> actually we call PlatformStallExecution()) to do NdisStallExecution()
+			// [busy wait] instead of NdisMSleep(). So we acquire RT_INITIAL_SPINLOCK 
+			// to run at Dispatch level to achive it.	
+			//cosa PlatformAcquireSpinLock(Adapter, RT_INITIAL_SPINLOCK);
+			WriteData[i] &= 0xfff;
+			PHY_SetRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask, WriteData[i]);
+			// TODO: we should not delay for such a long time. Ask SD3
+			rtw_mdelay_os(10);
+			ulRegRead = PHY_QueryRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bMaskDWord);				
+			rtw_mdelay_os(10);
+			//cosa PlatformReleaseSpinLock(Adapter, RT_INITIAL_SPINLOCK);
+			break;
+			
+		default:
+			rtStatus = _FAIL;
+			break;
+		}
+
+
+		//
+		// Check whether readback data is correct
+		//
+		if(ulRegRead != WriteData[i])
+		{
+			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("ulRegRead: %lx, WriteData: %lx \n", ulRegRead, WriteData[i]));
+			rtStatus = _FAIL;			
+			break;
+		}
+	}
+
+	return rtStatus;
+}
+
+#if 0
+VOID
+PHY_SetRFPowerState8192SUsb(
+	IN	PADAPTER		Adapter,
+	IN	RF_POWER_STATE	RFPowerState
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	BOOLEAN			WaitShutDown = FALSE;
+	//RF90_RADIO_PATH_E	eRFPath;
+	u1Byte				eRFPath;
+	BB_REGISTER_DEFINITION_T	*pPhyReg;
+	
+	if(pHalData->SetRFPowerStateInProgress == TRUE)
+		return;
+	
+	pHalData->SetRFPowerStateInProgress = TRUE;
+	
+	// TODO: Emily, 2006.11.21, we should rewrite this function
+
+	if(RFPowerState==RF_SHUT_DOWN)
+	{
+		RFPowerState=RF_OFF;
+		WaitShutDown=TRUE;
+	}
+	
+	
+	pHalData->RFPowerState = RFPowerState;
+	switch( pHalData->RFChipID )
+	{
+	case RF_8225:
+	case RF_6052:
+		switch( RFPowerState )
+		{
+		case RF_ON:
+			break;
+	
+		case RF_SLEEP:
+			break;
+	
+		case RF_OFF:
+			break;
+		}
+		break;
+
+	case RF_8256:
+		switch( RFPowerState )
+		{
+		case RF_ON:
+			break;
+	
+		case RF_SLEEP:
+			break;
+	
+		case RF_OFF:
+			for(eRFPath=(RF90_RADIO_PATH_E)RF90_PATH_A; eRFPath < RF90_PATH_MAX; eRFPath++)
+			{
+				if (!Adapter->HalFunc.PHYCheckIsLegalRfPathHandler(Adapter, eRFPath))		
+					continue;	
+				
+				pPhyReg = &pHalData->PHYRegDef[eRFPath];
+				PHY_SetBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV, bRFSI_RFENV);
+				PHY_SetBBReg(Adapter, pPhyReg->rfintfo, bRFSI_RFENV, 0);
+			}
+			break;
+		}
+		break;
+		
+	case RF_8258:
+		break;
+	}// switch( pHalData->RFChipID )
+
+	pHalData->SetRFPowerStateInProgress = FALSE;
+}
+#endif
+
+extern	VOID
+PHY_GetHWRegOriginalValue(
+	IN	PADAPTER		Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	// read rx initial gain
+	pHalData->DefaultInitialGain[0] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XAAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[1] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XBAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[2] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XCAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[3] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XDAGCCore1, bMaskByte0);
+	//RT_TRACE(COMP_INIT, DBG_LOUD,
+	//("Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x) \n", 
+	//pHalData->DefaultInitialGain[0], pHalData->DefaultInitialGain[1], 
+	//pHalData->DefaultInitialGain[2], pHalData->DefaultInitialGain[3]));
+
+	// read framesync
+	pHalData->framesync = (u8)PHY_QueryBBReg(Adapter, rOFDM0_RxDetector3, bMaskByte0);	 
+	pHalData->framesyncC34 = PHY_QueryBBReg(Adapter, rOFDM0_RxDetector2, bMaskDWord);
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Default framesync (0x%x) = 0x%x \n", 
+	//	rOFDM0_RxDetector3, pHalData->framesync));
+}
+
+
+
+/**
+* Function:	phy_InitBBRFRegisterDefinition
+*
+* OverView:	Initialize Register definition offset for Radio Path A/B/C/D
+*
+* Input:
+*			PADAPTER		Adapter,
+*
+* Output:	None
+* Return:		None
+* Note:		The initialization value is constant and it should never be changes
+*/
+static	VOID
+phy_InitBBRFRegisterDefinition(
+	IN	PADAPTER		Adapter
+)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);	
+
+	// RF Interface Sowrtware Control
+	pHalData->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 LSBs if read 32-bit from 0x870
+	pHalData->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872)
+	pHalData->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 LSBs if read 32-bit from 0x874
+	pHalData->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 MSBs if read 32-bit from 0x874 (16-bit for 0x876)
+
+	// RF Interface Readback Value
+	pHalData->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; // 16 LSBs if read 32-bit from 0x8E0	
+	pHalData->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2)
+	pHalData->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 LSBs if read 32-bit from 0x8E4
+	pHalData->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6)
+
+	// RF Interface Output (and Enable)
+	pHalData->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x860
+	pHalData->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x864
+
+	// RF Interface (Output and)  Enable
+	pHalData->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x860 (16-bit for 0x862)
+	pHalData->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x864 (16-bit for 0x866)
+
+	//Addr of LSSI. Wirte RF register by driver
+	pHalData->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter; //LSSI Parameter
+	pHalData->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;
+
+	// RF parameter
+	pHalData->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;  //BB Band Select
+	pHalData->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;
+	pHalData->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;
+	pHalData->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;
+
+	// Tx AGC Gain Stage (same for all path. Should we remove this?)
+	pHalData->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+	pHalData->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+	pHalData->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+	pHalData->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
+
+	// Tranceiver A~D HSSI Parameter-1
+	pHalData->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;  //wire control parameter1
+	pHalData->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;  //wire control parameter1
+
+	// Tranceiver A~D HSSI Parameter-2
+	pHalData->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;  //wire control parameter2
+	pHalData->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;  //wire control parameter2
+
+	// RF switch Control
+	pHalData->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl; //TR/Ant switch control
+	pHalData->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;
+	pHalData->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;
+	pHalData->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;
+
+	// AGC control 1 
+	pHalData->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;
+	pHalData->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;
+	pHalData->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;
+	pHalData->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;
+
+	// AGC control 2 
+	pHalData->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;
+	pHalData->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;
+	pHalData->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;
+	pHalData->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;
+
+	// RX AFE control 1 
+	pHalData->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;
+	pHalData->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;
+	pHalData->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;
+	pHalData->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;	
+
+	// RX AFE control 1  
+	pHalData->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;
+	pHalData->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;
+	pHalData->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;
+	pHalData->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;	
+
+	// Tx AFE control 1 
+	pHalData->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;
+	pHalData->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;
+	pHalData->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;
+	pHalData->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;	
+
+	// Tx AFE control 2 
+	pHalData->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;
+	pHalData->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;
+	pHalData->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;
+	pHalData->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;	
+
+	// Tranceiver LSSI Readback SI mode 
+	pHalData->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;
+	pHalData->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;
+	pHalData->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;
+	pHalData->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;	
+
+	// Tranceiver LSSI Readback PI mode 
+	pHalData->PHYRegDef[RF90_PATH_A].rfLSSIReadBackPi = TransceiverA_HSPI_Readback;
+	pHalData->PHYRegDef[RF90_PATH_B].rfLSSIReadBackPi = TransceiverB_HSPI_Readback;
+	//pHalData->PHYRegDef[RF90_PATH_C].rfLSSIReadBackPi = rFPGA0_XC_LSSIReadBack;
+	//pHalData->PHYRegDef[RF90_PATH_D].rfLSSIReadBackPi = rFPGA0_XD_LSSIReadBack;	
+
+}
+
+#if 0
+//
+//	Description: 
+//		Change RF power state.
+//
+//	Assumption:	
+//		This function must be executed in re-schdulable context, 
+//		ie. PASSIVE_LEVEL.
+//
+//	050823, by rcnjko.
+//
+extern	BOOLEAN
+PHY_SetRFPowerState(
+	IN	PADAPTER			Adapter, 
+	IN	RT_RF_POWER_STATE	eRFPowerState
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	BOOLEAN			bResult = FALSE;
+
+	RT_TRACE(COMP_RF, DBG_LOUD, ("---------> PHY_SetRFPowerState(): eRFPowerState(%d)\n", eRFPowerState));
+	if(eRFPowerState == pHalData->eRFPowerState)
+	{
+		RT_TRACE(COMP_RF, DBG_LOUD, ("<--------- PHY_SetRFPowerState(): discard the request for eRFPowerState(%d) is the same.\n", eRFPowerState));
+		return bResult;
+	}
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+	bResult = phy_SetRFPowerState8192SE(Adapter, eRFPowerState);
+#elif (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+	bResult = phy_SetRFPowerState8192CU(Adapter, eRFPowerState);
+#endif
+		
+	RT_TRACE(COMP_RF, DBG_LOUD, ("<--------- PHY_SetRFPowerState(): bResult(%d)\n", bResult));
+
+	return bResult;
+}
+
+
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_SetRtl8192seRfHalt()
+ *
+ * Overview:	For different power save scheme. Reboot/Halt(S3/S4)/SW radio/
+ *				SW radio/IPS will call the scheme.
+ *
+ * Input:		IN	PADAPTER	pAdapter
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	03/27/2009	MHC		Merge from Macro SET_RTL8192SE_RF_HALT
+ *						Because we need to send some parameter to the funtion.
+ *						Macro is hard to maintain larger code.
+ *
+ *---------------------------------------------------------------------------*/
+extern	void	
+PHY_SetRtl8192seRfHalt(		IN	PADAPTER	pAdapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	u1Byte			u1bTmp;
+	
+	
+}	// PHY_SetRtl8192seRfHalt
+
+
+//
+// Description:
+//	Set the RF power state for 8192SE.
+// Note:
+//	This function may turn off the radio like halting the adapter, so when the eRFPowerState is eRFOn it may
+//	mean that the NIC should be re-initialized.
+// By Bruce, 2008-12-25.
+//
+BOOLEAN
+phy_SetRFPowerState8192SE(
+	IN	PADAPTER			Adapter,
+	IN	RT_RF_POWER_STATE	eRFPowerState
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	BOOLEAN			bResult = TRUE;
+	u1Byte			i, QueueID;
+	PRT_POWER_SAVE_CONTROL	pPSC = GET_POWER_SAVE_CONTROL(pMgntInfo);
+	
+	pHalData->SetRFPowerStateInProgress = TRUE;
+	
+	switch(pHalData->RFChipID )
+	{
+		default:	// RL6052 for 8192S now!!!
+		switch( eRFPowerState )
+		{
+			//
+			// SW radio on/IPS site survey call will execute all flow
+			// HW radio on
+			//
+			case eRfOn:
+				{
+				#if(MUTUAL_AUTHENTICATION == 1)
+					if(pHalData->MutualAuthenticationFail)
+						break;
+				#endif
+					if((pHalData->eRFPowerState == eRfOff) && RT_IN_PS_LEVEL(Adapter, RT_RF_OFF_LEVL_HALT_NIC))
+					{ // The current RF state is OFF and the RF OFF level is halting the NIC, re-initialize the NIC.
+						RT_STATUS rtstatus;
+						u4Byte InitializeCount = 0;
+						do
+						{	
+							InitializeCount++;
+							rtstatus = NicIFEnableNIC( Adapter );
+						}while( (rtstatus != RT_STATUS_SUCCESS) &&(InitializeCount <10) );
+						RT_ASSERT(rtstatus == RT_STATUS_SUCCESS,("Nic Initialize Fail\n"));
+						RT_CLEAR_PS_LEVEL(Adapter, RT_RF_OFF_LEVL_HALT_NIC);
+					}
+					else
+					{ // This is the normal case, we just turn on the RF.
+//						PlatformEFIOWrite2Byte(Adapter, CMDR, 0x37FC);
+//						PlatformEFIOWrite1Byte(Adapter, TXPAUSE, 0x00);
+//						PlatformEFIOWrite1Byte(Adapter, PHY_CCA, 0x3);
+						phy_SetRTL8192CERfOn(Adapter);
+					}
+			
+					// Turn on RF we are still linked, which might happen when 
+					// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
+					if( pMgntInfo->bMediaConnect == TRUE )
+					{
+						Adapter->ledpriv.LedControlHandler(Adapter, LED_CTL_LINK); 
+					}
+					else
+					{
+						// Turn off LED if RF is not ON.
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK); 
+					}
+				}
+				break;
+			// 
+			// Card Disable/SW radio off/HW radio off/IPS enter call
+			//
+			case eRfOff:
+				{					
+				// Make sure BusyQueue is empty befor turn off RFE pwoer.
+				for(QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; )
+				{
+					if(RTIsListEmpty(&Adapter->TcbBusyQueue[QueueID]))
+					{
+						//DbgPrint("QueueID = %d", QueueID);
+						QueueID++;
+						continue;
+					}
+					#if( DEV_BUS_TYPE==DEV_BUS_PCI_INTERFACE)
+					else if(IsLowPowerState(Adapter))
+					{
+							RT_TRACE(COMP_POWER, DBG_LOUD, 
+							("eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 but lower power state!\n", (i+1), QueueID));
+						break;
+					}
+					#endif
+					else
+					{
+							RT_TRACE(COMP_POWER, DBG_LOUD, 
+							("eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 before doze!\n", (i+1), QueueID));
+							PlatformStallExecution(10);
+						i++;
+					}
+					
+					if(i >= MAX_DOZE_WAITING_TIMES_9x)
+					{
+						RT_TRACE(COMP_POWER, DBG_WARNING, ("\n\n\n SetZebraRFPowerState8185B(): eRfOff: %d times TcbBusyQueue[%d] != 0 !!!\n\n\n", MAX_DOZE_WAITING_TIMES_9x, QueueID));
+						break;
+					}
+				}			
+
+					if(pPSC->RegRfPsLevel & RT_RF_OFF_LEVL_HALT_NIC)
+					{ // Disable all components.
+						// why not just call haltadapter92se ?? neo 2009 1,3
+						//PHY_SetRtl8192seRfHalt(Adapter);
+						NicIFDisableNIC(Adapter);
+						RT_SET_PS_LEVEL(Adapter, RT_RF_OFF_LEVL_HALT_NIC);
+						if(pHalData->pwrdown && pMgntInfo->RfOffReason>= RF_CHANGE_BY_HW)
+							PlatformEFIOWrite1Byte(Adapter,0x03,0x31);
+					} 
+					else
+					{ // Normal case.
+						//SET_RTL8192SE_RF_SLEEP(Adapter);
+		
+						//
+						//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
+						//
+						if(pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )
+						{
+							Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK); 
+						}
+						else
+						{
+							// Turn off LED if RF is not ON.
+							Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF); 
+						}
+					}
+				}
+					break;
+				
+			case eRfSleep:
+				{
+					// HW setting had been configured with deeper mode.
+					if(pHalData->eRFPowerState == eRfOff)
+						break;
+					
+					// Make sure BusyQueue is empty befor turn off RFE pwoer.
+					for(QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; )
+					{
+						if(RTIsListEmpty(&Adapter->TcbBusyQueue[QueueID]))
+						{
+							QueueID++;
+							continue;
+						}
+#if( DEV_BUS_TYPE==DEV_BUS_PCI_INTERFACE)
+						else if(IsLowPowerState(Adapter))
+						{
+							RT_TRACE(COMP_POWER, DBG_LOUD, ("eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 but lower power state!\n", (i+1), QueueID));
+							break;
+						}
+#endif
+					else
+					{
+						RT_TRACE(COMP_POWER, DBG_LOUD, ("eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 before doze!\n", (i+1), QueueID));
+						PlatformStallExecution(10);
+						i++;
+					}
+						
+						if(i >= MAX_DOZE_WAITING_TIMES_9x)
+						{
+							RT_TRACE(COMP_POWER, DBG_WARNING, ("\n\n\n SetZebraRFPowerState8185B(): eRfOff: %d times TcbBusyQueue[%d] != 0 !!!\n\n\n", MAX_DOZE_WAITING_TIMES_9x, QueueID));
+							break;
+						}
+					}		
+
+					phy_SetRTL8192CERfSleep(Adapter);
+				}
+				break;
+				
+				default:
+				bResult = FALSE;
+				RT_ASSERT(FALSE, ("phy_SetRFPowerState8192S(): unknow state to set: 0x%X!!!\n", eRFPowerState));
+					break;
+		} 
+				break;
+	}
+
+	if(bResult)
+	{
+		// Update current RF state variable.
+		pHalData->eRFPowerState = eRFPowerState;
+	}
+	
+	pHalData->SetRFPowerStateInProgress = FALSE;
+
+	return bResult;
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_SwitchEphyParameter()
+ *
+ * Overview:	To prevent ASPM error. We need to change some EPHY parameter to 
+ *			replace HW autoload value..
+ *
+ * Input:		IN	PADAPTER			pAdapter
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	12/26/2008	MHC		Create. The flow is refered to DD PCIE.
+ *
+ *---------------------------------------------------------------------------*/
+VOID
+PHY_SwitchEphyParameter(
+	IN	PADAPTER			Adapter
+	)
+{
+	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(Adapter);
+
+	
+}	// PHY_SwitchEphyParameter
+
+
+
+#endif
+
+#if (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+//
+// Description:
+//	Set the RF power state for 8192CU.
+// Note:
+//	This function may turn off the radio like halting the adapter, so when the eRFPowerState is eRFOn it may
+//	mean that the NIC should be re-initialized.
+// By Bruce, 2008-12-25.
+//
+
+BOOLEAN
+phy_SetRFPowerState8192CU(
+	IN	PADAPTER			Adapter,
+	IN	RT_RF_POWER_STATE	eRFPowerState
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	BOOLEAN			bResult = TRUE;
+	u1Byte			i, QueueID;
+	u1Byte			u1bTmp;
+	
+	if(pHalData->SetRFPowerStateInProgress == TRUE)
+		return FALSE;
+	
+	pHalData->SetRFPowerStateInProgress = TRUE;
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("======> phy_SetRFPowerState8192CU .\n"));
+	switch(pHalData->RFChipID )
+	{
+		default:
+		switch( eRFPowerState )
+		{
+			case eRfOn:
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("======> phy_SetRFPowerState8192CU-eRfOn .\n"));			
+				NicIFEnableNIC(Adapter);
+				break;
+    	    
+			// 
+			// In current solution, RFSleep=RFOff in order to save power under 802.11 power save.
+			// By Bruce, 2008-01-16.
+			//
+			case eRfSleep:
+			case eRfOff:
+				// HW setting had been configured.
+				// Both of these RF configures are the same, configuring twice may cause HW abnormal.
+				if(pHalData->eRFPowerState == eRfSleep || pHalData->eRFPowerState== eRfOff)
+					break;
+				
+				// Make sure BusyQueue is empty befor turn off RFE pwoer.
+				for(QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; )
+				{
+					if(RTIsListEmpty(&Adapter->TcbBusyQueue[QueueID]))
+					{
+						//DbgPrint("QueueID = %d", QueueID);
+						QueueID++;
+						continue;
+					}					
+					else
+					{
+						RT_TRACE(COMP_POWER, DBG_LOUD, ("eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 before doze!\n", (i+1), QueueID));
+						PlatformSleepUs(10);
+						i++;
+					}
+					
+					if(i >= MAX_DOZE_WAITING_TIMES_9x)
+					{
+						RT_TRACE(COMP_POWER, DBG_WARNING, ("\n\n\n SetZebraRFPowerState8185B(): eRfOff: %d times TcbBusyQueue[%d] != 0 !!!\n\n\n", MAX_DOZE_WAITING_TIMES_9x, QueueID));
+						break;
+					}
+				}				
+
+				// 
+				//RF Off/Sleep sequence. Designed/tested from SD4 Scott, SD1 Grent and Jonbon.
+				// Added by 
+				//
+				//==================================================================
+
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("======> CardDisableWithoutHWSM -eRfOff.\n"));				
+				CardDisableWithoutHWSM( Adapter);
+	
+				break;
+
+			default:
+				bResult = FALSE;
+				RT_ASSERT(FALSE, ("phy_SetRFPowerState8192S(): unknow state to set: 0x%X!!!\n", eRFPowerState));
+				break;
+		} 
+		break;
+	}
+			
+	if(bResult)
+	{
+		// Update current RF state variable.
+		pHalData->eRFPowerState = eRFPowerState;
+		
+		switch(pHalData->RFChipID )
+		{
+			default:		
+			switch(pHalData->eRFPowerState)
+			{
+				case eRfOff:
+					//
+					//If Rf off reason is from IPS, Led should blink with no link, by Maddest 071015
+					//
+					if(pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )
+					{
+						Adapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK); 
+					}
+					else
+					{
+						// Turn off LED if RF is not ON.
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF); 
+					}
+					break;
+        		
+				case eRfOn:
+					// Turn on RF we are still linked, which might happen when 
+					// we quickly turn off and on HW RF. 2006.05.12, by rcnjko.
+					if( pMgntInfo->bMediaConnect == TRUE )
+					{
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK); 
+					}
+					else
+					{
+						// Turn off LED if RF is not ON.
+						Adapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK); 
+					}
+					break;
+        		
+				default:
+					// do nothing.
+					break;
+			}// Switch RF state
+
+				break;
+		}// Switch RFChipID
+	}
+	
+	pHalData->SetRFPowerStateInProgress = FALSE;
+
+	return bResult;
+}
+#endif
+#endif
+
+/*-----------------------------------------------------------------------------
+ * Function:    GetTxPowerLevel8190()
+ *
+ * Overview:    This function is export to "common" moudule
+ *
+ * Input:       PADAPTER		Adapter
+ *			psByte			Power Level
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ *---------------------------------------------------------------------------*/
+extern	VOID
+PHY_GetTxPowerLevel8192C(
+	IN	PADAPTER		Adapter,
+	OUT u32*    		powerlevel
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u8			TxPwrLevel = 0;
+	int			TxPwrDbm;
+	
+	//
+	// Because the Tx power indexes are different, we report the maximum of them to 
+	// meet the CCX TPC request. By Bruce, 2008-01-31.
+	//
+
+	// CCK
+	TxPwrLevel = pHalData->CurrentCckTxPwrIdx;
+	TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_B, TxPwrLevel);
+
+	// Legacy OFDM
+	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx + pHalData->LegacyHTTxPowerDiff;
+
+	// Compare with Legacy OFDM Tx power.
+	if(phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel) > TxPwrDbm)
+		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel);
+
+	// HT OFDM
+	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx;
+	
+	// Compare with HT OFDM Tx power.
+	if(phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
+		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel);
+
+	*powerlevel = TxPwrDbm;
+}
+
+
+void getTxPowerIndex(
+	IN	PADAPTER		Adapter,
+	IN	u8			channel,
+	IN OUT u8*		cckPowerLevel,
+	IN OUT u8*		ofdmPowerLevel
+	)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	u8				index = (channel -1);
+	// 1. CCK
+	cckPowerLevel[RF90_PATH_A] = pEEPROM->TxPwrLevelCck[RF90_PATH_A][index];	//RF-A
+	cckPowerLevel[RF90_PATH_B] = pEEPROM->TxPwrLevelCck[RF90_PATH_B][index];	//RF-B
+
+	// 2. OFDM for 1S or 2S
+	if (GET_RF_TYPE(Adapter) == RF_1T2R || GET_RF_TYPE(Adapter) == RF_1T1R)
+	{
+		// Read HT 40 OFDM TX power
+		ofdmPowerLevel[RF90_PATH_A] = pEEPROM->TxPwrLevelHT40_1S[RF90_PATH_A][index];
+		ofdmPowerLevel[RF90_PATH_B] = pEEPROM->TxPwrLevelHT40_1S[RF90_PATH_B][index];
+	}
+	else if (GET_RF_TYPE(Adapter) == RF_2T2R)
+	{
+		// Read HT 40 OFDM TX power
+		ofdmPowerLevel[RF90_PATH_A] = pEEPROM->TxPwrLevelHT40_2S[RF90_PATH_A][index];
+		ofdmPowerLevel[RF90_PATH_B] = pEEPROM->TxPwrLevelHT40_2S[RF90_PATH_B][index];
+	}
+	//RTPRINT(FPHY, PHY_TXPWR, ("Channel-%d, set tx power index !!\n", channel));
+}
+
+void ccxPowerIndexCheck(
+	IN	PADAPTER		Adapter,
+	IN	u8			channel,
+	IN OUT u8*		cckPowerLevel,
+	IN OUT u8*		ofdmPowerLevel
+	)
+{
+#if 0
+	PMGNT_INFO			pMgntInfo = &(Adapter->MgntInfo);
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PRT_CCX_INFO		pCcxInfo = GET_CCX_INFO(pMgntInfo);
+
+	//
+	// CCX 2 S31, AP control of client transmit power:
+	// 1. We shall not exceed Cell Power Limit as possible as we can.
+	// 2. Tolerance is +/- 5dB.
+	// 3. 802.11h Power Contraint takes higher precedence over CCX Cell Power Limit.
+	// 
+	// TODO: 
+	// 1. 802.11h power contraint 
+	//
+	// 071011, by rcnjko.
+	//
+	if(	pMgntInfo->OpMode == RT_OP_MODE_INFRASTRUCTURE && 
+		pMgntInfo->mAssoc &&
+		pCcxInfo->bUpdateCcxPwr &&
+		pCcxInfo->bWithCcxCellPwr &&
+		channel == pMgntInfo->dot11CurrentChannelNumber)
+	{
+		u1Byte	CckCellPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_B, pCcxInfo->CcxCellPwr);
+		u1Byte	LegacyOfdmCellPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_G, pCcxInfo->CcxCellPwr);
+		u1Byte	OfdmCellPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_N_24G, pCcxInfo->CcxCellPwr);
+
+		RT_TRACE(COMP_TXAGC, DBG_LOUD, 
+		("CCX Cell Limit: %d dbm => CCK Tx power index : %d, Legacy OFDM Tx power index : %d, OFDM Tx power index: %d\n", 
+		pCcxInfo->CcxCellPwr, CckCellPwrIdx, LegacyOfdmCellPwrIdx, OfdmCellPwrIdx));
+		RT_TRACE(COMP_TXAGC, DBG_LOUD, 
+		("EEPROM channel(%d) => CCK Tx power index: %d, Legacy OFDM Tx power index : %d, OFDM Tx power index: %d\n",
+		channel, cckPowerLevel[0], ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff, ofdmPowerLevel[0])); 
+
+		// CCK
+		if(cckPowerLevel[0] > CckCellPwrIdx)
+			cckPowerLevel[0] = CckCellPwrIdx;
+		// Legacy OFDM, HT OFDM
+		if(ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff > LegacyOfdmCellPwrIdx)
+		{
+			if((OfdmCellPwrIdx - pHalData->LegacyHTTxPowerDiff) > 0)
+			{
+				ofdmPowerLevel[0] = OfdmCellPwrIdx - pHalData->LegacyHTTxPowerDiff;
+			}
+			else
+			{
+				ofdmPowerLevel[0] = 0;
+			}
+		}
+
+		RT_TRACE(COMP_TXAGC, DBG_LOUD, 
+		("Altered CCK Tx power index : %d, Legacy OFDM Tx power index: %d, OFDM Tx power index: %d\n", 
+		cckPowerLevel[0], ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff, ofdmPowerLevel[0]));
+	}
+
+	pHalData->CurrentCckTxPwrIdx = cckPowerLevel[0];
+	pHalData->CurrentOfdm24GTxPwrIdx = ofdmPowerLevel[0];
+
+	RT_TRACE(COMP_TXAGC, DBG_LOUD, 
+		("PHY_SetTxPowerLevel8192S(): CCK Tx power index : %d, Legacy OFDM Tx power index: %d, OFDM Tx power index: %d\n", 
+		cckPowerLevel[0], ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff, ofdmPowerLevel[0]));
+#endif	
+}
+/*-----------------------------------------------------------------------------
+ * Function:    SetTxPowerLevel8190()
+ *
+ * Overview:    This function is export to "HalCommon" moudule
+ *			We must consider RF path later!!!!!!!
+ *
+ * Input:       PADAPTER		Adapter
+ *			u1Byte		channel
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *	2008/11/04	MHC		We remove EEPROM_93C56.
+ *						We need to move CCX relative code to independet file.
+ *	2009/01/21	MHC		Support new EEPROM format from SD3 requirement.
+ *
+ *---------------------------------------------------------------------------*/
+extern	VOID
+PHY_SetTxPowerLevel8192C(
+	IN	PADAPTER		Adapter,
+	IN	u8			channel
+	)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	u8	cckPowerLevel[2], ofdmPowerLevel[2];	// [0]:RF-A, [1]:RF-B
+
+#if(MP_DRIVER == 1)
+	return;
+#endif
+
+	//if(pHalData->bTXPowerDataReadFromEEPORM == _FALSE)
+	//	return;
+
+	getTxPowerIndex(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
+	//RTPRINT(FPHY, PHY_TXPWR, ("Channel-%d, cckPowerLevel (A / B) = 0x%x / 0x%x,   ofdmPowerLevel (A / B) = 0x%x / 0x%x\n", 
+	//	channel, cckPowerLevel[0], cckPowerLevel[1], ofdmPowerLevel[0], ofdmPowerLevel[1]));
+
+	ccxPowerIndexCheck(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
+
+	PHY_RF6052SetCckTxPower(Adapter, &cckPowerLevel[0]);
+	PHY_RF6052SetOFDMTxPower(Adapter, &ofdmPowerLevel[0], channel);
+
+#if 0
+	switch(pHalData->rf_chip)
+	{
+		case RF_8225:
+			PHY_SetRF8225CckTxPower(Adapter, cckPowerLevel[0]);
+			PHY_SetRF8225OfdmTxPower(Adapter, ofdmPowerLevel[0]);
+		break;
+
+		case RF_8256:
+			PHY_SetRF8256CCKTxPower(Adapter, cckPowerLevel[0]);
+			PHY_SetRF8256OFDMTxPower(Adapter, ofdmPowerLevel[0]);
+			break;
+
+		case RF_6052:
+			PHY_RF6052SetCckTxPower(Adapter, &cckPowerLevel[0]);
+			PHY_RF6052SetOFDMTxPower(Adapter, &ofdmPowerLevel[0], channel);
+			break;
+
+		case RF_8258:
+			break;
+	}
+#endif
+
+}
+
+
+//
+//	Description:
+//		Update transmit power level of all channel supported.
+//
+//	TODO: 
+//		A mode.
+//	By Bruce, 2008-02-04.
+//
+extern	BOOLEAN
+PHY_UpdateTxPowerDbm8192C(
+	IN	PADAPTER	Adapter,
+	IN	int		powerInDbm
+	)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u8				idx;
+	u8			rf_path;
+
+	// TODO: A mode Tx power.
+	u8	CckTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_B, powerInDbm);
+	u8	OfdmTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_N_24G, powerInDbm);
+
+	if(OfdmTxPwrIdx - pHalData->LegacyHTTxPowerDiff > 0)
+		OfdmTxPwrIdx -= pHalData->LegacyHTTxPowerDiff;
+	else
+		OfdmTxPwrIdx = 0;
+
+	//RT_TRACE(COMP_TXAGC, DBG_LOUD, ("PHY_UpdateTxPowerDbm8192S(): %ld dBm , CckTxPwrIdx = %d, OfdmTxPwrIdx = %d\n", powerInDbm, CckTxPwrIdx, OfdmTxPwrIdx));
+
+	for(idx = 0; idx < 14; idx++)
+	{
+		for (rf_path = 0; rf_path < 2; rf_path++)
+		{
+			pEEPROM->TxPwrLevelCck[rf_path][idx] = CckTxPwrIdx;
+			pEEPROM->TxPwrLevelHT40_1S[rf_path][idx] = 
+			pEEPROM->TxPwrLevelHT40_2S[rf_path][idx] = OfdmTxPwrIdx;
+		}
+	}
+
+	//Adapter->HalFunc.SetTxPowerLevelHandler(Adapter, pHalData->CurrentChannel);//gtest:todo
+
+	return _TRUE;	
+}
+
+
+/*
+	Description:
+		When beacon interval is changed, the values of the 
+		hw registers should be modified.
+	By tynli, 2008.10.24.
+
+*/
+
+
+extern void	
+PHY_SetBeaconHwReg(	
+	IN	PADAPTER		Adapter,
+	IN	u16			BeaconInterval	
+	)
+{
+
+}
+
+//
+//	Description:
+//		Map dBm into Tx power index according to 
+//		current HW model, for example, RF and PA, and
+//		current wireless mode.
+//	By Bruce, 2008-01-29.
+//
+static	u8
+phy_DbmToTxPwrIdx(
+	IN	PADAPTER		Adapter,
+	IN	WIRELESS_MODE	WirelessMode,
+	IN	int			PowerInDbm
+	)
+{
+	u8				TxPwrIdx = 0;
+	int				Offset = 0;
+	
+
+	//
+	// Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to 
+	// 3dbm, and OFDM HT equals to 0dbm repectively.
+	// Note:
+	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.  
+	// By Bruce, 2008-01-29.
+	// 
+	switch(WirelessMode)
+	{
+	case WIRELESS_MODE_B:
+		Offset = -7;
+		break;
+
+	case WIRELESS_MODE_G:
+	case WIRELESS_MODE_N_24G:
+		Offset = -8;
+		break;
+	default:
+		Offset = -8;
+		break;
+	}
+
+	if((PowerInDbm - Offset) > 0)
+	{
+		TxPwrIdx = (u8)((PowerInDbm - Offset) * 2);
+	}
+	else
+	{
+		TxPwrIdx = 0;
+	}
+
+	// Tx Power Index is too large.
+	if(TxPwrIdx > MAX_TXPWR_IDX_NMODE_92S)
+		TxPwrIdx = MAX_TXPWR_IDX_NMODE_92S;
+
+	return TxPwrIdx;
+}
+
+//
+//	Description:
+//		Map Tx power index into dBm according to 
+//		current HW model, for example, RF and PA, and
+//		current wireless mode.
+//	By Bruce, 2008-01-29.
+//
+int
+phy_TxPwrIdxToDbm(
+	IN	PADAPTER		Adapter,
+	IN	WIRELESS_MODE	WirelessMode,
+	IN	u8			TxPwrIdx
+	)
+{
+	int				Offset = 0;
+	int				PwrOutDbm = 0;
+	
+	//
+	// Tested by MP, we found that CCK Index 0 equals to -7dbm, OFDM legacy equals to -8dbm.
+	// Note:
+	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.  
+	// By Bruce, 2008-01-29.
+	// 
+	switch(WirelessMode)
+	{
+	case WIRELESS_MODE_B:
+		Offset = -7;
+		break;
+
+	case WIRELESS_MODE_G:
+	case WIRELESS_MODE_N_24G:
+		Offset = -8;
+	default:
+		Offset = -8;	
+		break;
+	}
+
+	PwrOutDbm = TxPwrIdx / 2 + Offset; // Discard the decimal part.
+
+	return PwrOutDbm;
+}
+
+
+extern	VOID 
+PHY_ScanOperationBackup8192C(
+	IN	PADAPTER	Adapter,
+	IN	u8		Operation
+	)
+{
+#if 0
+	IO_TYPE	IoType;
+	
+	if(!Adapter->bDriverStopped)
+	{
+		switch(Operation)
+		{
+			case SCAN_OPT_BACKUP:
+				IoType = IO_CMD_PAUSE_DM_BY_SCAN;
+				Adapter->HalFunc.SetHwRegHandler(Adapter,HW_VAR_IO_CMD,  (pu1Byte)&IoType);
+
+				break;
+
+			case SCAN_OPT_RESTORE:
+				IoType = IO_CMD_RESUME_DM_BY_SCAN;
+				Adapter->HalFunc.SetHwRegHandler(Adapter,HW_VAR_IO_CMD,  (pu1Byte)&IoType);
+				break;
+
+			default:
+				RT_TRACE(COMP_SCAN, DBG_LOUD, ("Unknown Scan Backup Operation. \n"));
+				break;
+		}
+	}
+#endif	
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_SetBWModeCallback8192C()
+ *
+ * Overview:    Timer callback function for SetSetBWMode
+ *
+ * Input:       	PRT_TIMER		pTimer
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Note:		(1) We do not take j mode into consideration now
+ *			(2) Will two workitem of "switch channel" and "switch channel bandwidth" run
+ *			     concurrently?
+ *---------------------------------------------------------------------------*/
+VOID
+_PHY_SetBWMode92C(
+	IN	PADAPTER	Adapter
+)
+{
+//	PADAPTER			Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	u8				regBwOpMode;
+	u8				regRRSR_RSC;
+
+	//return;
+
+	// Added it for 20/40 mhz switch time evaluation by guangan 070531
+	//u4Byte				NowL, NowH;
+	//u8Byte				BeginTime, EndTime; 
+
+	/*RT_TRACE(COMP_SCAN, DBG_LOUD, ("==>PHY_SetBWModeCallback8192C()  Switch to %s bandwidth\n", \
+					pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz"))*/
+
+	if(pHalData->rf_chip == RF_PSEUDO_11N)
+	{
+		//pHalData->SetBWModeInProgress= _FALSE;
+		return;
+	}
+
+	// There is no 40MHz mode in RF_8225.
+	if(pHalData->rf_chip==RF_8225)
+		return;
+
+	if(Adapter->bDriverStopped)
+		return;
+
+	// Added it for 20/40 mhz switch time evaluation by guangan 070531
+	//NowL = PlatformEFIORead4Byte(Adapter, TSFR);
+	//NowH = PlatformEFIORead4Byte(Adapter, TSFR+4);
+	//BeginTime = ((u8Byte)NowH << 32) + NowL;
+		
+	//3//
+	//3//<1>Set MAC register
+	//3//
+	//Adapter->HalFunc.SetBWModeHandler();
+	
+	regBwOpMode = rtw_read8(Adapter, REG_BWOPMODE);
+	regRRSR_RSC = rtw_read8(Adapter, REG_RRSR+2);
+	//regBwOpMode = Adapter->HalFunc.GetHwRegHandler(Adapter,HW_VAR_BWMODE,(pu1Byte)&regBwOpMode);
+	
+	switch(pHalData->CurrentChannelBW)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			regBwOpMode |= BW_OPMODE_20MHZ;
+			   // 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
+			break;
+			   
+		case HT_CHANNEL_WIDTH_40:
+			regBwOpMode &= ~BW_OPMODE_20MHZ;
+				// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
+
+			regRRSR_RSC = (regRRSR_RSC&0x90) |(pHalData->nCur40MhzPrimeSC<<5);
+			rtw_write8(Adapter, REG_RRSR+2, regRRSR_RSC);
+			break;
+
+		default:
+			/*RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetBWModeCallback8192C():
+						unknown Bandwidth: %#X\n",pHalData->CurrentChannelBW));*/
+			break;
+	}
+	
+	//3//
+	//3//<2>Set PHY related register
+	//3//
+	switch(pHalData->CurrentChannelBW)
+	{
+		/* 20 MHz channel*/
+		case HT_CHANNEL_WIDTH_20:
+			PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bRFMOD, 0x0);
+			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x0);
+			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10, 1);
+			
+			break;
+
+
+		/* 40 MHz channel*/
+		case HT_CHANNEL_WIDTH_40:
+			PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bRFMOD, 0x1);
+			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x1);
+			
+			// Set Control channel to upper or lower. These settings are required only for 40MHz
+			PHY_SetBBReg(Adapter, rCCK0_System, bCCKSideBand, (pHalData->nCur40MhzPrimeSC>>1));
+			PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0xC00, pHalData->nCur40MhzPrimeSC);
+			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10, 0);
+
+			PHY_SetBBReg(Adapter, 0x818, (BIT26|BIT27), (pHalData->nCur40MhzPrimeSC==HAL_PRIME_CHNL_OFFSET_LOWER)?2:1);
+			
+			break;
+
+
+			
+		default:
+			/*RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetBWModeCallback8192C(): unknown Bandwidth: %#X\n"\
+						,pHalData->CurrentChannelBW));*/
+			break;
+			
+	}
+	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
+
+	// Added it for 20/40 mhz switch time evaluation by guangan 070531
+	//NowL = PlatformEFIORead4Byte(Adapter, TSFR);
+	//NowH = PlatformEFIORead4Byte(Adapter, TSFR+4);
+	//EndTime = ((u8Byte)NowH << 32) + NowL;
+	//RT_TRACE(COMP_SCAN, DBG_LOUD, ("SetBWModeCallback8190Pci: time of SetBWMode = %I64d us!\n", (EndTime - BeginTime)));
+
+	//3<3>Set RF related register
+	switch(pHalData->rf_chip)
+	{
+		case RF_8225:		
+			//PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
+			break;	
+			
+		case RF_8256:
+			// Please implement this function in Hal8190PciPhy8256.c
+			//PHY_SetRF8256Bandwidth(Adapter, pHalData->CurrentChannelBW);
+			break;
+			
+		case RF_8258:
+			// Please implement this function in Hal8190PciPhy8258.c
+			// PHY_SetRF8258Bandwidth();
+			break;
+
+		case RF_PSEUDO_11N:
+			// Do Nothing
+			break;
+			
+		case RF_6052:
+			PHY_RF6052SetBandwidth(Adapter, pHalData->CurrentChannelBW);
+			break;	
+			
+		default:
+			//RT_ASSERT(FALSE, ("Unknown RFChipID: %d\n", pHalData->RFChipID));
+			break;
+	}
+
+	//pHalData->SetBWModeInProgress= FALSE;
+
+	//RT_TRACE(COMP_SCAN, DBG_LOUD, ("<==PHY_SetBWModeCallback8192C() \n" ));
+}
+
+#if 0
+extern	VOID
+PHY_SetBWModeCallback8192C(
+	IN	PRT_TIMER		pTimer
+)
+{
+	PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
+
+	_PHY_SetBWMode92C(Adapter);
+}
+#endif
+
+ /*-----------------------------------------------------------------------------
+ * Function:   SetBWMode8190Pci()
+ *
+ * Overview:  This function is export to "HalCommon" moudule
+ *
+ * Input:       	PADAPTER			Adapter
+ *			HT_CHANNEL_WIDTH	Bandwidth	//20M or 40M
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Note:		We do not take j mode into consideration now
+ *---------------------------------------------------------------------------*/
+extern	VOID
+PHY_SetBWMode8192C(
+	IN	PADAPTER					Adapter,
+	IN	HT_CHANNEL_WIDTH	Bandwidth,	// 20M or 40M
+	IN	unsigned char	Offset		// Upper, Lower, or Don't care
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	HT_CHANNEL_WIDTH 	tmpBW= pHalData->CurrentChannelBW;
+	// Modified it for 20/40 mhz switch by guangan 070531
+	//PMGNT_INFO	pMgntInfo=&Adapter->MgntInfo;
+
+	//return;
+	
+	//if(pHalData->SwChnlInProgress)
+//	if(pMgntInfo->bScanInProgress)
+//	{
+//		RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() %s Exit because bScanInProgress!\n", 
+//					Bandwidth == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz"));
+//		return;
+//	}
+
+//	if(pHalData->SetBWModeInProgress)
+//	{
+//		// Modified it for 20/40 mhz switch by guangan 070531
+//		RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() %s cancel last timer because SetBWModeInProgress!\n", 
+//					Bandwidth == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz"));
+//		PlatformCancelTimer(Adapter, &pHalData->SetBWModeTimer);
+//		//return;
+//	}
+
+	//if(pHalData->SetBWModeInProgress)
+	//	return;
+
+	//pHalData->SetBWModeInProgress= TRUE;
+	
+	pHalData->CurrentChannelBW = Bandwidth;
+
+#if 0
+	if(Offset==HT_EXTCHNL_OFFSET_LOWER)
+		pHalData->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;
+	else if(Offset==HT_EXTCHNL_OFFSET_UPPER)
+		pHalData->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;
+	else
+		pHalData->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+#else
+	pHalData->nCur40MhzPrimeSC = Offset;
+#endif
+
+	if((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
+	{
+#ifdef USE_WORKITEM	
+		//PlatformScheduleWorkItem(&(pHalData->SetBWModeWorkItem));
+#else
+	#if 0
+		//PlatformSetTimer(Adapter, &(pHalData->SetBWModeTimer), 0);
+	#else
+		_PHY_SetBWMode92C(Adapter);
+	#endif
+#endif		
+	}
+	else
+	{
+		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() SetBWModeInProgress FALSE driver sleep or unload\n"));	
+		//pHalData->SetBWModeInProgress= FALSE;	
+		pHalData->CurrentChannelBW = tmpBW;
+	}
+	
+}
+
+#if 0
+extern	VOID
+PHY_SwChnlCallback8192C(
+	IN	PRT_TIMER		pTimer
+	)
+{
+	PADAPTER		pAdapter = (PADAPTER)pTimer->Adapter;
+	PADAPTER		Adapter = ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, TRUE);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte			delay;
+	
+	RT_TRACE(COMP_SCAN, DBG_LOUD, ("==>PHY_SwChnlCallback8192C(), switch to channel\
+				%d\n", pHalData->CurrentChannel));
+	
+	if(Adapter->bDriverStopped)
+		return;
+	
+	if(pHalData->RFChipID == RF_PSEUDO_11N)
+	{
+		pHalData->SwChnlInProgress=FALSE;
+		return; 								//return immediately if it is peudo-phy	
+	}
+	
+
+	do{
+		if(!pHalData->SwChnlInProgress)
+			break;
+
+		if(!phy_SwChnlStepByStep(Adapter, pHalData->CurrentChannel, &pHalData->SwChnlStage, &pHalData->SwChnlStep, &delay))
+		{
+			if(delay>0)
+			{
+				PlatformSetTimer(Adapter, &pHalData->SwChnlTimer, delay);
+			}
+			else
+			continue;
+		}
+		else
+		{
+			pHalData->SwChnlInProgress=FALSE;
+		}
+		break;
+	}while(TRUE);
+
+	RT_TRACE(COMP_SCAN, DBG_LOUD, ("<==PHY_SwChnlCallback8192C()\n"));
+}
+#endif
+
+static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
+{
+	u8 eRFPath;
+	u32 param1, param2;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	//s1. pre common command - CmdID_SetTxPowerLevel
+	PHY_SetTxPowerLevel8192C(Adapter, channel);
+
+	//s2. RF dependent command - CmdID_RF_WriteReg, param1=RF_CHNLBW, param2=channel
+	param1 = RF_CHNLBW;
+	param2 = channel;
+	for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	{
+		pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffffc00) | param2);
+		PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, param1, bRFRegOffsetMask, pHalData->RfRegChnlVal[eRFPath]);
+	}
+	
+	
+	//s3. post common command - CmdID_End, None
+
+}
+
+extern	VOID
+PHY_SwChnl8192C(	// Call after initialization
+	IN	PADAPTER	Adapter,
+	IN	u8		channel
+	)
+{
+	//PADAPTER Adapter =  ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, _TRUE);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u8	tmpchannel = pHalData->CurrentChannel;
+	BOOLEAN  bResult = _TRUE;
+
+	if(pHalData->rf_chip == RF_PSEUDO_11N)
+	{
+		//pHalData->SwChnlInProgress=FALSE;
+		return; 								//return immediately if it is peudo-phy	
+	}
+	
+	//if(pHalData->SwChnlInProgress)
+	//	return;
+
+	//if(pHalData->SetBWModeInProgress)
+	//	return;
+
+	//--------------------------------------------
+	switch(pHalData->CurrentWirelessMode)
+	{
+		case WIRELESS_MODE_A:
+		case WIRELESS_MODE_N_5G:
+			//RT_ASSERT((channel>14), ("WIRELESS_MODE_A but channel<=14"));		
+			break;
+		
+		case WIRELESS_MODE_B:
+			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_B but channel>14"));
+			break;
+		
+		case WIRELESS_MODE_G:
+		case WIRELESS_MODE_N_24G:
+			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_G but channel>14"));
+			break;
+
+		default:
+			//RT_ASSERT(FALSE, ("Invalid WirelessMode(%#x)!!\n", pHalData->CurrentWirelessMode));
+			break;
+	}
+	//--------------------------------------------
+	
+	//pHalData->SwChnlInProgress = TRUE;
+	if(channel == 0)
+		channel = 1;
+	
+	pHalData->CurrentChannel=channel;
+
+	//pHalData->SwChnlStage=0;
+	//pHalData->SwChnlStep=0;
+
+	if((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
+	{
+#ifdef USE_WORKITEM	
+		//bResult = PlatformScheduleWorkItem(&(pHalData->SwChnlWorkItem));
+#else
+		#if 0		
+		//PlatformSetTimer(Adapter, &(pHalData->SwChnlTimer), 0);
+		#else
+		_PHY_SwChnl8192C(Adapter, channel);
+		#endif
+#endif
+		if(bResult)
+		{
+			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress TRUE schdule workitem done\n"));
+		}
+		else
+		{
+			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE schdule workitem error\n"));		
+			//if(IS_HARDWARE_TYPE_8192SU(Adapter))
+			//{
+			//	pHalData->SwChnlInProgress = FALSE; 	
+				pHalData->CurrentChannel = tmpchannel;			
+			//}
+		}
+
+	}
+	else
+	{
+		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE driver sleep or unload\n"));	
+		//if(IS_HARDWARE_TYPE_8192SU(Adapter))
+		//{
+		//	pHalData->SwChnlInProgress = FALSE;		
+			pHalData->CurrentChannel = tmpchannel;
+		//}
+	}
+}
+
+
+//
+// Description:
+//	Switch channel synchronously. Called by SwChnlByDelayHandler.
+//
+// Implemented by Bruce, 2008-02-14.
+// The following procedure is operted according to SwChanlCallback8190Pci().
+// However, this procedure is performed synchronously  which should be running under
+// passive level.
+// 
+extern	VOID
+PHY_SwChnlPhy8192C(	// Only called during initialize
+	IN	PADAPTER	Adapter,
+	IN	u8		channel
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	//RT_TRACE(COMP_SCAN | COMP_RM, DBG_LOUD, ("==>PHY_SwChnlPhy8192S(), switch from channel %d to channel %d.\n", pHalData->CurrentChannel, channel));
+
+	// Cannot IO.
+	//if(RT_CANNOT_IO(Adapter))
+	//	return;
+
+	// Channel Switching is in progress.
+	//if(pHalData->SwChnlInProgress)
+	//	return;
+	
+	//return immediately if it is peudo-phy
+	if(pHalData->rf_chip == RF_PSEUDO_11N)
+	{
+		//pHalData->SwChnlInProgress=FALSE;
+		return;
+	}
+	
+	//pHalData->SwChnlInProgress = TRUE;
+	if( channel == 0)
+		channel = 1;
+	
+	pHalData->CurrentChannel=channel;
+	
+	//pHalData->SwChnlStage = 0;
+	//pHalData->SwChnlStep = 0;
+	
+	phy_FinishSwChnlNow(Adapter,channel);
+	
+	//pHalData->SwChnlInProgress = FALSE;
+}
+
+
+static	BOOLEAN
+phy_SwChnlStepByStep(
+	IN	PADAPTER	Adapter,
+	IN	u8		channel,
+	IN	u8		*stage,
+	IN	u8		*step,
+	OUT u32		*delay
+	)
+{
+#if 0
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	PCHANNEL_ACCESS_SETTING	pChnlAccessSetting;
+	SwChnlCmd				PreCommonCmd[MAX_PRECMD_CNT];
+	u4Byte					PreCommonCmdCnt;
+	SwChnlCmd				PostCommonCmd[MAX_POSTCMD_CNT];
+	u4Byte					PostCommonCmdCnt;
+	SwChnlCmd				RfDependCmd[MAX_RFDEPENDCMD_CNT];
+	u4Byte					RfDependCmdCnt;
+	SwChnlCmd				*CurrentCmd;	
+	u1Byte					eRFPath;	
+	u4Byte					RfTXPowerCtrl;
+	BOOLEAN					bAdjRfTXPowerCtrl = _FALSE;
+	
+	
+	RT_ASSERT((Adapter != NULL), ("Adapter should not be NULL\n"));
+#if(MP_DRIVER != 1)
+	RT_ASSERT(IsLegalChannel(Adapter, channel), ("illegal channel: %d\n", channel));
+#endif
+	RT_ASSERT((pHalData != NULL), ("pHalData should not be NULL\n"));
+	
+	pChnlAccessSetting = &Adapter->MgntInfo.Info8185.ChannelAccessSetting;
+	RT_ASSERT((pChnlAccessSetting != NULL), ("pChnlAccessSetting should not be NULL\n"));
+	
+	//for(eRFPath = RF90_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	//for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	//{
+		// <1> Fill up pre common command.
+	PreCommonCmdCnt = 0;
+	phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT, 
+				CmdID_SetTxPowerLevel, 0, 0, 0);
+	phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT, 
+				CmdID_End, 0, 0, 0);
+	
+		// <2> Fill up post common command.
+	PostCommonCmdCnt = 0;
+
+	phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT, 
+				CmdID_End, 0, 0, 0);
+	
+		// <3> Fill up RF dependent command.
+	RfDependCmdCnt = 0;
+	switch( pHalData->RFChipID )
+	{
+		case RF_8225:		
+		RT_ASSERT((channel >= 1 && channel <= 14), ("illegal channel for Zebra: %d\n", channel));
+		// 2008/09/04 MH Change channel. 
+		if(channel==14) channel++;
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+			CmdID_RF_WriteReg, rZebra1_Channel, (0x10+channel-1), 10);
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+		CmdID_End, 0, 0, 0);
+		break;	
+		
+	case RF_8256:
+		// TEST!! This is not the table for 8256!!
+		RT_ASSERT((channel >= 1 && channel <= 14), ("illegal channel for Zebra: %d\n", channel));
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+			CmdID_RF_WriteReg, rRfChannel, channel, 10);
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+		CmdID_End, 0, 0, 0);
+		break;
+		
+	case RF_6052:
+		RT_ASSERT((channel >= 1 && channel <= 14), ("illegal channel for Zebra: %d\n", channel));
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+			CmdID_RF_WriteReg, RF_CHNLBW, channel, 10);		
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+		CmdID_End, 0, 0, 0);		
+		
+		break;
+
+	case RF_8258:
+		break;
+
+	// For FPGA two MAC verification
+	case RF_PSEUDO_11N:
+		return TRUE;
+	default:
+		RT_ASSERT(FALSE, ("Unknown RFChipID: %d\n", pHalData->RFChipID));
+		return FALSE;
+		break;
+	}
+
+	
+	do{
+		switch(*stage)
+		{
+		case 0:
+			CurrentCmd=&PreCommonCmd[*step];
+			break;
+		case 1:
+			CurrentCmd=&RfDependCmd[*step];
+			break;
+		case 2:
+			CurrentCmd=&PostCommonCmd[*step];
+			break;
+		}
+		
+		if(CurrentCmd->CmdID==CmdID_End)
+		{
+			if((*stage)==2)
+			{
+				return TRUE;
+			}
+			else
+			{
+				(*stage)++;
+				(*step)=0;
+				continue;
+			}
+		}
+		
+		switch(CurrentCmd->CmdID)
+		{
+		case CmdID_SetTxPowerLevel:
+			PHY_SetTxPowerLevel8192C(Adapter,channel);
+			break;
+		case CmdID_WritePortUlong:
+			PlatformEFIOWrite4Byte(Adapter, CurrentCmd->Para1, CurrentCmd->Para2);
+			break;
+		case CmdID_WritePortUshort:
+			PlatformEFIOWrite2Byte(Adapter, CurrentCmd->Para1, (u2Byte)CurrentCmd->Para2);
+			break;
+		case CmdID_WritePortUchar:
+			PlatformEFIOWrite1Byte(Adapter, CurrentCmd->Para1, (u1Byte)CurrentCmd->Para2);
+			break;
+		case CmdID_RF_WriteReg:	// Only modify channel for the register now !!!!!
+			for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+			{
+#if 1
+				pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffffc00) | CurrentCmd->Para2);
+				PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bRFRegOffsetMask, pHalData->RfRegChnlVal[eRFPath]);
+#else
+				PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bRFRegOffsetMask, (CurrentCmd->Para2));
+#endif
+			}
+			break;
+		}
+		
+		break;
+	}while(TRUE);
+	//cosa }/*for(Number of RF paths)*/
+
+	(*delay)=CurrentCmd->msDelay;
+	(*step)++;
+	return FALSE;
+#endif	
+	return _TRUE;
+}
+
+
+static	BOOLEAN
+phy_SetSwChnlCmdArray(
+	SwChnlCmd*		CmdTable,
+	u32			CmdTableIdx,
+	u32			CmdTableSz,
+	SwChnlCmdID		CmdID,
+	u32			Para1,
+	u32			Para2,
+	u32			msDelay
+	)
+{
+	SwChnlCmd* pCmd;
+
+	if(CmdTable == NULL)
+	{
+		//RT_ASSERT(FALSE, ("phy_SetSwChnlCmdArray(): CmdTable cannot be NULL.\n"));
+		return _FALSE;
+	}
+	if(CmdTableIdx >= CmdTableSz)
+	{
+		//RT_ASSERT(FALSE, 
+		//		("phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%ld, CmdTableSz:%ld\n",
+		//		CmdTableIdx, CmdTableSz));
+		return _FALSE;
+	}
+
+	pCmd = CmdTable + CmdTableIdx;
+	pCmd->CmdID = CmdID;
+	pCmd->Para1 = Para1;
+	pCmd->Para2 = Para2;
+	pCmd->msDelay = msDelay;
+
+	return _TRUE;
+}
+
+
+static	void
+phy_FinishSwChnlNow(	// We should not call this function directly
+		IN	PADAPTER	Adapter,
+		IN	u8		channel
+		)
+{
+#if 0
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32			delay;
+  
+	while(!phy_SwChnlStepByStep(Adapter,channel,&pHalData->SwChnlStage,&pHalData->SwChnlStep,&delay))
+	{
+		if(delay>0)
+			rtw_mdelay_os(delay);
+	}
+#endif	
+}
+
+
+//
+//	Description:
+//		Configure H/W functionality to enable/disable Monitor mode.
+//		Note, because we possibly need to configure BB and RF in this function, 
+//		so caller should in PASSIVE_LEVEL. 080118, by rcnjko.
+//
+extern	VOID
+PHY_SetMonitorMode8192C(
+	IN	PADAPTER			pAdapter,
+	IN	BOOLEAN				bEnableMonitorMode
+	)
+{
+#if 0
+	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(pAdapter);
+	BOOLEAN				bFilterOutNonAssociatedBSSID = FALSE;
+
+	//2 Note: we may need to stop antenna diversity.
+	if(bEnableMonitorMode)
+	{
+		bFilterOutNonAssociatedBSSID = FALSE;
+		RT_TRACE(COMP_RM, DBG_LOUD, ("PHY_SetMonitorMode8192S(): enable monitor mode\n"));
+
+		pHalData->bInMonitorMode = TRUE;
+		pAdapter->HalFunc.AllowAllDestAddrHandler(pAdapter, TRUE, TRUE);
+		pAdapter->HalFunc.SetHwRegHandler(pAdapter, HW_VAR_CHECK_BSSID, (pu1Byte)&bFilterOutNonAssociatedBSSID);
+	}
+	else
+	{
+		bFilterOutNonAssociatedBSSID = TRUE;
+		RT_TRACE(COMP_RM, DBG_LOUD, ("PHY_SetMonitorMode8192S(): disable monitor mode\n"));
+
+		pAdapter->HalFunc.AllowAllDestAddrHandler(pAdapter, FALSE, TRUE);
+		pHalData->bInMonitorMode = FALSE;
+		pAdapter->HalFunc.SetHwRegHandler(pAdapter, HW_VAR_CHECK_BSSID, (pu1Byte)&bFilterOutNonAssociatedBSSID);
+	}
+#endif	
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function:	PHYCheckIsLegalRfPath8190Pci()
+ *
+ * Overview:	Check different RF type to execute legal judgement. If RF Path is illegal
+ *			We will return false.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	11/15/2007	MHC		Create Version 0.  
+ *
+ *---------------------------------------------------------------------------*/
+extern	BOOLEAN	
+PHY_CheckIsLegalRfPath8192C(	
+	IN	PADAPTER	pAdapter,
+	IN	u32	eRFPath)
+{
+//	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	BOOLEAN				rtValue = _TRUE;
+
+	// NOt check RF Path now.!
+#if 0	
+	if (pHalData->rf_type == RF_1T2R && eRFPath != RF90_PATH_A)
+	{		
+		rtValue = FALSE;
+	}
+	if (pHalData->RF_Type == RF_1T2R && eRFPath != RF90_PATH_A)
+	{
+
+	}
+#endif
+	return	rtValue;
+
+}	/* PHY_CheckIsLegalRfPath8192C */
+
+//-------------------------------------------------------------------------
+//
+//	IQK
+//
+//-------------------------------------------------------------------------
+
+#define MAX_TOLERANCE		5
+#define IQK_DELAY_TIME		1 	//ms
+
+#define PHY_SetMacReg			PHY_SetBBReg
+#define IQK_MAC_REG_NUM		4
+#define IQK_ADDA_REG_NUM		16
+#define IQK_BB_REG_NUM		9
+#define HP_THERMAL_NUM		8
+
+u8			//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+_PHY_PathA_IQK(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		configPathB
+	)
+{
+	u32 regEAC, regE94, regE9C, regEA4;
+	u8 result = 0x00;
+
+	//RTPRINT(FINIT, INIT_IQK, ("Path A IQK!\n"));
+
+	//path-A IQK setting
+	//RTPRINT(FINIT, INIT_IQK, ("Path-A IQK setting!\n"));
+	PHY_SetBBReg(pAdapter, 0xe30, bMaskDWord, 0x10008c1f);
+	PHY_SetBBReg(pAdapter, 0xe34, bMaskDWord, 0x10008c1f);
+	PHY_SetBBReg(pAdapter, 0xe38, bMaskDWord, 0x82140102);
+
+	PHY_SetBBReg(pAdapter, 0xe3c, bMaskDWord, configPathB ? 0x28160202 : 0x28160502);
+
+#if 1
+	//path-B IQK setting
+	if(configPathB)
+	{
+		PHY_SetBBReg(pAdapter, 0xe50, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(pAdapter, 0xe54, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(pAdapter, 0xe58, bMaskDWord, 0x82140102);
+		PHY_SetBBReg(pAdapter, 0xe5c, bMaskDWord, 0x28160202);
+	}
+#endif
+	//LO calibration setting
+	//RTPRINT(FINIT, INIT_IQK, ("LO calibration setting!\n"));
+	PHY_SetBBReg(pAdapter, 0xe4c, bMaskDWord, 0x001028d1);
+
+	//One shot, path A LOK & IQK
+	//RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
+	PHY_SetBBReg(pAdapter, 0xe48, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pAdapter, 0xe48, bMaskDWord, 0xf8000000);
+	
+	// delay x ms
+	//RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME));
+	rtw_udelay_os(IQK_DELAY_TIME*1000);//PlatformStallExecution(IQK_DELAY_TIME*1000);
+
+	// Check failed
+	regEAC = PHY_QueryBBReg(pAdapter, 0xeac, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%x\n", regEAC));
+	regE94 = PHY_QueryBBReg(pAdapter, 0xe94, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xe94 = 0x%x\n", regE94));
+	regE9C= PHY_QueryBBReg(pAdapter, 0xe9c, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xe9c = 0x%x\n", regE9C));
+	regEA4= PHY_QueryBBReg(pAdapter, 0xea4, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%x\n", regEA4));
+
+        if(!(regEAC & BIT28) &&		
+		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
+		(((regE9C & 0x03FF0000)>>16) != 0x42) )
+		result |= 0x01;
+	else							//if Tx not OK, ignore Rx
+		return result;
+
+	if(!(regEAC & BIT27) &&		//if Tx is OK, check whether Rx is OK
+		(((regEA4 & 0x03FF0000)>>16) != 0x132) &&
+		(((regEAC & 0x03FF0000)>>16) != 0x36))
+		result |= 0x02;
+	else
+		DBG_8192C("Path A Rx IQK fail!!\n");
+	
+	return result;
+
+
+}
+
+u8				//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+_PHY_PathB_IQK(
+	IN	PADAPTER	pAdapter
+	)
+{
+	u32 regEAC, regEB4, regEBC, regEC4, regECC;
+	u8	result = 0x00;
+	//RTPRINT(FINIT, INIT_IQK, ("Path B IQK!\n"));
+#if 0
+	//path-B IQK setting
+	RTPRINT(FINIT, INIT_IQK, ("Path-B IQK setting!\n"));
+	PHY_SetBBReg(pAdapter, 0xe50, bMaskDWord, 0x10008c22);
+	PHY_SetBBReg(pAdapter, 0xe54, bMaskDWord, 0x10008c22);
+	PHY_SetBBReg(pAdapter, 0xe58, bMaskDWord, 0x82140102);
+	PHY_SetBBReg(pAdapter, 0xe5c, bMaskDWord, 0x28160202);
+
+	//LO calibration setting
+	RTPRINT(FINIT, INIT_IQK, ("LO calibration setting!\n"));
+	PHY_SetBBReg(pAdapter, 0xe4c, bMaskDWord, 0x001028d1);
+#endif
+	//One shot, path B LOK & IQK
+	//RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
+	PHY_SetBBReg(pAdapter, 0xe60, bMaskDWord, 0x00000002);
+	PHY_SetBBReg(pAdapter, 0xe60, bMaskDWord, 0x00000000);
+
+	// delay x ms
+	//RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for One shot, path B LOK & IQK.\n", IQK_DELAY_TIME));
+	rtw_udelay_os(IQK_DELAY_TIME*1000);//PlatformStallExecution(IQK_DELAY_TIME*1000);
+
+	// Check failed
+	regEAC = PHY_QueryBBReg(pAdapter, 0xeac, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%x\n", regEAC));
+	regEB4 = PHY_QueryBBReg(pAdapter, 0xeb4, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xeb4 = 0x%x\n", regEB4));
+	regEBC= PHY_QueryBBReg(pAdapter, 0xebc, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xebc = 0x%x\n", regEBC));
+	regEC4= PHY_QueryBBReg(pAdapter, 0xec4, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xec4 = 0x%x\n", regEC4));
+	regECC= PHY_QueryBBReg(pAdapter, 0xecc, bMaskDWord);
+	//RTPRINT(FINIT, INIT_IQK, ("0xecc = 0x%x\n", regECC));
+
+	if(!(regEAC & BIT31) &&
+		(((regEB4 & 0x03FF0000)>>16) != 0x142) &&
+		(((regEBC & 0x03FF0000)>>16) != 0x42))
+		result |= 0x01;
+	else
+		return result;
+
+	if(!(regEAC & BIT30) &&
+		(((regEC4 & 0x03FF0000)>>16) != 0x132) &&
+		(((regECC & 0x03FF0000)>>16) != 0x36))
+		result |= 0x02;
+	else
+		DBG_8192C("Path B Rx IQK fail!!\n");
+	
+
+	return result;
+
+}
+
+VOID _PHY_PathAFillIQKMatrix(
+	IN	PADAPTER	pAdapter,
+	IN  BOOLEAN    	bIQKOK,
+	IN	int		result[][8],
+	IN	u8		final_candidate,
+	IN  BOOLEAN		bTxOnly
+	)
+{
+	u32	Oldval_0, X, TX0_A, reg;
+	int	Y, TX0_C;
+	
+	DBG_8192C("Path A IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
+
+        if(final_candidate == 0xFF)
+		return;
+	else if(bIQKOK)
+	{
+		Oldval_0 = (PHY_QueryBBReg(pAdapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+
+			X = result[final_candidate][0];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;				
+		TX0_A = (X * Oldval_0) >> 8;
+		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx, TX0_A = 0x%lx, Oldval_0 0x%lx\n", X, TX0_A, Oldval_0));
+		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(31), ((X* Oldval_0>>7) & 0x1));
+
+		Y = result[final_candidate][1];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;		
+		TX0_C = (Y * Oldval_0) >> 8;
+		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx, TX = 0x%lx\n", Y, TX0_C));
+		PHY_SetBBReg(pAdapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
+		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(29), ((Y* Oldval_0>>7) & 0x1));
+
+	        if(bTxOnly)
+		{
+			DBG_8192C("_PHY_PathAFillIQKMatrix only Tx OK\n");
+			return;
+		}
+
+		reg = result[final_candidate][2];
+		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
+	
+		reg = result[final_candidate][3] & 0x3F;
+		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][3] >> 6) & 0xF;
+		PHY_SetBBReg(pAdapter, 0xca0, 0xF0000000, reg);
+	}
+}
+
+VOID
+_PHY_PathBFillIQKMatrix(
+	IN	PADAPTER	pAdapter,
+	IN  BOOLEAN   	bIQKOK,
+	IN	int		result[][8],
+	IN	u8		final_candidate,
+	IN	BOOLEAN		bTxOnly			//do Tx only
+	)
+{
+	u32	Oldval_1, X, TX1_A, reg;
+	int	Y, TX1_C;
+	
+	DBG_8192C("Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
+
+        if(final_candidate == 0xFF)
+		return;
+	else if(bIQKOK)
+	{
+		Oldval_1 = (PHY_QueryBBReg(pAdapter, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+
+		X = result[final_candidate][4];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;		
+		TX1_A = (X * Oldval_1) >> 8;
+		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx, TX1_A = 0x%lx\n", X, TX1_A));
+		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(27), ((X* Oldval_1>>7) & 0x1));
+
+		Y = result[final_candidate][5];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;		
+		TX1_C = (Y * Oldval_1) >> 8;
+		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx, TX1_C = 0x%lx\n", Y, TX1_C));
+		PHY_SetBBReg(pAdapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
+		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(25), ((Y* Oldval_1>>7) & 0x1));
+
+		if(bTxOnly)
+			return;
+
+		reg = result[final_candidate][6];
+		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
+	
+		reg = result[final_candidate][7] & 0x3F;
+		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][7] >> 6) & 0xF;
+		PHY_SetBBReg(pAdapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
+	}
+}
+
+VOID
+_PHY_SaveADDARegisters(
+	IN	PADAPTER	pAdapter,
+	IN	u32*		ADDAReg,
+	IN	u32*		ADDABackup,
+	IN	u32		RegisterNum
+	)
+{
+	u32	i;
+	
+	//RTPRINT(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
+	for( i = 0 ; i < RegisterNum ; i++){
+		ADDABackup[i] = PHY_QueryBBReg(pAdapter, ADDAReg[i], bMaskDWord);
+	}
+}
+VOID
+_PHY_SaveMACRegisters(
+	IN	PADAPTER	pAdapter,
+	IN	u32*		MACReg,
+	IN	u32*		MACBackup
+	)
+{
+	u32	i;
+	
+	//RTPRINT(FINIT, INIT_IQK, ("Save MAC parameters.\n"));
+	for( i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
+		MACBackup[i] =rtw_read8(pAdapter, MACReg[i]);		
+	}
+	MACBackup[i] = rtw_read32(pAdapter, MACReg[i]);		
+
+}
+VOID
+_PHY_MACSettingCalibration(
+	IN	PADAPTER	pAdapter,
+	IN	u32*		MACReg,
+	IN	u32*		MACBackup	
+	)
+{
+	u32	i = 0;
+
+	//RTPRINT(FINIT, INIT_IQK, ("MAC settings for Calibration.\n"));
+
+	rtw_write8(pAdapter, MACReg[i], 0x3F);
+
+	for(i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++){
+		rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT3)));
+	}
+	rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));	
+
+}
+
+VOID
+_PHY_ReloadMACRegisters(
+	IN	PADAPTER	pAdapter,
+	IN	u32*			MACReg,
+	IN	u32*			MACBackup
+	)
+{
+	u32	i;
+
+	//RTPRINT(FINIT, INIT_IQK, ("Reload MAC parameters !\n"));
+	for(i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
+		rtw_write8(pAdapter, MACReg[i], (u8)MACBackup[i]);
+	}
+	rtw_write32(pAdapter, MACReg[i], MACBackup[i]);	
+}
+
+VOID
+_PHY_ReloadADDARegisters(
+	IN	PADAPTER	pAdapter,
+	IN	u32*		ADDAReg,
+	IN	u32*		ADDABackup,
+	IN	u32		RegiesterNum
+	)
+{
+	u32	i;
+
+	//RTPRINT(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
+	for(i = 0 ; i < RegiesterNum; i++){
+		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, ADDABackup[i]);
+	}
+}
+
+VOID
+_PHY_PathADDAOn(
+	IN	PADAPTER	pAdapter,
+	IN	u32*		ADDAReg,
+	IN	BOOLEAN		isPathAOn,
+	IN	BOOLEAN		is2T
+	)
+{
+	u32	pathOn;
+	u32	i;
+
+	//RTPRINT(FINIT, INIT_IQK, ("ADDA ON.\n"));
+
+	pathOn = isPathAOn ? 0x04db25a4 : 0x0b1b25a4;
+	if(_FALSE == is2T){
+		pathOn = 0x0bdb25a0;
+		PHY_SetBBReg(pAdapter, ADDAReg[0], bMaskDWord, 0x0b1b25a0);
+	}
+	else{
+		PHY_SetBBReg(pAdapter, ADDAReg[0], bMaskDWord, pathOn);
+	}
+	
+	for( i = 1 ; i < IQK_ADDA_REG_NUM ; i++){
+		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, pathOn);
+	}
+	
+}
+
+VOID
+_PHY_PathAStandBy(
+	IN	PADAPTER	pAdapter
+	)
+{
+	//RTPRINT(FINIT, INIT_IQK, ("Path-A standby mode!\n"));
+
+	PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x0);
+	PHY_SetBBReg(pAdapter, 0x840, bMaskDWord, 0x00010000);
+	PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x80800000);
+}
+
+VOID
+_PHY_PIModeSwitch(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		PIMode
+	)
+{
+	u32	mode;
+
+	//RTPRINT(FINIT, INIT_IQK, ("BB Switch to %s mode!\n", (PIMode ? "PI" : "SI")));
+
+	mode = PIMode ? 0x01000100 : 0x01000000;
+	PHY_SetBBReg(pAdapter, 0x820, bMaskDWord, mode);
+	PHY_SetBBReg(pAdapter, 0x828, bMaskDWord, mode);
+}
+
+/*
+return _FALSE => do IQK again
+*/
+BOOLEAN							
+_PHY_SimularityCompare(
+	IN	PADAPTER	pAdapter,
+	IN	int 		result[][8],
+	IN	u8		 c1,
+	IN	u8		 c2
+	)
+{
+	u32		i, j, diff, SimularityBitMap, bound = 0;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	u8		final_candidate[2] = {0xFF, 0xFF};	//for path A and path B
+	BOOLEAN		bResult = _TRUE, is2T = IS_92C_SERIAL( pHalData->VersionID);
+	
+	if(is2T)
+		bound = 8;
+	else
+		bound = 4;
+
+	SimularityBitMap = 0;
+	
+	for( i = 0; i < bound; i++ )
+	{
+		diff = (result[c1][i] > result[c2][i]) ? (result[c1][i] - result[c2][i]) : (result[c2][i] - result[c1][i]);
+		if (diff > MAX_TOLERANCE)
+		{
+			if((i == 2 || i == 6) && !SimularityBitMap)
+			{
+				if(result[c1][i]+result[c1][i+1] == 0)
+					final_candidate[(i/4)] = c2;
+				else if (result[c2][i]+result[c2][i+1] == 0)
+					final_candidate[(i/4)] = c1;
+				else
+					SimularityBitMap = SimularityBitMap|(1<<i);					
+			}
+			else
+				SimularityBitMap = SimularityBitMap|(1<<i);
+		}
+	}
+	
+	if ( SimularityBitMap == 0)
+	{
+		for( i = 0; i < (bound/4); i++ )
+		{
+			if(final_candidate[i] != 0xFF)
+			{
+				for( j = i*4; j < (i+1)*4-2; j++)
+					result[3][j] = result[final_candidate[i]][j];
+				bResult = _FALSE;
+			}
+		}
+		return bResult;
+	}
+	else if (!(SimularityBitMap & 0x0F))			//path A OK
+	{
+		for(i = 0; i < 4; i++)
+			result[3][i] = result[c1][i];
+		return _FALSE;
+	}
+	else if (!(SimularityBitMap & 0xF0) && is2T)	//path B OK
+	{
+		for(i = 4; i < 8; i++)
+			result[3][i] = result[c1][i];
+		return _FALSE;
+	}	
+	else		
+		return _FALSE;
+	
+}
+
+VOID	
+_PHY_IQCalibrate(
+	IN	PADAPTER	pAdapter,
+	IN	int 		result[][8],
+	IN	u8		t,
+	IN	BOOLEAN		is2T
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u32			i;
+	u8			PathAOK, PathBOK;
+	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {	0x85c, 0xe6c, 0xe70, 0xe74,
+												0xe78, 0xe7c, 0xe80, 0xe84,
+												0xe88, 0xe8c, 0xed0, 0xed4,
+												0xed8, 0xedc, 0xee0, 0xeec };
+
+	u32			IQK_MAC_REG[IQK_MAC_REG_NUM] = {0x522, 0x550,	0x551,0x040};
+
+	u32			IQK_BB_REG[IQK_BB_REG_NUM] = {
+						0xc04, 	0xc08,	0x874,	0xb68,	0xb6c,
+						0x870,	0x860,	0x864,	0x800	
+						};	
+	
+#if MP_DRIVER
+	const u32	retryCount = 9;
+#else
+	const u32	retryCount = 2;
+#endif
+
+	// Note: IQ calibration must be performed after loading 
+	// 		PHY_REG.txt , and radio_a, radio_b.txt	
+	
+	u32 bbvalue;
+	BOOLEAN			isNormal = IS_NORMAL_CHIP(pHalData->VersionID);
+
+	if(t==0)
+	{
+	 	bbvalue = PHY_QueryBBReg(pAdapter, 0x800, bMaskDWord);
+		//RTPRINT(FINIT, INIT_IQK, ("PHY_IQCalibrate()==>0x%08lx\n",bbvalue));
+
+		//RTPRINT(FINIT, INIT_IQK, ("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
+	
+	 	// Save ADDA parameters, turn Path A ADDA on
+	 	_PHY_SaveADDARegisters(pAdapter, ADDA_REG, pHalData->ADDA_backup,IQK_ADDA_REG_NUM);
+		_PHY_SaveMACRegisters(pAdapter, IQK_MAC_REG, pHalData->IQK_MAC_backup);
+		_PHY_SaveADDARegisters(pAdapter, IQK_BB_REG, pHalData->IQK_BB_backup, IQK_BB_REG_NUM);
+	}
+ 	_PHY_PathADDAOn(pAdapter, ADDA_REG, _TRUE, is2T);
+
+	if(t==0)
+	{
+		pHalData->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+	}
+	if(!pHalData->bRfPiEnable){
+		// Switch BB to PI mode to do IQ Calibration.
+		_PHY_PIModeSwitch(pAdapter, _TRUE);
+	}
+
+	
+	PHY_SetBBReg(pAdapter, 0x800, BIT24, 0x00);		
+	PHY_SetBBReg(pAdapter, 0xc04, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(pAdapter, 0xc08, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(pAdapter, 0x874, bMaskDWord, 0x22204000);
+	PHY_SetBBReg(pAdapter, 0x870, BIT10, 0x01);
+	PHY_SetBBReg(pAdapter, 0x870, BIT26, 0x01);	
+	PHY_SetBBReg(pAdapter, 0x860, BIT10, 0x00);
+	PHY_SetBBReg(pAdapter, 0x864, BIT10, 0x00);	
+
+	if(is2T)
+	{
+		PHY_SetBBReg(pAdapter, 0x840, bMaskDWord, 0x00010000);
+		PHY_SetBBReg(pAdapter, 0x844, bMaskDWord, 0x00010000);
+	}
+	
+	//MAC settings
+	_PHY_MACSettingCalibration(pAdapter, IQK_MAC_REG, pHalData->IQK_MAC_backup);
+	//Page B init
+	if(isNormal)
+		PHY_SetBBReg(pAdapter, 0xb68, bMaskDWord, 0x00080000);		
+	else
+		PHY_SetBBReg(pAdapter, 0xb68, bMaskDWord, 0x0f600000);
+	
+	if(is2T)
+	{
+		if(isNormal)	
+			PHY_SetBBReg(pAdapter, 0xb6c, bMaskDWord, 0x00080000);
+		else
+			PHY_SetBBReg(pAdapter, 0xb6c, bMaskDWord, 0x0f600000);
+	}
+	
+	// IQ calibration setting
+	//RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));		
+	PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(pAdapter, 0xe40, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(pAdapter, 0xe44, bMaskDWord, 0x01004800);
+
+	for(i = 0 ; i < retryCount ; i++){
+		PathAOK = _PHY_PathA_IQK(pAdapter, is2T);
+		if(PathAOK == 0x03){
+				DBG_8192C("Path A IQK Success!!\n");
+				result[t][0] = (PHY_QueryBBReg(pAdapter, 0xe94, bMaskDWord)&0x3FF0000)>>16;
+				result[t][1] = (PHY_QueryBBReg(pAdapter, 0xe9c, bMaskDWord)&0x3FF0000)>>16;
+				result[t][2] = (PHY_QueryBBReg(pAdapter, 0xea4, bMaskDWord)&0x3FF0000)>>16;
+				result[t][3] = (PHY_QueryBBReg(pAdapter, 0xeac, bMaskDWord)&0x3FF0000)>>16;
+			break;
+		}
+		else if (i == (retryCount-1) && PathAOK == 0x01)	//Tx IQK OK
+		{
+			DBG_8192C("Path A IQK Only  Tx Success!!\n");
+			
+			result[t][0] = (PHY_QueryBBReg(pAdapter, 0xe94, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(pAdapter, 0xe9c, bMaskDWord)&0x3FF0000)>>16;			
+		}
+	}
+
+	if(0x00 == PathAOK){		
+		DBG_8192C("Path A IQK failed!!\n");
+	}
+
+	if(is2T){
+		_PHY_PathAStandBy(pAdapter);
+
+		// Turn Path B ADDA on
+		_PHY_PathADDAOn(pAdapter, ADDA_REG, _FALSE, is2T);
+
+		for(i = 0 ; i < retryCount ; i++){
+			PathBOK = _PHY_PathB_IQK(pAdapter);
+			if(PathBOK == 0x03){
+				DBG_8192C("Path B IQK Success!!\n");
+				result[t][4] = (PHY_QueryBBReg(pAdapter, 0xeb4, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(pAdapter, 0xebc, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (PHY_QueryBBReg(pAdapter, 0xec4, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (PHY_QueryBBReg(pAdapter, 0xecc, bMaskDWord)&0x3FF0000)>>16;
+				break;
+			}
+			else if (i == (retryCount - 1) && PathBOK == 0x01)	//Tx IQK OK
+			{
+				DBG_8192C("Path B Only Tx IQK Success!!\n");
+				result[t][4] = (PHY_QueryBBReg(pAdapter, 0xeb4, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(pAdapter, 0xebc, bMaskDWord)&0x3FF0000)>>16;				
+			}
+		}
+
+		if(0x00 == PathBOK){		
+			DBG_8192C("Path B IQK failed!!\n");
+		}
+	}
+
+
+	//Back to BB mode, load original value
+	//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
+	PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0);
+
+	if(t!=0)
+	{
+		if(!pHalData->bRfPiEnable){
+		// Switch back BB to SI mode after finish IQ Calibration.
+		_PHY_PIModeSwitch(pAdapter, _FALSE);
+	        }
+
+		// Reload ADDA power saving parameters
+	 	_PHY_ReloadADDARegisters(pAdapter, ADDA_REG, pHalData->ADDA_backup, IQK_ADDA_REG_NUM);
+
+		// Reload MAC parameters
+		_PHY_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pHalData->IQK_MAC_backup);
+		
+	 	// Reload BB parameters
+	 	_PHY_ReloadADDARegisters(pAdapter, IQK_BB_REG, pHalData->IQK_BB_backup, IQK_BB_REG_NUM);
+
+		// Restore RX initial gain
+		PHY_SetBBReg(pAdapter, 0x840, bMaskDWord, 0x00032ed3);
+		if(is2T){
+			PHY_SetBBReg(pAdapter, 0x844, bMaskDWord, 0x00032ed3);
+	        }
+
+		//load 0xe30 IQC default value
+		PHY_SetBBReg(pAdapter, 0xe30, bMaskDWord, 0x01008c00);		
+		PHY_SetBBReg(pAdapter, 0xe34, bMaskDWord, 0x01008c00);				
+		
+	}
+	
+	//RTPRINT(FINIT, INIT_IQK, ("_PHY_IQCalibrate() <==\n"));
+	
+}
+
+
+VOID	
+_PHY_LCCalibrate(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN		is2T
+	)
+{
+	u8	tmpReg;
+	u32 	RF_Amode, RF_Bmode, LC_Cal;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	BOOLEAN	isNormal = IS_NORMAL_CHIP(pHalData->VersionID);
+
+	//Check continuous TX and Packet TX
+	tmpReg = (u8)rtw_read32(pAdapter, 0xd03);
+
+	if((tmpReg&0x70) != 0)			//Deal with contisuous TX case
+		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	//disable all continuous TX
+	else 							// Deal with Packet TX case
+		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			// block all queues
+
+	if((tmpReg&0x70) != 0)
+	{
+		//1. Read original RF mode
+		//Path-A
+		RF_Amode = PHY_QueryRFReg(pAdapter, RF90_PATH_A, 0x00, bMask12Bits);
+
+		//Path-B
+		if(is2T)
+			RF_Bmode = PHY_QueryRFReg(pAdapter, RF90_PATH_B, 0x00, bMask12Bits);	
+
+		//2. Set RF mode = standby mode
+		//Path-A
+		PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x00, bMask12Bits, (RF_Amode&0x8FFFF)|0x10000);
+
+		//Path-B
+		if(is2T)
+			PHY_SetRFReg(pAdapter, RF90_PATH_B, 0x00, bMask12Bits, (RF_Bmode&0x8FFFF)|0x10000);			
+	}
+	
+	//3. Read RF reg18
+	LC_Cal = PHY_QueryRFReg(pAdapter, RF90_PATH_A, 0x18, bMask12Bits);
+	
+	//4. Set LC calibration begin
+	PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x18, bMask12Bits, LC_Cal|0x08000);
+
+	if(isNormal)
+		rtw_mdelay_os(100);		
+	else
+		rtw_mdelay_os(3);
+
+	//Restore original situation
+	if((tmpReg&0x70) != 0)	//Deal with contisuous TX case 
+	{  
+		//Path-A
+		rtw_write8(pAdapter, 0xd03, tmpReg);
+		PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x00, bMask12Bits, RF_Amode);
+		
+		//Path-B
+		if(is2T)
+			PHY_SetRFReg(pAdapter, RF90_PATH_B, 0x00, bMask12Bits, RF_Bmode);
+	}
+	else // Deal with Packet TX case
+	{
+		rtw_write8(pAdapter, REG_TXPAUSE, 0x00);	
+	}
+	
+}
+
+
+VOID	
+_PHY_APCalibrate(
+	IN	PADAPTER	pAdapter,
+	IN	char 		delta,
+	IN	BOOLEAN		is2T
+	)
+{
+
+//Analog Pre-distortion calibration
+#define		APK_BB_REG_NUM	5
+#define		APK_AFE_REG_NUM	16
+#define		APK_CURVE_REG_NUM 4
+#define		PATH_NUM		2
+
+#if 1//(PLATFORM == PLATFORM_WINDOWS)//???
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	u32 			regD[PATH_NUM];
+	u32			tmpReg, index, offset, path, i, pathbound = PATH_NUM, apkbound;
+			
+	u32			BB_backup[APK_BB_REG_NUM];
+	u32			BB_REG[APK_BB_REG_NUM] = {	
+						0x904, 0xc04, 0x800, 0xc08, 0x874 };
+	u32			BB_AP_MODE[APK_BB_REG_NUM] = {	
+						0x00000020, 0x00a05430, 0x02040000, 
+						0x000800e4, 0x00204000 };
+	u32			BB_normal_AP_MODE[APK_BB_REG_NUM] = {	
+						0x00000020, 0x00a05430, 0x02040000, 
+						0x000800e4, 0x22204000 };						
+
+	u32			AFE_backup[APK_AFE_REG_NUM];
+	u32			AFE_REG[APK_AFE_REG_NUM] = {	
+						0x85c, 0xe6c, 0xe70, 0xe74, 0xe78, 
+						0xe7c, 0xe80, 0xe84, 0xe88, 0xe8c, 
+						0xed0, 0xed4, 0xed8, 0xedc, 0xee0,
+						0xeec};
+
+	u32			MAC_backup[IQK_MAC_REG_NUM];
+	u32			MAC_REG[IQK_MAC_REG_NUM] = {
+						0x522, 0x550, 0x551, 0x040};
+
+	u32			APK_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x0852c, 0x1852c, 0x5852c, 0x1852c, 0x5852c},
+					{0x2852e, 0x0852e, 0x3852e, 0x0852e, 0x0852e}
+					};	
+
+	u32			APK_normal_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	//path settings equal to path b settings
+					{0x0852c, 0x0a52c, 0x5a52c, 0x5a52c, 0x5a52c}
+					};
+	
+	u32			APK_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x52019, 0x52014, 0x52013, 0x5200f, 0x5208d},
+					{0x5201a, 0x52019, 0x52016, 0x52033, 0x52050}
+					};
+
+	u32			APK_normal_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a},	//path settings equal to path b settings
+					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a}
+					};
+	
+	u32			APK_RF_value_A[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x1adb0, 0x1adb0, 0x1ada0, 0x1ad90, 0x1ad80},		
+					{0x00fb0, 0x00fb0, 0x00fa0, 0x00f90, 0x00f80}						
+					};
+
+	u32			AFE_on_off[PATH_NUM] = {
+					0x04db25a4, 0x0b1b25a4};	//path A on path B off / path A off path B on
+
+	u32			APK_offset[PATH_NUM] = {
+					0xb68, 0xb6c};
+
+	u32			APK_normal_offset[PATH_NUM] = {
+					0xb28, 0xb98};
+					
+	u32			APK_value[PATH_NUM] = {
+					0x92fc0000, 0x12fc0000};					
+
+	u32			APK_normal_value[PATH_NUM] = {
+					0x92680000, 0x12680000};					
+
+	s8			APK_delta_mapping[APK_BB_REG_NUM][13] = {
+					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},											
+					{-6, -4, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-11, -9, -7, -5, -3, -1, 0, 0, 0, 0, 0, 0, 0}
+					};
+	
+	u32			APK_normal_setting_value_1[13] = {
+					0x01017018, 0xf7ed8f84, 0x1b1a1816, 0x2522201e, 0x322e2b28,
+					0x433f3a36, 0x5b544e49, 0x7b726a62, 0xa69a8f84, 0xdfcfc0b3,
+					0x12680000, 0x00880000, 0x00880000
+					};
+
+	u32			APK_normal_setting_value_2[16] = {
+					0x01c7021d, 0x01670183, 0x01000123, 0x00bf00e2, 0x008d00a3,
+					0x0068007b, 0x004d0059, 0x003a0042, 0x002b0031, 0x001f0025,
+					0x0017001b, 0x00110014, 0x000c000f, 0x0009000b, 0x00070008,
+					0x00050006
+					};
+	
+	u32			APK_result[PATH_NUM][APK_BB_REG_NUM];	//val_1_1a, val_1_2a, val_2a, val_3a, val_4a
+	u32			AP_curve[PATH_NUM][APK_CURVE_REG_NUM];
+
+	int			BB_offset, delta_V, delta_offset;
+
+	BOOLEAN			isNormal = IS_NORMAL_CHIP(pHalData->VersionID);
+
+#if (MP_DRIVER == 1)
+	PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);	
+
+	pMptCtx->APK_bound[0] = 45;
+	pMptCtx->APK_bound[1] = 52;		
+#endif
+
+	//RTPRINT(FINIT, INIT_IQK, ("==>PHY_APCalibrate() delta %d\n", delta));
+	
+	//RTPRINT(FINIT, INIT_IQK, ("AP Calibration for %s %s\n", (is2T ? "2T2R" : "1T1R"), (isNormal ? "Normal chip" : "Test chip")));
+
+	if(!is2T)
+		pathbound = 1;
+
+	if(isNormal)
+	{
+// Temporarily do not allow normal driver to do the following settings because these offset
+// and value will cause RF internal PA to be unpredictably disabled by HW, such that RF Tx signal
+// will disappear after disable/enable card many times on 88CU. RF SD and DD have not find the
+// root cause, so we remove these actions temporarily. 
+#if (MP_DRIVER != 1)
+		return;
+#endif
+	
+		//settings adjust for normal chip
+		for(index = 0; index < PATH_NUM; index ++)
+		{
+ 			APK_offset[index] = APK_normal_offset[index];
+			APK_value[index] = APK_normal_value[index];
+			AFE_on_off[index] = 0x6fdb25a4;
+		}
+
+		for(index = 0; index < APK_BB_REG_NUM; index ++)
+		{
+			for(path = 0; path < pathbound; path++)
+			{
+				APK_RF_init_value[path][index] = APK_normal_RF_init_value[path][index];
+				APK_RF_value_0[path][index] = APK_normal_RF_value_0[path][index];
+			}
+			BB_AP_MODE[index] = BB_normal_AP_MODE[index];
+		}			
+
+		apkbound = 6;
+	}
+	else
+	{
+		PHY_SetBBReg(pAdapter, 0xb68, bMaskDWord, 0x0fe00000);
+		if(is2T)
+			PHY_SetBBReg(pAdapter, 0xb68, bMaskDWord, 0x0fe00000);
+		apkbound = 12;
+	}
+	
+	//save BB default value
+	for(index = 0; index < APK_BB_REG_NUM ; index++)
+	{
+		if(index == 0 && isNormal)		//skip 
+			continue;				
+		BB_backup[index] = PHY_QueryBBReg(pAdapter, BB_REG[index], bMaskDWord);
+	}
+	
+	//save MAC default value													
+	_PHY_SaveMACRegisters(pAdapter, MAC_REG, MAC_backup);
+	
+	//save AFE default value
+	_PHY_SaveADDARegisters(pAdapter, AFE_REG, AFE_backup,16);
+
+	for(path = 0; path < pathbound; path++)
+	{
+		//save old AP curve													
+		if(isNormal)
+		{
+			if(path == RF90_PATH_A)
+			{
+				//path A APK
+				//load APK setting
+				//path-A		
+				offset = 0xb00;
+				for(index = 0; index < 11; index ++)			
+				{
+					PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+					
+					offset += 0x04;
+				}
+				
+				PHY_SetBBReg(pAdapter, 0xb98, bMaskDWord, 0x12680000);
+				
+				offset = 0xb68;
+				for(; index < 13; index ++) 		
+				{
+					PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+					
+					offset += 0x04;
+				}	
+				
+				//page-B1
+				PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x40000000);
+				
+				//path A
+				offset = 0xb00;
+				for(index = 0; index < 16; index++)
+				{
+					PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);		
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+					
+					offset += 0x04;
+				}				
+				PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x00000000);							
+			}
+			else if(path == RF90_PATH_B)
+			{
+				//path B APK
+				//load APK setting
+				//path-B		
+				offset = 0xb70;
+				for(index = 0; index < 10; index ++)			
+				{
+					PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+					
+					offset += 0x04;
+				}
+				PHY_SetBBReg(pAdapter, 0xb28, bMaskDWord, 0x12680000);
+				
+				PHY_SetBBReg(pAdapter, 0xb98, bMaskDWord, 0x12680000);
+				
+				offset = 0xb68;
+				index = 11;
+				for(; index < 13; index ++) //offset 0xb68, 0xb6c		
+				{
+					PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+					
+					offset += 0x04;
+				}	
+				
+				//page-B1
+				PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x40000000);
+				
+				//path B
+				offset = 0xb60;
+				for(index = 0; index < 16; index++)
+				{
+					PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);		
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+					
+					offset += 0x04;
+				}				
+				PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x00000000);							
+			}
+		
+#if 0		
+			tmpReg = PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0x3, bMaskDWord);
+			AP_curve[path][0] = tmpReg & 0x1F;				//[4:0]
+
+			tmpReg = PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0x4, bMaskDWord);			
+			AP_curve[path][1] = (tmpReg & 0xF8000) >> 15; 	//[19:15]						
+			AP_curve[path][2] = (tmpReg & 0x7C00) >> 10;	//[14:10]
+			AP_curve[path][3] = (tmpReg & 0x3E0) >> 5;		//[9:5]			
+#endif			
+		}
+		else
+		{
+			tmpReg = PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xe, bMaskDWord);
+		
+			AP_curve[path][0] = (tmpReg & 0xF8000) >> 15; 	//[19:15]			
+			AP_curve[path][1] = (tmpReg & 0x7C00) >> 10;	//[14:10]
+			AP_curve[path][2] = (tmpReg & 0x3E0) >> 5;		//[9:5]
+			AP_curve[path][3] = tmpReg & 0x1F;				//[4:0]
+		}
+		
+		//save RF default value
+		regD[path] = PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xd, bMaskDWord);
+		
+		//Path A AFE all on, path B AFE All off or vise versa
+		for(index = 0; index < APK_AFE_REG_NUM ; index++)
+			PHY_SetBBReg(pAdapter, AFE_REG[index], bMaskDWord, AFE_on_off[path]);
+		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xe70 %x\n", PHY_QueryBBReg(pAdapter, 0xe70, bMaskDWord)));		
+
+		//BB to AP mode
+		if(path == 0)
+		{				
+			for(index = 0; index < APK_BB_REG_NUM ; index++)
+			{
+				if(index == 0 && isNormal)		//skip 
+					continue;			
+				PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
+			}
+		}
+
+		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x800 %x\n", PHY_QueryBBReg(pAdapter, 0x800, bMaskDWord)));				
+
+		//MAC settings
+		_PHY_MACSettingCalibration(pAdapter, MAC_REG, MAC_backup);
+		
+		if(path == RF90_PATH_A)	//Path B to standby mode
+		{
+			PHY_SetRFReg(pAdapter, RF90_PATH_B, 0x0, bMaskDWord, 0x10000);			
+		}
+		else			//Path A to standby mode
+		{
+			PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x00, bMaskDWord, 0x10000);			
+			PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x10, bMaskDWord, 0x1000f);			
+			PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x11, bMaskDWord, 0x20103);						
+		}
+
+		delta_offset = ((delta+14)/2);
+		if(delta_offset < 0)
+			delta_offset = 0;
+		else if (delta_offset > 12)
+			delta_offset = 12;
+			
+		//AP calibration
+		for(index = 0; index < APK_BB_REG_NUM; index++)
+		{
+			if(index != 1 && isNormal)		//only DO PA11+PAD01001, AP RF setting
+				continue;
+					
+			tmpReg = APK_RF_init_value[path][index];
+#if 1			
+			if(!pHalData->bAPKThermalMeterIgnore)
+			{
+				BB_offset = (tmpReg & 0xF0000) >> 16;
+
+				if(!(tmpReg & BIT15)) //sign bit 0
+				{
+					BB_offset = -BB_offset;
+				}
+
+				delta_V = APK_delta_mapping[index][delta_offset];
+				
+				BB_offset += delta_V;
+
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() APK index %d tmpReg 0x%x delta_V %d delta_offset %d\n", index, tmpReg, delta_V, delta_offset));		
+				
+				if(BB_offset < 0)
+				{
+					tmpReg = tmpReg & (~BIT15);
+					BB_offset = -BB_offset;
+				}
+				else
+				{
+					tmpReg = tmpReg | BIT15;
+				}
+				tmpReg = (tmpReg & 0xFFF0FFFF) | (BB_offset << 16);
+			}
+#endif
+
+			PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xc, bMaskDWord, 0x8992e);
+			//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xc %x\n", PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xc, bMaskDWord)));		
+			PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0x0, bMaskDWord, APK_RF_value_0[path][index]);
+			//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x0 %x\n", PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0x0, bMaskDWord)));		
+			PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xd, bMaskDWord, tmpReg);
+			//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xd %x\n", PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xd, bMaskDWord)));					
+			if(!isNormal)
+			{
+				PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xa, bMaskDWord, APK_RF_value_A[path][index]);
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xa %x\n", PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xa, bMaskDWord)));					
+			}
+			
+			// PA11+PAD01111, one shot	
+			i = 0;
+			do
+			{
+				PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x80000000);
+				{
+					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[0]);		
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", APK_offset[path], PHY_QueryBBReg(pAdapter, APK_offset[path], bMaskDWord)));
+					rtw_mdelay_os(3);
+					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[1]);
+					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", APK_offset[path], PHY_QueryBBReg(pAdapter, APK_offset[path], bMaskDWord)));
+					if(isNormal)
+					 	rtw_mdelay_os(20);
+					else
+						rtw_mdelay_os(3);
+				}
+				PHY_SetBBReg(pAdapter, 0xe28, bMaskDWord, 0x00000000);
+				
+				if(!isNormal)
+				{
+					tmpReg = PHY_QueryRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xb, bMaskDWord);
+				tmpReg = (tmpReg & 0x3E00) >> 9;
+				}
+				else
+				{
+					if(path == RF90_PATH_A)
+						tmpReg = PHY_QueryBBReg(pAdapter, 0xbd8, 0x03E00000);
+					else
+						tmpReg = PHY_QueryBBReg(pAdapter, 0xbd8, 0xF8000000);
+				}
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xbd8[25:21] %x\n", tmpReg));		
+				
+
+				i++;
+			}
+			while(tmpReg > apkbound && i < 4);
+
+			APK_result[path][index] = tmpReg;
+		}
+	}
+
+	//reload MAC default value	
+	_PHY_ReloadMACRegisters(pAdapter, MAC_REG, MAC_backup);
+	
+	//reload BB default value	
+	for(index = 0; index < APK_BB_REG_NUM ; index++)
+	{
+		if(index == 0 && isNormal)		//skip 
+			continue;					
+		PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]);
+	}
+
+	//reload AFE default value
+	_PHY_ReloadADDARegisters(pAdapter, AFE_REG, AFE_backup, 16);
+
+	//reload RF path default value
+	for(path = 0; path < pathbound; path++)
+	{
+		PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xd, bMaskDWord, regD[path]);
+		if(path == RF90_PATH_B)
+		{
+			PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x10, bMaskDWord, 0x1000f);			
+			PHY_SetRFReg(pAdapter, RF90_PATH_A, 0x11, bMaskDWord, 0x20101);						
+		}
+#if 1
+		if(!isNormal)
+		{
+			for(index = 0; index < APK_BB_REG_NUM ; index++)
+			{
+				if(APK_result[path][index] > 12)
+					APK_result[path][index] = AP_curve[path][index-1];
+				//RTPRINT(FINIT, INIT_IQK, ("apk result %d 0x%x \t", index, APK_result[path][index]));
+			}
+		}
+		else
+		{		//note no index == 0
+			if (APK_result[path][1] > 6)
+				APK_result[path][1] = 6;
+			//RTPRINT(FINIT, INIT_IQK, ("apk path %d result %d 0x%x \t", path, 1, APK_result[path][1]));			
+
+#if 0			
+			if(APK_result[path][2] < 2)
+				APK_result[path][2] = 2;
+			else if (APK_result[path][2] > 6)
+				APK_result[path][2] = 6;			
+		RTPRINT(FINIT, INIT_IQK, ("apk result %d 0x%x \t", 2, APK_result[path][2]));			
+
+			if(APK_result[path][3] < 2)
+				APK_result[path][3] = 2;
+			else if (APK_result[path][3] > 6)
+				APK_result[path][3] = 6;			
+		RTPRINT(FINIT, INIT_IQK, ("apk result %d 0x%x \t", 3, APK_result[path][3]));			
+
+			if(APK_result[path][4] < 5)
+				APK_result[path][4] = 5;
+			else if (APK_result[path][4] > 9)
+				APK_result[path][4] = 9;			
+		RTPRINT(FINIT, INIT_IQK, ("apk result %d 0x%x \t", 4, APK_result[path][4]));			
+#endif			
+		
+		}
+#endif		
+		
+	}
+
+	//RTPRINT(FINIT, INIT_IQK, ("\n"));
+	
+
+	for(path = 0; path < pathbound; path++)
+	{
+		if(isNormal)
+		{
+			PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0x3, bMaskDWord, 
+			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (APK_result[path][1] << 5) | APK_result[path][1]));
+			if(path == RF90_PATH_A)
+				PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0x4, bMaskDWord, 
+				((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x00 << 5) | 0x05));		
+			else
+			PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0x4, bMaskDWord, 
+				((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x02 << 5) | 0x05));						
+			PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xe, bMaskDWord, 
+			((0x08 << 15) | (0x08 << 10) | (0x08 << 5) | 0x08));			
+		}
+		else
+		{
+			for(index = 0; index < 2; index++)
+				pHalData->APKoutput[path][index] = ((APK_result[path][index] << 15) | (APK_result[path][2] << 10) | (APK_result[path][3] << 5) | APK_result[path][4]);
+
+#if MP_DRIVER == 1
+			if(pMptCtx->TxPwrLevel[path] > pMptCtx->APK_bound[path])	
+			{
+				PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xe, bMaskDWord, 
+				pHalData->APKoutput[path][0]);
+			}
+			else
+			{
+				PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xe, bMaskDWord, 
+				pHalData->APKoutput[path][1]);		
+			}
+#else
+			PHY_SetRFReg(pAdapter, (RF90_RADIO_PATH_E)path, 0xe, bMaskDWord, 
+			pHalData->APKoutput[path][0]);
+#endif
+		}
+	}
+
+	pHalData->bAPKdone = _TRUE;
+
+	//RTPRINT(FINIT, INIT_IQK, ("<==PHY_APCalibrate()\n"));
+#endif		
+}
+	
+void PHY_SetRFPath(IN	PADAPTER	pAdapter,u8 antenna)
+{
+//	if(is2T)
+//		return;
+#if 1	
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(pAdapter);
+	PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, antenna);
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	printk("PHY_SetRFPath==> set RF_(%s) to RF_(%s) \n",(2==pHalData->CurAntenna)?"A":"B",(2==antenna)?"A":"B");
+	pHalData->CurAntenna = antenna ;
+#endif
+	
+#else
+	if(!pAdapter->hw_init_completed)
+	{
+		PHY_SetBBReg(pAdapter, 0x4C, BIT23, 0x01);
+		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
+	}
+	
+	if(bMain)
+		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x2);	
+	else
+		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);		
+
+	//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("_PHY_SetRFPathSwitch 0x4C %lx, 0x878 %lx, 0x860 %lx \n", PHY_QueryBBReg(pAdapter, 0x4C, BIT23), PHY_QueryBBReg(pAdapter, 0x878, BIT13), PHY_QueryBBReg(pAdapter, 0x860, 0x300)));
+#endif
+}
+
+//return value TRUE => Main; FALSE => Aux
+
+u8 PHY_QueryRFPath(IN PADAPTER	pAdapter)
+{
+//	if(is2T)
+//		return _TRUE;
+#if 1
+	return PHY_QueryBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300);		
+#else
+	if(!pAdapter->hw_init_completed)
+	{
+		PHY_SetBBReg(pAdapter, 0x4C, BIT23, 0x01);
+		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
+	}
+
+	//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("_PHY_QueryRFPathSwitch 0x4C %lx, 0x878 %lx, 0x860 %lx \n", PHY_QueryBBReg(pAdapter, 0x4C, BIT23), PHY_QueryBBReg(pAdapter, 0x878, BIT13), PHY_QueryBBReg(pAdapter, 0x860, 0x300)));
+
+	if(PHY_QueryBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300) == 0x01)
+		return _TRUE;
+	else 
+		return _FALSE;
+#endif
+
+}
+
+
+VOID
+_PHY_DumpRFReg(IN	PADAPTER	pAdapter)
+{
+	u32 rfRegValue,rfRegOffset;
+
+	//RTPRINT(FINIT, INIT_RF, ("PHY_DumpRFReg()====>\n"));
+	
+	for(rfRegOffset = 0x00;rfRegOffset<=0x30;rfRegOffset++){		
+		rfRegValue = PHY_QueryRFReg(pAdapter,RF90_PATH_A, rfRegOffset, bMaskDWord);
+		//RTPRINT(FINIT, INIT_RF, (" 0x%02x = 0x%08x\n",rfRegOffset,rfRegValue));
+	}
+	//RTPRINT(FINIT, INIT_RF, ("<===== PHY_DumpRFReg()\n"));
+}
+
+#undef IQK_ADDA_REG_NUM
+#undef IQK_DELAY_TIME
+
+
+VOID
+PHY_IQCalibrate(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN 	bReCovery
+	
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u32			IQK_BB_REG[10] = {
+				rOFDM0_XARxIQImbalance, rOFDM0_XBRxIQImbalance, rOFDM0_ECCAThreshold, rOFDM0_AGCRSSITable,
+				rOFDM0_XATxIQImbalance, rOFDM0_XBTxIQImbalance, rOFDM0_XCTxIQImbalance, rOFDM0_XCTxAFE, rOFDM0_XDTxAFE, rOFDM0_RxIQExtAnta};
+	int			result[4][8];	//last is final result
+	u8			i, final_candidate;
+	BOOLEAN			bPathAOK, bPathBOK;
+	int			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
+	BOOLEAN			is12simular, is13simular, is23simular;	
+	BOOLEAN 		bStartContTx = _FALSE, bSingleTone = _FALSE;
+#if (MP_DRIVER == 1)
+	bStartContTx = pAdapter->MptCtx.bStartContTx;
+#endif
+
+	//ignore IQK when continuous Tx
+	if(bStartContTx)
+		return;
+
+#if DISABLE_BB_RF
+	return;
+#endif
+
+	if(bReCovery)
+	{
+		_PHY_ReloadADDARegisters(pAdapter, IQK_BB_REG, pHalData->IQK_BB_backup, 10);
+		return;
+	}
+
+        DBG_8192C("IQK:Start!!!\n");
+
+	for(i = 0; i < 8; i++)
+	{
+		result[0][i] = 0;
+		result[1][i] = 0;
+		result[2][i] = 0;
+		result[3][i] = 0;
+	}
+	final_candidate = 0xff;
+	bPathAOK = _FALSE;
+	bPathBOK = _FALSE;
+	is12simular = _FALSE;
+	is23simular = _FALSE;
+	is13simular = _FALSE;
+
+	for (i=0; i<3; i++)
+	{
+	 	if(IS_92C_SERIAL( pHalData->VersionID)){
+			 _PHY_IQCalibrate(pAdapter, result, i, _TRUE);
+	 		//_PHY_DumpRFReg(pAdapter);
+	 	}
+	 	else{
+	 		// For 88C 1T1R
+	 		_PHY_IQCalibrate(pAdapter, result, i, _FALSE);
+ 		}
+		
+		if(i == 1)
+		{
+			is12simular = _PHY_SimularityCompare(pAdapter, result, 0, 1);
+			if(is12simular)
+			{
+				final_candidate = 0;
+				break;
+			}
+		}
+		
+		if(i == 2)
+		{
+			is13simular = _PHY_SimularityCompare(pAdapter, result, 0, 2);
+			if(is13simular)
+			{
+				final_candidate = 0;			
+				break;
+			}
+			
+			is23simular = _PHY_SimularityCompare(pAdapter, result, 1, 2);
+			if(is23simular)
+				final_candidate = 1;
+			else
+			{
+				for(i = 0; i < 8; i++)
+					RegTmp += result[3][i];
+
+				if(RegTmp != 0)
+					final_candidate = 3;			
+				else
+					final_candidate = 0xFF;
+			}
+		}
+	}
+
+        for (i=0; i<4; i++)
+	{
+		RegE94 = result[i][0];
+		RegE9C = result[i][1];
+		RegEA4 = result[i][2];
+		RegEAC = result[i][3];
+		RegEB4 = result[i][4];
+		RegEBC = result[i][5];
+		RegEC4 = result[i][6];
+		RegECC = result[i][7];
+		//RTPRINT(FINIT, INIT_IQK, ("IQK: RegE94=%lx RegE9C=%lx RegEA4=%lx RegEAC=%lx RegEB4=%lx RegEBC=%lx RegEC4=%lx RegECC=%lx\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC));
+	}
+
+	if(final_candidate != 0xff)
+	{
+		pHalData->RegE94 = RegE94 = result[final_candidate][0];
+		pHalData->RegE9C = RegE9C = result[final_candidate][1];
+		RegEA4 = result[final_candidate][2];
+		RegEAC = result[final_candidate][3];
+		pHalData->RegEB4 = RegEB4 = result[final_candidate][4];
+		pHalData->RegEBC = RegEBC = result[final_candidate][5];
+		RegEC4 = result[final_candidate][6];
+		RegECC = result[final_candidate][7];
+		
+		DBG_8192C("IQK: final_candidate is %x\n", final_candidate);
+		
+		DBG_8192C("IQK: RegE94=%x RegE9C=%x RegEA4=%x RegEAC=%x RegEB4=%x RegEBC=%x RegEC4=%x RegECC=%x\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC);
+		
+		bPathAOK = bPathBOK = _TRUE;
+	}
+	else
+	{
+		pHalData->RegE94 = pHalData->RegEB4 = 0x100;	//X default value
+		pHalData->RegE9C = pHalData->RegEBC = 0x0;		//Y default value
+	}
+	
+	if((RegE94 != 0)/*&&(RegEA4 != 0)*/)
+		_PHY_PathAFillIQKMatrix(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
+	
+	if(IS_92C_SERIAL( pHalData->VersionID)){
+		if((RegEB4 != 0)/*&&(RegEC4 != 0)*/)
+		_PHY_PathBFillIQKMatrix(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+	}
+	_PHY_SaveADDARegisters(pAdapter, IQK_BB_REG, pHalData->IQK_BB_backup, 10);
+
+	#ifdef RTL8192C_RECONFIG_TO_1T1R
+	if(IS_92C_SERIAL(pHalData->VersionID))
+		//path B to standby mode
+		PHY_SetBBReg(pAdapter, 0x844, bMaskDWord, 0x00010000);
+	#endif
+
+}
+
+
+VOID
+PHY_LCCalibrate(
+	IN	PADAPTER	pAdapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	BOOLEAN 		bStartContTx = _FALSE;
+#if (MP_DRIVER == 1)	
+	bStartContTx = pAdapter->MptCtx.bStartContTx;
+#endif
+
+#if DISABLE_BB_RF
+	return;
+#endif
+
+	//ignore IQK when continuous Tx
+	if(bStartContTx)
+		return;
+
+	if(IS_92C_SERIAL( pHalData->VersionID)){
+		_PHY_LCCalibrate(pAdapter, _TRUE);
+	}
+	else{
+		// For 88C 1T1R
+		_PHY_LCCalibrate(pAdapter, _FALSE);
+	}
+}
+
+VOID
+PHY_APCalibrate(
+	IN	PADAPTER	pAdapter,
+	IN	char 		delta	
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+#if DISABLE_BB_RF
+	return;
+#endif
+
+	if(pHalData->bAPKdone)
+		return;
+
+//	if(IS_NORMAL_CHIP(pHalData->VersionID))
+//		return;
+
+	if(IS_92C_SERIAL( pHalData->VersionID)){
+		_PHY_APCalibrate(pAdapter, delta, _TRUE);
+	}
+	else{
+		// For 88C 1T1R
+		_PHY_APCalibrate(pAdapter, delta, _FALSE);
+	}
+}
+
+
+//
+// Move from phycfg.c to gen.c to be code independent later
+// 
+//-------------------------Move to other DIR later----------------------------*/
+#if (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+VOID
+DebugAllRegister_92SU_FPGA(
+	IN	PADAPTER			Adapter
+	)
+{
+	static u32	sMacRegCnt = 0x37c; 
+	//static u4Byte	sCckRegCnt = 95; 
+	//static u4Byte	sOfdmRegCnt = 64; 
+	
+	u32	i;
+	u32	u4bMacReg; 
+	
+	// MAC registers
+	//RT_TRACE(COMP_FPGA, DBG_LOUD, ("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"));
+	//RT_TRACE(COMP_FPGA, DBG_LOUD, ("MAC Registers:\n"));
+	for(i = 0; i < sMacRegCnt; i+=4)
+	{
+		if(i%16 == 0)
+	{
+			if(i > 0)
+		{
+				//RT_TRACE(COMP_FPGA, DBG_LOUD, ("\n"));
+		}
+			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("%03lX              ", i));
+			}
+		u4bMacReg = rtw_read32(Adapter, i);
+		//RT_TRACE(COMP_FPGA, DBG_LOUD, ("%08lX    ", u4bMacReg));
+		}
+	//RT_TRACE(COMP_FPGA, DBG_LOUD, ("\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"));
+}
+
+#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
+//
+//	Description:
+// 		To dump all Tx FIFO LLT related link-list table.
+//		Added by Roger, 2009.03.10.
+//
+VOID
+DumpAllTxFIFO_92SU(
+	IN	PADAPTER			Adapter
+	)
+{
+	u8	PageIdx;
+	u32	u4bFIFOReg;	
+	u8	PktOffset, QueueSel;
+	
+	if(Adapter->DumpAllTxFIFO)
+	{
+		//RT_TRACE(COMP_TXAGG, DBG_SERIOUS, ("\nDump all Tx FIFO Reg Section1:\n"));
+		for(PageIdx=0; PageIdx<0xff; PageIdx++)
+		{
+			rtw_write32(Adapter, 0x2b0, 0xb0280000+PageIdx*8);
+			u4bFIFOReg = rtw_read32(Adapter, 0x2b4);
+			//RT_TRACE(COMP_TXAGG, DBG_SERIOUS, ("%#x:\t%08x\n", PageIdx, u4bFIFOReg));
+		}
+
+		//RT_TRACE(COMP_TXAGG, DBG_SERIOUS, ("\nDump all Tx FIFO Reg Section2:\n"));
+		for(PageIdx=0; PageIdx<0xff; PageIdx++)
+		{
+			rtw_write32(Adapter, 0x2b0, 0xb0270000+PageIdx*8);
+			u4bFIFOReg = rtw_read32(Adapter, 0x2b4);
+			//RT_TRACE(COMP_TXAGG, DBG_SERIOUS, ("%#x:\t%08x\n", PageIdx, u4bFIFOReg));
+		}
+
+		//RT_TRACE(COMP_TXAGG, DBG_SERIOUS, ("\nDump Specific Data section:\n"));
+		for(PageIdx=0; PageIdx<0xff; PageIdx++)
+		{
+			rtw_write16(Adapter, 0x348, 0x2000+PageIdx*0x20);
+			u4bFIFOReg = rtw_read32(Adapter, 0x340);
+			PktOffset = (u8)((u4bFIFOReg & 0x00ff0000)>>16);			
+			u4bFIFOReg = rtw_read32(Adapter, 0x344);
+			QueueSel = (u8)((u4bFIFOReg & 0x00001f00)>>8);
+			if((PktOffset == 0x20) && (QueueSel == 0x13))
+			{
+				//RT_TRACE(COMP_TXAGG, DBG_SERIOUS, ("PageIdx(%#x) contain PktOffset0x20 with QueueSel0x13!!\n", PageIdx));
+			}
+		}		
+		Adapter->DumpAllTxFIFO = FALSE;
+	}
+}
+#endif
+
+
+
+//
+//	Description:
+// 		To dump all Tx FIFO LLT related link-list table.
+//		Added by Roger, 2009.03.10.
+//
+VOID
+DumpBBDbgPort_92CU(
+	IN	PADAPTER			Adapter
+	)
+{
+
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"));
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("BaseBand Debug Ports:\n"));
+	
+	PHY_SetBBReg(Adapter, 0x0908, 0xffff, 0x0000);
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xdf4, PHY_QueryBBReg(Adapter, 0x0df4, bMaskDWord)));
+	
+	PHY_SetBBReg(Adapter, 0x0908, 0xffff, 0x0803);
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xdf4, PHY_QueryBBReg(Adapter, 0x0df4, bMaskDWord)));
+	
+	PHY_SetBBReg(Adapter, 0x0908, 0xffff, 0x0a06);
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xdf4, PHY_QueryBBReg(Adapter, 0x0df4, bMaskDWord)));
+
+	PHY_SetBBReg(Adapter, 0x0908, 0xffff, 0x0007);
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xdf4, PHY_QueryBBReg(Adapter, 0x0df4, bMaskDWord)));
+
+	PHY_SetBBReg(Adapter, 0x0908, 0xffff, 0x0100);
+	PHY_SetBBReg(Adapter, 0x0a28, 0x00ff0000, 0x000f0000);	
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xdf4, PHY_QueryBBReg(Adapter, 0x0df4, bMaskDWord)));
+
+	PHY_SetBBReg(Adapter, 0x0908, 0xffff, 0x0100);
+	PHY_SetBBReg(Adapter, 0x0a28, 0x00ff0000, 0x00150000);	
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xdf4, PHY_QueryBBReg(Adapter, 0x0df4, bMaskDWord)));
+
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0x800, PHY_QueryBBReg(Adapter, 0x0800, bMaskDWord)));
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0x900, PHY_QueryBBReg(Adapter, 0x0900, bMaskDWord)));
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xa00, PHY_QueryBBReg(Adapter, 0x0a00, bMaskDWord)));
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xa54, PHY_QueryBBReg(Adapter, 0x0a54, bMaskDWord)));
+	//RT_TRACE(COMP_SEND, DBG_WARNING, ("Offset[%x]: %x\n", 0xa58, PHY_QueryBBReg(Adapter, 0x0a58, bMaskDWord)));
+
+}
+
+
+
+VOID
+RtUsbCheckForHangWorkItemCallback(
+                IN void*   pContext
+)
+{
+#if 0
+	PADAPTER	  Adapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+#if (HAL_CODE_BASE!=RTL8192_C)
+	RESET_TYPE	ResetType = RESET_TYPE_NORESET;
+	static u1Byte	check_reset_cnt=0;
+#endif
+
+	RT_TRACE(COMP_INIT, DBG_LOUD, (" ==>RtUsbCheckForHangWorkItemCallback()\n"));
+	
+	// <Roger_Notes> To check whether we should put out device into D2.
+	if(PlatformUsbChkSelectiveSuspend(Adapter))
+		Adapter->HalFunc.HalEnterSSHandler(Adapter); 
+
+	NicIFLinkStatusWatchdog(Adapter);
+
+	//
+	// <Roger_Notes> Schedule another system worker thread to perform Tx/Rx stuck checking.
+	// to prevent driver running out of kernel-mode stack. 2009.07.14.
+	//
+#if (HAL_CODE_BASE==RTL8192_C)
+
+#if (SILENT_RESET && (DEV_BUS_TYPE != DEV_BUS_USB_INTERFACE))
+	if((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))	
+		PlatformScheduleWorkItem(&(pHalData->RtUsbCheckResetWorkItem));
+#endif
+
+#else
+	//check if reset the driver
+	// Give a chance check and indicate whether ap is disapeared(driver activate roam first), 2008.07.17 ,Lanhsin
+	//if((check_reset_cnt++>=Reset_Cnt_Limit) && (!MgntRoamingInProgress(pMgntInfo)))
+	if((check_reset_cnt++>=Reset_Cnt_Limit))
+	{
+    		ResetType = NicIFCheckResetOrNot(Adapter);
+		check_reset_cnt = Reset_Cnt_Limit;
+	}
+
+	// Silent Reset for 8192
+	if( (Adapter->ResetProgress==RESET_TYPE_NORESET) &&
+	     (!Adapter->bResetInProgress) &&
+	     (Adapter->bForcedSilentReset || (ResetType==RESET_TYPE_SILENT))) // This is control by OID set in Pomelo
+	{
+		Adapter->bResetInProgress = TRUE;
+	
+		// <Roger_Notes> Export necessary BaseBand debug port to dump specific information. 2009.05.25.
+		DumpBBDbgPort_92CU(Adapter);	
+	
+#if (SILENT_RESET==1)       
+		NicIFSilentReset(Adapter);
+#else
+		//Cancel All Pending In Irp
+		PlatformUsbDisableInPipes(Adapter);
+
+		 //Cancel All Pending Out Irp
+		PlatformUsbDisableOutPipes(Adapter);
+
+		//wait for complet all pending irp, the value should varies with nic and driver
+		PlatformStallExecution(1000);
+
+		// Re-Open Out Pipes.
+		// This shall be done before FW download.
+		PlatformUsbEnableOutPipes(Adapter);
+
+		// Reset Tx/Rx data structure in driver.
+		NicIFResetMemory(Adapter);
+#endif
+	}
+        Adapter->bForcedSilentReset = FALSE;
+	Adapter->bResetInProgress = FALSE;
+#endif
+
+	RT_TRACE(COMP_INIT, DBG_LOUD, (" <==RtUsbCheckForHangWorkItemCallback()\n"));
+#endif
+}
+
+
+//
+//	Description:
+// 		To check whether we shall reset out NIC immediately. We schedule 
+//		another system worker thread to prevent driver running out of kernel-mode stack.
+//		Added by Roger, 2009.07.14.
+//
+VOID
+RtUsbCheckResetWorkItemCallback(
+                IN void*   pContext
+)
+{
+#if 0
+	PADAPTER	  Adapter = (PADAPTER)pContext;
+	RESET_TYPE	ResetType = RESET_TYPE_NORESET;
+      	PMGNT_INFO      pMgntInfo = &Adapter->MgntInfo;
+	static u1Byte	check_reset_cnt=0;
+	
+	RT_TRACE(COMP_RESET, DBG_TRACE, (" ==>RtUsbCheckResetWorkItemCallback()\n"));
+	
+	if(Adapter->bDriverStopped || Adapter->bSurpriseRemoved)
+		return;
+	
+#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
+	//vivi temply mask, 20090811
+	DumpAllTxFIFO_92SU(Adapter);	
+#endif
+
+	// Post-Processing Selective Suspend leave.
+	if(PlatformUsbSelectiveSuspendLeavePostProc(Adapter))
+	{
+		ResetType = RESET_TYPE_SILENT;		
+		RT_TRACE(COMP_RESET|COMP_POWER, DBG_TRACE, ("RtUsbCheckResetWorkItemCallback(): Force reset!!\n"));
+	}	
+	else if((check_reset_cnt++>=Reset_Cnt_Limit))
+	{
+    		ResetType = NicIFCheckResetOrNot(Adapter);
+		check_reset_cnt = Reset_Cnt_Limit;
+	}
+
+
+	// Silent Reset for 8192
+	if( (Adapter->ResetProgress==RESET_TYPE_NORESET) &&
+	     (!Adapter->bResetInProgress) &&
+	     (Adapter->bForcedSilentReset || (ResetType==RESET_TYPE_SILENT))) // This is control by OID set in Pomelo
+	{
+		Adapter->bResetInProgress = TRUE;
+	
+		RT_TRACE(COMP_RESET, DBG_WARNING, ("RtUsbCheckResetWorkItemCallback(): Reset in progress...\n"));
+		
+		// <Roger_Notes> Export necessary BaseBand debug port to dump specific information. 2009.05.25.
+		//DumpBBDbgPort_92CU(Adapter);	
+	
+#if (SILENT_RESET==1)       
+		NicIFSilentReset(Adapter);
+#else
+		//Cancel All Pending In Irp
+		PlatformUsbDisableInPipes(Adapter);
+
+		 //Cancel All Pending Out Irp
+		PlatformUsbDisableOutPipes(Adapter);
+
+		//wait for complet all pending irp, the value should varies with nic and driver
+		PlatformStallExecution(1000);
+
+		// Re-Open Out Pipes.
+		// This shall be done before FW download.
+		PlatformUsbEnableOutPipes(Adapter);
+
+		// Reset Tx/Rx data structure in driver.
+		NicIFResetMemory(Adapter);
+#endif
+	}
+
+        Adapter->bForcedSilentReset = FALSE;
+	Adapter->bResetInProgress = FALSE;
+
+	RT_TRACE(COMP_RESET, DBG_TRACE, (" <==RtUsbCheckResetWorkItemCallback()\n"));
+#endif
+}
+
+//
+// Callback routine of the work item for set bandwidth mode.
+//
+VOID
+SetBWModeCallback8192CUsbWorkItem(
+    IN void*            pContext
+    )
+{
+	PADAPTER		Adapter = (PADAPTER)pContext;
+
+	_PHY_SetBWMode92C(Adapter);
+}
+
+#if 0
+VOID
+SwChnlCallback8192CUsb(
+	IN	PRT_TIMER		pTimer
+	)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte			delay;
+
+	RT_TRACE(COMP_SCAN, DBG_LOUD, ("==>SwChnlCallback8190Pci(), switch to channel\
+				%d\n", pHalData->CurrentChannel));
+	
+	if(Adapter->bDriverStopped)
+		return;
+	
+	if(pHalData->RFChipID == RF_PSEUDO_11N)
+	{
+		pHalData->SwChnlInProgress=FALSE;
+		return; 								//return immediately if it is peudo-phy	
+	}
+	
+	do{
+		if(!pHalData->SwChnlInProgress)
+			break;
+
+		if(!phy_SwChnlStepByStep(Adapter, pHalData->CurrentChannel, &pHalData->SwChnlStage, &pHalData->SwChnlStep, &delay))
+		{
+			if(delay>0)
+			{
+				//PlatformSetTimer(Adapter, &pHalData->SwChnlTimer, delay);
+			}
+			else
+			continue;
+		}
+		else
+		{
+			//pHalData->SwChnlInProgress=FALSE;
+		}
+		break;
+	}while(_TRUE);
+}
+#endif
+
+//
+// Callback routine of the work item for switch channel.
+//
+VOID
+SwChnlCallback8192CUsbWorkItem(
+    IN void*            pContext
+    )
+{
+	PADAPTER	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	//RT_TRACE(COMP_TRACE, DBG_LOUD, ("==> SwChnlCallback8192CUsbWorkItem()\n"));
+
+	//if(pAdapter->bInSetPower && RT_USB_CANNOT_IO(pAdapter))
+	//{
+		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("<== SwChnlCallback8192CUsbWorkItem() SwChnlInProgress FALSE driver sleep or unload\n"));
+	
+		//pHalData->SwChnlInProgress = FALSE;		
+	//	return;
+	//}
+
+	phy_FinishSwChnlNow(pAdapter, pHalData->CurrentChannel);
+	//pHalData->SwChnlInProgress = FALSE;
+	
+	//RT_TRACE(COMP_TRACE, DBG_LOUD, ("<== SwChnlCallback8192CUsbWorkItem()\n"));
+}
+
+#endif
+
+#if 0
+BOOLEAN
+HalSetIO8192C(
+	IN	PADAPTER			pAdapter,
+	IN	IO_TYPE				IOType
+)
+{
+	PADAPTER		Adapter = ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, TRUE);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	BOOLEAN			bPostProcessing = FALSE;
+
+	if(RT_USB_CANNOT_IO(pAdapter))
+		return TRUE;	
+
+	RT_TRACE(COMP_CMD, DBG_LOUD, ("-->HalSetIO8192C(): Set IO Cmd(%#x), SetIOInProgress(%d)\n", 
+		IOType, pHalData->SetIOInProgress));
+
+	do{
+		switch(IOType)
+		{
+			case IO_CMD_RESUME_DM_BY_SCAN:
+				RT_TRACE(COMP_CMD, DBG_LOUD, ("[IO CMD] Resume DM after scan.\n"));
+				bPostProcessing = TRUE;
+				break;
+			case IO_CMD_PAUSE_DM_BY_SCAN:
+				RT_TRACE(COMP_CMD, DBG_LOUD, ("[IO CMD] Pause DM before scan.\n"));
+				bPostProcessing = TRUE;
+				break;
+			default:				
+				break;
+		}
+	}while(FALSE);
+
+	if(bPostProcessing && !pHalData->SetIOInProgress)
+	{
+		if(RT_USB_CANNOT_IO(Adapter))
+		{
+			RT_TRACE(COMP_CMD, DBG_WARNING, ("HalSetIO8192S(): USB can NOT IO!!\n"));
+			return FALSE;
+		}
+		pHalData->SetIOInProgress = TRUE;
+		pHalData->CurrentIOType = IOType; 
+	}
+	else
+	{
+		return FALSE;
+	}
+
+#ifdef USE_WORKITEM			
+	PlatformScheduleWorkItem(&(pHalData->IOWorkItem));
+#else
+	PlatformSetTimer(Adapter, &(pHalData->SetIOTimer), 0);
+#endif
+	RT_TRACE(COMP_CMD, DBG_LOUD, ("<--HalSetIO8192C(): Set IO Type(%#x)\n", IOType));
+
+	return TRUE;
+}
+
+VOID
+phy_SetIO(
+    PADAPTER		pAdapter
+    )
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PMGNT_INFO	pMgntInfo = &pAdapter->MgntInfo;
+	
+	if(RT_USB_CANNOT_IO(pAdapter) || pAdapter->bResetInProgress)	
+	{			
+		RT_TRACE(COMP_CMD, DBG_WARNING, ("phy_SetIO(): USB can NOT IO return\n"));
+		pHalData->SetIOInProgress = FALSE;
+		return;
+	}
+
+	RT_TRACE(COMP_CMD, DBG_LOUD, ("--->phy_SetIO(): Cmd(%#x), SetIOInProgress(%d)\n", 
+			pHalData->CurrentIOType, pHalData->SetIOInProgress));
+			
+	switch(pHalData->CurrentIOType)
+	{
+		case IO_CMD_RESUME_DM_BY_SCAN:
+			DM_DigTable.CurIGValue = pMgntInfo->InitGain_Backup.XAAGCCore1;
+			DM_Write_DIG(pAdapter);
+			pAdapter->HalFunc.SetTxPowerLevelHandler(pAdapter, pHalData->CurrentChannel);
+			break;		
+		case IO_CMD_PAUSE_DM_BY_SCAN:
+			pMgntInfo->InitGain_Backup.XAAGCCore1 = DM_DigTable.CurIGValue;
+			DM_DigTable.CurIGValue = 0x17;
+			DM_Write_DIG(pAdapter);
+			break;
+		default:
+			break;
+	}	
+	pHalData->SetIOInProgress = FALSE;// Clear FW CMD operation flag.
+	RT_TRACE(COMP_CMD, DBG_LOUD, ("<---phy_SetIO(): CurrentIOType(%#x)\n", pHalData->CurrentIOType));
+	
+}			
+
+#ifdef USE_WORKITEM
+VOID
+SetIOWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	if(RT_USB_CANNOT_IO(pAdapter) || pAdapter->bResetInProgress)
+	{
+		RT_TRACE(COMP_CMD, DBG_WARNING, ("SetIOWorkItemCallback(): USB can NOT IO return\n"));
+		pHalData->SetIOInProgress = FALSE;
+		return;
+	}
+	phy_SetIO(pAdapter);
+}
+			
+#else
+
+//
+// 	Callback routine of the timer callback for FW Cmd IO.
+//
+//	Description:
+//		This routine will send specific CMD IO to FW and check whether it is done.
+//
+VOID
+SetIOTimerCallback(
+   IN		PRT_TIMER		pTimer
+   )
+{
+	PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
+
+	if(Adapter->bDriverStopped)
+	{
+		RT_TRACE(COMP_RATE, DBG_TRACE, ("SetIOTimerCallback(): driver is going to unload\n"));
+		return;
+	}
+	phy_SetIO(Adapter);	
+}
+
+//
+// 2008/12/26 MH When we switch EPHY parameter. We must delay to wait ready bit.
+// We wait at most 1000*100 us.
+//
+static	VOID
+phy_CheckEphySwitchReady(
+	IN	PADAPTER			Adapter
+	)
+{
+	u4Byte	delay = 1000;
+	u1Byte	regu1;
+
+	regu1 = PlatformEFIORead1Byte(Adapter, 0x554);
+	while ((regu1 & BIT5) && (delay > 0))
+	{
+		regu1 = PlatformEFIORead1Byte(Adapter, 0x554);
+		delay--;
+		delay_us(100);
+	}	
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("regu1=%02x  delay = %ld\n", regu1, delay));	
+	
+}	// phy_CheckEphySwitchReady
+
+#endif
+
+BOOLEAN
+SetAntennaConfig92C(
+	IN	PADAPTER		pAdapter,
+	IN	u1Byte			DefaultAnt		// 0: Main, 1: Aux.
+)
+{
+	HAL_DATA_TYPE			*pHalData	= GET_HAL_DATA(pAdapter);
+	PMGNT_INFO				pMgntInfo = &(pAdapter->MgntInfo);
+	u4Byte					ulAntennaTx, ulAntennaRx;
+	R_ANTENNA_SELECT_OFDM	*p_ofdm_tx;	/* OFDM Tx register */
+	R_ANTENNA_SELECT_CCK	*p_cck_txrx;
+	u1Byte					r_rx_antenna_ofdm=0, r_ant_select_cck_val=0;
+	u1Byte					chgTx=0, chgRx=0;
+	u4Byte					r_ant_sel_cck_val=0, r_ant_select_ofdm_val=0, r_ofdm_tx_en_val=0;
+	u1Byte					rfChg = 0;
+	static	u1Byte			TestStart=0;
+
+
+	if(!TestStart)
+	{
+		TestStart = 1;
+		rfChg = 1;
+	}
+
+	pMgntInfo->AntennaTest = 1;
+	pHalData->AntennaTxPath = ANTENNA_A;
+	if(DefaultAnt == 0)	//ANTENNA_A
+	{
+		if(pHalData->AntennaRxPath == ANTENNA_B)	//from B switch to A
+			rfChg = 1;
+		pHalData->AntennaRxPath = ANTENNA_A;
+	}
+	else
+	{
+		if(pHalData->AntennaRxPath == ANTENNA_A)	//from A switch to B
+			rfChg = 1;
+		pHalData->AntennaRxPath = ANTENNA_B;
+	}
+
+	ulAntennaTx = pHalData->AntennaTxPath;
+	ulAntennaRx = pHalData->AntennaRxPath;
+	
+	p_ofdm_tx = (R_ANTENNA_SELECT_OFDM *)&r_ant_select_ofdm_val;
+	p_cck_txrx = (R_ANTENNA_SELECT_CCK *)&r_ant_select_cck_val;
+
+	
+	p_ofdm_tx->r_ant_ht1			= 0x1;
+	p_ofdm_tx->r_ant_ht2			= 0x2;	// Second TX RF path is A
+	p_ofdm_tx->r_ant_non_ht 		= 0x3;	// 0x1+0x2=0x3
+
+	// ]OTx 3-wire enableHTx Ant path}~|}A
+	// Hb]BB 0x824P0x82CAPNBB 0x804[3:0]]3(P}Ant. A and B)C
+	// nqpUAA Tx 0x90C=0x11111111AB Tx 0x90C=0x22222222AABP}N]w0x3321333
+	
+	switch(ulAntennaTx)
+	{
+	case ANTENNA_A:
+		p_ofdm_tx->r_tx_antenna		= 0x1;
+		r_ofdm_tx_en_val			= 0x1;
+		p_ofdm_tx->r_ant_l 			= 0x1;
+		p_ofdm_tx->r_ant_ht_s1 		= 0x1;
+		p_ofdm_tx->r_ant_non_ht_s1 	= 0x1;
+		p_cck_txrx->r_ccktx_enable	= 0x8;
+		chgTx = 1;
+		// From SD3 Willis suggestion !!! Set RF A=TX and B as standby
+		if (IS_HARDWARE_TYPE_8192S(pAdapter))
+		{
+			PHY_SetBBReg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+			PHY_SetBBReg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 1);
+			r_ofdm_tx_en_val			= 0x3;
+			// Power save
+			r_ant_select_ofdm_val = 0x11111111;
+
+			// 2009/01/08 MH From Sd3 Willis. We need to close RFB by SW control
+			if (pHalData->RF_Type == RF_2T2R)
+			{
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 1);
+				PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT1, 1);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT17, 0);
+			}
+		}
+		break;
+	case ANTENNA_B:
+		p_ofdm_tx->r_tx_antenna		= 0x2;
+		r_ofdm_tx_en_val			= 0x2;
+		p_ofdm_tx->r_ant_l 			= 0x2;	
+		p_ofdm_tx->r_ant_ht_s1 		= 0x2;	
+		p_ofdm_tx->r_ant_non_ht_s1 	= 0x2;
+		p_cck_txrx->r_ccktx_enable	= 0x4;
+		chgTx = 1;
+		// From SD3 Willis suggestion !!! Set RF A as standby
+		if (IS_HARDWARE_TYPE_8192S(pAdapter))
+		{
+			PHY_SetBBReg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 1);
+			PHY_SetBBReg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+			r_ofdm_tx_en_val			= 0x3;
+			// Power save
+			r_ant_select_ofdm_val = 0x22222222;
+
+			// 2008/10/31 MH From SD3 Willi's suggestion. We must read RF 1T table.
+			// 2009/01/08 MH From Sd3 Willis. We need to close RFA by SW control
+			if (pHalData->RF_Type == RF_2T2R)
+			{
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 1);
+				PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, BIT10, 0);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0);
+				//PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT1, 0);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT17, 1);
+			}
+		}
+		break;
+
+	case ANTENNA_AB:	// For 8192S
+		p_ofdm_tx->r_tx_antenna		= 0x3;
+		r_ofdm_tx_en_val			= 0x3;
+		p_ofdm_tx->r_ant_l 			= 0x3;
+		p_ofdm_tx->r_ant_ht_s1 		= 0x3;
+		p_ofdm_tx->r_ant_non_ht_s1 	= 0x3;
+		p_cck_txrx->r_ccktx_enable	= 0xC;
+		chgTx = 1;
+		// From SD3 Willis suggestion !!! Set RF B as standby
+		if (IS_HARDWARE_TYPE_8192S(pAdapter))
+		{
+			PHY_SetBBReg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+			PHY_SetBBReg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+			// Disable Power save
+			r_ant_select_ofdm_val = 0x3321333;
+			
+			// 2009/01/08 MH From Sd3 Willis. We need to enable RFA/B by SW control
+			if (pHalData->RF_Type == RF_2T2R)
+			{
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0);
+
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0);
+				//PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT1, 1);
+				PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT17, 1);
+			}
+		}
+		break;
+			default:
+				break;
+	}
+	
+	//
+	// r_rx_antenna_ofdm, bit0=A, bit1=B, bit2=C, bit3=D
+	// r_cckrx_enable : CCK default, 0=A, 1=B, 2=C, 3=D
+	// r_cckrx_enable_2 : CCK option, 0=A, 1=B, 2=C, 3=D
+	//
+	switch(ulAntennaRx)
+	{
+	case ANTENNA_A:
+		r_rx_antenna_ofdm 			= 0x1;	// A
+		p_cck_txrx->r_cckrx_enable 	= 0x0;	// default: A
+		p_cck_txrx->r_cckrx_enable_2	= 0x0;	// option: A
+		chgRx = 1;
+		break;
+	case ANTENNA_B:
+		r_rx_antenna_ofdm 			= 0x2;	// B
+		p_cck_txrx->r_cckrx_enable 	= 0x1;	// default: B
+		p_cck_txrx->r_cckrx_enable_2	= 0x1;	// option: B
+		chgRx = 1;
+		break;
+	case ANTENNA_AB:	// For 8192S and 8192E/U...
+		r_rx_antenna_ofdm 			= 0x3;	// AB
+		p_cck_txrx->r_cckrx_enable 	= 0x0;	// default:A
+		p_cck_txrx->r_cckrx_enable_2= 0x1;		// option:B
+		chgRx = 1;
+		break;
+	default:
+		break;
+	}
+	//
+	// For 8192S later not make sure!!!! If we enable RF A only, we must set RF B reg 0x00
+	// as 0x10159 from SD3 suggestion!!! Not make sure the reason!!
+	//
+
+	//==================================================
+	
+	if(chgTx && chgRx)
+	{
+		switch(pHalData->RFChipID)
+		{
+			case RF_8225:
+			case RF_8256:
+			case RF_6052:
+				r_ant_sel_cck_val = r_ant_select_cck_val;
+				if(rfChg)
+				{
+					//DbgPrint("Write RF-path register!!\n");
+					PHY_SetBBReg(pAdapter, rFPGA1_TxInfo, 0xffffffff, r_ant_select_ofdm_val);		//OFDM Tx
+					PHY_SetBBReg(pAdapter, rFPGA0_TxInfo, 0x0000000f, r_ofdm_tx_en_val);		//OFDM Tx
+					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, 0x0000000f, r_rx_antenna_ofdm);	//OFDM Rx
+					PHY_SetBBReg(pAdapter, rOFDM1_TRxPathEnable, 0x0000000f, r_rx_antenna_ofdm);	//OFDM Rx
+					PHY_SetBBReg(pAdapter, rCCK0_AFESetting, bMaskByte3, r_ant_sel_cck_val);		//CCK TxRx
+				}
+				break;
+			default:
+				RT_ASSERT(FALSE, ("Unsupported RFChipID for switching antenna.\n"));
+				break;
+		}
+	}
+	//DbgPrint("\n MPT_ProSwitchAntenna() is finished \n");
+	return TRUE;
+}
+
+VOID
+FillA2Entry8192C(
+	IN	PADAPTER			Adapter,
+	IN	u1Byte				index,
+	IN	pu1Byte				val
+)
+{
+	u4Byte				A2entry_index;
+	
+	PlatformEFIOWrite4Byte(Adapter, 0x2c4, ((pu4Byte)(val))[0]);
+	PlatformEFIOWrite2Byte(Adapter, 0x2c8, ((pu2Byte)(val+4))[0]);
+
+	A2entry_index = (u4Byte)index;
+	//PlatformEFIOWrite4Byte(Adapter, WFM5, (FW_ADD_A2_ENTRY | (A2entry_index & 0xff)<<8)); 
+	Adapter->HalFunc.SetFwCmdHandler(Adapter, FW_CMD_ADD_A2_ENTRY);
+	RT_PRINT_ADDR(COMP_CMD, DBG_LOUD, ("Add A2 Entry:\n"), val);
+}
+
+
+//
+// 2009/11/03 MH add for LPS mode power save sequence.
+// 2009/11/03 According to document V10.
+// 2009/11/24 According to document V11. by tynli.
+//
+VOID
+phy_SetRTL8192CERfSleep(
+	IN	PADAPTER			Adapter
+)
+{
+	u4Byte	U4bTmp;
+	u1Byte	delay = 5; //5: suggested by Scott.
+
+	// a.	TXPAUSE 0x522[7:0] = 0xFF				//Pause MAC TX queue
+	PlatformEFIOWrite1Byte(Adapter, REG_TXPAUSE, 0xFF);
+
+	// b.	RF path 0 offset 0x00 = 0x00					// disable RF
+	PHY_SetRFReg(Adapter, RF90_PATH_A, 0x00, 0xFF, 0x00);
+
+	// c.	APSD_CTRL 0x600[7:0] = 0x40
+	PlatformEFIOWrite1Byte(Adapter, REG_APSD_CTRL, 0x40);
+
+	// d.	While( RF_PATH_A_REG_00 != 0) {
+	//	APSD_CTRL 0x600[7:0] = 0x00
+	//	RF path 0 offset 0x00 = 0x00
+	//	APSD_CTRL 0x600[7:0] = 0x40
+	//}
+	// Added by tynli. 2009.11.24. Reference from Scott document v10.
+	U4bTmp = PHY_QueryRFReg(Adapter, RF90_PATH_A, 0 ,bRFRegOffsetMask);
+	while(U4bTmp != 0 && delay > 0 )
+	{	
+		PlatformEFIOWrite1Byte(Adapter, REG_APSD_CTRL, 0x0);
+		PHY_SetRFReg(Adapter, RF90_PATH_A, 0x00, 0xFF, 0x00);
+		PlatformEFIOWrite1Byte(Adapter, REG_APSD_CTRL, 0x40);
+		U4bTmp = PHY_QueryRFReg(Adapter, RF90_PATH_A, 0 ,bRFRegOffsetMask);
+		delay--;
+	}
+
+	if(delay == 0)
+	{
+		//Jump out the LPS turn off sequence to RF_ON_EXCEP
+		PlatformEFIOWrite1Byte(Adapter, REG_APSD_CTRL, 0x00);
+	
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+		PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0xE2);
+		PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0xE3);
+#else
+		PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0x16);
+		PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0x17);
+#endif
+		PlatformEFIOWrite1Byte(Adapter, REG_TXPAUSE, 0x00);
+		RT_TRACE(COMP_POWER, DBG_LOUD, ("phy_SetRTL8192CERfSleep(): Fail !!! Switch RF timeout.\n"));
+		return;
+	}
+
+	// e.	For PCIE: SYS_FUNC_EN 0x02[7:0] = 0xE2	//reset BB TRX function
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0xE2);
+#else
+	//e. For USB: SYS_FUNC_EN 0x02[7:0] = 0x16	//reset BB TRX function
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0x16);
+#endif
+
+	// f.	SPS_CTRL 0x11[7:0] = 0x22
+	PlatformEFIOWrite1Byte(Adapter, REG_SPS0_CTRL, 0x22);
+
+	//g.	//SYS_CLKR 0x08[11] = 0					//gated MAC clock
+	//PlatformEFIOWrite2Byte(Adapter, 0x08, PlatformEFIORead2Byte(Adapter, 0x08)&~BIT11);
+
+	
+}	// phy_SetRTL8192CERfSleep
+
+
+//
+// 2009/11/03 MH add for LPS mode power save sequence.
+// 2009/11/03 According to document V10.
+// 2009/11/24 According to document V11. by tynli.
+//
+VOID
+phy_SetRTL8192CERfOn(
+	IN	PADAPTER			Adapter
+)
+{
+	// a.	//SYS_CLKR 0x08[11] = 1					//restore MAC clock
+	//PlatformEFIOWrite2Byte(Adapter, 0x08, PlatformEFIORead2Byte(Adapter, 0x08)|BIT11);
+
+	// b.	SPS_CTRL 0x11[7:0] = 0x2b
+	PlatformEFIOWrite1Byte(Adapter, REG_SPS0_CTRL, 0x2b);
+	//PHY_SetRFReg(Adapter, RF90_PATH_A, 0x00, 0xFF, 0x00);
+
+	// c.	For PCIE: SYS_FUNC_EN 0x02[7:0] = 0xE3	//enable BB TRX function
+	//	For USB: SYS_FUNC_EN 0x02[7:0] = 0x17
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0xE3);
+#else
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0x17);
+#endif
+
+	// RF_ON_EXCEP(d~g):
+	// d.	APSD_CTRL 0x600[7:0] = 0x00
+	PlatformEFIOWrite1Byte(Adapter, REG_APSD_CTRL, 0x00);
+
+	// e.	For PCIE: SYS_FUNC_EN 0x02[7:0] = 0xE2	//reset BB TRX function again
+	//f.	For PCIE: SYS_FUNC_EN 0x02[7:0] = 0xE3	//enable BB TRX function
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0xE2);
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0xE3);
+#else
+	// e.For USB: SYS_FUNC_EN 0x02[7:0] = 0x16
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0x16);
+	// f. For USB: SYS_FUNC_EN 0x02[7:0] = 0x17
+	PlatformEFIOWrite1Byte(Adapter, REG_SYS_FUNC_EN, 0x17);
+#endif
+
+	// g.	TXPAUSE 0x522[7:0] = 0x00				//enable MAC TX queue
+	PlatformEFIOWrite1Byte(Adapter, REG_TXPAUSE, 0x00);
+
+	
+}	// phy_SetRTL8192CERfSleep
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1014 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+/******************************************************************************
+ * 
+ *     (c) Copyright  2008, RealTEK Technologies Inc. All Rights Reserved.
+ * 
+ * Module:	HalRf6052.c	( Source C File)
+ * 
+ * Note:	Provide RF 6052 series relative API.	 
+ *
+ * Function:	
+ * 		 
+ * Export:	
+ * 
+ * Abbrev:	
+ * 
+ * History:
+ * Data			Who		Remark
+ * 
+ * 09/25/2008	MHC		Create initial version.
+ * 11/05/2008 	MHC		Add API for tw power setting.
+ * 
+ * 	
+******************************************************************************/
+
+#define _HAL_RF6052_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_byteorder.h>
+
+#include <hal_init.h>
+
+#include "Hal8192CPhyReg.h"
+#include "Hal8192CPhyCfg.h"
+#include "HalRf.h"
+
+
+
+/*---------------------------Define Local Constant---------------------------*/
+// Define local structure for debug!!!!!
+typedef struct RF_Shadow_Compare_Map {
+	// Shadow register value
+	u32		Value;
+	// Compare or not flag
+	u8		Compare;
+	// Record If it had ever modified unpredicted
+	u8		ErrorOrNot;
+	// Recorver Flag
+	u8		Recorver;
+	//
+	u8		Driver_Write;
+}RF_SHADOW_T;
+/*---------------------------Define Local Constant---------------------------*/
+
+
+/*------------------------Define global variable-----------------------------*/
+/*------------------------Define global variable-----------------------------*/
+
+
+/*------------------------Define local variable------------------------------*/
+// 2008/11/20 MH For Debug only, RF
+//static	RF_SHADOW_T	RF_Shadow[RF6052_MAX_PATH][RF6052_MAX_REG] = {0};
+static	RF_SHADOW_T	RF_Shadow[RF6052_MAX_PATH][RF6052_MAX_REG];
+/*------------------------Define local variable------------------------------*/
+
+
+/*---------------------Define local function prototype-----------------------*/
+VOID
+phy_RF6052_Config_HardCode(
+	IN	PADAPTER		Adapter
+	);
+
+int
+phy_RF6052_Config_ParaFile(
+	IN	PADAPTER		Adapter
+	);
+/*---------------------Define local function prototype-----------------------*/
+
+/*------------------------Define function prototype--------------------------*/
+extern	void		RF_ChangeTxPath(	IN	PADAPTER	Adapter, 
+										IN	u16		DataRate);
+
+/*------------------------Define function prototype--------------------------*/
+
+
+/*------------------------Define function prototype--------------------------*/
+/*-----------------------------------------------------------------------------
+ * Function:	RF_ChangeTxPath
+ *
+ * Overview:	For RL6052, we must change some RF settign for 1T or 2T.
+ *
+ * Input:		u2Byte DataRate		// 0x80-8f, 0x90-9f
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 09/25/2008 	MHC		Create Version 0.
+ *						Firmwaer support the utility later.
+ *
+ *---------------------------------------------------------------------------*/
+extern	void		RF_ChangeTxPath(	IN	PADAPTER	Adapter, 
+										IN	u16		DataRate)
+{
+// We do not support gain table change inACUT now !!!! Delete later !!!
+#if 0//(RTL92SE_FPGA_VERIFY == 0)
+	static	u1Byte	RF_Path_Type = 2;	// 1 = 1T 2= 2T			
+	static	u4Byte	tx_gain_tbl1[6] 
+			= {0x17f50, 0x11f40, 0x0cf30, 0x08720, 0x04310, 0x00100};
+	static	u4Byte	tx_gain_tbl2[6] 
+			= {0x15ea0, 0x10e90, 0x0c680, 0x08250, 0x04040, 0x00030};
+	u1Byte	i;
+	
+	if (RF_Path_Type == 2 && (DataRate&0xF) <= 0x7)
+	{
+		// Set TX SYNC power G2G3 loop filter
+		PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+					RF_TXPA_G2, bRFRegOffsetMask, 0x0f000);
+		PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+					RF_TXPA_G3, bRFRegOffsetMask, 0xeacf1);
+
+		// Change TX AGC gain table
+		for (i = 0; i < 6; i++)					
+			PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+						RF_TX_AGC, bRFRegOffsetMask, tx_gain_tbl1[i]);
+
+		// Set PA to high value
+		PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+					RF_TXPA_G2, bRFRegOffsetMask, 0x01e39);
+	}
+	else if (RF_Path_Type == 1 && (DataRate&0xF) >= 0x8)
+	{
+		// Set TX SYNC power G2G3 loop filter
+		PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+					RF_TXPA_G2, bRFRegOffsetMask, 0x04440);
+		PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+					RF_TXPA_G3, bRFRegOffsetMask, 0xea4f1);
+
+		// Change TX AGC gain table
+		for (i = 0; i < 6; i++)
+			PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+						RF_TX_AGC, bRFRegOffsetMask, tx_gain_tbl2[i]);
+
+		// Set PA low gain
+		PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, 
+					RF_TXPA_G2, bRFRegOffsetMask, 0x01e19);
+	}
+#endif	
+	
+}	/* RF_ChangeTxPath */
+
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_RF6052SetBandwidth()
+ *
+ * Overview:    This function is called by SetBWModeCallback8190Pci() only
+ *
+ * Input:       PADAPTER				Adapter
+ *			WIRELESS_BANDWIDTH_E	Bandwidth	//20M or 40M
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Note:		For RF type 0222D
+ *---------------------------------------------------------------------------*/
+VOID
+PHY_RF6052SetBandwidth(
+	IN	PADAPTER				Adapter,
+	IN	HT_CHANNEL_WIDTH		Bandwidth)	//20M or 40M
+{		
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	switch(Bandwidth)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			pHalData->RfRegChnlVal[0] = ((pHalData->RfRegChnlVal[0] & 0xfffff3ff) | 0x0400);
+			PHY_SetRFReg(Adapter, RF90_PATH_A, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[0]);
+			break;
+				
+		case HT_CHANNEL_WIDTH_40:
+			pHalData->RfRegChnlVal[0] = ((pHalData->RfRegChnlVal[0] & 0xfffff3ff));
+			PHY_SetRFReg(Adapter, RF90_PATH_A, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[0]);			
+			break;
+				
+		default:
+			//RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetRF8225Bandwidth(): unknown Bandwidth: %#X\n",Bandwidth ));
+			break;			
+	}
+	
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_RF6052SetCckTxPower
+ *
+ * Overview:	
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/05/2008 	MHC		Simulate 8192series..
+ *
+ *---------------------------------------------------------------------------*/
+#define		TxHighPwrLevel_Normal		0	
+#define		TxHighPwrLevel_Level1		1
+#define		TxHighPwrLevel_Level2		2
+
+extern	VOID
+PHY_RF6052SetCckTxPower(
+	IN	PADAPTER		Adapter,
+	IN	u8*			pPowerlevel)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	//PMGNT_INFO		pMgntInfo=&Adapter->MgntInfo;	
+	u32			TxAGC[2]={0, 0}, tmpval=0;
+	BOOLEAN			TurboScanOff = _FALSE;
+	u8			idx1, idx2;
+	u8*			ptr;
+
+	// 2010/10/18 MH Accorsing to SD3 eechou's suggestion, we need to disable turbo scan for RU.	
+	// Otherwise, external PA will be broken if power index > 0x20.
+	if((pEEPROM->EEPROMRegulatory != 0)||( pHalData->ExternalPA))
+		TurboScanOff = _TRUE;
+
+		
+	if( pmlmeext->sitesurvey_res.state == _TRUE)
+	{
+		TxAGC[RF90_PATH_A] = 0x3f3f3f3f;
+		TxAGC[RF90_PATH_B] = 0x3f3f3f3f;
+
+		TurboScanOff = _TRUE;
+		
+		if(TurboScanOff)
+		{
+			for(idx1=RF90_PATH_A; idx1<=RF90_PATH_B; idx1++)
+			{
+				TxAGC[idx1] = 
+					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
+					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
+
+#if (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+				// 2010/10/18 MH For external PA module. We need to limit power index to be less than 0x20.
+				if (TxAGC[idx1] > 0x20 && pHalData->ExternalPA)
+					TxAGC[idx1] = 0x20;
+#endif
+			}
+		}
+	}
+	else
+	{
+// 20100427 Joseph: Driver dynamic Tx power shall not affect Tx power. It shall be determined by power training mechanism.
+// Currently, we cannot fully disable driver dynamic tx power mechanism because it is referenced by BT coexist mechanism.
+// In the future, two mechanism shall be separated from each other and maintained independantly. Thanks for Lanhsin's reminder.
+
+		if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
+		{	
+			TxAGC[RF90_PATH_A] = 0x10101010;
+			TxAGC[RF90_PATH_B] = 0x10101010;
+		}
+		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
+		{	
+			TxAGC[RF90_PATH_A] = 0x00000000;
+			TxAGC[RF90_PATH_B] = 0x00000000;
+		}
+		else
+		{
+			for(idx1=RF90_PATH_A; idx1<=RF90_PATH_B; idx1++)
+			{
+				TxAGC[idx1] = 
+					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
+					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
+			}
+
+			if(pEEPROM->EEPROMRegulatory==0)
+			{
+				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][6]) + 
+						(pHalData->MCSTxPowerLevelOriginalOffset[0][7]<<8);
+				TxAGC[RF90_PATH_A] += tmpval;
+				
+				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][14]) + 
+						(pHalData->MCSTxPowerLevelOriginalOffset[0][15]<<24);
+				TxAGC[RF90_PATH_B] += tmpval;
+			}
+		}
+	}
+
+	for(idx1=RF90_PATH_A; idx1<=RF90_PATH_B; idx1++)
+	{
+		ptr = (u8*)(&(TxAGC[idx1]));
+		for(idx2=0; idx2<4; idx2++)
+		{
+			if(*ptr > RF6052_MAX_TX_PWR)
+				*ptr = RF6052_MAX_TX_PWR;
+			ptr++;
+		}
+	}
+
+	// rf-A cck tx power
+	tmpval = TxAGC[RF90_PATH_A]&0xff;
+	PHY_SetBBReg(Adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, tmpval);
+	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1M (rf-A) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_A_CCK1_Mcs32));
+	tmpval = TxAGC[RF90_PATH_A]>>8;
+	PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
+	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 2~11M (rf-A) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11));
+
+	// rf-B cck tx power
+	tmpval = TxAGC[RF90_PATH_B]>>24;
+	PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, tmpval);
+	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 11M (rf-B) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11));
+	tmpval = TxAGC[RF90_PATH_B]&0x00ffffff;
+	PHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
+	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n", 
+	//	tmpval, rTxAGC_B_CCK1_55_Mcs32));
+	
+}	/* PHY_RF6052SetCckTxPower */
+
+//
+// powerbase0 for OFDM rates
+// powerbase1 for HT MCS rates
+//
+void getPowerBase(
+	IN	PADAPTER	Adapter,
+	IN	u8*		pPowerLevel,
+	IN	u8		Channel,
+	IN OUT u32*	OfdmBase,
+	IN OUT u32*	MCSBase
+	)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32			powerBase0, powerBase1;
+	u8			Legacy_pwrdiff=0, HT20_pwrdiff=0;
+	u8			i, powerlevel[2];
+
+	for(i=0; i<2; i++)
+	{
+		powerlevel[i] = pPowerLevel[i];
+		Legacy_pwrdiff = pEEPROM->TxPwrLegacyHtDiff[i][Channel-1];			
+		powerBase0 = powerlevel[i] + Legacy_pwrdiff; 
+
+		powerBase0 = (powerBase0<<24) | (powerBase0<<16) |(powerBase0<<8) |powerBase0;
+		*(OfdmBase+i) = powerBase0;
+		//RTPRINT(FPHY, PHY_TXPWR, (" [OFDM power base index rf(%c) = 0x%x]\n", ((i==0)?'A':'B'), *(OfdmBase+i)));
+	}
+
+	for(i=0; i<2; i++)
+	{
+		//Check HT20 to HT40 diff
+		if(pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
+		{
+			HT20_pwrdiff = pEEPROM->TxPwrHt20Diff[i][Channel-1];
+			powerlevel[i] += HT20_pwrdiff;
+		}
+		powerBase1 = powerlevel[i];
+		powerBase1 = (powerBase1<<24) | (powerBase1<<16) |(powerBase1<<8) |powerBase1;
+		*(MCSBase+i) = powerBase1;
+		//RTPRINT(FPHY, PHY_TXPWR, (" [MCS power base index rf(%c) = 0x%x]\n", ((i==0)?'A':'B'), *(MCSBase+i)));
+	}
+}
+
+void getTxPowerWriteValByRegulatory(
+	IN		PADAPTER	Adapter,
+	IN		u8		Channel,
+	IN		u8		index,
+	IN		u32*		powerBase0,
+	IN		u32*		powerBase1,
+	OUT		u32*		pOutWriteVal
+	)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv *pdmpriv = &Adapter->dmpriv;
+	u8	i, chnlGroup, pwr_diff_limit[4];
+	u32 	writeVal, customer_limit, rf;
+	
+	//
+	// Index 0 & 1= legacy OFDM, 2-5=HT_MCS rate
+	//
+	for(rf=0; rf<2; rf++)
+	{
+		switch(pEEPROM->EEPROMRegulatory)
+		{
+			case 0:	// Realtek better performance
+					// increase power diff defined by Realtek for large power
+				chnlGroup = 0;
+				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n", 
+				//	chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
+				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] + 
+					((index<2)?powerBase0[rf]:powerBase1[rf]);
+				//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+				break;
+			case 1:	// Realtek regulatory
+					// increase power diff defined by Realtek for regulatory
+				if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
+				{
+					writeVal = ((index<2)?powerBase0[rf]:powerBase1[rf]);
+					//RTPRINT(FPHY, PHY_TXPWR, ("Realtek regulatory, 40MHz, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+				}
+				else
+				{
+					if(pHalData->pwrGroupCnt == 1)
+						chnlGroup = 0;
+					if(pHalData->pwrGroupCnt >= 3)
+					{
+						if(Channel <= 3)
+							chnlGroup = 0;
+						else if(Channel >= 4 && Channel <= 9)
+							chnlGroup = 1;
+						else if(Channel > 9)
+							chnlGroup = 2;
+						if(pHalData->pwrGroupCnt == 4)
+							chnlGroup++;
+					}
+					//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n", 
+					//chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
+					writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] + 
+							((index<2)?powerBase0[rf]:powerBase1[rf]);
+					//RTPRINT(FPHY, PHY_TXPWR, ("Realtek regulatory, 20MHz, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+				}
+				break;
+			case 2:	// Better regulatory
+					// don't increase any power diff
+				writeVal = ((index<2)?powerBase0[rf]:powerBase1[rf]);
+				//RTPRINT(FPHY, PHY_TXPWR, ("Better regulatory, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+				break;
+			case 3:	// Customer defined power diff.
+					// increase power diff defined by customer.
+				chnlGroup = 0;
+				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n", 
+				//	chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
+
+				if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
+				{
+					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 40MHz rf(%c) = 0x%x\n", 
+					//	((rf==0)?'A':'B'), pHalData->PwrGroupHT40[rf][Channel-1]));
+				}
+				else
+				{
+					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 20MHz rf(%c) = 0x%x\n", 
+					//	((rf==0)?'A':'B'), pHalData->PwrGroupHT20[rf][Channel-1]));
+				}
+				for (i=0; i<4; i++)
+				{
+					pwr_diff_limit[i] = (u8)((pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]&(0x7f<<(i*8)))>>(i*8));
+					if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
+					{
+						if(pwr_diff_limit[i] > pEEPROM->PwrGroupHT40[rf][Channel-1])
+							pwr_diff_limit[i] = pEEPROM->PwrGroupHT40[rf][Channel-1];
+					}
+					else
+					{
+						if(pwr_diff_limit[i] > pEEPROM->PwrGroupHT20[rf][Channel-1])
+							pwr_diff_limit[i] = pEEPROM->PwrGroupHT20[rf][Channel-1];
+					}
+				}
+				customer_limit = (pwr_diff_limit[3]<<24) | (pwr_diff_limit[2]<<16) |
+								(pwr_diff_limit[1]<<8) | (pwr_diff_limit[0]);
+				//RTPRINT(FPHY, PHY_TXPWR, ("Customer's limit rf(%c) = 0x%x\n", ((rf==0)?'A':'B'), customer_limit));
+
+				writeVal = customer_limit + ((index<2)?powerBase0[rf]:powerBase1[rf]);
+				//RTPRINT(FPHY, PHY_TXPWR, ("Customer, writeVal rf(%c)= 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+				break;
+			default:
+				chnlGroup = 0;
+				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] + 
+						((index<2)?powerBase0[rf]:powerBase1[rf]);
+				//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal rf(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+				break;
+		}
+
+		if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
+			writeVal = 0x14141414;
+		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
+			writeVal = 0x00000000;
+
+		*(pOutWriteVal+rf) = writeVal;
+	}
+}
+
+void writeOFDMPowerReg(
+	IN		PADAPTER	Adapter,
+	IN		u8		index,
+	IN 		u32*		pValue
+	)
+{
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u16 RegOffset_A[6] = {	rTxAGC_A_Rate18_06, rTxAGC_A_Rate54_24, 
+							rTxAGC_A_Mcs03_Mcs00, rTxAGC_A_Mcs07_Mcs04, 
+							rTxAGC_A_Mcs11_Mcs08, rTxAGC_A_Mcs15_Mcs12};
+	u16 RegOffset_B[6] = {	rTxAGC_B_Rate18_06, rTxAGC_B_Rate54_24, 
+							rTxAGC_B_Mcs03_Mcs00, rTxAGC_B_Mcs07_Mcs04,
+							rTxAGC_B_Mcs11_Mcs08, rTxAGC_B_Mcs15_Mcs12};
+	u8 i, rf, pwr_val[4];
+	u32 writeVal;
+	u16 RegOffset;
+
+	for(rf=0; rf<2; rf++)
+	{
+		writeVal = pValue[rf];
+		for(i=0; i<4; i++)
+		{
+			pwr_val[i] = (u8)((writeVal & (0x7f<<(i*8)))>>(i*8));
+			if (pwr_val[i]  > RF6052_MAX_TX_PWR)
+				pwr_val[i]  = RF6052_MAX_TX_PWR;
+		}
+		writeVal = (pwr_val[3]<<24) | (pwr_val[2]<<16) |(pwr_val[1]<<8) |pwr_val[0];
+
+		if(rf == 0)
+			RegOffset = RegOffset_A[index];
+		else
+			RegOffset = RegOffset_B[index];
+		
+		PHY_SetBBReg(Adapter, RegOffset, bMaskDWord, writeVal);
+		//RTPRINT(FPHY, PHY_TXPWR, ("Set 0x%x = %08x\n", RegOffset, writeVal));	
+	}
+}
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_RF6052SetOFDMTxPower
+ *
+ * Overview:	For legacy and HY OFDM, we must read EEPROM TX power index for 
+ *			different channel and read original value in TX power register area from
+ *			0xe00. We increase offset and original value to be correct tx pwr.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/05/2008 	MHC		Simulate 8192 series method.
+ * 01/06/2009	MHC		1. Prevent Path B tx power overflow or underflow dure to
+ *						A/B pwr difference or legacy/HT pwr diff.
+ *						2. We concern with path B legacy/HT OFDM difference.
+ * 01/22/2009	MHC		Support new EPRO format from SD3.
+ *
+ *---------------------------------------------------------------------------*/
+extern	VOID 
+PHY_RF6052SetOFDMTxPower(
+	IN	PADAPTER	Adapter,
+	IN	u8*		pPowerLevel,
+	IN	u8		Channel)
+{
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u32 writeVal[2], powerBase0[2], powerBase1[2];
+	u8 index = 0;	
+
+	getPowerBase(Adapter, pPowerLevel, Channel, &powerBase0[0], &powerBase1[0]);
+
+	for(index=0; index<6; index++)
+	{
+		getTxPowerWriteValByRegulatory(Adapter, Channel, index, 
+			&powerBase0[0], &powerBase1[0], &writeVal[0]);
+
+		writeOFDMPowerReg(Adapter, index, &writeVal[0]);
+	}
+	
+}
+
+
+int
+PHY_RF6052_Config(
+	IN	PADAPTER		Adapter)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	int					rtStatus = _SUCCESS;	
+	
+	//
+	// Initialize general global value
+	//
+	// TODO: Extend RF_PATH_C and RF_PATH_D in the future
+	if(pHalData->rf_type == RF_1T1R)
+		pHalData->NumTotalRFPath = 1;
+	else
+		pHalData->NumTotalRFPath = 2;
+
+	//
+	// Config BB and RF
+	//
+	rtStatus = phy_RF6052_Config_ParaFile(Adapter);
+#if 0	
+	switch( Adapter->MgntInfo.bRegHwParaFile )
+	{
+		case 0:
+			phy_RF6052_Config_HardCode(Adapter);
+			break;
+
+		case 1:
+			rtStatus = phy_RF6052_Config_ParaFile(Adapter);
+			break;
+
+		case 2:
+			// Partial Modify. 
+			phy_RF6052_Config_HardCode(Adapter);
+			phy_RF6052_Config_ParaFile(Adapter);
+			break;
+
+		default:
+			phy_RF6052_Config_HardCode(Adapter);
+			break;
+	}
+#endif	
+	return rtStatus;
+		
+}
+
+VOID
+phy_RF6052_Config_HardCode(
+	IN	PADAPTER		Adapter
+	)
+{
+	
+	// Set Default Bandwidth to 20M
+	//Adapter->HalFunc	.SetBWModeHandler(Adapter, HT_CHANNEL_WIDTH_20);
+
+	// TODO: Set Default Channel to channel one for RTL8225
+	
+}
+
+int
+phy_RF6052_Config_ParaFile(
+	IN	PADAPTER		Adapter
+	)
+{
+	u32					u4RegValue;
+	u8					eRFPath;		
+	BB_REGISTER_DEFINITION_T	*pPhyReg;	
+
+	int				rtStatus = _SUCCESS;
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
+	static u8				sz88CRadioAFile[] = RTL8188C_PHY_RADIO_A;	
+	static u8				sz88CRadioBFile[] = RTL8188C_PHY_RADIO_B;
+#if DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE	
+	static u8				sz88CRadioAFile_mCard[] = RTL8188C_PHY_RADIO_A_mCard;	
+	static u8				sz88CRadioBFile_mCard[] = RTL8188C_PHY_RADIO_B_mCard;
+	static u8				sz88CRadioAFile_HP[] = RTL8188C_PHY_RADIO_A_HP;	
+#endif
+	static u8				sz92CCRadioAFile[] = RTL8192C_PHY_RADIO_A;	
+	static u8				sz92CRadioBFile[] = RTL8192C_PHY_RADIO_B;
+	u8					*pszRadioAFile, *pszRadioBFile;	
+
+	if(IS_92C_SERIAL( pHalData->VersionID))// 88c's IPA  is different from 92c's
+	{
+		pszRadioAFile = (u8*)&sz92CCRadioAFile;
+		pszRadioBFile = (u8*)&sz92CRadioBFile;
+	}
+	else{
+#if DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE
+		if( BOARD_MINICARD == pHalData->BoardType)
+		{
+			pszRadioAFile = sz88CRadioAFile_mCard;
+			pszRadioBFile = sz88CRadioBFile_mCard;
+		}
+		else if( BOARD_USB_High_PA == pHalData->BoardType)
+		{
+			pszRadioAFile = sz88CRadioAFile_HP;
+		}
+		else
+#endif	
+		{
+			pszRadioAFile = (u8*)&sz88CRadioAFile;
+			pszRadioBFile = (u8*)&sz88CRadioBFile;
+		}
+	}
+
+	//3//-----------------------------------------------------------------
+	//3// <2> Initialize RF
+	//3//-----------------------------------------------------------------
+	//for(eRFPath = RF90_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	{
+
+		pPhyReg = &pHalData->PHYRegDef[eRFPath];
+		
+		/*----Store original RFENV control type----*/		
+		switch(eRFPath)
+		{
+		case RF90_PATH_A:
+		case RF90_PATH_C:
+			u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV);
+			break;
+		case RF90_PATH_B :
+		case RF90_PATH_D:
+			u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV<<16);
+			break;
+		}
+
+		/*----Set RF_ENV enable----*/		
+		PHY_SetBBReg(Adapter, pPhyReg->rfintfe, bRFSI_RFENV<<16, 0x1);
+		rtw_udelay_os(1);//PlatformStallExecution(1);
+		
+		/*----Set RF_ENV output high----*/
+		PHY_SetBBReg(Adapter, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);
+		rtw_udelay_os(1);//PlatformStallExecution(1);
+
+		/* Set bit number of Address and Data for RF register */
+		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, b3WireAddressLength, 0x0); 	// Set 1 to 4 bits for 8255
+		rtw_udelay_os(1);//PlatformStallExecution(1);
+
+		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, b3WireDataLength, 0x0);	// Set 0 to 12  bits for 8255
+		rtw_udelay_os(1);//PlatformStallExecution(1);
+
+		/*----Initialize RF fom connfiguration file----*/
+		switch(eRFPath)
+		{
+		case RF90_PATH_A:
+#ifdef CONFIG_EMBEDDED_FWIMG
+			rtStatus= PHY_ConfigRFWithHeaderFile(Adapter,(RF90_RADIO_PATH_E)eRFPath);
+#else
+			rtStatus = PHY_ConfigRFWithParaFile(Adapter, pszRadioAFile, (RF90_RADIO_PATH_E)eRFPath);
+#endif
+			break;
+		case RF90_PATH_B:
+#ifdef CONFIG_EMBEDDED_FWIMG
+			rtStatus= PHY_ConfigRFWithHeaderFile(Adapter,(RF90_RADIO_PATH_E)eRFPath);
+#else			
+			rtStatus = PHY_ConfigRFWithParaFile(Adapter, pszRadioBFile, (RF90_RADIO_PATH_E)eRFPath);
+#endif
+			break;
+		case RF90_PATH_C:
+			break;
+		case RF90_PATH_D:
+			break;
+		}
+
+		/*----Restore RFENV control type----*/;
+		switch(eRFPath)
+		{
+		case RF90_PATH_A:
+		case RF90_PATH_C:
+			PHY_SetBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV, u4RegValue);
+			break;
+		case RF90_PATH_B :
+		case RF90_PATH_D:
+			PHY_SetBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV<<16, u4RegValue);
+			break;
+		}
+
+		if(rtStatus != _SUCCESS){
+			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("phy_RF6052_Config_ParaFile():Radio[%d] Fail!!", eRFPath));
+			goto phy_RF6052_Config_ParaFile_Fail;
+		}
+
+	}
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("<---phy_RF6052_Config_ParaFile()\n"));
+	return rtStatus;
+	
+phy_RF6052_Config_ParaFile_Fail:	
+	return rtStatus;
+}
+
+
+//
+// ==> RF shadow Operation API Code Section!!!
+//
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_RFShadowRead
+ *				PHY_RFShadowWrite
+ *				PHY_RFShadowCompare
+ *				PHY_RFShadowRecorver
+ *				PHY_RFShadowCompareAll
+ *				PHY_RFShadowRecorverAll
+ *				PHY_RFShadowCompareFlagSet
+ *				PHY_RFShadowRecorverFlagSet
+ *
+ * Overview:	When we set RF register, we must write shadow at first.
+ *			When we are running, we must compare shadow abd locate error addr.
+ *			Decide to recorver or not.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/20/2008 	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+extern	u32
+PHY_RFShadowRead(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset)
+{
+	return	RF_Shadow[eRFPath][Offset].Value;
+	
+}	/* PHY_RFShadowRead */
+
+
+extern	VOID
+PHY_RFShadowWrite(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u32				Data)
+{
+	RF_Shadow[eRFPath][Offset].Value = (Data & bRFRegOffsetMask);
+	RF_Shadow[eRFPath][Offset].Driver_Write = _TRUE;
+	
+}	/* PHY_RFShadowWrite */
+
+
+extern	BOOLEAN
+PHY_RFShadowCompare(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset)
+{
+	u32	reg;
+	// Check if we need to check the register
+	if (RF_Shadow[eRFPath][Offset].Compare == _TRUE)
+	{
+		reg = PHY_QueryRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask);
+		// Compare shadow and real rf register for 20bits!!
+		if (RF_Shadow[eRFPath][Offset].Value != reg)
+		{
+			// Locate error position.
+			RF_Shadow[eRFPath][Offset].ErrorOrNot = _TRUE;
+			//RT_TRACE(COMP_INIT, DBG_LOUD, 
+			//("PHY_RFShadowCompare RF-%d Addr%02lx Err = %05lx\n", 
+			//eRFPath, Offset, reg));
+		}
+		return RF_Shadow[eRFPath][Offset].ErrorOrNot ;
+	}
+	return _FALSE;
+}	/* PHY_RFShadowCompare */
+
+
+extern	VOID
+PHY_RFShadowRecorver(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset)
+{
+	// Check if the address is error
+	if (RF_Shadow[eRFPath][Offset].ErrorOrNot == _TRUE)
+	{
+		// Check if we need to recorver the register.
+		if (RF_Shadow[eRFPath][Offset].Recorver == _TRUE)
+		{
+			PHY_SetRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask, 
+							RF_Shadow[eRFPath][Offset].Value);
+			//RT_TRACE(COMP_INIT, DBG_LOUD, 
+			//("PHY_RFShadowRecorver RF-%d Addr%02lx=%05lx", 
+			//eRFPath, Offset, RF_Shadow[eRFPath][Offset].Value));
+		}
+	}
+	
+}	/* PHY_RFShadowRecorver */
+
+
+extern	VOID
+PHY_RFShadowCompareAll(
+	IN	PADAPTER			Adapter)
+{
+	u32		eRFPath;
+	u32		Offset;
+
+	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
+	{
+		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
+		{
+			PHY_RFShadowCompare(Adapter, (RF90_RADIO_PATH_E)eRFPath, Offset);
+		}
+	}
+	
+}	/* PHY_RFShadowCompareAll */
+
+
+extern	VOID
+PHY_RFShadowRecorverAll(
+	IN	PADAPTER			Adapter)
+{
+	u32		eRFPath;
+	u32		Offset;
+
+	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
+	{
+		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
+		{
+			PHY_RFShadowRecorver(Adapter, (RF90_RADIO_PATH_E)eRFPath, Offset);
+		}
+	}
+	
+}	/* PHY_RFShadowRecorverAll */
+
+
+extern	VOID
+PHY_RFShadowCompareFlagSet(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u8				Type)
+{
+	// Set True or False!!!
+	RF_Shadow[eRFPath][Offset].Compare = Type;
+		
+}	/* PHY_RFShadowCompareFlagSet */
+
+
+extern	VOID
+PHY_RFShadowRecorverFlagSet(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u8				Type)
+{
+	// Set True or False!!!
+	RF_Shadow[eRFPath][Offset].Recorver= Type;
+		
+}	/* PHY_RFShadowRecorverFlagSet */
+
+
+extern	VOID
+PHY_RFShadowCompareFlagSetAll(
+	IN	PADAPTER			Adapter)
+{
+	u32		eRFPath;
+	u32		Offset;
+
+	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
+	{
+		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
+		{
+			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
+			if (Offset != 0x26 && Offset != 0x27)
+				PHY_RFShadowCompareFlagSet(Adapter, (RF90_RADIO_PATH_E)eRFPath, Offset, _FALSE);
+			else
+				PHY_RFShadowCompareFlagSet(Adapter, (RF90_RADIO_PATH_E)eRFPath, Offset, _TRUE);
+		}
+	}
+		
+}	/* PHY_RFShadowCompareFlagSetAll */
+
+
+extern	VOID
+PHY_RFShadowRecorverFlagSetAll(
+	IN	PADAPTER			Adapter)
+{
+	u32		eRFPath;
+	u32		Offset;
+
+	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
+	{
+		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
+		{
+			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
+			if (Offset != 0x26 && Offset != 0x27)
+				PHY_RFShadowRecorverFlagSet(Adapter, (RF90_RADIO_PATH_E)eRFPath, Offset, _FALSE);
+			else
+				PHY_RFShadowRecorverFlagSet(Adapter, (RF90_RADIO_PATH_E)eRFPath, Offset, _TRUE);
+		}
+	}
+		
+}	/* PHY_RFShadowCompareFlagSetAll */
+
+extern	VOID
+PHY_RFShadowRefresh(
+	IN	PADAPTER			Adapter)
+{
+	u32		eRFPath;
+	u32		Offset;
+
+	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
+	{
+		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
+		{
+			RF_Shadow[eRFPath][Offset].Value = 0;
+			RF_Shadow[eRFPath][Offset].Compare = _FALSE;
+			RF_Shadow[eRFPath][Offset].Recorver  = _FALSE;
+			RF_Shadow[eRFPath][Offset].ErrorOrNot = _FALSE;
+			RF_Shadow[eRFPath][Offset].Driver_Write = _FALSE;
+		}
+	}
+	
+}	/* PHY_RFShadowRead */
+
+/* End of HalRf6052.c */
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,583 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192C_RECV_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+    
+
+static u8 evm_db2percentage(s8 value)
+{
+	//
+	// -33dB~0dB to 0%~99%
+	//
+	s8 ret_val;
+
+	ret_val = value;
+	//ret_val /= 2;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("EVMdbToPercentage92S Value=%d / %x \n", ret_val, ret_val));
+
+	if(ret_val >= 0)
+		ret_val = 0;
+	if(ret_val <= -33)
+		ret_val = -33;
+
+	ret_val = 0 - ret_val;
+	ret_val*=3;
+
+	if(ret_val == 99)
+		ret_val = 100;
+
+	return(ret_val);
+}
+
+static s32 signal_scale_mapping(s32 cur_sig )
+{
+	s32 ret_sig;
+
+	if(cur_sig >= 51 && cur_sig <= 100)
+	{
+		ret_sig = 100;
+	}
+	else if(cur_sig >= 41 && cur_sig <= 50)
+	{
+		ret_sig = 80 + ((cur_sig - 40)*2);
+	}
+	else if(cur_sig >= 31 && cur_sig <= 40)
+	{
+		ret_sig = 66 + (cur_sig - 30);
+	}
+	else if(cur_sig >= 21 && cur_sig <= 30)
+	{
+		ret_sig = 54 + (cur_sig - 20);
+	}
+	else if(cur_sig >= 10 && cur_sig <= 20)
+	{
+		ret_sig = 42 + (((cur_sig - 10) * 2) / 3);
+	}
+	else if(cur_sig >= 5 && cur_sig <= 9)
+	{
+		ret_sig = 22 + (((cur_sig - 5) * 3) / 2);
+	}
+	else if(cur_sig >= 1 && cur_sig <= 4)
+	{
+		ret_sig = 6 + (((cur_sig - 1) * 3) / 2);
+	}
+	else
+	{
+		ret_sig = cur_sig;
+	}
+
+
+	return ret_sig;
+}
+
+
+static s32  translate2dbm(_adapter *padapter,u8 signal_strength_idx	)
+{
+	s32	signal_power; // in dBm.
+
+
+	// Translate to dBm (x=0.5y-95).
+	signal_power = (s32)((signal_strength_idx + 1) >> 1);
+	signal_power -= 95;
+
+	return signal_power;
+}
+
+typedef struct _Phy_OFDM_Rx_Status_Report_8192cd
+{
+	unsigned char	trsw_gain_X[4];
+	unsigned char	pwdb_all;
+	unsigned char	cfosho_X[4];
+	unsigned char	cfotail_X[4];
+	unsigned char	rxevm_X[2];
+	unsigned char	rxsnr_X[4];
+	unsigned char	pdsnr_X[2];
+	unsigned char	csi_current_X[2];
+	unsigned char	csi_target_X[2];
+	unsigned char	sigevm;
+	unsigned char	max_ex_pwr;
+//#ifdef RTL8192SE
+#ifdef	_LITTLE_ENDIAN_
+	unsigned char ex_intf_flg:1;
+	unsigned char sgi_en:1;
+	unsigned char rxsc:2;
+	unsigned char rsvd:4;
+#else	// _BIG_ENDIAN_
+	unsigned char rsvd:4;
+	unsigned char rxsc:2;
+	unsigned char sgi_en:1;
+	unsigned char ex_intf_flg:1;
+#endif
+//#else	// RTL8190, RTL8192E
+//	unsigned char	sgi_en;
+//	unsigned char	rxsc_sgien_exflg;
+//#endif
+} PHY_STS_OFDM_8192CD_T;
+
+void rtl8192c_query_rx_phy_status(union recv_frame *prframe, struct recv_stat *prxstat)
+{
+	struct phy_cck_rx_status *pcck_buf;
+	u8	i, max_spatial_stream, evm;
+	s8	rx_pwr[4], rx_pwr_all;
+	u8	pwdb_all;
+	u32	rssi,total_rssi=0;
+	u8 	bcck_rate=0, rf_rx_num = 0, cck_highpwr = 0;
+	_adapter				*padapter = prframe->u.hdr.adapter;
+	struct rx_pkt_attrib	*pattrib = &prframe->u.hdr.attrib;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
+	struct eeprom_priv	*peeprompriv = &(padapter->eeprompriv);
+	struct phy_stat		*pphy_stat = (struct phy_stat *)(prxstat+1);
+	u8	*pphy_head=(u8 *)(prxstat+1);
+	u8 tmp_rxsnr;
+	s8 rx_snrX;
+
+	// Record it for next packet processing
+	bcck_rate=(pattrib->mcs_rate<=3? 1:0);
+
+	if(bcck_rate) //CCK
+	{
+		u8 report;
+
+		// CCK Driver info Structure is not the same as OFDM packet.
+		pcck_buf = (struct phy_cck_rx_status *)pphy_stat;
+		//Adapter->RxStats.NumQryPhyStatusCCK++;
+
+		//
+		// (1)Hardware does not provide RSSI for CCK
+		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
+		//
+
+		//if(pHalData->eRFPowerState == eRfOn)
+		//	cck_highpwr = (u1Byte)pHalData->bCckHighPower;
+		//else
+		//	cck_highpwr = FALSE;
+
+		cck_highpwr = pHalData->bCckHighPower;
+
+		if(!cck_highpwr)
+		{
+			report = pcck_buf->cck_agc_rpt&0xc0;
+			report = report>>6;
+			switch(report)
+			{
+				// 03312009 modified by cosa
+				// Modify the RF RNA gain value to -40, -20, -2, 14 by Jenyu's suggestion
+				// Note: different RF with the different RNA gain.
+				case 0x3:
+					rx_pwr_all = (-46) - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x2:
+					rx_pwr_all = (-26) - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x1:
+					rx_pwr_all = (-12) - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x0:
+					rx_pwr_all = (16) - (pcck_buf->cck_agc_rpt & 0x3e);
+					break;
+			}
+		}
+		else
+		{
+			report =((u8)(le32_to_cpu( pphy_stat->phydw1) >>8)) & 0x60;
+			report = report>>5;
+			switch(report)
+			{
+				case 0x3:
+					rx_pwr_all = (-46) - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+				case 0x2:
+					rx_pwr_all = (-26)- ((pcck_buf->cck_agc_rpt & 0x1f)<<1);
+					break;
+				case 0x1:
+					rx_pwr_all = (-12) - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+				case 0x0:
+					rx_pwr_all = (16) - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+			}
+		}
+
+		pwdb_all= query_rx_pwr_percentage(rx_pwr_all);
+		//if(pHalData->CustomerID == RT_CID_819x_Lenovo)
+		{
+			// CCK gain is smaller than OFDM/MCS gain,
+			// so we add gain diff by experiences, the val is 6
+			pwdb_all+=6;
+			if(pwdb_all > 100)
+				pwdb_all = 100;
+			// modify the offset to make the same gain index with OFDM.
+			if(pwdb_all > 34 && pwdb_all <= 42)
+				pwdb_all -= 2;
+			else if(pwdb_all > 26 && pwdb_all <= 34)
+				pwdb_all -= 6;
+			else if(pwdb_all > 14 && pwdb_all <= 26)
+				pwdb_all -= 8;
+			else if(pwdb_all > 4 && pwdb_all <= 14)
+				pwdb_all -= 4;
+		}
+
+		pattrib->RxPWDBAll = pwdb_all;	//for DIG/rate adaptive
+		pattrib->RecvSignalPower = rx_pwr_all;	//dBM
+		//
+		// (3) Get Signal Quality (EVM)
+		//
+		//if(bPacketMatchBSSID)
+		{
+			u8	sq;
+
+			if(pHalData->CustomerID == RT_CID_819x_Lenovo)
+			{
+				// mapping to 5 bars for vista signal strength
+				// signal quality in driver will be displayed to signal strength
+				// in vista.
+				if(pwdb_all >= 50)
+					sq = 100;
+				else if(pwdb_all >= 35 && pwdb_all < 50)
+					sq = 80;
+				else if(pwdb_all >= 22 && pwdb_all < 35)
+					sq = 60;
+				else if(pwdb_all >= 18 && pwdb_all < 22)
+					sq = 40;
+				else
+					sq = 20;
+			}
+			else
+			{
+				if(pwdb_all> 40)
+				{
+					sq = 100;
+				}
+				else
+				{
+					sq = pcck_buf->sq_rpt;
+
+					if(pcck_buf->sq_rpt > 64)
+						sq = 0;
+					else if (pcck_buf->sq_rpt < 20)
+						sq= 100;
+					else
+						sq = ((64-sq) * 100) / 44;
+
+				}
+			}
+
+			pattrib->signal_qual=sq;
+			pattrib->rx_mimo_signal_qual[0]=sq;
+			pattrib->rx_mimo_signal_qual[1]=(-1);
+		}
+
+	}
+	else //OFDM/HT
+	{
+		PHY_STS_OFDM_8192CD_T	*pOfdm_buf = (PHY_STS_OFDM_8192CD_T *)pphy_head;;
+		//
+		// (1)Get RSSI per-path
+		//
+		for(i=0; i<pHalData->NumTotalRFPath; i++)
+		{
+			rf_rx_num++;
+			rx_pwr[i] = ((pphy_head[PHY_STAT_GAIN_TRSW_SHT+i]&0x3F)*2) - 110;
+
+
+			//if (priv->pshare->rf_ft_var.rssi_dump) 
+			{
+				tmp_rxsnr =	pOfdm_buf->rxsnr_X[i];
+				rx_snrX = (s8)(tmp_rxsnr);
+				rx_snrX >>= 1;
+				pattrib->RxSNRdB[i] = (int)rx_snrX;
+			}
+			
+
+
+			/* Translate DBM to percentage. */
+			rssi=query_rx_pwr_percentage(rx_pwr[i]);
+			total_rssi += rssi;
+
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RF-%d RXPWR=%x RSSI=%d\n", i, rx_pwr[i], rssi));
+
+			//Get Rx snr value in DB
+			//Adapter->RxStats.RxSNRdB[i] = (s4Byte)(pDrvInfo->rxsnr[i]/2);
+
+
+			/* Record Signal Strength for next packet */
+			//if(bPacketMatchBSSID)
+			{
+				//pRfd->Status.RxMIMOSignalStrength[i] =(u1Byte) RSSI;
+
+				//The following is for lenovo signal strength in vista
+				if(pHalData->CustomerID == RT_CID_819x_Lenovo)
+				{
+					u8	sq;
+
+					if(i == 0)
+					{
+
+						// mapping to 5 bars for vista signal strength
+						// signal quality in driver will be displayed to signal strength
+						// in vista.
+						if(rssi >= 50)
+							sq = 100;
+						else if(rssi >= 35 && rssi < 50)
+							sq  = 80;
+						else if(rssi >= 22 && rssi < 35)
+							sq  = 60;
+						else if(rssi >= 18 && rssi < 22)
+							sq  = 40;
+						else
+							sq  = 20;
+						//DbgPrint("ofdm/mcs RSSI=%d\n", RSSI);
+						//pRfd->Status.SignalQuality = SQ;
+						
+						//DbgPrint("ofdm/mcs SQ = %d\n", pRfd->Status.SignalQuality);
+					}
+				}
+			}
+
+		}
+
+
+		//
+		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive),average
+		//
+		rx_pwr_all = (((pphy_head[PHY_STAT_PWDB_ALL_SHT]) >> 1 )& 0x7f) -110;//for OFDM Average RSSI
+		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
+
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("PWDB_ALL=%d\n",	pwdb_all));
+
+		pattrib->RxPWDBAll = pwdb_all;	//for DIG/rate adaptive
+		pattrib->RecvSignalPower = rx_pwr_all;//dBM
+		
+		//
+		// (3)EVM of HT rate
+		//
+		if(pHalData->CustomerID != RT_CID_819x_Lenovo)
+		{
+			if(pattrib->rxht &&  pattrib->mcs_rate >=20 && pattrib->mcs_rate<=27)
+				max_spatial_stream = 2; //both spatial stream make sense
+			else
+				max_spatial_stream = 1; //only spatial stream 1 makes sense
+
+			for(i=0; i<max_spatial_stream; i++)
+			{
+				// Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment
+				// fill most significant bit to "zero" when doing shifting operation which may change a negative
+				// value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.
+				evm = evm_db2percentage( (pphy_head[PHY_STAT_RXEVM_SHT+i] /*/ 2*/));//dbm
+
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",
+					pattrib->mcs_rate, pphy_head[PHY_STAT_RXEVM_SHT+i], "%",evm));
+
+				//if(bPacketMatchBSSID)
+				{
+					if(i==0) // Fill value in RFD, Get the first spatial stream only
+					{
+						pattrib->signal_qual = (u8)(evm & 0xff);
+					}
+					pattrib->rx_mimo_signal_qual[i] = (u8)(evm & 0xff);
+				}
+			}
+
+		}
+
+		//
+		// 4. Record rx statistics for debug
+		//
+
+	}
+
+
+	//UI BSS List signal strength(in percentage), make it good looking, from 0~100.
+	//It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
+
+	if(bcck_rate)
+	{
+		pattrib->signal_strength=(u8)signal_scale_mapping(pwdb_all);
+	}
+	else
+	{
+		if (rf_rx_num != 0)
+		{
+			pattrib->signal_strength= (u8)(signal_scale_mapping(total_rssi/=rf_rx_num));
+		}
+	}
+	//printk("%s,rx_pwr_all(%d),RxPWDBAll(%d)\n",__FUNCTION__,rx_pwr_all,pattrib->RxPWDBAll);
+
+}
+
+
+static void process_rssi(_adapter *padapter,union recv_frame *prframe)
+{
+	u32	last_rssi, tmp_val;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+
+	padapter->recvpriv.RxSNRdB[0] =  pattrib->RxSNRdB[0];
+	padapter->recvpriv.RxSNRdB[1] =  pattrib->RxSNRdB[1];
+
+	//printk("process_rssi=> pattrib->rssil(%d) signal_strength(%d)\n ",pattrib->RecvSignalPower,pattrib->signal_strength);
+	//if(pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
+	{
+		//Adapter->RxStats.RssiCalculateCnt++;	//For antenna Test
+		if(padapter->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
+		{
+			padapter->recvpriv.signal_strength_data.total_num = PHY_RSSI_SLID_WIN_MAX;
+			last_rssi = padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index];
+			padapter->recvpriv.signal_strength_data.total_val -= last_rssi;
+		}
+		padapter->recvpriv.signal_strength_data.total_val  +=pattrib->signal_strength;
+
+		padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index++] = pattrib->signal_strength;
+		if(padapter->recvpriv.signal_strength_data.index >= PHY_RSSI_SLID_WIN_MAX)
+			padapter->recvpriv.signal_strength_data.index = 0;
+
+
+		tmp_val = padapter->recvpriv.signal_strength_data.total_val/padapter->recvpriv.signal_strength_data.total_num;
+		padapter->recvpriv.signal_strength= tmp_val;
+		padapter->recvpriv.rssi=(s8)translate2dbm( padapter,(u8)tmp_val);		
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
+	}
+
+}// Process_UI_RSSI_8192C
+
+
+static void process_PWDB(_adapter *padapter, union recv_frame *prframe)
+{
+	int	UndecoratedSmoothedPWDB;
+	struct dm_priv		*pdmpriv = &padapter->dmpriv;
+	struct rx_pkt_attrib	*pattrib= &prframe->u.hdr.attrib;
+	struct sta_info		*psta = prframe->u.hdr.psta;
+
+	if(psta)
+	{
+		//UndecoratedSmoothedPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;//todo:
+		UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
+	}
+	else
+	{
+		UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
+	}
+	
+	{
+		if(UndecoratedSmoothedPWDB < 0) // initialize
+		{
+			UndecoratedSmoothedPWDB = pattrib->RxPWDBAll;
+		}
+
+		if(pattrib->RxPWDBAll > (u32)UndecoratedSmoothedPWDB)
+		{
+			UndecoratedSmoothedPWDB =
+					( ((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
+					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
+
+			UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB + 1;
+		}
+		else
+		{
+			UndecoratedSmoothedPWDB =
+					( ((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
+					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
+		}
+
+		if(psta)
+		{
+			//pEntry->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;//todo:
+			pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
+		}
+		else
+		{
+			pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
+		}
+
+		//UpdateRxSignalStatistics8192C(padapter, prframe);
+	}
+}
+
+
+static void process_link_qual(_adapter *padapter,union recv_frame *prframe)
+{
+	u32	last_evm=0, tmpVal;
+ 	struct rx_pkt_attrib *pattrib;
+
+	if(prframe == NULL || padapter==NULL){
+		return;
+	}
+	
+	pattrib = &prframe->u.hdr.attrib;
+
+	//printk("process_link_qual=> pattrib->signal_qual(%d)\n ",pattrib->signal_qual);
+	if(pattrib->signal_qual != 0)
+	{
+			//
+			// 1. Record the general EVM to the sliding window.
+			//
+			if(padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
+			{
+				padapter->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
+				last_evm = padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index];
+				padapter->recvpriv.signal_qual_data.total_val -= last_evm;
+			}
+			padapter->recvpriv.signal_qual_data.total_val += pattrib->signal_qual;
+
+			padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = pattrib->signal_qual;
+			if(padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
+				padapter->recvpriv.signal_qual_data.index = 0;
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Total SQ=%d  pattrib->signal_qual= %d\n", padapter->recvpriv.signal_qual_data.total_val, pattrib->signal_qual));
+
+			// <1> Showed on UI for user, in percentage.
+			tmpVal = padapter->recvpriv.signal_qual_data.total_val/padapter->recvpriv.signal_qual_data.total_num;
+			padapter->recvpriv.signal_qual=(u8)tmpVal;
+
+	}
+	else
+	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" pattrib->signal_qual =%d\n", pattrib->signal_qual));
+	}
+
+}// Process_UiLinkQuality8192S
+
+
+//void rtl8192c_process_phy_info(_adapter *padapter, union recv_frame *prframe)
+void rtl8192c_process_phy_info(_adapter *padapter, void *prframe)
+{
+	union recv_frame *precvframe = (union recv_frame *)prframe;
+	
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	if(GET_HAL_DATA(padapter)->RSSI_test == _TRUE)
+		return;
+#endif
+	//
+	// Check RSSI
+	//
+	process_rssi(padapter, precvframe);
+	//
+	// Check PWDB.
+	//
+	process_PWDB(padapter, precvframe); 
+	//
+	// Check EVM
+	//
+	process_link_qual(padapter,  precvframe);	
+
+}
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,8686 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*Created on  2010/ 5/25,  2:21*/
+
+#include <basic_types.h>
+#include "Hal8192CUHWImg.h"
+
+
+#if 1
+// =================== TSMC FW V68.1 2011-02-24 =======================
+u8 Rtl8192CUFwTSMCImgArray[TSMCImgArrayLength] = {
+0xc1,0x88,0x02,0x00,0x44,0x00,0x01,0x00,0x02,0x23,0x15,0x21,0xc0,0x3f,0x00,0x00,
+0x92,0x52,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x02,0x74,0xa5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x59,0x7b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x44,0x6c,0x00,0x00,0x00,0x00,0x00,0x02,0x66,0x96,0x00,0x00,
+0x05,0x04,0x03,0x02,0x00,0x03,0x06,0x05,0x04,0x03,0x00,0x04,0x06,0x05,0x04,0x02,
+0x00,0x04,0x08,0x07,0x06,0x04,0x00,0x06,0x0a,0x09,0x08,0x06,0x00,0x08,0x0a,0x09,
+0x08,0x04,0x00,0x08,0x0a,0x09,0x08,0x02,0x00,0x08,0x0a,0x09,0x08,0x00,0x00,0x08,
+0x12,0x11,0x10,0x08,0x00,0x10,0x1a,0x19,0x18,0x10,0x00,0x18,0x22,0x21,0x20,0x18,
+0x00,0x20,0x22,0x21,0x20,0x10,0x00,0x20,0x22,0x21,0x20,0x08,0x00,0x20,0x22,0x21,
+0x1c,0x08,0x00,0x20,0x22,0x21,0x14,0x08,0x00,0x20,0x22,0x20,0x18,0x08,0x00,0x20,
+0x31,0x30,0x20,0x10,0x00,0x30,0x31,0x30,0x18,0x00,0x00,0x30,0x31,0x2f,0x10,0x10,
+0x00,0x30,0x31,0x2c,0x10,0x10,0x00,0x30,0x31,0x28,0x10,0x00,0x00,0x30,0x31,0x20,
+0x10,0x00,0x00,0x30,0x31,0x10,0x10,0x00,0x00,0x30,0x04,0x04,0x04,0x05,0x04,0x04,
+0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,
+0x05,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x07,0x0a,0x0b,
+0x0d,0x10,0x04,0x05,0x05,0x06,0x06,0x09,0x0c,0x11,0x08,0x08,0x09,0x09,0x0a,0x0c,
+0x10,0x11,0x04,0x04,0x04,0x05,0x04,0x04,0x05,0x07,0x07,0x07,0x08,0x0a,0x04,0x04,
+0x04,0x04,0x06,0x0a,0x0b,0x0d,0x05,0x05,0x07,0x07,0x08,0x0b,0x0d,0x0f,0x04,0x04,
+0x04,0x05,0x07,0x07,0x09,0x09,0x0c,0x0e,0x10,0x12,0x04,0x04,0x05,0x05,0x06,0x0a,
+0x11,0x13,0x09,0x09,0x09,0x09,0x0c,0x0e,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x24,0x26,0x2a,0x18,0x1a,0x1d,0x1f,0x21,0x27,0x29,0x2a,0x00,0x00,
+0x00,0x1f,0x23,0x28,0x2a,0x2c,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x18,
+0x00,0x24,0x00,0x30,0x00,0x48,0x00,0x60,0x00,0x90,0x00,0xc0,0x00,0xd8,0x00,0x50,
+0x00,0x78,0x00,0xa0,0x00,0xc8,0x01,0x40,0x01,0x90,0x01,0xe0,0x02,0x30,0x01,0x2c,
+0x01,0x40,0x01,0xe0,0x02,0xd0,0x03,0xe8,0x04,0xb0,0x06,0x40,0x07,0xd0,0x00,0x02,
+0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x0c,0x00,0x12,0x00,0x18,0x00,0x24,0x00,0x30,
+0x00,0x48,0x00,0x60,0x00,0x6c,0x00,0x28,0x00,0x3c,0x00,0x50,0x00,0x64,0x00,0xa0,
+0x00,0xc8,0x00,0xf0,0x01,0x18,0x00,0x64,0x00,0xa0,0x00,0xf0,0x01,0x68,0x01,0xf4,
+0x02,0x58,0x03,0x20,0x03,0xe8,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x04,0x04,
+0x05,0x07,0x04,0x04,0x07,0x0a,0x0a,0x0c,0x0c,0x12,0x05,0x07,0x07,0x08,0x0b,0x12,
+0x24,0x3c,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x01,0x02,
+0x03,0x04,0x05,0x06,0x07,0x08,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x20,0x1e,
+0x1c,0x18,0x10,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xab,0x07,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,
+0x97,0x92,0xf0,0xe0,0x54,0x1f,0xa3,0xf0,0xfa,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xf9,0x90,0x97,0x95,0xf0,0xeb,0x25,
+0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,
+0x96,0xcf,0xf0,0xa3,0xef,0xf0,0xeb,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,0x98,0xcf,0xf0,0xa3,0xef,0xf0,0xea,0x25,
+0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0xea,0xc3,0x99,0x40,0x03,0x02,0x43,0x59,0x90,0x97,0x93,
+0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0xef,0x04,
+0x90,0x97,0x94,0xf0,0x90,0x97,0x95,0xe0,0xff,0x90,0x97,0x94,0xe0,0xfe,0xd3,0x9f,
+0x40,0x03,0x02,0x43,0x9c,0xee,0xc3,0x94,0x10,0x40,0x21,0xee,0x24,0xf0,0xff,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0x90,0x97,0x96,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,0x90,0x97,0x94,0xe0,
+0xff,0xc3,0x94,0x10,0x50,0x4a,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x98,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x2d,0x90,0x97,0x94,0xe0,0xff,0x64,0x13,0x60,0x09,0xef,0x64,0x12,0x60,
+0x04,0xef,0xb4,0x11,0x0d,0x90,0x97,0x96,0xe0,0x30,0xe0,0x06,0x90,0x97,0x94,0x74,
+0x18,0xf0,0x90,0x97,0x94,0xe0,0x90,0x97,0x93,0xf0,0x90,0x97,0x92,0xf0,0x80,0x4c,
+0x90,0x97,0x94,0xe0,0x04,0xf0,0x02,0x42,0xc4,0x90,0x97,0x95,0xe0,0xfa,0x90,0x97,
+0x93,0xe0,0xff,0x6a,0x70,0x7d,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0xe0,0xb4,0x01,0x11,0x90,0x97,0x92,0xe0,0x20,0xe6,0x0a,0xa3,0xe0,0x44,0x40,
+0x90,0x97,0x92,0xf0,0x80,0x06,0x90,0x97,0x92,0xe0,0xff,0x22,0x90,0x97,0x93,0xe0,
+0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,
+0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,
+0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,
+0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,
+0x7f,0x80,0x69,0x90,0x97,0x93,0xe0,0xd3,0x9a,0x40,0x61,0x90,0x97,0x95,0xe0,0xff,
+0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x93,0xef,
+0xf0,0x90,0x97,0x92,0xf0,0xfa,0xa3,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,
+0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,
+0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0xaf,0x02,0x22,0x74,0x01,0x2b,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x92,0xe0,0x44,0x80,0xff,0x74,
+0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,
+0xc0,0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,
+0x03,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x6c,0xf0,0x74,
+0x44,0xa3,0xf0,0x53,0x91,0xef,0x90,0x00,0x51,0xe0,0xff,0x90,0x00,0x55,0xe0,0x5f,
+0xf5,0x3d,0xe5,0x3d,0x30,0xe6,0x18,0x74,0x40,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,
+0xff,0xbf,0x03,0x0b,0x90,0x97,0xa7,0xe0,0x60,0x05,0x7f,0x01,0x12,0x74,0x21,0xe5,
+0x3d,0x30,0xe7,0x15,0x90,0x00,0x55,0x74,0x80,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,
+0xff,0xbf,0x03,0x05,0x7f,0x02,0x12,0x74,0x21,0x90,0x01,0xc4,0x74,0x6c,0xf0,0x74,
+0x44,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,
+0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0xe4,0xf5,
+0x25,0x22,0x22,0x02,0x7f,0xaa,0x02,0x7f,0xb1,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xff,0xc3,0x94,0x20,0x40,0x03,0x02,0x4e,0x3e,0x75,0xf0,0x09,0xef,0xa4,
+0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x4e,0x35,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,0x00,0xec,0x94,0x00,0x50,0x03,0x02,0x4e,0x35,
+0xef,0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf9,0x74,0x90,0x35,0xf0,0xfa,0x7b,0x01,0x8b,
+0x14,0xf5,0x15,0x89,0x16,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,
+0x34,0x91,0xf5,0x83,0xe0,0xfd,0xa3,0xe0,0x90,0x97,0x85,0xcd,0xf0,0xa3,0xed,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0xff,0xa3,0xe0,
+0x90,0x97,0x87,0xcf,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x02,0x12,0x63,0x4d,0xff,0xae,
+0xf0,0x12,0x63,0x22,0x2f,0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8e,0xf0,0xa3,0xef,0xf0,
+0x90,0x00,0x06,0x12,0x63,0x4d,0xff,0xae,0xf0,0x90,0x00,0x04,0x12,0x63,0x4d,0x2f,
+0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8c,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x08,0x12,0x63,
+0x4d,0xff,0x90,0x97,0x8a,0xe5,0xf0,0xf0,0xa3,0xef,0xf0,0x90,0x97,0x79,0xe0,0xfe,
+0x24,0x84,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x3f,0x90,0x97,0x7b,0xf0,
+0xe0,0xfd,0x54,0x1f,0xa3,0xf0,0x75,0xf0,0x09,0xee,0xa4,0x24,0x67,0xf5,0x82,0xe5,
+0xf0,0x34,0x93,0xf5,0x83,0xe0,0x90,0x97,0x90,0xf0,0x90,0x97,0x79,0xe0,0xfb,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xc3,0x94,0x05,0x40,0x03,0x02,0x49,
+0xba,0x90,0x97,0x90,0xe0,0xfe,0x90,0x97,0x7c,0xe0,0x9e,0x40,0x13,0x90,0x97,0x90,
+0xe0,0x90,0x97,0x7c,0xf0,0xed,0x54,0x40,0xfd,0x90,0x97,0x7b,0xf0,0xee,0x4d,0xf0,
+0x90,0x04,0xfd,0xe0,0x64,0x01,0x70,0x28,0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,
+0x93,0xfe,0x74,0x63,0x2b,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,
+0x06,0xef,0x90,0x40,0xda,0x80,0x32,0x90,0x97,0x7c,0xe0,0x90,0x40,0xf6,0x80,0x29,
+0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,0x93,0xfe,0x90,0x97,0x79,0xe0,0x24,0x63,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,0x06,0xef,0x90,0x41,0x12,
+0x80,0x07,0x90,0x97,0x7c,0xe0,0x90,0x41,0x2e,0x93,0x90,0x97,0x89,0xf0,0x90,0x97,
+0x89,0xe0,0x75,0xf0,0x06,0xa4,0x24,0x50,0xf9,0x74,0x40,0x35,0xf0,0x75,0x11,0xff,
+0xf5,0x12,0x89,0x13,0x90,0x97,0x7b,0xe0,0x90,0x41,0xf2,0x93,0xff,0xd3,0x90,0x97,
+0x88,0xe0,0x9f,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x0d,0x90,0x97,0x79,0xe0,0xff,
+0xe4,0xfd,0x12,0x5f,0x56,0x02,0x4d,0xcb,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,
+0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,
+0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x29,0xd9,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,
+0xa9,0x16,0x12,0x63,0x22,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,
+0xaa,0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,
+0x15,0xa9,0x16,0x90,0x00,0x02,0x12,0x63,0x4d,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,
+0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,
+0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,
+0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,
+0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xff,0x7e,
+0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x04,0x12,0x63,0x4d,0xfd,0xac,0xf0,
+0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,
+0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x03,0x12,
+0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x06,0x12,0x63,
+0x4d,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,
+0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,
+0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,
+0x90,0x00,0x04,0x12,0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,
+0x00,0x08,0x12,0x63,0x4d,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,
+0x05,0x12,0x62,0x95,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,
+0x29,0xf2,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,0x90,0x97,0x7d,0x40,0x50,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0xab,
+0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x05,0x12,0x62,0x95,0xff,0x7e,0x00,0x90,0x97,
+0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x29,0xf2,0xab,0x07,0xaa,0x06,0xd0,0x07,0xd0,
+0x06,0xd0,0x05,0xd0,0x04,0xc3,0xef,0x9b,0xff,0xee,0x9a,0xfe,0xed,0x94,0x00,0xfd,
+0xec,0x94,0x00,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x80,0x07,0x12,0x2a,0x8b,0x00,
+0x00,0x00,0x00,0x90,0x97,0x7d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0x90,0x97,0x7b,0xe0,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,
+0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,
+0x40,0x0b,0x90,0x97,0x79,0xe0,0xff,0x12,0x42,0x20,0x02,0x4d,0x99,0x90,0x97,0x7b,
+0xe0,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,
+0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xc3,0x12,0x63,0xd1,0x40,0x03,0x02,0x4d,0x99,0x90,0x97,0x79,
+0xe0,0xff,0x7d,0x01,0x12,0x5f,0x56,0x02,0x4d,0x99,0x90,0x97,0x79,0xe0,0xff,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x64,0x05,0x60,0x03,0x02,0x4b,0xb6,
+0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,
+0x64,0x01,0x70,0x03,0x02,0x4b,0xb6,0x90,0x93,0x62,0xe0,0xff,0xb4,0x03,0x0b,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x19,0x40,0x3d,0x80,0x2e,0xef,0xb4,0x02,0x0b,0x90,0x97,
+0x7c,0xe0,0xc3,0x94,0x11,0x40,0x2e,0x80,0x1f,0x90,0x93,0x62,0xe0,0xff,0xb4,0x01,
+0x0b,0x90,0x97,0x7c,0xe0,0xc3,0x94,0x0a,0x40,0x1b,0x80,0x0c,0xef,0x70,0x11,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x03,0x40,0x0d,0x90,0x95,0x83,0x74,0x01,0xf0,0x80,0x05,
+0xe4,0x90,0x95,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0x83,0xf5,0x82,0xe4,0x34,
+0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe0,0xff,0xc3,0x94,0x30,0x50,0x03,0x02,0x4b,0x44,0x90,0x95,0x83,0xe0,
+0x64,0x01,0x60,0x03,0x02,0x4b,0x44,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,0xe4,
+0x34,0x95,0xf5,0x83,0xe0,0x64,0x0a,0x60,0x56,0x90,0x97,0x79,0xe0,0xfe,0xef,0x24,
+0x05,0xfd,0xe4,0x33,0xfc,0x74,0x21,0x2e,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,
+0xff,0xd3,0x9d,0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x33,0xef,0x24,0x05,0xfd,
+0xe4,0x33,0xfc,0x74,0x63,0x2e,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xd3,0x9d,
+0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x16,0x90,0x97,0x79,0xe0,0x24,0xc4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xff,0x90,0x97,0x7c,0xe0,0x6f,0x60,0x56,0x90,
+0x97,0x79,0xe0,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xff,0xd3,0x94,
+0x42,0x40,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x11,0xef,0xd3,0x94,0x39,0x90,
+0x97,0x91,0x40,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0x90,0x97,0x79,0xe0,
+0xff,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xfe,0x74,0x21,0x2f,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,
+0xe4,0x34,0x95,0x80,0x2f,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,
+0x04,0xf0,0x80,0x14,0xe4,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0x24,0xa4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x7c,0xe0,0xff,0x90,0x97,0x79,
+0xe0,0xfe,0x24,0xc4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x91,
+0xe0,0xff,0x74,0x83,0x2e,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,
+0xe0,0x1e,0xef,0xc4,0x54,0xf0,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,
+0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x02,0x4d,0x7c,
+0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,
+0xe0,0x54,0xf0,0x02,0x4d,0x7c,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x96,0xf5,0x83,0xe0,0x64,0x06,0x60,0x03,0x02,0x4d,0x99,0x75,0xf0,0x09,0xef,
+0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x70,0x03,
+0x02,0x4d,0x99,0x90,0x97,0x7d,0x12,0x2a,0x8b,0x00,0x00,0x00,0x00,0x90,0x42,0x13,
+0xe4,0x93,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x29,0xf2,
+0xe4,0xfc,0xfd,0x90,0x97,0x81,0x12,0x2a,0x7f,0x90,0x97,0x79,0xe0,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0xe4,0x90,0x97,0x7a,0xf0,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x97,0x7a,0xe0,
+0xff,0x75,0xf0,0x02,0xa4,0xf5,0x82,0x85,0xf0,0x83,0x12,0x63,0x4d,0xfd,0xac,0xf0,
+0xef,0x90,0x42,0x0e,0x93,0xff,0x7e,0x00,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x81,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,0x50,0x0e,0x90,0x97,0x7a,0xe0,0x04,0xf0,
+0xe0,0x64,0x05,0x60,0x03,0x02,0x4c,0x20,0x90,0x97,0x7a,0xe0,0xc3,0x13,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xb4,0x01,0x0d,0x90,0x97,0x7a,0xe0,0x70,0x5d,0x90,0x97,0x91,
+0x04,0xf0,0x80,0x5b,0xef,0xb4,0x03,0x1d,0x90,0x97,0x7a,0xe0,0xff,0x70,0x08,0x90,
+0x97,0x91,0x74,0x03,0xf0,0x80,0x48,0xef,0xb4,0x01,0x08,0x90,0x97,0x91,0x74,0x01,
+0xf0,0x80,0x3c,0x80,0x35,0x90,0x97,0x91,0xe0,0x64,0x05,0x70,0x32,0x90,0x97,0x7a,
+0xe0,0xff,0x70,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x0f,0xef,0x90,0x97,0x91,
+0xb4,0x01,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0xd3,0x90,0x97,0x88,0xe0,
+0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,0x97,0x91,0xf0,0xd3,
+0x90,0x97,0x88,0xe0,0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,
+0x97,0x91,0xf0,0x90,0x97,0x91,0xe0,0xff,0x90,0x97,0x79,0xe0,0xfe,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,0xe0,0x1d,0xef,0xc4,0x54,0xf0,
+0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x80,0x13,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0xf0,0xf0,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x90,0x97,0x91,
+0xe0,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xd3,0x94,0x05,0x50,0x0f,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x04,0xf0,0x80,0x0f,0x90,0x97,0x79,0xe0,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xab,0x14,0xaa,0x15,0xa9,
+0x16,0xe4,0xf5,0xf0,0x12,0x63,0x85,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x02,
+0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,0x00,0x04,0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,
+0x00,0x06,0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,0x00,0x08,0xe4,0xf5,0xf0,0x12,0x63,
+0xa4,0x90,0x97,0x79,0xe0,0xff,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x02,0x45,0x0e,0x22,0xef,
+0x70,0x03,0x02,0x50,0xa7,0x90,0x97,0x6d,0xe0,0x60,0x03,0x02,0x54,0xe9,0x90,0x97,
+0x59,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,
+0x2a,0x7f,0x7f,0x8c,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x05,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x44,0x7e,
+0x08,0x12,0x2f,0xd9,0x90,0x97,0x09,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x5c,0x7e,0x08,0x12,0x2f,0xd9,0x90,
+0x97,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x6c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x11,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x70,
+0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x15,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x74,0x7e,0x0e,0x12,0x2f,0xd9,
+0x90,0x97,0x19,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x78,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x1d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,
+0x7c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x21,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x0e,0x12,0x2f,
+0xd9,0x90,0x97,0x25,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x80,0x85,0x12,0x2a,0x7f,0x7f,0x84,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x29,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,
+0x7f,0x88,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x2d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x8c,0x7e,0x0e,0x12,
+0x2f,0xd9,0x90,0x97,0x31,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xd0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x35,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,
+0x7f,0x7f,0xd4,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x39,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xd8,0x7e,0x0e,
+0x12,0x2f,0xd9,0x90,0x97,0x3d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xdc,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,
+0x41,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,
+0x2a,0x7f,0x7f,0xe0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x45,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xec,0x7e,
+0x0e,0x12,0x2f,0xd9,0x90,0x97,0x49,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,0x2f,0xd9,0x90,
+0x97,0x4d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x2f,0xd9,0x90,0x97,0x51,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,
+0x7e,0x09,0x12,0x2f,0xd9,0x90,0x97,0x55,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x08,0x12,0x2f,0xd9,
+0x90,0x97,0x6d,0x74,0x01,0xf0,0x22,0x90,0x97,0x6d,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x54,0xe9,0x7f,0x8c,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x59,0x12,0x2a,0x7f,0x7f,
+0x44,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x05,0x12,0x2a,0x7f,0x7f,0x5c,0x7e,0x08,
+0x12,0x27,0xde,0x90,0x97,0x09,0x12,0x2a,0x7f,0x7f,0x6c,0x7e,0x0e,0x12,0x27,0xde,
+0x90,0x97,0x0d,0x12,0x2a,0x7f,0x7f,0x70,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x11,
+0x12,0x2a,0x7f,0x7f,0x74,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x15,0x12,0x2a,0x7f,
+0x7f,0x78,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x19,0x12,0x2a,0x7f,0x7f,0x7c,0x7e,
+0x0e,0x12,0x27,0xde,0x90,0x97,0x1d,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x0e,0x12,0x27,
+0xde,0x90,0x97,0x21,0x12,0x2a,0x7f,0x7f,0x84,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,
+0x25,0x12,0x2a,0x7f,0x7f,0x88,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x29,0x12,0x2a,
+0x7f,0x7f,0x8c,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x2d,0x12,0x2a,0x7f,0x7f,0xd0,
+0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x31,0x12,0x2a,0x7f,0x7f,0xd4,0x7e,0x0e,0x12,
+0x27,0xde,0x90,0x97,0x35,0x12,0x2a,0x7f,0x7f,0xd8,0x7e,0x0e,0x12,0x27,0xde,0x90,
+0x97,0x39,0x12,0x2a,0x7f,0x7f,0xdc,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x3d,0x12,
+0x2a,0x7f,0x7f,0xe0,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x41,0x12,0x2a,0x7f,0x7f,
+0xec,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x45,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,
+0x12,0x27,0xde,0x90,0x97,0x49,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x27,0xde,
+0x90,0x97,0x4d,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x27,0xde,0x90,0x97,0x51,
+0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x55,0x12,0x2a,0x7f,
+0x7f,0x8c,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0xc0,0xfd,0xec,
+0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x8c,0x7e,0x08,0x12,0x2f,
+0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0x01,0x00,0x00,0x7f,0x44,0x7e,0x08,0x12,
+0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0xdb,0x25,0xa4,0x7f,0x5c,0x7e,0x08,
+0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x6c,0x7e,
+0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x70,
+0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,0xa4,0x7f,
+0x74,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,0xa4,
+0x7f,0x78,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,
+0xa4,0x7f,0x7c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,
+0x25,0xa4,0x7f,0x80,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x63,
+0xdb,0x25,0xa4,0x7f,0x84,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,
+0x04,0x1b,0x25,0xa4,0x7f,0x88,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,
+0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x8c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,
+0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,
+0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd4,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,
+0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd8,0x7e,0x0e,0x12,0x2f,0xd9,0x90,
+0x80,0x85,0x12,0x2a,0x8b,0x00,0x1b,0x25,0xa4,0x7f,0xdc,0x7e,0x0e,0x12,0x2f,0xd9,
+0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0x1b,0x25,0xa4,0x7f,0xe0,0x7e,0x0e,0x12,0x2f,
+0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x24,0xdb,0x25,0xa4,0x7f,0xec,0x7e,0x0e,0x12,
+0x2f,0xd9,0x7f,0x04,0x7e,0x0c,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,
+0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe7,
+0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x44,0x11,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,
+0x7e,0x0c,0x12,0x2f,0xd9,0x7f,0x04,0x7e,0x0d,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,
+0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,
+0xf0,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x01,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,
+0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x2f,0xd9,0x7f,0x0c,0x7e,0x09,0x12,
+0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x11,0xff,0xec,0x90,0x97,0xe7,
+0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x2f,0xd9,0x7f,0x0c,
+0x7e,0x09,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x54,0x0f,0xfd,0xec,0x54,0xf0,
+0xfc,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0x10,0xfd,0xec,0x44,0x01,0xfc,0x90,0x97,0xe7,
+0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x2f,0xd9,0x7f,0x04,
+0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xf0,0xff,0xec,0x90,0x97,0xe7,0x12,
+0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,
+0x01,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,
+0x08,0x12,0x2f,0xd9,0xe4,0x90,0x97,0x6d,0xf0,0x22,0x8f,0x11,0xef,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xaf,0x82,0xf5,0x12,0x8f,0x13,0xe5,0x11,0x75,0xf0,
+0x02,0xa4,0x24,0x81,0xf9,0x74,0x92,0x35,0xf0,0x75,0x14,0x01,0xf5,0x15,0x89,0x16,
+0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xaf,0x82,
+0xf5,0x17,0x8f,0x18,0xe5,0x11,0x75,0xf0,0x09,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,
+0xf0,0x75,0x19,0x01,0xf5,0x1a,0x89,0x1b,0x74,0xc1,0x25,0x11,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0xe0,0x12,0x63,0xee,0x55,0x6c,0x00,0x55,0x81,0x01,0x55,0x96,0x02,
+0x55,0xab,0x03,0x55,0xd5,0x04,0x55,0xea,0x05,0x55,0xff,0x06,0x56,0x26,0x0c,0x56,
+0x54,0x0d,0x56,0x81,0x0e,0x56,0xae,0x0f,0x00,0x00,0x56,0xe2,0xe5,0x11,0x25,0xe0,
+0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x15,0x80,
+0x3c,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,
+0xf0,0xa3,0x74,0x10,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x05,0x80,0x12,0xe5,0x11,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0xe4,0xf0,0xe5,0x11,
+0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,
+0x8f,0xf0,0x02,0x56,0xe2,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf5,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf0,0x80,0x12,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xa3,0x74,
+0x0d,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0x02,0x56,0xe2,0x90,0x04,0x47,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,
+0x12,0x62,0xc2,0x90,0x04,0x46,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,
+0x12,0x62,0xd4,0x90,0x04,0x45,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,
+0x44,0x02,0x56,0xd9,0x90,0x04,0x4b,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,
+0xc2,0x90,0x04,0x4a,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,
+0xd4,0x90,0x04,0x49,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x48,0x80,
+0x58,0x90,0x04,0x4f,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0xc2,0x90,0x04,
+0x4e,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xd4,0x90,0x04,
+0x4d,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x4c,0x80,0x2b,0x90,0x04,
+0x53,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0xc2,0x90,0x04,0x52,0xe0,0xab,
+0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xd4,0x90,0x04,0x51,0xe0,0x85,
+0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x50,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,
+0xa3,0xf0,0xab,0x14,0xaa,0x15,0xa9,0x16,0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x29,
+0xd9,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,0x12,0x29,0xd9,0x5f,0xd0,0x01,0xd0,0x02,
+0xd0,0x03,0x12,0x62,0xc2,0xab,0x14,0xe5,0x16,0x24,0x01,0xf9,0xe4,0x35,0x15,0xfa,
+0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x29,0xd9,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,
+0x90,0x00,0x01,0x12,0x62,0x95,0x5f,0xd0,0x01,0xd0,0x02,0xd0,0x03,0x12,0x62,0xc2,
+0x85,0x13,0x82,0x85,0x12,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,
+0x17,0x83,0xe0,0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0x85,0x13,0x82,0x85,0x12,
+0x83,0xa3,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,0x17,0x83,0xa3,0xe0,
+0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x4c,0x90,0x97,0x90,0x74,
+0x0b,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x50,0x03,0x02,0x58,0x28,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,
+0xa3,0xe0,0x5f,0x4e,0x60,0x0a,0x90,0x97,0x90,0xe0,0x24,0x10,0xa3,0xf0,0x80,0x68,
+0x90,0x97,0x90,0xe0,0x14,0xf0,0x80,0xba,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0x90,0x97,0x90,0x74,
+0x0f,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x40,0x3c,0x74,0x01,0x7e,0x00,
+0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,
+0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x08,0x90,0x97,0x90,0xe0,0xa3,0xf0,0x80,0x0d,0x90,0x97,0x90,0xe0,0x14,
+0xf0,0x80,0xbf,0xe4,0x90,0x97,0x91,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0xe4,0x90,0x97,0x90,
+0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x10,0x40,0x03,0x02,0x58,0xe2,0x74,0x01,
+0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,
+0xe0,0x5f,0x4e,0x60,0x06,0x90,0x97,0x90,0xe0,0x80,0x63,0x90,0x97,0x90,0xe0,0x04,
+0xf0,0x80,0xbe,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x46,0xe4,0x90,0x97,0x90,0xf0,0x90,0x97,0x90,0xe0,
+0xff,0xc3,0x94,0x0c,0x50,0x3c,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,
+0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x08,0x90,0x97,0x90,
+0xe0,0x24,0x10,0x80,0x09,0x90,0x97,0x90,0xe0,0x04,0xf0,0x80,0xbf,0xe4,0x90,0x97,
+0x92,0xf0,0x90,0x97,0x91,0xe0,0xff,0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x67,0xf5,
+0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xef,0xf0,0x90,0x97,0x92,0xe0,0xfe,0x75,0xf0,
+0x09,0xe5,0x11,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,
+0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0xd3,0x9f,0x40,0x1f,
+0x90,0x97,0x91,0xe0,0xff,0x74,0xc4,0x25,0x11,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xd3,0x94,0x13,0x40,0x08,0x90,0x93,0x62,0x74,0x03,0xf0,0x80,
+0x21,0xef,0xd3,0x94,0x0b,0x40,0x08,0x90,0x93,0x62,0x74,0x02,0xf0,0x80,0x13,0xef,
+0xd3,0x94,0x03,0x40,0x08,0x90,0x93,0x62,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x93,
+0x62,0xf0,0x90,0x93,0x62,0xe0,0x90,0x04,0xb1,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
+0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x7b,0xf0,0x74,0x59,
+0xa3,0xf0,0x90,0x01,0x34,0xe0,0x55,0x28,0xf5,0x2c,0x90,0x01,0x36,0xe0,0x55,0x2a,
+0xf5,0x2e,0xa3,0xe0,0x55,0x2b,0xf5,0x2f,0xe5,0x2c,0x20,0xe0,0x03,0x02,0x5b,0x29,
+0x90,0x01,0x34,0x74,0x01,0xf0,0x85,0xd1,0x4d,0x85,0xd2,0x4e,0x85,0xd3,0x4f,0x85,
+0xd4,0x50,0x85,0xd5,0x51,0x85,0xd6,0x52,0x85,0xd7,0x53,0x85,0xd9,0x54,0xe5,0x54,
+0x54,0x40,0xc3,0x13,0xff,0xe5,0x53,0x54,0x20,0x6f,0x70,0x03,0x02,0x5a,0xd8,0xe5,
+0x54,0x30,0xe5,0x03,0x02,0x5a,0xd8,0xe5,0x52,0x54,0x1f,0xf5,0x08,0xe5,0x4d,0x54,
+0x3f,0xf5,0x09,0xe5,0x51,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0x23,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xf6,0xe5,0x53,0x54,0x1f,0xff,
+0xe5,0x08,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0x8f,0xf0,
+0x12,0x62,0xf6,0xe5,0x09,0xd3,0x94,0x04,0x40,0x03,0x75,0x09,0x04,0x75,0xf0,0x0a,
+0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0x75,0xf0,0x02,
+0xe5,0x09,0x12,0x63,0xe2,0xe0,0xfe,0xa3,0xe0,0xff,0xe5,0x53,0x54,0x1f,0x2f,0xff,
+0xe4,0x3e,0xfe,0x75,0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,
+0x90,0xf5,0x83,0x75,0xf0,0x02,0xe5,0x09,0x12,0x63,0xe2,0xee,0xf0,0xa3,0xef,0xf0,
+0xe5,0x54,0x20,0xe6,0x24,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0xa3,
+0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xf6,0xe5,0x4f,0x30,
+0xe7,0x36,0xaf,0x08,0x12,0x75,0xa3,0x80,0x2f,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,
+0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,
+0xf6,0xe5,0x4f,0x30,0xe7,0x12,0xe5,0x4f,0x54,0x7f,0xfd,0xe5,0x53,0x54,0x1f,0xf5,
+0x0d,0xab,0x09,0xaf,0x08,0x12,0x76,0xe9,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,0x80,
+0x48,0x90,0x97,0xcb,0xe0,0x60,0x35,0x90,0x01,0x5b,0xe4,0xf0,0x90,0x01,0x3c,0x74,
+0x04,0xf0,0x90,0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x2d,0x75,0x44,0x14,0xf5,
+0x45,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5b,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x01,0xf0,0x90,0x97,0xc7,0xf0,0x80,0x0d,0x90,0x04,0x1b,0xe0,
+0x54,0x7f,0xff,0xbf,0x7f,0x03,0x12,0x7f,0x8d,0xe5,0x2c,0x30,0xe1,0x27,0x90,0x01,
+0x34,0x74,0x02,0xf0,0x90,0xfd,0x10,0x74,0x7f,0xf0,0x85,0xd1,0x58,0x85,0xd2,0x59,
+0x85,0xd3,0x5a,0x85,0xd4,0x5b,0x85,0xd5,0x5c,0x85,0xd6,0x5d,0x85,0xd7,0x5e,0x85,
+0xd9,0x5f,0x12,0x7d,0xc4,0xe5,0x2c,0x30,0xe3,0x06,0x90,0x01,0x34,0x74,0x08,0xf0,
+0xe5,0x2c,0x30,0xe4,0x09,0x90,0x01,0x34,0x74,0x10,0xf0,0x43,0x57,0x10,0xe5,0x2c,
+0x30,0xe5,0x1d,0x90,0x01,0xcf,0xe0,0x30,0xe5,0x16,0xe0,0x54,0xdf,0xf0,0x90,0x01,
+0x34,0x74,0x20,0xf0,0x90,0x00,0x03,0xe0,0x54,0xfb,0xf0,0x12,0x7f,0x30,0x80,0xfe,
+0xe5,0x2c,0x30,0xe6,0x06,0x90,0x01,0x34,0x74,0x40,0xf0,0xe5,0x2e,0x30,0xe1,0x3c,
+0x90,0x01,0x36,0x74,0x02,0xf0,0x43,0x57,0x40,0x90,0x01,0x02,0xe0,0x54,0x03,0x64,
+0x01,0x70,0x29,0x90,0x01,0x37,0xe0,0x30,0xe0,0x0a,0x74,0x01,0xf0,0x90,0x97,0xd0,
+0xe4,0xf0,0x80,0x18,0x90,0x97,0xd0,0xe0,0x04,0xf0,0xe0,0xc3,0x94,0x0a,0x40,0x0c,
+0xe4,0xf0,0x90,0x04,0x19,0xe0,0x30,0xe0,0x03,0x12,0x7e,0xfd,0xe5,0x2e,0x30,0xe0,
+0x09,0x90,0x01,0x36,0x74,0x01,0xf0,0x12,0x75,0x28,0xe5,0x2e,0x30,0xe2,0x72,0x90,
+0x01,0x36,0x74,0x04,0xf0,0xe5,0x69,0x64,0x01,0x70,0x66,0xe5,0x6a,0x60,0x62,0xe5,
+0x6a,0x64,0x02,0x60,0x06,0xe5,0x6a,0x64,0x05,0x70,0x27,0x90,0x06,0xab,0xe0,0x90,
+0x97,0xbe,0xf0,0x90,0x06,0xaa,0xe0,0x90,0x97,0xc9,0xf0,0x90,0x97,0xbe,0xe0,0x70,
+0x07,0x90,0x97,0xc9,0xe0,0xff,0x80,0x05,0x90,0x97,0xbe,0xe0,0xff,0x90,0x97,0xbe,
+0xef,0xf0,0x90,0x97,0xc0,0xe0,0x60,0x03,0xe0,0x14,0xf0,0x90,0x97,0xbf,0xe4,0xf0,
+0x90,0x01,0x57,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xfd,
+0xf0,0xe0,0x54,0xef,0xf0,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,0x80,0x03,0x12,0x76,
+0x19,0xe5,0x2e,0x30,0xe3,0x31,0x90,0x01,0x36,0x74,0x08,0xf0,0xe5,0x69,0x64,0x01,
+0x70,0x25,0xe5,0x6a,0x60,0x21,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,
+0xf0,0x75,0x44,0x03,0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x35,
+0xab,0x90,0x01,0x57,0x74,0x05,0xf0,0xe5,0x2e,0x30,0xe4,0x2f,0x90,0x01,0x36,0x74,
+0x10,0xf0,0xe5,0x69,0x64,0x01,0x70,0x23,0xe5,0x6a,0x60,0x1f,0x90,0x01,0x57,0xe4,
+0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0xcc,0xe4,0xf0,0x90,0x97,0xcd,0xe0,
+0x54,0xfd,0xf0,0xe0,0x54,0x07,0x70,0x03,0x12,0x7f,0x8d,0xe5,0x2e,0x30,0xe5,0x1f,
+0x90,0x01,0x36,0x74,0x20,0xf0,0xe5,0x69,0xb4,0x01,0x14,0xe5,0x6a,0x60,0x10,0x90,
+0x97,0xcb,0xe0,0x64,0x02,0x60,0x05,0x12,0x7f,0x1f,0x80,0x03,0x12,0x7b,0x06,0xe5,
+0x2e,0x30,0xe6,0x1e,0x90,0x01,0x36,0x74,0x40,0xf0,0xe5,0x69,0xb4,0x01,0x13,0xe5,
+0x6a,0x60,0x0f,0x90,0x97,0xcd,0xe0,0x54,0xfe,0xf0,0xe0,0x54,0x07,0x70,0x03,0x12,
+0x7f,0x8d,0xe5,0x2f,0x30,0xe1,0x09,0x90,0x01,0x37,0x74,0x02,0xf0,0x12,0x7c,0x92,
+0x74,0x7b,0x04,0x90,0x01,0xc4,0xf0,0x74,0x59,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,
+0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,
+0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x90,0x04,0x44,0x74,0x11,0xf0,0xa3,0x74,0xf0,0xf0,
+0xa3,0x74,0x0f,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xff,
+0xc3,0x94,0x10,0x50,0x14,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe4,
+0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x80,0xe2,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xfb,0xc3,0x94,0x20,0x40,0x03,0x02,0x5f,0x55,0xe0,0xff,0x75,0xf0,0x0a,
+0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,
+0xf0,0x0a,0xef,0xa4,0x24,0x02,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,
+0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x04,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x06,0xf5,0x82,0xe5,0xf0,
+0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x08,0xf5,
+0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x74,0xc4,0x2f,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0x74,0x13,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe4,0xf0,0x74,0x83,0x2f,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,
+0xef,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0x23,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0x64,0x2f,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe4,0xf0,0x90,0x41,0xc4,0x93,0xfe,0x74,0x01,0x93,0xff,0x90,0x41,0x8c,
+0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,
+0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,
+0x2a,0x7f,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0x74,0x01,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xf5,0x83,0x74,0x01,0xf0,0x74,0xc1,0x2b,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0x74,0x0c,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,
+0xf5,0x83,0x74,0xff,0xf0,0xa3,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x63,0xf5,0x82,
+0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0xa3,0x74,0x0f,0xf0,0x75,0xf0,0x09,0xeb,
+0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x13,0xf0,0x75,0xf0,
+0x09,0xeb,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0x74,
+0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0x74,0x13,0xf0,0x90,0x97,0x79,0xe0,
+0x04,0xf0,0x02,0x5d,0x7e,0x22,0xa9,0x07,0x74,0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,
+0xf5,0x83,0xe0,0x54,0x7f,0x90,0x97,0x92,0xf0,0xe0,0x54,0x1f,0xff,0x90,0x97,0x95,
+0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xe0,0x90,0x97,0x97,0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,
+0x34,0x93,0xf5,0x83,0xe0,0xfe,0x90,0x97,0x98,0xf0,0xe9,0x25,0xe0,0x24,0x24,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x99,0xcb,0xf0,0xa3,
+0xeb,0xf0,0xe9,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfb,
+0xa3,0xe0,0x90,0x97,0x9b,0xcb,0xf0,0xa3,0xeb,0xf0,0xef,0xd3,0x9e,0x40,0x0c,0x90,
+0x97,0x98,0xe0,0x90,0x97,0x95,0xf0,0x90,0x97,0x92,0xf0,0xed,0x70,0x03,0x02,0x60,
+0xb5,0x90,0x97,0x96,0xed,0xf0,0x90,0x97,0x92,0xe0,0x30,0xe6,0x0e,0x90,0x97,0x95,
+0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x96,0xe0,0x14,0xf0,0x90,0x97,0x96,0xe0,0x70,
+0x03,0x02,0x60,0xb5,0x90,0x97,0x95,0xe0,0xff,0xd3,0x94,0x00,0x50,0x03,0x02,0x60,
+0xb5,0xe4,0x90,0x97,0x94,0xf0,0xef,0x14,0x90,0x97,0x93,0xf0,0x90,0x97,0x97,0xe0,
+0xfd,0x90,0x97,0x93,0xe0,0xff,0xd3,0x9d,0x40,0x6f,0xef,0x94,0x10,0x40,0x21,0xef,
+0x24,0xf0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,
+0xce,0xd8,0xf9,0xff,0x90,0x97,0x9b,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,
+0x90,0x97,0x93,0xe0,0xff,0xc3,0x94,0x10,0x50,0x37,0x74,0x01,0x7e,0x00,0xa8,0x07,
+0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x99,0xe0,0x5e,
+0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x1a,0x90,0x97,0x93,0xe0,0x90,0x97,0x92,0xf0,0x90,
+0x97,0x94,0xe0,0x04,0xf0,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,0x94,0xe0,0x6f,0x60,
+0x08,0x90,0x97,0x93,0xe0,0x14,0xf0,0x80,0x83,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,
+0x94,0xe0,0xc3,0x9f,0x50,0x0f,0x90,0x97,0x93,0xe0,0xb5,0x05,0x08,0x90,0x97,0x97,
+0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x92,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,
+0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,
+0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,
+0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xe9,0x25,0xe0,0x25,0xe0,0x24,0xe1,
+0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0x90,0x97,0x92,0xe0,0xff,0x74,
+0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0x90,0x01,0xcc,0xe0,
+0x54,0x0f,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xfd,0x70,0x03,0x02,0x62,0x94,
+0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,
+0xce,0x33,0xce,0xd8,0xf9,0xff,0xef,0x5d,0x70,0x03,0x02,0x62,0x75,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd0,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,
+0x90,0x97,0x7a,0xf0,0x75,0x63,0x01,0x75,0x64,0x97,0x75,0x65,0x7a,0x75,0x66,0x01,
+0x7b,0x01,0x7a,0x97,0x79,0x7b,0x12,0x77,0xae,0x90,0x97,0x7b,0xe0,0xff,0xc4,0x13,
+0x13,0x13,0x54,0x01,0x90,0x97,0xef,0x30,0xe0,0x70,0xe0,0x75,0xf0,0x02,0xa4,0x24,
+0x88,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x02,0xa4,0x24,0x89,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,
+0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd1,0xf5,0x82,0xe5,
+0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,
+0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7f,
+0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,0x82,0xe5,0xf0,0x34,
+0x01,0xf5,0x83,0xe0,0x90,0x97,0x80,0xf0,0x80,0x42,0xe0,0x75,0xf0,0x04,0xa4,0x24,
+0xd1,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,
+0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,
+0xe0,0x90,0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,
+0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0xef,0x54,0x7f,0xff,
+0x7b,0x01,0x7a,0x97,0x79,0x7c,0x12,0x6e,0xea,0x90,0x97,0x79,0xe0,0xff,0x90,0x97,
+0xef,0xe0,0xfe,0x74,0x01,0xa8,0x06,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0x5f,
+0x90,0x97,0x79,0xf0,0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0x90,0x01,0xcc,0xf0,0x90,0x97,0xef,0xe0,0x04,0xf0,0xe0,0x54,
+0x03,0xf0,0x02,0x61,0x16,0xc2,0xaf,0x74,0x0c,0x04,0x90,0x01,0xc4,0xf0,0x74,0x61,
+0xa3,0xf0,0x90,0x97,0x79,0xe0,0x90,0x01,0xc6,0xf0,0x90,0x97,0xef,0xe0,0x90,0x01,
+0xc7,0xf0,0x80,0xfe,0x22,0xbb,0x01,0x0c,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe0,0x22,0x50,0x06,0xe9,0x25,0x82,0xf8,0xe6,0x22,0xbb,0xfe,0x06,0xe9,
+0x25,0x82,0xf8,0xe2,0x22,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe4,
+0x93,0x22,0xbb,0x01,0x06,0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x02,0xf7,0x22,0xbb,
+0xfe,0x01,0xf3,0x22,0xf8,0xbb,0x01,0x0d,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe8,0xf0,0x22,0x50,0x06,0xe9,0x25,0x82,0xc8,0xf6,0x22,0xbb,0xfe,0x05,
+0xe9,0x25,0x82,0xc8,0xf2,0x22,0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,0xc5,0xf0,0xf8,
+0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,0xf8,0xe0,0xc5,
+0xf0,0x25,0xf0,0xf0,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0xc8,0x38,0xf0,
+0xe8,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,0x50,
+0x06,0x87,0xf0,0x09,0xe7,0x19,0x22,0xbb,0xfe,0x07,0xe3,0xf5,0xf0,0x09,0xe3,0x19,
+0x22,0x89,0x82,0x8a,0x83,0xe4,0x93,0xf5,0xf0,0x74,0x01,0x93,0x22,0xbb,0x01,0x10,
+0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,
+0x50,0x09,0xe9,0x25,0x82,0xf8,0x86,0xf0,0x08,0xe6,0x22,0xbb,0xfe,0x0a,0xe9,0x25,
+0x82,0xf8,0xe2,0xf5,0xf0,0x08,0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,0xe9,0x93,0xf5,
+0xf0,0xa3,0xe9,0x93,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xf0,0xe5,0xf0,0xa3,
+0xf0,0x22,0x50,0x06,0xf7,0x09,0xa7,0xf0,0x19,0x22,0xbb,0xfe,0x06,0xf3,0xe5,0xf0,
+0x09,0xf3,0x19,0x22,0xf8,0xbb,0x01,0x11,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x09,0xe9,0x25,0x82,0xc8,0xf6,
+0x08,0xa6,0xf0,0x22,0xbb,0xfe,0x09,0xe9,0x25,0x82,0xc8,0xf2,0xe5,0xf0,0x08,0xf2,
+0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,0xe8,0x9c,0x45,
+0xf0,0x22,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,0x22,0xd0,0x83,
+0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,0x01,0x93,0x70,0x0d,0xa3,0xa3,0x93,0xf8,
+0x74,0x01,0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x02,0x93,0x68,0x60,0xef,0xa3,
+0xa3,0xa3,0x80,0xdf,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,
+0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x04,0x12,0x62,0x95,
+0xff,0x54,0x1f,0x90,0x97,0x87,0xf0,0x90,0x00,0x03,0x12,0x62,0x95,0x54,0xf0,0xc4,
+0x54,0x0f,0x90,0x97,0x88,0xf0,0xef,0x54,0x20,0xc4,0x13,0x54,0x07,0xa3,0xf0,0x90,
+0x00,0x04,0x12,0x62,0x95,0x54,0x40,0xc4,0x13,0x13,0x54,0x03,0x90,0x97,0x8a,0xf0,
+0x90,0x97,0x87,0xe0,0xff,0x75,0xf0,0x09,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xad,0x82,0x90,0x97,0x8b,0xf0,0xa3,0xed,0xf0,0xef,0x75,0xf0,0x09,0xa4,0x24,
+0x63,0xf9,0x74,0x93,0x35,0xf0,0xfa,0xa3,0x74,0x01,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,
+0xf0,0x90,0x97,0x84,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x03,0x12,0x62,0x95,
+0x54,0x0f,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0xef,0x12,
+0x62,0xc2,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x02,
+0x12,0x62,0x95,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,
+0x00,0x01,0xef,0x12,0x62,0xd4,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0x90,0x97,0x8b,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xf5,0x82,0x8c,0x83,0xef,0xf0,0x12,0x29,0xd9,0x8d,0x82,0x8c,0x83,0xa3,0xf0,0x90,
+0x97,0x88,0xe0,0xfe,0x90,0x97,0x87,0xe0,0xff,0x24,0xc1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0xee,0xf0,0x90,0x97,0x89,0xe0,0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x69,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,0x75,0xf0,0x09,0xef,0xa4,0x24,
+0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x90,0x97,0x8a,0xe0,
+0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xee,0xf0,0x02,0x54,0xea,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x97,0xa9,0xf0,0x90,
+0x00,0x01,0x12,0x62,0x95,0x25,0xe0,0x25,0xe0,0x90,0x97,0xa8,0xf0,0x12,0x29,0xd9,
+0x25,0xe0,0x25,0xe0,0x90,0x97,0xac,0xf0,0x90,0x05,0x60,0xe0,0x90,0x97,0xb7,0xf0,
+0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0xb9,0xf0,
+0x90,0x05,0x63,0xe0,0x90,0x97,0xba,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,
+0xc2,0xaf,0x90,0x97,0xa8,0xe0,0xff,0x12,0x79,0x11,0x90,0x97,0x84,0xe0,0x24,0xff,
+0x92,0xaf,0x90,0x97,0xa9,0xe0,0x70,0x03,0x02,0x66,0x62,0x90,0x97,0xa8,0xe0,0x70,
+0x03,0x02,0x66,0x62,0x90,0x97,0xac,0xe0,0x70,0x03,0x02,0x66,0x62,0xa2,0xaf,0xe4,
+0x33,0x90,0x97,0x84,0xf0,0xc2,0xaf,0x90,0x97,0xbb,0x74,0x01,0xf0,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,0xe0,0x44,0x01,
+0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,
+0x2f,0xd9,0x80,0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x00,0x45,0xe0,0x54,0xef,
+0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,0xf0,
+0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,0xf0,
+0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,
+0xc2,0xaf,0x90,0x01,0x3c,0xe0,0x44,0x20,0xf0,0x7d,0x20,0xe4,0xff,0x12,0x37,0x00,
+0x80,0x2b,0x90,0x97,0xa9,0xe0,0x70,0x2d,0x90,0x97,0xbb,0xf0,0x90,0x00,0x45,0xe0,
+0x54,0xfe,0xf0,0xa3,0xe0,0x54,0xfe,0xf0,0x90,0x05,0x22,0xe4,0xf0,0xa2,0xaf,0x33,
+0x90,0x97,0x84,0xf0,0xc2,0xaf,0x7d,0x20,0xe4,0xff,0x12,0x36,0x92,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,0x82,0xc0,0xd0,
+0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,0xc0,0x05,0xc0,
+0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x96,0xf0,0x74,0x66,0xa3,0xf0,0x53,0x91,0xdf,
+0x90,0x01,0x3c,0xe0,0x55,0x30,0xf5,0x34,0xa3,0xe0,0x55,0x31,0xf5,0x35,0xa3,0xe0,
+0x55,0x32,0xf5,0x36,0xa3,0xe0,0x55,0x33,0xf5,0x37,0xe5,0x34,0x30,0xe1,0x09,0x90,
+0x01,0x3c,0x74,0x02,0xf0,0x12,0x7b,0x44,0xe5,0x34,0x30,0xe2,0x33,0x90,0x01,0x3c,
+0x74,0x04,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe0,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,
+0xe4,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5b,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x01,0xf0,0x80,0x08,0x90,0x97,0xc7,0xe4,0xf0,0x12,0x7f,0x8d,
+0xe5,0x34,0x30,0xe3,0x33,0x90,0x01,0x3c,0x74,0x08,0xf0,0x90,0x06,0x92,0xe0,0x30,
+0xe1,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,
+0x35,0xab,0x90,0x01,0x5f,0x74,0x05,0xf0,0x90,0x06,0x92,0x74,0x02,0xf0,0x80,0x08,
+0x90,0x97,0xc6,0xe4,0xf0,0x12,0x7f,0x8d,0xe5,0x34,0x30,0xe4,0x09,0x90,0x01,0x3c,
+0x74,0x10,0xf0,0x12,0x7a,0x85,0xe5,0x34,0x30,0xe5,0x09,0x90,0x01,0x3c,0x74,0x20,
+0xf0,0x12,0x6e,0x26,0xe5,0x35,0x30,0xe0,0x11,0x90,0x01,0x3d,0x74,0x01,0xf0,0x90,
+0x00,0x83,0xe0,0x90,0x97,0xca,0xf0,0x12,0x7f,0x8d,0x74,0x96,0x04,0x90,0x01,0xc4,
+0xf0,0x74,0x66,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,
+0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,
+0xe4,0x90,0x97,0x76,0xf0,0xa3,0xf0,0x12,0x79,0xb2,0x90,0x00,0x02,0xe0,0x54,0xe0,
+0x90,0x97,0xd6,0x60,0x05,0x74,0x01,0xf0,0x80,0x03,0x74,0x02,0xf0,0x90,0x00,0xf3,
+0xe0,0x30,0xe3,0x08,0x90,0x97,0xd7,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x97,0xd7,
+0xf0,0x90,0x97,0xd7,0xe0,0xb4,0x01,0x13,0x90,0x00,0xf2,0xe0,0x30,0xe7,0x0c,0x90,
+0x97,0xce,0x74,0xfd,0xf0,0xa3,0x74,0x33,0xf0,0x80,0x0a,0x90,0x97,0xce,0x74,0xfd,
+0xf0,0xa3,0x74,0x2f,0xf0,0xe4,0xf5,0x57,0x12,0x5d,0x46,0x12,0x7f,0xa1,0x12,0x79,
+0x63,0x12,0x32,0x3d,0x12,0x44,0xfe,0x12,0x7e,0x27,0x90,0x00,0xf3,0xe0,0x30,0xe2,
+0x0d,0x90,0x05,0x41,0x74,0x10,0xf0,0x90,0x05,0x5a,0xf0,0xa3,0xe4,0xf0,0x90,0x01,
+0x64,0x74,0xa0,0xf0,0x75,0x44,0xff,0xe4,0xf5,0x45,0xfb,0x7d,0x01,0x7f,0x50,0x7e,
+0x01,0x12,0x35,0xab,0x12,0x7e,0xd0,0x12,0x78,0x0e,0x90,0x97,0x78,0xe5,0xd9,0xf0,
+0x12,0x7e,0xe8,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x40,0xf0,0x12,0x7f,0x30,0x75,
+0xe8,0x03,0x43,0xa8,0x85,0xd2,0xaf,0x90,0x01,0xc0,0xe4,0xf0,0xa3,0xf0,0xa3,0xf0,
+0xa3,0xf0,0x90,0x01,0xc6,0xf0,0xa3,0xf0,0x90,0x97,0x76,0xe0,0x64,0x01,0xf0,0x24,
+0xb0,0x90,0x01,0xc4,0xf0,0x74,0x67,0xa3,0xf0,0xe5,0x57,0x30,0xe6,0x17,0xc2,0xaf,
+0x53,0x57,0xbf,0xd2,0xaf,0x12,0x45,0x09,0x90,0x97,0xab,0xe0,0xff,0x60,0x03,0xb4,
+0x01,0x03,0x12,0x68,0xc2,0xe5,0x57,0x30,0xe4,0x0a,0xc2,0xaf,0x53,0x57,0xef,0xd2,
+0xaf,0x12,0x61,0x0c,0x90,0x97,0xab,0xe0,0x70,0x03,0x12,0x6b,0xad,0x12,0x7c,0xf4,
+0x80,0xb6,0x90,0x97,0xa2,0xe0,0xc3,0x94,0x14,0x50,0x06,0xe0,0x04,0xf0,0x02,0x69,
+0x7c,0x90,0x97,0xa2,0xe0,0x64,0x14,0x60,0x03,0x02,0x69,0x7c,0x90,0x97,0xb1,0xe0,
+0x70,0x25,0x90,0x97,0xb4,0xe0,0x70,0x1f,0x90,0x97,0xb2,0xe0,0x70,0x19,0x90,0x97,
+0xb5,0xe0,0x70,0x13,0x90,0x97,0xb3,0xe0,0x70,0x0d,0x90,0x97,0xb6,0xe0,0x70,0x07,
+0x90,0x04,0xfd,0xe0,0x54,0xfe,0xf0,0x90,0x97,0xb1,0xe0,0x90,0x04,0x44,0xf0,0x90,
+0x97,0xb2,0xe0,0x90,0x04,0x45,0xf0,0x90,0x97,0xb3,0xe0,0x90,0x04,0x46,0xf0,0xa3,
+0xe4,0xf0,0x90,0x97,0xb4,0xe0,0x90,0x04,0x48,0xf0,0x90,0x97,0xb5,0xe0,0x90,0x04,
+0x49,0xf0,0x90,0x97,0xb6,0xe0,0x90,0x04,0x4a,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x9d,
+0xe0,0x90,0x07,0x00,0xf0,0x90,0x97,0x9e,0xe0,0x90,0x07,0x01,0xf0,0x90,0x97,0x9f,
+0xe0,0x90,0x07,0x02,0xf0,0x90,0x97,0xa0,0xe0,0x90,0x07,0x03,0xf0,0xe4,0x90,0x97,
+0xa2,0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,
+0xb1,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x05,0x60,0xe0,
+0x90,0x97,0x79,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0x7a,0xf0,0x90,0x05,0x62,0xe0,
+0x90,0x97,0x7b,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xba,0xe0,
+0xff,0x90,0x97,0x7c,0xe0,0xfe,0xd3,0x9f,0x50,0x0b,0x90,0x97,0xba,0xe0,0xc3,0x9e,
+0xd3,0x94,0x01,0x40,0x11,0x90,0x97,0xa8,0xe0,0xb4,0x01,0x02,0x80,0x03,0x90,0x97,
+0xac,0xe0,0xff,0x12,0x79,0x11,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,
+0xee,0xed,0xf0,0x90,0x97,0xed,0xef,0xf0,0xd3,0x94,0x07,0x50,0x65,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,
+0x5f,0xf0,0x12,0x7f,0x30,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x46,0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,
+0x97,0xee,0xe0,0x60,0x16,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x45,0x80,0x70,0x90,0x97,0xed,0xe0,0xff,
+0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x45,
+0x80,0x75,0x90,0x97,0xed,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,
+0xf0,0x12,0x7f,0x30,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,0x97,
+0xee,0xe0,0x60,0x1b,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x42,0xe0,0x4f,0x80,0x1a,0x90,
+0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,
+0x54,0xf0,0xf4,0xff,0x90,0x00,0x42,0xe0,0x5f,0xf0,0x12,0x7f,0x30,0xd0,0xd0,0x92,
+0xaf,0x22,0x7f,0x78,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x5d,0x12,0x2a,0x7f,0x7f,
+0x04,0x7e,0x0c,0x12,0x27,0xde,0x90,0x97,0x61,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,
+0x12,0x27,0xde,0x90,0x97,0x65,0x12,0x2a,0x7f,0x90,0x97,0xd7,0xe0,0x90,0x97,0x5d,
+0xb4,0x01,0x13,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xc7,0xff,
+0xed,0x54,0xc7,0xfd,0x80,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x54,0xc7,0xff,0xec,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x78,0x7e,0x08,0x12,0x2f,
+0xd9,0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0x0f,
+0xff,0xec,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,0x2f,0xd9,0x90,
+0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x02,0xff,0xec,
+0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,0x12,0x2f,0xd9,0x7f,0x70,0x7e,
+0x0e,0x12,0x27,0xde,0x90,0x97,0x69,0x12,0x2a,0x7f,0x90,0x80,0x85,0x12,0x2a,0x8b,
+0x00,0x1b,0x25,0xa0,0x7f,0x70,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x59,0x12,0x2a,
+0x8b,0x00,0x00,0x00,0x00,0xe4,0xfd,0xff,0x12,0x34,0x81,0x90,0x97,0xd7,0xe0,0xb4,
+0x01,0x11,0x90,0x80,0x59,0x12,0x2a,0x8b,0x00,0x00,0x00,0x00,0xe4,0xfd,0x7f,0x01,
+0x12,0x34,0x81,0x90,0x00,0x11,0xe0,0x54,0xf6,0xf0,0x02,0x7f,0x30,0x90,0x97,0xbb,
+0xe0,0x64,0x01,0x60,0x09,0x90,0x97,0xa9,0xe0,0x60,0x03,0x02,0x6c,0x85,0x90,0x97,
+0x9d,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x3b,0x90,0x97,0x9e,0xe0,
+0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x28,0x90,0x97,0x9f,0xe0,0xc3,
+0x94,0xff,0x50,0x0a,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9e,0xf0,0x80,0x15,0x90,0x97,
+0xa0,0xe0,0xc3,0x94,0xff,0x50,0x10,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9f,0xf0,0x90,
+0x97,0x9e,0xf0,0x90,0x97,0x9d,0xf0,0x90,0x00,0x44,0xe0,0x54,0x0c,0x60,0x76,0xe0,
+0x30,0xe2,0x32,0x90,0x97,0xb1,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,
+0x24,0x90,0x97,0xb2,0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,
+0x90,0x97,0xb3,0xe0,0xc3,0x94,0xff,0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb2,
+0xf0,0x90,0x97,0xb1,0xf0,0x90,0x00,0x44,0xe0,0x30,0xe3,0x32,0x90,0x97,0xb4,0xe0,
+0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,0x90,0x97,0xb5,0xe0,0xc3,0x94,
+0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,0x97,0xb6,0xe0,0xc3,0x94,0xff,
+0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb4,0xf0,0x90,0x04,
+0xfd,0xe0,0x44,0x01,0xf0,0x22,0x8b,0x11,0x8a,0x12,0x89,0x13,0x90,0x00,0x02,0x12,
+0x62,0x95,0x90,0x97,0xaa,0xf0,0xe0,0x30,0xe0,0x5c,0x90,0x97,0xa1,0x74,0x01,0xf0,
+0x7f,0x80,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xa3,0x12,0x2a,0x7f,0xab,0x11,0xaa,
+0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0xe4,0xfc,0xfd,0xfe,0x78,0x1a,
+0x12,0x2a,0x6c,0xa8,0x04,0xa9,0x05,0xaa,0x06,0xab,0x07,0x90,0x97,0xa3,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xec,0x54,0x03,0xfc,0xeb,0x4f,0xff,
+0xea,0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,0x4c,0xfc,0x90,0x97,0xad,0x12,0x2a,0x7f,0x90,
+0x05,0x22,0xe4,0xf0,0x80,0x35,0xe4,0x90,0x97,0xa1,0xf0,0x7f,0x80,0x7e,0x08,0x12,
+0x27,0xde,0xec,0x54,0x03,0xfc,0xec,0x44,0xc0,0xfc,0x90,0x97,0xa3,0x12,0x2a,0x7f,
+0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0xaa,0xe0,0x90,
+0x00,0x47,0x30,0xe1,0x11,0x74,0x0c,0xf0,0xa3,0xe0,0x44,0x0c,0xf0,0x90,0x00,0x46,
+0xe0,0x44,0x10,0xf0,0x80,0x10,0xe0,0x54,0xf3,0xf0,0xa3,0xe0,0x54,0xf3,0xf0,0x90,
+0x00,0x46,0xe0,0x54,0xef,0xf0,0xe4,0x90,0x97,0xa7,0xf0,0x22,0xd3,0x10,0xaf,0x01,
+0xc3,0xc0,0xd0,0x90,0x97,0x8a,0xed,0xf0,0x90,0x97,0x89,0xef,0xf0,0xd3,0x94,0x07,
+0x50,0x4f,0xa3,0xe0,0x70,0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,0xf0,0x80,0x17,
+0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,
+0xff,0x90,0x00,0x47,0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,0x97,0x89,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0x80,
+0x5a,0x90,0x97,0x89,0xe0,0x24,0xf8,0xf0,0xa3,0xe0,0x70,0x1d,0x90,0x97,0x89,0xe0,
+0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,
+0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x80,0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,
+0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x43,
+0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7f,
+0x30,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x97,0xa9,0xe0,0x64,0x01,0x60,0x03,0x02,0x6e,
+0xe9,0x90,0x00,0x46,0xe0,0x44,0x01,0xf0,0x90,0x97,0xbb,0xe0,0x70,0x40,0x90,0x97,
+0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x80,
+0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x97,0xa8,0xe0,0xff,0x12,0x79,0x11,0x90,
+0x97,0xbb,0x74,0x01,0xf0,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0x80,0x44,0x90,0x97,
+0xbb,0xe0,0x64,0x01,0x70,0x3c,0x90,0x97,0xac,0xe0,0xff,0x12,0x79,0x11,0xe4,0x90,
+0x97,0xbb,0xf0,0x90,0x00,0x45,0xe0,0x44,0x01,0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,
+0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x80,0x05,0x90,0x05,0x22,
+0xe4,0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,
+0xf0,0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,
+0xf0,0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,0x22,0x90,0x97,0x81,0xeb,0xf0,0xa3,
+0xea,0xf0,0xa3,0xe9,0xf0,0xef,0x12,0x63,0xee,0x6f,0x1b,0x01,0x6f,0x29,0x02,0x6f,
+0x37,0x03,0x6f,0x45,0x05,0x6f,0x53,0x06,0x6f,0xa8,0x07,0x6f,0x61,0x09,0x6f,0x6f,
+0x0c,0x6f,0x7d,0x0d,0x6f,0x8b,0x0e,0x00,0x00,0x6f,0x99,0x90,0x97,0x81,0xe0,0xfb,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x4d,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x02,0x7f,0xb8,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xf9,0x02,0x7b,0x7f,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x02,0x7d,0x21,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x64,
+0x14,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x73,0x01,0x90,
+0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x65,0x55,0x90,0x97,0x81,
+0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7c,0xc6,0x90,0x97,0x81,0xe0,0xfb,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x6c,0x86,0xc2,0xaf,0x74,0xea,0x04,0x90,0x01,
+0xc4,0xf0,0x74,0x6e,0xa3,0xf0,0x80,0xfe,0x22,0x8f,0x67,0x8d,0x68,0xe5,0x67,0x54,
+0x0f,0xff,0x90,0x97,0xc8,0xe0,0x54,0x0f,0x6f,0x60,0x78,0xe5,0x67,0x30,0xe2,0x30,
+0x90,0x97,0xc8,0xe0,0x20,0xe2,0x05,0x7f,0x01,0x12,0x7e,0x08,0x90,0x97,0xc8,0xe0,
+0x30,0xe3,0x0a,0xe5,0x67,0x20,0xe3,0x05,0x12,0x7e,0x45,0x80,0x56,0x90,0x97,0xc8,
+0xe0,0x20,0xe3,0x4f,0xe5,0x67,0x30,0xe3,0x4a,0xaf,0x68,0x12,0x7d,0xe8,0x80,0x43,
+0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,0x0c,0x0e,0xe5,0x67,0x20,0xe3,0x09,0x12,
+0x7d,0x77,0xef,0x60,0x2e,0x12,0x7e,0x45,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,
+0x04,0x0e,0xe5,0x67,0x20,0xe2,0x09,0x12,0x7b,0xba,0xef,0x60,0x16,0x12,0x7b,0xf1,
+0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,0x02,0x09,0x12,0x7a,0xc8,0xef,0x60,0x03,
+0x12,0x7e,0x62,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0x90,0x97,0xca,0xe0,0x54,0x0f,
+0x6f,0x70,0x23,0xe0,0x30,0xe6,0x1f,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0x90,0x97,
+0xbc,0xe0,0xfe,0x4f,0x90,0x01,0x2f,0xf0,0xee,0x64,0x80,0x90,0x97,0xbc,0xf0,0x90,
+0x97,0xca,0xe0,0x54,0xbf,0xf0,0x22,0x90,0x97,0xde,0xef,0xf0,0xa3,0xed,0xf0,0xe4,
+0xa3,0xf0,0xa3,0xf0,0xe5,0x6a,0x60,0x05,0xe4,0xff,0x12,0x7e,0x9c,0x90,0x97,0xde,
+0xe0,0x30,0xe0,0x09,0x90,0x97,0xe0,0xe4,0xf0,0xa3,0x74,0x80,0xf0,0x90,0x04,0x1d,
+0xe0,0x60,0x1d,0x90,0x05,0x22,0xe0,0x90,0x97,0xe2,0xf0,0xe0,0xff,0x54,0x90,0x60,
+0xec,0x90,0x01,0xc8,0x74,0xfc,0xf0,0xef,0x54,0x6f,0x90,0x05,0x22,0xf0,0x80,0xdd,
+0x90,0x97,0xde,0xe0,0xff,0xc3,0x13,0x90,0xfd,0x10,0xf0,0x90,0x04,0x25,0xef,0xf0,
+0x90,0x97,0xdf,0xe0,0x60,0x1f,0xa3,0xa3,0xe0,0xff,0x24,0x0f,0xf5,0x82,0xe4,0x34,
+0xfc,0xf5,0x83,0xe0,0x44,0x80,0xf0,0x74,0x10,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe0,0x44,0x80,0xf0,0x90,0x97,0xe0,0xa3,0xe0,0xff,0xfd,0x24,0x08,0xf5,0x82,
+0xe4,0x34,0xfc,0xf5,0x83,0xe4,0xf0,0x74,0x09,0x2d,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe0,0x54,0xf0,0xf0,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,
+0x54,0xf7,0xf0,0x90,0x97,0xe0,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0xd3,0x10,0xaf,0x01,
+0xc3,0xc0,0xd0,0x90,0x97,0xf2,0xef,0xf0,0xd3,0x94,0x07,0x50,0x47,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0xe0,
+0x5f,0xf0,0x12,0x7f,0x30,0x90,0x97,0xf2,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,
+0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x44,0xe0,0xfb,
+0xe4,0xfe,0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,
+0xf8,0xff,0x80,0x4c,0x90,0x97,0xf2,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,
+0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,
+0x12,0x7f,0x30,0x90,0x97,0xf2,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,
+0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x42,0xe0,0xfb,0xe4,0xfe,
+0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,
+0xd0,0xd0,0x92,0xaf,0x22,0x90,0x00,0x11,0xe0,0x44,0x09,0xf0,0x12,0x7f,0x30,0x90,
+0x97,0x5d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x78,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x61,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,
+0x7e,0x0c,0x12,0x2f,0xd9,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,0x12,0x2f,0xd9,
+0x90,0x97,0x69,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x70,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x59,0x12,0x2a,
+0x8b,0x00,0x03,0x2d,0x95,0xe4,0xfd,0xff,0x12,0x34,0x81,0x90,0x97,0xd7,0xe0,0xb4,
+0x01,0x11,0x90,0x80,0x59,0x12,0x2a,0x8b,0x00,0x03,0x2d,0x95,0xe4,0xfd,0x7f,0x01,
+0x12,0x34,0x81,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0x70,0xeb,0xf0,
+0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,0x97,0xd6,0xe0,0x64,0x02,0x60,0x7e,0x90,0x01,
+0xaf,0xe0,0x60,0x09,0x90,0x01,0xc7,0xe0,0x04,0xf0,0xf0,0x80,0xf1,0x90,0x97,0xe3,
+0xe0,0xff,0x04,0xf0,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,
+0x00,0x01,0xef,0x12,0x62,0xd4,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0x8b,0x63,0x8a,0x64,0xf5,0x65,0x75,0x66,0x02,0x7b,0x01,0x7a,0x01,0x79,0xa0,0x12,
+0x77,0xae,0x90,0x97,0x73,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x63,0x8a,0x64,
+0xf5,0x65,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x12,0x29,0xd9,
+0xff,0xc4,0x54,0x0f,0xf5,0x66,0x7b,0x01,0x7a,0x01,0x79,0xa2,0x12,0x77,0xae,0x90,
+0x01,0xaf,0x74,0xff,0xf0,0x90,0x01,0xcb,0xe0,0x64,0x80,0xf0,0xd0,0xd0,0x92,0xaf,
+0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,
+0xa3,0xe9,0xf0,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,
+0x01,0x12,0x63,0x4d,0xfa,0xe5,0xf0,0x24,0x00,0xff,0xe4,0x3a,0xfe,0x90,0x97,0x84,
+0xa3,0xe0,0xfa,0x90,0x00,0x01,0xee,0x8f,0xf0,0x12,0x63,0xa4,0x12,0x29,0xd9,0xff,
+0x60,0x37,0xb5,0x22,0x1b,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x90,0x00,0x01,0x12,0x63,0x4d,0x65,0x24,0x70,0x04,0xe5,0x23,0x65,0xf0,0x60,0x2e,
+0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,
+0x4d,0xff,0xae,0xf0,0x12,0x79,0xfa,0x80,0x15,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x12,0x29,0xd9,0x65,0x22,0x60,0x03,0x12,0x7f,0x97,0xd0,0xd0,
+0x92,0xaf,0x22,0xef,0x64,0x01,0x70,0x34,0x7d,0x7d,0x7f,0x02,0x12,0x36,0x75,0x7d,
+0x02,0x7f,0x03,0x12,0x36,0x75,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,
+0xf0,0x7d,0x01,0x7f,0x0c,0x12,0x6f,0xa9,0xe4,0xff,0x12,0x7e,0x9c,0x90,0x06,0x04,
+0xe0,0x54,0x7f,0xf0,0x90,0x06,0x0a,0xe0,0x54,0xf8,0xf0,0x22,0x90,0x01,0x36,0x74,
+0x7d,0xf0,0xa3,0x74,0x02,0xf0,0x7d,0x7d,0xff,0x12,0x36,0xe6,0x7d,0x02,0x7f,0x03,
+0x12,0x36,0xe6,0x90,0x06,0x04,0xe0,0x44,0x80,0xf0,0x90,0x06,0x0a,0xe0,0x44,0x07,
+0xf0,0x90,0x97,0xc3,0xe0,0xa3,0xe0,0x90,0x05,0x58,0xf0,0xe5,0x69,0x30,0xe0,0x1b,
+0x90,0x97,0xc0,0xe0,0x70,0x1a,0xe0,0x04,0xf0,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,
+0x94,0x04,0x50,0x0c,0x7d,0x01,0x7f,0x04,0x02,0x6f,0xa9,0xe4,0x90,0x97,0xc0,0xf0,
+0x22,0xef,0x14,0x60,0x20,0x14,0x60,0x4b,0x24,0x02,0x70,0x78,0x90,0x97,0xa7,0x74,
+0x02,0xf0,0x90,0x00,0x48,0xe0,0x44,0x0c,0xf0,0x90,0x00,0x47,0xe0,0x44,0x08,0xf0,
+0x90,0x00,0x45,0x80,0x5b,0xe4,0x90,0x97,0xa7,0xf0,0x90,0x97,0xa3,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,
+0x7e,0x08,0x12,0x2f,0xd9,0x90,0x00,0x45,0xe0,0x44,0xef,0xf0,0xe0,0x54,0xef,0xf0,
+0xa3,0x80,0x2d,0x90,0x97,0xa7,0x74,0x01,0xf0,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,
+0x08,0x12,0x2f,0xd9,0x90,0x00,0x45,0xe0,0x44,0x20,0xf0,0xe0,0x44,0x10,0xf0,0xa3,
+0xe0,0x44,0x10,0xf0,0x22,0x02,0x74,0xe3,0x02,0x67,0xb0,0xe4,0x93,0xa3,0xf8,0xe4,
+0x93,0xa3,0x40,0x03,0xf6,0x80,0x01,0xf2,0x08,0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,
+0xf8,0x54,0x07,0x24,0x0c,0xc8,0xc3,0x33,0xc4,0x54,0x0f,0x44,0x20,0xc8,0x83,0x40,
+0x04,0xf4,0x56,0x80,0x01,0x46,0xf6,0xdf,0xe4,0x80,0x0b,0x01,0x02,0x04,0x08,0x10,
+0x20,0x40,0x80,0x90,0x7f,0x0e,0xe4,0x7e,0x01,0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,
+0x30,0xe5,0x09,0x54,0x1f,0xfe,0xe4,0x93,0xa3,0x60,0x01,0x0e,0xcf,0x54,0xc0,0x25,
+0xe0,0x60,0xa8,0x40,0xb8,0xe4,0x93,0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,
+0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,
+0x83,0xca,0xdf,0xe9,0xde,0xe7,0x80,0xbe,0xe4,0x90,0x97,0x6e,0xf0,0xe5,0x6a,0x60,
+0x71,0xe5,0x69,0x64,0x01,0x70,0x6b,0xe5,0x6a,0x14,0x60,0x29,0x24,0xfd,0x60,0x25,
+0x24,0x02,0x24,0xfb,0x50,0x02,0x80,0x23,0x90,0x97,0xbe,0xe0,0x14,0xf0,0xe0,0x60,
+0x04,0xa3,0xe0,0x60,0x16,0x90,0x97,0xbe,0xe0,0x70,0x0a,0x90,0x97,0xc9,0xe0,0x90,
+0x97,0xbe,0xf0,0x80,0x00,0x90,0x97,0x6e,0x74,0x01,0xf0,0x90,0x97,0x6e,0xe0,0x60,
+0x31,0x90,0x97,0xcd,0xe0,0x44,0x10,0xf0,0x90,0x97,0xc5,0xe0,0xf5,0x44,0xe4,0xf5,
+0x45,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x57,0x74,0x05,0xf0,
+0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,
+0x6f,0xa9,0x22,0xab,0x07,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,
+0x34,0x93,0xf5,0x83,0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xe0,0x54,0x1f,0xfa,0xd3,0x9f,0x40,0x02,0xaa,0x07,0xea,0x25,0xe0,0x24,0x9e,0xf5,
+0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xea,0x25,0xe0,
+0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,
+0x3e,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,
+0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0x74,0x84,0x2b,0xf5,0x82,
+0xe4,0x34,0x04,0xf5,0x83,0xea,0xf0,0xff,0x22,0x90,0x06,0xa9,0xe0,0xf5,0x0a,0x54,
+0xc0,0x70,0x0e,0x90,0x97,0xcd,0xe0,0x54,0xfe,0xf0,0xe0,0x54,0xfd,0xf0,0x12,0x7f,
+0x8d,0xe5,0x0a,0x30,0xe6,0x19,0x90,0x97,0xcd,0xe0,0x44,0x01,0xf0,0x90,0x97,0xcb,
+0xe0,0x64,0x02,0x60,0x05,0x12,0x7f,0x1f,0x80,0x0c,0x12,0x7b,0x06,0x80,0x07,0x90,
+0x97,0xcd,0xe0,0x54,0xfe,0xf0,0xe5,0x0a,0x90,0x97,0xcd,0x30,0xe7,0x20,0xe0,0x44,
+0x02,0xf0,0x75,0x44,0x03,0xe4,0xf5,0x45,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x35,
+0xab,0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,0xcc,0x74,0x01,0xf0,0x22,0xe0,0x54,
+0xfd,0xf0,0x22,0x8b,0x11,0x8a,0x12,0x89,0x13,0x12,0x7f,0x50,0xab,0x11,0xaa,0x12,
+0xa9,0x13,0x12,0x29,0xd9,0xf5,0x6a,0x14,0x60,0x0e,0x14,0x60,0x1f,0x14,0x60,0x31,
+0x24,0x03,0x70,0x44,0x7f,0x01,0x80,0x3d,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,
+0x02,0x12,0x62,0x95,0xfd,0xe4,0xff,0x12,0x7d,0x9e,0x80,0x29,0xab,0x11,0xaa,0x12,
+0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xfd,0x7f,0x01,0x12,0x7d,0x9e,0x1f,0x80,
+0x14,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xfd,0x7f,0x02,
+0x12,0x7d,0x9e,0xe4,0xff,0x12,0x73,0x93,0x22,0x8d,0x0b,0xe5,0x0b,0x54,0x1f,0xf5,
+0x0f,0x74,0x01,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xf5,0x0e,0x90,0x04,
+0xfd,0xe0,0xb4,0x01,0x05,0x75,0x10,0x03,0x80,0x03,0x75,0x10,0x01,0xeb,0xc3,0x95,
+0x10,0x40,0x03,0x02,0x75,0xa3,0xe5,0x0e,0x25,0x0d,0xfe,0xe5,0x0f,0x90,0x41,0xd6,
+0x93,0xfd,0xee,0xd3,0x9d,0x74,0x01,0x40,0x18,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,
+0x83,0xe4,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe5,0x0b,0xf0,
+0x22,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x22,0x8e,0x11,0x8f,0x12,
+0x8b,0x13,0x8a,0x14,0x89,0x15,0xe4,0x90,0x97,0x79,0xf0,0xef,0x90,0x00,0x31,0xf0,
+0x12,0x7f,0x30,0xe5,0x11,0x54,0x03,0xff,0x90,0x00,0x32,0xe0,0x54,0xfc,0x4f,0xf0,
+0x12,0x7f,0x30,0x90,0x00,0x33,0xe0,0x54,0x7f,0xf0,0x12,0x7f,0x30,0x90,0x00,0x33,
+0xe0,0x20,0xe7,0x0e,0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x05,0xe0,0x04,0xf0,
+0x80,0xeb,0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x10,0x90,0x00,0x30,0xe0,0xab,
+0x13,0xaa,0x14,0xa9,0x15,0x12,0x62,0xc2,0x7f,0x01,0x22,0x7f,0x00,0x22,0xd3,0x10,
+0xaf,0x01,0xc3,0xc0,0xd0,0x8b,0x60,0x8a,0x61,0x89,0x62,0x90,0x97,0xd8,0xeb,0xf0,
+0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xa3,0xe5,0x63,0xf0,0xa3,0xe5,0x64,0xf0,0xa3,0xe5,
+0x65,0xf0,0xaf,0x66,0x15,0x66,0xef,0x60,0x2a,0x90,0x97,0xdb,0xe0,0xfb,0xa3,0xe4,
+0x75,0xf0,0x01,0x12,0x63,0x0c,0xa9,0xf0,0xfa,0x12,0x29,0xd9,0xff,0x90,0x97,0xd8,
+0xe0,0xfb,0xa3,0xe4,0x75,0xf0,0x01,0x12,0x63,0x0c,0xa9,0xf0,0xfa,0xef,0x12,0x62,
+0xc2,0x80,0xcf,0xab,0x60,0xaa,0x61,0xa9,0x62,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x00,
+0x45,0xe4,0xf0,0x90,0x04,0xfd,0xf0,0xa3,0xf0,0x90,0x97,0xab,0xf0,0x90,0x97,0xb1,
+0xf0,0x90,0x97,0xb4,0xf0,0x90,0x97,0xb2,0xf0,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb3,
+0xf0,0x90,0x97,0xb6,0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,
+0xf0,0x90,0x97,0xa2,0xf0,0x90,0x97,0xa7,0xf0,0x90,0x97,0xa9,0xf0,0x90,0x97,0xbb,
+0xf0,0x90,0x97,0xac,0xf0,0x90,0x97,0xa8,0xf0,0x90,0x97,0xa1,0xf0,0x90,0x00,0x51,
+0xe0,0x44,0xc0,0xf0,0x22,0x90,0x00,0x2b,0xe0,0x44,0x01,0xf0,0x7f,0xe8,0x7e,0x03,
+0x12,0x37,0x54,0x90,0x00,0x08,0xe0,0x44,0x10,0xfd,0x7f,0x08,0x12,0x7f,0x83,0x90,
+0x00,0x09,0xe0,0x54,0xf7,0xfd,0x7f,0x09,0x12,0x7f,0x83,0x90,0x00,0x28,0xe0,0x54,
+0xfe,0xfd,0x7f,0x28,0x12,0x7f,0x83,0x90,0x00,0x20,0xe0,0x54,0xfe,0xfd,0x7f,0x20,
+0x12,0x7f,0x83,0x90,0x00,0x25,0xe0,0x44,0x40,0xfd,0x7f,0x25,0x12,0x7f,0x83,0x90,
+0x00,0x09,0xe0,0x54,0xef,0xfd,0x7f,0x09,0x02,0x7f,0x83,0x90,0x00,0x25,0xe0,0x54,
+0xbf,0xfd,0x7f,0x25,0x12,0x7f,0x83,0x90,0x00,0x20,0xe0,0x44,0x01,0xfd,0x7f,0x20,
+0x12,0x7f,0x83,0x90,0x00,0x28,0xe0,0x44,0x01,0xfd,0x7f,0x28,0x12,0x7f,0x83,0x90,
+0x00,0xf0,0xe0,0x30,0xe1,0xf9,0x90,0x00,0x09,0xe0,0x44,0x08,0xfd,0x7f,0x09,0x12,
+0x7f,0x83,0x90,0x00,0x08,0xe0,0x54,0xef,0xfd,0x7f,0x08,0x12,0x7f,0x83,0x90,0x00,
+0x2b,0xe0,0x54,0xfe,0xfd,0x7f,0x2b,0x12,0x7f,0x83,0x7f,0xe8,0x7e,0x03,0x02,0x37,
+0x54,0x90,0x05,0x60,0xe0,0x90,0x97,0xb7,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,
+0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0xb9,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0xba,
+0xf0,0xc3,0x74,0xff,0x9f,0xfe,0x90,0x97,0xb8,0xe0,0xd3,0x9e,0x40,0x1e,0xe0,0x2f,
+0xf0,0xa3,0xe0,0xb4,0xff,0x0f,0xe4,0xf0,0xa3,0xe0,0xb4,0xff,0x03,0xe4,0xf0,0x22,
+0x90,0x97,0xba,0x80,0x03,0x90,0x97,0xb9,0xe0,0x04,0xf0,0x22,0x90,0x97,0xb8,0xe0,
+0x2f,0xf0,0x22,0xe4,0xf5,0x69,0x90,0x97,0xcd,0xf0,0xf5,0x6a,0x90,0x97,0xca,0x74,
+0x0c,0xf0,0x90,0x97,0xc8,0xf0,0xe4,0x90,0x97,0xcb,0xf0,0x90,0x97,0xc7,0xf0,0x90,
+0x97,0xc6,0xf0,0x90,0x97,0xc9,0x04,0xf0,0x90,0x97,0xbe,0xf0,0xe4,0x90,0x97,0xcc,
+0xf0,0x90,0x97,0xc0,0xf0,0x90,0x97,0xc5,0x74,0x07,0xf0,0xe4,0x90,0x97,0xbf,0xf0,
+0x90,0x97,0xc3,0xf0,0xa3,0x74,0x02,0xf0,0xe4,0x90,0x97,0xc2,0xf0,0x90,0x97,0xbd,
+0xf0,0x22,0xe4,0x90,0x97,0xd5,0xf0,0xa2,0xaf,0x33,0x90,0x97,0x7a,0xf0,0x90,0x00,
+0x80,0xe0,0x20,0xe1,0x1a,0x12,0x37,0x7a,0x12,0x37,0x7a,0x90,0x97,0x79,0xe0,0x64,
+0x01,0xf0,0xe0,0x24,0xb2,0x90,0x01,0xc4,0xf0,0x74,0x79,0xa3,0xf0,0x80,0xdf,0x90,
+0x06,0x30,0x74,0x01,0xf0,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x80,0xf0,0x12,0x7f,
+0x30,0x90,0x97,0x7a,0xe0,0x24,0xff,0x92,0xaf,0x22,0x90,0x97,0x87,0xee,0xf0,0xa3,
+0xef,0xf0,0x75,0x22,0x01,0x8e,0x23,0xf5,0x24,0xe4,0xfd,0x7f,0x0b,0x12,0x6d,0x5c,
+0xe4,0xfd,0x7f,0x02,0x12,0x6d,0x5c,0x12,0x7e,0x7f,0xe4,0xff,0x12,0x7f,0x6c,0xe4,
+0xf5,0x26,0x90,0x01,0xc9,0xe5,0x26,0xf0,0x90,0x97,0x87,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xec,0xfb,0x8d,0x44,0xe4,0xf5,0x45,0x7d,0x01,0x7f,0x60,0x7e,0x01,0x02,0x35,0xab,
+0xe4,0x90,0x97,0xeb,0xf0,0xa3,0xf0,0x90,0x05,0xf8,0xe0,0x70,0x0f,0xa3,0xe0,0x70,
+0x0b,0xa3,0xe0,0x70,0x07,0xa3,0xe0,0x70,0x03,0x7f,0x01,0x22,0xd3,0x90,0x97,0xec,
+0xe0,0x94,0xe8,0x90,0x97,0xeb,0xe0,0x94,0x03,0x40,0x03,0x7f,0x00,0x22,0x7f,0x32,
+0x7e,0x00,0x12,0x37,0x54,0x90,0x97,0xec,0xe0,0x04,0xf0,0x70,0xca,0x90,0x97,0xeb,
+0xe0,0x04,0xf0,0x80,0xc2,0xe5,0x22,0x64,0x01,0x70,0x3c,0x12,0x7e,0x7f,0xbf,0x01,
+0x05,0x7f,0x01,0x12,0x7f,0x6c,0x90,0x00,0x46,0xe0,0x44,0x04,0xf0,0x12,0x7f,0x30,
+0x90,0x00,0x44,0xe0,0x54,0xfb,0xf0,0x12,0x7f,0x30,0x90,0x00,0x46,0xe0,0x54,0xfb,
+0xf0,0x12,0x7f,0x30,0x7f,0x02,0x12,0x71,0x1c,0x8f,0x26,0x90,0x01,0xc9,0xe5,0x26,
+0xf0,0xb4,0x01,0x03,0x12,0x7e,0xb7,0x22,0xe5,0x57,0x70,0x37,0x90,0x97,0xca,0xe0,
+0x54,0x0f,0xd3,0x94,0x01,0x50,0x2c,0x90,0x02,0x87,0xe0,0x70,0x26,0x90,0x97,0xd6,
+0xe0,0xb4,0x02,0x10,0x90,0x97,0xce,0xe0,0xfe,0xa3,0xe0,0xf5,0x82,0x8e,0x83,0xe0,
+0x60,0x08,0x80,0x0f,0x90,0x01,0xaf,0xe0,0x70,0x09,0x90,0x97,0xc2,0xe0,0x60,0x03,
+0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x01,0x5f,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x08,
+0xf0,0x75,0x44,0x14,0xe4,0xf5,0x45,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,0x35,0xab,
+0x90,0x01,0x5f,0x74,0x05,0xf0,0x90,0x06,0x92,0x74,0x02,0xf0,0x90,0x97,0xc6,0x14,
+0xf0,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,0x94,0x0c,0x50,0x07,0x7d,0x01,0x7f,0x0c,
+0x12,0x6f,0xa9,0x22,0x90,0x97,0xcc,0xe0,0x60,0x0e,0xe4,0xf0,0xa3,0xe0,0x54,0xfd,
+0xf0,0xe0,0x54,0x07,0x70,0x28,0x80,0x23,0x90,0x97,0xbf,0xe0,0x04,0xf0,0x90,0x97,
+0xcd,0xe0,0x54,0xef,0xf0,0x90,0x97,0xbf,0xe0,0xd3,0x94,0x01,0x40,0x0d,0xe5,0x69,
+0xb4,0x01,0x0b,0xa3,0xe0,0x70,0x07,0xe0,0x04,0xf0,0x22,0x12,0x7f,0x8d,0x22,0x90,
+0x02,0x09,0xe0,0xfd,0x12,0x29,0xd9,0xfe,0xaf,0x05,0xed,0x2e,0x90,0x97,0xd1,0xf0,
+0x90,0x00,0x01,0x12,0x62,0x95,0xff,0xed,0x2f,0x90,0x97,0xd2,0xf0,0x90,0x00,0x02,
+0x12,0x62,0x95,0xff,0xed,0x2f,0x90,0x97,0xd3,0xf0,0x90,0x00,0x03,0x12,0x62,0x95,
+0xff,0xae,0x05,0xed,0x2f,0x90,0x97,0xd4,0xf0,0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,
+0x64,0x7f,0x70,0x2a,0x90,0x97,0xcd,0xe0,0x54,0x03,0x70,0x22,0x90,0x97,0xca,0xe0,
+0x54,0x0f,0xd3,0x94,0x02,0x50,0x17,0x90,0x97,0xcd,0xe0,0x20,0xe2,0x10,0x90,0x97,
+0xcd,0xe0,0x20,0xe4,0x09,0x90,0x97,0xc0,0xe0,0x70,0x03,0x7f,0x01,0x22,0x7f,0x00,
+0x22,0x90,0x01,0x37,0x74,0x02,0xf0,0x90,0x05,0x22,0x74,0xff,0xf0,0x12,0x7a,0x40,
+0xef,0x70,0x06,0x90,0x01,0xc8,0x74,0xfd,0xf0,0x7d,0x02,0x7f,0x03,0x12,0x36,0xe6,
+0xe5,0x6a,0x60,0x05,0x7f,0x01,0x12,0x7e,0x9c,0x12,0x6a,0xc2,0x90,0x97,0xc8,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x8f,0x27,0x90,0x97,0xd3,0xe0,0xff,0x7d,
+0x01,0x12,0x70,0x67,0xe5,0x27,0x60,0x10,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,
+0xf5,0x83,0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,
+0xf5,0x83,0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x8f,0x6b,0x90,
+0x97,0xd4,0xe0,0xff,0x7d,0x01,0x12,0x70,0x67,0xe5,0x6b,0x60,0x10,0x74,0x21,0x2f,
+0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,
+0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,
+0xf0,0x22,0x7d,0x02,0x7f,0x03,0x12,0x36,0x75,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,
+0x80,0x23,0x90,0x97,0xcb,0xe0,0x60,0x06,0x7d,0x01,0x7f,0x0c,0x80,0x0f,0x90,0x97,
+0xc8,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xa9,
+0xe4,0xff,0x12,0x7e,0x9c,0x22,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x97,0xab,0xf0,
+0xe0,0x60,0x04,0xe0,0xb4,0xff,0x1c,0xa2,0xaf,0xe4,0x33,0xf5,0x11,0xc2,0xaf,0x90,
+0x00,0x47,0xe0,0x54,0xfb,0xf0,0x7d,0x40,0x7f,0x01,0x12,0x36,0xaf,0xe5,0x11,0x24,
+0xff,0x92,0xaf,0x22,0x90,0x06,0x34,0xe0,0x60,0x26,0x14,0x70,0x1b,0x7b,0x01,0x7a,
+0x06,0x79,0x35,0x7f,0xf9,0x7e,0x01,0x12,0x77,0x4c,0xbf,0x01,0x09,0x90,0x06,0x35,
+0xe0,0x54,0x0f,0xf0,0x80,0x05,0x80,0x00,0x02,0x7f,0x5e,0xe4,0x90,0x06,0x34,0xf0,
+0x22,0x12,0x29,0xd9,0xff,0xc3,0x94,0x20,0x50,0x14,0x90,0x00,0x02,0x12,0x62,0x95,
+0xfe,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xee,0xf0,0x22,0xef,0xb4,
+0x20,0x0a,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x93,0x61,0xf0,0x22,0xd3,0x10,0xaf,
+0x01,0xc3,0xc0,0xd0,0x90,0x00,0x01,0x12,0x62,0x95,0x90,0x97,0xcb,0xf0,0x90,0x00,
+0x03,0x12,0x62,0x95,0x90,0x97,0xbd,0xf0,0x12,0x29,0xd9,0x65,0x6a,0x60,0x03,0x12,
+0x76,0x83,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,0xff,0xbf,0x7f,
+0x1a,0x90,0x97,0xc7,0xe0,0x70,0x14,0x90,0x97,0xc6,0xe0,0x70,0x0e,0x90,0x97,0xca,
+0xe0,0x54,0x0f,0xd3,0x94,0x04,0x50,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0xef,0x24,
+0xfe,0x60,0x0b,0x04,0x70,0x1d,0x90,0x97,0xc9,0x74,0x01,0xf0,0x80,0x11,0xed,0x90,
+0x97,0xc9,0x70,0x05,0x74,0x05,0xf0,0x80,0x02,0xed,0xf0,0x90,0x97,0xc9,0xe0,0x90,
+0x97,0xbe,0xf0,0x22,0x90,0x97,0x6e,0xe0,0x54,0xf0,0x44,0x03,0xf0,0x54,0x0f,0x44,
+0x80,0xf0,0x90,0x97,0x73,0xe4,0xf0,0xa3,0x74,0x00,0xf0,0xa3,0x74,0x58,0xf0,0x7b,
+0x01,0x7a,0x97,0x79,0x6e,0x02,0x72,0x64,0x90,0x06,0x04,0xe0,0x54,0xbf,0xf0,0xef,
+0x60,0x0a,0xe5,0x69,0xb4,0x01,0x05,0xe4,0xff,0x12,0x7c,0x28,0x90,0x97,0xc8,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x0c,0xf0,0x22,0x90,0x97,0xf0,0xef,0xf0,0x12,0x71,0xc5,
+0x90,0x97,0xf0,0xe0,0x60,0x05,0x90,0x05,0x22,0xe4,0xf0,0x90,0x97,0xc8,0xe0,0x54,
+0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x75,0x28,0x33,0xe4,0xf5,0x29,0x75,0x2a,0x02,
+0xf5,0x2b,0x90,0x01,0x30,0xe5,0x28,0xf0,0xa3,0xe5,0x29,0xf0,0xa3,0xe5,0x2a,0xf0,
+0xa3,0xe5,0x2b,0xf0,0x22,0x90,0x06,0x04,0xe0,0x44,0x40,0xf0,0xe5,0x69,0xb4,0x01,
+0x05,0x7f,0x01,0x12,0x7c,0x28,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x04,
+0xf0,0x22,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x01,0xf0,0x12,0x78,0x65,
+0x12,0x78,0xbb,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x7f,
+0x0b,0x12,0x71,0x1c,0xef,0x65,0x25,0x60,0x10,0xe5,0x25,0xb4,0x01,0x05,0xe4,0xf5,
+0x25,0x80,0x03,0x75,0x25,0x01,0x7f,0x01,0x22,0x7f,0x00,0x22,0xef,0x60,0x0b,0x90,
+0x97,0xd7,0xe0,0xb4,0x01,0x10,0xe4,0xff,0x80,0x09,0x90,0x97,0xd7,0xe0,0xb4,0x01,
+0x05,0x7f,0x01,0x12,0x4e,0x3f,0x22,0x90,0x00,0x49,0xe0,0x90,0x97,0xf1,0xf0,0xe0,
+0x54,0x0f,0xf0,0xe0,0xff,0x44,0xf0,0x90,0x00,0x49,0xf0,0xef,0x44,0xb0,0xf0,0x22,
+0x75,0x30,0x1e,0x75,0x31,0x01,0xe4,0xf5,0x32,0x90,0x01,0x38,0xe5,0x30,0xf0,0xa3,
+0xe5,0x31,0xf0,0xa3,0xe5,0x32,0xf0,0x22,0x90,0x01,0x3c,0x74,0xff,0xf0,0xa3,0xf0,
+0xa3,0xf0,0x90,0x01,0x34,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x02,0x09,
+0xe0,0xff,0x7d,0x01,0x12,0x70,0x67,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x41,0x97,
+0xd0,0x00,0x41,0x97,0xef,0x00,0x41,0x97,0xbc,0x80,0x41,0x97,0xe3,0x00,0x00,0x90,
+0x97,0xd2,0xe0,0xff,0xe4,0xfd,0x12,0x70,0x67,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,
+0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x7f,0x10,0xdf,0xfe,0xd0,0xd0,0x92,0xaf,0x22,
+0x90,0x09,0x28,0xef,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,
+0xe4,0x90,0x97,0xcc,0xf0,0x90,0x97,0xbf,0xf0,0x90,0x97,0xcd,0xf0,0x22,0x90,0x06,
+0x34,0x74,0xff,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x01,0xca,0xe5,
+0x25,0xf0,0xef,0x60,0x03,0x12,0x7e,0xb7,0x22,0x8f,0x82,0x8e,0x83,0xa3,0xa3,0xa3,
+0xe4,0xf0,0x22,0x8f,0x82,0x75,0x83,0x00,0xed,0xf0,0x02,0x7f,0x30,0x90,0x97,0xca,
+0xe0,0xff,0x7d,0x01,0x02,0x6f,0xa9,0xe4,0xf5,0x22,0x7f,0x60,0x7e,0x01,0x02,0x7f,
+0x79,0x90,0x97,0xd7,0xe0,0x90,0x97,0x6d,0xf0,0x22,0x8f,0x1c,0x8c,0x1d,0x8d,0x1e,
+0x22,0x8f,0x1f,0x8c,0x20,0x8d,0x21,0x22,0x12,0x29,0xd9,0xf5,0x69,0x22,0xa1,0x16,
+};
+#else
+// =================== TSMC FW V66 2011-02-10 =======================
+u8 Rtl8192CUFwTSMCImgArray[TSMCImgArrayLength] = {
+0xc1,0x88,0x02,0x00,0x42,0x00,0x00,0x00,0x01,0x27,0x14,0x10,0x42,0x3f,0x00,0x00,
+0x15,0x49,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x02,0x74,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x59,0x7b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x44,0x68,0x00,0x00,0x00,0x00,0x00,0x02,0x66,0x69,0x00,0x00,
+0x05,0x04,0x03,0x02,0x00,0x03,0x06,0x05,0x04,0x03,0x00,0x04,0x06,0x05,0x04,0x02,
+0x00,0x04,0x08,0x07,0x06,0x04,0x00,0x06,0x0a,0x09,0x08,0x06,0x00,0x08,0x0a,0x09,
+0x08,0x04,0x00,0x08,0x0a,0x09,0x08,0x02,0x00,0x08,0x0a,0x09,0x08,0x00,0x00,0x08,
+0x12,0x11,0x10,0x08,0x00,0x10,0x1a,0x19,0x18,0x10,0x00,0x18,0x22,0x21,0x20,0x18,
+0x00,0x20,0x22,0x21,0x20,0x10,0x00,0x20,0x22,0x21,0x20,0x08,0x00,0x20,0x22,0x21,
+0x1c,0x08,0x00,0x20,0x22,0x21,0x14,0x08,0x00,0x20,0x22,0x20,0x18,0x08,0x00,0x20,
+0x31,0x30,0x20,0x10,0x00,0x30,0x31,0x30,0x18,0x00,0x00,0x30,0x31,0x2f,0x10,0x10,
+0x00,0x30,0x31,0x2c,0x10,0x10,0x00,0x30,0x31,0x28,0x10,0x00,0x00,0x30,0x31,0x20,
+0x10,0x00,0x00,0x30,0x31,0x10,0x10,0x00,0x00,0x30,0x04,0x04,0x04,0x05,0x04,0x04,
+0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,
+0x05,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x07,0x0a,0x0b,
+0x0d,0x10,0x04,0x05,0x05,0x06,0x06,0x09,0x0c,0x11,0x08,0x08,0x09,0x09,0x0a,0x0c,
+0x10,0x11,0x04,0x04,0x04,0x05,0x04,0x04,0x05,0x07,0x07,0x07,0x08,0x0a,0x04,0x04,
+0x04,0x04,0x06,0x0a,0x0c,0x0d,0x05,0x05,0x07,0x07,0x08,0x0b,0x0e,0x0f,0x04,0x04,
+0x04,0x05,0x07,0x07,0x09,0x09,0x0c,0x0e,0x10,0x12,0x04,0x04,0x05,0x05,0x06,0x0a,
+0x11,0x13,0x09,0x09,0x09,0x09,0x0c,0x0e,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x24,0x26,0x2a,0x18,0x1a,0x1d,0x1f,0x21,0x27,0x29,0x2a,0x00,0x00,
+0x00,0x1f,0x23,0x28,0x2a,0x2c,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x18,
+0x00,0x24,0x00,0x30,0x00,0x48,0x00,0x60,0x00,0x90,0x00,0xc0,0x00,0xd8,0x00,0x50,
+0x00,0x78,0x00,0xa0,0x00,0xc8,0x01,0x40,0x01,0x90,0x01,0xe0,0x02,0x30,0x01,0x2c,
+0x01,0x40,0x01,0xe0,0x02,0xd0,0x03,0xe8,0x04,0xb0,0x06,0x40,0x07,0xd0,0x00,0x02,
+0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x0c,0x00,0x12,0x00,0x18,0x00,0x24,0x00,0x30,
+0x00,0x48,0x00,0x60,0x00,0x6c,0x00,0x28,0x00,0x3c,0x00,0x50,0x00,0x64,0x00,0xa0,
+0x00,0xc8,0x00,0xf0,0x01,0x18,0x00,0x64,0x00,0xa0,0x00,0xf0,0x01,0x68,0x01,0xf4,
+0x02,0x58,0x03,0x20,0x03,0xe8,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x04,0x04,
+0x05,0x07,0x04,0x04,0x07,0x0a,0x0a,0x0c,0x0c,0x12,0x05,0x07,0x07,0x08,0x0b,0x12,
+0x24,0x3c,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x01,0x02,
+0x03,0x04,0x05,0x06,0x07,0x08,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x22,0x1f,
+0x1e,0x18,0x10,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xab,0x07,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,
+0x97,0x92,0xf0,0xe0,0x54,0x1f,0xa3,0xf0,0xfa,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xf9,0x90,0x97,0x95,0xf0,0xeb,0x25,
+0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,
+0x96,0xcf,0xf0,0xa3,0xef,0xf0,0xeb,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,0x98,0xcf,0xf0,0xa3,0xef,0xf0,0xea,0x25,
+0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0xea,0xc3,0x99,0x40,0x03,0x02,0x43,0x59,0x90,0x97,0x93,
+0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0xef,0x04,
+0x90,0x97,0x94,0xf0,0x90,0x97,0x95,0xe0,0xff,0x90,0x97,0x94,0xe0,0xfe,0xd3,0x9f,
+0x40,0x03,0x02,0x43,0x98,0xee,0xc3,0x94,0x10,0x40,0x21,0xee,0x24,0xf0,0xff,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0x90,0x97,0x96,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,0x90,0x97,0x94,0xe0,
+0xff,0xc3,0x94,0x10,0x50,0x4a,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x98,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x2d,0x90,0x97,0x94,0xe0,0xff,0x64,0x13,0x60,0x09,0xef,0x64,0x12,0x60,
+0x04,0xef,0xb4,0x11,0x0d,0x90,0x97,0x96,0xe0,0x30,0xe0,0x06,0x90,0x97,0x94,0x74,
+0x18,0xf0,0x90,0x97,0x94,0xe0,0x90,0x97,0x93,0xf0,0x90,0x97,0x92,0xf0,0x80,0x48,
+0x90,0x97,0x94,0xe0,0x04,0xf0,0x02,0x42,0xc4,0x90,0x97,0x95,0xe0,0xfa,0x90,0x97,
+0x93,0xe0,0xff,0x6a,0x70,0x79,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0xe0,0xb4,0x01,0x13,0x90,0x97,0x92,0xe0,0xff,0x30,0xe6,0x01,0x22,0x90,0x97,
+0x93,0xe0,0x44,0x40,0x90,0x97,0x92,0xf0,0x90,0x97,0x93,0xe0,0xff,0x25,0xe0,0x24,
+0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,
+0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,
+0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,
+0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0x80,0x69,0x90,
+0x97,0x93,0xe0,0xd3,0x9a,0x40,0x61,0x90,0x97,0x95,0xe0,0xff,0x74,0xe5,0x2b,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x93,0xef,0xf0,0x90,0x97,0x92,
+0xf0,0xfa,0xa3,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,
+0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,
+0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0xaf,0x02,0x22,0x74,0x01,0x2b,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0xe4,0xf0,0x90,0x97,0x92,0xe0,0x44,0x80,0xff,0x74,0x84,0x2b,0xf5,0x82,
+0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,0x82,
+0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,0xc0,
+0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x68,0xf0,0x74,0x44,0xa3,0xf0,0x53,
+0x91,0xef,0x90,0x00,0x51,0xe0,0xff,0x90,0x00,0x55,0xe0,0x5f,0xf5,0x3d,0xe5,0x3d,
+0x30,0xe6,0x18,0x74,0x40,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,0xff,0xbf,0x03,0x0b,
+0x90,0x97,0xa7,0xe0,0x60,0x05,0x7f,0x01,0x12,0x74,0x2b,0xe5,0x3d,0x30,0xe7,0x15,
+0x90,0x00,0x55,0x74,0x80,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,0xff,0xbf,0x03,0x05,
+0x7f,0x02,0x12,0x74,0x2b,0x90,0x01,0xc4,0x74,0x68,0xf0,0x74,0x44,0xa3,0xf0,0xd0,
+0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,
+0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x90,0x97,0xd5,0xe0,0x90,0x97,
+0x6d,0xf0,0x22,0x02,0x7f,0x26,0x02,0x7f,0x2d,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xff,0xc3,0x94,0x20,0x40,0x03,0x02,0x4e,0x3e,0x75,0xf0,0x09,0xef,0xa4,
+0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x4e,0x35,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,0x00,0xec,0x94,0x00,0x50,0x03,0x02,0x4e,0x35,
+0xef,0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf9,0x74,0x90,0x35,0xf0,0xfa,0x7b,0x01,0x8b,
+0x14,0xf5,0x15,0x89,0x16,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,
+0x34,0x91,0xf5,0x83,0xe0,0xfd,0xa3,0xe0,0x90,0x97,0x85,0xcd,0xf0,0xa3,0xed,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0xff,0xa3,0xe0,
+0x90,0x97,0x87,0xcf,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x02,0x12,0x63,0x20,0xff,0xae,
+0xf0,0x12,0x62,0xf5,0x2f,0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8e,0xf0,0xa3,0xef,0xf0,
+0x90,0x00,0x06,0x12,0x63,0x20,0xff,0xae,0xf0,0x90,0x00,0x04,0x12,0x63,0x20,0x2f,
+0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8c,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x08,0x12,0x63,
+0x20,0xff,0x90,0x97,0x8a,0xe5,0xf0,0xf0,0xa3,0xef,0xf0,0x90,0x97,0x79,0xe0,0xfe,
+0x24,0x84,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x3f,0x90,0x97,0x7b,0xf0,
+0xe0,0xfd,0x54,0x1f,0xa3,0xf0,0x75,0xf0,0x09,0xee,0xa4,0x24,0x67,0xf5,0x82,0xe5,
+0xf0,0x34,0x93,0xf5,0x83,0xe0,0x90,0x97,0x90,0xf0,0x90,0x97,0x79,0xe0,0xfb,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xc3,0x94,0x05,0x40,0x03,0x02,0x49,
+0xba,0x90,0x97,0x90,0xe0,0xfe,0x90,0x97,0x7c,0xe0,0x9e,0x40,0x13,0x90,0x97,0x90,
+0xe0,0x90,0x97,0x7c,0xf0,0xed,0x54,0x40,0xfd,0x90,0x97,0x7b,0xf0,0xee,0x4d,0xf0,
+0x90,0x04,0xfd,0xe0,0x64,0x01,0x70,0x28,0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,
+0x93,0xfe,0x74,0x63,0x2b,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,
+0x06,0xef,0x90,0x40,0xda,0x80,0x32,0x90,0x97,0x7c,0xe0,0x90,0x40,0xf6,0x80,0x29,
+0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,0x93,0xfe,0x90,0x97,0x79,0xe0,0x24,0x63,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,0x06,0xef,0x90,0x41,0x12,
+0x80,0x07,0x90,0x97,0x7c,0xe0,0x90,0x41,0x2e,0x93,0x90,0x97,0x89,0xf0,0x90,0x97,
+0x89,0xe0,0x75,0xf0,0x06,0xa4,0x24,0x50,0xf9,0x74,0x40,0x35,0xf0,0x75,0x11,0xff,
+0xf5,0x12,0x89,0x13,0x90,0x97,0x7b,0xe0,0x90,0x41,0xf2,0x93,0xff,0xd3,0x90,0x97,
+0x88,0xe0,0x9f,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x0d,0x90,0x97,0x79,0xe0,0xff,
+0xe4,0xfd,0x12,0x5f,0x29,0x02,0x4d,0xcb,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,
+0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,
+0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x29,0xd9,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,
+0xa9,0x16,0x12,0x62,0xf5,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,
+0xaa,0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x68,0xff,0x7e,0x00,0xab,0x14,0xaa,
+0x15,0xa9,0x16,0x90,0x00,0x02,0x12,0x63,0x20,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,
+0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,
+0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,
+0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,
+0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x68,0xff,0x7e,
+0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x04,0x12,0x63,0x20,0xfd,0xac,0xf0,
+0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,
+0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x03,0x12,
+0x62,0x68,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x06,0x12,0x63,
+0x20,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,
+0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,
+0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,
+0x90,0x00,0x04,0x12,0x62,0x68,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,
+0x00,0x08,0x12,0x63,0x20,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,
+0x05,0x12,0x62,0x68,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,
+0x29,0xf2,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xa4,0x90,0x97,0x7d,0x40,0x50,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0xab,
+0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x05,0x12,0x62,0x68,0xff,0x7e,0x00,0x90,0x97,
+0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x29,0xf2,0xab,0x07,0xaa,0x06,0xd0,0x07,0xd0,
+0x06,0xd0,0x05,0xd0,0x04,0xc3,0xef,0x9b,0xff,0xee,0x9a,0xfe,0xed,0x94,0x00,0xfd,
+0xec,0x94,0x00,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x80,0x07,0x12,0x2a,0x8b,0x00,
+0x00,0x00,0x00,0x90,0x97,0x7d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0x90,0x97,0x7b,0xe0,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,
+0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xa4,
+0x40,0x0b,0x90,0x97,0x79,0xe0,0xff,0x12,0x42,0x20,0x02,0x4d,0x99,0x90,0x97,0x7b,
+0xe0,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,
+0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xc3,0x12,0x63,0xa4,0x40,0x03,0x02,0x4d,0x99,0x90,0x97,0x79,
+0xe0,0xff,0x7d,0x01,0x12,0x5f,0x29,0x02,0x4d,0x99,0x90,0x97,0x79,0xe0,0xff,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x64,0x05,0x60,0x03,0x02,0x4b,0xb6,
+0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,
+0x64,0x01,0x70,0x03,0x02,0x4b,0xb6,0x90,0x93,0x62,0xe0,0xff,0xb4,0x03,0x0b,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x19,0x40,0x3d,0x80,0x2e,0xef,0xb4,0x02,0x0b,0x90,0x97,
+0x7c,0xe0,0xc3,0x94,0x11,0x40,0x2e,0x80,0x1f,0x90,0x93,0x62,0xe0,0xff,0xb4,0x01,
+0x0b,0x90,0x97,0x7c,0xe0,0xc3,0x94,0x0a,0x40,0x1b,0x80,0x0c,0xef,0x70,0x11,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x03,0x40,0x0d,0x90,0x95,0x83,0x74,0x01,0xf0,0x80,0x05,
+0xe4,0x90,0x95,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0x83,0xf5,0x82,0xe4,0x34,
+0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe0,0xff,0xc3,0x94,0x30,0x50,0x03,0x02,0x4b,0x44,0x90,0x95,0x83,0xe0,
+0x64,0x01,0x60,0x03,0x02,0x4b,0x44,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,0xe4,
+0x34,0x95,0xf5,0x83,0xe0,0x64,0x0a,0x60,0x56,0x90,0x97,0x79,0xe0,0xfe,0xef,0x24,
+0x05,0xfd,0xe4,0x33,0xfc,0x74,0x21,0x2e,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,
+0xff,0xd3,0x9d,0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x33,0xef,0x24,0x05,0xfd,
+0xe4,0x33,0xfc,0x74,0x63,0x2e,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xd3,0x9d,
+0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x16,0x90,0x97,0x79,0xe0,0x24,0xc4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xff,0x90,0x97,0x7c,0xe0,0x6f,0x60,0x56,0x90,
+0x97,0x79,0xe0,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xff,0xd3,0x94,
+0x44,0x40,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x11,0xef,0xd3,0x94,0x3a,0x90,
+0x97,0x91,0x40,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0x90,0x97,0x79,0xe0,
+0xff,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xfe,0x74,0x21,0x2f,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,
+0xe4,0x34,0x95,0x80,0x2f,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,
+0x04,0xf0,0x80,0x14,0xe4,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0x24,0xa4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x7c,0xe0,0xff,0x90,0x97,0x79,
+0xe0,0xfe,0x24,0xc4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x91,
+0xe0,0xff,0x74,0x83,0x2e,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,
+0xe0,0x1e,0xef,0xc4,0x54,0xf0,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,
+0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x02,0x4d,0x7c,
+0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,
+0xe0,0x54,0xf0,0x02,0x4d,0x7c,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x96,0xf5,0x83,0xe0,0x64,0x06,0x60,0x03,0x02,0x4d,0x99,0x75,0xf0,0x09,0xef,
+0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x70,0x03,
+0x02,0x4d,0x99,0x90,0x97,0x7d,0x12,0x2a,0x8b,0x00,0x00,0x00,0x00,0x90,0x42,0x13,
+0xe4,0x93,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x29,0xf2,
+0xe4,0xfc,0xfd,0x90,0x97,0x81,0x12,0x2a,0x7f,0x90,0x97,0x79,0xe0,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0xe4,0x90,0x97,0x7a,0xf0,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x97,0x7a,0xe0,
+0xff,0x75,0xf0,0x02,0xa4,0xf5,0x82,0x85,0xf0,0x83,0x12,0x63,0x20,0xfd,0xac,0xf0,
+0xef,0x90,0x42,0x0e,0x93,0xff,0x7e,0x00,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x81,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xa4,0x50,0x0e,0x90,0x97,0x7a,0xe0,0x04,0xf0,
+0xe0,0x64,0x05,0x60,0x03,0x02,0x4c,0x20,0x90,0x97,0x7a,0xe0,0xc3,0x13,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xb4,0x01,0x0d,0x90,0x97,0x7a,0xe0,0x70,0x5d,0x90,0x97,0x91,
+0x04,0xf0,0x80,0x5b,0xef,0xb4,0x03,0x1d,0x90,0x97,0x7a,0xe0,0xff,0x70,0x08,0x90,
+0x97,0x91,0x74,0x03,0xf0,0x80,0x48,0xef,0xb4,0x01,0x08,0x90,0x97,0x91,0x74,0x01,
+0xf0,0x80,0x3c,0x80,0x35,0x90,0x97,0x91,0xe0,0x64,0x05,0x70,0x32,0x90,0x97,0x7a,
+0xe0,0xff,0x70,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x0f,0xef,0x90,0x97,0x91,
+0xb4,0x01,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0xd3,0x90,0x97,0x88,0xe0,
+0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,0x97,0x91,0xf0,0xd3,
+0x90,0x97,0x88,0xe0,0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,
+0x97,0x91,0xf0,0x90,0x97,0x91,0xe0,0xff,0x90,0x97,0x79,0xe0,0xfe,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,0xe0,0x1d,0xef,0xc4,0x54,0xf0,
+0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x80,0x13,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0xf0,0xf0,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x90,0x97,0x91,
+0xe0,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xd3,0x94,0x05,0x50,0x0f,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x04,0xf0,0x80,0x0f,0x90,0x97,0x79,0xe0,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xab,0x14,0xaa,0x15,0xa9,
+0x16,0xe4,0xf5,0xf0,0x12,0x63,0x58,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x02,
+0xe4,0xf5,0xf0,0x12,0x63,0x77,0x90,0x00,0x04,0xe4,0xf5,0xf0,0x12,0x63,0x77,0x90,
+0x00,0x06,0xe4,0xf5,0xf0,0x12,0x63,0x77,0x90,0x00,0x08,0xe4,0xf5,0xf0,0x12,0x63,
+0x77,0x90,0x97,0x79,0xe0,0xff,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x02,0x45,0x0e,0x22,0xef,
+0x70,0x03,0x02,0x50,0xa7,0x90,0x97,0x6d,0xe0,0x60,0x03,0x02,0x54,0xe9,0x90,0x97,
+0x59,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,
+0x2a,0x7f,0x7f,0x8c,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x05,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x44,0x7e,
+0x08,0x12,0x2f,0xd9,0x90,0x97,0x09,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x5c,0x7e,0x08,0x12,0x2f,0xd9,0x90,
+0x97,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x6c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x11,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x70,
+0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x15,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x74,0x7e,0x0e,0x12,0x2f,0xd9,
+0x90,0x97,0x19,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x78,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x1d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,
+0x7c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x21,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x0e,0x12,0x2f,
+0xd9,0x90,0x97,0x25,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x80,0x85,0x12,0x2a,0x7f,0x7f,0x84,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x29,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,
+0x7f,0x88,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x2d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x8c,0x7e,0x0e,0x12,
+0x2f,0xd9,0x90,0x97,0x31,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xd0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x35,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,
+0x7f,0x7f,0xd4,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x39,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xd8,0x7e,0x0e,
+0x12,0x2f,0xd9,0x90,0x97,0x3d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xdc,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,
+0x41,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,
+0x2a,0x7f,0x7f,0xe0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x45,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xec,0x7e,
+0x0e,0x12,0x2f,0xd9,0x90,0x97,0x49,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,0x2f,0xd9,0x90,
+0x97,0x4d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x2f,0xd9,0x90,0x97,0x51,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,
+0x7e,0x09,0x12,0x2f,0xd9,0x90,0x97,0x55,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x08,0x12,0x2f,0xd9,
+0x90,0x97,0x6d,0x74,0x01,0xf0,0x22,0x90,0x97,0x6d,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x54,0xe9,0x7f,0x8c,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x59,0x12,0x2a,0x7f,0x7f,
+0x44,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x05,0x12,0x2a,0x7f,0x7f,0x5c,0x7e,0x08,
+0x12,0x27,0xde,0x90,0x97,0x09,0x12,0x2a,0x7f,0x7f,0x6c,0x7e,0x0e,0x12,0x27,0xde,
+0x90,0x97,0x0d,0x12,0x2a,0x7f,0x7f,0x70,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x11,
+0x12,0x2a,0x7f,0x7f,0x74,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x15,0x12,0x2a,0x7f,
+0x7f,0x78,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x19,0x12,0x2a,0x7f,0x7f,0x7c,0x7e,
+0x0e,0x12,0x27,0xde,0x90,0x97,0x1d,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x0e,0x12,0x27,
+0xde,0x90,0x97,0x21,0x12,0x2a,0x7f,0x7f,0x84,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,
+0x25,0x12,0x2a,0x7f,0x7f,0x88,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x29,0x12,0x2a,
+0x7f,0x7f,0x8c,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x2d,0x12,0x2a,0x7f,0x7f,0xd0,
+0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x31,0x12,0x2a,0x7f,0x7f,0xd4,0x7e,0x0e,0x12,
+0x27,0xde,0x90,0x97,0x35,0x12,0x2a,0x7f,0x7f,0xd8,0x7e,0x0e,0x12,0x27,0xde,0x90,
+0x97,0x39,0x12,0x2a,0x7f,0x7f,0xdc,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x3d,0x12,
+0x2a,0x7f,0x7f,0xe0,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x41,0x12,0x2a,0x7f,0x7f,
+0xec,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x45,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,
+0x12,0x27,0xde,0x90,0x97,0x49,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x27,0xde,
+0x90,0x97,0x4d,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x27,0xde,0x90,0x97,0x51,
+0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x55,0x12,0x2a,0x7f,
+0x7f,0x8c,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0xc0,0xfd,0xec,
+0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x8c,0x7e,0x08,0x12,0x2f,
+0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0x01,0x00,0x00,0x7f,0x44,0x7e,0x08,0x12,
+0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0xdb,0x25,0xa4,0x7f,0x5c,0x7e,0x08,
+0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x6c,0x7e,
+0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x70,
+0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,0xa4,0x7f,
+0x74,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,0xa4,
+0x7f,0x78,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,
+0xa4,0x7f,0x7c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,
+0x25,0xa4,0x7f,0x80,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x63,
+0xdb,0x25,0xa4,0x7f,0x84,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,
+0x04,0x1b,0x25,0xa4,0x7f,0x88,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,
+0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x8c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,
+0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,
+0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd4,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,
+0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd8,0x7e,0x0e,0x12,0x2f,0xd9,0x90,
+0x80,0x85,0x12,0x2a,0x8b,0x00,0x1b,0x25,0xa4,0x7f,0xdc,0x7e,0x0e,0x12,0x2f,0xd9,
+0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0x1b,0x25,0xa4,0x7f,0xe0,0x7e,0x0e,0x12,0x2f,
+0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x24,0xdb,0x25,0xa4,0x7f,0xec,0x7e,0x0e,0x12,
+0x2f,0xd9,0x7f,0x04,0x7e,0x0c,0x12,0x27,0xde,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,
+0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe1,
+0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x44,0x11,0xff,0xec,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,
+0x7e,0x0c,0x12,0x2f,0xd9,0x7f,0x04,0x7e,0x0d,0x12,0x27,0xde,0x90,0x97,0xe1,0x12,
+0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,
+0xf0,0xff,0xec,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x01,0xff,0xec,0x90,0x97,0xe1,0x12,0x2a,0x7f,
+0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x2f,0xd9,0x7f,0x0c,0x7e,0x09,0x12,
+0x27,0xde,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x11,0xff,0xec,0x90,0x97,0xe1,
+0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x2f,0xd9,0x7f,0x0c,
+0x7e,0x09,0x12,0x27,0xde,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x54,0x0f,0xfd,0xec,0x54,0xf0,
+0xfc,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0x10,0xfd,0xec,0x44,0x01,0xfc,0x90,0x97,0xe1,
+0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x2f,0xd9,0x7f,0x04,
+0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xf0,0xff,0xec,0x90,0x97,0xe1,0x12,
+0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,
+0x01,0xff,0xec,0x90,0x97,0xe1,0x12,0x2a,0x7f,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,
+0x08,0x12,0x2f,0xd9,0xe4,0x90,0x97,0x6d,0xf0,0x22,0x8f,0x11,0xef,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xaf,0x82,0xf5,0x12,0x8f,0x13,0xe5,0x11,0x75,0xf0,
+0x02,0xa4,0x24,0x81,0xf9,0x74,0x92,0x35,0xf0,0x75,0x14,0x01,0xf5,0x15,0x89,0x16,
+0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xaf,0x82,
+0xf5,0x17,0x8f,0x18,0xe5,0x11,0x75,0xf0,0x09,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,
+0xf0,0x75,0x19,0x01,0xf5,0x1a,0x89,0x1b,0x74,0xc1,0x25,0x11,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0xe0,0x12,0x63,0xc1,0x55,0x6c,0x00,0x55,0x81,0x01,0x55,0x96,0x02,
+0x55,0xab,0x03,0x55,0xd5,0x04,0x55,0xea,0x05,0x55,0xff,0x06,0x56,0x26,0x0c,0x56,
+0x54,0x0d,0x56,0x81,0x0e,0x56,0xae,0x0f,0x00,0x00,0x56,0xe2,0xe5,0x11,0x25,0xe0,
+0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x15,0x80,
+0x3c,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,
+0xf0,0xa3,0x74,0x10,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x05,0x80,0x12,0xe5,0x11,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0xe4,0xf0,0xe5,0x11,
+0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,
+0x8f,0xf0,0x02,0x56,0xe2,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf5,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf0,0x80,0x12,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xa3,0x74,
+0x0d,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0x02,0x56,0xe2,0x90,0x04,0x47,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,
+0x12,0x62,0x95,0x90,0x04,0x46,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,
+0x12,0x62,0xa7,0x90,0x04,0x45,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,
+0x44,0x02,0x56,0xd9,0x90,0x04,0x4b,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,
+0x95,0x90,0x04,0x4a,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,
+0xa7,0x90,0x04,0x49,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x48,0x80,
+0x58,0x90,0x04,0x4f,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0x95,0x90,0x04,
+0x4e,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xa7,0x90,0x04,
+0x4d,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x4c,0x80,0x2b,0x90,0x04,
+0x53,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0x95,0x90,0x04,0x52,0xe0,0xab,
+0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xa7,0x90,0x04,0x51,0xe0,0x85,
+0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x50,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,
+0xa3,0xf0,0xab,0x14,0xaa,0x15,0xa9,0x16,0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x29,
+0xd9,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,0x12,0x29,0xd9,0x5f,0xd0,0x01,0xd0,0x02,
+0xd0,0x03,0x12,0x62,0x95,0xab,0x14,0xe5,0x16,0x24,0x01,0xf9,0xe4,0x35,0x15,0xfa,
+0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x29,0xd9,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,
+0x90,0x00,0x01,0x12,0x62,0x68,0x5f,0xd0,0x01,0xd0,0x02,0xd0,0x03,0x12,0x62,0x95,
+0x85,0x13,0x82,0x85,0x12,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,
+0x17,0x83,0xe0,0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0x85,0x13,0x82,0x85,0x12,
+0x83,0xa3,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,0x17,0x83,0xa3,0xe0,
+0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x4c,0x90,0x97,0x90,0x74,
+0x0b,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x50,0x03,0x02,0x58,0x28,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,
+0xa3,0xe0,0x5f,0x4e,0x60,0x0a,0x90,0x97,0x90,0xe0,0x24,0x10,0xa3,0xf0,0x80,0x68,
+0x90,0x97,0x90,0xe0,0x14,0xf0,0x80,0xba,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0x90,0x97,0x90,0x74,
+0x0f,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x40,0x3c,0x74,0x01,0x7e,0x00,
+0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,
+0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x08,0x90,0x97,0x90,0xe0,0xa3,0xf0,0x80,0x0d,0x90,0x97,0x90,0xe0,0x14,
+0xf0,0x80,0xbf,0xe4,0x90,0x97,0x91,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0xe4,0x90,0x97,0x90,
+0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x10,0x40,0x03,0x02,0x58,0xe2,0x74,0x01,
+0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,
+0xe0,0x5f,0x4e,0x60,0x06,0x90,0x97,0x90,0xe0,0x80,0x63,0x90,0x97,0x90,0xe0,0x04,
+0xf0,0x80,0xbe,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x46,0xe4,0x90,0x97,0x90,0xf0,0x90,0x97,0x90,0xe0,
+0xff,0xc3,0x94,0x0c,0x50,0x3c,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,
+0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x08,0x90,0x97,0x90,
+0xe0,0x24,0x10,0x80,0x09,0x90,0x97,0x90,0xe0,0x04,0xf0,0x80,0xbf,0xe4,0x90,0x97,
+0x92,0xf0,0x90,0x97,0x91,0xe0,0xff,0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x67,0xf5,
+0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xef,0xf0,0x90,0x97,0x92,0xe0,0xfe,0x75,0xf0,
+0x09,0xe5,0x11,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,
+0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0xd3,0x9f,0x40,0x1f,
+0x90,0x97,0x91,0xe0,0xff,0x74,0xc4,0x25,0x11,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xd3,0x94,0x13,0x40,0x08,0x90,0x93,0x62,0x74,0x03,0xf0,0x80,
+0x21,0xef,0xd3,0x94,0x0b,0x40,0x08,0x90,0x93,0x62,0x74,0x02,0xf0,0x80,0x13,0xef,
+0xd3,0x94,0x03,0x40,0x08,0x90,0x93,0x62,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x93,
+0x62,0xf0,0x90,0x93,0x62,0xe0,0x90,0x04,0xb1,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
+0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x7b,0xf0,0x74,0x59,
+0xa3,0xf0,0x90,0x01,0x37,0xe0,0x55,0x2b,0xf5,0x2f,0x90,0x01,0x34,0xe0,0x55,0x28,
+0xf5,0x2c,0x90,0x01,0x36,0xe0,0x55,0x2a,0xf5,0x2e,0xe5,0x2c,0x20,0xe0,0x03,0x02,
+0x5b,0x2d,0x90,0x01,0x34,0x74,0x01,0xf0,0x85,0xd1,0x4d,0x85,0xd2,0x4e,0x85,0xd3,
+0x4f,0x85,0xd4,0x50,0x85,0xd5,0x51,0x85,0xd6,0x52,0x85,0xd7,0x53,0x85,0xd9,0x54,
+0xe5,0x54,0x54,0x40,0xc3,0x13,0xff,0xe5,0x53,0x54,0x20,0x6f,0x70,0x03,0x02,0x5a,
+0xda,0xe5,0x54,0x30,0xe5,0x03,0x02,0x5a,0xda,0xe5,0x52,0x54,0x1f,0xf5,0x08,0xe5,
+0x4d,0x54,0x3f,0xf5,0x09,0xe5,0x51,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0x23,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xc9,0xe5,0x53,0x54,
+0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,
+0x8f,0xf0,0x12,0x62,0xc9,0xe5,0x09,0xd3,0x94,0x04,0x40,0x03,0x75,0x09,0x04,0x75,
+0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0x75,
+0xf0,0x02,0xe5,0x09,0x12,0x63,0xb5,0xe0,0xfe,0xa3,0xe0,0xff,0xe5,0x53,0x54,0x1f,
+0x2f,0xff,0xe4,0x3e,0xfe,0x75,0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,
+0xf0,0x34,0x90,0xf5,0x83,0x75,0xf0,0x02,0xe5,0x09,0x12,0x63,0xb5,0xee,0xf0,0xa3,
+0xef,0xf0,0xe5,0x54,0x20,0xe6,0x24,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,
+0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xc9,0xe5,
+0x4f,0x30,0xe7,0x36,0xaf,0x08,0x12,0x76,0x21,0x80,0x2f,0xe5,0x53,0x54,0x1f,0xff,
+0xe5,0x08,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,
+0x12,0x62,0xc9,0xe5,0x4f,0x30,0xe7,0x12,0xe5,0x4f,0x54,0x7f,0xfd,0xe5,0x53,0x54,
+0x1f,0xf5,0x0d,0xab,0x09,0xaf,0x08,0x12,0x76,0x97,0xe5,0x68,0x60,0x4f,0x90,0x97,
+0xcb,0xe0,0x60,0x35,0x90,0x01,0x5b,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x04,0xf0,0x90,
+0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x34,0x75,0x44,0x14,0xf5,0x45,0xfb,0xfd,
+0x7f,0x58,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5b,0x74,0x05,0xf0,0x90,0x06,0x92,
+0x74,0x01,0xf0,0x90,0x97,0xc6,0xf0,0x80,0x14,0x90,0x04,0x1b,0xe0,0x54,0x7f,0xff,
+0xbf,0x7f,0x0a,0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x2c,0x30,
+0xe1,0x21,0x90,0x01,0x34,0x74,0x02,0xf0,0x85,0xd1,0x56,0x85,0xd2,0x57,0x85,0xd3,
+0x58,0x85,0xd4,0x59,0x85,0xd5,0x5a,0x85,0xd6,0x5b,0x85,0xd7,0x5c,0x85,0xd9,0x5d,
+0x12,0x7d,0x2a,0xe5,0x2c,0x30,0xe3,0x06,0x90,0x01,0x34,0x74,0x08,0xf0,0xe5,0x2c,
+0x30,0xe4,0x09,0x90,0x01,0x34,0x74,0x10,0xf0,0x43,0x55,0x10,0xe5,0x2c,0x30,0xe5,
+0x1d,0x90,0x01,0xcf,0xe0,0x30,0xe5,0x16,0xe0,0x54,0xdf,0xf0,0x90,0x01,0x34,0x74,
+0x20,0xf0,0x90,0x00,0x03,0xe0,0x54,0xfb,0xf0,0x12,0x7e,0xa6,0x80,0xfe,0xe5,0x2c,
+0x30,0xe6,0x06,0x90,0x01,0x34,0x74,0x40,0xf0,0xe5,0x2e,0x30,0xe1,0x09,0x90,0x01,
+0x36,0x74,0x02,0xf0,0x43,0x55,0x40,0xe5,0x2e,0x30,0xe0,0x09,0x90,0x01,0x36,0x74,
+0x01,0xf0,0x12,0x75,0xab,0xe5,0x2e,0x30,0xe2,0x63,0x90,0x01,0x36,0x74,0x04,0xf0,
+0xe5,0x67,0x64,0x01,0x70,0x57,0xe5,0x68,0x60,0x53,0xe5,0x68,0x64,0x02,0x70,0x27,
+0x90,0x06,0xab,0xe0,0x90,0x97,0xbd,0xf0,0x90,0x06,0xaa,0xe0,0x90,0x97,0xc9,0xf0,
+0x90,0x97,0xbd,0xe0,0x70,0x07,0x90,0x97,0xc9,0xe0,0xff,0x80,0x05,0x90,0x97,0xbd,
+0xe0,0xff,0x90,0x97,0xbd,0xef,0xf0,0x90,0x97,0xbf,0xe0,0x60,0x03,0xe0,0x14,0xf0,
+0x90,0x97,0xbe,0xe4,0xf0,0x90,0x01,0x57,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,
+0x97,0xcd,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0xef,0xf0,0x12,0x75,0x32,0xe5,0x2e,0x30,
+0xe3,0x31,0x90,0x01,0x36,0x74,0x08,0xf0,0xe5,0x67,0x64,0x01,0x70,0x25,0xe5,0x68,
+0x60,0x21,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x75,0x44,0x03,
+0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x57,
+0x74,0x05,0xf0,0xe5,0x2e,0x30,0xe4,0x3a,0x90,0x01,0x36,0x74,0x10,0xf0,0xe5,0x67,
+0x64,0x01,0x70,0x2e,0xe5,0x68,0x60,0x2a,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,
+0x74,0x02,0xf0,0x90,0x97,0xcc,0xe4,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xfd,0xf0,0xe0,
+0x54,0x03,0x70,0x0e,0x90,0x97,0xc8,0xf0,0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x12,
+0x6f,0xb5,0xe5,0x2e,0x30,0xe5,0x1f,0x90,0x01,0x36,0x74,0x20,0xf0,0xe5,0x67,0xb4,
+0x01,0x14,0xe5,0x68,0x60,0x10,0x90,0x97,0xcb,0xe0,0x64,0x02,0x60,0x05,0x12,0x7e,
+0x95,0x80,0x03,0x12,0x7b,0x3d,0xe5,0x2e,0x30,0xe6,0x2a,0x90,0x01,0x36,0x74,0x40,
+0xf0,0xe5,0x67,0x64,0x01,0x70,0x1e,0xe5,0x68,0x60,0x1a,0x90,0x97,0xcd,0xe0,0x54,
+0xfe,0xf0,0xe0,0x54,0x03,0x70,0x0e,0x90,0x97,0xc8,0xf0,0x90,0x97,0xca,0xe0,0xff,
+0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x2f,0x30,0xe1,0x09,0x90,0x01,0x37,0x74,0x02,0xf0,
+0x12,0x7c,0x1f,0x74,0x7b,0x04,0x90,0x01,0xc4,0xf0,0x74,0x59,0xa3,0xf0,0xd0,0x07,
+0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,
+0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x90,0x04,0x44,0x74,0x11,0xf0,0xa3,
+0x74,0xf0,0xf0,0xa3,0x74,0x0f,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xff,0xc3,0x94,0x10,0x50,0x14,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x04,
+0xf5,0x83,0xe4,0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x80,0xe2,0xe4,0x90,0x97,0x79,
+0xf0,0x90,0x97,0x79,0xe0,0xfb,0xc3,0x94,0x20,0x40,0x03,0x02,0x5f,0x28,0xe0,0xff,
+0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,
+0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x02,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x04,0xf5,0x82,0xe5,0xf0,
+0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x06,0xf5,
+0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,
+0x24,0x08,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x74,0xc4,
+0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x13,0xf0,0x74,0x84,0x2f,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0x74,0x83,0x2f,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xef,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0x23,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,
+0x64,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0xa4,0x2f,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x90,0x41,0xc4,0x93,0xfe,0x74,0x01,0x93,0xff,
+0x90,0x41,0x8c,0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x6a,0xf5,0x82,0xe5,0xf0,
+0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,
+0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x74,0xc1,0x2b,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0x74,0x0c,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x65,0xf5,0x82,0xe5,
+0xf0,0x34,0x93,0xf5,0x83,0x74,0xff,0xf0,0xa3,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,
+0x63,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0xa3,0x74,0x0f,0xf0,0x75,
+0xf0,0x09,0xeb,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x13,
+0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xe4,0xf0,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0x74,0x13,0xf0,0x90,
+0x97,0x79,0xe0,0x04,0xf0,0x02,0x5d,0x51,0x22,0xa9,0x07,0x74,0x84,0x29,0xf5,0x82,
+0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,0x97,0x92,0xf0,0xe0,0x54,0x1f,0xff,
+0x90,0x97,0x95,0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xf5,0x83,0xe0,0x90,0x97,0x97,0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x67,0xf5,
+0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xfe,0x90,0x97,0x98,0xf0,0xe9,0x25,0xe0,
+0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x99,
+0xcb,0xf0,0xa3,0xeb,0xf0,0xe9,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,
+0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x9b,0xcb,0xf0,0xa3,0xeb,0xf0,0xef,0xd3,0x9e,
+0x40,0x0c,0x90,0x97,0x98,0xe0,0x90,0x97,0x95,0xf0,0x90,0x97,0x92,0xf0,0xed,0x70,
+0x03,0x02,0x60,0x88,0x90,0x97,0x96,0xed,0xf0,0x90,0x97,0x92,0xe0,0x30,0xe6,0x0e,
+0x90,0x97,0x95,0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x96,0xe0,0x14,0xf0,0x90,0x97,
+0x96,0xe0,0x70,0x03,0x02,0x60,0x88,0x90,0x97,0x95,0xe0,0xff,0xd3,0x94,0x00,0x50,
+0x03,0x02,0x60,0x88,0xe4,0x90,0x97,0x94,0xf0,0xef,0x14,0x90,0x97,0x93,0xf0,0x90,
+0x97,0x97,0xe0,0xfd,0x90,0x97,0x93,0xe0,0xff,0xd3,0x9d,0x40,0x6f,0xef,0x94,0x10,
+0x40,0x21,0xef,0x24,0xf0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x9b,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x70,0x27,0x90,0x97,0x93,0xe0,0xff,0xc3,0x94,0x10,0x50,0x37,0x74,0x01,0x7e,
+0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,
+0x99,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x1a,0x90,0x97,0x93,0xe0,0x90,0x97,
+0x92,0xf0,0x90,0x97,0x94,0xe0,0x04,0xf0,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,0x94,
+0xe0,0x6f,0x60,0x08,0x90,0x97,0x93,0xe0,0x14,0xf0,0x80,0x83,0x90,0x97,0x96,0xe0,
+0xff,0x90,0x97,0x94,0xe0,0xc3,0x9f,0x50,0x0f,0x90,0x97,0x93,0xe0,0xb5,0x05,0x08,
+0x90,0x97,0x97,0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x92,0xe0,0xff,0x25,0xe0,0x24,
+0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,
+0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,
+0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xe9,0x25,0xe0,0x25,
+0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0x90,0x97,0x92,
+0xe0,0xff,0x74,0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0x90,
+0x01,0xcc,0xe0,0x54,0x0f,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xfd,0x70,0x03,
+0x02,0x62,0x67,0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,
+0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xef,0x5d,0x70,0x03,0x02,0x62,0x48,
+0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd0,0xf5,0x82,0xe5,0xf0,0x34,0x01,
+0xf5,0x83,0xe0,0x90,0x97,0x7a,0xf0,0x75,0x61,0x01,0x75,0x62,0x97,0x75,0x63,0x7a,
+0x75,0x64,0x01,0x7b,0x01,0x7a,0x97,0x79,0x7b,0x12,0x77,0x5c,0x90,0x97,0x7b,0xe0,
+0xff,0xc4,0x13,0x13,0x13,0x54,0x01,0x90,0x97,0xef,0x30,0xe0,0x70,0xe0,0x75,0xf0,
+0x02,0xa4,0x24,0x88,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,
+0x90,0x97,0xef,0xe0,0x75,0xf0,0x02,0xa4,0x24,0x89,0xf5,0x82,0xe4,0x35,0xf0,0xf5,
+0x83,0xe0,0x90,0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd1,
+0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,
+0x90,0x97,0x7f,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,0x82,
+0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x80,0xf0,0x80,0x42,0xe0,0x75,0xf0,
+0x04,0xa4,0x24,0xd1,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7c,
+0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,
+0x01,0xf5,0x83,0xe0,0x90,0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,
+0x24,0xd3,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0xef,
+0x54,0x7f,0xff,0x7b,0x01,0x7a,0x97,0x79,0x7c,0x12,0x6d,0x5b,0x90,0x97,0x79,0xe0,
+0xff,0x90,0x97,0xef,0xe0,0xfe,0x74,0x01,0xa8,0x06,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0x5f,0x90,0x97,0x79,0xf0,0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0xa8,0x07,
+0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0x90,0x01,0xcc,0xf0,0x90,0x97,0xef,0xe0,0x04,
+0xf0,0xe0,0x54,0x03,0xf0,0x02,0x60,0xe9,0xc2,0xaf,0x74,0xdf,0x04,0x90,0x01,0xc4,
+0xf0,0x74,0x60,0xa3,0xf0,0x90,0x97,0x79,0xe0,0x90,0x01,0xc6,0xf0,0x90,0x97,0xef,
+0xe0,0x90,0x01,0xc7,0xf0,0x80,0xfe,0x22,0xbb,0x01,0x0c,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe0,0x22,0x50,0x06,0xe9,0x25,0x82,0xf8,0xe6,0x22,0xbb,
+0xfe,0x06,0xe9,0x25,0x82,0xf8,0xe2,0x22,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe4,0x93,0x22,0xbb,0x01,0x06,0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x02,
+0xf7,0x22,0xbb,0xfe,0x01,0xf3,0x22,0xf8,0xbb,0x01,0x0d,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0x22,0x50,0x06,0xe9,0x25,0x82,0xc8,0xf6,0x22,
+0xbb,0xfe,0x05,0xe9,0x25,0x82,0xc8,0xf2,0x22,0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,
+0xc5,0xf0,0xf8,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,
+0xf8,0xe0,0xc5,0xf0,0x25,0xf0,0xf0,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,
+0xc8,0x38,0xf0,0xe8,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,
+0xe0,0x22,0x50,0x06,0x87,0xf0,0x09,0xe7,0x19,0x22,0xbb,0xfe,0x07,0xe3,0xf5,0xf0,
+0x09,0xe3,0x19,0x22,0x89,0x82,0x8a,0x83,0xe4,0x93,0xf5,0xf0,0x74,0x01,0x93,0x22,
+0xbb,0x01,0x10,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,
+0xa3,0xe0,0x22,0x50,0x09,0xe9,0x25,0x82,0xf8,0x86,0xf0,0x08,0xe6,0x22,0xbb,0xfe,
+0x0a,0xe9,0x25,0x82,0xf8,0xe2,0xf5,0xf0,0x08,0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,
+0xe9,0x93,0xf5,0xf0,0xa3,0xe9,0x93,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xf0,
+0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x06,0xf7,0x09,0xa7,0xf0,0x19,0x22,0xbb,0xfe,0x06,
+0xf3,0xe5,0xf0,0x09,0xf3,0x19,0x22,0xf8,0xbb,0x01,0x11,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x09,0xe9,0x25,
+0x82,0xc8,0xf6,0x08,0xa6,0xf0,0x22,0xbb,0xfe,0x09,0xe9,0x25,0x82,0xc8,0xf2,0xe5,
+0xf0,0x08,0xf2,0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,
+0xe8,0x9c,0x45,0xf0,0x22,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,
+0x22,0xd0,0x83,0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,0x01,0x93,0x70,0x0d,0xa3,
+0xa3,0x93,0xf8,0x74,0x01,0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x02,0x93,0x68,
+0x60,0xef,0xa3,0xa3,0xa3,0x80,0xdf,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,
+0xe9,0xf0,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x04,
+0x12,0x62,0x68,0xff,0x54,0x1f,0x90,0x97,0x87,0xf0,0x90,0x00,0x03,0x12,0x62,0x68,
+0x54,0xf0,0xc4,0x54,0x0f,0x90,0x97,0x88,0xf0,0xef,0x54,0x20,0xc4,0x13,0x54,0x07,
+0xa3,0xf0,0x90,0x00,0x04,0x12,0x62,0x68,0x54,0x40,0xc4,0x13,0x13,0x54,0x03,0x90,
+0x97,0x8a,0xf0,0x90,0x97,0x87,0xe0,0xff,0x75,0xf0,0x09,0xa4,0x24,0x65,0xf5,0x82,
+0xe5,0xf0,0x34,0x93,0xad,0x82,0x90,0x97,0x8b,0xf0,0xa3,0xed,0xf0,0xef,0x75,0xf0,
+0x09,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,0xf0,0xfa,0xa3,0x74,0x01,0xf0,0xa3,0xea,
+0xf0,0xa3,0xe9,0xf0,0x90,0x97,0x84,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x03,
+0x12,0x62,0x68,0x54,0x0f,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0xef,0x12,0x62,0x95,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x90,0x00,0x02,0x12,0x62,0x68,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xf9,0x90,0x00,0x01,0xef,0x12,0x62,0xa7,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x62,0x68,0xff,0x90,0x97,0x8b,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xf5,0x82,0x8c,0x83,0xef,0xf0,0x12,0x29,0xd9,0x8d,0x82,0x8c,0x83,
+0xa3,0xf0,0x90,0x97,0x88,0xe0,0xfe,0x90,0x97,0x87,0xe0,0xff,0x24,0xc1,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x89,0xe0,0xfe,0x75,0xf0,0x09,0xef,
+0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,0x75,0xf0,0x09,
+0xef,0xa4,0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x90,
+0x97,0x8a,0xe0,0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xf5,0x83,0xee,0xf0,0x02,0x54,0xea,0x90,0x00,0x02,0x12,0x62,0x68,0x90,0x97,
+0xa9,0xf0,0x90,0x00,0x01,0x12,0x62,0x68,0x25,0xe0,0x25,0xe0,0x90,0x97,0xa8,0xf0,
+0x12,0x29,0xd9,0x25,0xe0,0x25,0xe0,0x90,0x97,0xac,0xf0,0x90,0x05,0x60,0xe0,0x90,
+0x97,0xb7,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,0xf0,0x90,0x05,0x62,0xe0,0x90,
+0x97,0xb9,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0xba,0xf0,0xa2,0xaf,0xe4,0x33,0x90,
+0x97,0x84,0xf0,0xc2,0xaf,0x90,0x97,0xa8,0xe0,0xff,0x12,0x78,0x71,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x90,0x97,0xa9,0xe0,0x70,0x03,0x02,0x66,0x35,0x90,0x97,
+0xa8,0xe0,0x70,0x03,0x02,0x66,0x35,0x90,0x97,0xac,0xe0,0x70,0x03,0x02,0x66,0x35,
+0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,0xc2,0xaf,0x90,0x97,0xbb,0x74,0x01,0xf0,
+0x90,0x97,0x84,0xe0,0x24,0xff,0x92,0xaf,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,
+0xe0,0x44,0x01,0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,
+0x7e,0x08,0x12,0x2f,0xd9,0x80,0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x00,0x45,
+0xe0,0x54,0xef,0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,
+0x05,0x84,0xf0,0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,
+0x05,0x86,0xf0,0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,0xa2,0xaf,0xe4,0x33,0x90,
+0x97,0x84,0xf0,0xc2,0xaf,0x90,0x01,0x3c,0xe0,0x44,0x20,0xf0,0x7d,0x20,0xe4,0xff,
+0x12,0x37,0x00,0x80,0x2b,0x90,0x97,0xa9,0xe0,0x70,0x2d,0x90,0x97,0xbb,0xf0,0x90,
+0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,0xe0,0x54,0xfe,0xf0,0x90,0x05,0x22,0xe4,0xf0,
+0xa2,0xaf,0x33,0x90,0x97,0x84,0xf0,0xc2,0xaf,0x7d,0x20,0xe4,0xff,0x12,0x36,0x92,
+0x90,0x97,0x84,0xe0,0x24,0xff,0x92,0xaf,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,
+0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,
+0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x69,0xf0,0x74,0x66,0xa3,0xf0,
+0x53,0x91,0xdf,0x90,0x01,0x3c,0xe0,0x55,0x30,0xf5,0x34,0xa3,0xe0,0x55,0x31,0xf5,
+0x35,0xa3,0xe0,0x55,0x32,0xf5,0x36,0xe5,0x34,0x30,0xe0,0x0f,0x90,0x01,0x3c,0x74,
+0x01,0xf0,0x90,0x01,0x53,0x74,0x07,0xf0,0x43,0x55,0x80,0xe5,0x34,0x30,0xe1,0x09,
+0x90,0x01,0x3c,0x74,0x02,0xf0,0x12,0x79,0xeb,0xe5,0x34,0x30,0xe2,0x3a,0x90,0x01,
+0x3c,0x74,0x04,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe0,0x1e,0x75,0x44,0x14,0x75,0x45,
+0x00,0xe4,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5b,0x74,0x05,
+0xf0,0x90,0x06,0x92,0x74,0x01,0xf0,0x80,0x0f,0x90,0x97,0xc6,0xe4,0xf0,0x90,0x97,
+0xca,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x34,0x30,0xe3,0x3a,0x90,0x01,0x3c,
+0x74,0x08,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe1,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,
+0xe4,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5f,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x02,0xf0,0x80,0x0f,0x90,0x97,0xc5,0xe4,0xf0,0x90,0x97,0xca,
+0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x34,0x30,0xe4,0x09,0x90,0x01,0x3c,0x74,
+0x10,0xf0,0x12,0x7a,0xbc,0xe5,0x34,0x30,0xe5,0x09,0x90,0x01,0x3c,0x74,0x20,0xf0,
+0x12,0x6e,0xf1,0xe5,0x35,0x30,0xe0,0x15,0x90,0x01,0x3d,0x74,0x01,0xf0,0x90,0x00,
+0x83,0xe0,0x90,0x97,0xca,0xf0,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0x74,0x69,0x04,
+0x90,0x01,0xc4,0xf0,0x74,0x66,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,
+0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,
+0xd0,0xe0,0x32,0xe4,0x90,0x97,0x76,0xf0,0xa3,0xf0,0x12,0x79,0x5c,0x90,0x00,0x02,
+0xe0,0x54,0xe0,0x90,0x97,0xd4,0x60,0x05,0x74,0x01,0xf0,0x80,0x03,0x74,0x02,0xf0,
+0x90,0x00,0xf3,0xe0,0x30,0xe3,0x08,0x90,0x97,0xd5,0x74,0x01,0xf0,0x80,0x05,0xe4,
+0x90,0x97,0xd5,0xf0,0x90,0x97,0xd5,0xe0,0xb4,0x01,0x13,0x90,0x00,0xf2,0xe0,0x30,
+0xe7,0x0c,0x90,0x97,0xce,0x74,0xfd,0xf0,0xa3,0x74,0x33,0xf0,0x80,0x0a,0x90,0x97,
+0xce,0x74,0xfd,0xf0,0xa3,0x74,0x2f,0xf0,0xe4,0xf5,0x55,0x12,0x5d,0x19,0x12,0x44,
+0xfa,0x12,0x78,0xc3,0x12,0x32,0x3d,0x12,0x7f,0x3a,0x12,0x7d,0xad,0x90,0x00,0xf3,
+0xe0,0x30,0xe2,0x0d,0x90,0x05,0x41,0x74,0x10,0xf0,0x90,0x05,0x5a,0xf0,0xa3,0xe4,
+0xf0,0x90,0x01,0x64,0x74,0xa0,0xf0,0x75,0x44,0xff,0xe4,0xf5,0x45,0xfb,0x7d,0x01,
+0x7f,0x50,0x7e,0x01,0x12,0x35,0xab,0x12,0x7e,0x56,0x12,0x78,0x1a,0x90,0x97,0x78,
+0xe5,0xd9,0xf0,0x12,0x7e,0x6e,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x40,0xf0,0x12,
+0x7e,0xa6,0x75,0xe8,0x03,0x43,0xa8,0x85,0xd2,0xaf,0x90,0x01,0xc0,0xe4,0xf0,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x01,0xc6,0xf0,0xa3,0xf0,0x90,0x97,0x76,0xe0,0x64,
+0x01,0xf0,0x24,0xa3,0x90,0x01,0xc4,0xf0,0x74,0x67,0xa3,0xf0,0xe5,0x55,0x30,0xe6,
+0x17,0xc2,0xaf,0x53,0x55,0xbf,0xd2,0xaf,0x12,0x45,0x09,0x90,0x97,0xab,0xe0,0xff,
+0x60,0x03,0xb4,0x01,0x03,0x12,0x68,0xc1,0xe5,0x55,0x30,0xe7,0x07,0xc2,0xaf,0x53,
+0x55,0x7f,0xd2,0xaf,0xe5,0x55,0x30,0xe4,0x0a,0xc2,0xaf,0x53,0x55,0xef,0xd2,0xaf,
+0x12,0x60,0xdf,0x90,0x97,0xab,0xe0,0x70,0x03,0x12,0x6b,0xac,0x12,0x7c,0xaa,0x80,
+0xaa,0x90,0x97,0xa2,0xe0,0xc3,0x94,0x14,0x50,0x06,0xe0,0x04,0xf0,0x02,0x69,0x7b,
+0x90,0x97,0xa2,0xe0,0x64,0x14,0x60,0x03,0x02,0x69,0x7b,0x90,0x97,0xb1,0xe0,0x70,
+0x25,0x90,0x97,0xb4,0xe0,0x70,0x1f,0x90,0x97,0xb2,0xe0,0x70,0x19,0x90,0x97,0xb5,
+0xe0,0x70,0x13,0x90,0x97,0xb3,0xe0,0x70,0x0d,0x90,0x97,0xb6,0xe0,0x70,0x07,0x90,
+0x04,0xfd,0xe0,0x54,0xfe,0xf0,0x90,0x97,0xb1,0xe0,0x90,0x04,0x44,0xf0,0x90,0x97,
+0xb2,0xe0,0x90,0x04,0x45,0xf0,0x90,0x97,0xb3,0xe0,0x90,0x04,0x46,0xf0,0xa3,0xe4,
+0xf0,0x90,0x97,0xb4,0xe0,0x90,0x04,0x48,0xf0,0x90,0x97,0xb5,0xe0,0x90,0x04,0x49,
+0xf0,0x90,0x97,0xb6,0xe0,0x90,0x04,0x4a,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x9d,0xe0,
+0x90,0x07,0x00,0xf0,0x90,0x97,0x9e,0xe0,0x90,0x07,0x01,0xf0,0x90,0x97,0x9f,0xe0,
+0x90,0x07,0x02,0xf0,0x90,0x97,0xa0,0xe0,0x90,0x07,0x03,0xf0,0xe4,0x90,0x97,0xa2,
+0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,0xb1,
+0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x05,0x60,0xe0,0x90,
+0x97,0x79,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0x7a,0xf0,0x90,0x05,0x62,0xe0,0x90,
+0x97,0x7b,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xba,0xe0,0xff,
+0x90,0x97,0x7c,0xe0,0xfe,0xd3,0x9f,0x50,0x0b,0x90,0x97,0xba,0xe0,0xc3,0x9e,0xd3,
+0x94,0x01,0x40,0x11,0x90,0x97,0xa8,0xe0,0xb4,0x01,0x02,0x80,0x03,0x90,0x97,0xac,
+0xe0,0xff,0x12,0x78,0x71,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0xee,
+0xed,0xf0,0x90,0x97,0xed,0xef,0xf0,0xd3,0x94,0x07,0x50,0x65,0xe0,0xff,0x74,0x01,
+0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,
+0xf0,0x12,0x7e,0xa6,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x46,0xe0,0x4f,0xf0,0x12,0x7e,0xa6,0x90,0x97,
+0xee,0xe0,0x60,0x16,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x45,0x80,0x70,0x90,0x97,0xed,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x45,0x80,
+0x75,0x90,0x97,0xed,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,
+0x12,0x7e,0xa6,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,
+0x33,0xd8,0xfc,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7e,0xa6,0x90,0x97,0xee,
+0xe0,0x60,0x1b,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,
+0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x42,0xe0,0x4f,0x80,0x1a,0x90,0x97,
+0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,
+0xf0,0xf4,0xff,0x90,0x00,0x42,0xe0,0x5f,0xf0,0x12,0x7e,0xa6,0xd0,0xd0,0x92,0xaf,
+0x22,0x7f,0x78,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x5d,0x12,0x2a,0x7f,0x7f,0x04,
+0x7e,0x0c,0x12,0x27,0xde,0x90,0x97,0x61,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,0x12,
+0x27,0xde,0x90,0x97,0x65,0x12,0x2a,0x7f,0x90,0x97,0xd5,0xe0,0x90,0x97,0x5d,0xb4,
+0x01,0x13,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xc7,0xff,0xed,
+0x54,0xc7,0xfd,0x80,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,
+0xc7,0xff,0xec,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x78,0x7e,0x08,0x12,0x2f,0xd9,
+0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0x0f,0xff,
+0xec,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,0x2f,0xd9,0x90,0x97,
+0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x02,0xff,0xec,0x90,
+0x80,0x85,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,0x12,0x2f,0xd9,0x7f,0x70,0x7e,0x0e,
+0x12,0x27,0xde,0x90,0x97,0x69,0x12,0x2a,0x7f,0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,
+0x1b,0x25,0xa0,0x7f,0x70,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x59,0x12,0x2a,0x8b,
+0x00,0x00,0x00,0x00,0xe4,0xfd,0xff,0x12,0x34,0x81,0x90,0x97,0xd5,0xe0,0xb4,0x01,
+0x11,0x90,0x80,0x59,0x12,0x2a,0x8b,0x00,0x00,0x00,0x00,0xe4,0xfd,0x7f,0x01,0x12,
+0x34,0x81,0x90,0x00,0x11,0xe0,0x54,0xf6,0xf0,0x02,0x7e,0xa6,0x90,0x97,0xbb,0xe0,
+0x64,0x01,0x60,0x09,0x90,0x97,0xa9,0xe0,0x60,0x03,0x02,0x6c,0x84,0x90,0x97,0x9d,
+0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x3b,0x90,0x97,0x9e,0xe0,0xc3,
+0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x28,0x90,0x97,0x9f,0xe0,0xc3,0x94,
+0xff,0x50,0x0a,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9e,0xf0,0x80,0x15,0x90,0x97,0xa0,
+0xe0,0xc3,0x94,0xff,0x50,0x10,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9f,0xf0,0x90,0x97,
+0x9e,0xf0,0x90,0x97,0x9d,0xf0,0x90,0x00,0x44,0xe0,0x54,0x0c,0x60,0x76,0xe0,0x30,
+0xe2,0x32,0x90,0x97,0xb1,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,
+0x90,0x97,0xb2,0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,
+0x97,0xb3,0xe0,0xc3,0x94,0xff,0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb2,0xf0,
+0x90,0x97,0xb1,0xf0,0x90,0x00,0x44,0xe0,0x30,0xe3,0x32,0x90,0x97,0xb4,0xe0,0xc3,
+0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,0x90,0x97,0xb5,0xe0,0xc3,0x94,0xff,
+0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,0x97,0xb6,0xe0,0xc3,0x94,0xff,0x50,
+0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb4,0xf0,0x90,0x04,0xfd,
+0xe0,0x44,0x01,0xf0,0x22,0x8b,0x11,0x8a,0x12,0x89,0x13,0x90,0x00,0x02,0x12,0x62,
+0x68,0x90,0x97,0xaa,0xf0,0xe0,0x30,0xe0,0x5c,0x90,0x97,0xa1,0x74,0x01,0xf0,0x7f,
+0x80,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xa3,0x12,0x2a,0x7f,0xab,0x11,0xaa,0x12,
+0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x68,0xff,0xe4,0xfc,0xfd,0xfe,0x78,0x1a,0x12,
+0x2a,0x6c,0xa8,0x04,0xa9,0x05,0xaa,0x06,0xab,0x07,0x90,0x97,0xa3,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xec,0x54,0x03,0xfc,0xeb,0x4f,0xff,0xea,
+0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,0x4c,0xfc,0x90,0x97,0xad,0x12,0x2a,0x7f,0x90,0x05,
+0x22,0xe4,0xf0,0x80,0x35,0xe4,0x90,0x97,0xa1,0xf0,0x7f,0x80,0x7e,0x08,0x12,0x27,
+0xde,0xec,0x54,0x03,0xfc,0xec,0x44,0xc0,0xfc,0x90,0x97,0xa3,0x12,0x2a,0x7f,0x90,
+0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0xaa,0xe0,0x90,0x00,
+0x47,0x30,0xe1,0x11,0x74,0x0c,0xf0,0xa3,0xe0,0x44,0x0c,0xf0,0x90,0x00,0x46,0xe0,
+0x44,0x10,0xf0,0x80,0x10,0xe0,0x54,0xf3,0xf0,0xa3,0xe0,0x54,0xf3,0xf0,0x90,0x00,
+0x46,0xe0,0x54,0xef,0xf0,0xe4,0x90,0x97,0xa7,0xf0,0x22,0x90,0x97,0x81,0xeb,0xf0,
+0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xef,0x12,0x63,0xc1,0x6d,0x8c,0x01,0x6d,0x9a,0x02,
+0x6d,0xa8,0x03,0x6d,0xb6,0x05,0x6d,0xc4,0x06,0x6d,0xd2,0x07,0x6d,0xe0,0x09,0x6d,
+0xee,0x0c,0x6d,0xfc,0x0d,0x6e,0x0a,0x0e,0x00,0x00,0x6e,0x18,0x90,0x97,0x81,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x6e,0x90,0x97,0x81,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7f,0x34,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xf9,0x02,0x7c,0x4e,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0x02,0x7c,0xd7,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,
+0x63,0xe7,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7e,0xee,
+0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x73,0x0d,0x90,0x97,
+0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x65,0x28,0x90,0x97,0x81,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7c,0x7c,0x90,0x97,0x81,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x6c,0x85,0xc2,0xaf,0x74,0x5b,0x04,0x90,0x01,0xc4,
+0xf0,0x74,0x6d,0xa3,0xf0,0x80,0xfe,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,
+0x8a,0xed,0xf0,0x90,0x97,0x89,0xef,0xf0,0xd3,0x94,0x07,0x50,0x4f,0xa3,0xe0,0x70,
+0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,0xf0,0x80,0x17,0x90,0x97,0x89,0xe0,0xff,
+0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x47,0xe0,
+0x4f,0xf0,0x12,0x7e,0xa6,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0x80,0x5a,0x90,0x97,0x89,0xe0,
+0x24,0xf8,0xf0,0xa3,0xe0,0x70,0x1d,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,
+0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,
+0x5f,0xf0,0x80,0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7e,
+0xa6,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7e,0xa6,0xd0,0xd0,0x92,0xaf,
+0x22,0x90,0x97,0xa9,0xe0,0x64,0x01,0x60,0x03,0x02,0x6f,0xb4,0x90,0x00,0x46,0xe0,
+0x44,0x01,0xf0,0x90,0x97,0xbb,0xe0,0x70,0x40,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,
+0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x80,0x06,0x90,0x05,0x22,0x74,
+0x7f,0xf0,0x90,0x97,0xa8,0xe0,0xff,0x12,0x78,0x71,0x90,0x97,0xbb,0x74,0x01,0xf0,
+0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0x80,0x44,0x90,0x97,0xbb,0xe0,0x64,0x01,0x70,
+0x3c,0x90,0x97,0xac,0xe0,0xff,0x12,0x78,0x71,0xe4,0x90,0x97,0xbb,0xf0,0x90,0x00,
+0x45,0xe0,0x44,0x01,0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xa3,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,
+0x80,0x7e,0x08,0x12,0x2f,0xd9,0x80,0x05,0x90,0x05,0x22,0xe4,0xf0,0x90,0x05,0x87,
+0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,0xf0,0x90,0x97,0xb8,0xe0,
+0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,0xf0,0x90,0x97,0xba,0xe0,
+0x90,0x05,0x87,0xf0,0x22,0x8f,0x65,0x8d,0x66,0xe5,0x65,0x54,0x0f,0xff,0x90,0x97,
+0xc7,0xe0,0x54,0x0f,0x6f,0x60,0x78,0xe5,0x65,0x30,0xe2,0x30,0x90,0x97,0xc7,0xe0,
+0x20,0xe2,0x05,0x7f,0x01,0x12,0x7d,0x8e,0x90,0x97,0xc7,0xe0,0x30,0xe3,0x0a,0xe5,
+0x65,0x20,0xe3,0x05,0x12,0x7d,0xcb,0x80,0x56,0x90,0x97,0xc7,0xe0,0x20,0xe3,0x4f,
+0xe5,0x65,0x30,0xe3,0x4a,0xaf,0x66,0x12,0x7d,0x4e,0x80,0x43,0x90,0x97,0xc7,0xe0,
+0x54,0x0f,0xff,0xbf,0x0c,0x0e,0xe5,0x65,0x20,0xe3,0x09,0x12,0x7d,0x03,0xef,0x60,
+0x2e,0x12,0x7d,0xcb,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xff,0xbf,0x04,0x0e,0xe5,0x65,
+0x20,0xe2,0x09,0x12,0x7b,0x7b,0xef,0x60,0x16,0x12,0x7b,0xb3,0x90,0x97,0xc7,0xe0,
+0x54,0x0f,0xff,0xbf,0x02,0x09,0x12,0x7a,0xff,0xef,0x60,0x03,0x12,0x7d,0xe8,0x90,
+0x97,0xc7,0xe0,0x54,0x0f,0xff,0x90,0x97,0xca,0xe0,0x54,0x0f,0x6f,0x70,0x23,0xe0,
+0x30,0xe6,0x1f,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xff,0x90,0x97,0xbc,0xe0,0xfe,0x4f,
+0x90,0x01,0x2f,0xf0,0xee,0x64,0x80,0x90,0x97,0xbc,0xf0,0x90,0x97,0xca,0xe0,0x54,
+0xbf,0xf0,0x22,0x90,0x97,0xdc,0xef,0xf0,0xa3,0xed,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,
+0xe5,0x68,0x60,0x05,0xe4,0xff,0x12,0x7e,0x22,0x90,0x97,0xdc,0xe0,0x30,0xe0,0x09,
+0x90,0x97,0xde,0xe4,0xf0,0xa3,0x74,0x80,0xf0,0x90,0x04,0x1d,0xe0,0x60,0x1d,0x90,
+0x05,0x22,0xe0,0x90,0x97,0xe0,0xf0,0xe0,0xff,0x54,0x90,0x60,0xec,0x90,0x01,0xc8,
+0x74,0xfc,0xf0,0xef,0x54,0x6f,0x90,0x05,0x22,0xf0,0x80,0xdd,0x90,0x97,0xdc,0xe0,
+0xff,0xc3,0x13,0x90,0xfd,0x10,0xf0,0x90,0x04,0x25,0xef,0xf0,0x90,0x97,0xdd,0xe0,
+0x60,0x1f,0xa3,0xa3,0xe0,0xff,0x24,0x0f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,
+0x44,0x80,0xf0,0x74,0x10,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x44,0x80,
+0xf0,0x90,0x97,0xde,0xa3,0xe0,0xff,0xfd,0x24,0x08,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe4,0xf0,0x74,0x09,0x2d,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xf0,
+0xf0,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xf7,0xf0,0x90,
+0x97,0xde,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,
+0x97,0xf3,0xef,0xf0,0xd3,0x94,0x07,0x50,0x47,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0xe0,0x5f,0xf0,0x12,0x7e,
+0xa6,0x90,0x97,0xf3,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x44,0xe0,0xfb,0xe4,0xfe,0xef,0x5b,
+0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,0x80,0x4c,
+0x90,0x97,0xf3,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7e,0xa6,0x90,
+0x97,0xf3,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,0x05,0xc3,0x33,0xce,
+0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x42,0xe0,0xfb,0xe4,0xfe,0xef,0x5b,0xa8,0x05,
+0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,0xd0,0xd0,0x92,0xaf,
+0x22,0x90,0x00,0x11,0xe0,0x44,0x09,0xf0,0x12,0x7e,0xa6,0x90,0x97,0x5d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,
+0x78,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,0x2f,
+0xd9,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x80,0x85,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x69,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,
+0x7f,0x70,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x59,0x12,0x2a,0x8b,0x00,0x03,0x2d,
+0x95,0xe4,0xfd,0xff,0x12,0x34,0x81,0x90,0x97,0xd5,0xe0,0xb4,0x01,0x11,0x90,0x80,
+0x59,0x12,0x2a,0x8b,0x00,0x03,0x2d,0x95,0xe4,0xfd,0x7f,0x01,0x12,0x34,0x81,0x22,
+0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0x70,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,
+0xe9,0xf0,0x90,0x97,0xd4,0xe0,0x64,0x02,0x60,0x7e,0x90,0x01,0xaf,0xe0,0x60,0x09,
+0x90,0x01,0xc7,0xe0,0x04,0xf0,0xf0,0x80,0xf1,0x90,0x97,0xf1,0xe0,0xff,0x04,0xf0,
+0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0xef,0x12,
+0x62,0xa7,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x61,0x8a,0x62,
+0xf5,0x63,0x75,0x64,0x02,0x7b,0x01,0x7a,0x01,0x79,0xa0,0x12,0x77,0x5c,0x90,0x97,
+0x73,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x61,0x8a,0x62,0xf5,0x63,0x90,0x97,
+0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x12,0x29,0xd9,0xff,0xc4,0x54,0x0f,
+0xf5,0x64,0x7b,0x01,0x7a,0x01,0x79,0xa2,0x12,0x77,0x5c,0x90,0x01,0xaf,0x74,0xff,
+0xf0,0x90,0x01,0xcb,0xe0,0x64,0x80,0xf0,0xd0,0xd0,0x92,0xaf,0x22,0xd3,0x10,0xaf,
+0x01,0xc3,0xc0,0xd0,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,
+0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,0x20,
+0xfa,0xe5,0xf0,0x24,0x00,0xff,0xe4,0x3a,0xfe,0x90,0x97,0x84,0xa3,0xe0,0xfa,0x90,
+0x00,0x01,0xee,0x8f,0xf0,0x12,0x63,0x77,0x12,0x29,0xd9,0xff,0x60,0x37,0xb5,0x22,
+0x1b,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,
+0x63,0x20,0x65,0x24,0x70,0x04,0xe5,0x23,0x65,0xf0,0x60,0x2e,0x90,0x97,0x84,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,0x20,0xff,0xae,0xf0,
+0x12,0x7a,0x31,0x80,0x15,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x12,0x29,0xd9,0x65,0x22,0x60,0x03,0x12,0x7f,0x1c,0xd0,0xd0,0x92,0xaf,0x22,0xef,
+0x60,0x34,0x7d,0x7d,0x7f,0x02,0x12,0x36,0x75,0x7d,0x02,0x7f,0x03,0x12,0x36,0x75,
+0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x7d,0x01,0x7f,0x0c,0x12,
+0x6f,0xb5,0xe4,0xff,0x12,0x7e,0x22,0x90,0x06,0x04,0xe0,0x54,0x7f,0xf0,0x90,0x06,
+0x0a,0xe0,0x54,0xf8,0xf0,0x22,0x90,0x01,0x36,0x74,0x7d,0xf0,0xa3,0x74,0x02,0xf0,
+0x7d,0x7d,0xff,0x12,0x36,0xe6,0x7d,0x02,0x7f,0x03,0x12,0x36,0xe6,0x90,0x06,0x04,
+0xe0,0x44,0x80,0xf0,0x90,0x06,0x0a,0xe0,0x44,0x07,0xf0,0x90,0x97,0xc2,0xe0,0xa3,
+0xe0,0x90,0x05,0x58,0xf0,0xe5,0x67,0x30,0xe0,0x1b,0x90,0x97,0xbf,0xe0,0x70,0x1a,
+0xe0,0x04,0xf0,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x0c,0x7d,0x01,
+0x7f,0x04,0x02,0x6f,0xb5,0xe4,0x90,0x97,0xbf,0xf0,0x22,0xef,0x14,0x60,0x20,0x14,
+0x60,0x4b,0x24,0x02,0x70,0x78,0x90,0x97,0xa7,0x74,0x02,0xf0,0x90,0x00,0x48,0xe0,
+0x44,0x0c,0xf0,0x90,0x00,0x47,0xe0,0x44,0x08,0xf0,0x90,0x00,0x45,0x80,0x5b,0xe4,
+0x90,0x97,0xa7,0xf0,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x90,
+0x00,0x45,0xe0,0x44,0xef,0xf0,0xe0,0x54,0xef,0xf0,0xa3,0x80,0x2d,0x90,0x97,0xa7,
+0x74,0x01,0xf0,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x00,
+0x45,0xe0,0x44,0x20,0xf0,0xe0,0x44,0x10,0xf0,0xa3,0xe0,0x44,0x10,0xf0,0x22,0x02,
+0x74,0xed,0x02,0x67,0xa3,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0x40,0x03,0xf6,0x80,
+0x01,0xf2,0x08,0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,0xf8,0x54,0x07,0x24,0x0c,0xc8,
+0xc3,0x33,0xc4,0x54,0x0f,0x44,0x20,0xc8,0x83,0x40,0x04,0xf4,0x56,0x80,0x01,0x46,
+0xf6,0xdf,0xe4,0x80,0x0b,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x90,0x7e,0xd4,
+0xe4,0x7e,0x01,0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,0x30,0xe5,0x09,0x54,0x1f,0xfe,
+0xe4,0x93,0xa3,0x60,0x01,0x0e,0xcf,0x54,0xc0,0x25,0xe0,0x60,0xa8,0x40,0xb8,0xe4,
+0x93,0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,
+0x83,0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xdf,0xe9,0xde,0xe7,
+0x80,0xbe,0x90,0x06,0xa9,0xe0,0xf5,0x0a,0x54,0xc0,0x70,0x0e,0x90,0x97,0xc8,0xf0,
+0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x02,0x6f,0xb5,0xe5,0x0a,0x30,0xe6,0x1f,0x90,
+0x97,0xc8,0x74,0x01,0xf0,0x90,0x97,0xcd,0xe0,0x44,0x01,0xf0,0x90,0x97,0xcb,0xe0,
+0x64,0x02,0x60,0x05,0x12,0x7e,0x95,0x80,0x0c,0x12,0x7b,0x3d,0x80,0x07,0x90,0x97,
+0xcd,0xe0,0x54,0xfe,0xf0,0xe5,0x0a,0x30,0xe7,0x29,0x90,0x97,0xc8,0x74,0x01,0xf0,
+0x90,0x97,0xcd,0xe0,0x44,0x02,0xf0,0x75,0x44,0x03,0xe4,0xf5,0x45,0xfb,0xfd,0x7f,
+0x54,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,0xcc,0x74,
+0x01,0xf0,0x22,0x90,0x97,0xcd,0xe0,0x54,0xfd,0xf0,0x22,0xe4,0x90,0x97,0x6e,0xf0,
+0xe5,0x68,0x60,0x6c,0xe5,0x67,0x64,0x01,0x70,0x66,0xe5,0x68,0x64,0x02,0x60,0x06,
+0xe5,0x68,0x64,0x03,0x70,0x1d,0x90,0x97,0xbd,0xe0,0x14,0xf0,0xe0,0x60,0x04,0xa3,
+0xe0,0x60,0x16,0x90,0x97,0xbd,0xe0,0x70,0x0a,0x90,0x97,0xc9,0xe0,0x90,0x97,0xbd,
+0xf0,0x80,0x00,0x90,0x97,0x6e,0x74,0x01,0xf0,0x90,0x97,0x6e,0xe0,0x60,0x31,0x90,
+0x97,0xcd,0xe0,0x44,0x10,0xf0,0x90,0x97,0xc4,0xe0,0xf5,0x44,0xe4,0xf5,0x45,0xfb,
+0xfd,0x7f,0x54,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,
+0xc7,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xb5,
+0x22,0xab,0x07,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,
+0xf5,0x83,0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x54,
+0x1f,0xfa,0xd3,0x9f,0x40,0x02,0xaa,0x07,0xea,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xea,0x25,0xe0,0x24,0x66,
+0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,
+0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,
+0x04,0xf5,0x83,0xea,0xf0,0xff,0x22,0x8d,0x0b,0xe5,0x0b,0x54,0x1f,0xf5,0x0f,0x74,
+0x01,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xf5,0x0e,0x90,0x04,0xfd,0xe0,
+0xb4,0x01,0x05,0x75,0x10,0x03,0x80,0x03,0x75,0x10,0x01,0xeb,0xc3,0x95,0x10,0x40,
+0x03,0x02,0x76,0x21,0xe5,0x0e,0x25,0x0d,0xfe,0xe5,0x0f,0x90,0x41,0xd6,0x93,0xfd,
+0xee,0xd3,0x9d,0x74,0x01,0x40,0x18,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,
+0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe5,0x0b,0xf0,0x22,0x2f,
+0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x22,0x8e,0x11,0x8f,0x12,0x8b,0x13,
+0x8a,0x14,0x89,0x15,0xe4,0x90,0x97,0x79,0xf0,0xef,0x90,0x00,0x31,0xf0,0x12,0x7e,
+0xa6,0xe5,0x11,0x54,0x03,0xff,0x90,0x00,0x32,0xe0,0x54,0xfc,0x4f,0xf0,0x12,0x7e,
+0xa6,0x90,0x00,0x33,0xe0,0x54,0x7f,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x33,0xe0,0x20,
+0xe7,0x0e,0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x05,0xe0,0x04,0xf0,0x80,0xeb,
+0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x10,0x90,0x00,0x30,0xe0,0xab,0x13,0xaa,
+0x14,0xa9,0x15,0x12,0x62,0x95,0x7f,0x01,0x22,0x7f,0x00,0x22,0xd3,0x10,0xaf,0x01,
+0xc3,0xc0,0xd0,0x8b,0x5e,0x8a,0x5f,0x89,0x60,0x90,0x97,0xd6,0xeb,0xf0,0xa3,0xea,
+0xf0,0xa3,0xe9,0xf0,0xa3,0xe5,0x61,0xf0,0xa3,0xe5,0x62,0xf0,0xa3,0xe5,0x63,0xf0,
+0xaf,0x64,0x15,0x64,0xef,0x60,0x2a,0x90,0x97,0xd9,0xe0,0xfb,0xa3,0xe4,0x75,0xf0,
+0x01,0x12,0x62,0xdf,0xa9,0xf0,0xfa,0x12,0x29,0xd9,0xff,0x90,0x97,0xd6,0xe0,0xfb,
+0xa3,0xe4,0x75,0xf0,0x01,0x12,0x62,0xdf,0xa9,0xf0,0xfa,0xef,0x12,0x62,0x95,0x80,
+0xcf,0xab,0x5e,0xaa,0x5f,0xa9,0x60,0xd0,0xd0,0x92,0xaf,0x22,0x8b,0x11,0x8a,0x12,
+0x89,0x13,0x12,0x7e,0x83,0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x29,0xd9,0xf5,0x68,
+0x14,0x60,0x0e,0x14,0x60,0x0f,0x14,0x60,0x1a,0x24,0x03,0x70,0x3c,0x7f,0x01,0x80,
+0x35,0xe4,0xff,0x80,0x31,0x90,0x97,0xc9,0x74,0x01,0xf0,0x90,0x97,0xbd,0xf0,0xe4,
+0xff,0x80,0x23,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x68,0xff,
+0x90,0x97,0xc9,0x70,0x05,0x74,0x05,0xf0,0x80,0x02,0xef,0xf0,0x90,0x97,0xc9,0xe0,
+0x90,0x97,0xbd,0xf0,0xe4,0xff,0x12,0x73,0x9f,0x22,0x90,0x00,0x45,0xe4,0xf0,0x90,
+0x04,0xfd,0xf0,0xa3,0xf0,0x90,0x97,0xab,0xf0,0x90,0x97,0xb1,0xf0,0x90,0x97,0xb4,
+0xf0,0x90,0x97,0xb2,0xf0,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb3,0xf0,0x90,0x97,0xb6,
+0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,0xa2,
+0xf0,0x90,0x97,0xa7,0xf0,0x90,0x97,0xa9,0xf0,0x90,0x97,0xbb,0xf0,0x90,0x97,0xac,
+0xf0,0x90,0x97,0xa8,0xf0,0x90,0x97,0xa1,0xf0,0x90,0x00,0x51,0xe0,0x44,0xc0,0xf0,
+0x22,0x90,0x05,0x60,0xe0,0x90,0x97,0xb7,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,
+0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0xb9,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0xba,
+0xf0,0xc3,0x74,0xff,0x9f,0xfe,0x90,0x97,0xb8,0xe0,0xd3,0x9e,0x40,0x1e,0xe0,0x2f,
+0xf0,0xa3,0xe0,0xb4,0xff,0x0f,0xe4,0xf0,0xa3,0xe0,0xb4,0xff,0x03,0xe4,0xf0,0x22,
+0x90,0x97,0xba,0x80,0x03,0x90,0x97,0xb9,0xe0,0x04,0xf0,0x22,0x90,0x97,0xb8,0xe0,
+0x2f,0xf0,0x22,0xe4,0xf5,0x67,0x90,0x97,0xcd,0xf0,0xf5,0x68,0x90,0x97,0xca,0x74,
+0x0c,0xf0,0x90,0x97,0xc7,0xf0,0xe4,0x90,0x97,0xcb,0xf0,0x90,0x97,0xc6,0xf0,0x90,
+0x97,0xc5,0xf0,0x90,0x97,0xc9,0x04,0xf0,0x90,0x97,0xbd,0xf0,0xe4,0x90,0x97,0xcc,
+0xf0,0x90,0x97,0xc8,0xf0,0x90,0x97,0xbf,0xf0,0x90,0x97,0xc4,0x74,0x07,0xf0,0xe4,
+0x90,0x97,0xbe,0xf0,0x90,0x97,0xc2,0xf0,0xa3,0x74,0x02,0xf0,0xe4,0x90,0x97,0xc1,
+0xf0,0x22,0x90,0x00,0x2b,0xe0,0x44,0x01,0xf0,0x7f,0xe8,0x7e,0x03,0x12,0x37,0x54,
+0x90,0x00,0x08,0xe0,0x44,0x10,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x09,0xe0,0x54,0xf7,
+0xf0,0x12,0x7e,0xa6,0x90,0x00,0x28,0xe0,0x54,0xfe,0xf0,0x12,0x7e,0xa6,0x90,0x00,
+0x20,0xe0,0x54,0xfe,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x25,0xe0,0x44,0x40,0xf0,0x12,
+0x7e,0xa6,0x90,0x00,0x09,0xe0,0x54,0xef,0xf0,0x02,0x7e,0xa6,0xe4,0x90,0x97,0xd3,
+0xf0,0xa2,0xaf,0x33,0x90,0x97,0x7a,0xf0,0x90,0x00,0x80,0xe0,0x20,0xe1,0x1a,0x12,
+0x37,0x7a,0x12,0x37,0x7a,0x90,0x97,0x79,0xe0,0x64,0x01,0xf0,0xe0,0x24,0x5c,0x90,
+0x01,0xc4,0xf0,0x74,0x79,0xa3,0xf0,0x80,0xdf,0x90,0x06,0x30,0x74,0x01,0xf0,0xc2,
+0xaf,0x90,0x00,0x80,0xe0,0x44,0x80,0xf0,0x12,0x7e,0xa6,0x90,0x97,0x7a,0xe0,0x24,
+0xff,0x92,0xaf,0x22,0x90,0x00,0x25,0xe0,0x54,0xbf,0xf0,0x12,0x7e,0xa6,0x90,0x00,
+0x20,0xe0,0x44,0x01,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x28,0xe0,0x44,0x01,0xf0,0x12,
+0x7e,0xa6,0x90,0x00,0xf0,0xe0,0x30,0xe1,0xf9,0x90,0x00,0x09,0xe0,0x44,0x08,0xf0,
+0x12,0x7e,0xa6,0x90,0x00,0x08,0xe0,0x54,0xef,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x2b,
+0xe0,0x54,0xfe,0xf0,0x7f,0xe8,0x7e,0x03,0x02,0x37,0x54,0x90,0x97,0xcc,0xe0,0x60,
+0x12,0xe4,0xf0,0xa3,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0x03,0x70,0x33,0x90,0x97,0xc8,
+0xf0,0x80,0x23,0x90,0x97,0xbe,0xe0,0x04,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xef,0xf0,
+0x90,0x97,0xbe,0xe0,0xd3,0x94,0x01,0x40,0x0d,0xe5,0x67,0xb4,0x01,0x12,0xa3,0xe0,
+0x70,0x0e,0xe0,0x04,0xf0,0x22,0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,
+0x22,0x90,0x97,0x87,0xee,0xf0,0xa3,0xef,0xf0,0x75,0x22,0x01,0x8e,0x23,0xf5,0x24,
+0xe4,0xfd,0x7f,0x0b,0x12,0x6e,0x27,0xe4,0xfd,0x7f,0x02,0x12,0x6e,0x27,0x12,0x7e,
+0x05,0xe4,0xff,0x12,0x7e,0xe1,0xe4,0xf5,0x26,0x90,0x01,0xc9,0xe5,0x26,0xf0,0x90,
+0x97,0x87,0xe0,0xfc,0xa3,0xe0,0xfd,0xec,0xfb,0x8d,0x44,0xe4,0xf5,0x45,0x7d,0x01,
+0x7f,0x60,0x7e,0x01,0x02,0x35,0xab,0xe4,0x90,0x97,0xeb,0xf0,0xa3,0xf0,0x90,0x05,
+0xf8,0xe0,0x70,0x0f,0xa3,0xe0,0x70,0x0b,0xa3,0xe0,0x70,0x07,0xa3,0xe0,0x70,0x03,
+0x7f,0x01,0x22,0xd3,0x90,0x97,0xec,0xe0,0x94,0xe8,0x90,0x97,0xeb,0xe0,0x94,0x03,
+0x40,0x03,0x7f,0x00,0x22,0x7f,0x32,0x7e,0x00,0x12,0x37,0x54,0x90,0x97,0xec,0xe0,
+0x04,0xf0,0x70,0xca,0x90,0x97,0xeb,0xe0,0x04,0xf0,0x80,0xc2,0xe5,0x22,0x64,0x01,
+0x70,0x3c,0x12,0x7e,0x05,0xbf,0x01,0x05,0x7f,0x01,0x12,0x7e,0xe1,0x90,0x00,0x46,
+0xe0,0x44,0x04,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x44,0xe0,0x54,0xfb,0xf0,0x12,0x7e,
+0xa6,0x90,0x00,0x46,0xe0,0x54,0xfb,0xf0,0x12,0x7e,0xa6,0x7f,0x02,0x12,0x71,0x28,
+0x8f,0x26,0x90,0x01,0xc9,0xe5,0x26,0xf0,0xb4,0x01,0x03,0x12,0x7e,0x3d,0x22,0xe5,
+0x55,0x70,0x37,0x90,0x97,0xca,0xe0,0x54,0x0f,0xd3,0x94,0x01,0x50,0x2c,0x90,0x02,
+0x87,0xe0,0x70,0x26,0x90,0x97,0xd4,0xe0,0xb4,0x02,0x10,0x90,0x97,0xce,0xe0,0xfe,
+0xa3,0xe0,0xf5,0x82,0x8e,0x83,0xe0,0x60,0x08,0x80,0x0f,0x90,0x01,0xaf,0xe0,0x70,
+0x09,0x90,0x97,0xc1,0xe0,0x60,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x01,0x5f,
+0xe4,0xf0,0x90,0x01,0x3c,0x74,0x08,0xf0,0x75,0x44,0x14,0xe4,0xf5,0x45,0xfb,0xfd,
+0x7f,0x5c,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5f,0x74,0x05,0xf0,0x90,0x06,0x92,
+0x74,0x02,0xf0,0x90,0x97,0xc5,0x14,0xf0,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xc3,0x94,
+0x0c,0x50,0x07,0x7d,0x01,0x7f,0x0c,0x12,0x6f,0xb5,0x22,0x90,0x04,0x1b,0xe0,0x54,
+0x7f,0x64,0x7f,0x70,0x2b,0x90,0x97,0xc8,0xe0,0x64,0x01,0x60,0x23,0x90,0x97,0xca,
+0xe0,0x54,0x0f,0xd3,0x94,0x02,0x50,0x18,0x90,0x97,0xcd,0xe0,0x20,0xe4,0x11,0x90,
+0x97,0xc6,0xe0,0x64,0x01,0x60,0x09,0x90,0x97,0xbf,0xe0,0x70,0x03,0x7f,0x01,0x22,
+0x7f,0x00,0x22,0x90,0x01,0x37,0x74,0x02,0xf0,0x90,0x05,0x22,0x74,0xff,0xf0,0x12,
+0x7a,0x77,0xef,0x70,0x06,0x90,0x01,0xc8,0x74,0xfd,0xf0,0x7d,0x02,0x7f,0x03,0x12,
+0x36,0xe6,0xe5,0x68,0x60,0x05,0x7f,0x01,0x12,0x7e,0x22,0x12,0x6a,0xc1,0x90,0x97,
+0xc7,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x8f,0x27,0x90,0x97,0xd2,0xe0,
+0xff,0x7d,0x01,0x12,0x70,0x73,0xe5,0x27,0x60,0x10,0x74,0x21,0x2f,0xf5,0x82,0xe4,
+0x34,0xfc,0xf5,0x83,0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,0xf5,0x82,0xe4,
+0x34,0xfc,0xf5,0x83,0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x7d,
+0x02,0x7f,0x03,0x12,0x36,0x75,0xe5,0x68,0x60,0x23,0x90,0x97,0xcb,0xe0,0x60,0x06,
+0x7d,0x01,0x7f,0x0c,0x80,0x0f,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,
+0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xb5,0xe4,0xff,0x12,0x7e,0x22,0x22,0x90,0x02,
+0x09,0xe0,0xfd,0x12,0x29,0xd9,0xfe,0xaf,0x05,0xed,0x2e,0x90,0x97,0xd0,0xf0,0x90,
+0x00,0x01,0x12,0x62,0x68,0xff,0xed,0x2f,0x90,0x97,0xd1,0xf0,0x90,0x00,0x02,0x12,
+0x62,0x68,0xff,0xae,0x05,0xed,0x2f,0x90,0x97,0xd2,0xf0,0x22,0x90,0x00,0x02,0x12,
+0x62,0x68,0x90,0x97,0xab,0xf0,0xe0,0x60,0x04,0xe0,0xb4,0xff,0x1c,0xa2,0xaf,0xe4,
+0x33,0xf5,0x11,0xc2,0xaf,0x90,0x00,0x47,0xe0,0x54,0xfb,0xf0,0x7d,0x40,0x7f,0x01,
+0x12,0x36,0xaf,0xe5,0x11,0x24,0xff,0x92,0xaf,0x22,0x90,0x06,0x34,0xe0,0x60,0x26,
+0x14,0x70,0x1b,0x7b,0x01,0x7a,0x06,0x79,0x35,0x7f,0xf9,0x7e,0x01,0x12,0x76,0xfa,
+0xbf,0x01,0x09,0x90,0x06,0x35,0xe0,0x54,0x0f,0xf0,0x80,0x05,0x80,0x00,0x02,0x7e,
+0xc6,0xe4,0x90,0x06,0x34,0xf0,0x22,0x12,0x29,0xd9,0xff,0xc3,0x94,0x20,0x50,0x14,
+0x90,0x00,0x02,0x12,0x62,0x68,0xfe,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,
+0x83,0xee,0xf0,0x22,0xef,0xb4,0x20,0x0a,0x90,0x00,0x02,0x12,0x62,0x68,0x90,0x93,
+0x61,0xf0,0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,0xff,0xbf,0x7f,0x1a,0x90,0x97,0xc6,
+0xe0,0x70,0x14,0x90,0x97,0xc5,0xe0,0x70,0x0e,0x90,0x97,0xca,0xe0,0x54,0x0f,0xd3,
+0x94,0x04,0x50,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x97,0x6e,0xe0,0x54,0xf0,
+0x44,0x03,0xf0,0x54,0x0f,0x44,0x80,0xf0,0x90,0x97,0x73,0xe4,0xf0,0xa3,0x74,0x00,
+0xf0,0xa3,0x74,0x56,0xf0,0x7b,0x01,0x7a,0x97,0x79,0x6e,0x02,0x72,0x70,0x90,0x06,
+0x04,0xe0,0x54,0xbf,0xf0,0xef,0x60,0x0a,0xe5,0x67,0xb4,0x01,0x05,0xe4,0xff,0x12,
+0x7b,0xea,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x0c,0xf0,0x22,0xd3,0x10,
+0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x00,0x01,0x12,0x62,0x68,0x90,0x97,0xcb,0xf0,0x12,
+0x29,0xd9,0x65,0x68,0x60,0x03,0x12,0x77,0xbc,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x97,
+0xf0,0xef,0xf0,0x12,0x71,0xd1,0x90,0x97,0xf0,0xe0,0x60,0x05,0x90,0x05,0x22,0xe4,
+0xf0,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x75,0x28,0x33,
+0xe4,0xf5,0x29,0x75,0x2a,0x02,0xf5,0x2b,0x90,0x01,0x30,0xe5,0x28,0xf0,0xa3,0xe5,
+0x29,0xf0,0xa3,0xe5,0x2a,0xf0,0xa3,0xe5,0x2b,0xf0,0x22,0x90,0x06,0x04,0xe0,0x44,
+0x40,0xf0,0xe5,0x67,0xb4,0x01,0x05,0x7f,0x01,0x12,0x7b,0xea,0x90,0x97,0xc7,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,0xe0,
+0x44,0x01,0xf0,0x12,0x79,0x12,0x12,0x79,0xa4,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,
+0xe0,0x44,0x02,0xf0,0x22,0x7f,0x0b,0x12,0x71,0x28,0xef,0x65,0x25,0x60,0x10,0xe5,
+0x25,0xb4,0x01,0x05,0xe4,0xf5,0x25,0x80,0x03,0x75,0x25,0x01,0x7f,0x01,0x22,0x7f,
+0x00,0x22,0xef,0x60,0x0b,0x90,0x97,0xd5,0xe0,0xb4,0x01,0x10,0xe4,0xff,0x80,0x09,
+0x90,0x97,0xd5,0xe0,0xb4,0x01,0x05,0x7f,0x01,0x12,0x4e,0x3f,0x22,0x90,0x00,0x49,
+0xe0,0x90,0x97,0xf2,0xf0,0xe0,0x54,0x0f,0xf0,0xe0,0xff,0x44,0xf0,0x90,0x00,0x49,
+0xf0,0xef,0x44,0xb0,0xf0,0x22,0x75,0x30,0x1f,0x75,0x31,0x01,0xe4,0xf5,0x32,0x90,
+0x01,0x38,0xe5,0x30,0xf0,0xa3,0xe5,0x31,0xf0,0xa3,0xe5,0x32,0xf0,0x22,0x90,0x01,
+0x3c,0x74,0xff,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x01,0x34,0xf0,0xa3,0xf0,0xa3,0xf0,
+0xa3,0xf0,0x22,0xe4,0x90,0x97,0xcc,0xf0,0x90,0x97,0xbe,0xf0,0x90,0x97,0xc8,0xf0,
+0x90,0x97,0xcd,0xf0,0x22,0x90,0x97,0xd1,0xe0,0xff,0xe4,0xfd,0x12,0x70,0x73,0x90,
+0x04,0x1f,0x74,0x01,0xf0,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x7f,0x10,0xdf,
+0xfe,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x09,0x28,0xef,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x06,0x34,0x74,0xff,0xf0,0xe4,0xa3,0xf0,0xa3,
+0xf0,0xa3,0xf0,0x22,0x41,0x97,0xef,0x00,0x41,0x97,0xbc,0x80,0x41,0x97,0xf1,0x00,
+0x00,0x90,0x01,0xca,0xe5,0x25,0xf0,0xef,0x60,0x03,0x12,0x7e,0x3d,0x22,0x90,0x97,
+0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x22,0x90,0x97,0xe5,0xeb,0xf0,0xa3,
+0xea,0xf0,0xa3,0xe9,0xf0,0x22,0x90,0x97,0xe8,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,
+0xf0,0x22,0x8f,0x82,0x8e,0x83,0xa3,0xa3,0xa3,0xe4,0xf0,0x22,0xe4,0xf5,0x22,0x7f,
+0x60,0x7e,0x01,0x02,0x7f,0x12,0x8f,0x1c,0x8c,0x1d,0x8d,0x1e,0x22,0x8f,0x1f,0x8c,
+0x20,0x8d,0x21,0x22,0x12,0x29,0xd9,0xf5,0x67,0x22,0xe4,0xf5,0x25,0x22,0x22,0x00,
+0x96,0x5a,
+};
+#endif
+#if 1
+// =================== UMC A Cut V68.1 2011-02-24 =====================
+u8 Rtl8192CUFwUMCACutImgArray[UMCACutImgArrayLength] = {
+0xc1,0x88,0x02,0x00,0x44,0x00,0x01,0x00,0x02,0x23,0x15,0x24,0xc0,0x3f,0x01,0x00,
+0x92,0x52,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x02,0x74,0xa5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x59,0x7b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x44,0x6c,0x00,0x00,0x00,0x00,0x00,0x02,0x66,0x96,0x00,0x00,
+0x05,0x04,0x03,0x02,0x00,0x03,0x06,0x05,0x04,0x03,0x00,0x04,0x06,0x05,0x04,0x02,
+0x00,0x04,0x08,0x07,0x06,0x04,0x00,0x06,0x0a,0x09,0x08,0x06,0x00,0x08,0x0a,0x09,
+0x08,0x04,0x00,0x08,0x0a,0x09,0x08,0x02,0x00,0x08,0x0a,0x09,0x08,0x00,0x00,0x08,
+0x12,0x11,0x10,0x08,0x00,0x10,0x1a,0x19,0x18,0x10,0x00,0x18,0x22,0x21,0x20,0x18,
+0x00,0x20,0x22,0x21,0x20,0x10,0x00,0x20,0x22,0x21,0x20,0x08,0x00,0x20,0x22,0x21,
+0x1c,0x08,0x00,0x20,0x22,0x21,0x14,0x08,0x00,0x20,0x22,0x20,0x18,0x08,0x00,0x20,
+0x31,0x30,0x20,0x10,0x00,0x30,0x31,0x30,0x18,0x00,0x00,0x30,0x31,0x2f,0x10,0x10,
+0x00,0x30,0x31,0x2c,0x10,0x10,0x00,0x30,0x31,0x28,0x10,0x00,0x00,0x30,0x31,0x20,
+0x10,0x00,0x00,0x30,0x31,0x10,0x10,0x00,0x00,0x30,0x04,0x04,0x04,0x05,0x04,0x04,
+0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,
+0x05,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x07,0x0a,0x0b,
+0x0d,0x10,0x04,0x05,0x05,0x06,0x06,0x09,0x0c,0x11,0x08,0x08,0x09,0x09,0x0a,0x0c,
+0x10,0x11,0x04,0x04,0x04,0x05,0x04,0x04,0x05,0x07,0x07,0x07,0x08,0x0a,0x04,0x04,
+0x04,0x04,0x06,0x0a,0x0b,0x0d,0x05,0x05,0x07,0x07,0x08,0x0b,0x0d,0x0f,0x04,0x04,
+0x04,0x05,0x07,0x07,0x09,0x09,0x0c,0x0e,0x10,0x12,0x04,0x04,0x05,0x05,0x06,0x0a,
+0x11,0x13,0x09,0x09,0x09,0x09,0x0c,0x0e,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x24,0x26,0x2a,0x18,0x1a,0x1d,0x1f,0x21,0x27,0x29,0x2a,0x00,0x00,
+0x00,0x1f,0x23,0x28,0x2a,0x2c,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x18,
+0x00,0x24,0x00,0x30,0x00,0x48,0x00,0x60,0x00,0x90,0x00,0xc0,0x00,0xd8,0x00,0x50,
+0x00,0x78,0x00,0xa0,0x00,0xc8,0x01,0x40,0x01,0x90,0x01,0xe0,0x02,0x30,0x01,0x2c,
+0x01,0x40,0x01,0xe0,0x02,0xd0,0x03,0xe8,0x04,0xb0,0x06,0x40,0x07,0xd0,0x00,0x02,
+0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x0c,0x00,0x12,0x00,0x18,0x00,0x24,0x00,0x30,
+0x00,0x48,0x00,0x60,0x00,0x6c,0x00,0x28,0x00,0x3c,0x00,0x50,0x00,0x64,0x00,0xa0,
+0x00,0xc8,0x00,0xf0,0x01,0x18,0x00,0x64,0x00,0xa0,0x00,0xf0,0x01,0x68,0x01,0xf4,
+0x02,0x58,0x03,0x20,0x03,0xe8,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x04,0x04,
+0x05,0x07,0x04,0x04,0x07,0x0a,0x0a,0x0c,0x0c,0x12,0x05,0x07,0x07,0x08,0x0b,0x12,
+0x24,0x3c,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x01,0x02,
+0x03,0x04,0x05,0x06,0x07,0x08,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x20,0x1e,
+0x1c,0x18,0x10,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xab,0x07,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,
+0x97,0x92,0xf0,0xe0,0x54,0x1f,0xa3,0xf0,0xfa,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xf9,0x90,0x97,0x95,0xf0,0xeb,0x25,
+0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,
+0x96,0xcf,0xf0,0xa3,0xef,0xf0,0xeb,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,0x98,0xcf,0xf0,0xa3,0xef,0xf0,0xea,0x25,
+0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x25,0x08,0xea,0xc3,0x99,0x40,0x03,0x02,0x43,0x59,0x90,0x97,0x93,
+0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0xef,0x04,
+0x90,0x97,0x94,0xf0,0x90,0x97,0x95,0xe0,0xff,0x90,0x97,0x94,0xe0,0xfe,0xd3,0x9f,
+0x40,0x03,0x02,0x43,0x9c,0xee,0xc3,0x94,0x10,0x40,0x21,0xee,0x24,0xf0,0xff,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0x90,0x97,0x96,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,0x90,0x97,0x94,0xe0,
+0xff,0xc3,0x94,0x10,0x50,0x4a,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x98,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x2d,0x90,0x97,0x94,0xe0,0xff,0x64,0x13,0x60,0x09,0xef,0x64,0x12,0x60,
+0x04,0xef,0xb4,0x11,0x0d,0x90,0x97,0x96,0xe0,0x30,0xe0,0x06,0x90,0x97,0x94,0x74,
+0x18,0xf0,0x90,0x97,0x94,0xe0,0x90,0x97,0x93,0xf0,0x90,0x97,0x92,0xf0,0x80,0x4c,
+0x90,0x97,0x94,0xe0,0x04,0xf0,0x02,0x42,0xc4,0x90,0x97,0x95,0xe0,0xfa,0x90,0x97,
+0x93,0xe0,0xff,0x6a,0x70,0x7d,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0xe0,0xb4,0x01,0x11,0x90,0x97,0x92,0xe0,0x20,0xe6,0x0a,0xa3,0xe0,0x44,0x40,
+0x90,0x97,0x92,0xf0,0x80,0x06,0x90,0x97,0x92,0xe0,0xff,0x22,0x90,0x97,0x93,0xe0,
+0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,
+0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,
+0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,
+0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x25,
+0x08,0x80,0x69,0x90,0x97,0x93,0xe0,0xd3,0x9a,0x40,0x61,0x90,0x97,0x95,0xe0,0xff,
+0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x93,0xef,
+0xf0,0x90,0x97,0x92,0xf0,0xfa,0xa3,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,
+0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,
+0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x25,0x08,0xaf,0x02,0x22,0x74,0x01,0x2b,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x92,0xe0,0x44,0x80,0xff,0x74,
+0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,
+0xc0,0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,
+0x03,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x6c,0xf0,0x74,
+0x44,0xa3,0xf0,0x53,0x91,0xef,0x90,0x00,0x51,0xe0,0xff,0x90,0x00,0x55,0xe0,0x5f,
+0xf5,0x3d,0xe5,0x3d,0x30,0xe6,0x18,0x74,0x40,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,
+0xff,0xbf,0x03,0x0b,0x90,0x97,0xa7,0xe0,0x60,0x05,0x7f,0x01,0x12,0x74,0x21,0xe5,
+0x3d,0x30,0xe7,0x15,0x90,0x00,0x55,0x74,0x80,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,
+0xff,0xbf,0x03,0x05,0x7f,0x02,0x12,0x74,0x21,0x90,0x01,0xc4,0x74,0x6c,0xf0,0x74,
+0x44,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,
+0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0xe4,0xf5,
+0x25,0x22,0x22,0x02,0x7f,0xaa,0x02,0x7f,0xb1,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xff,0xc3,0x94,0x20,0x40,0x03,0x02,0x4e,0x3e,0x75,0xf0,0x09,0xef,0xa4,
+0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x4e,0x35,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,0x00,0xec,0x94,0x00,0x50,0x03,0x02,0x4e,0x35,
+0xef,0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf9,0x74,0x90,0x35,0xf0,0xfa,0x7b,0x01,0x8b,
+0x14,0xf5,0x15,0x89,0x16,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,
+0x34,0x91,0xf5,0x83,0xe0,0xfd,0xa3,0xe0,0x90,0x97,0x85,0xcd,0xf0,0xa3,0xed,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0xff,0xa3,0xe0,
+0x90,0x97,0x87,0xcf,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x02,0x12,0x63,0x4d,0xff,0xae,
+0xf0,0x12,0x63,0x22,0x2f,0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8e,0xf0,0xa3,0xef,0xf0,
+0x90,0x00,0x06,0x12,0x63,0x4d,0xff,0xae,0xf0,0x90,0x00,0x04,0x12,0x63,0x4d,0x2f,
+0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8c,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x08,0x12,0x63,
+0x4d,0xff,0x90,0x97,0x8a,0xe5,0xf0,0xf0,0xa3,0xef,0xf0,0x90,0x97,0x79,0xe0,0xfe,
+0x24,0x84,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x3f,0x90,0x97,0x7b,0xf0,
+0xe0,0xfd,0x54,0x1f,0xa3,0xf0,0x75,0xf0,0x09,0xee,0xa4,0x24,0x67,0xf5,0x82,0xe5,
+0xf0,0x34,0x93,0xf5,0x83,0xe0,0x90,0x97,0x90,0xf0,0x90,0x97,0x79,0xe0,0xfb,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xc3,0x94,0x05,0x40,0x03,0x02,0x49,
+0xba,0x90,0x97,0x90,0xe0,0xfe,0x90,0x97,0x7c,0xe0,0x9e,0x40,0x13,0x90,0x97,0x90,
+0xe0,0x90,0x97,0x7c,0xf0,0xed,0x54,0x40,0xfd,0x90,0x97,0x7b,0xf0,0xee,0x4d,0xf0,
+0x90,0x04,0xfd,0xe0,0x64,0x01,0x70,0x28,0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,
+0x93,0xfe,0x74,0x63,0x2b,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,
+0x06,0xef,0x90,0x40,0xda,0x80,0x32,0x90,0x97,0x7c,0xe0,0x90,0x40,0xf6,0x80,0x29,
+0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,0x93,0xfe,0x90,0x97,0x79,0xe0,0x24,0x63,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,0x06,0xef,0x90,0x41,0x12,
+0x80,0x07,0x90,0x97,0x7c,0xe0,0x90,0x41,0x2e,0x93,0x90,0x97,0x89,0xf0,0x90,0x97,
+0x89,0xe0,0x75,0xf0,0x06,0xa4,0x24,0x50,0xf9,0x74,0x40,0x35,0xf0,0x75,0x11,0xff,
+0xf5,0x12,0x89,0x13,0x90,0x97,0x7b,0xe0,0x90,0x41,0xf2,0x93,0xff,0xd3,0x90,0x97,
+0x88,0xe0,0x9f,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x0d,0x90,0x97,0x79,0xe0,0xff,
+0xe4,0xfd,0x12,0x5f,0x56,0x02,0x4d,0xcb,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,
+0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,0xf8,0xa3,
+0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x24,0x62,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,
+0xa9,0x16,0x12,0x63,0x22,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,
+0xaa,0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,
+0x15,0xa9,0x16,0x90,0x00,0x02,0x12,0x63,0x4d,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,
+0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,
+0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,
+0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,
+0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xff,0x7e,
+0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x04,0x12,0x63,0x4d,0xfd,0xac,0xf0,
+0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,
+0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x03,0x12,
+0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x06,0x12,0x63,
+0x4d,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,
+0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,
+0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,
+0x90,0x00,0x04,0x12,0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,
+0x00,0x08,0x12,0x63,0x4d,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,
+0x05,0x12,0x62,0x95,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,
+0x24,0x7b,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,0x90,0x97,0x7d,0x40,0x50,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0xab,
+0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x05,0x12,0x62,0x95,0xff,0x7e,0x00,0x90,0x97,
+0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x24,0x7b,0xab,0x07,0xaa,0x06,0xd0,0x07,0xd0,
+0x06,0xd0,0x05,0xd0,0x04,0xc3,0xef,0x9b,0xff,0xee,0x9a,0xfe,0xed,0x94,0x00,0xfd,
+0xec,0x94,0x00,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x80,0x07,0x12,0x25,0x14,0x00,
+0x00,0x00,0x00,0x90,0x97,0x7d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x25,0x08,0x90,0x97,0x7b,0xe0,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,
+0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,
+0x40,0x0b,0x90,0x97,0x79,0xe0,0xff,0x12,0x42,0x20,0x02,0x4d,0x99,0x90,0x97,0x7b,
+0xe0,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,
+0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xc3,0x12,0x63,0xd1,0x40,0x03,0x02,0x4d,0x99,0x90,0x97,0x79,
+0xe0,0xff,0x7d,0x01,0x12,0x5f,0x56,0x02,0x4d,0x99,0x90,0x97,0x79,0xe0,0xff,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x64,0x05,0x60,0x03,0x02,0x4b,0xb6,
+0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,
+0x64,0x01,0x70,0x03,0x02,0x4b,0xb6,0x90,0x93,0x62,0xe0,0xff,0xb4,0x03,0x0b,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x19,0x40,0x3d,0x80,0x2e,0xef,0xb4,0x02,0x0b,0x90,0x97,
+0x7c,0xe0,0xc3,0x94,0x11,0x40,0x2e,0x80,0x1f,0x90,0x93,0x62,0xe0,0xff,0xb4,0x01,
+0x0b,0x90,0x97,0x7c,0xe0,0xc3,0x94,0x0a,0x40,0x1b,0x80,0x0c,0xef,0x70,0x11,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x03,0x40,0x0d,0x90,0x95,0x83,0x74,0x01,0xf0,0x80,0x05,
+0xe4,0x90,0x95,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0x83,0xf5,0x82,0xe4,0x34,
+0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe0,0xff,0xc3,0x94,0x30,0x50,0x03,0x02,0x4b,0x44,0x90,0x95,0x83,0xe0,
+0x64,0x01,0x60,0x03,0x02,0x4b,0x44,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,0xe4,
+0x34,0x95,0xf5,0x83,0xe0,0x64,0x0a,0x60,0x56,0x90,0x97,0x79,0xe0,0xfe,0xef,0x24,
+0x05,0xfd,0xe4,0x33,0xfc,0x74,0x21,0x2e,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,
+0xff,0xd3,0x9d,0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x33,0xef,0x24,0x05,0xfd,
+0xe4,0x33,0xfc,0x74,0x63,0x2e,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xd3,0x9d,
+0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x16,0x90,0x97,0x79,0xe0,0x24,0xc4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xff,0x90,0x97,0x7c,0xe0,0x6f,0x60,0x56,0x90,
+0x97,0x79,0xe0,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xff,0xd3,0x94,
+0x42,0x40,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x11,0xef,0xd3,0x94,0x39,0x90,
+0x97,0x91,0x40,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0x90,0x97,0x79,0xe0,
+0xff,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xfe,0x74,0x21,0x2f,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,
+0xe4,0x34,0x95,0x80,0x2f,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,
+0x04,0xf0,0x80,0x14,0xe4,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0x24,0xa4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x7c,0xe0,0xff,0x90,0x97,0x79,
+0xe0,0xfe,0x24,0xc4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x91,
+0xe0,0xff,0x74,0x83,0x2e,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,
+0xe0,0x1e,0xef,0xc4,0x54,0xf0,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,
+0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x02,0x4d,0x7c,
+0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,
+0xe0,0x54,0xf0,0x02,0x4d,0x7c,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x96,0xf5,0x83,0xe0,0x64,0x06,0x60,0x03,0x02,0x4d,0x99,0x75,0xf0,0x09,0xef,
+0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x70,0x03,
+0x02,0x4d,0x99,0x90,0x97,0x7d,0x12,0x25,0x14,0x00,0x00,0x00,0x00,0x90,0x42,0x13,
+0xe4,0x93,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x24,0x7b,
+0xe4,0xfc,0xfd,0x90,0x97,0x81,0x12,0x25,0x08,0x90,0x97,0x79,0xe0,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0xe4,0x90,0x97,0x7a,0xf0,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x97,0x7a,0xe0,
+0xff,0x75,0xf0,0x02,0xa4,0xf5,0x82,0x85,0xf0,0x83,0x12,0x63,0x4d,0xfd,0xac,0xf0,
+0xef,0x90,0x42,0x0e,0x93,0xff,0x7e,0x00,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x81,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,0x50,0x0e,0x90,0x97,0x7a,0xe0,0x04,0xf0,
+0xe0,0x64,0x05,0x60,0x03,0x02,0x4c,0x20,0x90,0x97,0x7a,0xe0,0xc3,0x13,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xb4,0x01,0x0d,0x90,0x97,0x7a,0xe0,0x70,0x5d,0x90,0x97,0x91,
+0x04,0xf0,0x80,0x5b,0xef,0xb4,0x03,0x1d,0x90,0x97,0x7a,0xe0,0xff,0x70,0x08,0x90,
+0x97,0x91,0x74,0x03,0xf0,0x80,0x48,0xef,0xb4,0x01,0x08,0x90,0x97,0x91,0x74,0x01,
+0xf0,0x80,0x3c,0x80,0x35,0x90,0x97,0x91,0xe0,0x64,0x05,0x70,0x32,0x90,0x97,0x7a,
+0xe0,0xff,0x70,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x0f,0xef,0x90,0x97,0x91,
+0xb4,0x01,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0xd3,0x90,0x97,0x88,0xe0,
+0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,0x97,0x91,0xf0,0xd3,
+0x90,0x97,0x88,0xe0,0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,
+0x97,0x91,0xf0,0x90,0x97,0x91,0xe0,0xff,0x90,0x97,0x79,0xe0,0xfe,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,0xe0,0x1d,0xef,0xc4,0x54,0xf0,
+0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x80,0x13,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0xf0,0xf0,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x90,0x97,0x91,
+0xe0,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xd3,0x94,0x05,0x50,0x0f,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x04,0xf0,0x80,0x0f,0x90,0x97,0x79,0xe0,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xab,0x14,0xaa,0x15,0xa9,
+0x16,0xe4,0xf5,0xf0,0x12,0x63,0x85,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x02,
+0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,0x00,0x04,0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,
+0x00,0x06,0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,0x00,0x08,0xe4,0xf5,0xf0,0x12,0x63,
+0xa4,0x90,0x97,0x79,0xe0,0xff,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x02,0x45,0x0e,0x22,0xef,
+0x70,0x03,0x02,0x50,0xa7,0x90,0x97,0x6d,0xe0,0x60,0x03,0x02,0x54,0xe9,0x90,0x97,
+0x59,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,
+0x25,0x08,0x7f,0x8c,0x7e,0x08,0x12,0x2b,0x08,0x90,0x97,0x05,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x44,0x7e,
+0x08,0x12,0x2b,0x08,0x90,0x97,0x09,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x5c,0x7e,0x08,0x12,0x2b,0x08,0x90,
+0x97,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,
+0x12,0x25,0x08,0x7f,0x6c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x11,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x70,
+0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x15,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x74,0x7e,0x0e,0x12,0x2b,0x08,
+0x90,0x97,0x19,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x96,0x12,0x25,0x08,0x7f,0x78,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x1d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,
+0x7c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x21,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x0e,0x12,0x2b,
+0x08,0x90,0x97,0x25,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x80,0x96,0x12,0x25,0x08,0x7f,0x84,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x29,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,
+0x7f,0x88,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x2d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x8c,0x7e,0x0e,0x12,
+0x2b,0x08,0x90,0x97,0x31,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xd0,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x35,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,
+0x08,0x7f,0xd4,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x39,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xd8,0x7e,0x0e,
+0x12,0x2b,0x08,0x90,0x97,0x3d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xdc,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,
+0x41,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,
+0x25,0x08,0x7f,0xe0,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x45,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xec,0x7e,
+0x0e,0x12,0x2b,0x08,0x90,0x97,0x49,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0c,0x12,0x2b,0x08,0x90,
+0x97,0x4d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,
+0x12,0x25,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x2b,0x08,0x90,0x97,0x51,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x0c,
+0x7e,0x09,0x12,0x2b,0x08,0x90,0x97,0x55,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x08,0x12,0x2b,0x08,
+0x90,0x97,0x6d,0x74,0x01,0xf0,0x22,0x90,0x97,0x6d,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x54,0xe9,0x7f,0x8c,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x59,0x12,0x25,0x08,0x7f,
+0x44,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x05,0x12,0x25,0x08,0x7f,0x5c,0x7e,0x08,
+0x12,0x22,0x65,0x90,0x97,0x09,0x12,0x25,0x08,0x7f,0x6c,0x7e,0x0e,0x12,0x22,0x65,
+0x90,0x97,0x0d,0x12,0x25,0x08,0x7f,0x70,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x11,
+0x12,0x25,0x08,0x7f,0x74,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x15,0x12,0x25,0x08,
+0x7f,0x78,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x19,0x12,0x25,0x08,0x7f,0x7c,0x7e,
+0x0e,0x12,0x22,0x65,0x90,0x97,0x1d,0x12,0x25,0x08,0x7f,0x80,0x7e,0x0e,0x12,0x22,
+0x65,0x90,0x97,0x21,0x12,0x25,0x08,0x7f,0x84,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,
+0x25,0x12,0x25,0x08,0x7f,0x88,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x29,0x12,0x25,
+0x08,0x7f,0x8c,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x2d,0x12,0x25,0x08,0x7f,0xd0,
+0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x31,0x12,0x25,0x08,0x7f,0xd4,0x7e,0x0e,0x12,
+0x22,0x65,0x90,0x97,0x35,0x12,0x25,0x08,0x7f,0xd8,0x7e,0x0e,0x12,0x22,0x65,0x90,
+0x97,0x39,0x12,0x25,0x08,0x7f,0xdc,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x3d,0x12,
+0x25,0x08,0x7f,0xe0,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x41,0x12,0x25,0x08,0x7f,
+0xec,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x45,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0c,
+0x12,0x22,0x65,0x90,0x97,0x49,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x22,0x65,
+0x90,0x97,0x4d,0x12,0x25,0x08,0x7f,0x0c,0x7e,0x09,0x12,0x22,0x65,0x90,0x97,0x51,
+0x12,0x25,0x08,0x7f,0x04,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x55,0x12,0x25,0x08,
+0x7f,0x8c,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0xc0,0xfd,0xec,
+0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x8c,0x7e,0x08,0x12,0x2b,
+0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x00,0x01,0x00,0x00,0x7f,0x44,0x7e,0x08,0x12,
+0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x00,0xdb,0x25,0xa4,0x7f,0x5c,0x7e,0x08,
+0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0x6c,0x7e,
+0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0x70,
+0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,0x25,0xa4,0x7f,
+0x74,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,0x25,0xa4,
+0x7f,0x78,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,0x25,
+0xa4,0x7f,0x7c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,
+0x25,0xa4,0x7f,0x80,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x63,
+0xdb,0x25,0xa4,0x7f,0x84,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,
+0x04,0x1b,0x25,0xa4,0x7f,0x88,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,
+0x14,0x20,0xdb,0x25,0xa4,0x7f,0x8c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,
+0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0xd0,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,
+0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0xd4,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,
+0x96,0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0xd8,0x7e,0x0e,0x12,0x2b,0x08,0x90,
+0x80,0x96,0x12,0x25,0x14,0x00,0x1b,0x25,0xa4,0x7f,0xdc,0x7e,0x0e,0x12,0x2b,0x08,
+0x90,0x80,0x96,0x12,0x25,0x14,0x00,0x1b,0x25,0xa4,0x7f,0xe0,0x7e,0x0e,0x12,0x2b,
+0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x24,0xdb,0x25,0xa4,0x7f,0xec,0x7e,0x0e,0x12,
+0x2b,0x08,0x7f,0x04,0x7e,0x0c,0x12,0x22,0x65,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,
+0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe7,
+0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x44,0x11,0xff,0xec,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,
+0x7e,0x0c,0x12,0x2b,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x22,0x65,0x90,0x97,0xe7,0x12,
+0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,
+0xf0,0xff,0xec,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x01,0xff,0xec,0x90,0x97,0xe7,0x12,0x25,0x08,
+0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x2b,0x08,0x7f,0x0c,0x7e,0x09,0x12,
+0x22,0x65,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x11,0xff,0xec,0x90,0x97,0xe7,
+0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x0c,0x7e,0x09,0x12,0x2b,0x08,0x7f,0x0c,
+0x7e,0x09,0x12,0x22,0x65,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x54,0x0f,0xfd,0xec,0x54,0xf0,
+0xfc,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0x10,0xfd,0xec,0x44,0x01,0xfc,0x90,0x97,0xe7,
+0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x0c,0x7e,0x09,0x12,0x2b,0x08,0x7f,0x04,
+0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xf0,0xff,0xec,0x90,0x97,0xe7,0x12,
+0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,
+0x01,0xff,0xec,0x90,0x97,0xe7,0x12,0x25,0x08,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,
+0x08,0x12,0x2b,0x08,0xe4,0x90,0x97,0x6d,0xf0,0x22,0x8f,0x11,0xef,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xaf,0x82,0xf5,0x12,0x8f,0x13,0xe5,0x11,0x75,0xf0,
+0x02,0xa4,0x24,0x81,0xf9,0x74,0x92,0x35,0xf0,0x75,0x14,0x01,0xf5,0x15,0x89,0x16,
+0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xaf,0x82,
+0xf5,0x17,0x8f,0x18,0xe5,0x11,0x75,0xf0,0x09,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,
+0xf0,0x75,0x19,0x01,0xf5,0x1a,0x89,0x1b,0x74,0xc1,0x25,0x11,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0xe0,0x12,0x63,0xee,0x55,0x6c,0x00,0x55,0x81,0x01,0x55,0x96,0x02,
+0x55,0xab,0x03,0x55,0xd5,0x04,0x55,0xea,0x05,0x55,0xff,0x06,0x56,0x26,0x0c,0x56,
+0x54,0x0d,0x56,0x81,0x0e,0x56,0xae,0x0f,0x00,0x00,0x56,0xe2,0xe5,0x11,0x25,0xe0,
+0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x15,0x80,
+0x3c,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,
+0xf0,0xa3,0x74,0x10,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x05,0x80,0x12,0xe5,0x11,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0xe4,0xf0,0xe5,0x11,
+0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,
+0x8f,0xf0,0x02,0x56,0xe2,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf5,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf0,0x80,0x12,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xa3,0x74,
+0x0d,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0x02,0x56,0xe2,0x90,0x04,0x47,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,
+0x12,0x62,0xc2,0x90,0x04,0x46,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,
+0x12,0x62,0xd4,0x90,0x04,0x45,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,
+0x44,0x02,0x56,0xd9,0x90,0x04,0x4b,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,
+0xc2,0x90,0x04,0x4a,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,
+0xd4,0x90,0x04,0x49,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x48,0x80,
+0x58,0x90,0x04,0x4f,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0xc2,0x90,0x04,
+0x4e,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xd4,0x90,0x04,
+0x4d,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x4c,0x80,0x2b,0x90,0x04,
+0x53,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0xc2,0x90,0x04,0x52,0xe0,0xab,
+0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xd4,0x90,0x04,0x51,0xe0,0x85,
+0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x50,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,
+0xa3,0xf0,0xab,0x14,0xaa,0x15,0xa9,0x16,0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x24,
+0x62,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,0x12,0x24,0x62,0x5f,0xd0,0x01,0xd0,0x02,
+0xd0,0x03,0x12,0x62,0xc2,0xab,0x14,0xe5,0x16,0x24,0x01,0xf9,0xe4,0x35,0x15,0xfa,
+0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x24,0x62,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,
+0x90,0x00,0x01,0x12,0x62,0x95,0x5f,0xd0,0x01,0xd0,0x02,0xd0,0x03,0x12,0x62,0xc2,
+0x85,0x13,0x82,0x85,0x12,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,
+0x17,0x83,0xe0,0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0x85,0x13,0x82,0x85,0x12,
+0x83,0xa3,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,0x17,0x83,0xa3,0xe0,
+0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x4c,0x90,0x97,0x90,0x74,
+0x0b,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x50,0x03,0x02,0x58,0x28,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,
+0xa3,0xe0,0x5f,0x4e,0x60,0x0a,0x90,0x97,0x90,0xe0,0x24,0x10,0xa3,0xf0,0x80,0x68,
+0x90,0x97,0x90,0xe0,0x14,0xf0,0x80,0xba,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0x90,0x97,0x90,0x74,
+0x0f,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x40,0x3c,0x74,0x01,0x7e,0x00,
+0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,
+0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x08,0x90,0x97,0x90,0xe0,0xa3,0xf0,0x80,0x0d,0x90,0x97,0x90,0xe0,0x14,
+0xf0,0x80,0xbf,0xe4,0x90,0x97,0x91,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0xe4,0x90,0x97,0x90,
+0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x10,0x40,0x03,0x02,0x58,0xe2,0x74,0x01,
+0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,
+0xe0,0x5f,0x4e,0x60,0x06,0x90,0x97,0x90,0xe0,0x80,0x63,0x90,0x97,0x90,0xe0,0x04,
+0xf0,0x80,0xbe,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x46,0xe4,0x90,0x97,0x90,0xf0,0x90,0x97,0x90,0xe0,
+0xff,0xc3,0x94,0x0c,0x50,0x3c,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,
+0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x08,0x90,0x97,0x90,
+0xe0,0x24,0x10,0x80,0x09,0x90,0x97,0x90,0xe0,0x04,0xf0,0x80,0xbf,0xe4,0x90,0x97,
+0x92,0xf0,0x90,0x97,0x91,0xe0,0xff,0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x67,0xf5,
+0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xef,0xf0,0x90,0x97,0x92,0xe0,0xfe,0x75,0xf0,
+0x09,0xe5,0x11,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,
+0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0xd3,0x9f,0x40,0x1f,
+0x90,0x97,0x91,0xe0,0xff,0x74,0xc4,0x25,0x11,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xd3,0x94,0x13,0x40,0x08,0x90,0x93,0x62,0x74,0x03,0xf0,0x80,
+0x21,0xef,0xd3,0x94,0x0b,0x40,0x08,0x90,0x93,0x62,0x74,0x02,0xf0,0x80,0x13,0xef,
+0xd3,0x94,0x03,0x40,0x08,0x90,0x93,0x62,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x93,
+0x62,0xf0,0x90,0x93,0x62,0xe0,0x90,0x04,0xb1,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
+0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x7b,0xf0,0x74,0x59,
+0xa3,0xf0,0x90,0x01,0x34,0xe0,0x55,0x28,0xf5,0x2c,0x90,0x01,0x36,0xe0,0x55,0x2a,
+0xf5,0x2e,0xa3,0xe0,0x55,0x2b,0xf5,0x2f,0xe5,0x2c,0x20,0xe0,0x03,0x02,0x5b,0x29,
+0x90,0x01,0x34,0x74,0x01,0xf0,0x85,0xd1,0x4d,0x85,0xd2,0x4e,0x85,0xd3,0x4f,0x85,
+0xd4,0x50,0x85,0xd5,0x51,0x85,0xd6,0x52,0x85,0xd7,0x53,0x85,0xd9,0x54,0xe5,0x54,
+0x54,0x40,0xc3,0x13,0xff,0xe5,0x53,0x54,0x20,0x6f,0x70,0x03,0x02,0x5a,0xd8,0xe5,
+0x54,0x30,0xe5,0x03,0x02,0x5a,0xd8,0xe5,0x52,0x54,0x1f,0xf5,0x08,0xe5,0x4d,0x54,
+0x3f,0xf5,0x09,0xe5,0x51,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0x23,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xf6,0xe5,0x53,0x54,0x1f,0xff,
+0xe5,0x08,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0x8f,0xf0,
+0x12,0x62,0xf6,0xe5,0x09,0xd3,0x94,0x04,0x40,0x03,0x75,0x09,0x04,0x75,0xf0,0x0a,
+0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0x75,0xf0,0x02,
+0xe5,0x09,0x12,0x63,0xe2,0xe0,0xfe,0xa3,0xe0,0xff,0xe5,0x53,0x54,0x1f,0x2f,0xff,
+0xe4,0x3e,0xfe,0x75,0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,
+0x90,0xf5,0x83,0x75,0xf0,0x02,0xe5,0x09,0x12,0x63,0xe2,0xee,0xf0,0xa3,0xef,0xf0,
+0xe5,0x54,0x20,0xe6,0x24,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0xa3,
+0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xf6,0xe5,0x4f,0x30,
+0xe7,0x36,0xaf,0x08,0x12,0x75,0xa3,0x80,0x2f,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,
+0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,
+0xf6,0xe5,0x4f,0x30,0xe7,0x12,0xe5,0x4f,0x54,0x7f,0xfd,0xe5,0x53,0x54,0x1f,0xf5,
+0x0d,0xab,0x09,0xaf,0x08,0x12,0x76,0xe9,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,0x80,
+0x48,0x90,0x97,0xcb,0xe0,0x60,0x35,0x90,0x01,0x5b,0xe4,0xf0,0x90,0x01,0x3c,0x74,
+0x04,0xf0,0x90,0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x2d,0x75,0x44,0x14,0xf5,
+0x45,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x5b,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x01,0xf0,0x90,0x97,0xc7,0xf0,0x80,0x0d,0x90,0x04,0x1b,0xe0,
+0x54,0x7f,0xff,0xbf,0x7f,0x03,0x12,0x7f,0x8d,0xe5,0x2c,0x30,0xe1,0x27,0x90,0x01,
+0x34,0x74,0x02,0xf0,0x90,0xfd,0x10,0x74,0x7f,0xf0,0x85,0xd1,0x58,0x85,0xd2,0x59,
+0x85,0xd3,0x5a,0x85,0xd4,0x5b,0x85,0xd5,0x5c,0x85,0xd6,0x5d,0x85,0xd7,0x5e,0x85,
+0xd9,0x5f,0x12,0x7d,0xc4,0xe5,0x2c,0x30,0xe3,0x06,0x90,0x01,0x34,0x74,0x08,0xf0,
+0xe5,0x2c,0x30,0xe4,0x09,0x90,0x01,0x34,0x74,0x10,0xf0,0x43,0x57,0x10,0xe5,0x2c,
+0x30,0xe5,0x1d,0x90,0x01,0xcf,0xe0,0x30,0xe5,0x16,0xe0,0x54,0xdf,0xf0,0x90,0x01,
+0x34,0x74,0x20,0xf0,0x90,0x00,0x03,0xe0,0x54,0xfb,0xf0,0x12,0x7f,0x30,0x80,0xfe,
+0xe5,0x2c,0x30,0xe6,0x06,0x90,0x01,0x34,0x74,0x40,0xf0,0xe5,0x2e,0x30,0xe1,0x3c,
+0x90,0x01,0x36,0x74,0x02,0xf0,0x43,0x57,0x40,0x90,0x01,0x02,0xe0,0x54,0x03,0x64,
+0x01,0x70,0x29,0x90,0x01,0x37,0xe0,0x30,0xe0,0x0a,0x74,0x01,0xf0,0x90,0x97,0xd0,
+0xe4,0xf0,0x80,0x18,0x90,0x97,0xd0,0xe0,0x04,0xf0,0xe0,0xc3,0x94,0x0a,0x40,0x0c,
+0xe4,0xf0,0x90,0x04,0x19,0xe0,0x30,0xe0,0x03,0x12,0x7e,0xfd,0xe5,0x2e,0x30,0xe0,
+0x09,0x90,0x01,0x36,0x74,0x01,0xf0,0x12,0x75,0x28,0xe5,0x2e,0x30,0xe2,0x72,0x90,
+0x01,0x36,0x74,0x04,0xf0,0xe5,0x69,0x64,0x01,0x70,0x66,0xe5,0x6a,0x60,0x62,0xe5,
+0x6a,0x64,0x02,0x60,0x06,0xe5,0x6a,0x64,0x05,0x70,0x27,0x90,0x06,0xab,0xe0,0x90,
+0x97,0xbe,0xf0,0x90,0x06,0xaa,0xe0,0x90,0x97,0xc9,0xf0,0x90,0x97,0xbe,0xe0,0x70,
+0x07,0x90,0x97,0xc9,0xe0,0xff,0x80,0x05,0x90,0x97,0xbe,0xe0,0xff,0x90,0x97,0xbe,
+0xef,0xf0,0x90,0x97,0xc0,0xe0,0x60,0x03,0xe0,0x14,0xf0,0x90,0x97,0xbf,0xe4,0xf0,
+0x90,0x01,0x57,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xfd,
+0xf0,0xe0,0x54,0xef,0xf0,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,0x80,0x03,0x12,0x76,
+0x19,0xe5,0x2e,0x30,0xe3,0x31,0x90,0x01,0x36,0x74,0x08,0xf0,0xe5,0x69,0x64,0x01,
+0x70,0x25,0xe5,0x6a,0x60,0x21,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,
+0xf0,0x75,0x44,0x03,0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x30,
+0x62,0x90,0x01,0x57,0x74,0x05,0xf0,0xe5,0x2e,0x30,0xe4,0x2f,0x90,0x01,0x36,0x74,
+0x10,0xf0,0xe5,0x69,0x64,0x01,0x70,0x23,0xe5,0x6a,0x60,0x1f,0x90,0x01,0x57,0xe4,
+0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0xcc,0xe4,0xf0,0x90,0x97,0xcd,0xe0,
+0x54,0xfd,0xf0,0xe0,0x54,0x07,0x70,0x03,0x12,0x7f,0x8d,0xe5,0x2e,0x30,0xe5,0x1f,
+0x90,0x01,0x36,0x74,0x20,0xf0,0xe5,0x69,0xb4,0x01,0x14,0xe5,0x6a,0x60,0x10,0x90,
+0x97,0xcb,0xe0,0x64,0x02,0x60,0x05,0x12,0x7f,0x1f,0x80,0x03,0x12,0x7b,0x06,0xe5,
+0x2e,0x30,0xe6,0x1e,0x90,0x01,0x36,0x74,0x40,0xf0,0xe5,0x69,0xb4,0x01,0x13,0xe5,
+0x6a,0x60,0x0f,0x90,0x97,0xcd,0xe0,0x54,0xfe,0xf0,0xe0,0x54,0x07,0x70,0x03,0x12,
+0x7f,0x8d,0xe5,0x2f,0x30,0xe1,0x09,0x90,0x01,0x37,0x74,0x02,0xf0,0x12,0x7c,0x92,
+0x74,0x7b,0x04,0x90,0x01,0xc4,0xf0,0x74,0x59,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,
+0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,
+0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x90,0x04,0x44,0x74,0x11,0xf0,0xa3,0x74,0xf0,0xf0,
+0xa3,0x74,0x0f,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xff,
+0xc3,0x94,0x10,0x50,0x14,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe4,
+0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x80,0xe2,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xfb,0xc3,0x94,0x20,0x40,0x03,0x02,0x5f,0x55,0xe0,0xff,0x75,0xf0,0x0a,
+0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,
+0xf0,0x0a,0xef,0xa4,0x24,0x02,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,
+0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x04,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x06,0xf5,0x82,0xe5,0xf0,
+0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x08,0xf5,
+0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x74,0xc4,0x2f,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0x74,0x13,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe4,0xf0,0x74,0x83,0x2f,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,
+0xef,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0x23,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0x64,0x2f,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe4,0xf0,0x90,0x41,0xc4,0x93,0xfe,0x74,0x01,0x93,0xff,0x90,0x41,0x8c,
+0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,
+0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,
+0x25,0x08,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0x74,0x01,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xf5,0x83,0x74,0x01,0xf0,0x74,0xc1,0x2b,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0x74,0x0c,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,
+0xf5,0x83,0x74,0xff,0xf0,0xa3,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x63,0xf5,0x82,
+0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0xa3,0x74,0x0f,0xf0,0x75,0xf0,0x09,0xeb,
+0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x13,0xf0,0x75,0xf0,
+0x09,0xeb,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0x74,
+0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0x74,0x13,0xf0,0x90,0x97,0x79,0xe0,
+0x04,0xf0,0x02,0x5d,0x7e,0x22,0xa9,0x07,0x74,0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,
+0xf5,0x83,0xe0,0x54,0x7f,0x90,0x97,0x92,0xf0,0xe0,0x54,0x1f,0xff,0x90,0x97,0x95,
+0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xe0,0x90,0x97,0x97,0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,
+0x34,0x93,0xf5,0x83,0xe0,0xfe,0x90,0x97,0x98,0xf0,0xe9,0x25,0xe0,0x24,0x24,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x99,0xcb,0xf0,0xa3,
+0xeb,0xf0,0xe9,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfb,
+0xa3,0xe0,0x90,0x97,0x9b,0xcb,0xf0,0xa3,0xeb,0xf0,0xef,0xd3,0x9e,0x40,0x0c,0x90,
+0x97,0x98,0xe0,0x90,0x97,0x95,0xf0,0x90,0x97,0x92,0xf0,0xed,0x70,0x03,0x02,0x60,
+0xb5,0x90,0x97,0x96,0xed,0xf0,0x90,0x97,0x92,0xe0,0x30,0xe6,0x0e,0x90,0x97,0x95,
+0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x96,0xe0,0x14,0xf0,0x90,0x97,0x96,0xe0,0x70,
+0x03,0x02,0x60,0xb5,0x90,0x97,0x95,0xe0,0xff,0xd3,0x94,0x00,0x50,0x03,0x02,0x60,
+0xb5,0xe4,0x90,0x97,0x94,0xf0,0xef,0x14,0x90,0x97,0x93,0xf0,0x90,0x97,0x97,0xe0,
+0xfd,0x90,0x97,0x93,0xe0,0xff,0xd3,0x9d,0x40,0x6f,0xef,0x94,0x10,0x40,0x21,0xef,
+0x24,0xf0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,
+0xce,0xd8,0xf9,0xff,0x90,0x97,0x9b,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,
+0x90,0x97,0x93,0xe0,0xff,0xc3,0x94,0x10,0x50,0x37,0x74,0x01,0x7e,0x00,0xa8,0x07,
+0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x99,0xe0,0x5e,
+0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x1a,0x90,0x97,0x93,0xe0,0x90,0x97,0x92,0xf0,0x90,
+0x97,0x94,0xe0,0x04,0xf0,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,0x94,0xe0,0x6f,0x60,
+0x08,0x90,0x97,0x93,0xe0,0x14,0xf0,0x80,0x83,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,
+0x94,0xe0,0xc3,0x9f,0x50,0x0f,0x90,0x97,0x93,0xe0,0xb5,0x05,0x08,0x90,0x97,0x97,
+0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x92,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,
+0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,
+0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,
+0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xe9,0x25,0xe0,0x25,0xe0,0x24,0xe1,
+0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x25,0x08,0x90,0x97,0x92,0xe0,0xff,0x74,
+0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0x90,0x01,0xcc,0xe0,
+0x54,0x0f,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xfd,0x70,0x03,0x02,0x62,0x94,
+0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,
+0xce,0x33,0xce,0xd8,0xf9,0xff,0xef,0x5d,0x70,0x03,0x02,0x62,0x75,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd0,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,
+0x90,0x97,0x7a,0xf0,0x75,0x63,0x01,0x75,0x64,0x97,0x75,0x65,0x7a,0x75,0x66,0x01,
+0x7b,0x01,0x7a,0x97,0x79,0x7b,0x12,0x77,0xae,0x90,0x97,0x7b,0xe0,0xff,0xc4,0x13,
+0x13,0x13,0x54,0x01,0x90,0x97,0xef,0x30,0xe0,0x70,0xe0,0x75,0xf0,0x02,0xa4,0x24,
+0x88,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x02,0xa4,0x24,0x89,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,
+0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd1,0xf5,0x82,0xe5,
+0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,
+0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7f,
+0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,0x82,0xe5,0xf0,0x34,
+0x01,0xf5,0x83,0xe0,0x90,0x97,0x80,0xf0,0x80,0x42,0xe0,0x75,0xf0,0x04,0xa4,0x24,
+0xd1,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,
+0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,
+0xe0,0x90,0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,
+0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0xef,0x54,0x7f,0xff,
+0x7b,0x01,0x7a,0x97,0x79,0x7c,0x12,0x6e,0xea,0x90,0x97,0x79,0xe0,0xff,0x90,0x97,
+0xef,0xe0,0xfe,0x74,0x01,0xa8,0x06,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0x5f,
+0x90,0x97,0x79,0xf0,0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0x90,0x01,0xcc,0xf0,0x90,0x97,0xef,0xe0,0x04,0xf0,0xe0,0x54,
+0x03,0xf0,0x02,0x61,0x16,0xc2,0xaf,0x74,0x0c,0x04,0x90,0x01,0xc4,0xf0,0x74,0x61,
+0xa3,0xf0,0x90,0x97,0x79,0xe0,0x90,0x01,0xc6,0xf0,0x90,0x97,0xef,0xe0,0x90,0x01,
+0xc7,0xf0,0x80,0xfe,0x22,0xbb,0x01,0x0c,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe0,0x22,0x50,0x06,0xe9,0x25,0x82,0xf8,0xe6,0x22,0xbb,0xfe,0x06,0xe9,
+0x25,0x82,0xf8,0xe2,0x22,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe4,
+0x93,0x22,0xbb,0x01,0x06,0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x02,0xf7,0x22,0xbb,
+0xfe,0x01,0xf3,0x22,0xf8,0xbb,0x01,0x0d,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe8,0xf0,0x22,0x50,0x06,0xe9,0x25,0x82,0xc8,0xf6,0x22,0xbb,0xfe,0x05,
+0xe9,0x25,0x82,0xc8,0xf2,0x22,0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,0xc5,0xf0,0xf8,
+0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,0xf8,0xe0,0xc5,
+0xf0,0x25,0xf0,0xf0,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0xc8,0x38,0xf0,
+0xe8,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,0x50,
+0x06,0x87,0xf0,0x09,0xe7,0x19,0x22,0xbb,0xfe,0x07,0xe3,0xf5,0xf0,0x09,0xe3,0x19,
+0x22,0x89,0x82,0x8a,0x83,0xe4,0x93,0xf5,0xf0,0x74,0x01,0x93,0x22,0xbb,0x01,0x10,
+0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,
+0x50,0x09,0xe9,0x25,0x82,0xf8,0x86,0xf0,0x08,0xe6,0x22,0xbb,0xfe,0x0a,0xe9,0x25,
+0x82,0xf8,0xe2,0xf5,0xf0,0x08,0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,0xe9,0x93,0xf5,
+0xf0,0xa3,0xe9,0x93,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xf0,0xe5,0xf0,0xa3,
+0xf0,0x22,0x50,0x06,0xf7,0x09,0xa7,0xf0,0x19,0x22,0xbb,0xfe,0x06,0xf3,0xe5,0xf0,
+0x09,0xf3,0x19,0x22,0xf8,0xbb,0x01,0x11,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x09,0xe9,0x25,0x82,0xc8,0xf6,
+0x08,0xa6,0xf0,0x22,0xbb,0xfe,0x09,0xe9,0x25,0x82,0xc8,0xf2,0xe5,0xf0,0x08,0xf2,
+0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,0xe8,0x9c,0x45,
+0xf0,0x22,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,0x22,0xd0,0x83,
+0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,0x01,0x93,0x70,0x0d,0xa3,0xa3,0x93,0xf8,
+0x74,0x01,0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x02,0x93,0x68,0x60,0xef,0xa3,
+0xa3,0xa3,0x80,0xdf,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,
+0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x04,0x12,0x62,0x95,
+0xff,0x54,0x1f,0x90,0x97,0x87,0xf0,0x90,0x00,0x03,0x12,0x62,0x95,0x54,0xf0,0xc4,
+0x54,0x0f,0x90,0x97,0x88,0xf0,0xef,0x54,0x20,0xc4,0x13,0x54,0x07,0xa3,0xf0,0x90,
+0x00,0x04,0x12,0x62,0x95,0x54,0x40,0xc4,0x13,0x13,0x54,0x03,0x90,0x97,0x8a,0xf0,
+0x90,0x97,0x87,0xe0,0xff,0x75,0xf0,0x09,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xad,0x82,0x90,0x97,0x8b,0xf0,0xa3,0xed,0xf0,0xef,0x75,0xf0,0x09,0xa4,0x24,
+0x63,0xf9,0x74,0x93,0x35,0xf0,0xfa,0xa3,0x74,0x01,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,
+0xf0,0x90,0x97,0x84,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x03,0x12,0x62,0x95,
+0x54,0x0f,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0xef,0x12,
+0x62,0xc2,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x02,
+0x12,0x62,0x95,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,
+0x00,0x01,0xef,0x12,0x62,0xd4,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0x90,0x97,0x8b,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xf5,0x82,0x8c,0x83,0xef,0xf0,0x12,0x24,0x62,0x8d,0x82,0x8c,0x83,0xa3,0xf0,0x90,
+0x97,0x88,0xe0,0xfe,0x90,0x97,0x87,0xe0,0xff,0x24,0xc1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0xee,0xf0,0x90,0x97,0x89,0xe0,0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x69,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,0x75,0xf0,0x09,0xef,0xa4,0x24,
+0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x90,0x97,0x8a,0xe0,
+0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xee,0xf0,0x02,0x54,0xea,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x97,0xa9,0xf0,0x90,
+0x00,0x01,0x12,0x62,0x95,0x25,0xe0,0x25,0xe0,0x90,0x97,0xa8,0xf0,0x12,0x24,0x62,
+0x25,0xe0,0x25,0xe0,0x90,0x97,0xac,0xf0,0x90,0x05,0x60,0xe0,0x90,0x97,0xb7,0xf0,
+0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0xb9,0xf0,
+0x90,0x05,0x63,0xe0,0x90,0x97,0xba,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,
+0xc2,0xaf,0x90,0x97,0xa8,0xe0,0xff,0x12,0x79,0x11,0x90,0x97,0x84,0xe0,0x24,0xff,
+0x92,0xaf,0x90,0x97,0xa9,0xe0,0x70,0x03,0x02,0x66,0x62,0x90,0x97,0xa8,0xe0,0x70,
+0x03,0x02,0x66,0x62,0x90,0x97,0xac,0xe0,0x70,0x03,0x02,0x66,0x62,0xa2,0xaf,0xe4,
+0x33,0x90,0x97,0x84,0xf0,0xc2,0xaf,0x90,0x97,0xbb,0x74,0x01,0xf0,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,0xe0,0x44,0x01,
+0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,
+0x2b,0x08,0x80,0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x00,0x45,0xe0,0x54,0xef,
+0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,0xf0,
+0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,0xf0,
+0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,
+0xc2,0xaf,0x90,0x01,0x3c,0xe0,0x44,0x20,0xf0,0x7d,0x20,0xe4,0xff,0x12,0x31,0xb7,
+0x80,0x2b,0x90,0x97,0xa9,0xe0,0x70,0x2d,0x90,0x97,0xbb,0xf0,0x90,0x00,0x45,0xe0,
+0x54,0xfe,0xf0,0xa3,0xe0,0x54,0xfe,0xf0,0x90,0x05,0x22,0xe4,0xf0,0xa2,0xaf,0x33,
+0x90,0x97,0x84,0xf0,0xc2,0xaf,0x7d,0x20,0xe4,0xff,0x12,0x31,0x49,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,0x82,0xc0,0xd0,
+0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,0xc0,0x05,0xc0,
+0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x96,0xf0,0x74,0x66,0xa3,0xf0,0x53,0x91,0xdf,
+0x90,0x01,0x3c,0xe0,0x55,0x30,0xf5,0x34,0xa3,0xe0,0x55,0x31,0xf5,0x35,0xa3,0xe0,
+0x55,0x32,0xf5,0x36,0xa3,0xe0,0x55,0x33,0xf5,0x37,0xe5,0x34,0x30,0xe1,0x09,0x90,
+0x01,0x3c,0x74,0x02,0xf0,0x12,0x7b,0x44,0xe5,0x34,0x30,0xe2,0x33,0x90,0x01,0x3c,
+0x74,0x04,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe0,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,
+0xe4,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x5b,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x01,0xf0,0x80,0x08,0x90,0x97,0xc7,0xe4,0xf0,0x12,0x7f,0x8d,
+0xe5,0x34,0x30,0xe3,0x33,0x90,0x01,0x3c,0x74,0x08,0xf0,0x90,0x06,0x92,0xe0,0x30,
+0xe1,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,
+0x30,0x62,0x90,0x01,0x5f,0x74,0x05,0xf0,0x90,0x06,0x92,0x74,0x02,0xf0,0x80,0x08,
+0x90,0x97,0xc6,0xe4,0xf0,0x12,0x7f,0x8d,0xe5,0x34,0x30,0xe4,0x09,0x90,0x01,0x3c,
+0x74,0x10,0xf0,0x12,0x7a,0x85,0xe5,0x34,0x30,0xe5,0x09,0x90,0x01,0x3c,0x74,0x20,
+0xf0,0x12,0x6e,0x26,0xe5,0x35,0x30,0xe0,0x11,0x90,0x01,0x3d,0x74,0x01,0xf0,0x90,
+0x00,0x83,0xe0,0x90,0x97,0xca,0xf0,0x12,0x7f,0x8d,0x74,0x96,0x04,0x90,0x01,0xc4,
+0xf0,0x74,0x66,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,
+0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,
+0xe4,0x90,0x97,0x76,0xf0,0xa3,0xf0,0x12,0x79,0xb2,0x90,0x00,0x02,0xe0,0x54,0xe0,
+0x90,0x97,0xd6,0x60,0x05,0x74,0x01,0xf0,0x80,0x03,0x74,0x02,0xf0,0x90,0x00,0xf3,
+0xe0,0x30,0xe3,0x08,0x90,0x97,0xd7,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x97,0xd7,
+0xf0,0x90,0x97,0xd7,0xe0,0xb4,0x01,0x13,0x90,0x00,0xf2,0xe0,0x30,0xe7,0x0c,0x90,
+0x97,0xce,0x74,0xfd,0xf0,0xa3,0x74,0x33,0xf0,0x80,0x0a,0x90,0x97,0xce,0x74,0xfd,
+0xf0,0xa3,0x74,0x2f,0xf0,0xe4,0xf5,0x57,0x12,0x5d,0x46,0x12,0x7f,0xa1,0x12,0x79,
+0x63,0x12,0x2e,0x01,0x12,0x44,0xfe,0x12,0x7e,0x27,0x90,0x00,0xf3,0xe0,0x30,0xe2,
+0x0d,0x90,0x05,0x41,0x74,0x10,0xf0,0x90,0x05,0x5a,0xf0,0xa3,0xe4,0xf0,0x90,0x01,
+0x64,0x74,0xa0,0xf0,0x75,0x44,0xff,0xe4,0xf5,0x45,0xfb,0x7d,0x01,0x7f,0x50,0x7e,
+0x01,0x12,0x30,0x62,0x12,0x7e,0xd0,0x12,0x78,0x0e,0x90,0x97,0x78,0xe5,0xd9,0xf0,
+0x12,0x7e,0xe8,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x40,0xf0,0x12,0x7f,0x30,0x75,
+0xe8,0x03,0x43,0xa8,0x85,0xd2,0xaf,0x90,0x01,0xc0,0xe4,0xf0,0xa3,0xf0,0xa3,0xf0,
+0xa3,0xf0,0x90,0x01,0xc6,0xf0,0xa3,0xf0,0x90,0x97,0x76,0xe0,0x64,0x01,0xf0,0x24,
+0xb0,0x90,0x01,0xc4,0xf0,0x74,0x67,0xa3,0xf0,0xe5,0x57,0x30,0xe6,0x17,0xc2,0xaf,
+0x53,0x57,0xbf,0xd2,0xaf,0x12,0x45,0x09,0x90,0x97,0xab,0xe0,0xff,0x60,0x03,0xb4,
+0x01,0x03,0x12,0x68,0xc2,0xe5,0x57,0x30,0xe4,0x0a,0xc2,0xaf,0x53,0x57,0xef,0xd2,
+0xaf,0x12,0x61,0x0c,0x90,0x97,0xab,0xe0,0x70,0x03,0x12,0x6b,0xad,0x12,0x7c,0xf4,
+0x80,0xb6,0x90,0x97,0xa2,0xe0,0xc3,0x94,0x14,0x50,0x06,0xe0,0x04,0xf0,0x02,0x69,
+0x7c,0x90,0x97,0xa2,0xe0,0x64,0x14,0x60,0x03,0x02,0x69,0x7c,0x90,0x97,0xb1,0xe0,
+0x70,0x25,0x90,0x97,0xb4,0xe0,0x70,0x1f,0x90,0x97,0xb2,0xe0,0x70,0x19,0x90,0x97,
+0xb5,0xe0,0x70,0x13,0x90,0x97,0xb3,0xe0,0x70,0x0d,0x90,0x97,0xb6,0xe0,0x70,0x07,
+0x90,0x04,0xfd,0xe0,0x54,0xfe,0xf0,0x90,0x97,0xb1,0xe0,0x90,0x04,0x44,0xf0,0x90,
+0x97,0xb2,0xe0,0x90,0x04,0x45,0xf0,0x90,0x97,0xb3,0xe0,0x90,0x04,0x46,0xf0,0xa3,
+0xe4,0xf0,0x90,0x97,0xb4,0xe0,0x90,0x04,0x48,0xf0,0x90,0x97,0xb5,0xe0,0x90,0x04,
+0x49,0xf0,0x90,0x97,0xb6,0xe0,0x90,0x04,0x4a,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x9d,
+0xe0,0x90,0x07,0x00,0xf0,0x90,0x97,0x9e,0xe0,0x90,0x07,0x01,0xf0,0x90,0x97,0x9f,
+0xe0,0x90,0x07,0x02,0xf0,0x90,0x97,0xa0,0xe0,0x90,0x07,0x03,0xf0,0xe4,0x90,0x97,
+0xa2,0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,
+0xb1,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x05,0x60,0xe0,
+0x90,0x97,0x79,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0x7a,0xf0,0x90,0x05,0x62,0xe0,
+0x90,0x97,0x7b,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xba,0xe0,
+0xff,0x90,0x97,0x7c,0xe0,0xfe,0xd3,0x9f,0x50,0x0b,0x90,0x97,0xba,0xe0,0xc3,0x9e,
+0xd3,0x94,0x01,0x40,0x11,0x90,0x97,0xa8,0xe0,0xb4,0x01,0x02,0x80,0x03,0x90,0x97,
+0xac,0xe0,0xff,0x12,0x79,0x11,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,
+0xee,0xed,0xf0,0x90,0x97,0xed,0xef,0xf0,0xd3,0x94,0x07,0x50,0x65,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,
+0x5f,0xf0,0x12,0x7f,0x30,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x46,0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,
+0x97,0xee,0xe0,0x60,0x16,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x45,0x80,0x70,0x90,0x97,0xed,0xe0,0xff,
+0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x45,
+0x80,0x75,0x90,0x97,0xed,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,
+0xf0,0x12,0x7f,0x30,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,0x97,
+0xee,0xe0,0x60,0x1b,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x42,0xe0,0x4f,0x80,0x1a,0x90,
+0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,
+0x54,0xf0,0xf4,0xff,0x90,0x00,0x42,0xe0,0x5f,0xf0,0x12,0x7f,0x30,0xd0,0xd0,0x92,
+0xaf,0x22,0x7f,0x78,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x5d,0x12,0x25,0x08,0x7f,
+0x04,0x7e,0x0c,0x12,0x22,0x65,0x90,0x97,0x61,0x12,0x25,0x08,0x7f,0x00,0x7e,0x08,
+0x12,0x22,0x65,0x90,0x97,0x65,0x12,0x25,0x08,0x90,0x97,0xd7,0xe0,0x90,0x97,0x5d,
+0xb4,0x01,0x13,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xc7,0xff,
+0xed,0x54,0xc7,0xfd,0x80,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x54,0xc7,0xff,0xec,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x78,0x7e,0x08,0x12,0x2b,
+0x08,0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0x0f,
+0xff,0xec,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0c,0x12,0x2b,0x08,0x90,
+0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x02,0xff,0xec,
+0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x00,0x7e,0x08,0x12,0x2b,0x08,0x7f,0x70,0x7e,
+0x0e,0x12,0x22,0x65,0x90,0x97,0x69,0x12,0x25,0x08,0x90,0x80,0x96,0x12,0x25,0x14,
+0x00,0x1b,0x25,0xa0,0x7f,0x70,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x68,0x12,0x25,
+0x14,0x00,0x00,0x00,0x00,0xe4,0xfd,0xff,0x12,0x30,0x2c,0x90,0x97,0xd7,0xe0,0xb4,
+0x01,0x11,0x90,0x80,0x68,0x12,0x25,0x14,0x00,0x00,0x00,0x00,0xe4,0xfd,0x7f,0x01,
+0x12,0x30,0x2c,0x90,0x00,0x11,0xe0,0x54,0xf6,0xf0,0x02,0x7f,0x30,0x90,0x97,0xbb,
+0xe0,0x64,0x01,0x60,0x09,0x90,0x97,0xa9,0xe0,0x60,0x03,0x02,0x6c,0x85,0x90,0x97,
+0x9d,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x3b,0x90,0x97,0x9e,0xe0,
+0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x28,0x90,0x97,0x9f,0xe0,0xc3,
+0x94,0xff,0x50,0x0a,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9e,0xf0,0x80,0x15,0x90,0x97,
+0xa0,0xe0,0xc3,0x94,0xff,0x50,0x10,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9f,0xf0,0x90,
+0x97,0x9e,0xf0,0x90,0x97,0x9d,0xf0,0x90,0x00,0x44,0xe0,0x54,0x0c,0x60,0x76,0xe0,
+0x30,0xe2,0x32,0x90,0x97,0xb1,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,
+0x24,0x90,0x97,0xb2,0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,
+0x90,0x97,0xb3,0xe0,0xc3,0x94,0xff,0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb2,
+0xf0,0x90,0x97,0xb1,0xf0,0x90,0x00,0x44,0xe0,0x30,0xe3,0x32,0x90,0x97,0xb4,0xe0,
+0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,0x90,0x97,0xb5,0xe0,0xc3,0x94,
+0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,0x97,0xb6,0xe0,0xc3,0x94,0xff,
+0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb4,0xf0,0x90,0x04,
+0xfd,0xe0,0x44,0x01,0xf0,0x22,0x8b,0x11,0x8a,0x12,0x89,0x13,0x90,0x00,0x02,0x12,
+0x62,0x95,0x90,0x97,0xaa,0xf0,0xe0,0x30,0xe0,0x5c,0x90,0x97,0xa1,0x74,0x01,0xf0,
+0x7f,0x80,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0xa3,0x12,0x25,0x08,0xab,0x11,0xaa,
+0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0xe4,0xfc,0xfd,0xfe,0x78,0x1a,
+0x12,0x24,0xf5,0xa8,0x04,0xa9,0x05,0xaa,0x06,0xab,0x07,0x90,0x97,0xa3,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xec,0x54,0x03,0xfc,0xeb,0x4f,0xff,
+0xea,0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,0x4c,0xfc,0x90,0x97,0xad,0x12,0x25,0x08,0x90,
+0x05,0x22,0xe4,0xf0,0x80,0x35,0xe4,0x90,0x97,0xa1,0xf0,0x7f,0x80,0x7e,0x08,0x12,
+0x22,0x65,0xec,0x54,0x03,0xfc,0xec,0x44,0xc0,0xfc,0x90,0x97,0xa3,0x12,0x25,0x08,
+0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,0x2b,0x08,0x90,0x97,0xaa,0xe0,0x90,
+0x00,0x47,0x30,0xe1,0x11,0x74,0x0c,0xf0,0xa3,0xe0,0x44,0x0c,0xf0,0x90,0x00,0x46,
+0xe0,0x44,0x10,0xf0,0x80,0x10,0xe0,0x54,0xf3,0xf0,0xa3,0xe0,0x54,0xf3,0xf0,0x90,
+0x00,0x46,0xe0,0x54,0xef,0xf0,0xe4,0x90,0x97,0xa7,0xf0,0x22,0xd3,0x10,0xaf,0x01,
+0xc3,0xc0,0xd0,0x90,0x97,0x8a,0xed,0xf0,0x90,0x97,0x89,0xef,0xf0,0xd3,0x94,0x07,
+0x50,0x4f,0xa3,0xe0,0x70,0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,0xf0,0x80,0x17,
+0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,
+0xff,0x90,0x00,0x47,0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,0x97,0x89,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0x80,
+0x5a,0x90,0x97,0x89,0xe0,0x24,0xf8,0xf0,0xa3,0xe0,0x70,0x1d,0x90,0x97,0x89,0xe0,
+0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,
+0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x80,0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,
+0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x43,
+0xe0,0x4f,0xf0,0x12,0x7f,0x30,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7f,
+0x30,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x97,0xa9,0xe0,0x64,0x01,0x60,0x03,0x02,0x6e,
+0xe9,0x90,0x00,0x46,0xe0,0x44,0x01,0xf0,0x90,0x97,0xbb,0xe0,0x70,0x40,0x90,0x97,
+0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,0x2b,0x08,0x80,
+0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x97,0xa8,0xe0,0xff,0x12,0x79,0x11,0x90,
+0x97,0xbb,0x74,0x01,0xf0,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0x80,0x44,0x90,0x97,
+0xbb,0xe0,0x64,0x01,0x70,0x3c,0x90,0x97,0xac,0xe0,0xff,0x12,0x79,0x11,0xe4,0x90,
+0x97,0xbb,0xf0,0x90,0x00,0x45,0xe0,0x44,0x01,0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,
+0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,0x2b,0x08,0x80,0x05,0x90,0x05,0x22,
+0xe4,0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,
+0xf0,0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,
+0xf0,0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,0x22,0x90,0x97,0x81,0xeb,0xf0,0xa3,
+0xea,0xf0,0xa3,0xe9,0xf0,0xef,0x12,0x63,0xee,0x6f,0x1b,0x01,0x6f,0x29,0x02,0x6f,
+0x37,0x03,0x6f,0x45,0x05,0x6f,0x53,0x06,0x6f,0xa8,0x07,0x6f,0x61,0x09,0x6f,0x6f,
+0x0c,0x6f,0x7d,0x0d,0x6f,0x8b,0x0e,0x00,0x00,0x6f,0x99,0x90,0x97,0x81,0xe0,0xfb,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x4d,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x02,0x7f,0xb8,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xf9,0x02,0x7b,0x7f,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x02,0x7d,0x21,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x64,
+0x14,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x73,0x01,0x90,
+0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x65,0x55,0x90,0x97,0x81,
+0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7c,0xc6,0x90,0x97,0x81,0xe0,0xfb,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x6c,0x86,0xc2,0xaf,0x74,0xea,0x04,0x90,0x01,
+0xc4,0xf0,0x74,0x6e,0xa3,0xf0,0x80,0xfe,0x22,0x8f,0x67,0x8d,0x68,0xe5,0x67,0x54,
+0x0f,0xff,0x90,0x97,0xc8,0xe0,0x54,0x0f,0x6f,0x60,0x78,0xe5,0x67,0x30,0xe2,0x30,
+0x90,0x97,0xc8,0xe0,0x20,0xe2,0x05,0x7f,0x01,0x12,0x7e,0x08,0x90,0x97,0xc8,0xe0,
+0x30,0xe3,0x0a,0xe5,0x67,0x20,0xe3,0x05,0x12,0x7e,0x45,0x80,0x56,0x90,0x97,0xc8,
+0xe0,0x20,0xe3,0x4f,0xe5,0x67,0x30,0xe3,0x4a,0xaf,0x68,0x12,0x7d,0xe8,0x80,0x43,
+0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,0x0c,0x0e,0xe5,0x67,0x20,0xe3,0x09,0x12,
+0x7d,0x77,0xef,0x60,0x2e,0x12,0x7e,0x45,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,
+0x04,0x0e,0xe5,0x67,0x20,0xe2,0x09,0x12,0x7b,0xba,0xef,0x60,0x16,0x12,0x7b,0xf1,
+0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,0x02,0x09,0x12,0x7a,0xc8,0xef,0x60,0x03,
+0x12,0x7e,0x62,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0x90,0x97,0xca,0xe0,0x54,0x0f,
+0x6f,0x70,0x23,0xe0,0x30,0xe6,0x1f,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0x90,0x97,
+0xbc,0xe0,0xfe,0x4f,0x90,0x01,0x2f,0xf0,0xee,0x64,0x80,0x90,0x97,0xbc,0xf0,0x90,
+0x97,0xca,0xe0,0x54,0xbf,0xf0,0x22,0x90,0x97,0xde,0xef,0xf0,0xa3,0xed,0xf0,0xe4,
+0xa3,0xf0,0xa3,0xf0,0xe5,0x6a,0x60,0x05,0xe4,0xff,0x12,0x7e,0x9c,0x90,0x97,0xde,
+0xe0,0x30,0xe0,0x09,0x90,0x97,0xe0,0xe4,0xf0,0xa3,0x74,0x80,0xf0,0x90,0x04,0x1d,
+0xe0,0x60,0x1d,0x90,0x05,0x22,0xe0,0x90,0x97,0xe2,0xf0,0xe0,0xff,0x54,0x90,0x60,
+0xec,0x90,0x01,0xc8,0x74,0xfc,0xf0,0xef,0x54,0x6f,0x90,0x05,0x22,0xf0,0x80,0xdd,
+0x90,0x97,0xde,0xe0,0xff,0xc3,0x13,0x90,0xfd,0x10,0xf0,0x90,0x04,0x25,0xef,0xf0,
+0x90,0x97,0xdf,0xe0,0x60,0x1f,0xa3,0xa3,0xe0,0xff,0x24,0x0f,0xf5,0x82,0xe4,0x34,
+0xfc,0xf5,0x83,0xe0,0x44,0x80,0xf0,0x74,0x10,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe0,0x44,0x80,0xf0,0x90,0x97,0xe0,0xa3,0xe0,0xff,0xfd,0x24,0x08,0xf5,0x82,
+0xe4,0x34,0xfc,0xf5,0x83,0xe4,0xf0,0x74,0x09,0x2d,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe0,0x54,0xf0,0xf0,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,
+0x54,0xf7,0xf0,0x90,0x97,0xe0,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0xd3,0x10,0xaf,0x01,
+0xc3,0xc0,0xd0,0x90,0x97,0xf2,0xef,0xf0,0xd3,0x94,0x07,0x50,0x47,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0xe0,
+0x5f,0xf0,0x12,0x7f,0x30,0x90,0x97,0xf2,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,
+0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x44,0xe0,0xfb,
+0xe4,0xfe,0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,
+0xf8,0xff,0x80,0x4c,0x90,0x97,0xf2,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,
+0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,
+0x12,0x7f,0x30,0x90,0x97,0xf2,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,
+0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x42,0xe0,0xfb,0xe4,0xfe,
+0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,
+0xd0,0xd0,0x92,0xaf,0x22,0x90,0x00,0x11,0xe0,0x44,0x09,0xf0,0x12,0x7f,0x30,0x90,
+0x97,0x5d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,
+0x12,0x25,0x08,0x7f,0x78,0x7e,0x08,0x12,0x2b,0x08,0x90,0x97,0x61,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,
+0x7e,0x0c,0x12,0x2b,0x08,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x00,0x7e,0x08,0x12,0x2b,0x08,
+0x90,0x97,0x69,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x96,0x12,0x25,0x08,0x7f,0x70,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x68,0x12,0x25,
+0x14,0x00,0x03,0x2d,0x95,0xe4,0xfd,0xff,0x12,0x30,0x2c,0x90,0x97,0xd7,0xe0,0xb4,
+0x01,0x11,0x90,0x80,0x68,0x12,0x25,0x14,0x00,0x03,0x2d,0x95,0xe4,0xfd,0x7f,0x01,
+0x12,0x30,0x2c,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0x70,0xeb,0xf0,
+0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,0x97,0xd6,0xe0,0x64,0x02,0x60,0x7e,0x90,0x01,
+0xaf,0xe0,0x60,0x09,0x90,0x01,0xc7,0xe0,0x04,0xf0,0xf0,0x80,0xf1,0x90,0x97,0xe3,
+0xe0,0xff,0x04,0xf0,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,
+0x00,0x01,0xef,0x12,0x62,0xd4,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0x8b,0x63,0x8a,0x64,0xf5,0x65,0x75,0x66,0x02,0x7b,0x01,0x7a,0x01,0x79,0xa0,0x12,
+0x77,0xae,0x90,0x97,0x73,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x63,0x8a,0x64,
+0xf5,0x65,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x12,0x24,0x62,
+0xff,0xc4,0x54,0x0f,0xf5,0x66,0x7b,0x01,0x7a,0x01,0x79,0xa2,0x12,0x77,0xae,0x90,
+0x01,0xaf,0x74,0xff,0xf0,0x90,0x01,0xcb,0xe0,0x64,0x80,0xf0,0xd0,0xd0,0x92,0xaf,
+0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,
+0xa3,0xe9,0xf0,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,
+0x01,0x12,0x63,0x4d,0xfa,0xe5,0xf0,0x24,0x00,0xff,0xe4,0x3a,0xfe,0x90,0x97,0x84,
+0xa3,0xe0,0xfa,0x90,0x00,0x01,0xee,0x8f,0xf0,0x12,0x63,0xa4,0x12,0x24,0x62,0xff,
+0x60,0x37,0xb5,0x22,0x1b,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x90,0x00,0x01,0x12,0x63,0x4d,0x65,0x24,0x70,0x04,0xe5,0x23,0x65,0xf0,0x60,0x2e,
+0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,
+0x4d,0xff,0xae,0xf0,0x12,0x79,0xfa,0x80,0x15,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x12,0x24,0x62,0x65,0x22,0x60,0x03,0x12,0x7f,0x97,0xd0,0xd0,
+0x92,0xaf,0x22,0xef,0x64,0x01,0x70,0x34,0x7d,0x7d,0x7f,0x02,0x12,0x31,0x2c,0x7d,
+0x02,0x7f,0x03,0x12,0x31,0x2c,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,
+0xf0,0x7d,0x01,0x7f,0x0c,0x12,0x6f,0xa9,0xe4,0xff,0x12,0x7e,0x9c,0x90,0x06,0x04,
+0xe0,0x54,0x7f,0xf0,0x90,0x06,0x0a,0xe0,0x54,0xf8,0xf0,0x22,0x90,0x01,0x36,0x74,
+0x7d,0xf0,0xa3,0x74,0x02,0xf0,0x7d,0x7d,0xff,0x12,0x31,0x9d,0x7d,0x02,0x7f,0x03,
+0x12,0x31,0x9d,0x90,0x06,0x04,0xe0,0x44,0x80,0xf0,0x90,0x06,0x0a,0xe0,0x44,0x07,
+0xf0,0x90,0x97,0xc3,0xe0,0xa3,0xe0,0x90,0x05,0x58,0xf0,0xe5,0x69,0x30,0xe0,0x1b,
+0x90,0x97,0xc0,0xe0,0x70,0x1a,0xe0,0x04,0xf0,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,
+0x94,0x04,0x50,0x0c,0x7d,0x01,0x7f,0x04,0x02,0x6f,0xa9,0xe4,0x90,0x97,0xc0,0xf0,
+0x22,0xef,0x14,0x60,0x20,0x14,0x60,0x4b,0x24,0x02,0x70,0x78,0x90,0x97,0xa7,0x74,
+0x02,0xf0,0x90,0x00,0x48,0xe0,0x44,0x0c,0xf0,0x90,0x00,0x47,0xe0,0x44,0x08,0xf0,
+0x90,0x00,0x45,0x80,0x5b,0xe4,0x90,0x97,0xa7,0xf0,0x90,0x97,0xa3,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,
+0x7e,0x08,0x12,0x2b,0x08,0x90,0x00,0x45,0xe0,0x44,0xef,0xf0,0xe0,0x54,0xef,0xf0,
+0xa3,0x80,0x2d,0x90,0x97,0xa7,0x74,0x01,0xf0,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,
+0x08,0x12,0x2b,0x08,0x90,0x00,0x45,0xe0,0x44,0x20,0xf0,0xe0,0x44,0x10,0xf0,0xa3,
+0xe0,0x44,0x10,0xf0,0x22,0x02,0x74,0xe3,0x02,0x67,0xb0,0xe4,0x93,0xa3,0xf8,0xe4,
+0x93,0xa3,0x40,0x03,0xf6,0x80,0x01,0xf2,0x08,0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,
+0xf8,0x54,0x07,0x24,0x0c,0xc8,0xc3,0x33,0xc4,0x54,0x0f,0x44,0x20,0xc8,0x83,0x40,
+0x04,0xf4,0x56,0x80,0x01,0x46,0xf6,0xdf,0xe4,0x80,0x0b,0x01,0x02,0x04,0x08,0x10,
+0x20,0x40,0x80,0x90,0x7f,0x0e,0xe4,0x7e,0x01,0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,
+0x30,0xe5,0x09,0x54,0x1f,0xfe,0xe4,0x93,0xa3,0x60,0x01,0x0e,0xcf,0x54,0xc0,0x25,
+0xe0,0x60,0xa8,0x40,0xb8,0xe4,0x93,0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,
+0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,
+0x83,0xca,0xdf,0xe9,0xde,0xe7,0x80,0xbe,0xe4,0x90,0x97,0x6e,0xf0,0xe5,0x6a,0x60,
+0x71,0xe5,0x69,0x64,0x01,0x70,0x6b,0xe5,0x6a,0x14,0x60,0x29,0x24,0xfd,0x60,0x25,
+0x24,0x02,0x24,0xfb,0x50,0x02,0x80,0x23,0x90,0x97,0xbe,0xe0,0x14,0xf0,0xe0,0x60,
+0x04,0xa3,0xe0,0x60,0x16,0x90,0x97,0xbe,0xe0,0x70,0x0a,0x90,0x97,0xc9,0xe0,0x90,
+0x97,0xbe,0xf0,0x80,0x00,0x90,0x97,0x6e,0x74,0x01,0xf0,0x90,0x97,0x6e,0xe0,0x60,
+0x31,0x90,0x97,0xcd,0xe0,0x44,0x10,0xf0,0x90,0x97,0xc5,0xe0,0xf5,0x44,0xe4,0xf5,
+0x45,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x57,0x74,0x05,0xf0,
+0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,
+0x6f,0xa9,0x22,0xab,0x07,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,
+0x34,0x93,0xf5,0x83,0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xe0,0x54,0x1f,0xfa,0xd3,0x9f,0x40,0x02,0xaa,0x07,0xea,0x25,0xe0,0x24,0x9e,0xf5,
+0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xea,0x25,0xe0,
+0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,
+0x3e,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,
+0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x25,0x08,0x74,0x84,0x2b,0xf5,0x82,
+0xe4,0x34,0x04,0xf5,0x83,0xea,0xf0,0xff,0x22,0x90,0x06,0xa9,0xe0,0xf5,0x0a,0x54,
+0xc0,0x70,0x0e,0x90,0x97,0xcd,0xe0,0x54,0xfe,0xf0,0xe0,0x54,0xfd,0xf0,0x12,0x7f,
+0x8d,0xe5,0x0a,0x30,0xe6,0x19,0x90,0x97,0xcd,0xe0,0x44,0x01,0xf0,0x90,0x97,0xcb,
+0xe0,0x64,0x02,0x60,0x05,0x12,0x7f,0x1f,0x80,0x0c,0x12,0x7b,0x06,0x80,0x07,0x90,
+0x97,0xcd,0xe0,0x54,0xfe,0xf0,0xe5,0x0a,0x90,0x97,0xcd,0x30,0xe7,0x20,0xe0,0x44,
+0x02,0xf0,0x75,0x44,0x03,0xe4,0xf5,0x45,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x30,
+0x62,0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,0xcc,0x74,0x01,0xf0,0x22,0xe0,0x54,
+0xfd,0xf0,0x22,0x8b,0x11,0x8a,0x12,0x89,0x13,0x12,0x7f,0x50,0xab,0x11,0xaa,0x12,
+0xa9,0x13,0x12,0x24,0x62,0xf5,0x6a,0x14,0x60,0x0e,0x14,0x60,0x1f,0x14,0x60,0x31,
+0x24,0x03,0x70,0x44,0x7f,0x01,0x80,0x3d,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,
+0x02,0x12,0x62,0x95,0xfd,0xe4,0xff,0x12,0x7d,0x9e,0x80,0x29,0xab,0x11,0xaa,0x12,
+0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xfd,0x7f,0x01,0x12,0x7d,0x9e,0x1f,0x80,
+0x14,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xfd,0x7f,0x02,
+0x12,0x7d,0x9e,0xe4,0xff,0x12,0x73,0x93,0x22,0x8d,0x0b,0xe5,0x0b,0x54,0x1f,0xf5,
+0x0f,0x74,0x01,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xf5,0x0e,0x90,0x04,
+0xfd,0xe0,0xb4,0x01,0x05,0x75,0x10,0x03,0x80,0x03,0x75,0x10,0x01,0xeb,0xc3,0x95,
+0x10,0x40,0x03,0x02,0x75,0xa3,0xe5,0x0e,0x25,0x0d,0xfe,0xe5,0x0f,0x90,0x41,0xd6,
+0x93,0xfd,0xee,0xd3,0x9d,0x74,0x01,0x40,0x18,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,
+0x83,0xe4,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe5,0x0b,0xf0,
+0x22,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x22,0x8e,0x11,0x8f,0x12,
+0x8b,0x13,0x8a,0x14,0x89,0x15,0xe4,0x90,0x97,0x79,0xf0,0xef,0x90,0x00,0x31,0xf0,
+0x12,0x7f,0x30,0xe5,0x11,0x54,0x03,0xff,0x90,0x00,0x32,0xe0,0x54,0xfc,0x4f,0xf0,
+0x12,0x7f,0x30,0x90,0x00,0x33,0xe0,0x54,0x7f,0xf0,0x12,0x7f,0x30,0x90,0x00,0x33,
+0xe0,0x20,0xe7,0x0e,0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x05,0xe0,0x04,0xf0,
+0x80,0xeb,0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x10,0x90,0x00,0x30,0xe0,0xab,
+0x13,0xaa,0x14,0xa9,0x15,0x12,0x62,0xc2,0x7f,0x01,0x22,0x7f,0x00,0x22,0xd3,0x10,
+0xaf,0x01,0xc3,0xc0,0xd0,0x8b,0x60,0x8a,0x61,0x89,0x62,0x90,0x97,0xd8,0xeb,0xf0,
+0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xa3,0xe5,0x63,0xf0,0xa3,0xe5,0x64,0xf0,0xa3,0xe5,
+0x65,0xf0,0xaf,0x66,0x15,0x66,0xef,0x60,0x2a,0x90,0x97,0xdb,0xe0,0xfb,0xa3,0xe4,
+0x75,0xf0,0x01,0x12,0x63,0x0c,0xa9,0xf0,0xfa,0x12,0x24,0x62,0xff,0x90,0x97,0xd8,
+0xe0,0xfb,0xa3,0xe4,0x75,0xf0,0x01,0x12,0x63,0x0c,0xa9,0xf0,0xfa,0xef,0x12,0x62,
+0xc2,0x80,0xcf,0xab,0x60,0xaa,0x61,0xa9,0x62,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x00,
+0x45,0xe4,0xf0,0x90,0x04,0xfd,0xf0,0xa3,0xf0,0x90,0x97,0xab,0xf0,0x90,0x97,0xb1,
+0xf0,0x90,0x97,0xb4,0xf0,0x90,0x97,0xb2,0xf0,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb3,
+0xf0,0x90,0x97,0xb6,0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,
+0xf0,0x90,0x97,0xa2,0xf0,0x90,0x97,0xa7,0xf0,0x90,0x97,0xa9,0xf0,0x90,0x97,0xbb,
+0xf0,0x90,0x97,0xac,0xf0,0x90,0x97,0xa8,0xf0,0x90,0x97,0xa1,0xf0,0x90,0x00,0x51,
+0xe0,0x44,0xc0,0xf0,0x22,0x90,0x00,0x2b,0xe0,0x44,0x01,0xf0,0x7f,0xe8,0x7e,0x03,
+0x12,0x32,0x15,0x90,0x00,0x08,0xe0,0x44,0x10,0xfd,0x7f,0x08,0x12,0x7f,0x83,0x90,
+0x00,0x09,0xe0,0x54,0xf7,0xfd,0x7f,0x09,0x12,0x7f,0x83,0x90,0x00,0x28,0xe0,0x54,
+0xfe,0xfd,0x7f,0x28,0x12,0x7f,0x83,0x90,0x00,0x20,0xe0,0x54,0xfe,0xfd,0x7f,0x20,
+0x12,0x7f,0x83,0x90,0x00,0x25,0xe0,0x44,0x40,0xfd,0x7f,0x25,0x12,0x7f,0x83,0x90,
+0x00,0x09,0xe0,0x54,0xef,0xfd,0x7f,0x09,0x02,0x7f,0x83,0x90,0x00,0x25,0xe0,0x54,
+0xbf,0xfd,0x7f,0x25,0x12,0x7f,0x83,0x90,0x00,0x20,0xe0,0x44,0x01,0xfd,0x7f,0x20,
+0x12,0x7f,0x83,0x90,0x00,0x28,0xe0,0x44,0x01,0xfd,0x7f,0x28,0x12,0x7f,0x83,0x90,
+0x00,0xf0,0xe0,0x30,0xe1,0xf9,0x90,0x00,0x09,0xe0,0x44,0x08,0xfd,0x7f,0x09,0x12,
+0x7f,0x83,0x90,0x00,0x08,0xe0,0x54,0xef,0xfd,0x7f,0x08,0x12,0x7f,0x83,0x90,0x00,
+0x2b,0xe0,0x54,0xfe,0xfd,0x7f,0x2b,0x12,0x7f,0x83,0x7f,0xe8,0x7e,0x03,0x02,0x32,
+0x15,0x90,0x05,0x60,0xe0,0x90,0x97,0xb7,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,
+0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0xb9,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0xba,
+0xf0,0xc3,0x74,0xff,0x9f,0xfe,0x90,0x97,0xb8,0xe0,0xd3,0x9e,0x40,0x1e,0xe0,0x2f,
+0xf0,0xa3,0xe0,0xb4,0xff,0x0f,0xe4,0xf0,0xa3,0xe0,0xb4,0xff,0x03,0xe4,0xf0,0x22,
+0x90,0x97,0xba,0x80,0x03,0x90,0x97,0xb9,0xe0,0x04,0xf0,0x22,0x90,0x97,0xb8,0xe0,
+0x2f,0xf0,0x22,0xe4,0xf5,0x69,0x90,0x97,0xcd,0xf0,0xf5,0x6a,0x90,0x97,0xca,0x74,
+0x0c,0xf0,0x90,0x97,0xc8,0xf0,0xe4,0x90,0x97,0xcb,0xf0,0x90,0x97,0xc7,0xf0,0x90,
+0x97,0xc6,0xf0,0x90,0x97,0xc9,0x04,0xf0,0x90,0x97,0xbe,0xf0,0xe4,0x90,0x97,0xcc,
+0xf0,0x90,0x97,0xc0,0xf0,0x90,0x97,0xc5,0x74,0x07,0xf0,0xe4,0x90,0x97,0xbf,0xf0,
+0x90,0x97,0xc3,0xf0,0xa3,0x74,0x02,0xf0,0xe4,0x90,0x97,0xc2,0xf0,0x90,0x97,0xbd,
+0xf0,0x22,0xe4,0x90,0x97,0xd5,0xf0,0xa2,0xaf,0x33,0x90,0x97,0x7a,0xf0,0x90,0x00,
+0x80,0xe0,0x20,0xe1,0x1a,0x12,0x32,0x2b,0x12,0x32,0x2b,0x90,0x97,0x79,0xe0,0x64,
+0x01,0xf0,0xe0,0x24,0xb2,0x90,0x01,0xc4,0xf0,0x74,0x79,0xa3,0xf0,0x80,0xdf,0x90,
+0x06,0x30,0x74,0x01,0xf0,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x80,0xf0,0x12,0x7f,
+0x30,0x90,0x97,0x7a,0xe0,0x24,0xff,0x92,0xaf,0x22,0x90,0x97,0x87,0xee,0xf0,0xa3,
+0xef,0xf0,0x75,0x22,0x01,0x8e,0x23,0xf5,0x24,0xe4,0xfd,0x7f,0x0b,0x12,0x6d,0x5c,
+0xe4,0xfd,0x7f,0x02,0x12,0x6d,0x5c,0x12,0x7e,0x7f,0xe4,0xff,0x12,0x7f,0x6c,0xe4,
+0xf5,0x26,0x90,0x01,0xc9,0xe5,0x26,0xf0,0x90,0x97,0x87,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xec,0xfb,0x8d,0x44,0xe4,0xf5,0x45,0x7d,0x01,0x7f,0x60,0x7e,0x01,0x02,0x30,0x62,
+0xe4,0x90,0x97,0xeb,0xf0,0xa3,0xf0,0x90,0x05,0xf8,0xe0,0x70,0x0f,0xa3,0xe0,0x70,
+0x0b,0xa3,0xe0,0x70,0x07,0xa3,0xe0,0x70,0x03,0x7f,0x01,0x22,0xd3,0x90,0x97,0xec,
+0xe0,0x94,0xe8,0x90,0x97,0xeb,0xe0,0x94,0x03,0x40,0x03,0x7f,0x00,0x22,0x7f,0x32,
+0x7e,0x00,0x12,0x32,0x15,0x90,0x97,0xec,0xe0,0x04,0xf0,0x70,0xca,0x90,0x97,0xeb,
+0xe0,0x04,0xf0,0x80,0xc2,0xe5,0x22,0x64,0x01,0x70,0x3c,0x12,0x7e,0x7f,0xbf,0x01,
+0x05,0x7f,0x01,0x12,0x7f,0x6c,0x90,0x00,0x46,0xe0,0x44,0x04,0xf0,0x12,0x7f,0x30,
+0x90,0x00,0x44,0xe0,0x54,0xfb,0xf0,0x12,0x7f,0x30,0x90,0x00,0x46,0xe0,0x54,0xfb,
+0xf0,0x12,0x7f,0x30,0x7f,0x02,0x12,0x71,0x1c,0x8f,0x26,0x90,0x01,0xc9,0xe5,0x26,
+0xf0,0xb4,0x01,0x03,0x12,0x7e,0xb7,0x22,0xe5,0x57,0x70,0x37,0x90,0x97,0xca,0xe0,
+0x54,0x0f,0xd3,0x94,0x01,0x50,0x2c,0x90,0x02,0x87,0xe0,0x70,0x26,0x90,0x97,0xd6,
+0xe0,0xb4,0x02,0x10,0x90,0x97,0xce,0xe0,0xfe,0xa3,0xe0,0xf5,0x82,0x8e,0x83,0xe0,
+0x60,0x08,0x80,0x0f,0x90,0x01,0xaf,0xe0,0x70,0x09,0x90,0x97,0xc2,0xe0,0x60,0x03,
+0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x01,0x5f,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x08,
+0xf0,0x75,0x44,0x14,0xe4,0xf5,0x45,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,0x30,0x62,
+0x90,0x01,0x5f,0x74,0x05,0xf0,0x90,0x06,0x92,0x74,0x02,0xf0,0x90,0x97,0xc6,0x14,
+0xf0,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,0x94,0x0c,0x50,0x07,0x7d,0x01,0x7f,0x0c,
+0x12,0x6f,0xa9,0x22,0x90,0x97,0xcc,0xe0,0x60,0x0e,0xe4,0xf0,0xa3,0xe0,0x54,0xfd,
+0xf0,0xe0,0x54,0x07,0x70,0x28,0x80,0x23,0x90,0x97,0xbf,0xe0,0x04,0xf0,0x90,0x97,
+0xcd,0xe0,0x54,0xef,0xf0,0x90,0x97,0xbf,0xe0,0xd3,0x94,0x01,0x40,0x0d,0xe5,0x69,
+0xb4,0x01,0x0b,0xa3,0xe0,0x70,0x07,0xe0,0x04,0xf0,0x22,0x12,0x7f,0x8d,0x22,0x90,
+0x02,0x09,0xe0,0xfd,0x12,0x24,0x62,0xfe,0xaf,0x05,0xed,0x2e,0x90,0x97,0xd1,0xf0,
+0x90,0x00,0x01,0x12,0x62,0x95,0xff,0xed,0x2f,0x90,0x97,0xd2,0xf0,0x90,0x00,0x02,
+0x12,0x62,0x95,0xff,0xed,0x2f,0x90,0x97,0xd3,0xf0,0x90,0x00,0x03,0x12,0x62,0x95,
+0xff,0xae,0x05,0xed,0x2f,0x90,0x97,0xd4,0xf0,0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,
+0x64,0x7f,0x70,0x2a,0x90,0x97,0xcd,0xe0,0x54,0x03,0x70,0x22,0x90,0x97,0xca,0xe0,
+0x54,0x0f,0xd3,0x94,0x02,0x50,0x17,0x90,0x97,0xcd,0xe0,0x20,0xe2,0x10,0x90,0x97,
+0xcd,0xe0,0x20,0xe4,0x09,0x90,0x97,0xc0,0xe0,0x70,0x03,0x7f,0x01,0x22,0x7f,0x00,
+0x22,0x90,0x01,0x37,0x74,0x02,0xf0,0x90,0x05,0x22,0x74,0xff,0xf0,0x12,0x7a,0x40,
+0xef,0x70,0x06,0x90,0x01,0xc8,0x74,0xfd,0xf0,0x7d,0x02,0x7f,0x03,0x12,0x31,0x9d,
+0xe5,0x6a,0x60,0x05,0x7f,0x01,0x12,0x7e,0x9c,0x12,0x6a,0xc2,0x90,0x97,0xc8,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x8f,0x27,0x90,0x97,0xd3,0xe0,0xff,0x7d,
+0x01,0x12,0x70,0x67,0xe5,0x27,0x60,0x10,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,
+0xf5,0x83,0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,
+0xf5,0x83,0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x8f,0x6b,0x90,
+0x97,0xd4,0xe0,0xff,0x7d,0x01,0x12,0x70,0x67,0xe5,0x6b,0x60,0x10,0x74,0x21,0x2f,
+0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,
+0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,
+0xf0,0x22,0x7d,0x02,0x7f,0x03,0x12,0x31,0x2c,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,
+0x80,0x23,0x90,0x97,0xcb,0xe0,0x60,0x06,0x7d,0x01,0x7f,0x0c,0x80,0x0f,0x90,0x97,
+0xc8,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xa9,
+0xe4,0xff,0x12,0x7e,0x9c,0x22,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x97,0xab,0xf0,
+0xe0,0x60,0x04,0xe0,0xb4,0xff,0x1c,0xa2,0xaf,0xe4,0x33,0xf5,0x11,0xc2,0xaf,0x90,
+0x00,0x47,0xe0,0x54,0xfb,0xf0,0x7d,0x40,0x7f,0x01,0x12,0x31,0x66,0xe5,0x11,0x24,
+0xff,0x92,0xaf,0x22,0x90,0x06,0x34,0xe0,0x60,0x26,0x14,0x70,0x1b,0x7b,0x01,0x7a,
+0x06,0x79,0x35,0x7f,0xf9,0x7e,0x01,0x12,0x77,0x4c,0xbf,0x01,0x09,0x90,0x06,0x35,
+0xe0,0x54,0x0f,0xf0,0x80,0x05,0x80,0x00,0x02,0x7f,0x5e,0xe4,0x90,0x06,0x34,0xf0,
+0x22,0x12,0x24,0x62,0xff,0xc3,0x94,0x20,0x50,0x14,0x90,0x00,0x02,0x12,0x62,0x95,
+0xfe,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xee,0xf0,0x22,0xef,0xb4,
+0x20,0x0a,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x93,0x61,0xf0,0x22,0xd3,0x10,0xaf,
+0x01,0xc3,0xc0,0xd0,0x90,0x00,0x01,0x12,0x62,0x95,0x90,0x97,0xcb,0xf0,0x90,0x00,
+0x03,0x12,0x62,0x95,0x90,0x97,0xbd,0xf0,0x12,0x24,0x62,0x65,0x6a,0x60,0x03,0x12,
+0x76,0x83,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,0xff,0xbf,0x7f,
+0x1a,0x90,0x97,0xc7,0xe0,0x70,0x14,0x90,0x97,0xc6,0xe0,0x70,0x0e,0x90,0x97,0xca,
+0xe0,0x54,0x0f,0xd3,0x94,0x04,0x50,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0xef,0x24,
+0xfe,0x60,0x0b,0x04,0x70,0x1d,0x90,0x97,0xc9,0x74,0x01,0xf0,0x80,0x11,0xed,0x90,
+0x97,0xc9,0x70,0x05,0x74,0x05,0xf0,0x80,0x02,0xed,0xf0,0x90,0x97,0xc9,0xe0,0x90,
+0x97,0xbe,0xf0,0x22,0x90,0x97,0x6e,0xe0,0x54,0xf0,0x44,0x03,0xf0,0x54,0x0f,0x44,
+0x80,0xf0,0x90,0x97,0x73,0xe4,0xf0,0xa3,0x74,0x00,0xf0,0xa3,0x74,0x58,0xf0,0x7b,
+0x01,0x7a,0x97,0x79,0x6e,0x02,0x72,0x64,0x90,0x06,0x04,0xe0,0x54,0xbf,0xf0,0xef,
+0x60,0x0a,0xe5,0x69,0xb4,0x01,0x05,0xe4,0xff,0x12,0x7c,0x28,0x90,0x97,0xc8,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x0c,0xf0,0x22,0x90,0x97,0xf0,0xef,0xf0,0x12,0x71,0xc5,
+0x90,0x97,0xf0,0xe0,0x60,0x05,0x90,0x05,0x22,0xe4,0xf0,0x90,0x97,0xc8,0xe0,0x54,
+0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x75,0x28,0x33,0xe4,0xf5,0x29,0x75,0x2a,0x02,
+0xf5,0x2b,0x90,0x01,0x30,0xe5,0x28,0xf0,0xa3,0xe5,0x29,0xf0,0xa3,0xe5,0x2a,0xf0,
+0xa3,0xe5,0x2b,0xf0,0x22,0x90,0x06,0x04,0xe0,0x44,0x40,0xf0,0xe5,0x69,0xb4,0x01,
+0x05,0x7f,0x01,0x12,0x7c,0x28,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x04,
+0xf0,0x22,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x01,0xf0,0x12,0x78,0x65,
+0x12,0x78,0xbb,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x7f,
+0x0b,0x12,0x71,0x1c,0xef,0x65,0x25,0x60,0x10,0xe5,0x25,0xb4,0x01,0x05,0xe4,0xf5,
+0x25,0x80,0x03,0x75,0x25,0x01,0x7f,0x01,0x22,0x7f,0x00,0x22,0xef,0x60,0x0b,0x90,
+0x97,0xd7,0xe0,0xb4,0x01,0x10,0xe4,0xff,0x80,0x09,0x90,0x97,0xd7,0xe0,0xb4,0x01,
+0x05,0x7f,0x01,0x12,0x4e,0x3f,0x22,0x90,0x00,0x49,0xe0,0x90,0x97,0xf1,0xf0,0xe0,
+0x54,0x0f,0xf0,0xe0,0xff,0x44,0xf0,0x90,0x00,0x49,0xf0,0xef,0x44,0xb0,0xf0,0x22,
+0x75,0x30,0x1e,0x75,0x31,0x01,0xe4,0xf5,0x32,0x90,0x01,0x38,0xe5,0x30,0xf0,0xa3,
+0xe5,0x31,0xf0,0xa3,0xe5,0x32,0xf0,0x22,0x90,0x01,0x3c,0x74,0xff,0xf0,0xa3,0xf0,
+0xa3,0xf0,0x90,0x01,0x34,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x02,0x09,
+0xe0,0xff,0x7d,0x01,0x12,0x70,0x67,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x41,0x97,
+0xd0,0x00,0x41,0x97,0xef,0x00,0x41,0x97,0xbc,0x80,0x41,0x97,0xe3,0x00,0x00,0x90,
+0x97,0xd2,0xe0,0xff,0xe4,0xfd,0x12,0x70,0x67,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,
+0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x7f,0x10,0xdf,0xfe,0xd0,0xd0,0x92,0xaf,0x22,
+0x90,0x09,0x28,0xef,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,
+0xe4,0x90,0x97,0xcc,0xf0,0x90,0x97,0xbf,0xf0,0x90,0x97,0xcd,0xf0,0x22,0x90,0x06,
+0x34,0x74,0xff,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x01,0xca,0xe5,
+0x25,0xf0,0xef,0x60,0x03,0x12,0x7e,0xb7,0x22,0x8f,0x82,0x8e,0x83,0xa3,0xa3,0xa3,
+0xe4,0xf0,0x22,0x8f,0x82,0x75,0x83,0x00,0xed,0xf0,0x02,0x7f,0x30,0x90,0x97,0xca,
+0xe0,0xff,0x7d,0x01,0x02,0x6f,0xa9,0xe4,0xf5,0x22,0x7f,0x60,0x7e,0x01,0x02,0x7f,
+0x79,0x90,0x97,0xd7,0xe0,0x90,0x97,0x6d,0xf0,0x22,0x8f,0x1c,0x8c,0x1d,0x8d,0x1e,
+0x22,0x8f,0x1f,0x8c,0x20,0x8d,0x21,0x22,0x12,0x24,0x62,0xf5,0x69,0x22,0x8d,0x08,
+};
+#else
+// =================== UMC A Cut V66 2011-02-10 ======================
+u8 Rtl8192CUFwUMCACutImgArray[UMCACutImgArrayLength] = {
+0xc1,0x88,0x02,0x00,0x42,0x00,0x00,0x00,0x01,0x27,0x14,0x08,0x42,0x3f,0x01,0x00,
+0x15,0x49,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x02,0x74,0xaf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x59,0x7b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x44,0x68,0x00,0x00,0x00,0x00,0x00,0x02,0x66,0x69,0x00,0x00,
+0x05,0x04,0x03,0x02,0x00,0x03,0x06,0x05,0x04,0x03,0x00,0x04,0x06,0x05,0x04,0x02,
+0x00,0x04,0x08,0x07,0x06,0x04,0x00,0x06,0x0a,0x09,0x08,0x06,0x00,0x08,0x0a,0x09,
+0x08,0x04,0x00,0x08,0x0a,0x09,0x08,0x02,0x00,0x08,0x0a,0x09,0x08,0x00,0x00,0x08,
+0x12,0x11,0x10,0x08,0x00,0x10,0x1a,0x19,0x18,0x10,0x00,0x18,0x22,0x21,0x20,0x18,
+0x00,0x20,0x22,0x21,0x20,0x10,0x00,0x20,0x22,0x21,0x20,0x08,0x00,0x20,0x22,0x21,
+0x1c,0x08,0x00,0x20,0x22,0x21,0x14,0x08,0x00,0x20,0x22,0x20,0x18,0x08,0x00,0x20,
+0x31,0x30,0x20,0x10,0x00,0x30,0x31,0x30,0x18,0x00,0x00,0x30,0x31,0x2f,0x10,0x10,
+0x00,0x30,0x31,0x2c,0x10,0x10,0x00,0x30,0x31,0x28,0x10,0x00,0x00,0x30,0x31,0x20,
+0x10,0x00,0x00,0x30,0x31,0x10,0x10,0x00,0x00,0x30,0x04,0x04,0x04,0x05,0x04,0x04,
+0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,
+0x05,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x07,0x0a,0x0b,
+0x0d,0x10,0x04,0x05,0x05,0x06,0x06,0x09,0x0c,0x11,0x08,0x08,0x09,0x09,0x0a,0x0c,
+0x10,0x11,0x04,0x04,0x04,0x05,0x04,0x04,0x05,0x07,0x07,0x07,0x08,0x0a,0x04,0x04,
+0x04,0x04,0x06,0x0a,0x0c,0x0d,0x05,0x05,0x07,0x07,0x08,0x0b,0x0e,0x0f,0x04,0x04,
+0x04,0x05,0x07,0x07,0x09,0x09,0x0c,0x0e,0x10,0x12,0x04,0x04,0x05,0x05,0x06,0x0a,
+0x11,0x13,0x09,0x09,0x09,0x09,0x0c,0x0e,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x24,0x26,0x2a,0x18,0x1a,0x1d,0x1f,0x21,0x27,0x29,0x2a,0x00,0x00,
+0x00,0x1f,0x23,0x28,0x2a,0x2c,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x18,
+0x00,0x24,0x00,0x30,0x00,0x48,0x00,0x60,0x00,0x90,0x00,0xc0,0x00,0xd8,0x00,0x50,
+0x00,0x78,0x00,0xa0,0x00,0xc8,0x01,0x40,0x01,0x90,0x01,0xe0,0x02,0x30,0x01,0x2c,
+0x01,0x40,0x01,0xe0,0x02,0xd0,0x03,0xe8,0x04,0xb0,0x06,0x40,0x07,0xd0,0x00,0x02,
+0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x0c,0x00,0x12,0x00,0x18,0x00,0x24,0x00,0x30,
+0x00,0x48,0x00,0x60,0x00,0x6c,0x00,0x28,0x00,0x3c,0x00,0x50,0x00,0x64,0x00,0xa0,
+0x00,0xc8,0x00,0xf0,0x01,0x18,0x00,0x64,0x00,0xa0,0x00,0xf0,0x01,0x68,0x01,0xf4,
+0x02,0x58,0x03,0x20,0x03,0xe8,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x04,0x04,
+0x05,0x07,0x04,0x04,0x07,0x0a,0x0a,0x0c,0x0c,0x12,0x05,0x07,0x07,0x08,0x0b,0x12,
+0x24,0x3c,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x01,0x02,
+0x03,0x04,0x05,0x06,0x07,0x08,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x22,0x1f,
+0x1e,0x18,0x10,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xab,0x07,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,
+0x97,0x92,0xf0,0xe0,0x54,0x1f,0xa3,0xf0,0xfa,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xf9,0x90,0x97,0x95,0xf0,0xeb,0x25,
+0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,
+0x96,0xcf,0xf0,0xa3,0xef,0xf0,0xeb,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,0x98,0xcf,0xf0,0xa3,0xef,0xf0,0xea,0x25,
+0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x25,0x08,0xea,0xc3,0x99,0x40,0x03,0x02,0x43,0x59,0x90,0x97,0x93,
+0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0xef,0x04,
+0x90,0x97,0x94,0xf0,0x90,0x97,0x95,0xe0,0xff,0x90,0x97,0x94,0xe0,0xfe,0xd3,0x9f,
+0x40,0x03,0x02,0x43,0x98,0xee,0xc3,0x94,0x10,0x40,0x21,0xee,0x24,0xf0,0xff,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0x90,0x97,0x96,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,0x90,0x97,0x94,0xe0,
+0xff,0xc3,0x94,0x10,0x50,0x4a,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x98,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x2d,0x90,0x97,0x94,0xe0,0xff,0x64,0x13,0x60,0x09,0xef,0x64,0x12,0x60,
+0x04,0xef,0xb4,0x11,0x0d,0x90,0x97,0x96,0xe0,0x30,0xe0,0x06,0x90,0x97,0x94,0x74,
+0x18,0xf0,0x90,0x97,0x94,0xe0,0x90,0x97,0x93,0xf0,0x90,0x97,0x92,0xf0,0x80,0x48,
+0x90,0x97,0x94,0xe0,0x04,0xf0,0x02,0x42,0xc4,0x90,0x97,0x95,0xe0,0xfa,0x90,0x97,
+0x93,0xe0,0xff,0x6a,0x70,0x79,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0xe0,0xb4,0x01,0x13,0x90,0x97,0x92,0xe0,0xff,0x30,0xe6,0x01,0x22,0x90,0x97,
+0x93,0xe0,0x44,0x40,0x90,0x97,0x92,0xf0,0x90,0x97,0x93,0xe0,0xff,0x25,0xe0,0x24,
+0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,
+0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,
+0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,
+0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x25,0x08,0x80,0x69,0x90,
+0x97,0x93,0xe0,0xd3,0x9a,0x40,0x61,0x90,0x97,0x95,0xe0,0xff,0x74,0xe5,0x2b,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x93,0xef,0xf0,0x90,0x97,0x92,
+0xf0,0xfa,0xa3,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,
+0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,
+0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x25,0x08,0xaf,0x02,0x22,0x74,0x01,0x2b,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0xe4,0xf0,0x90,0x97,0x92,0xe0,0x44,0x80,0xff,0x74,0x84,0x2b,0xf5,0x82,
+0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,0x82,
+0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,0xc0,
+0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x68,0xf0,0x74,0x44,0xa3,0xf0,0x53,
+0x91,0xef,0x90,0x00,0x51,0xe0,0xff,0x90,0x00,0x55,0xe0,0x5f,0xf5,0x3d,0xe5,0x3d,
+0x30,0xe6,0x18,0x74,0x40,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,0xff,0xbf,0x03,0x0b,
+0x90,0x97,0xa7,0xe0,0x60,0x05,0x7f,0x01,0x12,0x74,0x2b,0xe5,0x3d,0x30,0xe7,0x15,
+0x90,0x00,0x55,0x74,0x80,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,0xff,0xbf,0x03,0x05,
+0x7f,0x02,0x12,0x74,0x2b,0x90,0x01,0xc4,0x74,0x68,0xf0,0x74,0x44,0xa3,0xf0,0xd0,
+0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,
+0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x90,0x97,0xd5,0xe0,0x90,0x97,
+0x6d,0xf0,0x22,0x02,0x7f,0x26,0x02,0x7f,0x2d,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xff,0xc3,0x94,0x20,0x40,0x03,0x02,0x4e,0x3e,0x75,0xf0,0x09,0xef,0xa4,
+0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x4e,0x35,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,0x00,0xec,0x94,0x00,0x50,0x03,0x02,0x4e,0x35,
+0xef,0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf9,0x74,0x90,0x35,0xf0,0xfa,0x7b,0x01,0x8b,
+0x14,0xf5,0x15,0x89,0x16,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,
+0x34,0x91,0xf5,0x83,0xe0,0xfd,0xa3,0xe0,0x90,0x97,0x85,0xcd,0xf0,0xa3,0xed,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0xff,0xa3,0xe0,
+0x90,0x97,0x87,0xcf,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x02,0x12,0x63,0x20,0xff,0xae,
+0xf0,0x12,0x62,0xf5,0x2f,0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8e,0xf0,0xa3,0xef,0xf0,
+0x90,0x00,0x06,0x12,0x63,0x20,0xff,0xae,0xf0,0x90,0x00,0x04,0x12,0x63,0x20,0x2f,
+0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8c,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x08,0x12,0x63,
+0x20,0xff,0x90,0x97,0x8a,0xe5,0xf0,0xf0,0xa3,0xef,0xf0,0x90,0x97,0x79,0xe0,0xfe,
+0x24,0x84,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x3f,0x90,0x97,0x7b,0xf0,
+0xe0,0xfd,0x54,0x1f,0xa3,0xf0,0x75,0xf0,0x09,0xee,0xa4,0x24,0x67,0xf5,0x82,0xe5,
+0xf0,0x34,0x93,0xf5,0x83,0xe0,0x90,0x97,0x90,0xf0,0x90,0x97,0x79,0xe0,0xfb,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xc3,0x94,0x05,0x40,0x03,0x02,0x49,
+0xba,0x90,0x97,0x90,0xe0,0xfe,0x90,0x97,0x7c,0xe0,0x9e,0x40,0x13,0x90,0x97,0x90,
+0xe0,0x90,0x97,0x7c,0xf0,0xed,0x54,0x40,0xfd,0x90,0x97,0x7b,0xf0,0xee,0x4d,0xf0,
+0x90,0x04,0xfd,0xe0,0x64,0x01,0x70,0x28,0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,
+0x93,0xfe,0x74,0x63,0x2b,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,
+0x06,0xef,0x90,0x40,0xda,0x80,0x32,0x90,0x97,0x7c,0xe0,0x90,0x40,0xf6,0x80,0x29,
+0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,0x93,0xfe,0x90,0x97,0x79,0xe0,0x24,0x63,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,0x06,0xef,0x90,0x41,0x12,
+0x80,0x07,0x90,0x97,0x7c,0xe0,0x90,0x41,0x2e,0x93,0x90,0x97,0x89,0xf0,0x90,0x97,
+0x89,0xe0,0x75,0xf0,0x06,0xa4,0x24,0x50,0xf9,0x74,0x40,0x35,0xf0,0x75,0x11,0xff,
+0xf5,0x12,0x89,0x13,0x90,0x97,0x7b,0xe0,0x90,0x41,0xf2,0x93,0xff,0xd3,0x90,0x97,
+0x88,0xe0,0x9f,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x0d,0x90,0x97,0x79,0xe0,0xff,
+0xe4,0xfd,0x12,0x5f,0x29,0x02,0x4d,0xcb,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,
+0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,0xf8,0xa3,
+0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x24,0x62,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,
+0xa9,0x16,0x12,0x62,0xf5,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,
+0xaa,0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x68,0xff,0x7e,0x00,0xab,0x14,0xaa,
+0x15,0xa9,0x16,0x90,0x00,0x02,0x12,0x63,0x20,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,
+0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,
+0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,
+0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,
+0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x68,0xff,0x7e,
+0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x04,0x12,0x63,0x20,0xfd,0xac,0xf0,
+0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,
+0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x03,0x12,
+0x62,0x68,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x06,0x12,0x63,
+0x20,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,
+0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,
+0x7d,0x12,0x25,0x08,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,
+0x90,0x00,0x04,0x12,0x62,0x68,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,
+0x00,0x08,0x12,0x63,0x20,0xfd,0xac,0xf0,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,
+0x05,0x12,0x62,0x68,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,
+0x24,0x7b,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xa4,0x90,0x97,0x7d,0x40,0x50,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0xab,
+0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x05,0x12,0x62,0x68,0xff,0x7e,0x00,0x90,0x97,
+0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x24,0x7b,0xab,0x07,0xaa,0x06,0xd0,0x07,0xd0,
+0x06,0xd0,0x05,0xd0,0x04,0xc3,0xef,0x9b,0xff,0xee,0x9a,0xfe,0xed,0x94,0x00,0xfd,
+0xec,0x94,0x00,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x80,0x07,0x12,0x25,0x14,0x00,
+0x00,0x00,0x00,0x90,0x97,0x7d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x25,0x08,0x90,0x97,0x7b,0xe0,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,
+0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xa4,
+0x40,0x0b,0x90,0x97,0x79,0xe0,0xff,0x12,0x42,0x20,0x02,0x4d,0x99,0x90,0x97,0x7b,
+0xe0,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,
+0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xc3,0x12,0x63,0xa4,0x40,0x03,0x02,0x4d,0x99,0x90,0x97,0x79,
+0xe0,0xff,0x7d,0x01,0x12,0x5f,0x29,0x02,0x4d,0x99,0x90,0x97,0x79,0xe0,0xff,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x64,0x05,0x60,0x03,0x02,0x4b,0xb6,
+0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,
+0x64,0x01,0x70,0x03,0x02,0x4b,0xb6,0x90,0x93,0x62,0xe0,0xff,0xb4,0x03,0x0b,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x19,0x40,0x3d,0x80,0x2e,0xef,0xb4,0x02,0x0b,0x90,0x97,
+0x7c,0xe0,0xc3,0x94,0x11,0x40,0x2e,0x80,0x1f,0x90,0x93,0x62,0xe0,0xff,0xb4,0x01,
+0x0b,0x90,0x97,0x7c,0xe0,0xc3,0x94,0x0a,0x40,0x1b,0x80,0x0c,0xef,0x70,0x11,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x03,0x40,0x0d,0x90,0x95,0x83,0x74,0x01,0xf0,0x80,0x05,
+0xe4,0x90,0x95,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0x83,0xf5,0x82,0xe4,0x34,
+0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe0,0xff,0xc3,0x94,0x30,0x50,0x03,0x02,0x4b,0x44,0x90,0x95,0x83,0xe0,
+0x64,0x01,0x60,0x03,0x02,0x4b,0x44,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,0xe4,
+0x34,0x95,0xf5,0x83,0xe0,0x64,0x0a,0x60,0x56,0x90,0x97,0x79,0xe0,0xfe,0xef,0x24,
+0x05,0xfd,0xe4,0x33,0xfc,0x74,0x21,0x2e,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,
+0xff,0xd3,0x9d,0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x33,0xef,0x24,0x05,0xfd,
+0xe4,0x33,0xfc,0x74,0x63,0x2e,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xd3,0x9d,
+0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x16,0x90,0x97,0x79,0xe0,0x24,0xc4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xff,0x90,0x97,0x7c,0xe0,0x6f,0x60,0x56,0x90,
+0x97,0x79,0xe0,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xff,0xd3,0x94,
+0x44,0x40,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x11,0xef,0xd3,0x94,0x3a,0x90,
+0x97,0x91,0x40,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0x90,0x97,0x79,0xe0,
+0xff,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xfe,0x74,0x21,0x2f,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,
+0xe4,0x34,0x95,0x80,0x2f,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,
+0x04,0xf0,0x80,0x14,0xe4,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0x24,0xa4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x7c,0xe0,0xff,0x90,0x97,0x79,
+0xe0,0xfe,0x24,0xc4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x91,
+0xe0,0xff,0x74,0x83,0x2e,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,
+0xe0,0x1e,0xef,0xc4,0x54,0xf0,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,
+0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x02,0x4d,0x7c,
+0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,
+0xe0,0x54,0xf0,0x02,0x4d,0x7c,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x96,0xf5,0x83,0xe0,0x64,0x06,0x60,0x03,0x02,0x4d,0x99,0x75,0xf0,0x09,0xef,
+0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x70,0x03,
+0x02,0x4d,0x99,0x90,0x97,0x7d,0x12,0x25,0x14,0x00,0x00,0x00,0x00,0x90,0x42,0x13,
+0xe4,0x93,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x24,0x7b,
+0xe4,0xfc,0xfd,0x90,0x97,0x81,0x12,0x25,0x08,0x90,0x97,0x79,0xe0,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0xe4,0x90,0x97,0x7a,0xf0,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x97,0x7a,0xe0,
+0xff,0x75,0xf0,0x02,0xa4,0xf5,0x82,0x85,0xf0,0x83,0x12,0x63,0x20,0xfd,0xac,0xf0,
+0xef,0x90,0x42,0x0e,0x93,0xff,0x7e,0x00,0x12,0x24,0x7b,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x25,0x08,0x90,0x97,0x81,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xa4,0x50,0x0e,0x90,0x97,0x7a,0xe0,0x04,0xf0,
+0xe0,0x64,0x05,0x60,0x03,0x02,0x4c,0x20,0x90,0x97,0x7a,0xe0,0xc3,0x13,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xb4,0x01,0x0d,0x90,0x97,0x7a,0xe0,0x70,0x5d,0x90,0x97,0x91,
+0x04,0xf0,0x80,0x5b,0xef,0xb4,0x03,0x1d,0x90,0x97,0x7a,0xe0,0xff,0x70,0x08,0x90,
+0x97,0x91,0x74,0x03,0xf0,0x80,0x48,0xef,0xb4,0x01,0x08,0x90,0x97,0x91,0x74,0x01,
+0xf0,0x80,0x3c,0x80,0x35,0x90,0x97,0x91,0xe0,0x64,0x05,0x70,0x32,0x90,0x97,0x7a,
+0xe0,0xff,0x70,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x0f,0xef,0x90,0x97,0x91,
+0xb4,0x01,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0xd3,0x90,0x97,0x88,0xe0,
+0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,0x97,0x91,0xf0,0xd3,
+0x90,0x97,0x88,0xe0,0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,
+0x97,0x91,0xf0,0x90,0x97,0x91,0xe0,0xff,0x90,0x97,0x79,0xe0,0xfe,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,0xe0,0x1d,0xef,0xc4,0x54,0xf0,
+0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x80,0x13,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0xf0,0xf0,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x90,0x97,0x91,
+0xe0,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xd3,0x94,0x05,0x50,0x0f,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x04,0xf0,0x80,0x0f,0x90,0x97,0x79,0xe0,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xab,0x14,0xaa,0x15,0xa9,
+0x16,0xe4,0xf5,0xf0,0x12,0x63,0x58,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x02,
+0xe4,0xf5,0xf0,0x12,0x63,0x77,0x90,0x00,0x04,0xe4,0xf5,0xf0,0x12,0x63,0x77,0x90,
+0x00,0x06,0xe4,0xf5,0xf0,0x12,0x63,0x77,0x90,0x00,0x08,0xe4,0xf5,0xf0,0x12,0x63,
+0x77,0x90,0x97,0x79,0xe0,0xff,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x02,0x45,0x0e,0x22,0xef,
+0x70,0x03,0x02,0x50,0xa7,0x90,0x97,0x6d,0xe0,0x60,0x03,0x02,0x54,0xe9,0x90,0x97,
+0x59,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,
+0x25,0x08,0x7f,0x8c,0x7e,0x08,0x12,0x2b,0x08,0x90,0x97,0x05,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x44,0x7e,
+0x08,0x12,0x2b,0x08,0x90,0x97,0x09,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x5c,0x7e,0x08,0x12,0x2b,0x08,0x90,
+0x97,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,
+0x12,0x25,0x08,0x7f,0x6c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x11,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x70,
+0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x15,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x74,0x7e,0x0e,0x12,0x2b,0x08,
+0x90,0x97,0x19,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x96,0x12,0x25,0x08,0x7f,0x78,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x1d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,
+0x7c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x21,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x0e,0x12,0x2b,
+0x08,0x90,0x97,0x25,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x80,0x96,0x12,0x25,0x08,0x7f,0x84,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x29,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,
+0x7f,0x88,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x2d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x8c,0x7e,0x0e,0x12,
+0x2b,0x08,0x90,0x97,0x31,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xd0,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x35,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,
+0x08,0x7f,0xd4,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x39,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xd8,0x7e,0x0e,
+0x12,0x2b,0x08,0x90,0x97,0x3d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xdc,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,
+0x41,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,
+0x25,0x08,0x7f,0xe0,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x97,0x45,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0xec,0x7e,
+0x0e,0x12,0x2b,0x08,0x90,0x97,0x49,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0c,0x12,0x2b,0x08,0x90,
+0x97,0x4d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,
+0x12,0x25,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x2b,0x08,0x90,0x97,0x51,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x0c,
+0x7e,0x09,0x12,0x2b,0x08,0x90,0x97,0x55,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x08,0x12,0x2b,0x08,
+0x90,0x97,0x6d,0x74,0x01,0xf0,0x22,0x90,0x97,0x6d,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x54,0xe9,0x7f,0x8c,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x59,0x12,0x25,0x08,0x7f,
+0x44,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x05,0x12,0x25,0x08,0x7f,0x5c,0x7e,0x08,
+0x12,0x22,0x65,0x90,0x97,0x09,0x12,0x25,0x08,0x7f,0x6c,0x7e,0x0e,0x12,0x22,0x65,
+0x90,0x97,0x0d,0x12,0x25,0x08,0x7f,0x70,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x11,
+0x12,0x25,0x08,0x7f,0x74,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x15,0x12,0x25,0x08,
+0x7f,0x78,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x19,0x12,0x25,0x08,0x7f,0x7c,0x7e,
+0x0e,0x12,0x22,0x65,0x90,0x97,0x1d,0x12,0x25,0x08,0x7f,0x80,0x7e,0x0e,0x12,0x22,
+0x65,0x90,0x97,0x21,0x12,0x25,0x08,0x7f,0x84,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,
+0x25,0x12,0x25,0x08,0x7f,0x88,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x29,0x12,0x25,
+0x08,0x7f,0x8c,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x2d,0x12,0x25,0x08,0x7f,0xd0,
+0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x31,0x12,0x25,0x08,0x7f,0xd4,0x7e,0x0e,0x12,
+0x22,0x65,0x90,0x97,0x35,0x12,0x25,0x08,0x7f,0xd8,0x7e,0x0e,0x12,0x22,0x65,0x90,
+0x97,0x39,0x12,0x25,0x08,0x7f,0xdc,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x3d,0x12,
+0x25,0x08,0x7f,0xe0,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x41,0x12,0x25,0x08,0x7f,
+0xec,0x7e,0x0e,0x12,0x22,0x65,0x90,0x97,0x45,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0c,
+0x12,0x22,0x65,0x90,0x97,0x49,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x22,0x65,
+0x90,0x97,0x4d,0x12,0x25,0x08,0x7f,0x0c,0x7e,0x09,0x12,0x22,0x65,0x90,0x97,0x51,
+0x12,0x25,0x08,0x7f,0x04,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x55,0x12,0x25,0x08,
+0x7f,0x8c,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0xc0,0xfd,0xec,
+0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x8c,0x7e,0x08,0x12,0x2b,
+0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x00,0x01,0x00,0x00,0x7f,0x44,0x7e,0x08,0x12,
+0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x00,0xdb,0x25,0xa4,0x7f,0x5c,0x7e,0x08,
+0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0x6c,0x7e,
+0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0x70,
+0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,0x25,0xa4,0x7f,
+0x74,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,0x25,0xa4,
+0x7f,0x78,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,0x25,
+0xa4,0x7f,0x7c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x04,0x1b,
+0x25,0xa4,0x7f,0x80,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x63,
+0xdb,0x25,0xa4,0x7f,0x84,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,0x14,
+0x04,0x1b,0x25,0xa4,0x7f,0x88,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,0x25,
+0x14,0x20,0xdb,0x25,0xa4,0x7f,0x8c,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,0x12,
+0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0xd0,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x96,
+0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0xd4,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,
+0x96,0x12,0x25,0x14,0x20,0xdb,0x25,0xa4,0x7f,0xd8,0x7e,0x0e,0x12,0x2b,0x08,0x90,
+0x80,0x96,0x12,0x25,0x14,0x00,0x1b,0x25,0xa4,0x7f,0xdc,0x7e,0x0e,0x12,0x2b,0x08,
+0x90,0x80,0x96,0x12,0x25,0x14,0x00,0x1b,0x25,0xa4,0x7f,0xe0,0x7e,0x0e,0x12,0x2b,
+0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x24,0xdb,0x25,0xa4,0x7f,0xec,0x7e,0x0e,0x12,
+0x2b,0x08,0x7f,0x04,0x7e,0x0c,0x12,0x22,0x65,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,
+0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe1,
+0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x44,0x11,0xff,0xec,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,
+0x7e,0x0c,0x12,0x2b,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x22,0x65,0x90,0x97,0xe1,0x12,
+0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,
+0xf0,0xff,0xec,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x01,0xff,0xec,0x90,0x97,0xe1,0x12,0x25,0x08,
+0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0d,0x12,0x2b,0x08,0x7f,0x0c,0x7e,0x09,0x12,
+0x22,0x65,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x11,0xff,0xec,0x90,0x97,0xe1,
+0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x0c,0x7e,0x09,0x12,0x2b,0x08,0x7f,0x0c,
+0x7e,0x09,0x12,0x22,0x65,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x54,0x0f,0xfd,0xec,0x54,0xf0,
+0xfc,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0x10,0xfd,0xec,0x44,0x01,0xfc,0x90,0x97,0xe1,
+0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x0c,0x7e,0x09,0x12,0x2b,0x08,0x7f,0x04,
+0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xf0,0xff,0xec,0x90,0x97,0xe1,0x12,
+0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,
+0x01,0xff,0xec,0x90,0x97,0xe1,0x12,0x25,0x08,0x90,0x97,0xe1,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,
+0x08,0x12,0x2b,0x08,0xe4,0x90,0x97,0x6d,0xf0,0x22,0x8f,0x11,0xef,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xaf,0x82,0xf5,0x12,0x8f,0x13,0xe5,0x11,0x75,0xf0,
+0x02,0xa4,0x24,0x81,0xf9,0x74,0x92,0x35,0xf0,0x75,0x14,0x01,0xf5,0x15,0x89,0x16,
+0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xaf,0x82,
+0xf5,0x17,0x8f,0x18,0xe5,0x11,0x75,0xf0,0x09,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,
+0xf0,0x75,0x19,0x01,0xf5,0x1a,0x89,0x1b,0x74,0xc1,0x25,0x11,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0xe0,0x12,0x63,0xc1,0x55,0x6c,0x00,0x55,0x81,0x01,0x55,0x96,0x02,
+0x55,0xab,0x03,0x55,0xd5,0x04,0x55,0xea,0x05,0x55,0xff,0x06,0x56,0x26,0x0c,0x56,
+0x54,0x0d,0x56,0x81,0x0e,0x56,0xae,0x0f,0x00,0x00,0x56,0xe2,0xe5,0x11,0x25,0xe0,
+0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x15,0x80,
+0x3c,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,
+0xf0,0xa3,0x74,0x10,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x05,0x80,0x12,0xe5,0x11,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0xe4,0xf0,0xe5,0x11,
+0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,
+0x8f,0xf0,0x02,0x56,0xe2,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf5,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf0,0x80,0x12,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xa3,0x74,
+0x0d,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0x02,0x56,0xe2,0x90,0x04,0x47,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,
+0x12,0x62,0x95,0x90,0x04,0x46,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,
+0x12,0x62,0xa7,0x90,0x04,0x45,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,
+0x44,0x02,0x56,0xd9,0x90,0x04,0x4b,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,
+0x95,0x90,0x04,0x4a,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,
+0xa7,0x90,0x04,0x49,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x48,0x80,
+0x58,0x90,0x04,0x4f,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0x95,0x90,0x04,
+0x4e,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xa7,0x90,0x04,
+0x4d,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x4c,0x80,0x2b,0x90,0x04,
+0x53,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0x95,0x90,0x04,0x52,0xe0,0xab,
+0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xa7,0x90,0x04,0x51,0xe0,0x85,
+0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x50,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,
+0xa3,0xf0,0xab,0x14,0xaa,0x15,0xa9,0x16,0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x24,
+0x62,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,0x12,0x24,0x62,0x5f,0xd0,0x01,0xd0,0x02,
+0xd0,0x03,0x12,0x62,0x95,0xab,0x14,0xe5,0x16,0x24,0x01,0xf9,0xe4,0x35,0x15,0xfa,
+0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x24,0x62,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,
+0x90,0x00,0x01,0x12,0x62,0x68,0x5f,0xd0,0x01,0xd0,0x02,0xd0,0x03,0x12,0x62,0x95,
+0x85,0x13,0x82,0x85,0x12,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,
+0x17,0x83,0xe0,0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0x85,0x13,0x82,0x85,0x12,
+0x83,0xa3,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,0x17,0x83,0xa3,0xe0,
+0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x4c,0x90,0x97,0x90,0x74,
+0x0b,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x50,0x03,0x02,0x58,0x28,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,
+0xa3,0xe0,0x5f,0x4e,0x60,0x0a,0x90,0x97,0x90,0xe0,0x24,0x10,0xa3,0xf0,0x80,0x68,
+0x90,0x97,0x90,0xe0,0x14,0xf0,0x80,0xba,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0x90,0x97,0x90,0x74,
+0x0f,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x40,0x3c,0x74,0x01,0x7e,0x00,
+0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,
+0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x08,0x90,0x97,0x90,0xe0,0xa3,0xf0,0x80,0x0d,0x90,0x97,0x90,0xe0,0x14,
+0xf0,0x80,0xbf,0xe4,0x90,0x97,0x91,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0xe4,0x90,0x97,0x90,
+0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x10,0x40,0x03,0x02,0x58,0xe2,0x74,0x01,
+0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,
+0xe0,0x5f,0x4e,0x60,0x06,0x90,0x97,0x90,0xe0,0x80,0x63,0x90,0x97,0x90,0xe0,0x04,
+0xf0,0x80,0xbe,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x46,0xe4,0x90,0x97,0x90,0xf0,0x90,0x97,0x90,0xe0,
+0xff,0xc3,0x94,0x0c,0x50,0x3c,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,
+0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x08,0x90,0x97,0x90,
+0xe0,0x24,0x10,0x80,0x09,0x90,0x97,0x90,0xe0,0x04,0xf0,0x80,0xbf,0xe4,0x90,0x97,
+0x92,0xf0,0x90,0x97,0x91,0xe0,0xff,0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x67,0xf5,
+0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xef,0xf0,0x90,0x97,0x92,0xe0,0xfe,0x75,0xf0,
+0x09,0xe5,0x11,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,
+0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0xd3,0x9f,0x40,0x1f,
+0x90,0x97,0x91,0xe0,0xff,0x74,0xc4,0x25,0x11,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xd3,0x94,0x13,0x40,0x08,0x90,0x93,0x62,0x74,0x03,0xf0,0x80,
+0x21,0xef,0xd3,0x94,0x0b,0x40,0x08,0x90,0x93,0x62,0x74,0x02,0xf0,0x80,0x13,0xef,
+0xd3,0x94,0x03,0x40,0x08,0x90,0x93,0x62,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x93,
+0x62,0xf0,0x90,0x93,0x62,0xe0,0x90,0x04,0xb1,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
+0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x7b,0xf0,0x74,0x59,
+0xa3,0xf0,0x90,0x01,0x37,0xe0,0x55,0x2b,0xf5,0x2f,0x90,0x01,0x34,0xe0,0x55,0x28,
+0xf5,0x2c,0x90,0x01,0x36,0xe0,0x55,0x2a,0xf5,0x2e,0xe5,0x2c,0x20,0xe0,0x03,0x02,
+0x5b,0x2d,0x90,0x01,0x34,0x74,0x01,0xf0,0x85,0xd1,0x4d,0x85,0xd2,0x4e,0x85,0xd3,
+0x4f,0x85,0xd4,0x50,0x85,0xd5,0x51,0x85,0xd6,0x52,0x85,0xd7,0x53,0x85,0xd9,0x54,
+0xe5,0x54,0x54,0x40,0xc3,0x13,0xff,0xe5,0x53,0x54,0x20,0x6f,0x70,0x03,0x02,0x5a,
+0xda,0xe5,0x54,0x30,0xe5,0x03,0x02,0x5a,0xda,0xe5,0x52,0x54,0x1f,0xf5,0x08,0xe5,
+0x4d,0x54,0x3f,0xf5,0x09,0xe5,0x51,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0x23,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xc9,0xe5,0x53,0x54,
+0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,
+0x8f,0xf0,0x12,0x62,0xc9,0xe5,0x09,0xd3,0x94,0x04,0x40,0x03,0x75,0x09,0x04,0x75,
+0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0x75,
+0xf0,0x02,0xe5,0x09,0x12,0x63,0xb5,0xe0,0xfe,0xa3,0xe0,0xff,0xe5,0x53,0x54,0x1f,
+0x2f,0xff,0xe4,0x3e,0xfe,0x75,0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,
+0xf0,0x34,0x90,0xf5,0x83,0x75,0xf0,0x02,0xe5,0x09,0x12,0x63,0xb5,0xee,0xf0,0xa3,
+0xef,0xf0,0xe5,0x54,0x20,0xe6,0x24,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,
+0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xc9,0xe5,
+0x4f,0x30,0xe7,0x36,0xaf,0x08,0x12,0x76,0x21,0x80,0x2f,0xe5,0x53,0x54,0x1f,0xff,
+0xe5,0x08,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,
+0x12,0x62,0xc9,0xe5,0x4f,0x30,0xe7,0x12,0xe5,0x4f,0x54,0x7f,0xfd,0xe5,0x53,0x54,
+0x1f,0xf5,0x0d,0xab,0x09,0xaf,0x08,0x12,0x76,0x97,0xe5,0x68,0x60,0x4f,0x90,0x97,
+0xcb,0xe0,0x60,0x35,0x90,0x01,0x5b,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x04,0xf0,0x90,
+0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x34,0x75,0x44,0x14,0xf5,0x45,0xfb,0xfd,
+0x7f,0x58,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x5b,0x74,0x05,0xf0,0x90,0x06,0x92,
+0x74,0x01,0xf0,0x90,0x97,0xc6,0xf0,0x80,0x14,0x90,0x04,0x1b,0xe0,0x54,0x7f,0xff,
+0xbf,0x7f,0x0a,0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x2c,0x30,
+0xe1,0x21,0x90,0x01,0x34,0x74,0x02,0xf0,0x85,0xd1,0x56,0x85,0xd2,0x57,0x85,0xd3,
+0x58,0x85,0xd4,0x59,0x85,0xd5,0x5a,0x85,0xd6,0x5b,0x85,0xd7,0x5c,0x85,0xd9,0x5d,
+0x12,0x7d,0x2a,0xe5,0x2c,0x30,0xe3,0x06,0x90,0x01,0x34,0x74,0x08,0xf0,0xe5,0x2c,
+0x30,0xe4,0x09,0x90,0x01,0x34,0x74,0x10,0xf0,0x43,0x55,0x10,0xe5,0x2c,0x30,0xe5,
+0x1d,0x90,0x01,0xcf,0xe0,0x30,0xe5,0x16,0xe0,0x54,0xdf,0xf0,0x90,0x01,0x34,0x74,
+0x20,0xf0,0x90,0x00,0x03,0xe0,0x54,0xfb,0xf0,0x12,0x7e,0xa6,0x80,0xfe,0xe5,0x2c,
+0x30,0xe6,0x06,0x90,0x01,0x34,0x74,0x40,0xf0,0xe5,0x2e,0x30,0xe1,0x09,0x90,0x01,
+0x36,0x74,0x02,0xf0,0x43,0x55,0x40,0xe5,0x2e,0x30,0xe0,0x09,0x90,0x01,0x36,0x74,
+0x01,0xf0,0x12,0x75,0xab,0xe5,0x2e,0x30,0xe2,0x63,0x90,0x01,0x36,0x74,0x04,0xf0,
+0xe5,0x67,0x64,0x01,0x70,0x57,0xe5,0x68,0x60,0x53,0xe5,0x68,0x64,0x02,0x70,0x27,
+0x90,0x06,0xab,0xe0,0x90,0x97,0xbd,0xf0,0x90,0x06,0xaa,0xe0,0x90,0x97,0xc9,0xf0,
+0x90,0x97,0xbd,0xe0,0x70,0x07,0x90,0x97,0xc9,0xe0,0xff,0x80,0x05,0x90,0x97,0xbd,
+0xe0,0xff,0x90,0x97,0xbd,0xef,0xf0,0x90,0x97,0xbf,0xe0,0x60,0x03,0xe0,0x14,0xf0,
+0x90,0x97,0xbe,0xe4,0xf0,0x90,0x01,0x57,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,
+0x97,0xcd,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0xef,0xf0,0x12,0x75,0x32,0xe5,0x2e,0x30,
+0xe3,0x31,0x90,0x01,0x36,0x74,0x08,0xf0,0xe5,0x67,0x64,0x01,0x70,0x25,0xe5,0x68,
+0x60,0x21,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x75,0x44,0x03,
+0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x57,
+0x74,0x05,0xf0,0xe5,0x2e,0x30,0xe4,0x3a,0x90,0x01,0x36,0x74,0x10,0xf0,0xe5,0x67,
+0x64,0x01,0x70,0x2e,0xe5,0x68,0x60,0x2a,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,
+0x74,0x02,0xf0,0x90,0x97,0xcc,0xe4,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xfd,0xf0,0xe0,
+0x54,0x03,0x70,0x0e,0x90,0x97,0xc8,0xf0,0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x12,
+0x6f,0xb5,0xe5,0x2e,0x30,0xe5,0x1f,0x90,0x01,0x36,0x74,0x20,0xf0,0xe5,0x67,0xb4,
+0x01,0x14,0xe5,0x68,0x60,0x10,0x90,0x97,0xcb,0xe0,0x64,0x02,0x60,0x05,0x12,0x7e,
+0x95,0x80,0x03,0x12,0x7b,0x3d,0xe5,0x2e,0x30,0xe6,0x2a,0x90,0x01,0x36,0x74,0x40,
+0xf0,0xe5,0x67,0x64,0x01,0x70,0x1e,0xe5,0x68,0x60,0x1a,0x90,0x97,0xcd,0xe0,0x54,
+0xfe,0xf0,0xe0,0x54,0x03,0x70,0x0e,0x90,0x97,0xc8,0xf0,0x90,0x97,0xca,0xe0,0xff,
+0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x2f,0x30,0xe1,0x09,0x90,0x01,0x37,0x74,0x02,0xf0,
+0x12,0x7c,0x1f,0x74,0x7b,0x04,0x90,0x01,0xc4,0xf0,0x74,0x59,0xa3,0xf0,0xd0,0x07,
+0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,
+0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x90,0x04,0x44,0x74,0x11,0xf0,0xa3,
+0x74,0xf0,0xf0,0xa3,0x74,0x0f,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xff,0xc3,0x94,0x10,0x50,0x14,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x04,
+0xf5,0x83,0xe4,0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x80,0xe2,0xe4,0x90,0x97,0x79,
+0xf0,0x90,0x97,0x79,0xe0,0xfb,0xc3,0x94,0x20,0x40,0x03,0x02,0x5f,0x28,0xe0,0xff,
+0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,
+0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x02,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x04,0xf5,0x82,0xe5,0xf0,
+0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x06,0xf5,
+0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,
+0x24,0x08,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x74,0xc4,
+0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x13,0xf0,0x74,0x84,0x2f,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0x74,0x83,0x2f,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xef,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0x23,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,
+0x64,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0xa4,0x2f,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x90,0x41,0xc4,0x93,0xfe,0x74,0x01,0x93,0xff,
+0x90,0x41,0x8c,0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x25,0x08,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x6a,0xf5,0x82,0xe5,0xf0,
+0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,
+0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x74,0xc1,0x2b,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0x74,0x0c,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x65,0xf5,0x82,0xe5,
+0xf0,0x34,0x93,0xf5,0x83,0x74,0xff,0xf0,0xa3,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,
+0x63,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0xa3,0x74,0x0f,0xf0,0x75,
+0xf0,0x09,0xeb,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x13,
+0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xe4,0xf0,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0x74,0x13,0xf0,0x90,
+0x97,0x79,0xe0,0x04,0xf0,0x02,0x5d,0x51,0x22,0xa9,0x07,0x74,0x84,0x29,0xf5,0x82,
+0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,0x97,0x92,0xf0,0xe0,0x54,0x1f,0xff,
+0x90,0x97,0x95,0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xf5,0x83,0xe0,0x90,0x97,0x97,0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x67,0xf5,
+0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xfe,0x90,0x97,0x98,0xf0,0xe9,0x25,0xe0,
+0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x99,
+0xcb,0xf0,0xa3,0xeb,0xf0,0xe9,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,
+0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x9b,0xcb,0xf0,0xa3,0xeb,0xf0,0xef,0xd3,0x9e,
+0x40,0x0c,0x90,0x97,0x98,0xe0,0x90,0x97,0x95,0xf0,0x90,0x97,0x92,0xf0,0xed,0x70,
+0x03,0x02,0x60,0x88,0x90,0x97,0x96,0xed,0xf0,0x90,0x97,0x92,0xe0,0x30,0xe6,0x0e,
+0x90,0x97,0x95,0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x96,0xe0,0x14,0xf0,0x90,0x97,
+0x96,0xe0,0x70,0x03,0x02,0x60,0x88,0x90,0x97,0x95,0xe0,0xff,0xd3,0x94,0x00,0x50,
+0x03,0x02,0x60,0x88,0xe4,0x90,0x97,0x94,0xf0,0xef,0x14,0x90,0x97,0x93,0xf0,0x90,
+0x97,0x97,0xe0,0xfd,0x90,0x97,0x93,0xe0,0xff,0xd3,0x9d,0x40,0x6f,0xef,0x94,0x10,
+0x40,0x21,0xef,0x24,0xf0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x9b,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x70,0x27,0x90,0x97,0x93,0xe0,0xff,0xc3,0x94,0x10,0x50,0x37,0x74,0x01,0x7e,
+0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,
+0x99,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x1a,0x90,0x97,0x93,0xe0,0x90,0x97,
+0x92,0xf0,0x90,0x97,0x94,0xe0,0x04,0xf0,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,0x94,
+0xe0,0x6f,0x60,0x08,0x90,0x97,0x93,0xe0,0x14,0xf0,0x80,0x83,0x90,0x97,0x96,0xe0,
+0xff,0x90,0x97,0x94,0xe0,0xc3,0x9f,0x50,0x0f,0x90,0x97,0x93,0xe0,0xb5,0x05,0x08,
+0x90,0x97,0x97,0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x92,0xe0,0xff,0x25,0xe0,0x24,
+0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,
+0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,
+0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xe9,0x25,0xe0,0x25,
+0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x25,0x08,0x90,0x97,0x92,
+0xe0,0xff,0x74,0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0x90,
+0x01,0xcc,0xe0,0x54,0x0f,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xfd,0x70,0x03,
+0x02,0x62,0x67,0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,
+0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xef,0x5d,0x70,0x03,0x02,0x62,0x48,
+0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd0,0xf5,0x82,0xe5,0xf0,0x34,0x01,
+0xf5,0x83,0xe0,0x90,0x97,0x7a,0xf0,0x75,0x61,0x01,0x75,0x62,0x97,0x75,0x63,0x7a,
+0x75,0x64,0x01,0x7b,0x01,0x7a,0x97,0x79,0x7b,0x12,0x77,0x5c,0x90,0x97,0x7b,0xe0,
+0xff,0xc4,0x13,0x13,0x13,0x54,0x01,0x90,0x97,0xef,0x30,0xe0,0x70,0xe0,0x75,0xf0,
+0x02,0xa4,0x24,0x88,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,
+0x90,0x97,0xef,0xe0,0x75,0xf0,0x02,0xa4,0x24,0x89,0xf5,0x82,0xe4,0x35,0xf0,0xf5,
+0x83,0xe0,0x90,0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd1,
+0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,
+0x90,0x97,0x7f,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,0x82,
+0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x80,0xf0,0x80,0x42,0xe0,0x75,0xf0,
+0x04,0xa4,0x24,0xd1,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7c,
+0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,
+0x01,0xf5,0x83,0xe0,0x90,0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,
+0x24,0xd3,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0xef,
+0x54,0x7f,0xff,0x7b,0x01,0x7a,0x97,0x79,0x7c,0x12,0x6d,0x5b,0x90,0x97,0x79,0xe0,
+0xff,0x90,0x97,0xef,0xe0,0xfe,0x74,0x01,0xa8,0x06,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0x5f,0x90,0x97,0x79,0xf0,0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0xa8,0x07,
+0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0x90,0x01,0xcc,0xf0,0x90,0x97,0xef,0xe0,0x04,
+0xf0,0xe0,0x54,0x03,0xf0,0x02,0x60,0xe9,0xc2,0xaf,0x74,0xdf,0x04,0x90,0x01,0xc4,
+0xf0,0x74,0x60,0xa3,0xf0,0x90,0x97,0x79,0xe0,0x90,0x01,0xc6,0xf0,0x90,0x97,0xef,
+0xe0,0x90,0x01,0xc7,0xf0,0x80,0xfe,0x22,0xbb,0x01,0x0c,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe0,0x22,0x50,0x06,0xe9,0x25,0x82,0xf8,0xe6,0x22,0xbb,
+0xfe,0x06,0xe9,0x25,0x82,0xf8,0xe2,0x22,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe4,0x93,0x22,0xbb,0x01,0x06,0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x02,
+0xf7,0x22,0xbb,0xfe,0x01,0xf3,0x22,0xf8,0xbb,0x01,0x0d,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0x22,0x50,0x06,0xe9,0x25,0x82,0xc8,0xf6,0x22,
+0xbb,0xfe,0x05,0xe9,0x25,0x82,0xc8,0xf2,0x22,0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,
+0xc5,0xf0,0xf8,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,
+0xf8,0xe0,0xc5,0xf0,0x25,0xf0,0xf0,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,
+0xc8,0x38,0xf0,0xe8,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,
+0xe0,0x22,0x50,0x06,0x87,0xf0,0x09,0xe7,0x19,0x22,0xbb,0xfe,0x07,0xe3,0xf5,0xf0,
+0x09,0xe3,0x19,0x22,0x89,0x82,0x8a,0x83,0xe4,0x93,0xf5,0xf0,0x74,0x01,0x93,0x22,
+0xbb,0x01,0x10,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,
+0xa3,0xe0,0x22,0x50,0x09,0xe9,0x25,0x82,0xf8,0x86,0xf0,0x08,0xe6,0x22,0xbb,0xfe,
+0x0a,0xe9,0x25,0x82,0xf8,0xe2,0xf5,0xf0,0x08,0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,
+0xe9,0x93,0xf5,0xf0,0xa3,0xe9,0x93,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xf0,
+0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x06,0xf7,0x09,0xa7,0xf0,0x19,0x22,0xbb,0xfe,0x06,
+0xf3,0xe5,0xf0,0x09,0xf3,0x19,0x22,0xf8,0xbb,0x01,0x11,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x09,0xe9,0x25,
+0x82,0xc8,0xf6,0x08,0xa6,0xf0,0x22,0xbb,0xfe,0x09,0xe9,0x25,0x82,0xc8,0xf2,0xe5,
+0xf0,0x08,0xf2,0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,
+0xe8,0x9c,0x45,0xf0,0x22,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,
+0x22,0xd0,0x83,0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,0x01,0x93,0x70,0x0d,0xa3,
+0xa3,0x93,0xf8,0x74,0x01,0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x02,0x93,0x68,
+0x60,0xef,0xa3,0xa3,0xa3,0x80,0xdf,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,
+0xe9,0xf0,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x04,
+0x12,0x62,0x68,0xff,0x54,0x1f,0x90,0x97,0x87,0xf0,0x90,0x00,0x03,0x12,0x62,0x68,
+0x54,0xf0,0xc4,0x54,0x0f,0x90,0x97,0x88,0xf0,0xef,0x54,0x20,0xc4,0x13,0x54,0x07,
+0xa3,0xf0,0x90,0x00,0x04,0x12,0x62,0x68,0x54,0x40,0xc4,0x13,0x13,0x54,0x03,0x90,
+0x97,0x8a,0xf0,0x90,0x97,0x87,0xe0,0xff,0x75,0xf0,0x09,0xa4,0x24,0x65,0xf5,0x82,
+0xe5,0xf0,0x34,0x93,0xad,0x82,0x90,0x97,0x8b,0xf0,0xa3,0xed,0xf0,0xef,0x75,0xf0,
+0x09,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,0xf0,0xfa,0xa3,0x74,0x01,0xf0,0xa3,0xea,
+0xf0,0xa3,0xe9,0xf0,0x90,0x97,0x84,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x03,
+0x12,0x62,0x68,0x54,0x0f,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0xef,0x12,0x62,0x95,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x90,0x00,0x02,0x12,0x62,0x68,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xf9,0x90,0x00,0x01,0xef,0x12,0x62,0xa7,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x62,0x68,0xff,0x90,0x97,0x8b,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xf5,0x82,0x8c,0x83,0xef,0xf0,0x12,0x24,0x62,0x8d,0x82,0x8c,0x83,
+0xa3,0xf0,0x90,0x97,0x88,0xe0,0xfe,0x90,0x97,0x87,0xe0,0xff,0x24,0xc1,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x89,0xe0,0xfe,0x75,0xf0,0x09,0xef,
+0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,0x75,0xf0,0x09,
+0xef,0xa4,0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x90,
+0x97,0x8a,0xe0,0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xf5,0x83,0xee,0xf0,0x02,0x54,0xea,0x90,0x00,0x02,0x12,0x62,0x68,0x90,0x97,
+0xa9,0xf0,0x90,0x00,0x01,0x12,0x62,0x68,0x25,0xe0,0x25,0xe0,0x90,0x97,0xa8,0xf0,
+0x12,0x24,0x62,0x25,0xe0,0x25,0xe0,0x90,0x97,0xac,0xf0,0x90,0x05,0x60,0xe0,0x90,
+0x97,0xb7,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,0xf0,0x90,0x05,0x62,0xe0,0x90,
+0x97,0xb9,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0xba,0xf0,0xa2,0xaf,0xe4,0x33,0x90,
+0x97,0x84,0xf0,0xc2,0xaf,0x90,0x97,0xa8,0xe0,0xff,0x12,0x78,0x71,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x90,0x97,0xa9,0xe0,0x70,0x03,0x02,0x66,0x35,0x90,0x97,
+0xa8,0xe0,0x70,0x03,0x02,0x66,0x35,0x90,0x97,0xac,0xe0,0x70,0x03,0x02,0x66,0x35,
+0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,0xc2,0xaf,0x90,0x97,0xbb,0x74,0x01,0xf0,
+0x90,0x97,0x84,0xe0,0x24,0xff,0x92,0xaf,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,
+0xe0,0x44,0x01,0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,
+0x7e,0x08,0x12,0x2b,0x08,0x80,0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x00,0x45,
+0xe0,0x54,0xef,0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,
+0x05,0x84,0xf0,0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,
+0x05,0x86,0xf0,0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,0xa2,0xaf,0xe4,0x33,0x90,
+0x97,0x84,0xf0,0xc2,0xaf,0x90,0x01,0x3c,0xe0,0x44,0x20,0xf0,0x7d,0x20,0xe4,0xff,
+0x12,0x31,0xb7,0x80,0x2b,0x90,0x97,0xa9,0xe0,0x70,0x2d,0x90,0x97,0xbb,0xf0,0x90,
+0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,0xe0,0x54,0xfe,0xf0,0x90,0x05,0x22,0xe4,0xf0,
+0xa2,0xaf,0x33,0x90,0x97,0x84,0xf0,0xc2,0xaf,0x7d,0x20,0xe4,0xff,0x12,0x31,0x49,
+0x90,0x97,0x84,0xe0,0x24,0xff,0x92,0xaf,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,
+0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,
+0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x69,0xf0,0x74,0x66,0xa3,0xf0,
+0x53,0x91,0xdf,0x90,0x01,0x3c,0xe0,0x55,0x30,0xf5,0x34,0xa3,0xe0,0x55,0x31,0xf5,
+0x35,0xa3,0xe0,0x55,0x32,0xf5,0x36,0xe5,0x34,0x30,0xe0,0x0f,0x90,0x01,0x3c,0x74,
+0x01,0xf0,0x90,0x01,0x53,0x74,0x07,0xf0,0x43,0x55,0x80,0xe5,0x34,0x30,0xe1,0x09,
+0x90,0x01,0x3c,0x74,0x02,0xf0,0x12,0x79,0xeb,0xe5,0x34,0x30,0xe2,0x3a,0x90,0x01,
+0x3c,0x74,0x04,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe0,0x1e,0x75,0x44,0x14,0x75,0x45,
+0x00,0xe4,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x5b,0x74,0x05,
+0xf0,0x90,0x06,0x92,0x74,0x01,0xf0,0x80,0x0f,0x90,0x97,0xc6,0xe4,0xf0,0x90,0x97,
+0xca,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x34,0x30,0xe3,0x3a,0x90,0x01,0x3c,
+0x74,0x08,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe1,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,
+0xe4,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x5f,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x02,0xf0,0x80,0x0f,0x90,0x97,0xc5,0xe4,0xf0,0x90,0x97,0xca,
+0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0xe5,0x34,0x30,0xe4,0x09,0x90,0x01,0x3c,0x74,
+0x10,0xf0,0x12,0x7a,0xbc,0xe5,0x34,0x30,0xe5,0x09,0x90,0x01,0x3c,0x74,0x20,0xf0,
+0x12,0x6e,0xf1,0xe5,0x35,0x30,0xe0,0x15,0x90,0x01,0x3d,0x74,0x01,0xf0,0x90,0x00,
+0x83,0xe0,0x90,0x97,0xca,0xf0,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,0x74,0x69,0x04,
+0x90,0x01,0xc4,0xf0,0x74,0x66,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,
+0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,
+0xd0,0xe0,0x32,0xe4,0x90,0x97,0x76,0xf0,0xa3,0xf0,0x12,0x79,0x5c,0x90,0x00,0x02,
+0xe0,0x54,0xe0,0x90,0x97,0xd4,0x60,0x05,0x74,0x01,0xf0,0x80,0x03,0x74,0x02,0xf0,
+0x90,0x00,0xf3,0xe0,0x30,0xe3,0x08,0x90,0x97,0xd5,0x74,0x01,0xf0,0x80,0x05,0xe4,
+0x90,0x97,0xd5,0xf0,0x90,0x97,0xd5,0xe0,0xb4,0x01,0x13,0x90,0x00,0xf2,0xe0,0x30,
+0xe7,0x0c,0x90,0x97,0xce,0x74,0xfd,0xf0,0xa3,0x74,0x33,0xf0,0x80,0x0a,0x90,0x97,
+0xce,0x74,0xfd,0xf0,0xa3,0x74,0x2f,0xf0,0xe4,0xf5,0x55,0x12,0x5d,0x19,0x12,0x44,
+0xfa,0x12,0x78,0xc3,0x12,0x2e,0x01,0x12,0x7f,0x3a,0x12,0x7d,0xad,0x90,0x00,0xf3,
+0xe0,0x30,0xe2,0x0d,0x90,0x05,0x41,0x74,0x10,0xf0,0x90,0x05,0x5a,0xf0,0xa3,0xe4,
+0xf0,0x90,0x01,0x64,0x74,0xa0,0xf0,0x75,0x44,0xff,0xe4,0xf5,0x45,0xfb,0x7d,0x01,
+0x7f,0x50,0x7e,0x01,0x12,0x30,0x62,0x12,0x7e,0x56,0x12,0x78,0x1a,0x90,0x97,0x78,
+0xe5,0xd9,0xf0,0x12,0x7e,0x6e,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x40,0xf0,0x12,
+0x7e,0xa6,0x75,0xe8,0x03,0x43,0xa8,0x85,0xd2,0xaf,0x90,0x01,0xc0,0xe4,0xf0,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x01,0xc6,0xf0,0xa3,0xf0,0x90,0x97,0x76,0xe0,0x64,
+0x01,0xf0,0x24,0xa3,0x90,0x01,0xc4,0xf0,0x74,0x67,0xa3,0xf0,0xe5,0x55,0x30,0xe6,
+0x17,0xc2,0xaf,0x53,0x55,0xbf,0xd2,0xaf,0x12,0x45,0x09,0x90,0x97,0xab,0xe0,0xff,
+0x60,0x03,0xb4,0x01,0x03,0x12,0x68,0xc1,0xe5,0x55,0x30,0xe7,0x07,0xc2,0xaf,0x53,
+0x55,0x7f,0xd2,0xaf,0xe5,0x55,0x30,0xe4,0x0a,0xc2,0xaf,0x53,0x55,0xef,0xd2,0xaf,
+0x12,0x60,0xdf,0x90,0x97,0xab,0xe0,0x70,0x03,0x12,0x6b,0xac,0x12,0x7c,0xaa,0x80,
+0xaa,0x90,0x97,0xa2,0xe0,0xc3,0x94,0x14,0x50,0x06,0xe0,0x04,0xf0,0x02,0x69,0x7b,
+0x90,0x97,0xa2,0xe0,0x64,0x14,0x60,0x03,0x02,0x69,0x7b,0x90,0x97,0xb1,0xe0,0x70,
+0x25,0x90,0x97,0xb4,0xe0,0x70,0x1f,0x90,0x97,0xb2,0xe0,0x70,0x19,0x90,0x97,0xb5,
+0xe0,0x70,0x13,0x90,0x97,0xb3,0xe0,0x70,0x0d,0x90,0x97,0xb6,0xe0,0x70,0x07,0x90,
+0x04,0xfd,0xe0,0x54,0xfe,0xf0,0x90,0x97,0xb1,0xe0,0x90,0x04,0x44,0xf0,0x90,0x97,
+0xb2,0xe0,0x90,0x04,0x45,0xf0,0x90,0x97,0xb3,0xe0,0x90,0x04,0x46,0xf0,0xa3,0xe4,
+0xf0,0x90,0x97,0xb4,0xe0,0x90,0x04,0x48,0xf0,0x90,0x97,0xb5,0xe0,0x90,0x04,0x49,
+0xf0,0x90,0x97,0xb6,0xe0,0x90,0x04,0x4a,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x9d,0xe0,
+0x90,0x07,0x00,0xf0,0x90,0x97,0x9e,0xe0,0x90,0x07,0x01,0xf0,0x90,0x97,0x9f,0xe0,
+0x90,0x07,0x02,0xf0,0x90,0x97,0xa0,0xe0,0x90,0x07,0x03,0xf0,0xe4,0x90,0x97,0xa2,
+0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,0xb1,
+0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x05,0x60,0xe0,0x90,
+0x97,0x79,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0x7a,0xf0,0x90,0x05,0x62,0xe0,0x90,
+0x97,0x7b,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xba,0xe0,0xff,
+0x90,0x97,0x7c,0xe0,0xfe,0xd3,0x9f,0x50,0x0b,0x90,0x97,0xba,0xe0,0xc3,0x9e,0xd3,
+0x94,0x01,0x40,0x11,0x90,0x97,0xa8,0xe0,0xb4,0x01,0x02,0x80,0x03,0x90,0x97,0xac,
+0xe0,0xff,0x12,0x78,0x71,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0xee,
+0xed,0xf0,0x90,0x97,0xed,0xef,0xf0,0xd3,0x94,0x07,0x50,0x65,0xe0,0xff,0x74,0x01,
+0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,
+0xf0,0x12,0x7e,0xa6,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x46,0xe0,0x4f,0xf0,0x12,0x7e,0xa6,0x90,0x97,
+0xee,0xe0,0x60,0x16,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x45,0x80,0x70,0x90,0x97,0xed,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x45,0x80,
+0x75,0x90,0x97,0xed,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,
+0x12,0x7e,0xa6,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,
+0x33,0xd8,0xfc,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7e,0xa6,0x90,0x97,0xee,
+0xe0,0x60,0x1b,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,
+0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x42,0xe0,0x4f,0x80,0x1a,0x90,0x97,
+0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,
+0xf0,0xf4,0xff,0x90,0x00,0x42,0xe0,0x5f,0xf0,0x12,0x7e,0xa6,0xd0,0xd0,0x92,0xaf,
+0x22,0x7f,0x78,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0x5d,0x12,0x25,0x08,0x7f,0x04,
+0x7e,0x0c,0x12,0x22,0x65,0x90,0x97,0x61,0x12,0x25,0x08,0x7f,0x00,0x7e,0x08,0x12,
+0x22,0x65,0x90,0x97,0x65,0x12,0x25,0x08,0x90,0x97,0xd5,0xe0,0x90,0x97,0x5d,0xb4,
+0x01,0x13,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xc7,0xff,0xed,
+0x54,0xc7,0xfd,0x80,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,
+0xc7,0xff,0xec,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x78,0x7e,0x08,0x12,0x2b,0x08,
+0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0x0f,0xff,
+0xec,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0c,0x12,0x2b,0x08,0x90,0x97,
+0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x02,0xff,0xec,0x90,
+0x80,0x96,0x12,0x25,0x08,0x7f,0x00,0x7e,0x08,0x12,0x2b,0x08,0x7f,0x70,0x7e,0x0e,
+0x12,0x22,0x65,0x90,0x97,0x69,0x12,0x25,0x08,0x90,0x80,0x96,0x12,0x25,0x14,0x00,
+0x1b,0x25,0xa0,0x7f,0x70,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x68,0x12,0x25,0x14,
+0x00,0x00,0x00,0x00,0xe4,0xfd,0xff,0x12,0x30,0x2c,0x90,0x97,0xd5,0xe0,0xb4,0x01,
+0x11,0x90,0x80,0x68,0x12,0x25,0x14,0x00,0x00,0x00,0x00,0xe4,0xfd,0x7f,0x01,0x12,
+0x30,0x2c,0x90,0x00,0x11,0xe0,0x54,0xf6,0xf0,0x02,0x7e,0xa6,0x90,0x97,0xbb,0xe0,
+0x64,0x01,0x60,0x09,0x90,0x97,0xa9,0xe0,0x60,0x03,0x02,0x6c,0x84,0x90,0x97,0x9d,
+0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x3b,0x90,0x97,0x9e,0xe0,0xc3,
+0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x28,0x90,0x97,0x9f,0xe0,0xc3,0x94,
+0xff,0x50,0x0a,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9e,0xf0,0x80,0x15,0x90,0x97,0xa0,
+0xe0,0xc3,0x94,0xff,0x50,0x10,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x9f,0xf0,0x90,0x97,
+0x9e,0xf0,0x90,0x97,0x9d,0xf0,0x90,0x00,0x44,0xe0,0x54,0x0c,0x60,0x76,0xe0,0x30,
+0xe2,0x32,0x90,0x97,0xb1,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,
+0x90,0x97,0xb2,0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,
+0x97,0xb3,0xe0,0xc3,0x94,0xff,0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb2,0xf0,
+0x90,0x97,0xb1,0xf0,0x90,0x00,0x44,0xe0,0x30,0xe3,0x32,0x90,0x97,0xb4,0xe0,0xc3,
+0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,0x90,0x97,0xb5,0xe0,0xc3,0x94,0xff,
+0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,0x97,0xb6,0xe0,0xc3,0x94,0xff,0x50,
+0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb4,0xf0,0x90,0x04,0xfd,
+0xe0,0x44,0x01,0xf0,0x22,0x8b,0x11,0x8a,0x12,0x89,0x13,0x90,0x00,0x02,0x12,0x62,
+0x68,0x90,0x97,0xaa,0xf0,0xe0,0x30,0xe0,0x5c,0x90,0x97,0xa1,0x74,0x01,0xf0,0x7f,
+0x80,0x7e,0x08,0x12,0x22,0x65,0x90,0x97,0xa3,0x12,0x25,0x08,0xab,0x11,0xaa,0x12,
+0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x68,0xff,0xe4,0xfc,0xfd,0xfe,0x78,0x1a,0x12,
+0x24,0xf5,0xa8,0x04,0xa9,0x05,0xaa,0x06,0xab,0x07,0x90,0x97,0xa3,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xec,0x54,0x03,0xfc,0xeb,0x4f,0xff,0xea,
+0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,0x4c,0xfc,0x90,0x97,0xad,0x12,0x25,0x08,0x90,0x05,
+0x22,0xe4,0xf0,0x80,0x35,0xe4,0x90,0x97,0xa1,0xf0,0x7f,0x80,0x7e,0x08,0x12,0x22,
+0x65,0xec,0x54,0x03,0xfc,0xec,0x44,0xc0,0xfc,0x90,0x97,0xa3,0x12,0x25,0x08,0x90,
+0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,
+0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,0x2b,0x08,0x90,0x97,0xaa,0xe0,0x90,0x00,
+0x47,0x30,0xe1,0x11,0x74,0x0c,0xf0,0xa3,0xe0,0x44,0x0c,0xf0,0x90,0x00,0x46,0xe0,
+0x44,0x10,0xf0,0x80,0x10,0xe0,0x54,0xf3,0xf0,0xa3,0xe0,0x54,0xf3,0xf0,0x90,0x00,
+0x46,0xe0,0x54,0xef,0xf0,0xe4,0x90,0x97,0xa7,0xf0,0x22,0x90,0x97,0x81,0xeb,0xf0,
+0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xef,0x12,0x63,0xc1,0x6d,0x8c,0x01,0x6d,0x9a,0x02,
+0x6d,0xa8,0x03,0x6d,0xb6,0x05,0x6d,0xc4,0x06,0x6d,0xd2,0x07,0x6d,0xe0,0x09,0x6d,
+0xee,0x0c,0x6d,0xfc,0x0d,0x6e,0x0a,0x0e,0x00,0x00,0x6e,0x18,0x90,0x97,0x81,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x6e,0x90,0x97,0x81,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7f,0x34,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xf9,0x02,0x7c,0x4e,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0x02,0x7c,0xd7,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,
+0x63,0xe7,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7e,0xee,
+0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x73,0x0d,0x90,0x97,
+0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x65,0x28,0x90,0x97,0x81,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7c,0x7c,0x90,0x97,0x81,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x6c,0x85,0xc2,0xaf,0x74,0x5b,0x04,0x90,0x01,0xc4,
+0xf0,0x74,0x6d,0xa3,0xf0,0x80,0xfe,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,
+0x8a,0xed,0xf0,0x90,0x97,0x89,0xef,0xf0,0xd3,0x94,0x07,0x50,0x4f,0xa3,0xe0,0x70,
+0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,0xf0,0x80,0x17,0x90,0x97,0x89,0xe0,0xff,
+0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x47,0xe0,
+0x4f,0xf0,0x12,0x7e,0xa6,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0x80,0x5a,0x90,0x97,0x89,0xe0,
+0x24,0xf8,0xf0,0xa3,0xe0,0x70,0x1d,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,
+0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,
+0x5f,0xf0,0x80,0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7e,
+0xa6,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7e,0xa6,0xd0,0xd0,0x92,0xaf,
+0x22,0x90,0x97,0xa9,0xe0,0x64,0x01,0x60,0x03,0x02,0x6f,0xb4,0x90,0x00,0x46,0xe0,
+0x44,0x01,0xf0,0x90,0x97,0xbb,0xe0,0x70,0x40,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,
+0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,
+0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,0x2b,0x08,0x80,0x06,0x90,0x05,0x22,0x74,
+0x7f,0xf0,0x90,0x97,0xa8,0xe0,0xff,0x12,0x78,0x71,0x90,0x97,0xbb,0x74,0x01,0xf0,
+0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0x80,0x44,0x90,0x97,0xbb,0xe0,0x64,0x01,0x70,
+0x3c,0x90,0x97,0xac,0xe0,0xff,0x12,0x78,0x71,0xe4,0x90,0x97,0xbb,0xf0,0x90,0x00,
+0x45,0xe0,0x44,0x01,0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xa3,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,
+0x80,0x7e,0x08,0x12,0x2b,0x08,0x80,0x05,0x90,0x05,0x22,0xe4,0xf0,0x90,0x05,0x87,
+0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,0xf0,0x90,0x97,0xb8,0xe0,
+0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,0xf0,0x90,0x97,0xba,0xe0,
+0x90,0x05,0x87,0xf0,0x22,0x8f,0x65,0x8d,0x66,0xe5,0x65,0x54,0x0f,0xff,0x90,0x97,
+0xc7,0xe0,0x54,0x0f,0x6f,0x60,0x78,0xe5,0x65,0x30,0xe2,0x30,0x90,0x97,0xc7,0xe0,
+0x20,0xe2,0x05,0x7f,0x01,0x12,0x7d,0x8e,0x90,0x97,0xc7,0xe0,0x30,0xe3,0x0a,0xe5,
+0x65,0x20,0xe3,0x05,0x12,0x7d,0xcb,0x80,0x56,0x90,0x97,0xc7,0xe0,0x20,0xe3,0x4f,
+0xe5,0x65,0x30,0xe3,0x4a,0xaf,0x66,0x12,0x7d,0x4e,0x80,0x43,0x90,0x97,0xc7,0xe0,
+0x54,0x0f,0xff,0xbf,0x0c,0x0e,0xe5,0x65,0x20,0xe3,0x09,0x12,0x7d,0x03,0xef,0x60,
+0x2e,0x12,0x7d,0xcb,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xff,0xbf,0x04,0x0e,0xe5,0x65,
+0x20,0xe2,0x09,0x12,0x7b,0x7b,0xef,0x60,0x16,0x12,0x7b,0xb3,0x90,0x97,0xc7,0xe0,
+0x54,0x0f,0xff,0xbf,0x02,0x09,0x12,0x7a,0xff,0xef,0x60,0x03,0x12,0x7d,0xe8,0x90,
+0x97,0xc7,0xe0,0x54,0x0f,0xff,0x90,0x97,0xca,0xe0,0x54,0x0f,0x6f,0x70,0x23,0xe0,
+0x30,0xe6,0x1f,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xff,0x90,0x97,0xbc,0xe0,0xfe,0x4f,
+0x90,0x01,0x2f,0xf0,0xee,0x64,0x80,0x90,0x97,0xbc,0xf0,0x90,0x97,0xca,0xe0,0x54,
+0xbf,0xf0,0x22,0x90,0x97,0xdc,0xef,0xf0,0xa3,0xed,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,
+0xe5,0x68,0x60,0x05,0xe4,0xff,0x12,0x7e,0x22,0x90,0x97,0xdc,0xe0,0x30,0xe0,0x09,
+0x90,0x97,0xde,0xe4,0xf0,0xa3,0x74,0x80,0xf0,0x90,0x04,0x1d,0xe0,0x60,0x1d,0x90,
+0x05,0x22,0xe0,0x90,0x97,0xe0,0xf0,0xe0,0xff,0x54,0x90,0x60,0xec,0x90,0x01,0xc8,
+0x74,0xfc,0xf0,0xef,0x54,0x6f,0x90,0x05,0x22,0xf0,0x80,0xdd,0x90,0x97,0xdc,0xe0,
+0xff,0xc3,0x13,0x90,0xfd,0x10,0xf0,0x90,0x04,0x25,0xef,0xf0,0x90,0x97,0xdd,0xe0,
+0x60,0x1f,0xa3,0xa3,0xe0,0xff,0x24,0x0f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,
+0x44,0x80,0xf0,0x74,0x10,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x44,0x80,
+0xf0,0x90,0x97,0xde,0xa3,0xe0,0xff,0xfd,0x24,0x08,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe4,0xf0,0x74,0x09,0x2d,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xf0,
+0xf0,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xf7,0xf0,0x90,
+0x97,0xde,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,
+0x97,0xf3,0xef,0xf0,0xd3,0x94,0x07,0x50,0x47,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0xe0,0x5f,0xf0,0x12,0x7e,
+0xa6,0x90,0x97,0xf3,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x44,0xe0,0xfb,0xe4,0xfe,0xef,0x5b,
+0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,0x80,0x4c,
+0x90,0x97,0xf3,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7e,0xa6,0x90,
+0x97,0xf3,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,0x05,0xc3,0x33,0xce,
+0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x42,0xe0,0xfb,0xe4,0xfe,0xef,0x5b,0xa8,0x05,
+0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,0xd0,0xd0,0x92,0xaf,
+0x22,0x90,0x00,0x11,0xe0,0x44,0x09,0xf0,0x12,0x7e,0xa6,0x90,0x97,0x5d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,
+0x78,0x7e,0x08,0x12,0x2b,0x08,0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x04,0x7e,0x0c,0x12,0x2b,
+0x08,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x80,0x96,0x12,0x25,0x08,0x7f,0x00,0x7e,0x08,0x12,0x2b,0x08,0x90,0x97,0x69,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,
+0x7f,0x70,0x7e,0x0e,0x12,0x2b,0x08,0x90,0x80,0x68,0x12,0x25,0x14,0x00,0x03,0x2d,
+0x95,0xe4,0xfd,0xff,0x12,0x30,0x2c,0x90,0x97,0xd5,0xe0,0xb4,0x01,0x11,0x90,0x80,
+0x68,0x12,0x25,0x14,0x00,0x03,0x2d,0x95,0xe4,0xfd,0x7f,0x01,0x12,0x30,0x2c,0x22,
+0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0x70,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,
+0xe9,0xf0,0x90,0x97,0xd4,0xe0,0x64,0x02,0x60,0x7e,0x90,0x01,0xaf,0xe0,0x60,0x09,
+0x90,0x01,0xc7,0xe0,0x04,0xf0,0xf0,0x80,0xf1,0x90,0x97,0xf1,0xe0,0xff,0x04,0xf0,
+0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0xef,0x12,
+0x62,0xa7,0x90,0x97,0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x61,0x8a,0x62,
+0xf5,0x63,0x75,0x64,0x02,0x7b,0x01,0x7a,0x01,0x79,0xa0,0x12,0x77,0x5c,0x90,0x97,
+0x73,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x61,0x8a,0x62,0xf5,0x63,0x90,0x97,
+0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x12,0x24,0x62,0xff,0xc4,0x54,0x0f,
+0xf5,0x64,0x7b,0x01,0x7a,0x01,0x79,0xa2,0x12,0x77,0x5c,0x90,0x01,0xaf,0x74,0xff,
+0xf0,0x90,0x01,0xcb,0xe0,0x64,0x80,0xf0,0xd0,0xd0,0x92,0xaf,0x22,0xd3,0x10,0xaf,
+0x01,0xc3,0xc0,0xd0,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,
+0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,0x20,
+0xfa,0xe5,0xf0,0x24,0x00,0xff,0xe4,0x3a,0xfe,0x90,0x97,0x84,0xa3,0xe0,0xfa,0x90,
+0x00,0x01,0xee,0x8f,0xf0,0x12,0x63,0x77,0x12,0x24,0x62,0xff,0x60,0x37,0xb5,0x22,
+0x1b,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,
+0x63,0x20,0x65,0x24,0x70,0x04,0xe5,0x23,0x65,0xf0,0x60,0x2e,0x90,0x97,0x84,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,0x20,0xff,0xae,0xf0,
+0x12,0x7a,0x31,0x80,0x15,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x12,0x24,0x62,0x65,0x22,0x60,0x03,0x12,0x7f,0x1c,0xd0,0xd0,0x92,0xaf,0x22,0xef,
+0x60,0x34,0x7d,0x7d,0x7f,0x02,0x12,0x31,0x2c,0x7d,0x02,0x7f,0x03,0x12,0x31,0x2c,
+0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x7d,0x01,0x7f,0x0c,0x12,
+0x6f,0xb5,0xe4,0xff,0x12,0x7e,0x22,0x90,0x06,0x04,0xe0,0x54,0x7f,0xf0,0x90,0x06,
+0x0a,0xe0,0x54,0xf8,0xf0,0x22,0x90,0x01,0x36,0x74,0x7d,0xf0,0xa3,0x74,0x02,0xf0,
+0x7d,0x7d,0xff,0x12,0x31,0x9d,0x7d,0x02,0x7f,0x03,0x12,0x31,0x9d,0x90,0x06,0x04,
+0xe0,0x44,0x80,0xf0,0x90,0x06,0x0a,0xe0,0x44,0x07,0xf0,0x90,0x97,0xc2,0xe0,0xa3,
+0xe0,0x90,0x05,0x58,0xf0,0xe5,0x67,0x30,0xe0,0x1b,0x90,0x97,0xbf,0xe0,0x70,0x1a,
+0xe0,0x04,0xf0,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x0c,0x7d,0x01,
+0x7f,0x04,0x02,0x6f,0xb5,0xe4,0x90,0x97,0xbf,0xf0,0x22,0xef,0x14,0x60,0x20,0x14,
+0x60,0x4b,0x24,0x02,0x70,0x78,0x90,0x97,0xa7,0x74,0x02,0xf0,0x90,0x00,0x48,0xe0,
+0x44,0x0c,0xf0,0x90,0x00,0x47,0xe0,0x44,0x08,0xf0,0x90,0x00,0x45,0x80,0x5b,0xe4,
+0x90,0x97,0xa7,0xf0,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,0x2b,0x08,0x90,
+0x00,0x45,0xe0,0x44,0xef,0xf0,0xe0,0x54,0xef,0xf0,0xa3,0x80,0x2d,0x90,0x97,0xa7,
+0x74,0x01,0xf0,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x96,0x12,0x25,0x08,0x7f,0x80,0x7e,0x08,0x12,0x2b,0x08,0x90,0x00,
+0x45,0xe0,0x44,0x20,0xf0,0xe0,0x44,0x10,0xf0,0xa3,0xe0,0x44,0x10,0xf0,0x22,0x02,
+0x74,0xed,0x02,0x67,0xa3,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0x40,0x03,0xf6,0x80,
+0x01,0xf2,0x08,0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,0xf8,0x54,0x07,0x24,0x0c,0xc8,
+0xc3,0x33,0xc4,0x54,0x0f,0x44,0x20,0xc8,0x83,0x40,0x04,0xf4,0x56,0x80,0x01,0x46,
+0xf6,0xdf,0xe4,0x80,0x0b,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x90,0x7e,0xd4,
+0xe4,0x7e,0x01,0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,0x30,0xe5,0x09,0x54,0x1f,0xfe,
+0xe4,0x93,0xa3,0x60,0x01,0x0e,0xcf,0x54,0xc0,0x25,0xe0,0x60,0xa8,0x40,0xb8,0xe4,
+0x93,0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,
+0x83,0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xdf,0xe9,0xde,0xe7,
+0x80,0xbe,0x90,0x06,0xa9,0xe0,0xf5,0x0a,0x54,0xc0,0x70,0x0e,0x90,0x97,0xc8,0xf0,
+0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x02,0x6f,0xb5,0xe5,0x0a,0x30,0xe6,0x1f,0x90,
+0x97,0xc8,0x74,0x01,0xf0,0x90,0x97,0xcd,0xe0,0x44,0x01,0xf0,0x90,0x97,0xcb,0xe0,
+0x64,0x02,0x60,0x05,0x12,0x7e,0x95,0x80,0x0c,0x12,0x7b,0x3d,0x80,0x07,0x90,0x97,
+0xcd,0xe0,0x54,0xfe,0xf0,0xe5,0x0a,0x30,0xe7,0x29,0x90,0x97,0xc8,0x74,0x01,0xf0,
+0x90,0x97,0xcd,0xe0,0x44,0x02,0xf0,0x75,0x44,0x03,0xe4,0xf5,0x45,0xfb,0xfd,0x7f,
+0x54,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,0xcc,0x74,
+0x01,0xf0,0x22,0x90,0x97,0xcd,0xe0,0x54,0xfd,0xf0,0x22,0xe4,0x90,0x97,0x6e,0xf0,
+0xe5,0x68,0x60,0x6c,0xe5,0x67,0x64,0x01,0x70,0x66,0xe5,0x68,0x64,0x02,0x60,0x06,
+0xe5,0x68,0x64,0x03,0x70,0x1d,0x90,0x97,0xbd,0xe0,0x14,0xf0,0xe0,0x60,0x04,0xa3,
+0xe0,0x60,0x16,0x90,0x97,0xbd,0xe0,0x70,0x0a,0x90,0x97,0xc9,0xe0,0x90,0x97,0xbd,
+0xf0,0x80,0x00,0x90,0x97,0x6e,0x74,0x01,0xf0,0x90,0x97,0x6e,0xe0,0x60,0x31,0x90,
+0x97,0xcd,0xe0,0x44,0x10,0xf0,0x90,0x97,0xc4,0xe0,0xf5,0x44,0xe4,0xf5,0x45,0xfb,
+0xfd,0x7f,0x54,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,
+0xc7,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xb5,
+0x22,0xab,0x07,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,
+0xf5,0x83,0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x54,
+0x1f,0xfa,0xd3,0x9f,0x40,0x02,0xaa,0x07,0xea,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xea,0x25,0xe0,0x24,0x66,
+0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,
+0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x25,0x08,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,
+0x04,0xf5,0x83,0xea,0xf0,0xff,0x22,0x8d,0x0b,0xe5,0x0b,0x54,0x1f,0xf5,0x0f,0x74,
+0x01,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xf5,0x0e,0x90,0x04,0xfd,0xe0,
+0xb4,0x01,0x05,0x75,0x10,0x03,0x80,0x03,0x75,0x10,0x01,0xeb,0xc3,0x95,0x10,0x40,
+0x03,0x02,0x76,0x21,0xe5,0x0e,0x25,0x0d,0xfe,0xe5,0x0f,0x90,0x41,0xd6,0x93,0xfd,
+0xee,0xd3,0x9d,0x74,0x01,0x40,0x18,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,
+0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe5,0x0b,0xf0,0x22,0x2f,
+0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x22,0x8e,0x11,0x8f,0x12,0x8b,0x13,
+0x8a,0x14,0x89,0x15,0xe4,0x90,0x97,0x79,0xf0,0xef,0x90,0x00,0x31,0xf0,0x12,0x7e,
+0xa6,0xe5,0x11,0x54,0x03,0xff,0x90,0x00,0x32,0xe0,0x54,0xfc,0x4f,0xf0,0x12,0x7e,
+0xa6,0x90,0x00,0x33,0xe0,0x54,0x7f,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x33,0xe0,0x20,
+0xe7,0x0e,0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x05,0xe0,0x04,0xf0,0x80,0xeb,
+0x90,0x97,0x79,0xe0,0xc3,0x94,0x64,0x50,0x10,0x90,0x00,0x30,0xe0,0xab,0x13,0xaa,
+0x14,0xa9,0x15,0x12,0x62,0x95,0x7f,0x01,0x22,0x7f,0x00,0x22,0xd3,0x10,0xaf,0x01,
+0xc3,0xc0,0xd0,0x8b,0x5e,0x8a,0x5f,0x89,0x60,0x90,0x97,0xd6,0xeb,0xf0,0xa3,0xea,
+0xf0,0xa3,0xe9,0xf0,0xa3,0xe5,0x61,0xf0,0xa3,0xe5,0x62,0xf0,0xa3,0xe5,0x63,0xf0,
+0xaf,0x64,0x15,0x64,0xef,0x60,0x2a,0x90,0x97,0xd9,0xe0,0xfb,0xa3,0xe4,0x75,0xf0,
+0x01,0x12,0x62,0xdf,0xa9,0xf0,0xfa,0x12,0x24,0x62,0xff,0x90,0x97,0xd6,0xe0,0xfb,
+0xa3,0xe4,0x75,0xf0,0x01,0x12,0x62,0xdf,0xa9,0xf0,0xfa,0xef,0x12,0x62,0x95,0x80,
+0xcf,0xab,0x5e,0xaa,0x5f,0xa9,0x60,0xd0,0xd0,0x92,0xaf,0x22,0x8b,0x11,0x8a,0x12,
+0x89,0x13,0x12,0x7e,0x83,0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x24,0x62,0xf5,0x68,
+0x14,0x60,0x0e,0x14,0x60,0x0f,0x14,0x60,0x1a,0x24,0x03,0x70,0x3c,0x7f,0x01,0x80,
+0x35,0xe4,0xff,0x80,0x31,0x90,0x97,0xc9,0x74,0x01,0xf0,0x90,0x97,0xbd,0xf0,0xe4,
+0xff,0x80,0x23,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x68,0xff,
+0x90,0x97,0xc9,0x70,0x05,0x74,0x05,0xf0,0x80,0x02,0xef,0xf0,0x90,0x97,0xc9,0xe0,
+0x90,0x97,0xbd,0xf0,0xe4,0xff,0x12,0x73,0x9f,0x22,0x90,0x00,0x45,0xe4,0xf0,0x90,
+0x04,0xfd,0xf0,0xa3,0xf0,0x90,0x97,0xab,0xf0,0x90,0x97,0xb1,0xf0,0x90,0x97,0xb4,
+0xf0,0x90,0x97,0xb2,0xf0,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb3,0xf0,0x90,0x97,0xb6,
+0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,0xa2,
+0xf0,0x90,0x97,0xa7,0xf0,0x90,0x97,0xa9,0xf0,0x90,0x97,0xbb,0xf0,0x90,0x97,0xac,
+0xf0,0x90,0x97,0xa8,0xf0,0x90,0x97,0xa1,0xf0,0x90,0x00,0x51,0xe0,0x44,0xc0,0xf0,
+0x22,0x90,0x05,0x60,0xe0,0x90,0x97,0xb7,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,
+0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0xb9,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0xba,
+0xf0,0xc3,0x74,0xff,0x9f,0xfe,0x90,0x97,0xb8,0xe0,0xd3,0x9e,0x40,0x1e,0xe0,0x2f,
+0xf0,0xa3,0xe0,0xb4,0xff,0x0f,0xe4,0xf0,0xa3,0xe0,0xb4,0xff,0x03,0xe4,0xf0,0x22,
+0x90,0x97,0xba,0x80,0x03,0x90,0x97,0xb9,0xe0,0x04,0xf0,0x22,0x90,0x97,0xb8,0xe0,
+0x2f,0xf0,0x22,0xe4,0xf5,0x67,0x90,0x97,0xcd,0xf0,0xf5,0x68,0x90,0x97,0xca,0x74,
+0x0c,0xf0,0x90,0x97,0xc7,0xf0,0xe4,0x90,0x97,0xcb,0xf0,0x90,0x97,0xc6,0xf0,0x90,
+0x97,0xc5,0xf0,0x90,0x97,0xc9,0x04,0xf0,0x90,0x97,0xbd,0xf0,0xe4,0x90,0x97,0xcc,
+0xf0,0x90,0x97,0xc8,0xf0,0x90,0x97,0xbf,0xf0,0x90,0x97,0xc4,0x74,0x07,0xf0,0xe4,
+0x90,0x97,0xbe,0xf0,0x90,0x97,0xc2,0xf0,0xa3,0x74,0x02,0xf0,0xe4,0x90,0x97,0xc1,
+0xf0,0x22,0x90,0x00,0x2b,0xe0,0x44,0x01,0xf0,0x7f,0xe8,0x7e,0x03,0x12,0x32,0x15,
+0x90,0x00,0x08,0xe0,0x44,0x10,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x09,0xe0,0x54,0xf7,
+0xf0,0x12,0x7e,0xa6,0x90,0x00,0x28,0xe0,0x54,0xfe,0xf0,0x12,0x7e,0xa6,0x90,0x00,
+0x20,0xe0,0x54,0xfe,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x25,0xe0,0x44,0x40,0xf0,0x12,
+0x7e,0xa6,0x90,0x00,0x09,0xe0,0x54,0xef,0xf0,0x02,0x7e,0xa6,0xe4,0x90,0x97,0xd3,
+0xf0,0xa2,0xaf,0x33,0x90,0x97,0x7a,0xf0,0x90,0x00,0x80,0xe0,0x20,0xe1,0x1a,0x12,
+0x32,0x2b,0x12,0x32,0x2b,0x90,0x97,0x79,0xe0,0x64,0x01,0xf0,0xe0,0x24,0x5c,0x90,
+0x01,0xc4,0xf0,0x74,0x79,0xa3,0xf0,0x80,0xdf,0x90,0x06,0x30,0x74,0x01,0xf0,0xc2,
+0xaf,0x90,0x00,0x80,0xe0,0x44,0x80,0xf0,0x12,0x7e,0xa6,0x90,0x97,0x7a,0xe0,0x24,
+0xff,0x92,0xaf,0x22,0x90,0x00,0x25,0xe0,0x54,0xbf,0xf0,0x12,0x7e,0xa6,0x90,0x00,
+0x20,0xe0,0x44,0x01,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x28,0xe0,0x44,0x01,0xf0,0x12,
+0x7e,0xa6,0x90,0x00,0xf0,0xe0,0x30,0xe1,0xf9,0x90,0x00,0x09,0xe0,0x44,0x08,0xf0,
+0x12,0x7e,0xa6,0x90,0x00,0x08,0xe0,0x54,0xef,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x2b,
+0xe0,0x54,0xfe,0xf0,0x7f,0xe8,0x7e,0x03,0x02,0x32,0x15,0x90,0x97,0xcc,0xe0,0x60,
+0x12,0xe4,0xf0,0xa3,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0x03,0x70,0x33,0x90,0x97,0xc8,
+0xf0,0x80,0x23,0x90,0x97,0xbe,0xe0,0x04,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xef,0xf0,
+0x90,0x97,0xbe,0xe0,0xd3,0x94,0x01,0x40,0x0d,0xe5,0x67,0xb4,0x01,0x12,0xa3,0xe0,
+0x70,0x0e,0xe0,0x04,0xf0,0x22,0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x12,0x6f,0xb5,
+0x22,0x90,0x97,0x87,0xee,0xf0,0xa3,0xef,0xf0,0x75,0x22,0x01,0x8e,0x23,0xf5,0x24,
+0xe4,0xfd,0x7f,0x0b,0x12,0x6e,0x27,0xe4,0xfd,0x7f,0x02,0x12,0x6e,0x27,0x12,0x7e,
+0x05,0xe4,0xff,0x12,0x7e,0xe1,0xe4,0xf5,0x26,0x90,0x01,0xc9,0xe5,0x26,0xf0,0x90,
+0x97,0x87,0xe0,0xfc,0xa3,0xe0,0xfd,0xec,0xfb,0x8d,0x44,0xe4,0xf5,0x45,0x7d,0x01,
+0x7f,0x60,0x7e,0x01,0x02,0x30,0x62,0xe4,0x90,0x97,0xeb,0xf0,0xa3,0xf0,0x90,0x05,
+0xf8,0xe0,0x70,0x0f,0xa3,0xe0,0x70,0x0b,0xa3,0xe0,0x70,0x07,0xa3,0xe0,0x70,0x03,
+0x7f,0x01,0x22,0xd3,0x90,0x97,0xec,0xe0,0x94,0xe8,0x90,0x97,0xeb,0xe0,0x94,0x03,
+0x40,0x03,0x7f,0x00,0x22,0x7f,0x32,0x7e,0x00,0x12,0x32,0x15,0x90,0x97,0xec,0xe0,
+0x04,0xf0,0x70,0xca,0x90,0x97,0xeb,0xe0,0x04,0xf0,0x80,0xc2,0xe5,0x22,0x64,0x01,
+0x70,0x3c,0x12,0x7e,0x05,0xbf,0x01,0x05,0x7f,0x01,0x12,0x7e,0xe1,0x90,0x00,0x46,
+0xe0,0x44,0x04,0xf0,0x12,0x7e,0xa6,0x90,0x00,0x44,0xe0,0x54,0xfb,0xf0,0x12,0x7e,
+0xa6,0x90,0x00,0x46,0xe0,0x54,0xfb,0xf0,0x12,0x7e,0xa6,0x7f,0x02,0x12,0x71,0x28,
+0x8f,0x26,0x90,0x01,0xc9,0xe5,0x26,0xf0,0xb4,0x01,0x03,0x12,0x7e,0x3d,0x22,0xe5,
+0x55,0x70,0x37,0x90,0x97,0xca,0xe0,0x54,0x0f,0xd3,0x94,0x01,0x50,0x2c,0x90,0x02,
+0x87,0xe0,0x70,0x26,0x90,0x97,0xd4,0xe0,0xb4,0x02,0x10,0x90,0x97,0xce,0xe0,0xfe,
+0xa3,0xe0,0xf5,0x82,0x8e,0x83,0xe0,0x60,0x08,0x80,0x0f,0x90,0x01,0xaf,0xe0,0x70,
+0x09,0x90,0x97,0xc1,0xe0,0x60,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x01,0x5f,
+0xe4,0xf0,0x90,0x01,0x3c,0x74,0x08,0xf0,0x75,0x44,0x14,0xe4,0xf5,0x45,0xfb,0xfd,
+0x7f,0x5c,0x7e,0x01,0x12,0x30,0x62,0x90,0x01,0x5f,0x74,0x05,0xf0,0x90,0x06,0x92,
+0x74,0x02,0xf0,0x90,0x97,0xc5,0x14,0xf0,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xc3,0x94,
+0x0c,0x50,0x07,0x7d,0x01,0x7f,0x0c,0x12,0x6f,0xb5,0x22,0x90,0x04,0x1b,0xe0,0x54,
+0x7f,0x64,0x7f,0x70,0x2b,0x90,0x97,0xc8,0xe0,0x64,0x01,0x60,0x23,0x90,0x97,0xca,
+0xe0,0x54,0x0f,0xd3,0x94,0x02,0x50,0x18,0x90,0x97,0xcd,0xe0,0x20,0xe4,0x11,0x90,
+0x97,0xc6,0xe0,0x64,0x01,0x60,0x09,0x90,0x97,0xbf,0xe0,0x70,0x03,0x7f,0x01,0x22,
+0x7f,0x00,0x22,0x90,0x01,0x37,0x74,0x02,0xf0,0x90,0x05,0x22,0x74,0xff,0xf0,0x12,
+0x7a,0x77,0xef,0x70,0x06,0x90,0x01,0xc8,0x74,0xfd,0xf0,0x7d,0x02,0x7f,0x03,0x12,
+0x31,0x9d,0xe5,0x68,0x60,0x05,0x7f,0x01,0x12,0x7e,0x22,0x12,0x6a,0xc1,0x90,0x97,
+0xc7,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x8f,0x27,0x90,0x97,0xd2,0xe0,
+0xff,0x7d,0x01,0x12,0x70,0x73,0xe5,0x27,0x60,0x10,0x74,0x21,0x2f,0xf5,0x82,0xe4,
+0x34,0xfc,0xf5,0x83,0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,0xf5,0x82,0xe4,
+0x34,0xfc,0xf5,0x83,0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x7d,
+0x02,0x7f,0x03,0x12,0x31,0x2c,0xe5,0x68,0x60,0x23,0x90,0x97,0xcb,0xe0,0x60,0x06,
+0x7d,0x01,0x7f,0x0c,0x80,0x0f,0x90,0x97,0xc7,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,
+0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xb5,0xe4,0xff,0x12,0x7e,0x22,0x22,0x90,0x02,
+0x09,0xe0,0xfd,0x12,0x24,0x62,0xfe,0xaf,0x05,0xed,0x2e,0x90,0x97,0xd0,0xf0,0x90,
+0x00,0x01,0x12,0x62,0x68,0xff,0xed,0x2f,0x90,0x97,0xd1,0xf0,0x90,0x00,0x02,0x12,
+0x62,0x68,0xff,0xae,0x05,0xed,0x2f,0x90,0x97,0xd2,0xf0,0x22,0x90,0x00,0x02,0x12,
+0x62,0x68,0x90,0x97,0xab,0xf0,0xe0,0x60,0x04,0xe0,0xb4,0xff,0x1c,0xa2,0xaf,0xe4,
+0x33,0xf5,0x11,0xc2,0xaf,0x90,0x00,0x47,0xe0,0x54,0xfb,0xf0,0x7d,0x40,0x7f,0x01,
+0x12,0x31,0x66,0xe5,0x11,0x24,0xff,0x92,0xaf,0x22,0x90,0x06,0x34,0xe0,0x60,0x26,
+0x14,0x70,0x1b,0x7b,0x01,0x7a,0x06,0x79,0x35,0x7f,0xf9,0x7e,0x01,0x12,0x76,0xfa,
+0xbf,0x01,0x09,0x90,0x06,0x35,0xe0,0x54,0x0f,0xf0,0x80,0x05,0x80,0x00,0x02,0x7e,
+0xc6,0xe4,0x90,0x06,0x34,0xf0,0x22,0x12,0x24,0x62,0xff,0xc3,0x94,0x20,0x50,0x14,
+0x90,0x00,0x02,0x12,0x62,0x68,0xfe,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,
+0x83,0xee,0xf0,0x22,0xef,0xb4,0x20,0x0a,0x90,0x00,0x02,0x12,0x62,0x68,0x90,0x93,
+0x61,0xf0,0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,0xff,0xbf,0x7f,0x1a,0x90,0x97,0xc6,
+0xe0,0x70,0x14,0x90,0x97,0xc5,0xe0,0x70,0x0e,0x90,0x97,0xca,0xe0,0x54,0x0f,0xd3,
+0x94,0x04,0x50,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x97,0x6e,0xe0,0x54,0xf0,
+0x44,0x03,0xf0,0x54,0x0f,0x44,0x80,0xf0,0x90,0x97,0x73,0xe4,0xf0,0xa3,0x74,0x00,
+0xf0,0xa3,0x74,0x56,0xf0,0x7b,0x01,0x7a,0x97,0x79,0x6e,0x02,0x72,0x70,0x90,0x06,
+0x04,0xe0,0x54,0xbf,0xf0,0xef,0x60,0x0a,0xe5,0x67,0xb4,0x01,0x05,0xe4,0xff,0x12,
+0x7b,0xea,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x0c,0xf0,0x22,0xd3,0x10,
+0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x00,0x01,0x12,0x62,0x68,0x90,0x97,0xcb,0xf0,0x12,
+0x24,0x62,0x65,0x68,0x60,0x03,0x12,0x77,0xbc,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x97,
+0xf0,0xef,0xf0,0x12,0x71,0xd1,0x90,0x97,0xf0,0xe0,0x60,0x05,0x90,0x05,0x22,0xe4,
+0xf0,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x75,0x28,0x33,
+0xe4,0xf5,0x29,0x75,0x2a,0x02,0xf5,0x2b,0x90,0x01,0x30,0xe5,0x28,0xf0,0xa3,0xe5,
+0x29,0xf0,0xa3,0xe5,0x2a,0xf0,0xa3,0xe5,0x2b,0xf0,0x22,0x90,0x06,0x04,0xe0,0x44,
+0x40,0xf0,0xe5,0x67,0xb4,0x01,0x05,0x7f,0x01,0x12,0x7b,0xea,0x90,0x97,0xc7,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,0xe0,
+0x44,0x01,0xf0,0x12,0x79,0x12,0x12,0x79,0xa4,0x90,0x97,0xc7,0xe0,0x54,0xf0,0xf0,
+0xe0,0x44,0x02,0xf0,0x22,0x7f,0x0b,0x12,0x71,0x28,0xef,0x65,0x25,0x60,0x10,0xe5,
+0x25,0xb4,0x01,0x05,0xe4,0xf5,0x25,0x80,0x03,0x75,0x25,0x01,0x7f,0x01,0x22,0x7f,
+0x00,0x22,0xef,0x60,0x0b,0x90,0x97,0xd5,0xe0,0xb4,0x01,0x10,0xe4,0xff,0x80,0x09,
+0x90,0x97,0xd5,0xe0,0xb4,0x01,0x05,0x7f,0x01,0x12,0x4e,0x3f,0x22,0x90,0x00,0x49,
+0xe0,0x90,0x97,0xf2,0xf0,0xe0,0x54,0x0f,0xf0,0xe0,0xff,0x44,0xf0,0x90,0x00,0x49,
+0xf0,0xef,0x44,0xb0,0xf0,0x22,0x75,0x30,0x1f,0x75,0x31,0x01,0xe4,0xf5,0x32,0x90,
+0x01,0x38,0xe5,0x30,0xf0,0xa3,0xe5,0x31,0xf0,0xa3,0xe5,0x32,0xf0,0x22,0x90,0x01,
+0x3c,0x74,0xff,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x01,0x34,0xf0,0xa3,0xf0,0xa3,0xf0,
+0xa3,0xf0,0x22,0xe4,0x90,0x97,0xcc,0xf0,0x90,0x97,0xbe,0xf0,0x90,0x97,0xc8,0xf0,
+0x90,0x97,0xcd,0xf0,0x22,0x90,0x97,0xd1,0xe0,0xff,0xe4,0xfd,0x12,0x70,0x73,0x90,
+0x04,0x1f,0x74,0x01,0xf0,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x7f,0x10,0xdf,
+0xfe,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x09,0x28,0xef,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x06,0x34,0x74,0xff,0xf0,0xe4,0xa3,0xf0,0xa3,
+0xf0,0xa3,0xf0,0x22,0x41,0x97,0xef,0x00,0x41,0x97,0xbc,0x80,0x41,0x97,0xf1,0x00,
+0x00,0x90,0x01,0xca,0xe5,0x25,0xf0,0xef,0x60,0x03,0x12,0x7e,0x3d,0x22,0x90,0x97,
+0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x22,0x90,0x97,0xe5,0xeb,0xf0,0xa3,
+0xea,0xf0,0xa3,0xe9,0xf0,0x22,0x90,0x97,0xe8,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,
+0xf0,0x22,0x8f,0x82,0x8e,0x83,0xa3,0xa3,0xa3,0xe4,0xf0,0x22,0xe4,0xf5,0x22,0x7f,
+0x60,0x7e,0x01,0x02,0x7f,0x12,0x8f,0x1c,0x8c,0x1d,0x8d,0x1e,0x22,0x8f,0x1f,0x8c,
+0x20,0x8d,0x21,0x22,0x12,0x24,0x62,0xf5,0x67,0x22,0xe4,0xf5,0x25,0x22,0x22,0x00,
+0x18,0xe6,};
+#endif
+// =================== UMC B Cut V68.1 2011-02-24 =====================
+u8 Rtl8192CUFwUMCBCutImgArray[UMCBCutImgArrayLength] = {
+0xc2,0x88,0x02,0x00,0x44,0x00,0x01,0x00,0x02,0x23,0x15,0x25,0xae,0x3f,0x01,0x00,
+0x92,0x52,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x02,0x74,0x8f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x59,0x7b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x72,0x59,0x00,0x00,0x00,0x00,0x00,0x02,0x66,0x96,0x00,0x00,
+0x05,0x04,0x03,0x02,0x00,0x03,0x06,0x05,0x04,0x03,0x00,0x04,0x06,0x05,0x04,0x02,
+0x00,0x04,0x08,0x07,0x06,0x04,0x00,0x06,0x0a,0x09,0x08,0x06,0x00,0x08,0x0a,0x09,
+0x08,0x04,0x00,0x08,0x0a,0x09,0x08,0x02,0x00,0x08,0x0a,0x09,0x08,0x00,0x00,0x08,
+0x12,0x11,0x10,0x08,0x00,0x10,0x1a,0x19,0x18,0x10,0x00,0x18,0x22,0x21,0x20,0x18,
+0x00,0x20,0x22,0x21,0x20,0x10,0x00,0x20,0x22,0x21,0x20,0x08,0x00,0x20,0x22,0x21,
+0x1c,0x08,0x00,0x20,0x22,0x21,0x14,0x08,0x00,0x20,0x22,0x20,0x18,0x08,0x00,0x20,
+0x31,0x30,0x20,0x10,0x00,0x30,0x31,0x30,0x18,0x00,0x00,0x30,0x31,0x2f,0x10,0x10,
+0x00,0x30,0x31,0x2c,0x10,0x10,0x00,0x30,0x31,0x28,0x10,0x00,0x00,0x30,0x31,0x20,
+0x10,0x00,0x00,0x30,0x31,0x10,0x10,0x00,0x00,0x30,0x04,0x04,0x04,0x05,0x04,0x04,
+0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x04,0x05,0x05,0x05,0x06,0x06,0x04,0x04,
+0x05,0x05,0x05,0x05,0x06,0x06,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x07,0x0a,0x0b,
+0x0d,0x10,0x04,0x05,0x05,0x06,0x06,0x09,0x0c,0x11,0x08,0x08,0x09,0x09,0x0a,0x0c,
+0x10,0x11,0x04,0x04,0x04,0x05,0x04,0x04,0x05,0x07,0x07,0x07,0x08,0x0a,0x04,0x04,
+0x04,0x04,0x06,0x0a,0x0b,0x0d,0x05,0x05,0x07,0x07,0x08,0x0b,0x0d,0x0f,0x04,0x04,
+0x04,0x05,0x07,0x07,0x09,0x09,0x0c,0x0e,0x10,0x12,0x04,0x04,0x05,0x05,0x06,0x0a,
+0x11,0x13,0x09,0x09,0x09,0x09,0x0c,0x0e,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x24,0x26,0x2a,0x18,0x1a,0x1d,0x1f,0x21,0x27,0x29,0x2a,0x00,0x00,
+0x00,0x1f,0x23,0x28,0x2a,0x2c,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x18,
+0x00,0x24,0x00,0x30,0x00,0x48,0x00,0x60,0x00,0x90,0x00,0xc0,0x00,0xd8,0x00,0x50,
+0x00,0x78,0x00,0xa0,0x00,0xc8,0x01,0x40,0x01,0x90,0x01,0xe0,0x02,0x30,0x01,0x2c,
+0x01,0x40,0x01,0xe0,0x02,0xd0,0x03,0xe8,0x04,0xb0,0x06,0x40,0x07,0xd0,0x00,0x02,
+0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x0c,0x00,0x12,0x00,0x18,0x00,0x24,0x00,0x30,
+0x00,0x48,0x00,0x60,0x00,0x6c,0x00,0x28,0x00,0x3c,0x00,0x50,0x00,0x64,0x00,0xa0,
+0x00,0xc8,0x00,0xf0,0x01,0x18,0x00,0x64,0x00,0xa0,0x00,0xf0,0x01,0x68,0x01,0xf4,
+0x02,0x58,0x03,0x20,0x03,0xe8,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x04,0x04,
+0x05,0x07,0x04,0x04,0x07,0x0a,0x0a,0x0c,0x0c,0x12,0x05,0x07,0x07,0x08,0x0b,0x12,
+0x24,0x3c,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x01,0x02,
+0x03,0x04,0x05,0x06,0x07,0x08,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x20,0x1e,
+0x1c,0x18,0x10,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0xab,0x07,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,
+0x97,0x92,0xf0,0xe0,0x54,0x1f,0xa3,0xf0,0xfa,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x67,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xf9,0x90,0x97,0x95,0xf0,0xeb,0x25,
+0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,
+0x96,0xcf,0xf0,0xa3,0xef,0xf0,0xeb,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,0x98,0xcf,0xf0,0xa3,0xef,0xf0,0xea,0x25,
+0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0xea,0xc3,0x99,0x40,0x03,0x02,0x43,0x59,0x90,0x97,0x93,
+0xe0,0xff,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0xef,0x04,
+0x90,0x97,0x94,0xf0,0x90,0x97,0x95,0xe0,0xff,0x90,0x97,0x94,0xe0,0xfe,0xd3,0x9f,
+0x40,0x03,0x02,0x43,0x9c,0xee,0xc3,0x94,0x10,0x40,0x21,0xee,0x24,0xf0,0xff,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0x90,0x97,0x96,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,0x90,0x97,0x94,0xe0,
+0xff,0xc3,0x94,0x10,0x50,0x4a,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x98,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x2d,0x90,0x97,0x94,0xe0,0xff,0x64,0x13,0x60,0x09,0xef,0x64,0x12,0x60,
+0x04,0xef,0xb4,0x11,0x0d,0x90,0x97,0x96,0xe0,0x30,0xe0,0x06,0x90,0x97,0x94,0x74,
+0x18,0xf0,0x90,0x97,0x94,0xe0,0x90,0x97,0x93,0xf0,0x90,0x97,0x92,0xf0,0x80,0x4c,
+0x90,0x97,0x94,0xe0,0x04,0xf0,0x02,0x42,0xc4,0x90,0x97,0x95,0xe0,0xfa,0x90,0x97,
+0x93,0xe0,0xff,0x6a,0x70,0x7d,0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0xe0,0xb4,0x01,0x11,0x90,0x97,0x92,0xe0,0x20,0xe6,0x0a,0xa3,0xe0,0x44,0x40,
+0x90,0x97,0x92,0xf0,0x80,0x06,0x90,0x97,0x92,0xe0,0xff,0x22,0x90,0x97,0x93,0xe0,
+0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,
+0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,
+0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,
+0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,
+0x7f,0x80,0x69,0x90,0x97,0x93,0xe0,0xd3,0x9a,0x40,0x61,0x90,0x97,0x95,0xe0,0xff,
+0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x93,0xef,
+0xf0,0x90,0x97,0x92,0xf0,0xfa,0xa3,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,
+0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,
+0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0xaf,0x02,0x22,0x74,0x01,0x2b,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x92,0xe0,0x44,0x80,0xff,0x74,
+0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0x90,0x97,0x5d,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,
+0x7f,0x78,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,
+0x2f,0xd9,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x69,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,
+0x7f,0x7f,0x70,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x59,0x12,0x2a,0x8b,0x00,0x03,
+0x2d,0x95,0xe4,0xfd,0xff,0x12,0x34,0x81,0x90,0x97,0xd7,0xe0,0xb4,0x01,0x11,0x90,
+0x80,0x59,0x12,0x2a,0x8b,0x00,0x03,0x2d,0x95,0xe4,0xfd,0x7f,0x01,0x12,0x34,0x81,
+0x22,0x22,0x00,0x02,0x7f,0x94,0x02,0x7f,0x9b,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xff,0xc3,0x94,0x20,0x40,0x03,0x02,0x4e,0x3e,0x75,0xf0,0x09,0xef,0xa4,
+0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x4e,0x35,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,0x00,0xec,0x94,0x00,0x50,0x03,0x02,0x4e,0x35,
+0xef,0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf9,0x74,0x90,0x35,0xf0,0xfa,0x7b,0x01,0x8b,
+0x14,0xf5,0x15,0x89,0x16,0x90,0x97,0x79,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,
+0x34,0x91,0xf5,0x83,0xe0,0xfd,0xa3,0xe0,0x90,0x97,0x85,0xcd,0xf0,0xa3,0xed,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0xff,0xa3,0xe0,
+0x90,0x97,0x87,0xcf,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x02,0x12,0x63,0x4d,0xff,0xae,
+0xf0,0x12,0x63,0x22,0x2f,0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8e,0xf0,0xa3,0xef,0xf0,
+0x90,0x00,0x06,0x12,0x63,0x4d,0xff,0xae,0xf0,0x90,0x00,0x04,0x12,0x63,0x4d,0x2f,
+0xff,0xe5,0xf0,0x3e,0x90,0x97,0x8c,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x08,0x12,0x63,
+0x4d,0xff,0x90,0x97,0x8a,0xe5,0xf0,0xf0,0xa3,0xef,0xf0,0x90,0x97,0x79,0xe0,0xfe,
+0x24,0x84,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x3f,0x90,0x97,0x7b,0xf0,
+0xe0,0xfd,0x54,0x1f,0xa3,0xf0,0x75,0xf0,0x09,0xee,0xa4,0x24,0x67,0xf5,0x82,0xe5,
+0xf0,0x34,0x93,0xf5,0x83,0xe0,0x90,0x97,0x90,0xf0,0x90,0x97,0x79,0xe0,0xfb,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xc3,0x94,0x05,0x40,0x03,0x02,0x49,
+0xba,0x90,0x97,0x90,0xe0,0xfe,0x90,0x97,0x7c,0xe0,0x9e,0x40,0x13,0x90,0x97,0x90,
+0xe0,0x90,0x97,0x7c,0xf0,0xed,0x54,0x40,0xfd,0x90,0x97,0x7b,0xf0,0xee,0x4d,0xf0,
+0x90,0x04,0xfd,0xe0,0x64,0x01,0x70,0x28,0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,
+0x93,0xfe,0x74,0x63,0x2b,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,
+0x06,0xef,0x90,0x40,0xda,0x80,0x32,0x90,0x97,0x7c,0xe0,0x90,0x40,0xf6,0x80,0x29,
+0x90,0x97,0x7c,0xe0,0xff,0x90,0x41,0x4a,0x93,0xfe,0x90,0x97,0x79,0xe0,0x24,0x63,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,0x06,0xef,0x90,0x41,0x12,
+0x80,0x07,0x90,0x97,0x7c,0xe0,0x90,0x41,0x2e,0x93,0x90,0x97,0x89,0xf0,0x90,0x97,
+0x89,0xe0,0x75,0xf0,0x06,0xa4,0x24,0x50,0xf9,0x74,0x40,0x35,0xf0,0x75,0x11,0xff,
+0xf5,0x12,0x89,0x13,0x90,0x97,0x7b,0xe0,0x90,0x41,0xf2,0x93,0xff,0xd3,0x90,0x97,
+0x88,0xe0,0x9f,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x0d,0x90,0x97,0x79,0xe0,0xff,
+0xe4,0xfd,0x12,0x5f,0x56,0x02,0x4d,0xcb,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,
+0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,
+0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x29,0xd9,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,
+0xa9,0x16,0x12,0x63,0x22,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,
+0xaa,0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,
+0x15,0xa9,0x16,0x90,0x00,0x02,0x12,0x63,0x4d,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,
+0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,
+0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,
+0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,
+0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xff,0x7e,
+0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x04,0x12,0x63,0x4d,0xfd,0xac,0xf0,
+0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,
+0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x03,0x12,
+0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x06,0x12,0x63,
+0x4d,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,
+0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,
+0x7d,0x12,0x2a,0x7f,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x11,0xaa,0x12,0xa9,0x13,
+0x90,0x00,0x04,0x12,0x62,0x95,0xff,0x7e,0x00,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,
+0x00,0x08,0x12,0x63,0x4d,0xfd,0xac,0xf0,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,
+0x05,0x12,0x62,0x95,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,
+0x29,0xf2,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,0x90,0x97,0x7d,0x40,0x50,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0xab,
+0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x05,0x12,0x62,0x95,0xff,0x7e,0x00,0x90,0x97,
+0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x29,0xf2,0xab,0x07,0xaa,0x06,0xd0,0x07,0xd0,
+0x06,0xd0,0x05,0xd0,0x04,0xc3,0xef,0x9b,0xff,0xee,0x9a,0xfe,0xed,0x94,0x00,0xfd,
+0xec,0x94,0x00,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x80,0x07,0x12,0x2a,0x8b,0x00,
+0x00,0x00,0x00,0x90,0x97,0x7d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x97,0x79,0xe0,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0x90,0x97,0x7b,0xe0,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,
+0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,
+0x40,0x0b,0x90,0x97,0x79,0xe0,0xff,0x12,0x42,0x20,0x02,0x4d,0x99,0x90,0x97,0x7b,
+0xe0,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,
+0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xc3,0x12,0x63,0xd1,0x40,0x03,0x02,0x4d,0x99,0x90,0x97,0x79,
+0xe0,0xff,0x7d,0x01,0x12,0x5f,0x56,0x02,0x4d,0x99,0x90,0x97,0x79,0xe0,0xff,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x64,0x05,0x60,0x03,0x02,0x4b,0xb6,
+0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,
+0x64,0x01,0x70,0x03,0x02,0x4b,0xb6,0x90,0x93,0x62,0xe0,0xff,0xb4,0x03,0x0b,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x19,0x40,0x3d,0x80,0x2e,0xef,0xb4,0x02,0x0b,0x90,0x97,
+0x7c,0xe0,0xc3,0x94,0x11,0x40,0x2e,0x80,0x1f,0x90,0x93,0x62,0xe0,0xff,0xb4,0x01,
+0x0b,0x90,0x97,0x7c,0xe0,0xc3,0x94,0x0a,0x40,0x1b,0x80,0x0c,0xef,0x70,0x11,0x90,
+0x97,0x7c,0xe0,0xc3,0x94,0x03,0x40,0x0d,0x90,0x95,0x83,0x74,0x01,0xf0,0x80,0x05,
+0xe4,0x90,0x95,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0x83,0xf5,0x82,0xe4,0x34,
+0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0x74,0x63,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe0,0xff,0xc3,0x94,0x30,0x50,0x03,0x02,0x4b,0x44,0x90,0x95,0x83,0xe0,
+0x64,0x01,0x60,0x03,0x02,0x4b,0x44,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,0xe4,
+0x34,0x95,0xf5,0x83,0xe0,0x64,0x0a,0x60,0x56,0x90,0x97,0x79,0xe0,0xfe,0xef,0x24,
+0x05,0xfd,0xe4,0x33,0xfc,0x74,0x21,0x2e,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,
+0xff,0xd3,0x9d,0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x33,0xef,0x24,0x05,0xfd,
+0xe4,0x33,0xfc,0x74,0x63,0x2e,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xd3,0x9d,
+0xec,0x64,0x80,0xf8,0x74,0x80,0x98,0x50,0x16,0x90,0x97,0x79,0xe0,0x24,0xc4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xff,0x90,0x97,0x7c,0xe0,0x6f,0x60,0x56,0x90,
+0x97,0x79,0xe0,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xff,0xd3,0x94,
+0x42,0x40,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x11,0xef,0xd3,0x94,0x39,0x90,
+0x97,0x91,0x40,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0x90,0x97,0x79,0xe0,
+0xff,0x24,0x63,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xfe,0x74,0x21,0x2f,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x79,0xe0,0x24,0x84,0xf5,0x82,
+0xe4,0x34,0x95,0x80,0x2f,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,
+0x04,0xf0,0x80,0x14,0xe4,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0x24,0xa4,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x7c,0xe0,0xff,0x90,0x97,0x79,
+0xe0,0xfe,0x24,0xc4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x91,
+0xe0,0xff,0x74,0x83,0x2e,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,
+0xe0,0x1e,0xef,0xc4,0x54,0xf0,0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,
+0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x02,0x4d,0x7c,
+0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,
+0xe0,0x54,0xf0,0x02,0x4d,0x7c,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x96,0xf5,0x83,0xe0,0x64,0x06,0x60,0x03,0x02,0x4d,0x99,0x75,0xf0,0x09,0xef,
+0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0x64,0x01,0x70,0x03,
+0x02,0x4d,0x99,0x90,0x97,0x7d,0x12,0x2a,0x8b,0x00,0x00,0x00,0x00,0x90,0x42,0x13,
+0xe4,0x93,0xff,0x7e,0x00,0x90,0x97,0x85,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x29,0xf2,
+0xe4,0xfc,0xfd,0x90,0x97,0x81,0x12,0x2a,0x7f,0x90,0x97,0x79,0xe0,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xe0,0x90,0x97,0x91,0xf0,0xe4,0x90,0x97,0x7a,0xf0,
+0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x97,0x7a,0xe0,
+0xff,0x75,0xf0,0x02,0xa4,0xf5,0x82,0x85,0xf0,0x83,0x12,0x63,0x4d,0xfd,0xac,0xf0,
+0xef,0x90,0x42,0x0e,0x93,0xff,0x7e,0x00,0x12,0x29,0xf2,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x7d,0x12,0x2a,0x7f,0x90,0x97,0x81,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x97,0x7d,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x63,0xd1,0x50,0x0e,0x90,0x97,0x7a,0xe0,0x04,0xf0,
+0xe0,0x64,0x05,0x60,0x03,0x02,0x4c,0x20,0x90,0x97,0x7a,0xe0,0xc3,0x13,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xb4,0x01,0x0d,0x90,0x97,0x7a,0xe0,0x70,0x5d,0x90,0x97,0x91,
+0x04,0xf0,0x80,0x5b,0xef,0xb4,0x03,0x1d,0x90,0x97,0x7a,0xe0,0xff,0x70,0x08,0x90,
+0x97,0x91,0x74,0x03,0xf0,0x80,0x48,0xef,0xb4,0x01,0x08,0x90,0x97,0x91,0x74,0x01,
+0xf0,0x80,0x3c,0x80,0x35,0x90,0x97,0x91,0xe0,0x64,0x05,0x70,0x32,0x90,0x97,0x7a,
+0xe0,0xff,0x70,0x08,0x90,0x97,0x91,0x74,0x05,0xf0,0x80,0x0f,0xef,0x90,0x97,0x91,
+0xb4,0x01,0x05,0x74,0x03,0xf0,0x80,0x03,0x74,0x01,0xf0,0xd3,0x90,0x97,0x88,0xe0,
+0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,0x97,0x91,0xf0,0xd3,
+0x90,0x97,0x88,0xe0,0x94,0x03,0x90,0x97,0x87,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,
+0x97,0x91,0xf0,0x90,0x97,0x91,0xe0,0xff,0x90,0x97,0x79,0xe0,0xfe,0x24,0x83,0xf5,
+0x82,0xe4,0x34,0x94,0xf5,0x83,0xef,0xf0,0xee,0x30,0xe0,0x1d,0xef,0xc4,0x54,0xf0,
+0x90,0x97,0x91,0xf0,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,
+0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x80,0x13,0x90,0x97,0x79,0xe0,0xc3,0x13,0xff,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0xf0,0xf0,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x90,0x97,0x91,
+0xe0,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x90,0x97,0x79,0xe0,0xff,0x24,0xa4,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xd3,0x94,0x05,0x50,0x0f,0x74,0xa4,0x2f,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x04,0xf0,0x80,0x0f,0x90,0x97,0x79,0xe0,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xab,0x14,0xaa,0x15,0xa9,
+0x16,0xe4,0xf5,0xf0,0x12,0x63,0x85,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x02,
+0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,0x00,0x04,0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,
+0x00,0x06,0xe4,0xf5,0xf0,0x12,0x63,0xa4,0x90,0x00,0x08,0xe4,0xf5,0xf0,0x12,0x63,
+0xa4,0x90,0x97,0x79,0xe0,0xff,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x02,0x45,0x0e,0x22,0xef,
+0x70,0x03,0x02,0x50,0xa7,0x90,0x97,0x6d,0xe0,0x60,0x03,0x02,0x54,0xe9,0x90,0x97,
+0x59,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,
+0x2a,0x7f,0x7f,0x8c,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x97,0x05,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x44,0x7e,
+0x08,0x12,0x2f,0xd9,0x90,0x97,0x09,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x5c,0x7e,0x08,0x12,0x2f,0xd9,0x90,
+0x97,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x6c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x11,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x70,
+0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x15,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x74,0x7e,0x0e,0x12,0x2f,0xd9,
+0x90,0x97,0x19,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x78,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x1d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,
+0x7c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x21,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x0e,0x12,0x2f,
+0xd9,0x90,0x97,0x25,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x80,0x85,0x12,0x2a,0x7f,0x7f,0x84,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x29,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,
+0x7f,0x88,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x2d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x8c,0x7e,0x0e,0x12,
+0x2f,0xd9,0x90,0x97,0x31,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xd0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x35,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,
+0x7f,0x7f,0xd4,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x39,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xd8,0x7e,0x0e,
+0x12,0x2f,0xd9,0x90,0x97,0x3d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xdc,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,
+0x41,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,
+0x2a,0x7f,0x7f,0xe0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x97,0x45,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0xec,0x7e,
+0x0e,0x12,0x2f,0xd9,0x90,0x97,0x49,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,0x2f,0xd9,0x90,
+0x97,0x4d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,
+0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x2f,0xd9,0x90,0x97,0x51,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,
+0x7e,0x09,0x12,0x2f,0xd9,0x90,0x97,0x55,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x08,0x12,0x2f,0xd9,
+0x90,0x97,0x6d,0x74,0x01,0xf0,0x22,0x90,0x97,0x6d,0xe0,0x64,0x01,0x60,0x03,0x02,
+0x54,0xe9,0x7f,0x8c,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x59,0x12,0x2a,0x7f,0x7f,
+0x44,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x05,0x12,0x2a,0x7f,0x7f,0x5c,0x7e,0x08,
+0x12,0x27,0xde,0x90,0x97,0x09,0x12,0x2a,0x7f,0x7f,0x6c,0x7e,0x0e,0x12,0x27,0xde,
+0x90,0x97,0x0d,0x12,0x2a,0x7f,0x7f,0x70,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x11,
+0x12,0x2a,0x7f,0x7f,0x74,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x15,0x12,0x2a,0x7f,
+0x7f,0x78,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x19,0x12,0x2a,0x7f,0x7f,0x7c,0x7e,
+0x0e,0x12,0x27,0xde,0x90,0x97,0x1d,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x0e,0x12,0x27,
+0xde,0x90,0x97,0x21,0x12,0x2a,0x7f,0x7f,0x84,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,
+0x25,0x12,0x2a,0x7f,0x7f,0x88,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x29,0x12,0x2a,
+0x7f,0x7f,0x8c,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x2d,0x12,0x2a,0x7f,0x7f,0xd0,
+0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x31,0x12,0x2a,0x7f,0x7f,0xd4,0x7e,0x0e,0x12,
+0x27,0xde,0x90,0x97,0x35,0x12,0x2a,0x7f,0x7f,0xd8,0x7e,0x0e,0x12,0x27,0xde,0x90,
+0x97,0x39,0x12,0x2a,0x7f,0x7f,0xdc,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x3d,0x12,
+0x2a,0x7f,0x7f,0xe0,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x41,0x12,0x2a,0x7f,0x7f,
+0xec,0x7e,0x0e,0x12,0x27,0xde,0x90,0x97,0x45,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,
+0x12,0x27,0xde,0x90,0x97,0x49,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x27,0xde,
+0x90,0x97,0x4d,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x27,0xde,0x90,0x97,0x51,
+0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x55,0x12,0x2a,0x7f,
+0x7f,0x8c,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0xc0,0xfd,0xec,
+0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x8c,0x7e,0x08,0x12,0x2f,
+0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0x01,0x00,0x00,0x7f,0x44,0x7e,0x08,0x12,
+0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0xdb,0x25,0xa4,0x7f,0x5c,0x7e,0x08,
+0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x6c,0x7e,
+0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x70,
+0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,0xa4,0x7f,
+0x74,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,0xa4,
+0x7f,0x78,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,0x25,
+0xa4,0x7f,0x7c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x04,0x1b,
+0x25,0xa4,0x7f,0x80,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x63,
+0xdb,0x25,0xa4,0x7f,0x84,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,
+0x04,0x1b,0x25,0xa4,0x7f,0x88,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,0x2a,
+0x8b,0x20,0xdb,0x25,0xa4,0x7f,0x8c,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,0x12,
+0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd0,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x85,
+0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd4,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,
+0x85,0x12,0x2a,0x8b,0x20,0xdb,0x25,0xa4,0x7f,0xd8,0x7e,0x0e,0x12,0x2f,0xd9,0x90,
+0x80,0x85,0x12,0x2a,0x8b,0x00,0x1b,0x25,0xa4,0x7f,0xdc,0x7e,0x0e,0x12,0x2f,0xd9,
+0x90,0x80,0x85,0x12,0x2a,0x8b,0x00,0x1b,0x25,0xa4,0x7f,0xe0,0x7e,0x0e,0x12,0x2f,
+0xd9,0x90,0x80,0x85,0x12,0x2a,0x8b,0x24,0xdb,0x25,0xa4,0x7f,0xec,0x7e,0x0e,0x12,
+0x2f,0xd9,0x7f,0x04,0x7e,0x0c,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,
+0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe7,
+0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x44,0x11,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,
+0x7e,0x0c,0x12,0x2f,0xd9,0x7f,0x04,0x7e,0x0d,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,
+0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,
+0xf0,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x01,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,
+0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,
+0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0d,0x12,0x2f,0xd9,0x7f,0x0c,0x7e,0x09,0x12,
+0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x11,0xff,0xec,0x90,0x97,0xe7,
+0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x2f,0xd9,0x7f,0x0c,
+0x7e,0x09,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x54,0x0f,0xfd,0xec,0x54,0xf0,
+0xfc,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0x10,0xfd,0xec,0x44,0x01,0xfc,0x90,0x97,0xe7,
+0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x0c,0x7e,0x09,0x12,0x2f,0xd9,0x7f,0x04,
+0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xf0,0xff,0xec,0x90,0x97,0xe7,0x12,
+0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,
+0x01,0xff,0xec,0x90,0x97,0xe7,0x12,0x2a,0x7f,0x90,0x97,0xe7,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,
+0x08,0x12,0x2f,0xd9,0xe4,0x90,0x97,0x6d,0xf0,0x22,0x8f,0x11,0xef,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xaf,0x82,0xf5,0x12,0x8f,0x13,0xe5,0x11,0x75,0xf0,
+0x02,0xa4,0x24,0x81,0xf9,0x74,0x92,0x35,0xf0,0x75,0x14,0x01,0xf5,0x15,0x89,0x16,
+0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xaf,0x82,
+0xf5,0x17,0x8f,0x18,0xe5,0x11,0x75,0xf0,0x09,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,
+0xf0,0x75,0x19,0x01,0xf5,0x1a,0x89,0x1b,0x74,0xc1,0x25,0x11,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0xe0,0x12,0x63,0xee,0x55,0x6c,0x00,0x55,0x81,0x01,0x55,0x96,0x02,
+0x55,0xab,0x03,0x55,0xd5,0x04,0x55,0xea,0x05,0x55,0xff,0x06,0x56,0x26,0x0c,0x56,
+0x54,0x0d,0x56,0x81,0x0e,0x56,0xae,0x0f,0x00,0x00,0x56,0xe2,0xe5,0x11,0x25,0xe0,
+0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x15,0x80,
+0x3c,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,
+0xf0,0xa3,0x74,0x10,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x05,0x80,0x12,0xe5,0x11,0x25,0xe0,0x24,
+0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0xe4,0xf0,0xe5,0x11,
+0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,
+0x8f,0xf0,0x02,0x56,0xe2,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf5,0x80,0x27,0xe5,0x11,0x25,0xe0,0x24,0x24,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf0,0x80,0x12,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0xa3,0x74,
+0x0d,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,
+0xf0,0xa3,0xf0,0x02,0x56,0xe2,0x90,0x04,0x47,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,
+0x12,0x62,0xc2,0x90,0x04,0x46,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,
+0x12,0x62,0xd4,0x90,0x04,0x45,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,
+0x44,0x02,0x56,0xd9,0x90,0x04,0x4b,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,
+0xc2,0x90,0x04,0x4a,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,
+0xd4,0x90,0x04,0x49,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x48,0x80,
+0x58,0x90,0x04,0x4f,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0xc2,0x90,0x04,
+0x4e,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xd4,0x90,0x04,
+0x4d,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x4c,0x80,0x2b,0x90,0x04,
+0x53,0xe0,0xab,0x14,0xaa,0x15,0xa9,0x16,0x12,0x62,0xc2,0x90,0x04,0x52,0xe0,0xab,
+0x14,0xaa,0x15,0xa9,0x16,0x90,0x00,0x01,0x12,0x62,0xd4,0x90,0x04,0x51,0xe0,0x85,
+0x13,0x82,0x85,0x12,0x83,0xf0,0x90,0x04,0x50,0xe0,0x85,0x13,0x82,0x85,0x12,0x83,
+0xa3,0xf0,0xab,0x14,0xaa,0x15,0xa9,0x16,0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x29,
+0xd9,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,0x12,0x29,0xd9,0x5f,0xd0,0x01,0xd0,0x02,
+0xd0,0x03,0x12,0x62,0xc2,0xab,0x14,0xe5,0x16,0x24,0x01,0xf9,0xe4,0x35,0x15,0xfa,
+0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x29,0xd9,0xff,0xab,0x19,0xaa,0x1a,0xa9,0x1b,
+0x90,0x00,0x01,0x12,0x62,0x95,0x5f,0xd0,0x01,0xd0,0x02,0xd0,0x03,0x12,0x62,0xc2,
+0x85,0x13,0x82,0x85,0x12,0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,
+0x17,0x83,0xe0,0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0x85,0x13,0x82,0x85,0x12,
+0x83,0xa3,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x18,0x82,0x85,0x17,0x83,0xa3,0xe0,
+0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x4c,0x90,0x97,0x90,0x74,
+0x0b,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x50,0x03,0x02,0x58,0x28,0x74,
+0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,
+0xa3,0xe0,0x5f,0x4e,0x60,0x0a,0x90,0x97,0x90,0xe0,0x24,0x10,0xa3,0xf0,0x80,0x68,
+0x90,0x97,0x90,0xe0,0x14,0xf0,0x80,0xba,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0x90,0x97,0x90,0x74,
+0x0f,0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x00,0x40,0x3c,0x74,0x01,0x7e,0x00,
+0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,
+0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,
+0x4e,0x60,0x08,0x90,0x97,0x90,0xe0,0xa3,0xf0,0x80,0x0d,0x90,0x97,0x90,0xe0,0x14,
+0xf0,0x80,0xbf,0xe4,0x90,0x97,0x91,0xf0,0xe5,0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0xe4,0x90,0x97,0x90,
+0xf0,0x90,0x97,0x90,0xe0,0xff,0xc3,0x94,0x10,0x40,0x03,0x02,0x58,0xe2,0x74,0x01,
+0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,
+0x11,0x25,0xe0,0x24,0x24,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,
+0xe0,0x5f,0x4e,0x60,0x06,0x90,0x97,0x90,0xe0,0x80,0x63,0x90,0x97,0x90,0xe0,0x04,
+0xf0,0x80,0xbe,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x46,0xe4,0x90,0x97,0x90,0xf0,0x90,0x97,0x90,0xe0,
+0xff,0xc3,0x94,0x0c,0x50,0x3c,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x11,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,
+0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x08,0x90,0x97,0x90,
+0xe0,0x24,0x10,0x80,0x09,0x90,0x97,0x90,0xe0,0x04,0xf0,0x80,0xbf,0xe4,0x90,0x97,
+0x92,0xf0,0x90,0x97,0x91,0xe0,0xff,0x75,0xf0,0x09,0xe5,0x11,0xa4,0x24,0x67,0xf5,
+0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xef,0xf0,0x90,0x97,0x92,0xe0,0xfe,0x75,0xf0,
+0x09,0xe5,0x11,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,
+0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0xd3,0x9f,0x40,0x1f,
+0x90,0x97,0x91,0xe0,0xff,0x74,0xc4,0x25,0x11,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xef,0xf0,0x74,0x84,0x25,0x11,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x90,
+0x97,0x91,0xe0,0xff,0xd3,0x94,0x13,0x40,0x08,0x90,0x93,0x62,0x74,0x03,0xf0,0x80,
+0x21,0xef,0xd3,0x94,0x0b,0x40,0x08,0x90,0x93,0x62,0x74,0x02,0xf0,0x80,0x13,0xef,
+0xd3,0x94,0x03,0x40,0x08,0x90,0x93,0x62,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x93,
+0x62,0xf0,0x90,0x93,0x62,0xe0,0x90,0x04,0xb1,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
+0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x7b,0xf0,0x74,0x59,
+0xa3,0xf0,0x90,0x01,0x34,0xe0,0x55,0x28,0xf5,0x2c,0x90,0x01,0x36,0xe0,0x55,0x2a,
+0xf5,0x2e,0xa3,0xe0,0x55,0x2b,0xf5,0x2f,0xe5,0x2c,0x20,0xe0,0x03,0x02,0x5b,0x29,
+0x90,0x01,0x34,0x74,0x01,0xf0,0x85,0xd1,0x4d,0x85,0xd2,0x4e,0x85,0xd3,0x4f,0x85,
+0xd4,0x50,0x85,0xd5,0x51,0x85,0xd6,0x52,0x85,0xd7,0x53,0x85,0xd9,0x54,0xe5,0x54,
+0x54,0x40,0xc3,0x13,0xff,0xe5,0x53,0x54,0x20,0x6f,0x70,0x03,0x02,0x5a,0xd8,0xe5,
+0x54,0x30,0xe5,0x03,0x02,0x5a,0xd8,0xe5,0x52,0x54,0x1f,0xf5,0x08,0xe5,0x4d,0x54,
+0x3f,0xf5,0x09,0xe5,0x51,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0x23,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xf6,0xe5,0x53,0x54,0x1f,0xff,
+0xe5,0x08,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0x8f,0xf0,
+0x12,0x62,0xf6,0xe5,0x09,0xd3,0x94,0x04,0x40,0x03,0x75,0x09,0x04,0x75,0xf0,0x0a,
+0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0x75,0xf0,0x02,
+0xe5,0x09,0x12,0x63,0xe2,0xe0,0xfe,0xa3,0xe0,0xff,0xe5,0x53,0x54,0x1f,0x2f,0xff,
+0xe4,0x3e,0xfe,0x75,0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,
+0x90,0xf5,0x83,0x75,0xf0,0x02,0xe5,0x09,0x12,0x63,0xe2,0xee,0xf0,0xa3,0xef,0xf0,
+0xe5,0x54,0x20,0xe6,0x24,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0xa3,
+0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,0xf6,0xe5,0x4f,0x30,
+0xe7,0x36,0xaf,0x08,0x12,0x75,0x8d,0x80,0x2f,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,
+0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x62,
+0xf6,0xe5,0x4f,0x30,0xe7,0x12,0xe5,0x4f,0x54,0x7f,0xfd,0xe5,0x53,0x54,0x1f,0xf5,
+0x0d,0xab,0x09,0xaf,0x08,0x12,0x76,0xd3,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,0x80,
+0x48,0x90,0x97,0xcb,0xe0,0x60,0x35,0x90,0x01,0x5b,0xe4,0xf0,0x90,0x01,0x3c,0x74,
+0x04,0xf0,0x90,0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x2d,0x75,0x44,0x14,0xf5,
+0x45,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5b,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x01,0xf0,0x90,0x97,0xc7,0xf0,0x80,0x0d,0x90,0x04,0x1b,0xe0,
+0x54,0x7f,0xff,0xbf,0x7f,0x03,0x12,0x7f,0x77,0xe5,0x2c,0x30,0xe1,0x27,0x90,0x01,
+0x34,0x74,0x02,0xf0,0x90,0xfd,0x10,0x74,0x7f,0xf0,0x85,0xd1,0x58,0x85,0xd2,0x59,
+0x85,0xd3,0x5a,0x85,0xd4,0x5b,0x85,0xd5,0x5c,0x85,0xd6,0x5d,0x85,0xd7,0x5e,0x85,
+0xd9,0x5f,0x12,0x7d,0xae,0xe5,0x2c,0x30,0xe3,0x06,0x90,0x01,0x34,0x74,0x08,0xf0,
+0xe5,0x2c,0x30,0xe4,0x09,0x90,0x01,0x34,0x74,0x10,0xf0,0x43,0x57,0x10,0xe5,0x2c,
+0x30,0xe5,0x1d,0x90,0x01,0xcf,0xe0,0x30,0xe5,0x16,0xe0,0x54,0xdf,0xf0,0x90,0x01,
+0x34,0x74,0x20,0xf0,0x90,0x00,0x03,0xe0,0x54,0xfb,0xf0,0x12,0x7f,0x1a,0x80,0xfe,
+0xe5,0x2c,0x30,0xe6,0x06,0x90,0x01,0x34,0x74,0x40,0xf0,0xe5,0x2e,0x30,0xe1,0x3c,
+0x90,0x01,0x36,0x74,0x02,0xf0,0x43,0x57,0x40,0x90,0x01,0x02,0xe0,0x54,0x03,0x64,
+0x01,0x70,0x29,0x90,0x01,0x37,0xe0,0x30,0xe0,0x0a,0x74,0x01,0xf0,0x90,0x97,0xd0,
+0xe4,0xf0,0x80,0x18,0x90,0x97,0xd0,0xe0,0x04,0xf0,0xe0,0xc3,0x94,0x0a,0x40,0x0c,
+0xe4,0xf0,0x90,0x04,0x19,0xe0,0x30,0xe0,0x03,0x12,0x7e,0xe7,0xe5,0x2e,0x30,0xe0,
+0x09,0x90,0x01,0x36,0x74,0x01,0xf0,0x12,0x75,0x12,0xe5,0x2e,0x30,0xe2,0x72,0x90,
+0x01,0x36,0x74,0x04,0xf0,0xe5,0x69,0x64,0x01,0x70,0x66,0xe5,0x6a,0x60,0x62,0xe5,
+0x6a,0x64,0x02,0x60,0x06,0xe5,0x6a,0x64,0x05,0x70,0x27,0x90,0x06,0xab,0xe0,0x90,
+0x97,0xbe,0xf0,0x90,0x06,0xaa,0xe0,0x90,0x97,0xc9,0xf0,0x90,0x97,0xbe,0xe0,0x70,
+0x07,0x90,0x97,0xc9,0xe0,0xff,0x80,0x05,0x90,0x97,0xbe,0xe0,0xff,0x90,0x97,0xbe,
+0xef,0xf0,0x90,0x97,0xc0,0xe0,0x60,0x03,0xe0,0x14,0xf0,0x90,0x97,0xbf,0xe4,0xf0,
+0x90,0x01,0x57,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xfd,
+0xf0,0xe0,0x54,0xef,0xf0,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,0x80,0x03,0x12,0x76,
+0x03,0xe5,0x2e,0x30,0xe3,0x31,0x90,0x01,0x36,0x74,0x08,0xf0,0xe5,0x69,0x64,0x01,
+0x70,0x25,0xe5,0x6a,0x60,0x21,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,
+0xf0,0x75,0x44,0x03,0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x35,
+0xab,0x90,0x01,0x57,0x74,0x05,0xf0,0xe5,0x2e,0x30,0xe4,0x2f,0x90,0x01,0x36,0x74,
+0x10,0xf0,0xe5,0x69,0x64,0x01,0x70,0x23,0xe5,0x6a,0x60,0x1f,0x90,0x01,0x57,0xe4,
+0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0xcc,0xe4,0xf0,0x90,0x97,0xcd,0xe0,
+0x54,0xfd,0xf0,0xe0,0x54,0x07,0x70,0x03,0x12,0x7f,0x77,0xe5,0x2e,0x30,0xe5,0x1f,
+0x90,0x01,0x36,0x74,0x20,0xf0,0xe5,0x69,0xb4,0x01,0x14,0xe5,0x6a,0x60,0x10,0x90,
+0x97,0xcb,0xe0,0x64,0x02,0x60,0x05,0x12,0x7f,0x09,0x80,0x03,0x12,0x7a,0xf0,0xe5,
+0x2e,0x30,0xe6,0x1e,0x90,0x01,0x36,0x74,0x40,0xf0,0xe5,0x69,0xb4,0x01,0x13,0xe5,
+0x6a,0x60,0x0f,0x90,0x97,0xcd,0xe0,0x54,0xfe,0xf0,0xe0,0x54,0x07,0x70,0x03,0x12,
+0x7f,0x77,0xe5,0x2f,0x30,0xe1,0x09,0x90,0x01,0x37,0x74,0x02,0xf0,0x12,0x7c,0x7c,
+0x74,0x7b,0x04,0x90,0x01,0xc4,0xf0,0x74,0x59,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,
+0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,
+0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x90,0x04,0x44,0x74,0x11,0xf0,0xa3,0x74,0xf0,0xf0,
+0xa3,0x74,0x0f,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xff,
+0xc3,0x94,0x10,0x50,0x14,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe4,
+0xf0,0x90,0x97,0x79,0xe0,0x04,0xf0,0x80,0xe2,0xe4,0x90,0x97,0x79,0xf0,0x90,0x97,
+0x79,0xe0,0xfb,0xc3,0x94,0x20,0x40,0x03,0x02,0x5f,0x55,0xe0,0xff,0x75,0xf0,0x0a,
+0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,
+0xf0,0x0a,0xef,0xa4,0x24,0x02,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,
+0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x04,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,
+0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x06,0xf5,0x82,0xe5,0xf0,
+0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x08,0xf5,
+0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x74,0xc4,0x2f,0xf5,0x82,
+0xe4,0x34,0x96,0xf5,0x83,0x74,0x13,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0xe4,0xf0,0x74,0x83,0x2f,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,
+0xef,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0x23,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0xef,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,
+0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0x64,0x2f,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x96,
+0xf5,0x83,0xe4,0xf0,0x90,0x41,0xc4,0x93,0xfe,0x74,0x01,0x93,0xff,0x90,0x41,0x8c,
+0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,
+0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,
+0x2a,0x7f,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,
+0x83,0x74,0x01,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x69,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xf5,0x83,0x74,0x01,0xf0,0x74,0xc1,0x2b,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0x74,0x0c,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,0x93,
+0xf5,0x83,0x74,0xff,0xf0,0xa3,0xf0,0x75,0xf0,0x09,0xeb,0xa4,0x24,0x63,0xf5,0x82,
+0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0xa3,0x74,0x0f,0xf0,0x75,0xf0,0x09,0xeb,
+0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x13,0xf0,0x75,0xf0,
+0x09,0xeb,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe4,0xf0,0x74,
+0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0x74,0x13,0xf0,0x90,0x97,0x79,0xe0,
+0x04,0xf0,0x02,0x5d,0x7e,0x22,0xa9,0x07,0x74,0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,
+0xf5,0x83,0xe0,0x54,0x7f,0x90,0x97,0x92,0xf0,0xe0,0x54,0x1f,0xff,0x90,0x97,0x95,
+0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x68,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xe0,0x90,0x97,0x97,0xf0,0x75,0xf0,0x09,0xe9,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,
+0x34,0x93,0xf5,0x83,0xe0,0xfe,0x90,0x97,0x98,0xf0,0xe9,0x25,0xe0,0x24,0x24,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x99,0xcb,0xf0,0xa3,
+0xeb,0xf0,0xe9,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfb,
+0xa3,0xe0,0x90,0x97,0x9b,0xcb,0xf0,0xa3,0xeb,0xf0,0xef,0xd3,0x9e,0x40,0x0c,0x90,
+0x97,0x98,0xe0,0x90,0x97,0x95,0xf0,0x90,0x97,0x92,0xf0,0xed,0x70,0x03,0x02,0x60,
+0xb5,0x90,0x97,0x96,0xed,0xf0,0x90,0x97,0x92,0xe0,0x30,0xe6,0x0e,0x90,0x97,0x95,
+0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x96,0xe0,0x14,0xf0,0x90,0x97,0x96,0xe0,0x70,
+0x03,0x02,0x60,0xb5,0x90,0x97,0x95,0xe0,0xff,0xd3,0x94,0x00,0x50,0x03,0x02,0x60,
+0xb5,0xe4,0x90,0x97,0x94,0xf0,0xef,0x14,0x90,0x97,0x93,0xf0,0x90,0x97,0x97,0xe0,
+0xfd,0x90,0x97,0x93,0xe0,0xff,0xd3,0x9d,0x40,0x6f,0xef,0x94,0x10,0x40,0x21,0xef,
+0x24,0xf0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,
+0xce,0xd8,0xf9,0xff,0x90,0x97,0x9b,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,
+0x90,0x97,0x93,0xe0,0xff,0xc3,0x94,0x10,0x50,0x37,0x74,0x01,0x7e,0x00,0xa8,0x07,
+0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x99,0xe0,0x5e,
+0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x1a,0x90,0x97,0x93,0xe0,0x90,0x97,0x92,0xf0,0x90,
+0x97,0x94,0xe0,0x04,0xf0,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,0x94,0xe0,0x6f,0x60,
+0x08,0x90,0x97,0x93,0xe0,0x14,0xf0,0x80,0x83,0x90,0x97,0x96,0xe0,0xff,0x90,0x97,
+0x94,0xe0,0xc3,0x9f,0x50,0x0f,0x90,0x97,0x93,0xe0,0xb5,0x05,0x08,0x90,0x97,0x97,
+0xe0,0x90,0x97,0x92,0xf0,0x90,0x97,0x92,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,
+0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,
+0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,
+0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xe9,0x25,0xe0,0x25,0xe0,0x24,0xe1,
+0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x2a,0x7f,0x90,0x97,0x92,0xe0,0xff,0x74,
+0x84,0x29,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0x90,0x01,0xcc,0xe0,
+0x54,0x0f,0x90,0x97,0x79,0xf0,0x90,0x97,0x79,0xe0,0xfd,0x70,0x03,0x02,0x62,0x94,
+0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,
+0xce,0x33,0xce,0xd8,0xf9,0xff,0xef,0x5d,0x70,0x03,0x02,0x62,0x75,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd0,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,
+0x90,0x97,0x7a,0xf0,0x75,0x63,0x01,0x75,0x64,0x97,0x75,0x65,0x7a,0x75,0x66,0x01,
+0x7b,0x01,0x7a,0x97,0x79,0x7b,0x12,0x77,0x98,0x90,0x97,0x7b,0xe0,0xff,0xc4,0x13,
+0x13,0x13,0x54,0x01,0x90,0x97,0xef,0x30,0xe0,0x70,0xe0,0x75,0xf0,0x02,0xa4,0x24,
+0x88,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xef,
+0xe0,0x75,0xf0,0x02,0xa4,0x24,0x89,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,
+0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd1,0xf5,0x82,0xe5,
+0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,
+0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7f,
+0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,0x82,0xe5,0xf0,0x34,
+0x01,0xf5,0x83,0xe0,0x90,0x97,0x80,0xf0,0x80,0x42,0xe0,0x75,0xf0,0x04,0xa4,0x24,
+0xd1,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,
+0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,
+0xe0,0x90,0x97,0x7d,0xf0,0x90,0x97,0xef,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,
+0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x7e,0xf0,0xef,0x54,0x7f,0xff,
+0x7b,0x01,0x7a,0x97,0x79,0x7c,0x12,0x6e,0xe1,0x90,0x97,0x79,0xe0,0xff,0x90,0x97,
+0xef,0xe0,0xfe,0x74,0x01,0xa8,0x06,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0x5f,
+0x90,0x97,0x79,0xf0,0x90,0x97,0xef,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0x90,0x01,0xcc,0xf0,0x90,0x97,0xef,0xe0,0x04,0xf0,0xe0,0x54,
+0x03,0xf0,0x02,0x61,0x16,0xc2,0xaf,0x74,0x0c,0x04,0x90,0x01,0xc4,0xf0,0x74,0x61,
+0xa3,0xf0,0x90,0x97,0x79,0xe0,0x90,0x01,0xc6,0xf0,0x90,0x97,0xef,0xe0,0x90,0x01,
+0xc7,0xf0,0x80,0xfe,0x22,0xbb,0x01,0x0c,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe0,0x22,0x50,0x06,0xe9,0x25,0x82,0xf8,0xe6,0x22,0xbb,0xfe,0x06,0xe9,
+0x25,0x82,0xf8,0xe2,0x22,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe4,
+0x93,0x22,0xbb,0x01,0x06,0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x02,0xf7,0x22,0xbb,
+0xfe,0x01,0xf3,0x22,0xf8,0xbb,0x01,0x0d,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe8,0xf0,0x22,0x50,0x06,0xe9,0x25,0x82,0xc8,0xf6,0x22,0xbb,0xfe,0x05,
+0xe9,0x25,0x82,0xc8,0xf2,0x22,0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,0xc5,0xf0,0xf8,
+0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,0xf8,0xe0,0xc5,
+0xf0,0x25,0xf0,0xf0,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0xc8,0x38,0xf0,
+0xe8,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,0x50,
+0x06,0x87,0xf0,0x09,0xe7,0x19,0x22,0xbb,0xfe,0x07,0xe3,0xf5,0xf0,0x09,0xe3,0x19,
+0x22,0x89,0x82,0x8a,0x83,0xe4,0x93,0xf5,0xf0,0x74,0x01,0x93,0x22,0xbb,0x01,0x10,
+0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,
+0x50,0x09,0xe9,0x25,0x82,0xf8,0x86,0xf0,0x08,0xe6,0x22,0xbb,0xfe,0x0a,0xe9,0x25,
+0x82,0xf8,0xe2,0xf5,0xf0,0x08,0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,0xe9,0x93,0xf5,
+0xf0,0xa3,0xe9,0x93,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xf0,0xe5,0xf0,0xa3,
+0xf0,0x22,0x50,0x06,0xf7,0x09,0xa7,0xf0,0x19,0x22,0xbb,0xfe,0x06,0xf3,0xe5,0xf0,
+0x09,0xf3,0x19,0x22,0xf8,0xbb,0x01,0x11,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x09,0xe9,0x25,0x82,0xc8,0xf6,
+0x08,0xa6,0xf0,0x22,0xbb,0xfe,0x09,0xe9,0x25,0x82,0xc8,0xf2,0xe5,0xf0,0x08,0xf2,
+0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,0xe8,0x9c,0x45,
+0xf0,0x22,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,0x22,0xd0,0x83,
+0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,0x01,0x93,0x70,0x0d,0xa3,0xa3,0x93,0xf8,
+0x74,0x01,0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x02,0x93,0x68,0x60,0xef,0xa3,
+0xa3,0xa3,0x80,0xdf,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,
+0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x04,0x12,0x62,0x95,
+0xff,0x54,0x1f,0x90,0x97,0x87,0xf0,0x90,0x00,0x03,0x12,0x62,0x95,0x54,0xf0,0xc4,
+0x54,0x0f,0x90,0x97,0x88,0xf0,0xef,0x54,0x20,0xc4,0x13,0x54,0x07,0xa3,0xf0,0x90,
+0x00,0x04,0x12,0x62,0x95,0x54,0x40,0xc4,0x13,0x13,0x54,0x03,0x90,0x97,0x8a,0xf0,
+0x90,0x97,0x87,0xe0,0xff,0x75,0xf0,0x09,0xa4,0x24,0x65,0xf5,0x82,0xe5,0xf0,0x34,
+0x93,0xad,0x82,0x90,0x97,0x8b,0xf0,0xa3,0xed,0xf0,0xef,0x75,0xf0,0x09,0xa4,0x24,
+0x63,0xf9,0x74,0x93,0x35,0xf0,0xfa,0xa3,0x74,0x01,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,
+0xf0,0x90,0x97,0x84,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x03,0x12,0x62,0x95,
+0x54,0x0f,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0xef,0x12,
+0x62,0xc2,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x02,
+0x12,0x62,0x95,0xff,0x90,0x97,0x8d,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,
+0x00,0x01,0xef,0x12,0x62,0xd4,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0x90,0x00,0x01,0x12,0x62,0x95,0xff,0x90,0x97,0x8b,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xf5,0x82,0x8c,0x83,0xef,0xf0,0x12,0x29,0xd9,0x8d,0x82,0x8c,0x83,0xa3,0xf0,0x90,
+0x97,0x88,0xe0,0xfe,0x90,0x97,0x87,0xe0,0xff,0x24,0xc1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0xee,0xf0,0x90,0x97,0x89,0xe0,0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x69,
+0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xee,0xf0,0x75,0xf0,0x09,0xef,0xa4,0x24,
+0x6a,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x90,0x97,0x8a,0xe0,
+0xfe,0x75,0xf0,0x09,0xef,0xa4,0x24,0x6b,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,
+0xee,0xf0,0x02,0x54,0xea,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x97,0xa9,0xf0,0x90,
+0x00,0x01,0x12,0x62,0x95,0x25,0xe0,0x25,0xe0,0x90,0x97,0xa8,0xf0,0x12,0x29,0xd9,
+0x25,0xe0,0x25,0xe0,0x90,0x97,0xac,0xf0,0x90,0x05,0x60,0xe0,0x90,0x97,0xb7,0xf0,
+0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0xb9,0xf0,
+0x90,0x05,0x63,0xe0,0x90,0x97,0xba,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,
+0xc2,0xaf,0x90,0x97,0xa8,0xe0,0xff,0x12,0x78,0xfb,0x90,0x97,0x84,0xe0,0x24,0xff,
+0x92,0xaf,0x90,0x97,0xa9,0xe0,0x70,0x03,0x02,0x66,0x62,0x90,0x97,0xa8,0xe0,0x70,
+0x03,0x02,0x66,0x62,0x90,0x97,0xac,0xe0,0x70,0x03,0x02,0x66,0x62,0xa2,0xaf,0xe4,
+0x33,0x90,0x97,0x84,0xf0,0xc2,0xaf,0x90,0x97,0xbb,0x74,0x01,0xf0,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,0xe0,0x44,0x01,
+0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,
+0x2f,0xd9,0x80,0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x00,0x45,0xe0,0x54,0xef,
+0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,0xf0,
+0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,0xf0,
+0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x84,0xf0,
+0xc2,0xaf,0x90,0x01,0x3c,0xe0,0x44,0x20,0xf0,0x7d,0x20,0xe4,0xff,0x12,0x37,0x00,
+0x80,0x2b,0x90,0x97,0xa9,0xe0,0x70,0x2d,0x90,0x97,0xbb,0xf0,0x90,0x00,0x45,0xe0,
+0x54,0xfe,0xf0,0xa3,0xe0,0x54,0xfe,0xf0,0x90,0x05,0x22,0xe4,0xf0,0xa2,0xaf,0x33,
+0x90,0x97,0x84,0xf0,0xc2,0xaf,0x7d,0x20,0xe4,0xff,0x12,0x36,0x92,0x90,0x97,0x84,
+0xe0,0x24,0xff,0x92,0xaf,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,0x82,0xc0,0xd0,
+0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,0xc0,0x05,0xc0,
+0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x96,0xf0,0x74,0x66,0xa3,0xf0,0x53,0x91,0xdf,
+0x90,0x01,0x3c,0xe0,0x55,0x30,0xf5,0x34,0xa3,0xe0,0x55,0x31,0xf5,0x35,0xa3,0xe0,
+0x55,0x32,0xf5,0x36,0xa3,0xe0,0x55,0x33,0xf5,0x37,0xe5,0x34,0x30,0xe1,0x09,0x90,
+0x01,0x3c,0x74,0x02,0xf0,0x12,0x7b,0x2e,0xe5,0x34,0x30,0xe2,0x33,0x90,0x01,0x3c,
+0x74,0x04,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe0,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,
+0xe4,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5b,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x01,0xf0,0x80,0x08,0x90,0x97,0xc7,0xe4,0xf0,0x12,0x7f,0x77,
+0xe5,0x34,0x30,0xe3,0x33,0x90,0x01,0x3c,0x74,0x08,0xf0,0x90,0x06,0x92,0xe0,0x30,
+0xe1,0x1e,0x75,0x44,0x14,0x75,0x45,0x00,0xe4,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,
+0x35,0xab,0x90,0x01,0x5f,0x74,0x05,0xf0,0x90,0x06,0x92,0x74,0x02,0xf0,0x80,0x08,
+0x90,0x97,0xc6,0xe4,0xf0,0x12,0x7f,0x77,0xe5,0x34,0x30,0xe4,0x09,0x90,0x01,0x3c,
+0x74,0x10,0xf0,0x12,0x7a,0x6f,0xe5,0x34,0x30,0xe5,0x09,0x90,0x01,0x3c,0x74,0x20,
+0xf0,0x12,0x6e,0x1d,0xe5,0x35,0x30,0xe0,0x11,0x90,0x01,0x3d,0x74,0x01,0xf0,0x90,
+0x00,0x83,0xe0,0x90,0x97,0xca,0xf0,0x12,0x7f,0x77,0x74,0x96,0x04,0x90,0x01,0xc4,
+0xf0,0x74,0x66,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,
+0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,
+0xe4,0x90,0x97,0x76,0xf0,0xa3,0xf0,0x12,0x79,0x9c,0x90,0x00,0x02,0xe0,0x54,0xe0,
+0x90,0x97,0xd6,0x60,0x05,0x74,0x01,0xf0,0x80,0x03,0x74,0x02,0xf0,0x90,0x00,0xf3,
+0xe0,0x30,0xe3,0x08,0x90,0x97,0xd7,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x97,0xd7,
+0xf0,0x90,0x97,0xd7,0xe0,0xb4,0x01,0x13,0x90,0x00,0xf2,0xe0,0x30,0xe7,0x0c,0x90,
+0x97,0xce,0x74,0xfd,0xf0,0xa3,0x74,0x33,0xf0,0x80,0x0a,0x90,0x97,0xce,0x74,0xfd,
+0xf0,0xa3,0x74,0x2f,0xf0,0xe4,0xf5,0x57,0x12,0x5d,0x46,0x12,0x7f,0x8b,0x12,0x79,
+0x4d,0x12,0x32,0x3d,0x12,0x7f,0xa8,0x12,0x7e,0x11,0x90,0x00,0xf3,0xe0,0x30,0xe2,
+0x0d,0x90,0x05,0x41,0x74,0x10,0xf0,0x90,0x05,0x5a,0xf0,0xa3,0xe4,0xf0,0x90,0x01,
+0x64,0x74,0xa0,0xf0,0x75,0x44,0xff,0xe4,0xf5,0x45,0xfb,0x7d,0x01,0x7f,0x50,0x7e,
+0x01,0x12,0x35,0xab,0x12,0x7e,0xba,0x12,0x77,0xf8,0x90,0x97,0x78,0xe5,0xd9,0xf0,
+0x12,0x7e,0xd2,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x40,0xf0,0x12,0x7f,0x1a,0x75,
+0xe8,0x03,0x43,0xa8,0x85,0xd2,0xaf,0x90,0x01,0xc0,0xe4,0xf0,0xa3,0xf0,0xa3,0xf0,
+0xa3,0xf0,0x90,0x01,0xc6,0xf0,0xa3,0xf0,0x90,0x97,0x76,0xe0,0x64,0x01,0xf0,0x24,
+0xb0,0x90,0x01,0xc4,0xf0,0x74,0x67,0xa3,0xf0,0xe5,0x57,0x30,0xe6,0x17,0xc2,0xaf,
+0x53,0x57,0xbf,0xd2,0xaf,0x12,0x45,0x09,0x90,0x97,0xab,0xe0,0xff,0x60,0x03,0xb4,
+0x01,0x03,0x12,0x68,0xc2,0xe5,0x57,0x30,0xe4,0x0a,0xc2,0xaf,0x53,0x57,0xef,0xd2,
+0xaf,0x12,0x61,0x0c,0x90,0x97,0xab,0xe0,0x70,0x03,0x12,0x6b,0xa4,0x12,0x7c,0xde,
+0x80,0xb6,0x90,0x97,0xa2,0xe0,0xc3,0x94,0x14,0x50,0x06,0xe0,0x04,0xf0,0x02,0x69,
+0x7c,0x90,0x97,0xa2,0xe0,0x64,0x14,0x60,0x03,0x02,0x69,0x7c,0x90,0x97,0xb1,0xe0,
+0x70,0x25,0x90,0x97,0xb4,0xe0,0x70,0x1f,0x90,0x97,0xb2,0xe0,0x70,0x19,0x90,0x97,
+0xb5,0xe0,0x70,0x13,0x90,0x97,0xb3,0xe0,0x70,0x0d,0x90,0x97,0xb6,0xe0,0x70,0x07,
+0x90,0x04,0xfd,0xe0,0x54,0xfe,0xf0,0x90,0x97,0xb1,0xe0,0x90,0x04,0x44,0xf0,0x90,
+0x97,0xb2,0xe0,0x90,0x04,0x45,0xf0,0x90,0x97,0xb3,0xe0,0x90,0x04,0x46,0xf0,0xa3,
+0xe4,0xf0,0x90,0x97,0xb4,0xe0,0x90,0x04,0x48,0xf0,0x90,0x97,0xb5,0xe0,0x90,0x04,
+0x49,0xf0,0x90,0x97,0xb6,0xe0,0x90,0x04,0x4a,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x9d,
+0xe0,0x90,0x07,0x00,0xf0,0x90,0x97,0x9e,0xe0,0x90,0x07,0x01,0xf0,0x90,0x97,0x9f,
+0xe0,0x90,0x07,0x02,0xf0,0x90,0x97,0xa0,0xe0,0x90,0x07,0x03,0xf0,0xe4,0x90,0x97,
+0xa2,0xf0,0x90,0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,
+0xb1,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x05,0x60,0xe0,
+0x90,0x97,0x79,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0x7a,0xf0,0x90,0x05,0x62,0xe0,
+0x90,0x97,0x7b,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0x7c,0xf0,0x90,0x97,0xba,0xe0,
+0xff,0x90,0x97,0x7c,0xe0,0xfe,0xd3,0x9f,0x50,0x0b,0x90,0x97,0xba,0xe0,0xc3,0x9e,
+0xd3,0x94,0x01,0x40,0x11,0x90,0x97,0xa8,0xe0,0xb4,0x01,0x02,0x80,0x03,0x90,0x97,
+0xac,0xe0,0xff,0x12,0x78,0xfb,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,
+0xee,0xed,0xf0,0x90,0x97,0xed,0xef,0xf0,0xd3,0x94,0x07,0x50,0x65,0xe0,0xff,0x74,
+0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,
+0x5f,0xf0,0x12,0x7f,0x1a,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x46,0xe0,0x4f,0xf0,0x12,0x7f,0x1a,0x90,
+0x97,0xee,0xe0,0x60,0x16,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x45,0x80,0x70,0x90,0x97,0xed,0xe0,0xff,
+0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x45,
+0x80,0x75,0x90,0x97,0xed,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,
+0xf0,0x12,0x7f,0x1a,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7f,0x1a,0x90,0x97,
+0xee,0xe0,0x60,0x1b,0x90,0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,
+0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x42,0xe0,0x4f,0x80,0x1a,0x90,
+0x97,0xed,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,
+0x54,0xf0,0xf4,0xff,0x90,0x00,0x42,0xe0,0x5f,0xf0,0x12,0x7f,0x1a,0xd0,0xd0,0x92,
+0xaf,0x22,0x7f,0x78,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,0x5d,0x12,0x2a,0x7f,0x7f,
+0x04,0x7e,0x0c,0x12,0x27,0xde,0x90,0x97,0x61,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,
+0x12,0x27,0xde,0x90,0x97,0x65,0x12,0x2a,0x7f,0x90,0x97,0xd7,0xe0,0x90,0x97,0x5d,
+0xb4,0x01,0x13,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xc7,0xff,
+0xed,0x54,0xc7,0xfd,0x80,0x0d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0x54,0xc7,0xff,0xec,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x78,0x7e,0x08,0x12,0x2f,
+0xd9,0x90,0x97,0x61,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0x0f,
+0xff,0xec,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x04,0x7e,0x0c,0x12,0x2f,0xd9,0x90,
+0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x02,0xff,0xec,
+0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x00,0x7e,0x08,0x12,0x2f,0xd9,0x7f,0x70,0x7e,
+0x0e,0x12,0x27,0xde,0x90,0x97,0x69,0x12,0x2a,0x7f,0x90,0x80,0x85,0x12,0x2a,0x8b,
+0x00,0x1b,0x25,0xa0,0x7f,0x70,0x7e,0x0e,0x12,0x2f,0xd9,0x90,0x80,0x59,0x12,0x2a,
+0x8b,0x00,0x00,0x00,0x00,0xe4,0xfd,0xff,0x12,0x34,0x81,0x90,0x97,0xd7,0xe0,0xb4,
+0x01,0x11,0x90,0x80,0x59,0x12,0x2a,0x8b,0x00,0x00,0x00,0x00,0xe4,0xfd,0x7f,0x01,
+0x12,0x34,0x81,0x22,0x90,0x97,0xbb,0xe0,0x64,0x01,0x60,0x09,0x90,0x97,0xa9,0xe0,
+0x60,0x03,0x02,0x6c,0x7c,0x90,0x97,0x9d,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,
+0xf0,0x80,0x3b,0x90,0x97,0x9e,0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,
+0x80,0x28,0x90,0x97,0x9f,0xe0,0xc3,0x94,0xff,0x50,0x0a,0xe0,0x04,0xf0,0xe4,0x90,
+0x97,0x9e,0xf0,0x80,0x15,0x90,0x97,0xa0,0xe0,0xc3,0x94,0xff,0x50,0x10,0xe0,0x04,
+0xf0,0xe4,0x90,0x97,0x9f,0xf0,0x90,0x97,0x9e,0xf0,0x90,0x97,0x9d,0xf0,0x90,0x00,
+0x44,0xe0,0x54,0x0c,0x60,0x76,0xe0,0x30,0xe2,0x32,0x90,0x97,0xb1,0xe0,0xc3,0x94,
+0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,0x90,0x97,0xb2,0xe0,0xc3,0x94,0xff,0x50,
+0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,0x97,0xb3,0xe0,0xc3,0x94,0xff,0x50,0x0c,
+0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb2,0xf0,0x90,0x97,0xb1,0xf0,0x90,0x00,0x44,0xe0,
+0x30,0xe3,0x32,0x90,0x97,0xb4,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,
+0x24,0x90,0x97,0xb5,0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,
+0x90,0x97,0xb6,0xe0,0xc3,0x94,0xff,0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0xb5,
+0xf0,0x90,0x97,0xb4,0xf0,0x90,0x04,0xfd,0xe0,0x44,0x01,0xf0,0x22,0x8b,0x11,0x8a,
+0x12,0x89,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x97,0xaa,0xf0,0xe0,0x30,0xe0,
+0x5c,0x90,0x97,0xa1,0x74,0x01,0xf0,0x7f,0x80,0x7e,0x08,0x12,0x27,0xde,0x90,0x97,
+0xa3,0x12,0x2a,0x7f,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x01,0x12,0x62,0x95,
+0xff,0xe4,0xfc,0xfd,0xfe,0x78,0x1a,0x12,0x2a,0x6c,0xa8,0x04,0xa9,0x05,0xaa,0x06,
+0xab,0x07,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0xec,0x54,0x03,0xfc,0xeb,0x4f,0xff,0xea,0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,0x4c,0xfc,
+0x90,0x97,0xad,0x12,0x2a,0x7f,0x90,0x05,0x22,0xe4,0xf0,0x80,0x35,0xe4,0x90,0x97,
+0xa1,0xf0,0x7f,0x80,0x7e,0x08,0x12,0x27,0xde,0xec,0x54,0x03,0xfc,0xec,0x44,0xc0,
+0xfc,0x90,0x97,0xa3,0x12,0x2a,0x7f,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,
+0x2f,0xd9,0x90,0x97,0xaa,0xe0,0x90,0x00,0x47,0x30,0xe1,0x11,0x74,0x0c,0xf0,0xa3,
+0xe0,0x44,0x0c,0xf0,0x90,0x00,0x46,0xe0,0x44,0x10,0xf0,0x80,0x10,0xe0,0x54,0xf3,
+0xf0,0xa3,0xe0,0x54,0xf3,0xf0,0x90,0x00,0x46,0xe0,0x54,0xef,0xf0,0xe4,0x90,0x97,
+0xa7,0xf0,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0x8a,0xed,0xf0,0x90,
+0x97,0x89,0xef,0xf0,0xd3,0x94,0x07,0x50,0x4f,0xa3,0xe0,0x70,0x1a,0x90,0x97,0x89,
+0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,
+0x00,0x47,0xe0,0x5f,0xf0,0x80,0x17,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,
+0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x47,0xe0,0x4f,0xf0,0x12,0x7f,
+0x1a,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0xff,0x90,0x00,0x46,0x80,0x5a,0x90,0x97,0x89,0xe0,0x24,0xf8,0xf0,0xa3,
+0xe0,0x70,0x1d,0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,
+0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x80,0x1a,
+0x90,0x97,0x89,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,
+0xc4,0x54,0xf0,0xff,0x90,0x00,0x43,0xe0,0x4f,0xf0,0x12,0x7f,0x1a,0x90,0x97,0x89,
+0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,
+0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7f,0x1a,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x97,0xa9,
+0xe0,0x64,0x01,0x60,0x03,0x02,0x6e,0xe0,0x90,0x00,0x46,0xe0,0x44,0x01,0xf0,0x90,
+0x97,0xbb,0xe0,0x70,0x40,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xad,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,
+0x80,0x7e,0x08,0x12,0x2f,0xd9,0x80,0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x97,
+0xa8,0xe0,0xff,0x12,0x78,0xfb,0x90,0x97,0xbb,0x74,0x01,0xf0,0x90,0x00,0x45,0xe0,
+0x54,0xfe,0xf0,0x80,0x44,0x90,0x97,0xbb,0xe0,0x64,0x01,0x70,0x3c,0x90,0x97,0xac,
+0xe0,0xff,0x12,0x78,0xfb,0xe4,0x90,0x97,0xbb,0xf0,0x90,0x00,0x45,0xe0,0x44,0x01,
+0xf0,0x90,0x97,0xa1,0xe0,0x60,0x1d,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,
+0x2f,0xd9,0x80,0x05,0x90,0x05,0x22,0xe4,0xf0,0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,
+0x90,0x97,0xb7,0xe0,0x90,0x05,0x84,0xf0,0x90,0x97,0xb8,0xe0,0x90,0x05,0x85,0xf0,
+0x90,0x97,0xb9,0xe0,0x90,0x05,0x86,0xf0,0x90,0x97,0xba,0xe0,0x90,0x05,0x87,0xf0,
+0x22,0x90,0x97,0x81,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xef,0x12,0x63,0xee,
+0x6f,0x12,0x01,0x6f,0x20,0x02,0x6f,0x2e,0x03,0x6f,0x3c,0x05,0x6f,0x4a,0x06,0x6f,
+0x9f,0x07,0x6f,0x58,0x09,0x6f,0x66,0x0c,0x6f,0x74,0x0d,0x6f,0x82,0x0e,0x00,0x00,
+0x6f,0x90,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x37,
+0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7f,0xa2,0x90,0x97,
+0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7b,0x69,0x90,0x97,0x81,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x0b,0x90,0x97,0x81,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x64,0x14,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xf9,0x02,0x72,0xeb,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,
+0xf9,0x02,0x65,0x55,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,
+0x7c,0xb0,0x90,0x97,0x81,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x6c,0x7d,
+0xc2,0xaf,0x74,0xe1,0x04,0x90,0x01,0xc4,0xf0,0x74,0x6e,0xa3,0xf0,0x80,0xfe,0x22,
+0x8f,0x67,0x8d,0x68,0xe5,0x67,0x54,0x0f,0xff,0x90,0x97,0xc8,0xe0,0x54,0x0f,0x6f,
+0x60,0x78,0xe5,0x67,0x30,0xe2,0x30,0x90,0x97,0xc8,0xe0,0x20,0xe2,0x05,0x7f,0x01,
+0x12,0x7d,0xf2,0x90,0x97,0xc8,0xe0,0x30,0xe3,0x0a,0xe5,0x67,0x20,0xe3,0x05,0x12,
+0x7e,0x2f,0x80,0x56,0x90,0x97,0xc8,0xe0,0x20,0xe3,0x4f,0xe5,0x67,0x30,0xe3,0x4a,
+0xaf,0x68,0x12,0x7d,0xd2,0x80,0x43,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,0x0c,
+0x0e,0xe5,0x67,0x20,0xe3,0x09,0x12,0x7d,0x61,0xef,0x60,0x2e,0x12,0x7e,0x2f,0x90,
+0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,0x04,0x0e,0xe5,0x67,0x20,0xe2,0x09,0x12,0x7b,
+0xa4,0xef,0x60,0x16,0x12,0x7b,0xdb,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xff,0xbf,0x02,
+0x09,0x12,0x7a,0xb2,0xef,0x60,0x03,0x12,0x7e,0x4c,0x90,0x97,0xc8,0xe0,0x54,0x0f,
+0xff,0x90,0x97,0xca,0xe0,0x54,0x0f,0x6f,0x70,0x23,0xe0,0x30,0xe6,0x1f,0x90,0x97,
+0xc8,0xe0,0x54,0x0f,0xff,0x90,0x97,0xbc,0xe0,0xfe,0x4f,0x90,0x01,0x2f,0xf0,0xee,
+0x64,0x80,0x90,0x97,0xbc,0xf0,0x90,0x97,0xca,0xe0,0x54,0xbf,0xf0,0x22,0x90,0x97,
+0xde,0xef,0xf0,0xa3,0xed,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xe5,0x6a,0x60,0x05,0xe4,
+0xff,0x12,0x7e,0x86,0x90,0x97,0xde,0xe0,0x30,0xe0,0x09,0x90,0x97,0xe0,0xe4,0xf0,
+0xa3,0x74,0x80,0xf0,0x90,0x04,0x1d,0xe0,0x60,0x1d,0x90,0x05,0x22,0xe0,0x90,0x97,
+0xe2,0xf0,0xe0,0xff,0x54,0x90,0x60,0xec,0x90,0x01,0xc8,0x74,0xfc,0xf0,0xef,0x54,
+0x6f,0x90,0x05,0x22,0xf0,0x80,0xdd,0x90,0x97,0xde,0xe0,0xff,0xc3,0x13,0x90,0xfd,
+0x10,0xf0,0x90,0x04,0x25,0xef,0xf0,0x90,0x97,0xdf,0xe0,0x60,0x1f,0xa3,0xa3,0xe0,
+0xff,0x24,0x0f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x44,0x80,0xf0,0x74,0x10,
+0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x44,0x80,0xf0,0x90,0x97,0xe0,0xa3,
+0xe0,0xff,0xfd,0x24,0x08,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe4,0xf0,0x74,0x09,
+0x2d,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xf0,0xf0,0x74,0x21,0x2f,0xf5,
+0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xf7,0xf0,0x90,0x97,0xe0,0xe0,0xfe,0xa3,
+0xe0,0xff,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x97,0xf2,0xef,0xf0,0xd3,
+0x94,0x07,0x50,0x47,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0xff,0x90,0x00,0x46,0xe0,0x5f,0xf0,0x12,0x7f,0x1a,0x90,0x97,0xf2,0xe0,
+0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,
+0xf9,0xff,0x90,0x00,0x44,0xe0,0xfb,0xe4,0xfe,0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,
+0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,0x80,0x4c,0x90,0x97,0xf2,0xe0,0x24,
+0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,
+0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x12,0x7f,0x1a,0x90,0x97,0xf2,0xe0,0xfd,0x74,
+0x01,0x7e,0x00,0xa8,0x05,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,
+0x90,0x00,0x42,0xe0,0xfb,0xe4,0xfe,0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,
+0xe7,0x13,0xce,0x13,0xd8,0xf8,0xff,0xd0,0xd0,0x92,0xaf,0x22,0xd3,0x10,0xaf,0x01,
+0xc3,0xc0,0xd0,0x90,0x97,0x70,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,0x97,
+0xd6,0xe0,0x64,0x02,0x60,0x7e,0x90,0x01,0xaf,0xe0,0x60,0x09,0x90,0x01,0xc7,0xe0,
+0x04,0xf0,0xf0,0x80,0xf1,0x90,0x97,0xe3,0xe0,0xff,0x04,0xf0,0x90,0x97,0x70,0xe0,
+0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0xef,0x12,0x62,0xd4,0x90,0x97,
+0x70,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x63,0x8a,0x64,0xf5,0x65,0x75,0x66,
+0x02,0x7b,0x01,0x7a,0x01,0x79,0xa0,0x12,0x77,0x98,0x90,0x97,0x73,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0x8b,0x63,0x8a,0x64,0xf5,0x65,0x90,0x97,0x70,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0xf9,0x12,0x29,0xd9,0xff,0xc4,0x54,0x0f,0xf5,0x66,0x7b,0x01,
+0x7a,0x01,0x79,0xa2,0x12,0x77,0x98,0x90,0x01,0xaf,0x74,0xff,0xf0,0x90,0x01,0xcb,
+0xe0,0x64,0x80,0xf0,0xd0,0xd0,0x92,0xaf,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,
+0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,
+0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0x59,0xf0,0x74,0x72,0xa3,0xf0,
+0x53,0x91,0xef,0x90,0x00,0x51,0xe0,0xff,0x90,0x00,0x55,0xe0,0x5f,0xf5,0x3d,0xe5,
+0x3d,0x30,0xe6,0x18,0x74,0x40,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,0xff,0xbf,0x03,
+0x0b,0x90,0x97,0xa7,0xe0,0x60,0x05,0x7f,0x01,0x12,0x74,0x0b,0xe5,0x3d,0x30,0xe7,
+0x15,0x90,0x00,0x55,0x74,0x80,0xf0,0x90,0x97,0xaa,0xe0,0x54,0x03,0xff,0xbf,0x03,
+0x05,0x7f,0x02,0x12,0x74,0x0b,0x90,0x01,0xc4,0x74,0x59,0xf0,0x74,0x72,0xa3,0xf0,
+0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,
+0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0xd3,0x10,0xaf,0x01,0xc3,
+0xc0,0xd0,0x90,0x97,0x84,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x90,0x97,0x84,
+0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,0x4d,0xfa,0xe5,
+0xf0,0x24,0x00,0xff,0xe4,0x3a,0xfe,0x90,0x97,0x84,0xa3,0xe0,0xfa,0x90,0x00,0x01,
+0xee,0x8f,0xf0,0x12,0x63,0xa4,0x12,0x29,0xd9,0xff,0x60,0x37,0xb5,0x22,0x1b,0x90,
+0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,0x4d,
+0x65,0x24,0x70,0x04,0xe5,0x23,0x65,0xf0,0x60,0x2e,0x90,0x97,0x84,0xe0,0xfb,0xa3,
+0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x63,0x4d,0xff,0xae,0xf0,0x12,0x79,
+0xe4,0x80,0x15,0x90,0x97,0x84,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x12,0x29,
+0xd9,0x65,0x22,0x60,0x03,0x12,0x7f,0x81,0xd0,0xd0,0x92,0xaf,0x22,0xef,0x64,0x01,
+0x70,0x34,0x7d,0x7d,0x7f,0x02,0x12,0x36,0x75,0x7d,0x02,0x7f,0x03,0x12,0x36,0x75,
+0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x7d,0x01,0x7f,0x0c,0x12,
+0x6f,0xa0,0xe4,0xff,0x12,0x7e,0x86,0x90,0x06,0x04,0xe0,0x54,0x7f,0xf0,0x90,0x06,
+0x0a,0xe0,0x54,0xf8,0xf0,0x22,0x90,0x01,0x36,0x74,0x7d,0xf0,0xa3,0x74,0x02,0xf0,
+0x7d,0x7d,0xff,0x12,0x36,0xe6,0x7d,0x02,0x7f,0x03,0x12,0x36,0xe6,0x90,0x06,0x04,
+0xe0,0x44,0x80,0xf0,0x90,0x06,0x0a,0xe0,0x44,0x07,0xf0,0x90,0x97,0xc3,0xe0,0xa3,
+0xe0,0x90,0x05,0x58,0xf0,0xe5,0x69,0x30,0xe0,0x1b,0x90,0x97,0xc0,0xe0,0x70,0x1a,
+0xe0,0x04,0xf0,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x0c,0x7d,0x01,
+0x7f,0x04,0x02,0x6f,0xa0,0xe4,0x90,0x97,0xc0,0xf0,0x22,0xef,0x14,0x60,0x20,0x14,
+0x60,0x4b,0x24,0x02,0x70,0x78,0x90,0x97,0xa7,0x74,0x02,0xf0,0x90,0x00,0x48,0xe0,
+0x44,0x0c,0xf0,0x90,0x00,0x47,0xe0,0x44,0x08,0xf0,0x90,0x00,0x45,0x80,0x5b,0xe4,
+0x90,0x97,0xa7,0xf0,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x90,
+0x00,0x45,0xe0,0x44,0xef,0xf0,0xe0,0x54,0xef,0xf0,0xa3,0x80,0x2d,0x90,0x97,0xa7,
+0x74,0x01,0xf0,0x90,0x97,0xad,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x80,0x85,0x12,0x2a,0x7f,0x7f,0x80,0x7e,0x08,0x12,0x2f,0xd9,0x90,0x00,
+0x45,0xe0,0x44,0x20,0xf0,0xe0,0x44,0x10,0xf0,0xa3,0xe0,0x44,0x10,0xf0,0x22,0x02,
+0x74,0xcd,0x02,0x67,0xb0,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0x40,0x03,0xf6,0x80,
+0x01,0xf2,0x08,0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,0xf8,0x54,0x07,0x24,0x0c,0xc8,
+0xc3,0x33,0xc4,0x54,0x0f,0x44,0x20,0xc8,0x83,0x40,0x04,0xf4,0x56,0x80,0x01,0x46,
+0xf6,0xdf,0xe4,0x80,0x0b,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x90,0x7e,0xf8,
+0xe4,0x7e,0x01,0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,0x30,0xe5,0x09,0x54,0x1f,0xfe,
+0xe4,0x93,0xa3,0x60,0x01,0x0e,0xcf,0x54,0xc0,0x25,0xe0,0x60,0xa8,0x40,0xb8,0xe4,
+0x93,0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,
+0x83,0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xdf,0xe9,0xde,0xe7,
+0x80,0xbe,0xe4,0x90,0x97,0x6e,0xf0,0xe5,0x6a,0x60,0x71,0xe5,0x69,0x64,0x01,0x70,
+0x6b,0xe5,0x6a,0x14,0x60,0x29,0x24,0xfd,0x60,0x25,0x24,0x02,0x24,0xfb,0x50,0x02,
+0x80,0x23,0x90,0x97,0xbe,0xe0,0x14,0xf0,0xe0,0x60,0x04,0xa3,0xe0,0x60,0x16,0x90,
+0x97,0xbe,0xe0,0x70,0x0a,0x90,0x97,0xc9,0xe0,0x90,0x97,0xbe,0xf0,0x80,0x00,0x90,
+0x97,0x6e,0x74,0x01,0xf0,0x90,0x97,0x6e,0xe0,0x60,0x31,0x90,0x97,0xcd,0xe0,0x44,
+0x10,0xf0,0x90,0x97,0xc5,0xe0,0xf5,0x44,0xe4,0xf5,0x45,0xfb,0xfd,0x7f,0x54,0x7e,
+0x01,0x12,0x35,0xab,0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,0xc8,0xe0,0x54,0x0f,
+0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xa0,0x22,0xab,0x07,0x75,
+0xf0,0x09,0xeb,0xa4,0x24,0x67,0xf5,0x82,0xe5,0xf0,0x34,0x93,0xf5,0x83,0xe0,0xff,
+0x74,0xe5,0x2b,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x54,0x1f,0xfa,0xd3,0x9f,
+0x40,0x02,0xaa,0x07,0xea,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,
+0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xea,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,
+0x41,0xf5,0x83,0x74,0x01,0x93,0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,
+0xff,0xe4,0xfc,0xfd,0xeb,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0x12,0x2a,0x7f,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xea,
+0xf0,0xff,0x22,0x90,0x06,0xa9,0xe0,0xf5,0x0a,0x54,0xc0,0x70,0x0e,0x90,0x97,0xcd,
+0xe0,0x54,0xfe,0xf0,0xe0,0x54,0xfd,0xf0,0x12,0x7f,0x77,0xe5,0x0a,0x30,0xe6,0x19,
+0x90,0x97,0xcd,0xe0,0x44,0x01,0xf0,0x90,0x97,0xcb,0xe0,0x64,0x02,0x60,0x05,0x12,
+0x7f,0x09,0x80,0x0c,0x12,0x7a,0xf0,0x80,0x07,0x90,0x97,0xcd,0xe0,0x54,0xfe,0xf0,
+0xe5,0x0a,0x90,0x97,0xcd,0x30,0xe7,0x20,0xe0,0x44,0x02,0xf0,0x75,0x44,0x03,0xe4,
+0xf5,0x45,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x57,0x74,0x05,
+0xf0,0x90,0x97,0xcc,0x74,0x01,0xf0,0x22,0xe0,0x54,0xfd,0xf0,0x22,0x8b,0x11,0x8a,
+0x12,0x89,0x13,0x12,0x7f,0x3a,0xab,0x11,0xaa,0x12,0xa9,0x13,0x12,0x29,0xd9,0xf5,
+0x6a,0x14,0x60,0x0e,0x14,0x60,0x1f,0x14,0x60,0x31,0x24,0x03,0x70,0x44,0x7f,0x01,
+0x80,0x3d,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xfd,0xe4,
+0xff,0x12,0x7d,0x88,0x80,0x29,0xab,0x11,0xaa,0x12,0xa9,0x13,0x90,0x00,0x02,0x12,
+0x62,0x95,0xfd,0x7f,0x01,0x12,0x7d,0x88,0x1f,0x80,0x14,0xab,0x11,0xaa,0x12,0xa9,
+0x13,0x90,0x00,0x02,0x12,0x62,0x95,0xfd,0x7f,0x02,0x12,0x7d,0x88,0xe4,0xff,0x12,
+0x73,0x7d,0x22,0x8d,0x0b,0xe5,0x0b,0x54,0x1f,0xf5,0x0f,0x74,0x01,0x2f,0xf5,0x82,
+0xe4,0x34,0x92,0xf5,0x83,0xe0,0xf5,0x0e,0x90,0x04,0xfd,0xe0,0xb4,0x01,0x05,0x75,
+0x10,0x03,0x80,0x03,0x75,0x10,0x01,0xeb,0xc3,0x95,0x10,0x40,0x03,0x02,0x75,0x8d,
+0xe5,0x0e,0x25,0x0d,0xfe,0xe5,0x0f,0x90,0x41,0xd6,0x93,0xfd,0xee,0xd3,0x9d,0x74,
+0x01,0x40,0x18,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x2f,
+0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe5,0x0b,0xf0,0x22,0x2f,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0xee,0xf0,0x22,0x8e,0x11,0x8f,0x12,0x8b,0x13,0x8a,0x14,0x89,0x15,
+0xe4,0x90,0x97,0x79,0xf0,0xef,0x90,0x00,0x31,0xf0,0x12,0x7f,0x1a,0xe5,0x11,0x54,
+0x03,0xff,0x90,0x00,0x32,0xe0,0x54,0xfc,0x4f,0xf0,0x12,0x7f,0x1a,0x90,0x00,0x33,
+0xe0,0x54,0x7f,0xf0,0x12,0x7f,0x1a,0x90,0x00,0x33,0xe0,0x20,0xe7,0x0e,0x90,0x97,
+0x79,0xe0,0xc3,0x94,0x64,0x50,0x05,0xe0,0x04,0xf0,0x80,0xeb,0x90,0x97,0x79,0xe0,
+0xc3,0x94,0x64,0x50,0x10,0x90,0x00,0x30,0xe0,0xab,0x13,0xaa,0x14,0xa9,0x15,0x12,
+0x62,0xc2,0x7f,0x01,0x22,0x7f,0x00,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x8b,
+0x60,0x8a,0x61,0x89,0x62,0x90,0x97,0xd8,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,
+0xa3,0xe5,0x63,0xf0,0xa3,0xe5,0x64,0xf0,0xa3,0xe5,0x65,0xf0,0xaf,0x66,0x15,0x66,
+0xef,0x60,0x2a,0x90,0x97,0xdb,0xe0,0xfb,0xa3,0xe4,0x75,0xf0,0x01,0x12,0x63,0x0c,
+0xa9,0xf0,0xfa,0x12,0x29,0xd9,0xff,0x90,0x97,0xd8,0xe0,0xfb,0xa3,0xe4,0x75,0xf0,
+0x01,0x12,0x63,0x0c,0xa9,0xf0,0xfa,0xef,0x12,0x62,0xc2,0x80,0xcf,0xab,0x60,0xaa,
+0x61,0xa9,0x62,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x00,0x45,0xe4,0xf0,0x90,0x04,0xfd,
+0xf0,0xa3,0xf0,0x90,0x97,0xab,0xf0,0x90,0x97,0xb1,0xf0,0x90,0x97,0xb4,0xf0,0x90,
+0x97,0xb2,0xf0,0x90,0x97,0xb5,0xf0,0x90,0x97,0xb3,0xf0,0x90,0x97,0xb6,0xf0,0x90,
+0x97,0x9d,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,0xa2,0xf0,0x90,
+0x97,0xa7,0xf0,0x90,0x97,0xa9,0xf0,0x90,0x97,0xbb,0xf0,0x90,0x97,0xac,0xf0,0x90,
+0x97,0xa8,0xf0,0x90,0x97,0xa1,0xf0,0x90,0x00,0x51,0xe0,0x44,0xc0,0xf0,0x22,0x90,
+0x00,0x2b,0xe0,0x44,0x01,0xf0,0x7f,0xe8,0x7e,0x03,0x12,0x37,0x54,0x90,0x00,0x08,
+0xe0,0x44,0x10,0xfd,0x7f,0x08,0x12,0x7f,0x6d,0x90,0x00,0x09,0xe0,0x54,0xf7,0xfd,
+0x7f,0x09,0x12,0x7f,0x6d,0x90,0x00,0x28,0xe0,0x54,0xfe,0xfd,0x7f,0x28,0x12,0x7f,
+0x6d,0x90,0x00,0x20,0xe0,0x54,0xfe,0xfd,0x7f,0x20,0x12,0x7f,0x6d,0x90,0x00,0x25,
+0xe0,0x44,0x40,0xfd,0x7f,0x25,0x12,0x7f,0x6d,0x90,0x00,0x09,0xe0,0x54,0xef,0xfd,
+0x7f,0x09,0x02,0x7f,0x6d,0x90,0x00,0x25,0xe0,0x54,0xbf,0xfd,0x7f,0x25,0x12,0x7f,
+0x6d,0x90,0x00,0x20,0xe0,0x44,0x01,0xfd,0x7f,0x20,0x12,0x7f,0x6d,0x90,0x00,0x28,
+0xe0,0x44,0x01,0xfd,0x7f,0x28,0x12,0x7f,0x6d,0x90,0x00,0xf0,0xe0,0x30,0xe1,0xf9,
+0x90,0x00,0x09,0xe0,0x44,0x08,0xfd,0x7f,0x09,0x12,0x7f,0x6d,0x90,0x00,0x08,0xe0,
+0x54,0xef,0xfd,0x7f,0x08,0x12,0x7f,0x6d,0x90,0x00,0x2b,0xe0,0x54,0xfe,0xfd,0x7f,
+0x2b,0x12,0x7f,0x6d,0x7f,0xe8,0x7e,0x03,0x02,0x37,0x54,0x90,0x05,0x60,0xe0,0x90,
+0x97,0xb7,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0xb8,0xf0,0x90,0x05,0x62,0xe0,0x90,
+0x97,0xb9,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0xba,0xf0,0xc3,0x74,0xff,0x9f,0xfe,
+0x90,0x97,0xb8,0xe0,0xd3,0x9e,0x40,0x1e,0xe0,0x2f,0xf0,0xa3,0xe0,0xb4,0xff,0x0f,
+0xe4,0xf0,0xa3,0xe0,0xb4,0xff,0x03,0xe4,0xf0,0x22,0x90,0x97,0xba,0x80,0x03,0x90,
+0x97,0xb9,0xe0,0x04,0xf0,0x22,0x90,0x97,0xb8,0xe0,0x2f,0xf0,0x22,0xe4,0xf5,0x69,
+0x90,0x97,0xcd,0xf0,0xf5,0x6a,0x90,0x97,0xca,0x74,0x0c,0xf0,0x90,0x97,0xc8,0xf0,
+0xe4,0x90,0x97,0xcb,0xf0,0x90,0x97,0xc7,0xf0,0x90,0x97,0xc6,0xf0,0x90,0x97,0xc9,
+0x04,0xf0,0x90,0x97,0xbe,0xf0,0xe4,0x90,0x97,0xcc,0xf0,0x90,0x97,0xc0,0xf0,0x90,
+0x97,0xc5,0x74,0x07,0xf0,0xe4,0x90,0x97,0xbf,0xf0,0x90,0x97,0xc3,0xf0,0xa3,0x74,
+0x02,0xf0,0xe4,0x90,0x97,0xc2,0xf0,0x90,0x97,0xbd,0xf0,0x22,0xe4,0x90,0x97,0xd5,
+0xf0,0xa2,0xaf,0x33,0x90,0x97,0x7a,0xf0,0x90,0x00,0x80,0xe0,0x20,0xe1,0x1a,0x12,
+0x37,0x7a,0x12,0x37,0x7a,0x90,0x97,0x79,0xe0,0x64,0x01,0xf0,0xe0,0x24,0x9c,0x90,
+0x01,0xc4,0xf0,0x74,0x79,0xa3,0xf0,0x80,0xdf,0x90,0x06,0x30,0x74,0x01,0xf0,0xc2,
+0xaf,0x90,0x00,0x80,0xe0,0x44,0x80,0xf0,0x12,0x7f,0x1a,0x90,0x97,0x7a,0xe0,0x24,
+0xff,0x92,0xaf,0x22,0x90,0x97,0x87,0xee,0xf0,0xa3,0xef,0xf0,0x75,0x22,0x01,0x8e,
+0x23,0xf5,0x24,0xe4,0xfd,0x7f,0x0b,0x12,0x6d,0x53,0xe4,0xfd,0x7f,0x02,0x12,0x6d,
+0x53,0x12,0x7e,0x69,0xe4,0xff,0x12,0x7f,0x56,0xe4,0xf5,0x26,0x90,0x01,0xc9,0xe5,
+0x26,0xf0,0x90,0x97,0x87,0xe0,0xfc,0xa3,0xe0,0xfd,0xec,0xfb,0x8d,0x44,0xe4,0xf5,
+0x45,0x7d,0x01,0x7f,0x60,0x7e,0x01,0x02,0x35,0xab,0xe4,0x90,0x97,0xeb,0xf0,0xa3,
+0xf0,0x90,0x05,0xf8,0xe0,0x70,0x0f,0xa3,0xe0,0x70,0x0b,0xa3,0xe0,0x70,0x07,0xa3,
+0xe0,0x70,0x03,0x7f,0x01,0x22,0xd3,0x90,0x97,0xec,0xe0,0x94,0xe8,0x90,0x97,0xeb,
+0xe0,0x94,0x03,0x40,0x03,0x7f,0x00,0x22,0x7f,0x32,0x7e,0x00,0x12,0x37,0x54,0x90,
+0x97,0xec,0xe0,0x04,0xf0,0x70,0xca,0x90,0x97,0xeb,0xe0,0x04,0xf0,0x80,0xc2,0xe5,
+0x22,0x64,0x01,0x70,0x3c,0x12,0x7e,0x69,0xbf,0x01,0x05,0x7f,0x01,0x12,0x7f,0x56,
+0x90,0x00,0x46,0xe0,0x44,0x04,0xf0,0x12,0x7f,0x1a,0x90,0x00,0x44,0xe0,0x54,0xfb,
+0xf0,0x12,0x7f,0x1a,0x90,0x00,0x46,0xe0,0x54,0xfb,0xf0,0x12,0x7f,0x1a,0x7f,0x02,
+0x12,0x71,0x13,0x8f,0x26,0x90,0x01,0xc9,0xe5,0x26,0xf0,0xb4,0x01,0x03,0x12,0x7e,
+0xa1,0x22,0xe5,0x57,0x70,0x37,0x90,0x97,0xca,0xe0,0x54,0x0f,0xd3,0x94,0x01,0x50,
+0x2c,0x90,0x02,0x87,0xe0,0x70,0x26,0x90,0x97,0xd6,0xe0,0xb4,0x02,0x10,0x90,0x97,
+0xce,0xe0,0xfe,0xa3,0xe0,0xf5,0x82,0x8e,0x83,0xe0,0x60,0x08,0x80,0x0f,0x90,0x01,
+0xaf,0xe0,0x70,0x09,0x90,0x97,0xc2,0xe0,0x60,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,
+0x90,0x01,0x5f,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x08,0xf0,0x75,0x44,0x14,0xe4,0xf5,
+0x45,0xfb,0xfd,0x7f,0x5c,0x7e,0x01,0x12,0x35,0xab,0x90,0x01,0x5f,0x74,0x05,0xf0,
+0x90,0x06,0x92,0x74,0x02,0xf0,0x90,0x97,0xc6,0x14,0xf0,0x90,0x97,0xc8,0xe0,0x54,
+0x0f,0xc3,0x94,0x0c,0x50,0x07,0x7d,0x01,0x7f,0x0c,0x12,0x6f,0xa0,0x22,0x90,0x97,
+0xcc,0xe0,0x60,0x0e,0xe4,0xf0,0xa3,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0x07,0x70,0x28,
+0x80,0x23,0x90,0x97,0xbf,0xe0,0x04,0xf0,0x90,0x97,0xcd,0xe0,0x54,0xef,0xf0,0x90,
+0x97,0xbf,0xe0,0xd3,0x94,0x01,0x40,0x0d,0xe5,0x69,0xb4,0x01,0x0b,0xa3,0xe0,0x70,
+0x07,0xe0,0x04,0xf0,0x22,0x12,0x7f,0x77,0x22,0x90,0x02,0x09,0xe0,0xfd,0x12,0x29,
+0xd9,0xfe,0xaf,0x05,0xed,0x2e,0x90,0x97,0xd1,0xf0,0x90,0x00,0x01,0x12,0x62,0x95,
+0xff,0xed,0x2f,0x90,0x97,0xd2,0xf0,0x90,0x00,0x02,0x12,0x62,0x95,0xff,0xed,0x2f,
+0x90,0x97,0xd3,0xf0,0x90,0x00,0x03,0x12,0x62,0x95,0xff,0xae,0x05,0xed,0x2f,0x90,
+0x97,0xd4,0xf0,0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x2a,0x90,0x97,
+0xcd,0xe0,0x54,0x03,0x70,0x22,0x90,0x97,0xca,0xe0,0x54,0x0f,0xd3,0x94,0x02,0x50,
+0x17,0x90,0x97,0xcd,0xe0,0x20,0xe2,0x10,0x90,0x97,0xcd,0xe0,0x20,0xe4,0x09,0x90,
+0x97,0xc0,0xe0,0x70,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x01,0x37,0x74,0x02,
+0xf0,0x90,0x05,0x22,0x74,0xff,0xf0,0x12,0x7a,0x2a,0xef,0x70,0x06,0x90,0x01,0xc8,
+0x74,0xfd,0xf0,0x7d,0x02,0x7f,0x03,0x12,0x36,0xe6,0xe5,0x6a,0x60,0x05,0x7f,0x01,
+0x12,0x7e,0x86,0x12,0x6a,0xc2,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,
+0xf0,0x22,0x8f,0x27,0x90,0x97,0xd3,0xe0,0xff,0x7d,0x01,0x12,0x70,0x5e,0xe5,0x27,
+0x60,0x10,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x44,0x10,0xf0,
+0x80,0x0e,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe0,0x54,0xef,0xf0,
+0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x8f,0x6b,0x90,0x97,0xd4,0xe0,0xff,0x7d,0x01,
+0x12,0x70,0x5e,0xe5,0x6b,0x60,0x10,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,
+0x83,0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x7d,0x02,0x7f,0x03,
+0x12,0x36,0x75,0xe5,0x6a,0x14,0x24,0xfd,0x50,0x02,0x80,0x23,0x90,0x97,0xcb,0xe0,
+0x60,0x06,0x7d,0x01,0x7f,0x0c,0x80,0x0f,0x90,0x97,0xc8,0xe0,0x54,0x0f,0xc3,0x94,
+0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,0x6f,0xa0,0xe4,0xff,0x12,0x7e,0x86,0x22,
+0x90,0x00,0x02,0x12,0x62,0x95,0x90,0x97,0xab,0xf0,0xe0,0x60,0x04,0xe0,0xb4,0xff,
+0x1c,0xa2,0xaf,0xe4,0x33,0xf5,0x11,0xc2,0xaf,0x90,0x00,0x47,0xe0,0x54,0xfb,0xf0,
+0x7d,0x40,0x7f,0x01,0x12,0x36,0xaf,0xe5,0x11,0x24,0xff,0x92,0xaf,0x22,0x90,0x06,
+0x34,0xe0,0x60,0x26,0x14,0x70,0x1b,0x7b,0x01,0x7a,0x06,0x79,0x35,0x7f,0xf9,0x7e,
+0x01,0x12,0x77,0x36,0xbf,0x01,0x09,0x90,0x06,0x35,0xe0,0x54,0x0f,0xf0,0x80,0x05,
+0x80,0x00,0x02,0x7f,0x48,0xe4,0x90,0x06,0x34,0xf0,0x22,0x12,0x29,0xd9,0xff,0xc3,
+0x94,0x20,0x50,0x14,0x90,0x00,0x02,0x12,0x62,0x95,0xfe,0x74,0x63,0x2f,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xee,0xf0,0x22,0xef,0xb4,0x20,0x0a,0x90,0x00,0x02,0x12,
+0x62,0x95,0x90,0x93,0x61,0xf0,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,0xd0,0x90,0x00,
+0x01,0x12,0x62,0x95,0x90,0x97,0xcb,0xf0,0x90,0x00,0x03,0x12,0x62,0x95,0x90,0x97,
+0xbd,0xf0,0x12,0x29,0xd9,0x65,0x6a,0x60,0x03,0x12,0x76,0x6d,0xd0,0xd0,0x92,0xaf,
+0x22,0x90,0x04,0x1b,0xe0,0x54,0x7f,0xff,0xbf,0x7f,0x1a,0x90,0x97,0xc7,0xe0,0x70,
+0x14,0x90,0x97,0xc6,0xe0,0x70,0x0e,0x90,0x97,0xca,0xe0,0x54,0x0f,0xd3,0x94,0x04,
+0x50,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0xef,0x24,0xfe,0x60,0x0b,0x04,0x70,0x1d,
+0x90,0x97,0xc9,0x74,0x01,0xf0,0x80,0x11,0xed,0x90,0x97,0xc9,0x70,0x05,0x74,0x05,
+0xf0,0x80,0x02,0xed,0xf0,0x90,0x97,0xc9,0xe0,0x90,0x97,0xbe,0xf0,0x22,0x90,0x97,
+0x6e,0xe0,0x54,0xf0,0x44,0x03,0xf0,0x54,0x0f,0x44,0x80,0xf0,0x90,0x97,0x73,0xe4,
+0xf0,0xa3,0x74,0x00,0xf0,0xa3,0x74,0x58,0xf0,0x7b,0x01,0x7a,0x97,0x79,0x6e,0x02,
+0x71,0xbc,0x90,0x06,0x04,0xe0,0x54,0xbf,0xf0,0xef,0x60,0x0a,0xe5,0x69,0xb4,0x01,
+0x05,0xe4,0xff,0x12,0x7c,0x12,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x0c,
+0xf0,0x22,0x90,0x97,0xf0,0xef,0xf0,0x12,0x44,0x6c,0x90,0x97,0xf0,0xe0,0x60,0x05,
+0x90,0x05,0x22,0xe4,0xf0,0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x04,0xf0,
+0x22,0x75,0x28,0x33,0xe4,0xf5,0x29,0x75,0x2a,0x02,0xf5,0x2b,0x90,0x01,0x30,0xe5,
+0x28,0xf0,0xa3,0xe5,0x29,0xf0,0xa3,0xe5,0x2a,0xf0,0xa3,0xe5,0x2b,0xf0,0x22,0x90,
+0x06,0x04,0xe0,0x44,0x40,0xf0,0xe5,0x69,0xb4,0x01,0x05,0x7f,0x01,0x12,0x7c,0x12,
+0x90,0x97,0xc8,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x90,0x97,0xc8,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x01,0xf0,0x12,0x78,0x4f,0x12,0x78,0xa5,0x90,0x97,0xc8,
+0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x7f,0x0b,0x12,0x71,0x13,0xef,0x65,
+0x25,0x60,0x10,0xe5,0x25,0xb4,0x01,0x05,0xe4,0xf5,0x25,0x80,0x03,0x75,0x25,0x01,
+0x7f,0x01,0x22,0x7f,0x00,0x22,0xef,0x60,0x0b,0x90,0x97,0xd7,0xe0,0xb4,0x01,0x10,
+0xe4,0xff,0x80,0x09,0x90,0x97,0xd7,0xe0,0xb4,0x01,0x05,0x7f,0x01,0x12,0x4e,0x3f,
+0x22,0x90,0x00,0x49,0xe0,0x90,0x97,0xf1,0xf0,0xe0,0x54,0x0f,0xf0,0xe0,0xff,0x44,
+0xf0,0x90,0x00,0x49,0xf0,0xef,0x44,0xb0,0xf0,0x22,0x75,0x30,0x1e,0x75,0x31,0x01,
+0xe4,0xf5,0x32,0x90,0x01,0x38,0xe5,0x30,0xf0,0xa3,0xe5,0x31,0xf0,0xa3,0xe5,0x32,
+0xf0,0x22,0x90,0x01,0x3c,0x74,0xff,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x01,0x34,0xf0,
+0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x02,0x09,0xe0,0xff,0x7d,0x01,0x12,0x70,
+0x5e,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x41,0x97,0xd0,0x00,0x41,0x97,0xef,0x00,
+0x41,0x97,0xbc,0x80,0x41,0x97,0xe3,0x00,0x00,0x90,0x97,0xd2,0xe0,0xff,0xe4,0xfd,
+0x12,0x70,0x5e,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0xd3,0x10,0xaf,0x01,0xc3,0xc0,
+0xd0,0x7f,0x10,0xdf,0xfe,0xd0,0xd0,0x92,0xaf,0x22,0x90,0x09,0x28,0xef,0xf0,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0xe4,0x90,0x97,0xcc,0xf0,0x90,
+0x97,0xbf,0xf0,0x90,0x97,0xcd,0xf0,0x22,0x90,0x06,0x34,0x74,0xff,0xf0,0xe4,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x90,0x01,0xca,0xe5,0x25,0xf0,0xef,0x60,0x03,0x12,
+0x7e,0xa1,0x22,0x8f,0x82,0x8e,0x83,0xa3,0xa3,0xa3,0xe4,0xf0,0x22,0x8f,0x82,0x75,
+0x83,0x00,0xed,0xf0,0x02,0x7f,0x1a,0x90,0x97,0xca,0xe0,0xff,0x7d,0x01,0x02,0x6f,
+0xa0,0xe4,0xf5,0x22,0x7f,0x60,0x7e,0x01,0x02,0x7f,0x63,0x90,0x97,0xd7,0xe0,0x90,
+0x97,0x6d,0xf0,0x22,0x8f,0x1c,0x8c,0x1d,0x8d,0x1e,0x22,0x8f,0x1f,0x8c,0x20,0x8d,
+0x21,0x22,0x12,0x29,0xd9,0xf5,0x69,0x22,0xe4,0xf5,0x25,0x22,0x8a,0xcb,
+};
+
+
+// ===================8723=========================================
+u8 Rtl8192CUFwUMC8723ImgArray[UMC8723ImgArrayLength] = {
+0xc1,0x88,0x02,0x00,0x39,0x00,0x01,0x00,0x09,0x09,0x16,0x47,0x80,0x3f,0x00,0x00,
+0x29,0x29,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x02,0x74,0xc9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x59,0xd0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x02,0x73,0xab,0x00,0x00,0x00,0x00,0x00,0x02,0x67,0xfe,0x00,0x00,
+0x05,0x04,0x03,0x02,0x00,0x03,0x06,0x05,0x04,0x03,0x00,0x04,0x06,0x05,0x04,0x02,
+0x00,0x04,0x08,0x07,0x06,0x04,0x00,0x06,0x0a,0x09,0x08,0x06,0x00,0x08,0x0a,0x09,
+0x08,0x04,0x00,0x08,0x0a,0x09,0x08,0x02,0x00,0x08,0x0a,0x09,0x08,0x00,0x00,0x08,
+0x12,0x11,0x10,0x08,0x00,0x10,0x1a,0x19,0x18,0x10,0x00,0x18,0x22,0x21,0x20,0x18,
+0x00,0x20,0x22,0x21,0x20,0x10,0x00,0x20,0x22,0x21,0x20,0x08,0x00,0x20,0x22,0x21,
+0x1c,0x08,0x00,0x20,0x22,0x21,0x14,0x08,0x00,0x20,0x22,0x20,0x18,0x08,0x00,0x20,
+0x31,0x30,0x20,0x10,0x00,0x30,0x31,0x30,0x18,0x00,0x00,0x30,0x31,0x2f,0x10,0x10,
+0x00,0x30,0x31,0x2c,0x10,0x10,0x00,0x30,0x31,0x28,0x10,0x00,0x00,0x30,0x31,0x20,
+0x10,0x00,0x00,0x30,0x31,0x10,0x10,0x00,0x00,0x30,0x05,0x05,0x05,0x05,0x05,0x05,
+0x05,0x07,0x07,0x07,0x08,0x0a,0x05,0x05,0x05,0x07,0x07,0x0a,0x0d,0x0e,0x05,0x05,
+0x07,0x07,0x08,0x0c,0x14,0x14,0x05,0x05,0x05,0x05,0x09,0x09,0x09,0x09,0x0c,0x0e,
+0x13,0x13,0x09,0x09,0x0a,0x0b,0x0d,0x11,0x13,0x13,0x09,0x09,0x09,0x09,0x0c,0x14,
+0x15,0x15,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x06,0x06,0x06,0x06,0x06,0x05,0x05,
+0x05,0x06,0x06,0x06,0x06,0x06,0x05,0x05,0x06,0x06,0x06,0x06,0x06,0x06,0x05,0x05,
+0x05,0x05,0x09,0x09,0x09,0x09,0x0b,0x0d,0x10,0x12,0x05,0x09,0x0a,0x0c,0x0d,0x0e,
+0x10,0x12,0x09,0x09,0x0e,0x0e,0x10,0x10,0x12,0x12,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x24,0x26,0x2a,0x18,0x1a,0x1d,0x1f,0x21,0x27,0x29,0x2a,0x00,0x00,
+0x00,0x1f,0x23,0x28,0x2a,0x2c,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x18,
+0x00,0x24,0x00,0x30,0x00,0x48,0x00,0x60,0x00,0x90,0x00,0xc0,0x00,0xd8,0x00,0x50,
+0x00,0x78,0x00,0xa0,0x00,0xc8,0x01,0x40,0x01,0x90,0x01,0xe0,0x02,0x30,0x01,0x2c,
+0x01,0x40,0x01,0xe0,0x02,0xd0,0x03,0xe8,0x04,0xb0,0x06,0x40,0x07,0xd0,0x00,0x02,
+0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x0c,0x00,0x12,0x00,0x18,0x00,0x24,0x00,0x30,
+0x00,0x48,0x00,0x60,0x00,0x6c,0x00,0x28,0x00,0x3c,0x00,0x50,0x00,0x64,0x00,0xa0,
+0x00,0xc8,0x00,0xf0,0x01,0x18,0x00,0x64,0x00,0xa0,0x00,0xf0,0x01,0x68,0x01,0xf4,
+0x02,0x58,0x03,0x20,0x03,0xe8,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,
+0x07,0x08,0x01,0x02,0x03,0x04,0x08,0x0f,0x23,0x3c,0x05,0x06,0x07,0x0f,0x19,0x32,
+0x4b,0x64,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x01,0x02,
+0x03,0x04,0x05,0x06,0x07,0x08,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x22,0x1f,
+0x1e,0x18,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x8f,0x17,0x74,0x42,0x90,0x01,0xc4,0xf0,0xa3,0x74,0x20,0xf0,0x74,0x84,0x25,0x17,
+0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,0x97,0x54,0xf0,0xe0,0xfb,
+0x54,0x1f,0xff,0xa3,0xf0,0xe5,0x17,0x75,0xf0,0x08,0xa4,0x24,0x67,0xf5,0x82,0xe4,
+0x34,0x93,0xf5,0x83,0xe0,0xfe,0x90,0x97,0x57,0xf0,0xe5,0x17,0x25,0xe0,0x24,0x81,
+0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfd,0xa3,0xe0,0x90,0x97,0x58,0xcd,0xf0,
+0xa3,0xed,0xf0,0xe5,0x17,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,
+0xe0,0xfd,0xa3,0xe0,0x90,0x97,0x5a,0xcd,0xf0,0xa3,0xed,0xf0,0xef,0xc3,0x9e,0x40,
+0x03,0x02,0x43,0x56,0x90,0x01,0xc5,0x74,0x20,0xf0,0x90,0x97,0x55,0xe0,0xff,0x74,
+0xa5,0x25,0x17,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0xef,0x04,0x90,0x97,
+0x56,0xf0,0x90,0x97,0x57,0xe0,0xff,0x90,0x97,0x56,0xe0,0xfe,0xd3,0x9f,0x40,0x03,
+0x02,0x43,0xa0,0xee,0xc3,0x94,0x10,0x40,0x21,0xee,0x24,0xf0,0xff,0x74,0x01,0x7e,
+0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,
+0x58,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x70,0x27,0x90,0x97,0x56,0xe0,0xff,0xc3,
+0x94,0x10,0x50,0x59,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,
+0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x5a,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,
+0x3c,0x90,0x97,0x56,0xe0,0xb4,0x11,0x0d,0x90,0x97,0x59,0xe0,0x30,0xe7,0x06,0x90,
+0x97,0x56,0x74,0x17,0xf0,0x90,0x97,0x56,0xe0,0xff,0x64,0x13,0x60,0x04,0xef,0xb4,
+0x12,0x0d,0x90,0x97,0x58,0xe0,0x30,0xe0,0x06,0x90,0x97,0x56,0x74,0x18,0xf0,0x90,
+0x97,0x56,0xe0,0x90,0x97,0x55,0xf0,0x90,0x97,0x54,0xf0,0x80,0x53,0x90,0x97,0x56,
+0xe0,0x04,0xf0,0x02,0x42,0xb2,0x90,0x97,0x57,0xe0,0xf9,0x90,0x97,0x55,0xe0,0xff,
+0x69,0x60,0x03,0x02,0x43,0xe8,0x90,0x01,0xc5,0x74,0x40,0xf0,0x74,0xa5,0x25,0x17,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0xe5,0x17,0x75,0xf0,0x08,0xa4,0x24,
+0x69,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0xe0,0xb4,0x01,0x14,0xeb,0x30,0xe6,0x06,
+0x90,0x97,0x54,0xe0,0xff,0x22,0x90,0x97,0x55,0xe0,0x44,0x40,0x90,0x97,0x54,0xf0,
+0x90,0x97,0x55,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,
+0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,
+0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,
+0xff,0xe4,0xfc,0xfd,0xe5,0x17,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0x12,0x1d,0xa9,0x80,0x71,0x90,0x97,0x55,0xe0,0xd3,0x99,0x40,0x69,
+0x90,0x01,0xc5,0x74,0x60,0xf0,0x90,0x97,0x57,0xe0,0xff,0x74,0xa5,0x25,0x17,0xf5,
+0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x90,0x97,0x55,0xef,0xf0,0x90,0x97,0x54,
+0xf0,0xfb,0xa3,0xe0,0xff,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,
+0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,
+0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,
+0xff,0xe4,0xfc,0xfd,0xe5,0x17,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0x12,0x1d,0xa9,0xaf,0x03,0x22,0x74,0x01,0x25,0x17,0xf5,0x82,0xe4,
+0x34,0x92,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x54,0xe0,0x44,0x80,0xff,0x74,0x84,0x25,
+0x17,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x22,0xef,0x14,0x60,0x20,0x14,
+0x60,0x4b,0x24,0x02,0x70,0x78,0x90,0x97,0x69,0x74,0x02,0xf0,0x90,0x00,0x48,0xe0,
+0x44,0x0c,0xf0,0x90,0x00,0x47,0xe0,0x44,0x08,0xf0,0x90,0x00,0x45,0x80,0x5b,0xe4,
+0x90,0x97,0x69,0xf0,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x80,0x7e,0x08,0x12,0x33,0xd8,0x90,
+0x00,0x45,0xe0,0x44,0xef,0xf0,0xe0,0x54,0xef,0xf0,0xa3,0x80,0x2d,0x90,0x97,0x69,
+0x74,0x01,0xf0,0x90,0x97,0x6f,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x80,0x7e,0x08,0x12,0x33,0xd8,0x90,0x00,
+0x45,0xe0,0x44,0x20,0xf0,0xe0,0x44,0x10,0xf0,0xa3,0xe0,0x44,0x10,0xf0,0x22,0xe4,
+0xf5,0x61,0x22,0x02,0x7f,0x69,0x02,0x7f,0x70,0x74,0x45,0x90,0x01,0xc4,0xf0,0xa3,
+0x74,0x09,0xf0,0xe4,0x90,0x97,0x3a,0xf0,0x90,0x97,0x3a,0xe0,0xff,0xc3,0x94,0x20,
+0x40,0x03,0x02,0x4e,0x3a,0xef,0x75,0xf0,0x08,0xa4,0x24,0x6a,0xf5,0x82,0xe4,0x34,
+0x93,0xf5,0x83,0xe0,0x64,0x01,0x60,0x03,0x02,0x4e,0x31,0x90,0x97,0x3a,0xe0,0x25,
+0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,
+0x00,0xec,0x94,0x00,0x50,0x03,0x02,0x4e,0x31,0xef,0x75,0xf0,0x0a,0xa4,0x24,0x00,
+0xf9,0x74,0x90,0x35,0xf0,0xfa,0x7b,0x01,0x8b,0x13,0xf5,0x14,0x89,0x15,0x90,0x97,
+0x3a,0xe0,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe0,0xfd,0xa3,
+0xe0,0x90,0x97,0x46,0xcd,0xf0,0xa3,0xed,0xf0,0xef,0x25,0xe0,0x24,0x63,0xf5,0x82,
+0xe4,0x34,0x94,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x97,0x48,0xcf,0xf0,0xa3,0xef,
+0xf0,0x90,0x00,0x02,0x12,0x66,0x20,0xff,0xae,0xf0,0x12,0x65,0xf5,0x2f,0xff,0xe5,
+0xf0,0x3e,0x90,0x97,0x4f,0xf0,0xa3,0xef,0xf0,0x90,0x00,0x06,0x12,0x66,0x20,0xff,
+0xae,0xf0,0x90,0x00,0x04,0x12,0x66,0x20,0x2f,0xff,0xe5,0xf0,0x3e,0x90,0x97,0x4d,
+0xf0,0xa3,0xef,0xf0,0x90,0x00,0x08,0x12,0x66,0x20,0xff,0x90,0x97,0x4b,0xe5,0xf0,
+0xf0,0xa3,0xef,0xf0,0x90,0x97,0x3a,0xe0,0xfe,0x24,0x84,0xf5,0x82,0xe4,0x34,0x04,
+0xf5,0x83,0xe0,0x54,0x3f,0x90,0x97,0x3c,0xf0,0xe0,0xfd,0x54,0x1f,0xa3,0xf0,0xee,
+0x75,0xf0,0x08,0xa4,0x24,0x67,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0xe0,0x90,0x97,
+0x51,0xf0,0x90,0x97,0x3a,0xe0,0xfb,0x24,0x64,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xe0,0xc3,0x94,0x05,0x40,0x03,0x02,0x49,0xc2,0x90,0x97,0x51,0xe0,0xfe,0x90,0x97,
+0x3d,0xe0,0x9e,0x40,0x13,0x90,0x97,0x51,0xe0,0x90,0x97,0x3d,0xf0,0xed,0x54,0x40,
+0xfd,0x90,0x97,0x3c,0xf0,0xee,0x4d,0xf0,0x90,0x04,0xfd,0xe0,0x64,0x01,0x70,0x28,
+0x90,0x97,0x3d,0xe0,0xff,0x90,0x41,0x4a,0x93,0xfe,0x74,0x23,0x2b,0xf5,0x82,0xe4,
+0x34,0x95,0xf5,0x83,0xe0,0xc3,0x9e,0x40,0x06,0xef,0x90,0x41,0x12,0x80,0x32,0x90,
+0x97,0x3d,0xe0,0x90,0x41,0x2e,0x80,0x29,0x90,0x97,0x3d,0xe0,0xff,0x90,0x41,0x4a,
+0x93,0xfe,0x90,0x97,0x3a,0xe0,0x24,0x23,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,
+0xc3,0x9e,0x40,0x06,0xef,0x90,0x40,0xda,0x80,0x07,0x90,0x97,0x3d,0xe0,0x90,0x40,
+0xf6,0x93,0x90,0x97,0x4a,0xf0,0x90,0x97,0x4a,0xe0,0x75,0xf0,0x06,0xa4,0x24,0x50,
+0xf9,0x74,0x40,0x35,0xf0,0x75,0x10,0xff,0xf5,0x11,0x89,0x12,0x90,0x97,0x3c,0xe0,
+0x90,0x41,0xf2,0x93,0xff,0xd3,0x90,0x97,0x49,0xe0,0x9f,0x90,0x97,0x48,0xe0,0x94,
+0x00,0x40,0x0d,0x90,0x97,0x3a,0xe0,0xff,0xe4,0xfd,0x12,0x5f,0x6d,0x02,0x4d,0xc7,
+0x90,0x97,0x3a,0xe0,0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,
+0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x97,0x3e,0x12,
+0x1d,0xa9,0x90,0x97,0x3e,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,
+0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x10,0xaa,0x11,0xa9,0x12,0x12,0x1c,
+0xd6,0xff,0x7e,0x00,0xab,0x13,0xaa,0x14,0xa9,0x15,0x12,0x65,0xf5,0xfd,0xac,0xf0,
+0x12,0x1d,0x1c,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,
+0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x3e,0x12,0x1d,0xa9,
+0x90,0x97,0x3e,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,
+0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x10,0xaa,0x11,0xa9,0x12,0x90,0x00,0x01,0x12,
+0x1c,0xef,0xff,0x7e,0x00,0xab,0x13,0xaa,0x14,0xa9,0x15,0x90,0x00,0x02,0x12,0x66,
+0x20,0xfd,0xac,0xf0,0x12,0x1d,0x1c,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,
+0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,
+0x3e,0x12,0x1d,0xa9,0x90,0x97,0x3e,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x10,0xaa,0x11,0xa9,0x12,
+0x90,0x00,0x02,0x12,0x1c,0xef,0xff,0x7e,0x00,0xab,0x13,0xaa,0x14,0xa9,0x15,0x90,
+0x00,0x04,0x12,0x66,0x20,0xfd,0xac,0xf0,0x12,0x1d,0x1c,0xe4,0xfc,0xfd,0xd0,0x03,
+0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,
+0x38,0xfc,0x90,0x97,0x3e,0x12,0x1d,0xa9,0x90,0x97,0x3e,0xe0,0xf8,0xa3,0xe0,0xf9,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,0x10,
+0xaa,0x11,0xa9,0x12,0x90,0x00,0x03,0x12,0x1c,0xef,0xff,0x7e,0x00,0xab,0x13,0xaa,
+0x14,0xa9,0x15,0x90,0x00,0x06,0x12,0x66,0x20,0xfd,0xac,0xf0,0x12,0x1d,0x1c,0xe4,
+0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,0xff,0xea,0x3e,0xfe,
+0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x3e,0x12,0x1d,0xa9,0x90,0x97,0x3e,0xe0,
+0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,
+0xc0,0x03,0xab,0x10,0xaa,0x11,0xa9,0x12,0x90,0x00,0x04,0x12,0x1c,0xef,0xff,0x7e,
+0x00,0xab,0x13,0xaa,0x14,0xa9,0x15,0x90,0x00,0x08,0x12,0x66,0x20,0xfd,0xac,0xf0,
+0x12,0x1d,0x1c,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,0x2f,
+0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x3e,0x12,0x1d,0xa9,
+0xab,0x10,0xaa,0x11,0xa9,0x12,0x90,0x00,0x05,0x12,0x1c,0xef,0xff,0x7e,0x00,0x90,
+0x97,0x46,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x1d,0x1c,0xe4,0xfc,0xfd,0x90,0x97,0x3e,
+0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x66,0xa4,0x90,
+0x97,0x3e,0x40,0x50,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xc0,
+0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0xab,0x10,0xaa,0x11,0xa9,0x12,0x90,0x00,0x05,
+0x12,0x1c,0xef,0xff,0x7e,0x00,0x90,0x97,0x46,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x1d,
+0x1c,0xab,0x07,0xaa,0x06,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xc3,0xef,0x9b,
+0xff,0xee,0x9a,0xfe,0xed,0x94,0x00,0xfd,0xec,0x94,0x00,0xfc,0x90,0x97,0x3e,0x12,
+0x1d,0xa9,0x80,0x07,0x12,0x1d,0xb5,0x00,0x00,0x00,0x00,0x90,0x97,0x3e,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x97,0x3a,0xe0,0x25,0xe0,0x25,
+0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x1d,0xa9,0x90,0x97,0x3c,
+0xe0,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,
+0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,0x3e,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x66,0xa4,0x40,0x0b,0x90,0x97,0x3a,0xe0,0xff,0x12,
+0x42,0x20,0x02,0x4d,0x3e,0x90,0x97,0x3c,0xe0,0x25,0xe0,0x24,0x9e,0xf5,0x82,0xe4,
+0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,0xff,0xe4,0xfc,0xfd,0x90,0x97,
+0x3e,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc3,0x12,0x66,0xa4,
+0x40,0x03,0x02,0x4d,0x3e,0x90,0x97,0x3a,0xe0,0xff,0x7d,0x01,0x12,0x5f,0x6d,0x02,
+0x4d,0x3e,0x90,0x97,0x3a,0xe0,0xff,0x24,0x64,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,
+0xe0,0x64,0x05,0x60,0x03,0x02,0x4b,0x8e,0x90,0x04,0xb3,0xe0,0x64,0x01,0x70,0x03,
+0x02,0x4b,0x8e,0x90,0x93,0x62,0xe0,0xfe,0xb4,0x03,0x0b,0x90,0x97,0x3d,0xe0,0xc3,
+0x94,0x19,0x40,0x3d,0x80,0x2e,0xee,0xb4,0x02,0x0b,0x90,0x97,0x3d,0xe0,0xc3,0x94,
+0x11,0x40,0x2e,0x80,0x1f,0x90,0x93,0x62,0xe0,0xfe,0xb4,0x01,0x0b,0x90,0x97,0x3d,
+0xe0,0xc3,0x94,0x0a,0x40,0x1b,0x80,0x0c,0xee,0x70,0x11,0x90,0x97,0x3d,0xe0,0xc3,
+0x94,0x03,0x40,0x0d,0x90,0x95,0x43,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x95,0x43,
+0xf0,0x74,0x23,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xff,0xc3,0x94,0x30,
+0x50,0x03,0x02,0x4b,0x2d,0x90,0x95,0x43,0xe0,0x64,0x01,0x60,0x03,0x02,0x4b,0x2d,
+0x90,0x97,0x3a,0xe0,0x24,0x44,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0x64,0x0a,
+0x60,0x56,0x90,0x97,0x3a,0xe0,0xfe,0xef,0x24,0x05,0xfd,0xe4,0x33,0xfc,0x74,0x21,
+0x2e,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xff,0xd3,0x9d,0xec,0x64,0x80,0xf8,
+0x74,0x80,0x98,0x50,0x33,0xef,0x24,0x05,0xfd,0xe4,0x33,0xfc,0x74,0x23,0x2e,0xf5,
+0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xd3,0x9d,0xec,0x64,0x80,0xf8,0x74,0x80,0x98,
+0x50,0x16,0x90,0x97,0x3a,0xe0,0x24,0x84,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,
+0xff,0x90,0x97,0x3d,0xe0,0x6f,0x60,0x56,0x90,0x97,0x3a,0xe0,0x24,0x23,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xe0,0xff,0xd3,0x94,0x46,0x40,0x08,0x90,0x97,0x52,0x74,
+0x05,0xf0,0x80,0x11,0xef,0xd3,0x94,0x3c,0x90,0x97,0x52,0x40,0x05,0x74,0x03,0xf0,
+0x80,0x03,0x74,0x01,0xf0,0x90,0x97,0x3a,0xe0,0xff,0x24,0x23,0xf5,0x82,0xe4,0x34,
+0x95,0xf5,0x83,0xe0,0xfe,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xee,
+0xf0,0x90,0x97,0x3a,0xe0,0x24,0x44,0xf5,0x82,0xe4,0x34,0x95,0x80,0x2f,0x90,0x97,
+0x3a,0xe0,0xff,0x24,0x64,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0x44,
+0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0x04,0xf0,0x80,0x14,0xe4,0x90,0x97,
+0x52,0xf0,0x90,0x97,0x3a,0xe0,0x24,0x64,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,
+0xf0,0x90,0x97,0x3d,0xe0,0xff,0x90,0x97,0x3a,0xe0,0xfe,0x24,0x84,0xf5,0x82,0xe4,
+0x34,0x96,0xf5,0x83,0xef,0xf0,0xee,0x30,0xe0,0x1e,0x90,0x97,0x52,0xe0,0xc4,0x54,
+0xf0,0xf0,0x90,0x97,0x3a,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,
+0xf5,0x83,0xe0,0x54,0x0f,0x02,0x4d,0x21,0x90,0x97,0x3a,0xe0,0xc3,0x13,0xff,0x24,
+0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0xf0,0x02,0x4d,0x21,0x90,0x97,
+0x3a,0xe0,0x24,0x64,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x64,0x06,0x60,0x03,
+0x02,0x4d,0x3e,0x90,0x04,0xb3,0xe0,0x64,0x01,0x70,0x03,0x02,0x4d,0x3e,0x90,0x97,
+0x3e,0x12,0x1d,0xb5,0x00,0x00,0x00,0x00,0x90,0x42,0x13,0xe4,0x93,0xff,0x7e,0x00,
+0x90,0x97,0x46,0xe0,0xfc,0xa3,0xe0,0xfd,0x12,0x1d,0x1c,0xe4,0xfc,0xfd,0x90,0x97,
+0x42,0x12,0x1d,0xa9,0xe4,0x90,0x97,0x3b,0xf0,0x90,0x97,0x3e,0xe0,0xf8,0xa3,0xe0,
+0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,0xab,
+0x13,0xaa,0x14,0xa9,0x15,0x90,0x97,0x3b,0xe0,0xff,0x75,0xf0,0x02,0xa4,0xf5,0x82,
+0x85,0xf0,0x83,0x12,0x66,0x20,0xfd,0xac,0xf0,0xef,0x90,0x42,0x0e,0x93,0xff,0x7e,
+0x00,0x12,0x1d,0x1c,0xe4,0xfc,0xfd,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xeb,
+0x2f,0xff,0xea,0x3e,0xfe,0xed,0x39,0xfd,0xec,0x38,0xfc,0x90,0x97,0x3e,0x12,0x1d,
+0xa9,0x90,0x97,0x42,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x97,0x3e,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,0xfa,0xa3,0xe0,0xfb,0xd3,0x12,0x66,
+0xa4,0x50,0x0e,0x90,0x97,0x3b,0xe0,0x04,0xf0,0xe0,0x64,0x05,0x60,0x03,0x02,0x4b,
+0xd9,0x90,0x97,0x3b,0xe0,0xc3,0x13,0xf0,0x90,0x97,0x52,0xe0,0xff,0xb4,0x01,0x0d,
+0x90,0x97,0x3b,0xe0,0x70,0x5d,0x90,0x97,0x52,0x04,0xf0,0x80,0x5b,0xef,0xb4,0x03,
+0x1d,0x90,0x97,0x3b,0xe0,0xff,0x70,0x08,0x90,0x97,0x52,0x74,0x03,0xf0,0x80,0x48,
+0xef,0xb4,0x01,0x08,0x90,0x97,0x52,0x74,0x01,0xf0,0x80,0x3c,0x80,0x35,0x90,0x97,
+0x52,0xe0,0x64,0x05,0x70,0x32,0x90,0x97,0x3b,0xe0,0xff,0x70,0x08,0x90,0x97,0x52,
+0x74,0x05,0xf0,0x80,0x0f,0xef,0x90,0x97,0x52,0xb4,0x01,0x05,0x74,0x03,0xf0,0x80,
+0x03,0x74,0x01,0xf0,0xd3,0x90,0x97,0x49,0xe0,0x94,0x03,0x90,0x97,0x48,0xe0,0x94,
+0x00,0x40,0x05,0xe4,0x90,0x97,0x52,0xf0,0xd3,0x90,0x97,0x49,0xe0,0x94,0x03,0x90,
+0x97,0x48,0xe0,0x94,0x00,0x40,0x05,0xe4,0x90,0x97,0x52,0xf0,0x90,0x97,0x3a,0xe0,
+0xff,0x30,0xe0,0x1a,0x90,0x97,0x52,0xe0,0xc4,0x54,0xf0,0xf0,0xef,0xc3,0x13,0xff,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,0x0f,0x80,0x13,0x90,0x97,
+0x3a,0xe0,0xc3,0x13,0xff,0x24,0xa4,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,
+0xf0,0xf0,0x74,0xa4,0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xc0,0x83,0xc0,0x82,
+0xe0,0xff,0x90,0x97,0x52,0xe0,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x90,0x97,
+0x3a,0xe0,0xff,0x24,0x64,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0xd3,0x94,0x05,
+0x50,0x0f,0x74,0x64,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe0,0x04,0xf0,0x80,
+0x0f,0x90,0x97,0x3a,0xe0,0x24,0x64,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,
+0x90,0x97,0x3a,0xe0,0xff,0x24,0x84,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe0,0x54,
+0x1f,0xc3,0x94,0x09,0x50,0x05,0x90,0x92,0x00,0x80,0x11,0x74,0x84,0x2f,0xf5,0x82,
+0xe4,0x34,0x04,0xf5,0x83,0xe0,0x90,0x92,0x00,0x20,0xe2,0x05,0x74,0x08,0xf0,0x80,
+0x03,0x74,0x04,0xf0,0x90,0x97,0x3a,0xe0,0x60,0x0d,0x90,0x96,0xa4,0xe0,0xff,0x90,
+0x92,0x00,0xe0,0xc3,0x9f,0x50,0x08,0x90,0x92,0x00,0xe0,0x90,0x96,0xa4,0xf0,0x90,
+0x96,0xa4,0xe0,0x90,0x04,0x80,0xf0,0xab,0x13,0xaa,0x14,0xa9,0x15,0xe4,0xf5,0xf0,
+0x12,0x66,0x58,0xab,0x13,0xaa,0x14,0xa9,0x15,0x90,0x00,0x02,0xe4,0xf5,0xf0,0x12,
+0x66,0x77,0x90,0x00,0x04,0xe4,0xf5,0xf0,0x12,0x66,0x77,0x90,0x00,0x06,0xe4,0xf5,
+0xf0,0x12,0x66,0x77,0x90,0x00,0x08,0xe4,0xf5,0xf0,0x12,0x66,0x77,0x90,0x97,0x3a,
+0xe0,0xff,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0xf0,0xa3,
+0xf0,0xef,0x25,0xe0,0x24,0x63,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,
+0xf0,0xef,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,
+0xf0,0x90,0x97,0x3a,0xe0,0x04,0xf0,0x02,0x45,0x18,0x22,0xef,0x70,0x03,0x02,0x50,
+0xa3,0x90,0x97,0x2d,0xe0,0x60,0x03,0x02,0x54,0xe5,0x90,0x97,0x19,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x8c,
+0x7e,0x08,0x12,0x33,0xd8,0x90,0x96,0xc5,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x44,0x7e,0x08,0x12,0x33,0xd8,
+0x90,0x96,0xc9,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,
+0x56,0x12,0x1d,0xa9,0x7f,0x5c,0x7e,0x08,0x12,0x33,0xd8,0x90,0x96,0xcd,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,
+0x6c,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x96,0xd1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x70,0x7e,0x0e,0x12,0x33,
+0xd8,0x90,0x96,0xd5,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x81,0x56,0x12,0x1d,0xa9,0x7f,0x74,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x96,0xd9,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,
+0x7f,0x78,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x96,0xdd,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x7c,0x7e,0x0e,0x12,
+0x33,0xd8,0x90,0x96,0xe1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x80,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x96,0xe5,
+0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,
+0xa9,0x7f,0x84,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x96,0xe9,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x88,0x7e,0x0e,
+0x12,0x33,0xd8,0x90,0x96,0xed,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x8c,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x96,
+0xf1,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,
+0x1d,0xa9,0x7f,0xd0,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x96,0xf5,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0xd4,0x7e,
+0x0e,0x12,0x33,0xd8,0x90,0x96,0xf9,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0xd8,0x7e,0x0e,0x12,0x33,0xd8,0x90,
+0x96,0xfd,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,
+0x12,0x1d,0xa9,0x7f,0xdc,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x97,0x01,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0xe0,
+0x7e,0x0e,0x12,0x33,0xd8,0x90,0x97,0x05,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0xec,0x7e,0x0e,0x12,0x33,0xd8,
+0x90,0x97,0x09,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,
+0x56,0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x0c,0x12,0x33,0xd8,0x90,0x97,0x0d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,
+0x04,0x7e,0x0d,0x12,0x33,0xd8,0x90,0x97,0x11,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x0c,0x7e,0x09,0x12,0x33,
+0xd8,0x90,0x97,0x15,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,
+0x81,0x56,0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x08,0x12,0x33,0xd8,0x90,0x97,0x2d,0x74,
+0x01,0xf0,0x22,0x90,0x97,0x2d,0xe0,0x64,0x01,0x60,0x03,0x02,0x54,0xe5,0x7f,0x8c,
+0x7e,0x08,0x12,0x2b,0x13,0x90,0x97,0x19,0x12,0x1d,0xa9,0x7f,0x44,0x7e,0x08,0x12,
+0x2b,0x13,0x90,0x96,0xc5,0x12,0x1d,0xa9,0x7f,0x5c,0x7e,0x08,0x12,0x2b,0x13,0x90,
+0x96,0xc9,0x12,0x1d,0xa9,0x7f,0x6c,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xcd,0x12,
+0x1d,0xa9,0x7f,0x70,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xd1,0x12,0x1d,0xa9,0x7f,
+0x74,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xd5,0x12,0x1d,0xa9,0x7f,0x78,0x7e,0x0e,
+0x12,0x2b,0x13,0x90,0x96,0xd9,0x12,0x1d,0xa9,0x7f,0x7c,0x7e,0x0e,0x12,0x2b,0x13,
+0x90,0x96,0xdd,0x12,0x1d,0xa9,0x7f,0x80,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xe1,
+0x12,0x1d,0xa9,0x7f,0x84,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xe5,0x12,0x1d,0xa9,
+0x7f,0x88,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xe9,0x12,0x1d,0xa9,0x7f,0x8c,0x7e,
+0x0e,0x12,0x2b,0x13,0x90,0x96,0xed,0x12,0x1d,0xa9,0x7f,0xd0,0x7e,0x0e,0x12,0x2b,
+0x13,0x90,0x96,0xf1,0x12,0x1d,0xa9,0x7f,0xd4,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,
+0xf5,0x12,0x1d,0xa9,0x7f,0xd8,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xf9,0x12,0x1d,
+0xa9,0x7f,0xdc,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x96,0xfd,0x12,0x1d,0xa9,0x7f,0xe0,
+0x7e,0x0e,0x12,0x2b,0x13,0x90,0x97,0x01,0x12,0x1d,0xa9,0x7f,0xec,0x7e,0x0e,0x12,
+0x2b,0x13,0x90,0x97,0x05,0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x0c,0x12,0x2b,0x13,0x90,
+0x97,0x09,0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x0d,0x12,0x2b,0x13,0x90,0x97,0x0d,0x12,
+0x1d,0xa9,0x7f,0x0c,0x7e,0x09,0x12,0x2b,0x13,0x90,0x97,0x11,0x12,0x1d,0xa9,0x7f,
+0x04,0x7e,0x08,0x12,0x2b,0x13,0x90,0x97,0x15,0x12,0x1d,0xa9,0x7f,0x8c,0x7e,0x08,
+0x12,0x2b,0x13,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x44,0xc0,0xfd,0xec,0x90,0x97,0xa3,0x12,
+0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,
+0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x8c,0x7e,0x08,0x12,0x33,0xd8,0x90,0x81,0x56,
+0x12,0x1d,0xb5,0x00,0x01,0x00,0x00,0x7f,0x44,0x7e,0x08,0x12,0x33,0xd8,0x90,0x81,
+0x56,0x12,0x1d,0xb5,0x00,0xdb,0x25,0xa4,0x7f,0x5c,0x7e,0x08,0x12,0x33,0xd8,0x90,
+0x81,0x56,0x12,0x1d,0xb5,0x20,0xdb,0x25,0xa4,0x7f,0x6c,0x7e,0x0e,0x12,0x33,0xd8,
+0x90,0x81,0x56,0x12,0x1d,0xb5,0x20,0xdb,0x25,0xa4,0x7f,0x70,0x7e,0x0e,0x12,0x33,
+0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x04,0x1b,0x25,0xa4,0x7f,0x74,0x7e,0x0e,0x12,
+0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x04,0x1b,0x25,0xa4,0x7f,0x78,0x7e,0x0e,
+0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x04,0x1b,0x25,0xa4,0x7f,0x7c,0x7e,
+0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x04,0x1b,0x25,0xa4,0x7f,0x80,
+0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x63,0xdb,0x25,0xa4,0x7f,
+0x84,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x04,0x1b,0x25,0xa4,
+0x7f,0x88,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x20,0xdb,0x25,
+0xa4,0x7f,0x8c,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x20,0xdb,
+0x25,0xa4,0x7f,0xd0,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,0x20,
+0xdb,0x25,0xa4,0x7f,0xd4,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,0xb5,
+0x20,0xdb,0x25,0xa4,0x7f,0xd8,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,0x1d,
+0xb5,0x00,0x1b,0x25,0xa4,0x7f,0xdc,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,0x12,
+0x1d,0xb5,0x00,0x1b,0x25,0xa4,0x7f,0xe0,0x7e,0x0e,0x12,0x33,0xd8,0x90,0x81,0x56,
+0x12,0x1d,0xb5,0x24,0xdb,0x25,0xa4,0x7f,0xec,0x7e,0x0e,0x12,0x33,0xd8,0x7f,0x04,
+0x7e,0x0c,0x12,0x2b,0x13,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xe4,0xff,0xec,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,
+0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x11,0xff,0xec,
+0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x0c,0x12,0x33,
+0xd8,0x7f,0x04,0x7e,0x0d,0x12,0x2b,0x13,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,
+0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xf0,0xff,0xec,0x90,
+0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0x44,0x01,0xff,0xec,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,
+0x7f,0x04,0x7e,0x0d,0x12,0x33,0xd8,0x7f,0x0c,0x7e,0x09,0x12,0x2b,0x13,0x90,0x97,
+0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xe4,
+0xff,0xec,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x11,0xff,0xec,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,
+0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,
+0x12,0x1d,0xa9,0x7f,0x0c,0x7e,0x09,0x12,0x33,0xd8,0x7f,0x0c,0x7e,0x09,0x12,0x2b,
+0x13,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0xff,0xed,0x54,0x0f,0xfd,0xec,0x54,0xf0,0xfc,0x90,0x97,0xa3,
+0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0xed,0x44,0x10,0xfd,0xec,0x44,0x01,0xfc,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,
+0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,
+0x12,0x1d,0xa9,0x7f,0x0c,0x7e,0x09,0x12,0x33,0xd8,0x7f,0x04,0x7e,0x08,0x12,0x2b,
+0x13,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0x54,0xf0,0xff,0xec,0x90,0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,
+0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x44,0x01,0xff,0xec,0x90,
+0x97,0xa3,0x12,0x1d,0xa9,0x90,0x97,0xa3,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x08,0x12,0x33,0xd8,
+0xe4,0x90,0x97,0x2d,0xf0,0x22,0x8f,0x10,0xef,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,
+0x34,0x95,0xaf,0x82,0xf5,0x11,0x8f,0x12,0xe5,0x10,0x75,0xf0,0x02,0xa4,0x24,0x81,
+0xf9,0x74,0x92,0x35,0xf0,0x75,0x13,0x01,0xf5,0x14,0x89,0x15,0xe5,0x10,0x75,0xf0,
+0x08,0xa4,0x24,0x65,0xf5,0x82,0xe4,0x34,0x93,0xaf,0x82,0xf5,0x16,0x8f,0x17,0xe5,
+0x10,0x75,0xf0,0x08,0xa4,0x24,0x63,0xf9,0x74,0x93,0x35,0xf0,0x75,0x18,0x01,0xf5,
+0x19,0x89,0x1a,0x74,0xc1,0x25,0x10,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x12,
+0x66,0xc1,0x55,0x67,0x00,0x55,0x7c,0x01,0x55,0x91,0x02,0x55,0xa6,0x03,0x55,0xd0,
+0x04,0x55,0xe5,0x05,0x55,0xfa,0x06,0x56,0x21,0x0c,0x56,0x4f,0x0d,0x56,0x7c,0x0e,
+0x56,0xa9,0x0f,0x00,0x00,0x56,0xdd,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,
+0x34,0x95,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x15,0x80,0x3c,0xe5,0x10,0x25,0xe0,
+0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0x74,0x10,0x80,
+0x27,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0x74,0xf0,
+0xf0,0xa3,0x74,0x05,0x80,0x12,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,
+0x95,0xf5,0x83,0x74,0xf0,0xf0,0xa3,0xe4,0xf0,0xe5,0x10,0x25,0xe0,0x24,0x81,0xf5,
+0x82,0xe4,0x34,0x92,0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0x8f,0xf0,0x02,0x56,0xdd,
+0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0x74,0x0f,0xf0,
+0xa3,0x74,0xf5,0x80,0x27,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,
+0xf5,0x83,0x74,0x0f,0xf0,0xa3,0x74,0xf0,0x80,0x12,0xe5,0x10,0x25,0xe0,0x24,0xe4,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0x74,0x0d,0xf0,0xe5,0x10,0x25,
+0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x02,0x56,
+0xdd,0x90,0x04,0x47,0xe0,0xab,0x13,0xaa,0x14,0xa9,0x15,0x12,0x65,0x95,0x90,0x04,
+0x46,0xe0,0xab,0x13,0xaa,0x14,0xa9,0x15,0x90,0x00,0x01,0x12,0x65,0xa7,0x90,0x04,
+0x45,0xe0,0x85,0x12,0x82,0x85,0x11,0x83,0xf0,0x90,0x04,0x44,0x02,0x56,0xd4,0x90,
+0x04,0x4b,0xe0,0xab,0x13,0xaa,0x14,0xa9,0x15,0x12,0x65,0x95,0x90,0x04,0x4a,0xe0,
+0xab,0x13,0xaa,0x14,0xa9,0x15,0x90,0x00,0x01,0x12,0x65,0xa7,0x90,0x04,0x49,0xe0,
+0x85,0x12,0x82,0x85,0x11,0x83,0xf0,0x90,0x04,0x48,0x80,0x58,0x90,0x04,0x4f,0xe0,
+0xab,0x13,0xaa,0x14,0xa9,0x15,0x12,0x65,0x95,0x90,0x04,0x4e,0xe0,0xab,0x13,0xaa,
+0x14,0xa9,0x15,0x90,0x00,0x01,0x12,0x65,0xa7,0x90,0x04,0x4d,0xe0,0x85,0x12,0x82,
+0x85,0x11,0x83,0xf0,0x90,0x04,0x4c,0x80,0x2b,0x90,0x04,0x53,0xe0,0xab,0x13,0xaa,
+0x14,0xa9,0x15,0x12,0x65,0x95,0x90,0x04,0x52,0xe0,0xab,0x13,0xaa,0x14,0xa9,0x15,
+0x90,0x00,0x01,0x12,0x65,0xa7,0x90,0x04,0x51,0xe0,0x85,0x12,0x82,0x85,0x11,0x83,
+0xf0,0x90,0x04,0x50,0xe0,0x85,0x12,0x82,0x85,0x11,0x83,0xa3,0xf0,0xab,0x13,0xaa,
+0x14,0xa9,0x15,0xc0,0x03,0xc0,0x02,0xc0,0x01,0x12,0x1c,0xd6,0xff,0xab,0x18,0xaa,
+0x19,0xa9,0x1a,0x12,0x1c,0xd6,0x5f,0xd0,0x01,0xd0,0x02,0xd0,0x03,0x12,0x65,0x95,
+0xab,0x13,0xe5,0x15,0x24,0x01,0xf9,0xe4,0x35,0x14,0xfa,0xc0,0x03,0xc0,0x02,0xc0,
+0x01,0x12,0x1c,0xd6,0xff,0xab,0x18,0xaa,0x19,0xa9,0x1a,0x90,0x00,0x01,0x12,0x1c,
+0xef,0x5f,0xd0,0x01,0xd0,0x02,0xd0,0x03,0x12,0x65,0x95,0x85,0x12,0x82,0x85,0x11,
+0x83,0xc0,0x83,0xc0,0x82,0xe0,0xff,0x85,0x17,0x82,0x85,0x16,0x83,0xe0,0xfe,0xef,
+0x5e,0xd0,0x82,0xd0,0x83,0xf0,0x85,0x12,0x82,0x85,0x11,0x83,0xa3,0xc0,0x83,0xc0,
+0x82,0xe0,0xff,0x85,0x17,0x82,0x85,0x16,0x83,0xa3,0xe0,0xfe,0xef,0x5e,0xd0,0x82,
+0xd0,0x83,0xf0,0xe5,0x10,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x4c,0x90,0x97,0x51,0x74,0x0b,0xf0,0x90,0x97,0x51,
+0xe0,0xff,0xc3,0x94,0x00,0x50,0x03,0x02,0x58,0x23,0x74,0x01,0x7e,0x00,0xa8,0x07,
+0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x10,0x25,0xe0,0x24,
+0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,
+0x0a,0x90,0x97,0x51,0xe0,0x24,0x10,0xa3,0xf0,0x80,0x68,0x90,0x97,0x51,0xe0,0x14,
+0xf0,0x80,0xba,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0x90,0x97,0x51,0x74,0x0f,0xf0,0x90,0x97,0x51,
+0xe0,0xff,0xc3,0x94,0x00,0x40,0x3c,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,
+0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x08,0x90,0x97,
+0x51,0xe0,0xa3,0xf0,0x80,0x0d,0x90,0x97,0x51,0xe0,0x14,0xf0,0x80,0xbf,0xe4,0x90,
+0x97,0x52,0xf0,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,
+0xe0,0xfe,0xa3,0xe0,0x4e,0x60,0x47,0xe4,0x90,0x97,0x51,0xf0,0x90,0x97,0x51,0xe0,
+0xff,0xc3,0x94,0x10,0x40,0x03,0x02,0x58,0xdd,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,
+0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xe5,0x10,0x25,0xe0,0x24,0xe4,
+0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x06,
+0x90,0x97,0x51,0xe0,0x80,0x63,0x90,0x97,0x51,0xe0,0x04,0xf0,0x80,0xbe,0xe5,0x10,
+0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x4e,
+0x60,0x46,0xe4,0x90,0x97,0x51,0xf0,0x90,0x97,0x51,0xe0,0xff,0xc3,0x94,0x0c,0x50,
+0x3c,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,
+0xf9,0xff,0xe5,0x10,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,
+0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x08,0x90,0x97,0x51,0xe0,0x24,0x10,0x80,0x09,
+0x90,0x97,0x51,0xe0,0x04,0xf0,0x80,0xbf,0xe4,0x90,0x97,0x53,0xf0,0x90,0x97,0x52,
+0xe0,0xff,0xe5,0x10,0x75,0xf0,0x08,0xa4,0x24,0x67,0xf5,0x82,0xe4,0x34,0x93,0xf5,
+0x83,0xef,0xf0,0x90,0x97,0x53,0xe0,0xfe,0xe5,0x10,0x75,0xf0,0x08,0xa4,0x24,0x68,
+0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0xee,0xf0,0x74,0x84,0x25,0x10,0xf5,0x82,0xe4,
+0x34,0x04,0xf5,0x83,0xe0,0xd3,0x9f,0x40,0x1f,0x90,0x97,0x52,0xe0,0xff,0x74,0x84,
+0x25,0x10,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xef,0xf0,0x74,0x84,0x25,0x10,0xf5,
+0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,0xf0,0x90,0x97,0x52,0xe0,0xff,0xd3,0x94,0x13,
+0x40,0x08,0x90,0x93,0x62,0x74,0x03,0xf0,0x80,0x21,0xef,0xd3,0x94,0x0b,0x40,0x08,
+0x90,0x93,0x62,0x74,0x02,0xf0,0x80,0x13,0xef,0xd3,0x94,0x03,0x40,0x08,0x90,0x93,
+0x62,0x74,0x01,0xf0,0x80,0x05,0xe4,0x90,0x93,0x62,0xf0,0x90,0x93,0x62,0xe0,0x90,
+0x04,0xb1,0xf0,0xe5,0x10,0x25,0xe0,0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,
+0xe0,0xff,0xa3,0xe0,0x90,0x04,0x9c,0xcf,0xf0,0xa3,0xef,0xf0,0xe5,0x10,0x25,0xe0,
+0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,0x04,0x9e,
+0xcf,0xf0,0xa3,0xef,0xf0,0xe5,0x10,0x75,0xf0,0x08,0xa4,0x24,0x69,0xf5,0x82,0xe4,
+0x34,0x93,0xf5,0x83,0xe0,0xc4,0x33,0x54,0xe0,0x45,0x10,0x90,0x04,0xa0,0xf0,0x74,
+0xc1,0x25,0x10,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0xe0,0x90,0x04,0xa1,0xf0,0x22,
+0xc0,0xe0,0xc0,0xf0,0xc0,0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,
+0x01,0xc0,0x02,0xc0,0x03,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,
+0x74,0xd0,0xf0,0x74,0x59,0xa3,0xf0,0x90,0x01,0x37,0xe0,0x55,0x2b,0xf5,0x2f,0x90,
+0x01,0x34,0xe0,0x55,0x28,0xf5,0x2c,0x90,0x01,0x36,0xe0,0x55,0x2a,0xf5,0x2e,0xe5,
+0x2c,0x20,0xe0,0x03,0x02,0x5b,0x82,0x90,0x01,0x34,0x74,0x01,0xf0,0x85,0xd1,0x4d,
+0x85,0xd2,0x4e,0x85,0xd3,0x4f,0x85,0xd4,0x50,0x85,0xd5,0x51,0x85,0xd6,0x52,0x85,
+0xd7,0x53,0x85,0xd9,0x54,0xe5,0x54,0x54,0x40,0xc3,0x13,0xff,0xe5,0x53,0x54,0x20,
+0x6f,0x70,0x03,0x02,0x5b,0x2f,0xe5,0x54,0x30,0xe5,0x03,0x02,0x5b,0x2f,0xe5,0x52,
+0x54,0x1f,0xf5,0x08,0xe5,0x4d,0x54,0x3f,0xf5,0x09,0xe5,0x51,0x54,0x1f,0xff,0xe5,
+0x08,0x25,0xe0,0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,0xf0,0x12,
+0x65,0xc9,0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0xc0,0xf5,0x82,0xe4,
+0x34,0x91,0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x65,0xc9,0xe5,0x09,0xd3,0x94,0x04,0x40,
+0x03,0x75,0x09,0x04,0x75,0xf0,0x0a,0xe5,0x08,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,
+0x34,0x90,0xf5,0x83,0x75,0xf0,0x02,0xe5,0x09,0x12,0x66,0xb5,0xe0,0xfe,0xa3,0xe0,
+0xff,0xe5,0x53,0x54,0x1f,0x2f,0xff,0xe4,0x3e,0xfe,0x75,0xf0,0x0a,0xe5,0x08,0xa4,
+0x24,0x00,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0x75,0xf0,0x02,0xe5,0x09,0x12,
+0x66,0xb5,0xee,0xf0,0xa3,0xef,0xf0,0xe5,0x54,0x20,0xe6,0x24,0xe5,0x53,0x54,0x1f,
+0xff,0xe5,0x08,0x25,0xe0,0x24,0x63,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0x8f,
+0xf0,0x12,0x65,0xc9,0xe5,0x4f,0x30,0xe7,0x36,0xaf,0x08,0x12,0x75,0x4c,0x80,0x2f,
+0xe5,0x53,0x54,0x1f,0xff,0xe5,0x08,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,
+0xf5,0x83,0xe4,0x8f,0xf0,0x12,0x65,0xc9,0xe5,0x4f,0x30,0xe7,0x12,0xe5,0x4f,0x54,
+0x7f,0xfd,0xe5,0x53,0x54,0x1f,0xf5,0x0d,0xab,0x09,0xaf,0x08,0x12,0x76,0x52,0xe5,
+0x65,0x60,0x4f,0x90,0x97,0x8d,0xe0,0x60,0x35,0x90,0x01,0x5b,0xe4,0xf0,0x90,0x01,
+0x3c,0x74,0x04,0xf0,0x90,0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x34,0x75,0x48,
+0x14,0xf5,0x49,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x38,0xec,0x90,0x01,0x5b,0x74,
+0x05,0xf0,0x90,0x06,0x92,0x74,0x01,0xf0,0x90,0x97,0x87,0xf0,0x80,0x14,0x90,0x04,
+0x1b,0xe0,0x54,0x7f,0xff,0xbf,0x7f,0x0a,0x90,0x97,0x8b,0xe0,0xff,0x7d,0x01,0x12,
+0x6e,0xda,0xe5,0x2c,0x30,0xe1,0x21,0x90,0x01,0x34,0x74,0x02,0xf0,0x85,0xd1,0x56,
+0x85,0xd2,0x57,0x85,0xd3,0x58,0x85,0xd4,0x59,0x85,0xd5,0x5a,0x85,0xd6,0x5b,0x85,
+0xd7,0x5c,0x85,0xd9,0x5d,0x12,0x7d,0xc4,0xe5,0x2c,0x30,0xe3,0x06,0x90,0x01,0x34,
+0x74,0x08,0xf0,0xe5,0x2c,0x30,0xe4,0x09,0x90,0x01,0x34,0x74,0x10,0xf0,0x43,0x55,
+0x10,0xe5,0x2c,0x30,0xe5,0x21,0x90,0x01,0xcf,0xe0,0x30,0xe5,0x1a,0xe0,0x54,0xdf,
+0xf0,0x90,0x01,0x34,0x74,0x20,0xf0,0x90,0x00,0x03,0xe0,0x54,0xfb,0xf0,0x7f,0x10,
+0x7e,0x00,0x12,0x3a,0xa8,0x80,0xfe,0xe5,0x2c,0x30,0xe6,0x06,0x90,0x01,0x34,0x74,
+0x40,0xf0,0xe5,0x2e,0x30,0xe1,0x09,0x90,0x01,0x36,0x74,0x02,0xf0,0x43,0x55,0x40,
+0xe5,0x2e,0x30,0xe0,0x09,0x90,0x01,0x36,0x74,0x01,0xf0,0x12,0x76,0xd3,0xe5,0x2e,
+0x30,0xe2,0x63,0x90,0x01,0x36,0x74,0x04,0xf0,0xe5,0x64,0x64,0x01,0x70,0x57,0xe5,
+0x65,0x60,0x53,0xe5,0x65,0x64,0x02,0x70,0x27,0x90,0x06,0xab,0xe0,0x90,0x97,0x7f,
+0xf0,0x90,0x06,0xaa,0xe0,0x90,0x97,0x8a,0xf0,0x90,0x97,0x7f,0xe0,0x70,0x07,0x90,
+0x97,0x8a,0xe0,0xff,0x80,0x05,0x90,0x97,0x7f,0xe0,0xff,0x90,0x97,0x7f,0xef,0xf0,
+0x90,0x97,0x81,0xe0,0x60,0x03,0xe0,0x14,0xf0,0x90,0x97,0x80,0xe4,0xf0,0x90,0x01,
+0x57,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0x8f,0xe0,0x54,0xfd,0xf0,0xe0,
+0x54,0xef,0xf0,0x12,0x77,0x49,0xe5,0x2e,0x30,0xe3,0x31,0x90,0x01,0x36,0x74,0x08,
+0xf0,0xe5,0x64,0x64,0x01,0x70,0x25,0xe5,0x65,0x60,0x21,0x90,0x01,0x57,0xe4,0xf0,
+0x90,0x01,0x3c,0x74,0x02,0xf0,0x75,0x48,0x03,0x75,0x49,0x00,0xe4,0xfb,0xfd,0x7f,
+0x54,0x7e,0x01,0x12,0x38,0xec,0x90,0x01,0x57,0x74,0x05,0xf0,0xe5,0x2e,0x30,0xe4,
+0x3a,0x90,0x01,0x36,0x74,0x10,0xf0,0xe5,0x64,0x64,0x01,0x70,0x2e,0xe5,0x65,0x60,
+0x2a,0x90,0x01,0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x90,0x97,0x8e,0xe4,
+0xf0,0x90,0x97,0x8f,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0x03,0x70,0x0e,0x90,0x97,0x89,
+0xf0,0x90,0x97,0x8b,0xe0,0xff,0x7d,0x01,0x12,0x6e,0xda,0xe5,0x2e,0x30,0xe5,0x12,
+0x90,0x01,0x36,0x74,0x20,0xf0,0xe5,0x64,0xb4,0x01,0x07,0xe5,0x65,0x60,0x03,0x12,
+0x7e,0x7e,0xe5,0x2e,0x30,0xe6,0x2a,0x90,0x01,0x36,0x74,0x40,0xf0,0xe5,0x64,0x64,
+0x01,0x70,0x1e,0xe5,0x65,0x60,0x1a,0x90,0x97,0x8f,0xe0,0x54,0xfe,0xf0,0xe0,0x54,
+0x03,0x70,0x0e,0x90,0x97,0x89,0xf0,0x90,0x97,0x8b,0xe0,0xff,0x7d,0x01,0x12,0x6e,
+0xda,0xe5,0x2f,0x30,0xe1,0x09,0x90,0x01,0x37,0x74,0x02,0xf0,0x12,0x7c,0xe8,0x74,
+0xd0,0x04,0x90,0x01,0xc4,0xf0,0x74,0x59,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,
+0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,
+0xd0,0xf0,0xd0,0xe0,0x32,0x74,0x5d,0x90,0x01,0xc4,0xf0,0xa3,0x74,0x65,0xf0,0x90,
+0x04,0x44,0x74,0x11,0xf0,0xa3,0x74,0xf0,0xf0,0xa3,0x74,0x0f,0xf0,0xa3,0xe4,0xf0,
+0x90,0x97,0x3a,0xf0,0x90,0x97,0x3a,0xe0,0xff,0xc3,0x94,0x10,0x50,0x14,0x74,0xa4,
+0x2f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xe4,0xf0,0x90,0x97,0x3a,0xe0,0x04,0xf0,
+0x80,0xe2,0xe4,0x90,0x97,0x3a,0xf0,0x90,0x97,0x3a,0xe0,0xfb,0xc3,0x94,0x20,0x40,
+0x03,0x02,0x5f,0x6c,0xe0,0xff,0x75,0xf0,0x0a,0xa4,0x24,0x00,0xf5,0x82,0xe5,0xf0,
+0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x02,0xf5,
+0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,0x0a,0xef,0xa4,
+0x24,0x04,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x75,0xf0,
+0x0a,0xef,0xa4,0x24,0x06,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,0xe4,0xf0,0xa3,
+0xf0,0x75,0xf0,0x0a,0xef,0xa4,0x24,0x08,0xf5,0x82,0xe5,0xf0,0x34,0x90,0xf5,0x83,
+0xe4,0xf0,0xa3,0xf0,0x74,0x84,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0x74,0x13,
+0xf0,0x74,0x44,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xef,0x25,0xe0,
+0x24,0xc0,0xf5,0x82,0xe4,0x34,0x91,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,
+0x24,0x63,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,
+0x24,0xe3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,
+0x24,0xa3,0xf5,0x82,0xe4,0x34,0x94,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,
+0x24,0x64,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0xef,0x25,0xe0,
+0x24,0xa4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe4,0xf0,0xa3,0xf0,0x74,0x44,0x2f,
+0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,0xf0,0x74,0x24,0x2f,0xf5,0x82,0xe4,0x34,
+0x96,0xf5,0x83,0xe4,0xf0,0x74,0x64,0x2f,0xf5,0x82,0xe4,0x34,0x96,0xf5,0x83,0xe4,
+0xf0,0x90,0x41,0xc4,0x93,0xfe,0x74,0x01,0x93,0xff,0x90,0x41,0x8c,0x74,0x01,0x93,
+0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xeb,0x25,
+0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x1d,0xa9,0xeb,
+0x75,0xf0,0x08,0xa4,0x24,0x6a,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,
+0xeb,0x75,0xf0,0x08,0xa4,0x24,0x69,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0x74,0x01,
+0xf0,0x74,0xc1,0x2b,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x74,0x0c,0xf0,0xeb,0x75,
+0xf0,0x08,0xa4,0x24,0x65,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0x74,0xff,0xf0,0xa3,
+0xf0,0xeb,0x75,0xf0,0x08,0xa4,0x24,0x63,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0xe4,
+0xf0,0xa3,0x74,0x0f,0xf0,0xeb,0x75,0xf0,0x08,0xa4,0x24,0x67,0xf5,0x82,0xe4,0x34,
+0x93,0xf5,0x83,0x74,0x13,0xf0,0xeb,0x75,0xf0,0x08,0xa4,0x24,0x68,0xf5,0x82,0xe4,
+0x34,0x93,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x2b,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,
+0x74,0x13,0xf0,0x90,0x97,0x3a,0xe0,0x04,0xf0,0x02,0x5d,0xa7,0x22,0x8f,0x17,0x74,
+0x5f,0x90,0x01,0xc4,0xf0,0xa3,0x74,0x6d,0xf0,0x74,0x84,0x25,0x17,0xf5,0x82,0xe4,
+0x34,0x04,0xf5,0x83,0xe0,0x54,0x7f,0x90,0x97,0x54,0xf0,0xe0,0x54,0x1f,0xff,0x90,
+0x97,0x57,0xf0,0xe5,0x17,0x75,0xf0,0x08,0xa4,0x24,0x68,0xf5,0x82,0xe4,0x34,0x93,
+0xf5,0x83,0xe0,0x90,0x97,0x59,0xf0,0xe5,0x17,0x75,0xf0,0x08,0xa4,0x24,0x67,0xf5,
+0x82,0xe4,0x34,0x93,0xf5,0x83,0xe0,0xfe,0x90,0x97,0x5a,0xf0,0xe5,0x17,0x25,0xe0,
+0x24,0xe4,0xf5,0x82,0xe4,0x34,0x95,0xf5,0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x5b,
+0xcb,0xf0,0xa3,0xeb,0xf0,0xe5,0x17,0x25,0xe0,0x24,0x81,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0xe0,0xfb,0xa3,0xe0,0x90,0x97,0x5d,0xcb,0xf0,0xa3,0xeb,0xf0,0xef,0xd3,
+0x9e,0x40,0x0c,0x90,0x97,0x5a,0xe0,0x90,0x97,0x57,0xf0,0x90,0x97,0x54,0xf0,0xed,
+0x70,0x03,0x02,0x60,0xd9,0x90,0x97,0x58,0xed,0xf0,0x90,0x97,0x54,0xe0,0x30,0xe6,
+0x0e,0x90,0x97,0x57,0xe0,0x90,0x97,0x54,0xf0,0x90,0x97,0x58,0xe0,0x14,0xf0,0x90,
+0x97,0x58,0xe0,0x70,0x03,0x02,0x60,0xd9,0x90,0x97,0x57,0xe0,0xff,0xd3,0x94,0x00,
+0x50,0x03,0x02,0x60,0xd9,0xe4,0x90,0x97,0x56,0xf0,0xef,0x14,0x90,0x97,0x55,0xf0,
+0x90,0x97,0x59,0xe0,0xfd,0x90,0x97,0x55,0xe0,0xff,0xd3,0x9d,0x40,0x6f,0xef,0x94,
+0x10,0x40,0x21,0xef,0x24,0xf0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,
+0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x97,0x5d,0xe0,0x5e,0xfe,0xa3,0xe0,
+0x5f,0x4e,0x70,0x27,0x90,0x97,0x55,0xe0,0xff,0xc3,0x94,0x10,0x50,0x37,0x74,0x01,
+0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,
+0x97,0x5b,0xe0,0x5e,0xfe,0xa3,0xe0,0x5f,0x4e,0x60,0x1a,0x90,0x97,0x55,0xe0,0x90,
+0x97,0x54,0xf0,0x90,0x97,0x56,0xe0,0x04,0xf0,0x90,0x97,0x58,0xe0,0xff,0x90,0x97,
+0x56,0xe0,0x6f,0x60,0x08,0x90,0x97,0x55,0xe0,0x14,0xf0,0x80,0x83,0x90,0x97,0x58,
+0xe0,0xff,0x90,0x97,0x56,0xe0,0xc3,0x9f,0x50,0x0f,0x90,0x97,0x55,0xe0,0xb5,0x05,
+0x08,0x90,0x97,0x59,0xe0,0x90,0x97,0x54,0xf0,0x90,0x97,0x54,0xe0,0xff,0x25,0xe0,
+0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfc,0x74,0x01,0x93,0xfd,
+0xef,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,0x2d,
+0xff,0xe4,0x93,0x3c,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xe5,0x17,0x25,
+0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x1d,0xa9,0x90,
+0x97,0x54,0xe0,0xff,0x74,0x84,0x25,0x17,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xef,
+0xf0,0x22,0x90,0x01,0xc4,0x74,0x32,0xf0,0x74,0x61,0xa3,0xf0,0x90,0x01,0xcc,0xe0,
+0x54,0x0f,0x90,0x97,0x3a,0xf0,0x90,0x97,0x3a,0xe0,0xfd,0x70,0x03,0x02,0x62,0xd2,
+0x90,0x97,0xb1,0xe0,0xff,0x74,0x01,0x7e,0x00,0xa8,0x07,0x08,0x80,0x05,0xc3,0x33,
+0xce,0x33,0xce,0xd8,0xf9,0xff,0xef,0x5d,0x70,0x03,0x02,0x62,0xb3,0x90,0x97,0xb1,
+0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd0,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,
+0x90,0x97,0x3b,0xf0,0xa2,0xaf,0xe4,0x33,0xa3,0xf0,0xc2,0xaf,0x75,0x24,0x01,0x75,
+0x25,0x97,0x75,0x26,0x3b,0x75,0x27,0x01,0x7b,0x01,0x7a,0x97,0x79,0x3d,0x12,0x79,
+0x27,0x90,0x97,0x3c,0xe0,0x24,0xff,0x92,0xaf,0xa3,0xe0,0xff,0xc4,0x13,0x13,0x13,
+0x54,0x01,0x90,0x97,0xb1,0x30,0xe0,0x70,0xe0,0x75,0xf0,0x02,0xa4,0x24,0x88,0xf5,
+0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,0x97,0x3e,0xf0,0x90,0x97,0xb1,0xe0,0x75,
+0xf0,0x02,0xa4,0x24,0x89,0xf5,0x82,0xe4,0x35,0xf0,0xf5,0x83,0xe0,0x90,0x97,0x3f,
+0xf0,0x90,0x97,0xb1,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd1,0xf5,0x82,0xe5,0xf0,0x34,
+0x01,0xf5,0x83,0xe0,0x90,0x97,0x40,0xf0,0x90,0x97,0xb1,0xe0,0x75,0xf0,0x04,0xa4,
+0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x41,0xf0,0x90,
+0x97,0xb1,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,
+0x83,0xe0,0x90,0x97,0x42,0xf0,0x80,0x42,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd1,0xf5,
+0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x3e,0xf0,0x90,0x97,0xb1,0xe0,
+0x75,0xf0,0x04,0xa4,0x24,0xd2,0xf5,0x82,0xe5,0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,
+0x97,0x3f,0xf0,0x90,0x97,0xb1,0xe0,0x75,0xf0,0x04,0xa4,0x24,0xd3,0xf5,0x82,0xe5,
+0xf0,0x34,0x01,0xf5,0x83,0xe0,0x90,0x97,0x40,0xf0,0xef,0x54,0x7f,0xff,0x7b,0x01,
+0x7a,0x97,0x79,0x3e,0x12,0x6e,0x02,0x90,0x97,0x3a,0xe0,0xff,0x90,0x97,0xb1,0xe0,
+0xfe,0x74,0x01,0xa8,0x06,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0x5f,0x90,0x97,
+0x3a,0xf0,0x90,0x97,0xb1,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,
+0xd8,0xfc,0x90,0x01,0xcc,0xf0,0x90,0x97,0xb1,0xe0,0x04,0xf0,0xe0,0x54,0x03,0xf0,
+0x02,0x61,0x46,0xc2,0xaf,0x74,0x32,0x04,0x90,0x01,0xc4,0xf0,0x74,0x61,0xa3,0xf0,
+0x90,0x97,0x3a,0xe0,0x90,0x01,0xc6,0xf0,0x90,0x97,0xb1,0xe0,0x90,0x01,0xc7,0xf0,
+0x80,0xfe,0x22,0xe4,0x90,0x97,0x37,0xf0,0xa3,0xf0,0x12,0x7a,0x6c,0x90,0x00,0x02,
+0xe0,0x54,0xe0,0x90,0x97,0x96,0x60,0x05,0x74,0x01,0xf0,0x80,0x03,0x74,0x02,0xf0,
+0x90,0x00,0xf3,0xe0,0x30,0xe3,0x08,0x90,0x97,0x97,0x74,0x01,0xf0,0x80,0x05,0xe4,
+0x90,0x97,0x97,0xf0,0x90,0x97,0x97,0xe0,0xb4,0x01,0x13,0x90,0x00,0xf2,0xe0,0x30,
+0xe7,0x0c,0x90,0x97,0x90,0x74,0xfd,0xf0,0xa3,0x74,0x33,0xf0,0x80,0x0a,0x90,0x97,
+0x90,0x74,0xfd,0xf0,0xa3,0x74,0x2f,0xf0,0xe4,0xf5,0x55,0x12,0x5d,0x65,0x12,0x7f,
+0x60,0x12,0x79,0xce,0x12,0x36,0xd1,0x12,0x44,0xff,0x75,0x28,0x33,0xe4,0xf5,0x29,
+0x75,0x2a,0x02,0xf5,0x2b,0x90,0x01,0x30,0xe5,0x28,0xf0,0xa3,0xe5,0x29,0xf0,0xa3,
+0xe5,0x2a,0xf0,0xa3,0xe5,0x2b,0xf0,0x90,0x00,0xf3,0xe0,0x30,0xe2,0x0d,0x90,0x05,
+0x41,0x74,0x10,0xf0,0x90,0x05,0x5a,0xf0,0xa3,0xe4,0xf0,0x90,0x01,0x64,0x74,0xa0,
+0xf0,0x75,0x48,0xff,0xe4,0xf5,0x49,0xfb,0x7d,0x01,0x7f,0x50,0x7e,0x01,0x12,0x38,
+0xec,0x75,0x30,0x1f,0x75,0x31,0x01,0xe4,0xf5,0x32,0x90,0x01,0x38,0xe5,0x30,0xf0,
+0xa3,0xe5,0x31,0xf0,0xa3,0xe5,0x32,0xf0,0x12,0x78,0xd0,0x90,0x97,0x39,0xe5,0xd9,
+0xf0,0x90,0x01,0x3c,0x74,0xff,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x01,0x34,0xf0,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0xc2,0xaf,0x90,0x00,0x80,0xe0,0x44,0x40,0xf0,0x7f,0x10,
+0x7e,0x00,0x12,0x3a,0xa8,0x75,0xe8,0x03,0x43,0xa8,0x85,0xd2,0xaf,0x90,0x01,0xc0,
+0xe4,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x01,0xc6,0xf0,0xa3,0xf0,0x90,0x97,
+0x37,0xe0,0x64,0x01,0xf0,0x24,0xd3,0x90,0x01,0xc4,0xf0,0x74,0x62,0xa3,0xf0,0xe5,
+0x55,0x30,0xe6,0x17,0xc2,0xaf,0x53,0x55,0xbf,0xd2,0xaf,0x12,0x45,0x09,0x90,0x97,
+0x6d,0xe0,0xff,0x60,0x03,0xb4,0x01,0x03,0x12,0x6a,0x1f,0xe5,0x55,0x30,0xe7,0x07,
+0xc2,0xaf,0x53,0x55,0x7f,0xd2,0xaf,0xe5,0x55,0x30,0xe4,0x0a,0xc2,0xaf,0x53,0x55,
+0xef,0xd2,0xaf,0x12,0x61,0x32,0x90,0x97,0x6d,0xe0,0x70,0x03,0x12,0x6d,0x29,0x12,
+0x7d,0x45,0x80,0xaa,0x90,0x00,0x02,0x12,0x1c,0xef,0x90,0x97,0x6b,0xf0,0x90,0x00,
+0x01,0x12,0x1c,0xef,0x25,0xe0,0x25,0xe0,0x90,0x97,0x6a,0xf0,0x12,0x1c,0xd6,0x25,
+0xe0,0x25,0xe0,0x90,0x97,0x6e,0xf0,0x90,0x97,0x6b,0xe0,0x90,0x04,0x98,0xf0,0x90,
+0x97,0x6a,0xe0,0x13,0x13,0x54,0x3f,0x90,0x04,0x99,0xf0,0x90,0x97,0x6e,0xe0,0x13,
+0x13,0x54,0x3f,0x90,0x04,0x9a,0xf0,0x90,0x05,0x60,0xe0,0x90,0x97,0x79,0xf0,0x90,
+0x05,0x61,0xe0,0x90,0x97,0x7a,0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0x7b,0xf0,0x90,
+0x05,0x63,0xe0,0x90,0x97,0x7c,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x49,0xf0,0xc2,
+0xaf,0x90,0x97,0x6a,0xe0,0xff,0x12,0x79,0x7c,0x90,0x97,0x49,0xe0,0x24,0xff,0x92,
+0xaf,0x90,0x97,0x6b,0xe0,0x70,0x03,0x02,0x65,0x61,0x90,0x97,0x6a,0xe0,0x70,0x03,
+0x02,0x65,0x61,0x90,0x97,0x6e,0xe0,0x70,0x03,0x02,0x65,0x61,0xa2,0xaf,0xe4,0x33,
+0x90,0x97,0x49,0xf0,0xc2,0xaf,0x90,0x97,0x7d,0x74,0x01,0xf0,0x90,0x97,0x49,0xe0,
+0x24,0xff,0x92,0xaf,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0xa3,0xe0,0x44,0x01,0xf0,
+0x90,0x97,0x63,0xe0,0x60,0x1d,0x90,0x97,0x6f,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x80,0x7e,0x08,0x12,0x33,
+0xd8,0x80,0x06,0x90,0x05,0x22,0x74,0x7f,0xf0,0x90,0x00,0x45,0xe0,0x54,0xef,0xf0,
+0x90,0x05,0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0x79,0xe0,0x90,0x05,0x84,0xf0,0x90,
+0x97,0x7a,0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0x7b,0xe0,0x90,0x05,0x86,0xf0,0x90,
+0x97,0x7c,0xe0,0x90,0x05,0x87,0xf0,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x49,0xf0,0xc2,
+0xaf,0x90,0x01,0x3c,0xe0,0x44,0x20,0xf0,0x7d,0x20,0xe4,0xff,0x12,0x3a,0x49,0x80,
+0x2b,0x90,0x97,0x6b,0xe0,0x70,0x2d,0x90,0x97,0x7d,0xf0,0x90,0x00,0x45,0xe0,0x54,
+0xfe,0xf0,0xa3,0xe0,0x54,0xfe,0xf0,0x90,0x05,0x22,0xe4,0xf0,0xa2,0xaf,0x33,0x90,
+0x97,0x49,0xf0,0xc2,0xaf,0x7d,0x20,0xe4,0xff,0x12,0x39,0xdb,0x90,0x97,0x49,0xe0,
+0x24,0xff,0x92,0xaf,0x22,0xbb,0x01,0x06,0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x02,
+0xf7,0x22,0xbb,0xfe,0x01,0xf3,0x22,0xf8,0xbb,0x01,0x0d,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0x22,0x50,0x06,0xe9,0x25,0x82,0xc8,0xf6,0x22,
+0xbb,0xfe,0x05,0xe9,0x25,0x82,0xc8,0xf2,0x22,0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,
+0xc5,0xf0,0xf8,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,
+0xf8,0xe0,0xc5,0xf0,0x25,0xf0,0xf0,0xe5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,0xe0,
+0xc8,0x38,0xf0,0xe8,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,
+0xe0,0x22,0x50,0x06,0x87,0xf0,0x09,0xe7,0x19,0x22,0xbb,0xfe,0x07,0xe3,0xf5,0xf0,
+0x09,0xe3,0x19,0x22,0x89,0x82,0x8a,0x83,0xe4,0x93,0xf5,0xf0,0x74,0x01,0x93,0x22,
+0xbb,0x01,0x10,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,
+0xa3,0xe0,0x22,0x50,0x09,0xe9,0x25,0x82,0xf8,0x86,0xf0,0x08,0xe6,0x22,0xbb,0xfe,
+0x0a,0xe9,0x25,0x82,0xf8,0xe2,0xf5,0xf0,0x08,0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,
+0xe9,0x93,0xf5,0xf0,0xa3,0xe9,0x93,0x22,0xbb,0x01,0x0a,0x89,0x82,0x8a,0x83,0xf0,
+0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x06,0xf7,0x09,0xa7,0xf0,0x19,0x22,0xbb,0xfe,0x06,
+0xf3,0xe5,0xf0,0x09,0xf3,0x19,0x22,0xf8,0xbb,0x01,0x11,0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x09,0xe9,0x25,
+0x82,0xc8,0xf6,0x08,0xa6,0xf0,0x22,0xbb,0xfe,0x09,0xe9,0x25,0x82,0xc8,0xf2,0xe5,
+0xf0,0x08,0xf2,0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,
+0xe8,0x9c,0x45,0xf0,0x22,0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,
+0x22,0xd0,0x83,0xd0,0x82,0xf8,0xe4,0x93,0x70,0x12,0x74,0x01,0x93,0x70,0x0d,0xa3,
+0xa3,0x93,0xf8,0x74,0x01,0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x02,0x93,0x68,
+0x60,0xef,0xa3,0xa3,0xa3,0x80,0xdf,0x90,0x97,0x46,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,
+0xe9,0xf0,0x90,0x97,0x46,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x04,
+0x12,0x1c,0xef,0xff,0x54,0x1f,0x90,0x97,0x49,0xf0,0x90,0x00,0x03,0x12,0x1c,0xef,
+0x54,0xf0,0xc4,0x54,0x0f,0x90,0x97,0x4a,0xf0,0xef,0x54,0x20,0xc4,0x13,0x54,0x07,
+0xa3,0xf0,0x90,0x97,0x49,0xe0,0xff,0x75,0xf0,0x08,0xa4,0x24,0x65,0xf5,0x82,0xe4,
+0x34,0x93,0xad,0x82,0x90,0x97,0x4c,0xf0,0xa3,0xed,0xf0,0xef,0x75,0xf0,0x08,0xa4,
+0x24,0x63,0xf9,0x74,0x93,0x35,0xf0,0xfa,0xa3,0x74,0x01,0xf0,0xa3,0xea,0xf0,0xa3,
+0xe9,0xf0,0x90,0x97,0x46,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x03,0x12,0x1c,
+0xef,0x54,0x0f,0xff,0x90,0x97,0x4e,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0xef,
+0x12,0x65,0x95,0x90,0x97,0x46,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,
+0x02,0x12,0x1c,0xef,0xff,0x90,0x97,0x4e,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x90,0x00,0x01,0xef,0x12,0x65,0xa7,0x90,0x97,0x46,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xf9,0x90,0x00,0x01,0x12,0x1c,0xef,0xff,0x90,0x97,0x4c,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xf5,0x82,0x8c,0x83,0xef,0xf0,0x12,0x1c,0xd6,0x8d,0x82,0x8c,0x83,0xa3,0xf0,
+0x90,0x97,0x4a,0xe0,0xfe,0x90,0x97,0x49,0xe0,0xff,0x24,0xc1,0xf5,0x82,0xe4,0x34,
+0x92,0xf5,0x83,0xee,0xf0,0x90,0x97,0x4b,0xe0,0xfe,0xef,0x75,0xf0,0x08,0xa4,0x24,
+0x69,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0xee,0xf0,0xef,0x75,0xf0,0x08,0xa4,0x24,
+0x6a,0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0x74,0x01,0xf0,0x02,0x54,0xe6,0xc0,0xe0,
+0xc0,0xf0,0xc0,0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,
+0x02,0xc0,0x03,0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0xfe,
+0xf0,0x74,0x67,0xa3,0xf0,0x53,0x91,0xdf,0x90,0x01,0x3c,0xe0,0x55,0x30,0xf5,0x34,
+0xa3,0xe0,0x55,0x31,0xf5,0x35,0xa3,0xe0,0x55,0x32,0xf5,0x36,0xe5,0x34,0x30,0xe0,
+0x0f,0x90,0x01,0x3c,0x74,0x01,0xf0,0x90,0x01,0x53,0x74,0x07,0xf0,0x43,0x55,0x80,
+0xe5,0x34,0x30,0xe1,0x09,0x90,0x01,0x3c,0x74,0x02,0xf0,0x12,0x7b,0x00,0xe5,0x34,
+0x30,0xe2,0x3a,0x90,0x01,0x3c,0x74,0x04,0xf0,0x90,0x06,0x92,0xe0,0x30,0xe0,0x1e,
+0x75,0x48,0x14,0x75,0x49,0x00,0xe4,0xfb,0xfd,0x7f,0x58,0x7e,0x01,0x12,0x38,0xec,
+0x90,0x01,0x5b,0x74,0x05,0xf0,0x90,0x06,0x92,0x74,0x01,0xf0,0x80,0x0f,0x90,0x97,
+0x87,0xe4,0xf0,0x90,0x97,0x8b,0xe0,0xff,0x7d,0x01,0x12,0x6e,0xda,0xe5,0x34,0x30,
+0xe3,0x06,0x90,0x01,0x3c,0x74,0x08,0xf0,0xe5,0x34,0x30,0xe4,0x09,0x90,0x01,0x3c,
+0x74,0x10,0xf0,0x12,0x7e,0xdf,0xe5,0x34,0x30,0xe5,0x09,0x90,0x01,0x3c,0x74,0x20,
+0xf0,0x12,0x6f,0xa2,0xe5,0x35,0x30,0xe0,0x15,0x90,0x01,0x3d,0x74,0x01,0xf0,0x90,
+0x00,0x83,0xe0,0x90,0x97,0x8b,0xf0,0xe0,0xff,0x7d,0x01,0x12,0x6e,0xda,0xe5,0x36,
+0x30,0xe3,0x06,0x90,0x01,0x3e,0x74,0x08,0xf0,0x74,0xfe,0x04,0x90,0x01,0xc4,0xf0,
+0x74,0x67,0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,
+0xd0,0x01,0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0x8b,
+0x10,0x8a,0x11,0x89,0x12,0x90,0x00,0x02,0x12,0x1c,0xef,0x90,0x97,0x6c,0xf0,0xe0,
+0x90,0x04,0x94,0xf0,0x90,0x00,0x01,0x12,0x1c,0xef,0x90,0x04,0x95,0xf0,0x90,0x97,
+0x6c,0xe0,0x30,0xe0,0x74,0x90,0x97,0x63,0x74,0x01,0xf0,0x7f,0x80,0x7e,0x08,0x12,
+0x2b,0x13,0x90,0x97,0x65,0x12,0x1d,0xa9,0xab,0x10,0xaa,0x11,0xa9,0x12,0x90,0x00,
+0x01,0x12,0x1c,0xef,0xff,0xe4,0xfc,0xfd,0xfe,0x78,0x1a,0x12,0x1d,0x96,0xa8,0x04,
+0xa9,0x05,0xaa,0x06,0xab,0x07,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,
+0xfe,0xa3,0xe0,0xff,0xec,0x54,0x03,0xfc,0xeb,0x4f,0xff,0xea,0x4e,0xfe,0xe9,0x4d,
+0xfd,0xe8,0x4c,0xfc,0x90,0x97,0x6f,0x12,0x1d,0xa9,0x90,0x05,0x22,0xe4,0xf0,0x90,
+0x97,0x6f,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x78,0x18,0x12,
+0x1d,0x83,0x90,0x04,0x96,0xef,0xf0,0x80,0x45,0xe4,0x90,0x97,0x63,0xf0,0x7f,0x80,
+0x7e,0x08,0x12,0x2b,0x13,0x90,0x97,0x65,0x12,0x1d,0xa9,0x90,0x97,0x65,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0xec,0x44,0xc0,0xfc,0x90,0x97,0x65,
+0x12,0x1d,0xa9,0x90,0x97,0x65,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,
+0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x80,0x7e,0x08,0x12,0x33,0xd8,0x90,0x97,
+0x6c,0xe0,0x90,0x00,0x47,0x30,0xe1,0x11,0x74,0x0c,0xf0,0xa3,0xe0,0x44,0x0c,0xf0,
+0x90,0x00,0x46,0xe0,0x44,0x10,0xf0,0x80,0x10,0xe0,0x54,0xf3,0xf0,0xa3,0xe0,0x54,
+0xf3,0xf0,0x90,0x00,0x46,0xe0,0x54,0xef,0xf0,0xe4,0x90,0x97,0x69,0xf0,0x22,0x90,
+0x97,0x64,0xe0,0xc3,0x94,0x14,0x50,0x06,0xe0,0x04,0xf0,0x02,0x6a,0xd9,0x90,0x97,
+0x64,0xe0,0x64,0x14,0x60,0x03,0x02,0x6a,0xd9,0x90,0x97,0x73,0xe0,0x70,0x25,0x90,
+0x97,0x76,0xe0,0x70,0x1f,0x90,0x97,0x74,0xe0,0x70,0x19,0x90,0x97,0x77,0xe0,0x70,
+0x13,0x90,0x97,0x75,0xe0,0x70,0x0d,0x90,0x97,0x78,0xe0,0x70,0x07,0x90,0x04,0xfd,
+0xe0,0x54,0xfe,0xf0,0x90,0x97,0x73,0xe0,0x90,0x04,0x88,0xf0,0x90,0x97,0x74,0xe0,
+0x90,0x04,0x89,0xf0,0x90,0x97,0x75,0xe0,0x90,0x04,0x8a,0xf0,0xa3,0xe4,0xf0,0x90,
+0x97,0x76,0xe0,0x90,0x04,0x8c,0xf0,0x90,0x97,0x77,0xe0,0x90,0x04,0x8d,0xf0,0x90,
+0x97,0x78,0xe0,0x90,0x04,0x8e,0xf0,0xa3,0xe4,0xf0,0x90,0x97,0x5f,0xe0,0x90,0x04,
+0x90,0xf0,0x90,0x97,0x60,0xe0,0x90,0x04,0x91,0xf0,0x90,0x97,0x61,0xe0,0x90,0x04,
+0x92,0xf0,0x90,0x97,0x62,0xe0,0x90,0x04,0x93,0xf0,0xe4,0x90,0x97,0x64,0xf0,0x90,
+0x97,0x5f,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,0x73,0xf0,0xa3,
+0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x90,0x97,0x64,0xe0,0x90,0x04,0x97,
+0xf0,0x90,0x05,0x60,0xe0,0x90,0x97,0x3a,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0x3b,
+0xf0,0x90,0x05,0x62,0xe0,0x90,0x97,0x3c,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0x3d,
+0xf0,0x90,0x97,0x7c,0xe0,0xff,0x90,0x97,0x3d,0xe0,0xfe,0xd3,0x9f,0x50,0x0b,0x90,
+0x97,0x7c,0xe0,0xc3,0x9e,0xd3,0x94,0x01,0x40,0x11,0x90,0x97,0x6a,0xe0,0xb4,0x01,
+0x02,0x80,0x03,0x90,0x97,0x6e,0xe0,0xff,0x12,0x79,0x7c,0x22,0x90,0x97,0xb0,0xed,
+0xf0,0x90,0x97,0xaf,0xef,0xf0,0xd3,0x94,0x07,0x50,0x6d,0xe0,0xff,0x74,0x01,0xa8,
+0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,0xf0,
+0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,0xaf,0xe0,0xff,0x74,0x01,0xa8,0x07,
+0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x46,0xe0,0x4f,0xf0,0x7f,0x10,
+0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,0xb0,0xe0,0x60,0x16,0x90,0x97,0xaf,0xe0,0xff,
+0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,0x00,0x45,0x80,
+0x78,0x90,0x97,0xaf,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,
+0xfc,0xf4,0xff,0x90,0x00,0x45,0x80,0x7d,0x90,0x97,0xaf,0xe0,0x24,0xf8,0xf0,0xe0,
+0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,0xf4,
+0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,
+0xaf,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xff,0x90,
+0x00,0x43,0xe0,0x4f,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,0xb0,0xe0,
+0x60,0x1b,0x90,0x97,0xaf,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,
+0xd8,0xfc,0xc4,0x54,0xf0,0xff,0x90,0x00,0x42,0xe0,0x4f,0x80,0x1a,0x90,0x97,0xaf,
+0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xc4,0x54,0xf0,
+0xf4,0xff,0x90,0x00,0x42,0xe0,0x5f,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x22,
+0x90,0x01,0xc4,0x74,0x30,0xf0,0x74,0x6c,0xa3,0xf0,0x7f,0x78,0x7e,0x08,0x12,0x2b,
+0x13,0x90,0x97,0x1d,0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x0c,0x12,0x2b,0x13,0x90,0x97,
+0x21,0x12,0x1d,0xa9,0x7f,0x00,0x7e,0x08,0x12,0x2b,0x13,0x90,0x97,0x25,0x12,0x1d,
+0xa9,0x90,0x97,0x97,0xe0,0x90,0x97,0x1d,0xb4,0x01,0x13,0xe0,0xfc,0xa3,0xe0,0xfd,
+0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xc7,0xff,0xed,0x54,0xc7,0xfd,0x80,0x0d,0xe0,0xfc,
+0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0xc7,0xff,0xec,0x90,0x81,0x56,0x12,
+0x1d,0xa9,0x7f,0x78,0x7e,0x08,0x12,0x33,0xd8,0x90,0x97,0x21,0xe0,0xfc,0xa3,0xe0,
+0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0x54,0x0f,0xff,0xec,0x90,0x81,0x56,0x12,0x1d,0xa9,
+0x7f,0x04,0x7e,0x0c,0x12,0x33,0xd8,0x90,0x97,0x25,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,
+0xe0,0xfe,0xa3,0xe0,0x44,0x02,0xff,0xec,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x00,
+0x7e,0x08,0x12,0x33,0xd8,0x7f,0x70,0x7e,0x0e,0x12,0x2b,0x13,0x90,0x97,0x29,0x12,
+0x1d,0xa9,0x90,0x81,0x56,0x12,0x1d,0xb5,0x00,0x1b,0x25,0xa0,0x7f,0x70,0x7e,0x0e,
+0x12,0x33,0xd8,0x90,0x81,0x24,0x12,0x1d,0xb5,0x00,0x00,0x00,0x00,0xe4,0xfd,0xff,
+0x12,0x38,0xb6,0x90,0x97,0x97,0xe0,0xb4,0x01,0x11,0x90,0x81,0x24,0x12,0x1d,0xb5,
+0x00,0x00,0x00,0x00,0xe4,0xfd,0x7f,0x01,0x12,0x38,0xb6,0x90,0x00,0x11,0xe0,0x54,
+0xf6,0xf0,0x7f,0x10,0x7e,0x00,0x02,0x3a,0xa8,0x90,0x97,0x7d,0xe0,0x64,0x01,0x60,
+0x09,0x90,0x97,0x6b,0xe0,0x60,0x03,0x02,0x6e,0x01,0x90,0x97,0x5f,0xe0,0xc3,0x94,
+0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x3b,0x90,0x97,0x60,0xe0,0xc3,0x94,0xff,0x50,
+0x06,0xe0,0x04,0xf0,0xe4,0x80,0x28,0x90,0x97,0x61,0xe0,0xc3,0x94,0xff,0x50,0x0a,
+0xe0,0x04,0xf0,0xe4,0x90,0x97,0x60,0xf0,0x80,0x15,0x90,0x97,0x62,0xe0,0xc3,0x94,
+0xff,0x50,0x10,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x61,0xf0,0x90,0x97,0x60,0xf0,0x90,
+0x97,0x5f,0xf0,0x90,0x00,0x44,0xe0,0x54,0x0c,0x60,0x76,0xe0,0x30,0xe2,0x32,0x90,
+0x97,0x73,0xe0,0xc3,0x94,0xff,0x50,0x05,0xe0,0x04,0xf0,0x80,0x24,0x90,0x97,0x74,
+0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,0x04,0xf0,0xe4,0x80,0x11,0x90,0x97,0x75,0xe0,
+0xc3,0x94,0xff,0x50,0x0c,0xe0,0x04,0xf0,0xe4,0x90,0x97,0x74,0xf0,0x90,0x97,0x73,
+0xf0,0x90,0x00,0x44,0xe0,0x30,0xe3,0x32,0x90,0x97,0x76,0xe0,0xc3,0x94,0xff,0x50,
+0x05,0xe0,0x04,0xf0,0x80,0x24,0x90,0x97,0x77,0xe0,0xc3,0x94,0xff,0x50,0x06,0xe0,
+0x04,0xf0,0xe4,0x80,0x11,0x90,0x97,0x78,0xe0,0xc3,0x94,0xff,0x50,0x0c,0xe0,0x04,
+0xf0,0xe4,0x90,0x97,0x77,0xf0,0x90,0x97,0x76,0xf0,0x90,0x04,0xfd,0xe0,0x44,0x01,
+0xf0,0x22,0x90,0x97,0x43,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xad,0x07,0x90,
+0x01,0xc4,0x74,0x02,0xf0,0x74,0x6e,0xa3,0xf0,0xed,0x12,0x66,0xc1,0x6e,0x3f,0x01,
+0x6e,0x4d,0x02,0x6e,0x5b,0x03,0x6e,0x69,0x05,0x6e,0x77,0x06,0x6e,0x85,0x07,0x6e,
+0x93,0x09,0x6e,0xa1,0x0c,0x6e,0xaf,0x0d,0x6e,0xbd,0x0e,0x00,0x00,0x6e,0xcb,0x90,
+0x97,0x43,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x9d,0x90,0x97,0x43,
+0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7f,0x77,0x90,0x97,0x43,0xe0,0xfb,
+0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7d,0x17,0x90,0x97,0x43,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x02,0x7c,0x0b,0x90,0x97,0x43,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xf9,0x02,0x66,0xe7,0x90,0x97,0x43,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,
+0x02,0x7f,0x28,0x90,0x97,0x43,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x73,
+0x14,0x90,0x97,0x43,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x64,0x34,0x90,
+0x97,0x43,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x7c,0x7e,0x90,0x97,0x43,
+0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x02,0x69,0x0f,0xc2,0xaf,0x74,0x02,0x04,
+0x90,0x01,0xc4,0xf0,0x74,0x6e,0xa3,0xf0,0x80,0xfe,0x8f,0x62,0x8d,0x63,0x90,0x01,
+0xc4,0x74,0xda,0xf0,0x74,0x6e,0xa3,0xf0,0xe5,0x62,0x54,0x0f,0xff,0x90,0x97,0x88,
+0xe0,0x54,0x0f,0x6f,0x60,0x78,0xe5,0x62,0x30,0xe2,0x30,0x90,0x97,0x88,0xe0,0x20,
+0xe2,0x05,0x7f,0x01,0x12,0x7e,0x08,0x90,0x97,0x88,0xe0,0x30,0xe3,0x0a,0xe5,0x62,
+0x20,0xe3,0x05,0x12,0x7e,0x27,0x80,0x56,0x90,0x97,0x88,0xe0,0x20,0xe3,0x4f,0xe5,
+0x62,0x30,0xe3,0x4a,0xaf,0x63,0x12,0x7d,0xe8,0x80,0x43,0x90,0x97,0x88,0xe0,0x54,
+0x0f,0xff,0xbf,0x0c,0x0e,0xe5,0x62,0x20,0xe3,0x09,0x12,0x7d,0x72,0xef,0x60,0x2e,
+0x12,0x7e,0x27,0x90,0x97,0x88,0xe0,0x54,0x0f,0xff,0xbf,0x04,0x0e,0xe5,0x62,0x20,
+0xe2,0x09,0x12,0x7b,0x8a,0xef,0x60,0x16,0x12,0x7c,0x47,0x90,0x97,0x88,0xe0,0x54,
+0x0f,0xff,0xbf,0x02,0x09,0x12,0x7a,0xb8,0xef,0x60,0x03,0x12,0x7e,0x44,0x90,0x97,
+0x88,0xe0,0x54,0x0f,0xff,0x90,0x97,0x8b,0xe0,0x54,0x0f,0x6f,0x70,0x23,0xe0,0x30,
+0xe6,0x1f,0x90,0x97,0x88,0xe0,0x54,0x0f,0xff,0x90,0x97,0x7e,0xe0,0xfe,0x4f,0x90,
+0x01,0x2f,0xf0,0xee,0x64,0x80,0x90,0x97,0x7e,0xf0,0x90,0x97,0x8b,0xe0,0x54,0xbf,
+0xf0,0x22,0x90,0x97,0x6b,0xe0,0x64,0x01,0x60,0x03,0x02,0x70,0x65,0x90,0x00,0x46,
+0xe0,0x44,0x01,0xf0,0x90,0x97,0x7d,0xe0,0x70,0x40,0x90,0x97,0x63,0xe0,0x60,0x1d,
+0x90,0x97,0x6f,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,
+0x56,0x12,0x1d,0xa9,0x7f,0x80,0x7e,0x08,0x12,0x33,0xd8,0x80,0x06,0x90,0x05,0x22,
+0x74,0x7f,0xf0,0x90,0x97,0x6a,0xe0,0xff,0x12,0x79,0x7c,0x90,0x97,0x7d,0x74,0x01,
+0xf0,0x90,0x00,0x45,0xe0,0x54,0xfe,0xf0,0x80,0x44,0x90,0x97,0x7d,0xe0,0x64,0x01,
+0x70,0x3c,0x90,0x97,0x6e,0xe0,0xff,0x12,0x79,0x7c,0xe4,0x90,0x97,0x7d,0xf0,0x90,
+0x00,0x45,0xe0,0x44,0x01,0xf0,0x90,0x97,0x63,0xe0,0x60,0x1d,0x90,0x97,0x65,0xe0,
+0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,
+0x7f,0x80,0x7e,0x08,0x12,0x33,0xd8,0x80,0x05,0x90,0x05,0x22,0xe4,0xf0,0x90,0x05,
+0x87,0xe0,0x64,0x80,0xf0,0x90,0x97,0x79,0xe0,0x90,0x05,0x84,0xf0,0x90,0x97,0x7a,
+0xe0,0x90,0x05,0x85,0xf0,0x90,0x97,0x7b,0xe0,0x90,0x05,0x86,0xf0,0x90,0x97,0x7c,
+0xe0,0x90,0x05,0x87,0xf0,0x22,0x90,0x97,0x30,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,
+0xf0,0x90,0x97,0x96,0xe0,0x64,0x02,0x70,0x03,0x02,0x71,0x1b,0x90,0x01,0xaf,0xe0,
+0x60,0x09,0x90,0x01,0xc7,0xe0,0x04,0xf0,0xf0,0x80,0xf1,0x90,0x97,0xb3,0xe0,0xff,
+0x04,0xf0,0x90,0x97,0x30,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,
+0xef,0x12,0x65,0xa7,0xa2,0xaf,0xe4,0x33,0x90,0x97,0x36,0xf0,0xc2,0xaf,0x90,0x97,
+0x30,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0x8b,0x24,0x8a,0x25,0xf5,0x26,0x75,0x27,
+0x02,0x7b,0x01,0x7a,0x01,0x79,0xa0,0x12,0x79,0x27,0x90,0x97,0x36,0xe0,0x24,0xff,
+0x92,0xaf,0xa2,0xaf,0xe4,0x33,0xf0,0xc2,0xaf,0x90,0x97,0x33,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0x8b,0x24,0x8a,0x25,0xf5,0x26,0x90,0x97,0x30,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x12,0x1c,0xd6,0xff,0xc4,0x54,0x0f,0xf5,0x27,0x7b,0x01,0x7a,
+0x01,0x79,0xa2,0x12,0x79,0x27,0x90,0x97,0x36,0xe0,0x24,0xff,0x92,0xaf,0x90,0x01,
+0xaf,0x74,0xff,0xf0,0x90,0x01,0xcb,0xe0,0x64,0x80,0xf0,0x22,0x90,0x01,0xc4,0x74,
+0x1c,0xf0,0x74,0x71,0xa3,0xf0,0x90,0x00,0x11,0xe0,0x44,0x09,0xf0,0x7f,0x10,0x7e,
+0x00,0x12,0x3a,0xa8,0x90,0x97,0x1d,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,
+0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x78,0x7e,0x08,0x12,0x33,0xd8,0x90,
+0x97,0x21,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,
+0x12,0x1d,0xa9,0x7f,0x04,0x7e,0x0c,0x12,0x33,0xd8,0x90,0x97,0x25,0xe0,0xfc,0xa3,
+0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x00,
+0x7e,0x08,0x12,0x33,0xd8,0x90,0x97,0x29,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,
+0xa3,0xe0,0xff,0x90,0x81,0x56,0x12,0x1d,0xa9,0x7f,0x70,0x7e,0x0e,0x12,0x33,0xd8,
+0x90,0x81,0x24,0x12,0x1d,0xb5,0x00,0x03,0x2d,0x95,0xe4,0xfd,0xff,0x12,0x38,0xb6,
+0x90,0x97,0x97,0xe0,0xb4,0x01,0x11,0x90,0x81,0x24,0x12,0x1d,0xb5,0x00,0x03,0x2d,
+0x95,0xe4,0xfd,0x7f,0x01,0x12,0x38,0xb6,0x22,0x90,0x97,0x9e,0xef,0xf0,0xa3,0xed,
+0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xe5,0x65,0x60,0x05,0xe4,0xff,0x12,0x7e,0x99,0x90,
+0x97,0x9e,0xe0,0x30,0xe0,0x09,0x90,0x97,0xa0,0xe4,0xf0,0xa3,0x74,0x80,0xf0,0x90,
+0x04,0x1d,0xe0,0x60,0x1d,0x90,0x05,0x22,0xe0,0x90,0x97,0xa2,0xf0,0xe0,0xff,0x54,
+0x90,0x60,0xec,0x90,0x01,0xc8,0x74,0xfc,0xf0,0xef,0x54,0x6f,0x90,0x05,0x22,0xf0,
+0x80,0xdd,0x90,0x97,0x9e,0xe0,0xff,0xc3,0x13,0x90,0xfd,0x10,0xf0,0x90,0x04,0x25,
+0xef,0xf0,0x90,0x97,0x9f,0xe0,0x60,0x10,0xa3,0xa3,0xe0,0x24,0x10,0xf5,0x82,0xe4,
+0x34,0xfc,0xf5,0x83,0xe0,0x44,0x80,0xf0,0x90,0x97,0xa0,0xa3,0xe0,0xff,0xfd,0x24,
+0x08,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,0xe4,0xf0,0x74,0x09,0x2d,0xf5,0x82,0xe4,
+0x34,0xfc,0xf5,0x83,0xe0,0x54,0xf0,0xf0,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,
+0xf5,0x83,0xe0,0x54,0xf7,0xf0,0x90,0x97,0xa0,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0x90,
+0x97,0xb5,0xef,0xf0,0xd3,0x94,0x07,0x50,0x4a,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0xe0,0x5f,0xf0,0x7f,0x10,
+0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,0xb5,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,0x05,
+0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x44,0xe0,0xfb,
+0xe4,0xfe,0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,0xd8,
+0xf8,0xff,0x22,0x90,0x97,0xb5,0xe0,0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,
+0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x7f,
+0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,0xb5,0xe0,0xfd,0x74,0x01,0x7e,0x00,0xa8,
+0x05,0x08,0x80,0x05,0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0x90,0x00,0x42,0xe0,
+0xfb,0xe4,0xfe,0xef,0x5b,0xa8,0x05,0x08,0x80,0x06,0xce,0xa2,0xe7,0x13,0xce,0x13,
+0xd8,0xf8,0xff,0x22,0x90,0x97,0x46,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xa2,
+0xaf,0xe4,0x33,0xa3,0xf0,0xc2,0xaf,0x90,0x97,0x46,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,
+0xe0,0xf9,0x90,0x00,0x01,0x12,0x66,0x20,0xfa,0xe5,0xf0,0x24,0x00,0xff,0xe4,0x3a,
+0xfe,0x90,0x97,0x46,0xa3,0xe0,0xfa,0x90,0x00,0x01,0xee,0x8f,0xf0,0x12,0x66,0x77,
+0x12,0x1c,0xd6,0xff,0x60,0x37,0xb5,0x5e,0x1b,0x90,0x97,0x46,0xe0,0xfb,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xf9,0x90,0x00,0x01,0x12,0x66,0x20,0x65,0x60,0x70,0x04,0xe5,0x5f,
+0x65,0xf0,0x60,0x2e,0x90,0x97,0x46,0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x90,
+0x00,0x01,0x12,0x66,0x20,0xff,0xae,0xf0,0x12,0x7c,0xb4,0x80,0x15,0x90,0x97,0x46,
+0xe0,0xfb,0xa3,0xe0,0xfa,0xa3,0xe0,0xf9,0x12,0x1c,0xd6,0x65,0x5e,0x60,0x03,0x12,
+0x7f,0x56,0x90,0x97,0x49,0xe0,0x24,0xff,0x92,0xaf,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
+0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x00,0xc0,0x00,0xc0,0x01,0xc0,0x02,0xc0,0x03,
+0xc0,0x04,0xc0,0x05,0xc0,0x06,0xc0,0x07,0x90,0x01,0xc4,0x74,0xab,0xf0,0x74,0x73,
+0xa3,0xf0,0x53,0x91,0xef,0x90,0x00,0x51,0xe0,0xff,0x90,0x00,0x55,0xe0,0x5f,0xf5,
+0x3d,0xe5,0x3d,0x30,0xe6,0x18,0x74,0x40,0xf0,0x90,0x97,0x6c,0xe0,0x54,0x03,0xff,
+0xbf,0x03,0x0b,0x90,0x97,0x69,0xe0,0x60,0x05,0x7f,0x01,0x12,0x44,0x7b,0xe5,0x3d,
+0x30,0xe7,0x15,0x90,0x00,0x55,0x74,0x80,0xf0,0x90,0x97,0x6c,0xe0,0x54,0x03,0xff,
+0xbf,0x03,0x05,0x7f,0x02,0x12,0x44,0x7b,0x90,0x01,0xc4,0x74,0xab,0xf0,0x74,0x73,
+0xa3,0xf0,0xd0,0x07,0xd0,0x06,0xd0,0x05,0xd0,0x04,0xd0,0x03,0xd0,0x02,0xd0,0x01,
+0xd0,0x00,0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,0xef,0x60,0x34,
+0x7d,0x7d,0x7f,0x02,0x12,0x39,0xbe,0x7d,0x02,0x7f,0x03,0x12,0x39,0xbe,0x90,0x01,
+0x57,0xe4,0xf0,0x90,0x01,0x3c,0x74,0x02,0xf0,0x7d,0x01,0x7f,0x0c,0x12,0x6e,0xda,
+0xe4,0xff,0x12,0x7e,0x99,0x90,0x06,0x04,0xe0,0x54,0x7f,0xf0,0x90,0x06,0x0a,0xe0,
+0x54,0xf8,0xf0,0x22,0x90,0x01,0x36,0x74,0x7d,0xf0,0xa3,0x74,0x02,0xf0,0x7d,0x7d,
+0xff,0x12,0x3a,0x2f,0x7d,0x02,0x7f,0x03,0x12,0x3a,0x2f,0x90,0x06,0x04,0xe0,0x44,
+0x80,0xf0,0x90,0x06,0x0a,0xe0,0x44,0x07,0xf0,0x90,0x97,0x83,0xe0,0xa3,0xe0,0x90,
+0x05,0x58,0xf0,0xe5,0x64,0x30,0xe0,0x1b,0x90,0x97,0x81,0xe0,0x70,0x1a,0xe0,0x04,
+0xf0,0x90,0x97,0x88,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x0c,0x7d,0x01,0x7f,0x04,
+0x02,0x6e,0xda,0xe4,0x90,0x97,0x81,0xf0,0x22,0x02,0x75,0x07,0x02,0x62,0xd3,0xe4,
+0x93,0xa3,0xf8,0xe4,0x93,0xa3,0x40,0x03,0xf6,0x80,0x01,0xf2,0x08,0xdf,0xf4,0x80,
+0x29,0xe4,0x93,0xa3,0xf8,0x54,0x07,0x24,0x0c,0xc8,0xc3,0x33,0xc4,0x54,0x0f,0x44,
+0x20,0xc8,0x83,0x40,0x04,0xf4,0x56,0x80,0x01,0x46,0xf6,0xdf,0xe4,0x80,0x0b,0x01,
+0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x90,0x7f,0x0e,0xe4,0x7e,0x01,0x93,0x60,0xbc,
+0xa3,0xff,0x54,0x3f,0x30,0xe5,0x09,0x54,0x1f,0xfe,0xe4,0x93,0xa3,0x60,0x01,0x0e,
+0xcf,0x54,0xc0,0x25,0xe0,0x60,0xa8,0x40,0xb8,0xe4,0x93,0xa3,0xfa,0xe4,0x93,0xa3,
+0xf8,0xe4,0x93,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xf0,0xa3,0xc8,0xc5,
+0x82,0xc8,0xca,0xc5,0x83,0xca,0xdf,0xe9,0xde,0xe7,0x80,0xbe,0x8f,0x0f,0x74,0x75,
+0x90,0x01,0xc4,0xf0,0xa3,0x74,0x4c,0xf0,0xe5,0x0f,0x75,0xf0,0x08,0xa4,0x24,0x67,
+0xf5,0x82,0xe4,0x34,0x93,0xf5,0x83,0xe0,0xff,0x74,0xa5,0x25,0x0f,0xf5,0x82,0xe4,
+0x34,0x96,0xf5,0x83,0xe0,0x54,0x1f,0xfb,0xd3,0x9f,0x40,0x02,0xab,0x07,0xeb,0x25,
+0xe0,0x24,0x9e,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0xe4,0x93,0xfe,0x74,0x01,0x93,
+0xff,0xeb,0x25,0xe0,0x24,0x66,0xf5,0x82,0xe4,0x34,0x41,0xf5,0x83,0x74,0x01,0x93,
+0x2f,0xff,0xe4,0x93,0x3e,0xc3,0x13,0xfe,0xef,0x13,0xff,0xe4,0xfc,0xfd,0xe5,0x0f,
+0x25,0xe0,0x25,0xe0,0x24,0xe1,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,0x12,0x1d,0xa9,
+0x74,0x84,0x25,0x0f,0xf5,0x82,0xe4,0x34,0x04,0xf5,0x83,0xeb,0xf0,0xff,0x22,0x90,
+0x97,0x4c,0xef,0xf0,0xd3,0x94,0x07,0x50,0x33,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,
+0x80,0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x47,0xe0,0x5f,0xf0,0x7f,0x10,
+0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,0x4c,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,
+0x02,0xc3,0x33,0xd8,0xfc,0xf4,0xff,0x90,0x00,0x46,0x80,0x3b,0x90,0x97,0x4c,0xe0,
+0x24,0xf8,0xf0,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,0xd8,0xfc,
+0xc4,0x54,0xf0,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x7f,0x10,0x7e,0x00,0x12,
+0x3a,0xa8,0x90,0x97,0x4c,0xe0,0xff,0x74,0x01,0xa8,0x07,0x08,0x80,0x02,0xc3,0x33,
+0xd8,0xfc,0xf4,0xff,0x90,0x00,0x43,0xe0,0x5f,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,
+0xa8,0x22,0x8f,0x0a,0x8d,0x0b,0xad,0x03,0x74,0x76,0x90,0x01,0xc4,0xf0,0xa3,0x74,
+0x52,0xf0,0xe5,0x0b,0x54,0x1f,0xf9,0x74,0x01,0x25,0x0a,0xf5,0x82,0xe4,0x34,0x92,
+0xf5,0x83,0xe0,0xff,0x90,0x04,0xfd,0xe0,0xb4,0x01,0x05,0x75,0x0e,0x03,0x80,0x03,
+0x75,0x0e,0x01,0xed,0xd3,0x95,0x0e,0x40,0x05,0xaf,0x0a,0x02,0x75,0x4c,0x90,0x01,
+0xc5,0x74,0x20,0xf0,0xe5,0x0d,0x2f,0xff,0xe9,0x90,0x41,0xd6,0x93,0xfe,0xef,0xd3,
+0x9e,0x40,0x22,0x90,0x01,0xc5,0x74,0x40,0xf0,0x74,0x01,0x25,0x0a,0xf5,0x82,0xe4,
+0x34,0x92,0xf5,0x83,0xe4,0xf0,0x74,0x84,0x25,0x0a,0xf5,0x82,0xe4,0x34,0x04,0xf5,
+0x83,0xe5,0x0b,0xf0,0x22,0x74,0x01,0x25,0x0a,0xf5,0x82,0xe4,0x34,0x92,0xf5,0x83,
+0xef,0xf0,0x22,0xe4,0x90,0x97,0x2e,0xf0,0xe5,0x65,0x60,0x6c,0xe5,0x64,0x64,0x01,
+0x70,0x66,0xe5,0x65,0x64,0x02,0x60,0x06,0xe5,0x65,0x64,0x03,0x70,0x1d,0x90,0x97,
+0x7f,0xe0,0x14,0xf0,0xe0,0x60,0x04,0xa3,0xe0,0x60,0x16,0x90,0x97,0x7f,0xe0,0x70,
+0x0a,0x90,0x97,0x8a,0xe0,0x90,0x97,0x7f,0xf0,0x80,0x00,0x90,0x97,0x2e,0x74,0x01,
+0xf0,0x90,0x97,0x2e,0xe0,0x60,0x31,0x90,0x97,0x8f,0xe0,0x44,0x10,0xf0,0x90,0x97,
+0x85,0xe0,0xf5,0x48,0xe4,0xf5,0x49,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x38,0xec,
+0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,0x88,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,
+0x07,0x7d,0x01,0x7f,0x04,0x12,0x6e,0xda,0x22,0x90,0x06,0xa9,0xe0,0xf5,0x0a,0x54,
+0xc0,0x70,0x0e,0x90,0x97,0x89,0xf0,0x90,0x97,0x8b,0xe0,0xff,0x7d,0x01,0x02,0x6e,
+0xda,0xe5,0x0a,0x30,0xe6,0x12,0x90,0x97,0x89,0x74,0x01,0xf0,0x90,0x97,0x8f,0xe0,
+0x44,0x01,0xf0,0x12,0x7e,0x7e,0x80,0x07,0x90,0x97,0x8f,0xe0,0x54,0xfe,0xf0,0xe5,
+0x0a,0x30,0xe7,0x29,0x90,0x97,0x89,0x74,0x01,0xf0,0x90,0x97,0x8f,0xe0,0x44,0x02,
+0xf0,0x75,0x48,0x03,0xe4,0xf5,0x49,0xfb,0xfd,0x7f,0x54,0x7e,0x01,0x12,0x38,0xec,
+0x90,0x01,0x57,0x74,0x05,0xf0,0x90,0x97,0x8e,0x74,0x01,0xf0,0x22,0x90,0x97,0x8f,
+0xe0,0x54,0xfd,0xf0,0x22,0x90,0x00,0x2b,0xe0,0x44,0x01,0xf0,0x7f,0xe8,0x7e,0x03,
+0x12,0x3a,0xa8,0x90,0x00,0x08,0xe0,0x44,0x10,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,
+0xa8,0x90,0x00,0x09,0xe0,0x54,0xf7,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,
+0x00,0x28,0xe0,0x54,0xfe,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x00,0x20,
+0xe0,0x54,0xfe,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x00,0x25,0xe0,0x44,
+0x40,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x00,0x09,0xe0,0x54,0xef,0xf0,
+0x7f,0x10,0x7e,0x00,0x02,0x3a,0xa8,0x8b,0x10,0x8a,0x11,0x89,0x12,0x12,0x7e,0xcd,
+0xab,0x10,0xaa,0x11,0xa9,0x12,0x12,0x1c,0xd6,0xf5,0x65,0x14,0x60,0x0e,0x14,0x60,
+0x0f,0x14,0x60,0x1a,0x24,0x03,0x70,0x3c,0x7f,0x01,0x80,0x35,0xe4,0xff,0x80,0x31,
+0x90,0x97,0x8a,0x74,0x01,0xf0,0x90,0x97,0x7f,0xf0,0xe4,0xff,0x80,0x23,0xab,0x10,
+0xaa,0x11,0xa9,0x12,0x90,0x00,0x02,0x12,0x1c,0xef,0xff,0x90,0x97,0x8a,0x70,0x05,
+0x74,0x05,0xf0,0x80,0x02,0xef,0xf0,0x90,0x97,0x8a,0xe0,0x90,0x97,0x7f,0xf0,0xe4,
+0xff,0x12,0x74,0x3d,0x22,0x90,0x00,0x25,0xe0,0x54,0xbf,0xf0,0x7f,0x10,0x7e,0x00,
+0x12,0x3a,0xa8,0x90,0x00,0x20,0xe0,0x44,0x01,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,
+0xa8,0x90,0x00,0x28,0xe0,0x44,0x01,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,
+0x00,0xf0,0xe0,0x30,0xe1,0xf9,0x90,0x00,0x09,0xe0,0x44,0x08,0xf0,0x7f,0x10,0x7e,
+0x00,0x12,0x3a,0xa8,0x90,0x00,0x08,0xe0,0x54,0xef,0xf0,0x7f,0x10,0x7e,0x00,0x12,
+0x3a,0xa8,0x90,0x00,0x2b,0xe0,0x54,0xfe,0xf0,0x7f,0xe8,0x7e,0x03,0x02,0x3a,0xa8,
+0x90,0x00,0x45,0xe4,0xf0,0x90,0x04,0xfd,0xf0,0xa3,0xf0,0x90,0x97,0x6d,0xf0,0x90,
+0x97,0x73,0xf0,0x90,0x97,0x76,0xf0,0x90,0x97,0x74,0xf0,0x90,0x97,0x77,0xf0,0x90,
+0x97,0x75,0xf0,0x90,0x97,0x78,0xf0,0x90,0x97,0x5f,0x04,0xf0,0xe4,0xa3,0xf0,0xa3,
+0xf0,0xa3,0xf0,0x90,0x97,0x64,0xf0,0x90,0x97,0x69,0xf0,0x90,0x97,0x6b,0xf0,0x90,
+0x97,0x7d,0xf0,0x90,0x97,0x6e,0xf0,0x90,0x97,0x6a,0xf0,0x90,0x97,0x63,0xf0,0x90,
+0x00,0x51,0xe0,0x44,0xc0,0xf0,0x22,0x8b,0x21,0x8a,0x22,0x89,0x23,0x90,0x97,0x98,
+0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0xa3,0xe5,0x24,0xf0,0xa3,0xe5,0x25,0xf0,
+0xa3,0xe5,0x26,0xf0,0xaf,0x27,0x15,0x27,0xef,0x60,0x2a,0x90,0x97,0x9b,0xe0,0xfb,
+0xa3,0xe4,0x75,0xf0,0x01,0x12,0x65,0xdf,0xa9,0xf0,0xfa,0x12,0x1c,0xd6,0xff,0x90,
+0x97,0x98,0xe0,0xfb,0xa3,0xe4,0x75,0xf0,0x01,0x12,0x65,0xdf,0xa9,0xf0,0xfa,0xef,
+0x12,0x65,0x95,0x80,0xcf,0xab,0x21,0xaa,0x22,0xa9,0x23,0x22,0x90,0x05,0x60,0xe0,
+0x90,0x97,0x79,0xf0,0x90,0x05,0x61,0xe0,0x90,0x97,0x7a,0xf0,0x90,0x05,0x62,0xe0,
+0x90,0x97,0x7b,0xf0,0x90,0x05,0x63,0xe0,0x90,0x97,0x7c,0xf0,0xc3,0x74,0xff,0x9f,
+0xfe,0x90,0x97,0x7a,0xe0,0xd3,0x9e,0x40,0x1e,0xe0,0x2f,0xf0,0xa3,0xe0,0xb4,0xff,
+0x0f,0xe4,0xf0,0xa3,0xe0,0xb4,0xff,0x03,0xe4,0xf0,0x22,0x90,0x97,0x7c,0x80,0x03,
+0x90,0x97,0x7b,0xe0,0x04,0xf0,0x22,0x90,0x97,0x7a,0xe0,0x2f,0xf0,0x22,0xe4,0xf5,
+0x64,0x90,0x97,0x8f,0xf0,0xf5,0x65,0x90,0x97,0x8b,0x74,0x0c,0xf0,0x90,0x97,0x88,
+0xf0,0xe4,0x90,0x97,0x8d,0xf0,0x90,0x97,0x87,0xf0,0x90,0x97,0x86,0xf0,0x90,0x97,
+0x8a,0x04,0xf0,0x90,0x97,0x7f,0xf0,0xe4,0x90,0x97,0x8e,0xf0,0x90,0x97,0x89,0xf0,
+0x90,0x97,0x81,0xf0,0x90,0x97,0x85,0x74,0x07,0xf0,0xe4,0x90,0x97,0x80,0xf0,0x90,
+0x97,0x83,0xf0,0xa3,0x74,0x02,0xf0,0xe4,0x90,0x97,0x8c,0xf0,0x22,0xe4,0x90,0x97,
+0xad,0xf0,0xa3,0xf0,0x90,0x01,0xc4,0x74,0x1d,0xf0,0x74,0x7a,0xa3,0xf0,0x90,0x05,
+0xf8,0xe0,0x70,0x0f,0xa3,0xe0,0x70,0x0b,0xa3,0xe0,0x70,0x07,0xa3,0xe0,0x70,0x03,
+0x7f,0x01,0x22,0xd3,0x90,0x97,0xae,0xe0,0x94,0xe8,0x90,0x97,0xad,0xe0,0x94,0x03,
+0x40,0x03,0x7f,0x00,0x22,0x7f,0x32,0x7e,0x00,0x12,0x3a,0xa8,0x90,0x97,0xae,0xe0,
+0x04,0xf0,0x70,0xca,0x90,0x97,0xad,0xe0,0x04,0xf0,0x80,0xc2,0xe4,0x90,0x97,0x95,
+0xf0,0xa2,0xaf,0x33,0x90,0x97,0x3b,0xf0,0x90,0x00,0x80,0xe0,0x20,0xe1,0x1a,0x12,
+0x3a,0xbe,0x12,0x3a,0xbe,0x90,0x97,0x3a,0xe0,0x64,0x01,0xf0,0xe0,0x24,0x6c,0x90,
+0x01,0xc4,0xf0,0x74,0x7a,0xa3,0xf0,0x80,0xdf,0x90,0x06,0x30,0x74,0x01,0xf0,0xc2,
+0xaf,0x90,0x00,0x80,0xe0,0x44,0x80,0xf0,0x7f,0x10,0x7e,0x00,0x12,0x3a,0xa8,0x90,
+0x97,0x3b,0xe0,0x24,0xff,0x92,0xaf,0x22,0x90,0x01,0xc4,0x74,0xb8,0xf0,0x74,0x7a,
+0xa3,0xf0,0xe5,0x55,0x70,0x37,0x90,0x97,0x8b,0xe0,0x54,0x0f,0xd3,0x94,0x01,0x50,
+0x2c,0x90,0x02,0x87,0xe0,0x70,0x26,0x90,0x97,0x96,0xe0,0xb4,0x02,0x10,0x90,0x97,
+0x90,0xe0,0xfe,0xa3,0xe0,0xf5,0x82,0x8e,0x83,0xe0,0x60,0x08,0x80,0x0f,0x90,0x01,
+0xaf,0xe0,0x70,0x09,0x90,0x97,0x8c,0xe0,0x60,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,
+0x90,0x97,0x8e,0xe0,0x60,0x12,0xe4,0xf0,0xa3,0xe0,0x54,0xfd,0xf0,0xe0,0x54,0x03,
+0x70,0x33,0x90,0x97,0x89,0xf0,0x80,0x23,0x90,0x97,0x80,0xe0,0x04,0xf0,0x90,0x97,
+0x8f,0xe0,0x54,0xef,0xf0,0x90,0x97,0x80,0xe0,0xd3,0x94,0x01,0x40,0x0d,0xe5,0x64,
+0xb4,0x01,0x12,0xa3,0xe0,0x70,0x0e,0xe0,0x04,0xf0,0x22,0x90,0x97,0x8b,0xe0,0xff,
+0x7d,0x01,0x12,0x6e,0xda,0x22,0xe4,0x90,0x97,0x3a,0xf0,0xef,0x90,0x00,0x31,0xf0,
+0xee,0x54,0x03,0xff,0xa3,0xe0,0x54,0xfc,0x4f,0xf0,0xa3,0xe0,0x54,0x7f,0xf0,0x90,
+0x00,0x30,0xe0,0x20,0xe7,0x0e,0x90,0x97,0x3a,0xe0,0xc3,0x94,0x64,0x50,0x05,0xe0,
+0x04,0xf0,0x80,0xeb,0x90,0x97,0x3a,0xe0,0xc3,0x94,0x64,0x50,0x0a,0x90,0x00,0x30,
+0xe0,0x12,0x65,0x95,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x01,0xc4,0x74,0x8a,0xf0,
+0x74,0x7b,0xa3,0xf0,0x90,0x04,0x1b,0xe0,0x54,0x7f,0x64,0x7f,0x70,0x2b,0x90,0x97,
+0x89,0xe0,0x64,0x01,0x60,0x23,0x90,0x97,0x8b,0xe0,0x54,0x0f,0xd3,0x94,0x02,0x50,
+0x18,0x90,0x97,0x8f,0xe0,0x20,0xe4,0x11,0x90,0x97,0x87,0xe0,0x64,0x01,0x60,0x09,
+0x90,0x97,0x81,0xe0,0x70,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0x8f,0x66,0x90,0x01,
+0xc4,0x74,0xcc,0xf0,0x74,0x7b,0xa3,0xf0,0x90,0x97,0x94,0xe0,0xff,0x7d,0x01,0x12,
+0x71,0xc9,0xe5,0x66,0x60,0x10,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,
+0xe0,0x44,0x10,0xf0,0x80,0x0e,0x74,0x21,0x2f,0xf5,0x82,0xe4,0x34,0xfc,0xf5,0x83,
+0xe0,0x54,0xef,0xf0,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0x12,0x1c,0xd6,0xff,0xc3,
+0x94,0x20,0x50,0x15,0x90,0x00,0x02,0x12,0x1c,0xef,0xfe,0x74,0x23,0x2f,0xf5,0x82,
+0xe4,0x34,0x95,0xf5,0x83,0xee,0xf0,0x80,0x0e,0xef,0xb4,0x20,0x0a,0x90,0x00,0x02,
+0x12,0x1c,0xef,0x90,0x93,0x61,0xf0,0x74,0x23,0x2f,0xf5,0x82,0xe4,0x34,0x95,0xf5,
+0x83,0xe0,0x90,0x04,0xb2,0xf0,0x22,0x90,0x01,0x37,0x74,0x02,0xf0,0x90,0x05,0x22,
+0x74,0xff,0xf0,0x12,0x7a,0x1d,0xef,0x70,0x06,0x90,0x01,0xc8,0x74,0xfd,0xf0,0x7d,
+0x02,0x7f,0x03,0x12,0x3a,0x2f,0xe5,0x65,0x60,0x05,0x7f,0x01,0x12,0x7e,0x99,0x12,
+0x6c,0x30,0x90,0x97,0x88,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,0x22,0x90,0x00,
+0x02,0x12,0x1c,0xef,0x90,0x97,0x6d,0xf0,0xe0,0x90,0x04,0x9b,0xf0,0x90,0x97,0x6d,
+0xe0,0x60,0x04,0xe0,0xb4,0xff,0x1c,0xa2,0xaf,0xe4,0x33,0xf5,0x10,0xc2,0xaf,0x90,
+0x00,0x47,0xe0,0x54,0xfb,0xf0,0x7d,0x40,0x7f,0x01,0x12,0x39,0xf8,0xe5,0x10,0x24,
+0xff,0x92,0xaf,0x22,0x90,0x97,0x4a,0xee,0xf0,0xa3,0xef,0xf0,0x75,0x5e,0x01,0x8e,
+0x5f,0xf5,0x60,0x7f,0x0b,0x12,0x75,0xcf,0x12,0x7e,0x61,0xe4,0xff,0x12,0x7f,0x1b,
+0x90,0x97,0x4a,0xe0,0xfc,0xa3,0xe0,0xfd,0xec,0xfb,0x8d,0x48,0xe4,0xf5,0x49,0x7d,
+0x01,0x7f,0x60,0x7e,0x01,0x02,0x38,0xec,0x7d,0x02,0x7f,0x03,0x12,0x39,0xbe,0xe5,
+0x65,0x60,0x23,0x90,0x97,0x8d,0xe0,0x60,0x06,0x7d,0x01,0x7f,0x0c,0x80,0x0f,0x90,
+0x97,0x88,0xe0,0x54,0x0f,0xc3,0x94,0x04,0x50,0x07,0x7d,0x01,0x7f,0x04,0x12,0x6e,
+0xda,0xe4,0xff,0x12,0x7e,0x99,0x22,0x90,0x02,0x09,0xe0,0xfd,0x12,0x1c,0xd6,0xfe,
+0xaf,0x05,0xed,0x2e,0x90,0x97,0x92,0xf0,0x90,0x00,0x01,0x12,0x1c,0xef,0xff,0xed,
+0x2f,0x90,0x97,0x93,0xf0,0x90,0x00,0x02,0x12,0x1c,0xef,0xff,0xae,0x05,0xed,0x2f,
+0x90,0x97,0x94,0xf0,0x22,0x90,0x06,0x34,0xe0,0x60,0x26,0x14,0x70,0x1b,0x7b,0x01,
+0x7a,0x06,0x79,0x35,0x7f,0xf9,0x7e,0x01,0x12,0x7b,0x46,0xbf,0x01,0x09,0x90,0x06,
+0x35,0xe0,0x54,0x0f,0xf0,0x80,0x05,0x80,0x00,0x02,0x7f,0x00,0xe4,0x90,0x06,0x34,
+0xf0,0x22,0x90,0x01,0xc4,0x74,0x72,0xf0,0x74,0x7d,0xa3,0xf0,0x90,0x04,0x1b,0xe0,
+0x54,0x7f,0xff,0xbf,0x7f,0x14,0x90,0x97,0x87,0xe0,0x70,0x0e,0x90,0x97,0x8b,0xe0,
+0x54,0x0f,0xd3,0x94,0x04,0x50,0x03,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x00,0x01,
+0x12,0x1c,0xef,0x90,0x97,0x8d,0xf0,0x12,0x1c,0xd6,0x65,0x65,0x60,0x15,0xa2,0xaf,
+0xe4,0x33,0x90,0x97,0x46,0xf0,0xc2,0xaf,0x12,0x78,0x17,0x90,0x97,0x46,0xe0,0x24,
+0xff,0x92,0xaf,0x22,0x90,0x97,0x2e,0xe0,0x54,0xf0,0x44,0x03,0xf0,0x54,0x0f,0x44,
+0x80,0xf0,0x90,0x97,0x33,0xe4,0xf0,0xa3,0x74,0x00,0xf0,0xa3,0x74,0x56,0xf0,0x7b,
+0x01,0x7a,0x97,0x79,0x2e,0x02,0x70,0x66,0x90,0x06,0x04,0xe0,0x54,0xbf,0xf0,0xef,
+0x60,0x0a,0xe5,0x64,0xb4,0x01,0x05,0xe4,0xff,0x12,0x7b,0xcc,0x90,0x97,0x88,0xe0,
+0x54,0xf0,0xf0,0xe0,0x44,0x0c,0xf0,0x22,0x90,0x97,0xb2,0xef,0xf0,0x12,0x71,0x1c,
+0x90,0x97,0xb2,0xe0,0x60,0x05,0x90,0x05,0x22,0xe4,0xf0,0x90,0x97,0x88,0xe0,0x54,
+0xf0,0xf0,0xe0,0x44,0x04,0xf0,0x22,0x90,0x06,0x04,0xe0,0x44,0x40,0xf0,0xe5,0x64,
+0xb4,0x01,0x05,0x7f,0x01,0x12,0x7b,0xcc,0x90,0x97,0x88,0xe0,0x54,0xf0,0xf0,0xe0,
+0x44,0x04,0xf0,0x22,0x90,0x97,0x88,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x01,0xf0,0x12,
+0x77,0xb5,0x12,0x78,0x75,0x90,0x97,0x88,0xe0,0x54,0xf0,0xf0,0xe0,0x44,0x02,0xf0,
+0x22,0x7f,0x0b,0x12,0x72,0x6f,0xef,0x65,0x61,0x60,0x10,0xe5,0x61,0xb4,0x01,0x05,
+0xe4,0xf5,0x61,0x80,0x03,0x75,0x61,0x01,0x7f,0x01,0x22,0x7f,0x00,0x22,0x90,0x01,
+0xc4,0x74,0x7e,0xf0,0x74,0x7e,0xa3,0xf0,0x90,0x97,0x93,0xe0,0xff,0xe4,0xfd,0x12,
+0x71,0xc9,0x90,0x04,0x1f,0x74,0x01,0xf0,0x22,0xef,0x60,0x0b,0x90,0x97,0x97,0xe0,
+0xb4,0x01,0x10,0xe4,0xff,0x80,0x09,0x90,0x97,0x97,0xe0,0xb4,0x01,0x05,0x7f,0x01,
+0x12,0x4e,0x3b,0x22,0x90,0x00,0x49,0xe0,0x90,0x97,0xb4,0xf0,0xe0,0x54,0x0f,0xf0,
+0xe0,0xff,0x44,0xf0,0x90,0x00,0x49,0xf0,0xef,0x44,0xb0,0xf0,0x22,0xe4,0x90,0x97,
+0x8e,0xf0,0x90,0x97,0x80,0xf0,0x90,0x97,0x89,0xf0,0x90,0x97,0x8f,0xf0,0x22,0xe5,
+0x5e,0xb4,0x01,0x0b,0x12,0x7e,0x61,0xbf,0x01,0x05,0x7f,0x01,0x12,0x7f,0x1b,0x22,
+0x90,0x09,0x28,0xef,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,
+0x90,0x06,0x34,0x74,0xff,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0xa3,0xf0,0x22,0x41,0x97,
+0xb1,0x00,0x41,0x97,0x7e,0x80,0x41,0x97,0xb3,0x00,0x00,0x90,0x01,0xca,0xe5,0x61,
+0xf0,0xef,0x60,0x03,0x12,0x7e,0xb4,0x22,0x90,0x97,0x46,0xeb,0xf0,0xa3,0xea,0xf0,
+0xa3,0xe9,0xf0,0x22,0x90,0x97,0xa7,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x22,
+0x90,0x97,0xaa,0xeb,0xf0,0xa3,0xea,0xf0,0xa3,0xe9,0xf0,0x22,0x8f,0x82,0x8e,0x83,
+0xa3,0xa3,0xa3,0xe4,0xf0,0x22,0xe4,0xf5,0x5e,0x7f,0x60,0x7e,0x01,0x02,0x7f,0x4c,
+0x90,0x97,0x97,0xe0,0x90,0x97,0x2d,0xf0,0x22,0x8f,0x1b,0x8c,0x1c,0x8d,0x1d,0x22,
+0x8f,0x1e,0x8c,0x1f,0x8d,0x20,0x22,0x12,0x1c,0xd6,0xf5,0x64,0x22,0x22,0x52,0x09,
+};
+
+u32 Rtl8192CUPHY_REG_2TArray[PHY_REG_2TArrayLength] = {
+0x024,0x0011800d,
+0x028,0x00ffdb83,
+0x800,0x80040002,
+0x804,0x00000003,
+0x808,0x0000fc00,
+0x80c,0x0000000a,
+0x810,0x10005388,
+0x814,0x020c3d10,
+0x818,0x02200385,
+0x81c,0x00000000,
+0x820,0x01000100,
+0x824,0x00390004,
+0x828,0x01000100,
+0x82c,0x00390004,
+0x830,0x27272727,
+0x834,0x27272727,
+0x838,0x27272727,
+0x83c,0x27272727,
+0x840,0x00010000,
+0x844,0x00010000,
+0x848,0x27272727,
+0x84c,0x27272727,
+0x850,0x00000000,
+0x854,0x00000000,
+0x858,0x569a569a,
+0x85c,0x0c1b25a4,
+0x860,0x66e60230,
+0x864,0x061f0130,
+0x868,0x27272727,
+0x86c,0x2b2b2b27,
+0x870,0x07000700,
+0x874,0x22184000,
+0x878,0x08080808,
+0x87c,0x00000000,
+0x880,0xc0083070,
+0x884,0x000004d5,
+0x888,0x00000000,
+0x88c,0xcc0000c0,
+0x890,0x00000800,
+0x894,0xfffffffe,
+0x898,0x40302010,
+0x89c,0x00706050,
+0x900,0x00000000,
+0x904,0x00000023,
+0x908,0x00000000,
+0x90c,0x81121313,
+0xa00,0x00d047c8,
+0xa04,0x80ff000c,
+0xa08,0x8c838300,
+0xa0c,0x2e68120f,
+0xa10,0x9500bb78,
+0xa14,0x11144028,
+0xa18,0x00881117,
+0xa1c,0x89140f00,
+0xa20,0x1a1b0000,
+0xa24,0x090e1317,
+0xa28,0x00000204,
+0xa2c,0x00d30000,
+0xa70,0x101fbf00,
+0xa74,0x00000007,
+0xc00,0x48071d40,
+0xc04,0x03a05633,
+0xc08,0x000000e4,
+0xc0c,0x6c6c6c6c,
+0xc10,0x08800000,
+0xc14,0x40000100,
+0xc18,0x08800000,
+0xc1c,0x40000100,
+0xc20,0x00000000,
+0xc24,0x00000000,
+0xc28,0x00000000,
+0xc2c,0x00000000,
+0xc30,0x69e9ac44,
+0xc34,0x469652cf,
+0xc38,0x49795994,
+0xc3c,0x0a97971c,
+0xc40,0x1f7c403f,
+0xc44,0x000100b7,
+0xc48,0xec020107,
+0xc4c,0x007f037f,
+0xc50,0x6954341e,
+0xc54,0x43bc0094,
+0xc58,0x6954341e,
+0xc5c,0x433c0094,
+0xc60,0x00000000,
+0xc64,0x5116848b,
+0xc68,0x47c00bff,
+0xc6c,0x00000036,
+0xc70,0x2c7f000d,
+0xc74,0x0186115b,
+0xc78,0x0000001f,
+0xc7c,0x00b99612,
+0xc80,0x40000100,
+0xc84,0x20f60000,
+0xc88,0x40000100,
+0xc8c,0x20200000,
+0xc90,0x00121820,
+0xc94,0x00000000,
+0xc98,0x00121820,
+0xc9c,0x00007f7f,
+0xca0,0x00000000,
+0xca4,0x00000080,
+0xca8,0x00000000,
+0xcac,0x00000000,
+0xcb0,0x00000000,
+0xcb4,0x00000000,
+0xcb8,0x00000000,
+0xcbc,0x28000000,
+0xcc0,0x00000000,
+0xcc4,0x00000000,
+0xcc8,0x00000000,
+0xccc,0x00000000,
+0xcd0,0x00000000,
+0xcd4,0x00000000,
+0xcd8,0x64b22427,
+0xcdc,0x00766932,
+0xce0,0x00222222,
+0xce4,0x00000000,
+0xce8,0x37644302,
+0xcec,0x2f97d40c,
+0xd00,0x00080740,
+0xd04,0x00020403,
+0xd08,0x0000907f,
+0xd0c,0x20010201,
+0xd10,0xa0633333,
+0xd14,0x3333bc43,
+0xd18,0x7a8f5b6b,
+0xd2c,0xcc979975,
+0xd30,0x00000000,
+0xd34,0x80608000,
+0xd38,0x00000000,
+0xd3c,0x00027293,
+0xd40,0x00000000,
+0xd44,0x00000000,
+0xd48,0x00000000,
+0xd4c,0x00000000,
+0xd50,0x6437140a,
+0xd54,0x00000000,
+0xd58,0x00000000,
+0xd5c,0x30032064,
+0xd60,0x4653de68,
+0xd64,0x04518a3c,
+0xd68,0x00002101,
+0xd6c,0x2a201c16,
+0xd70,0x1812362e,
+0xd74,0x322c2220,
+0xd78,0x000e3c24,
+0xe00,0x2a2a2a2a,
+0xe04,0x2a2a2a2a,
+0xe08,0x03902a2a,
+0xe10,0x2a2a2a2a,
+0xe14,0x2a2a2a2a,
+0xe18,0x2a2a2a2a,
+0xe1c,0x2a2a2a2a,
+0xe28,0x00000000,
+0xe30,0x1000dc1f,
+0xe34,0x10008c1f,
+0xe38,0x02140102,
+0xe3c,0x681604c2,
+0xe40,0x01007c00,
+0xe44,0x01004800,
+0xe48,0xfb000000,
+0xe4c,0x000028d1,
+0xe50,0x1000dc1f,
+0xe54,0x10008c1f,
+0xe58,0x02140102,
+0xe5c,0x28160d05,
+0xe60,0x00000010,
+0xe68,0x001b25a4,
+0xe6c,0x63db25a4,
+0xe70,0x63db25a4,
+0xe74,0x0c1b25a4,
+0xe78,0x0c1b25a4,
+0xe7c,0x0c1b25a4,
+0xe80,0x0c1b25a4,
+0xe84,0x63db25a4,
+0xe88,0x0c1b25a4,
+0xe8c,0x63db25a4,
+0xed0,0x63db25a4,
+0xed4,0x63db25a4,
+0xed8,0x63db25a4,
+0xedc,0x001b25a4,
+0xee0,0x001b25a4,
+0xeec,0x6fdb25a4,
+0xf14,0x00000003,
+0xf4c,0x00000000,
+0xf00,0x00000300,
+};
+
+u32 Rtl8192CUPHY_REG_1TArray[PHY_REG_1TArrayLength] = {
+0x024,0x0011800d,
+0x028,0x00ffdb83,
+0x800,0x80040000,
+0x804,0x00000001,
+0x808,0x0000fc00,
+0x80c,0x0000000a,
+0x810,0x10005388,
+0x814,0x020c3d10,
+0x818,0x02200385,
+0x81c,0x00000000,
+0x820,0x01000100,
+0x824,0x00390004,
+0x828,0x00000000,
+0x82c,0x00000000,
+0x830,0x00000000,
+0x834,0x00000000,
+0x838,0x00000000,
+0x83c,0x00000000,
+0x840,0x00010000,
+0x844,0x00000000,
+0x848,0x00000000,
+0x84c,0x00000000,
+0x850,0x00000000,
+0x854,0x00000000,
+0x858,0x569a569a,
+0x85c,0x001b25a4,
+0x860,0x66e60230,
+0x864,0x061f0130,
+0x868,0x00000000,
+0x86c,0x32323200,
+0x870,0x07000700,
+0x874,0x22004000,
+0x878,0x00000808,
+0x87c,0x00000000,
+0x880,0xc0083070,
+0x884,0x000004d5,
+0x888,0x00000000,
+0x88c,0xccc000c0,
+0x890,0x00000800,
+0x894,0xfffffffe,
+0x898,0x40302010,
+0x89c,0x00706050,
+0x900,0x00000000,
+0x904,0x00000023,
+0x908,0x00000000,
+0x90c,0x81121111,
+0xa00,0x00d047c8,
+0xa04,0x80ff000c,
+0xa08,0x8c838300,
+0xa0c,0x2e68120f,
+0xa10,0x9500bb78,
+0xa14,0x11144028,
+0xa18,0x00881117,
+0xa1c,0x89140f00,
+0xa20,0x1a1b0000,
+0xa24,0x090e1317,
+0xa28,0x00000204,
+0xa2c,0x00d30000,
+0xa70,0x101fbf00,
+0xa74,0x00000007,
+0xc00,0x48071d40,
+0xc04,0x03a05611,
+0xc08,0x000000e4,
+0xc0c,0x6c6c6c6c,
+0xc10,0x08800000,
+0xc14,0x40000100,
+0xc18,0x08800000,
+0xc1c,0x40000100,
+0xc20,0x00000000,
+0xc24,0x00000000,
+0xc28,0x00000000,
+0xc2c,0x00000000,
+0xc30,0x69e9ac44,
+0xc34,0x469652cf,
+0xc38,0x49795994,
+0xc3c,0x0a97971c,
+0xc40,0x1f7c403f,
+0xc44,0x000100b7,
+0xc48,0xec020107,
+0xc4c,0x007f037f,
+0xc50,0x6954341e,
+0xc54,0x43bc0094,
+0xc58,0x6954341e,
+0xc5c,0x433c0094,
+0xc60,0x00000000,
+0xc64,0x5116848b,
+0xc68,0x47c00bff,
+0xc6c,0x00000036,
+0xc70,0x2c7f000d,
+0xc74,0x018610db,
+0xc78,0x0000001f,
+0xc7c,0x00b91612,
+0xc80,0x40000100,
+0xc84,0x20f60000,
+0xc88,0x40000100,
+0xc8c,0x20200000,
+0xc90,0x00121820,
+0xc94,0x00000000,
+0xc98,0x00121820,
+0xc9c,0x00007f7f,
+0xca0,0x00000000,
+0xca4,0x00000080,
+0xca8,0x00000000,
+0xcac,0x00000000,
+0xcb0,0x00000000,
+0xcb4,0x00000000,
+0xcb8,0x00000000,
+0xcbc,0x28000000,
+0xcc0,0x00000000,
+0xcc4,0x00000000,
+0xcc8,0x00000000,
+0xccc,0x00000000,
+0xcd0,0x00000000,
+0xcd4,0x00000000,
+0xcd8,0x64b22427,
+0xcdc,0x00766932,
+0xce0,0x00222222,
+0xce4,0x00000000,
+0xce8,0x37644302,
+0xcec,0x2f97d40c,
+0xd00,0x00080740,
+0xd04,0x00020401,
+0xd08,0x0000907f,
+0xd0c,0x20010201,
+0xd10,0xa0633333,
+0xd14,0x3333bc43,
+0xd18,0x7a8f5b6b,
+0xd2c,0xcc979975,
+0xd30,0x00000000,
+0xd34,0x80608000,
+0xd38,0x00000000,
+0xd3c,0x00027293,
+0xd40,0x00000000,
+0xd44,0x00000000,
+0xd48,0x00000000,
+0xd4c,0x00000000,
+0xd50,0x6437140a,
+0xd54,0x00000000,
+0xd58,0x00000000,
+0xd5c,0x30032064,
+0xd60,0x4653de68,
+0xd64,0x04518a3c,
+0xd68,0x00002101,
+0xd6c,0x2a201c16,
+0xd70,0x1812362e,
+0xd74,0x322c2220,
+0xd78,0x000e3c24,
+0xe00,0x2a2a2a2a,
+0xe04,0x2a2a2a2a,
+0xe08,0x03902a2a,
+0xe10,0x2a2a2a2a,
+0xe14,0x2a2a2a2a,
+0xe18,0x2a2a2a2a,
+0xe1c,0x2a2a2a2a,
+0xe28,0x00000000,
+0xe30,0x1000dc1f,
+0xe34,0x10008c1f,
+0xe38,0x02140102,
+0xe3c,0x681604c2,
+0xe40,0x01007c00,
+0xe44,0x01004800,
+0xe48,0xfb000000,
+0xe4c,0x000028d1,
+0xe50,0x1000dc1f,
+0xe54,0x10008c1f,
+0xe58,0x02140102,
+0xe5c,0x28160d05,
+0xe60,0x00000008,
+0xe68,0x001b25a4,
+0xe6c,0x631b25a0,
+0xe70,0x631b25a0,
+0xe74,0x081b25a0,
+0xe78,0x081b25a0,
+0xe7c,0x081b25a0,
+0xe80,0x081b25a0,
+0xe84,0x631b25a0,
+0xe88,0x081b25a0,
+0xe8c,0x631b25a0,
+0xed0,0x631b25a0,
+0xed4,0x631b25a0,
+0xed8,0x631b25a0,
+0xedc,0x001b25a0,
+0xee0,0x001b25a0,
+0xeec,0x6b1b25a0,
+0xf14,0x00000003,
+0xf4c,0x00000000,
+0xf00,0x00000300,
+};
+
+u32 Rtl8192CUPHY_ChangeTo_1T1RArray[PHY_ChangeTo_1T1RArrayLength] = {
+0x0, };
+
+u32 Rtl8192CUPHY_ChangeTo_1T2RArray[PHY_ChangeTo_1T2RArrayLength] = {
+0x0, };
+
+u32 Rtl8192CUPHY_ChangeTo_2T2RArray[PHY_ChangeTo_2T2RArrayLength] = {
+0x0, };
+
+u32 Rtl8192CUPHY_REG_Array_PG[PHY_REG_Array_PGLength] = {
+0xe00,0xffffffff,0x0a0c0c0c,
+0xe04,0xffffffff,0x02040608,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x0a0c0d0e,
+0xe14,0xffffffff,0x02040608,
+0xe18,0xffffffff,0x0a0c0d0e,
+0xe1c,0xffffffff,0x02040608,
+0x830,0xffffffff,0x0a0c0c0c,
+0x834,0xffffffff,0x02040608,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x0a0c0d0e,
+0x848,0xffffffff,0x02040608,
+0x84c,0xffffffff,0x0a0c0d0e,
+0x868,0xffffffff,0x02040608,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x04040404,
+0xe04,0xffffffff,0x00020204,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x06060606,
+0xe14,0xffffffff,0x00020406,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x04040404,
+0x834,0xffffffff,0x00020204,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x06060606,
+0x848,0xffffffff,0x00020406,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x04040404,
+0xe04,0xffffffff,0x00020204,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x04040404,
+0x834,0xffffffff,0x00020204,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+};
+
+u32  Rtl8192CUPHY_REG_Array_PG_mCard[PHY_REG_Array_PG_mCardLength] = {
+0xe00,0xffffffff,0x0a0c0c0c,
+0xe04,0xffffffff,0x02040608,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x0a0c0d0e,
+0xe14,0xffffffff,0x02040608,
+0xe18,0xffffffff,0x0a0c0d0e,
+0xe1c,0xffffffff,0x02040608,
+0x830,0xffffffff,0x0a0c0c0c,
+0x834,0xffffffff,0x02040608,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x0a0c0d0e,
+0x848,0xffffffff,0x02040608,
+0x84c,0xffffffff,0x0a0c0d0e,
+0x868,0xffffffff,0x02040608,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x04040404,
+0xe04,0xffffffff,0x00020204,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x06060606,
+0xe14,0xffffffff,0x00020406,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x04040404,
+0x834,0xffffffff,0x00020204,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x06060606,
+0x848,0xffffffff,0x00020406,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x04040404,
+0xe04,0xffffffff,0x00020204,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x04040404,
+0x834,0xffffffff,0x00020204,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+};
+
+u32 Rtl8192CUPHY_REG_Array_MP[PHY_REG_Array_MPLength] = {
+0xc30,0x69e9ac4a,
+0xc3c,0x0a979718,
+};
+
+u32 Rtl8192CUPHY_REG_1T_HPArray[PHY_REG_1T_HPArrayLength] = {
+0x024,0x0011800d,
+0x028,0x00ffdb83,
+0x040,0x000c0004,
+0x800,0x80040000,
+0x804,0x00000001,
+0x808,0x0000fc00,
+0x80c,0x0000000a,
+0x810,0x10005388,
+0x814,0x020c3d10,
+0x818,0x02200385,
+0x81c,0x00000000,
+0x820,0x01000100,
+0x824,0x00390204,
+0x828,0x00000000,
+0x82c,0x00000000,
+0x830,0x00000000,
+0x834,0x00000000,
+0x838,0x00000000,
+0x83c,0x00000000,
+0x840,0x00010000,
+0x844,0x00000000,
+0x848,0x00000000,
+0x84c,0x00000000,
+0x850,0x00000000,
+0x854,0x00000000,
+0x858,0x569a569a,
+0x85c,0x001b25a4,
+0x860,0x66e60230,
+0x864,0x061f0130,
+0x868,0x00000000,
+0x86c,0x32323200,
+0x870,0x03000300,
+0x874,0x22004000,
+0x878,0x00000808,
+0x87c,0x00ffc3f1,
+0x880,0xc0083070,
+0x884,0x000004d5,
+0x888,0x00000000,
+0x88c,0xccc000c0,
+0x890,0x00000800,
+0x894,0xfffffffe,
+0x898,0x40302010,
+0x89c,0x00706050,
+0x900,0x00000000,
+0x904,0x00000023,
+0x908,0x00000000,
+0x90c,0x81121111,
+0xa00,0x00d047c8,
+0xa04,0x80ff000c,
+0xa08,0x8c838300,
+0xa0c,0x2e68120f,
+0xa10,0x9500bb78,
+0xa14,0x11144028,
+0xa18,0x00881117,
+0xa1c,0x89140f00,
+0xa20,0x15160000,
+0xa24,0x070b0f12,
+0xa28,0x00000104,
+0xa2c,0x00d30000,
+0xa70,0x101fbf00,
+0xa74,0x00000007,
+0xc00,0x48071d40,
+0xc04,0x03a05611,
+0xc08,0x000000e4,
+0xc0c,0x6c6c6c6c,
+0xc10,0x08800000,
+0xc14,0x40000100,
+0xc18,0x08800000,
+0xc1c,0x40000100,
+0xc20,0x00000000,
+0xc24,0x00000000,
+0xc28,0x00000000,
+0xc2c,0x00000000,
+0xc30,0x69e9ac44,
+0xc34,0x469652cf,
+0xc38,0x49795994,
+0xc3c,0x0a97971c,
+0xc40,0x1f7c403f,
+0xc44,0x000100b7,
+0xc48,0xec020107,
+0xc4c,0x007f037f,
+0xc50,0x6954342e,
+0xc54,0x43bc0094,
+0xc58,0x6954342f,
+0xc5c,0x433c0094,
+0xc60,0x00000000,
+0xc64,0x5116848b,
+0xc68,0x47c00bff,
+0xc6c,0x00000036,
+0xc70,0x2c56000d,
+0xc74,0x018610db,
+0xc78,0x0000001f,
+0xc7c,0x00b91612,
+0xc80,0x24000090,
+0xc84,0x20f60000,
+0xc88,0x24000090,
+0xc8c,0x20200000,
+0xc90,0x00121820,
+0xc94,0x00000000,
+0xc98,0x00121820,
+0xc9c,0x00007f7f,
+0xca0,0x00000000,
+0xca4,0x00000080,
+0xca8,0x00000000,
+0xcac,0x00000000,
+0xcb0,0x00000000,
+0xcb4,0x00000000,
+0xcb8,0x00000000,
+0xcbc,0x28000000,
+0xcc0,0x00000000,
+0xcc4,0x00000000,
+0xcc8,0x00000000,
+0xccc,0x00000000,
+0xcd0,0x00000000,
+0xcd4,0x00000000,
+0xcd8,0x64b22427,
+0xcdc,0x00766932,
+0xce0,0x00222222,
+0xce4,0x00000000,
+0xce8,0x37644302,
+0xcec,0x2f97d40c,
+0xd00,0x00080740,
+0xd04,0x00020401,
+0xd08,0x0000907f,
+0xd0c,0x20010201,
+0xd10,0xa0633333,
+0xd14,0x3333bc43,
+0xd18,0x7a8f5b6b,
+0xd2c,0xcc979975,
+0xd30,0x00000000,
+0xd34,0x80608000,
+0xd38,0x00000000,
+0xd3c,0x00027293,
+0xd40,0x00000000,
+0xd44,0x00000000,
+0xd48,0x00000000,
+0xd4c,0x00000000,
+0xd50,0x6437140a,
+0xd54,0x00000000,
+0xd58,0x00000000,
+0xd5c,0x30032064,
+0xd60,0x4653de68,
+0xd64,0x04518a3c,
+0xd68,0x00002101,
+0xd6c,0x2a201c16,
+0xd70,0x1812362e,
+0xd74,0x322c2220,
+0xd78,0x000e3c24,
+0xe00,0x2a2a2a2a,
+0xe04,0x2a2a2a2a,
+0xe08,0x03902a2a,
+0xe10,0x2a2a2a2a,
+0xe14,0x2a2a2a2a,
+0xe18,0x2a2a2a2a,
+0xe1c,0x2a2a2a2a,
+0xe28,0x00000000,
+0xe30,0x1000dc1f,
+0xe34,0x10008c1f,
+0xe38,0x02140102,
+0xe3c,0x681604c2,
+0xe40,0x01007c00,
+0xe44,0x01004800,
+0xe48,0xfb000000,
+0xe4c,0x000028d1,
+0xe50,0x1000dc1f,
+0xe54,0x10008c1f,
+0xe58,0x02140102,
+0xe5c,0x28160d05,
+0xe60,0x00000010,
+0xe68,0x001b25a4,
+0xe6c,0x631b25a0,
+0xe70,0x631b25a0,
+0xe74,0x081b25a0,
+0xe78,0x081b25a0,
+0xe7c,0x081b25a0,
+0xe80,0x081b25a0,
+0xe84,0x631b25a0,
+0xe88,0x081b25a0,
+0xe8c,0x631b25a0,
+0xed0,0x631b25a0,
+0xed4,0x631b25a0,
+0xed8,0x631b25a0,
+0xedc,0x001b25a0,
+0xee0,0x001b25a0,
+0xeec,0x6b1b25a0,
+0xee8,0x31555448,
+0xf14,0x00000003,
+0xf4c,0x00000000,
+0xf00,0x00000300,
+};
+
+u32 Rtl8192CUPHY_REG_1T_mCardArray[PHY_REG_1T_mCardArrayLength] = {
+0x024,0x0011800d,
+0x028,0x00ffdb83,
+0x800,0x80040000,
+0x804,0x00000001,
+0x808,0x0000fc00,
+0x80c,0x0000000a,
+0x810,0x10005388,
+0x814,0x020c3d10,
+0x818,0x02200385,
+0x81c,0x00000000,
+0x820,0x01000100,
+0x824,0x00390004,
+0x828,0x00000000,
+0x82c,0x00000000,
+0x830,0x00000000,
+0x834,0x00000000,
+0x838,0x00000000,
+0x83c,0x00000000,
+0x840,0x00010000,
+0x844,0x00000000,
+0x848,0x00000000,
+0x84c,0x00000000,
+0x850,0x00000000,
+0x854,0x00000000,
+0x858,0x569a569a,
+0x85c,0x001b25a4,
+0x860,0x66e60230,
+0x864,0x061f0130,
+0x868,0x00000000,
+0x86c,0x32323200,
+0x870,0x07000700,
+0x874,0x22004000,
+0x878,0x00000808,
+0x87c,0x00000000,
+0x880,0xc0083070,
+0x884,0x000004d5,
+0x888,0x00000000,
+0x88c,0xccc000c0,
+0x890,0x00000800,
+0x894,0xfffffffe,
+0x898,0x40302010,
+0x89c,0x00706050,
+0x900,0x00000000,
+0x904,0x00000023,
+0x908,0x00000000,
+0x90c,0x81121111,
+0xa00,0x00d047c8,
+0xa04,0x80ff000c,
+0xa08,0x8c838300,
+0xa0c,0x2e68120f,
+0xa10,0x9500bb78,
+0xa14,0x11144028,
+0xa18,0x00881117,
+0xa1c,0x89140f00,
+0xa20,0x1a1b0000,
+0xa24,0x090e1317,
+0xa28,0x00000204,
+0xa2c,0x00d30000,
+0xa70,0x101fbf00,
+0xa74,0x00000007,
+0xc00,0x48071d40,
+0xc04,0x03a05611,
+0xc08,0x000000e4,
+0xc0c,0x6c6c6c6c,
+0xc10,0x08800000,
+0xc14,0x40000100,
+0xc18,0x08800000,
+0xc1c,0x40000100,
+0xc20,0x00000000,
+0xc24,0x00000000,
+0xc28,0x00000000,
+0xc2c,0x00000000,
+0xc30,0x69e9ac44,
+0xc34,0x469652cf,
+0xc38,0x49795994,
+0xc3c,0x0a97971c,
+0xc40,0x1f7c403f,
+0xc44,0x000100b7,
+0xc48,0xec020107,
+0xc4c,0x007f037f,
+0xc50,0x6954341e,
+0xc54,0x43bc0094,
+0xc58,0x6954341e,
+0xc5c,0x433c0094,
+0xc60,0x00000000,
+0xc64,0x5116848b,
+0xc68,0x47c00bff,
+0xc6c,0x00000036,
+0xc70,0x2c7f000d,
+0xc74,0x018610db,
+0xc78,0x0000001f,
+0xc7c,0x00b91612,
+0xc80,0x40000100,
+0xc84,0x20f60000,
+0xc88,0x40000100,
+0xc8c,0x20200000,
+0xc90,0x00121820,
+0xc94,0x00000000,
+0xc98,0x00121820,
+0xc9c,0x00007f7f,
+0xca0,0x00000000,
+0xca4,0x00000080,
+0xca8,0x00000000,
+0xcac,0x00000000,
+0xcb0,0x00000000,
+0xcb4,0x00000000,
+0xcb8,0x00000000,
+0xcbc,0x28000000,
+0xcc0,0x00000000,
+0xcc4,0x00000000,
+0xcc8,0x00000000,
+0xccc,0x00000000,
+0xcd0,0x00000000,
+0xcd4,0x00000000,
+0xcd8,0x64b22427,
+0xcdc,0x00766932,
+0xce0,0x00222222,
+0xce4,0x00000000,
+0xce8,0x37644302,
+0xcec,0x2f97d40c,
+0xd00,0x00080740,
+0xd04,0x00020401,
+0xd08,0x0000907f,
+0xd0c,0x20010201,
+0xd10,0xa0633333,
+0xd14,0x3333bc43,
+0xd18,0x7a8f5b6b,
+0xd2c,0xcc979975,
+0xd30,0x00000000,
+0xd34,0x80608000,
+0xd38,0x00000000,
+0xd3c,0x00027293,
+0xd40,0x00000000,
+0xd44,0x00000000,
+0xd48,0x00000000,
+0xd4c,0x00000000,
+0xd50,0x6437140a,
+0xd54,0x00000000,
+0xd58,0x00000000,
+0xd5c,0x30032064,
+0xd60,0x4653de68,
+0xd64,0x04518a3c,
+0xd68,0x00002101,
+0xd6c,0x2a201c16,
+0xd70,0x1812362e,
+0xd74,0x322c2220,
+0xd78,0x000e3c24,
+0xe00,0x2a2a2a2a,
+0xe04,0x2a2a2a2a,
+0xe08,0x03902a2a,
+0xe10,0x2a2a2a2a,
+0xe14,0x2a2a2a2a,
+0xe18,0x2a2a2a2a,
+0xe1c,0x2a2a2a2a,
+0xe28,0x00000000,
+0xe30,0x1000dc1f,
+0xe34,0x10008c1f,
+0xe38,0x02140102,
+0xe3c,0x681604c2,
+0xe40,0x01007c00,
+0xe44,0x01004800,
+0xe48,0xfb000000,
+0xe4c,0x000028d1,
+0xe50,0x1000dc1f,
+0xe54,0x10008c1f,
+0xe58,0x02140102,
+0xe5c,0x28160d05,
+0xe60,0x00000008,
+0xe68,0x001b25a4,
+0xe6c,0x631b25a0,
+0xe70,0x631b25a0,
+0xe74,0x081b25a0,
+0xe78,0x081b25a0,
+0xe7c,0x081b25a0,
+0xe80,0x081b25a0,
+0xe84,0x631b25a0,
+0xe88,0x081b25a0,
+0xe8c,0x631b25a0,
+0xed0,0x631b25a0,
+0xed4,0x631b25a0,
+0xed8,0x631b25a0,
+0xedc,0x001b25a0,
+0xee0,0x001b25a0,
+0xeec,0x6b1b25a0,
+0xf14,0x00000003,
+0xf4c,0x00000000,
+0xf00,0x00000300,
+};
+
+u32 Rtl8192CUPHY_REG_2T_mCardArray[PHY_REG_2T_mCardArrayLength] = {
+0x024,0x0011800d,
+0x028,0x00ffdb83,
+0x800,0x80040002,
+0x804,0x00000003,
+0x808,0x0000fc00,
+0x80c,0x0000000a,
+0x810,0x10005388,
+0x814,0x020c3d10,
+0x818,0x02200385,
+0x81c,0x00000000,
+0x820,0x01000100,
+0x824,0x00390004,
+0x828,0x01000100,
+0x82c,0x00390004,
+0x830,0x27272727,
+0x834,0x27272727,
+0x838,0x27272727,
+0x83c,0x27272727,
+0x840,0x00010000,
+0x844,0x00010000,
+0x848,0x27272727,
+0x84c,0x27272727,
+0x850,0x00000000,
+0x854,0x00000000,
+0x858,0x569a569a,
+0x85c,0x0c1b25a4,
+0x860,0x66e60230,
+0x864,0x061f0130,
+0x868,0x27272727,
+0x86c,0x2b2b2b27,
+0x870,0x07000700,
+0x874,0x22184000,
+0x878,0x08080808,
+0x87c,0x00000000,
+0x880,0xc0083070,
+0x884,0x000004d5,
+0x888,0x00000000,
+0x88c,0xcc0000c0,
+0x890,0x00000800,
+0x894,0xfffffffe,
+0x898,0x40302010,
+0x89c,0x00706050,
+0x900,0x00000000,
+0x904,0x00000023,
+0x908,0x00000000,
+0x90c,0x81121313,
+0xa00,0x00d047c8,
+0xa04,0x80ff000c,
+0xa08,0x8c838300,
+0xa0c,0x2e68120f,
+0xa10,0x9500bb78,
+0xa14,0x11144028,
+0xa18,0x00881117,
+0xa1c,0x89140f00,
+0xa20,0x1a1b0000,
+0xa24,0x090e1317,
+0xa28,0x00000204,
+0xa2c,0x00d30000,
+0xa70,0x101fbf00,
+0xa74,0x00000007,
+0xc00,0x48071d40,
+0xc04,0x03a05633,
+0xc08,0x000000e4,
+0xc0c,0x6c6c6c6c,
+0xc10,0x08800000,
+0xc14,0x40000100,
+0xc18,0x08800000,
+0xc1c,0x40000100,
+0xc20,0x00000000,
+0xc24,0x00000000,
+0xc28,0x00000000,
+0xc2c,0x00000000,
+0xc30,0x69e9ac44,
+0xc34,0x469652cf,
+0xc38,0x49795994,
+0xc3c,0x0a97971c,
+0xc40,0x1f7c403f,
+0xc44,0x000100b7,
+0xc48,0xec020107,
+0xc4c,0x007f037f,
+0xc50,0x6954341e,
+0xc54,0x43bc0094,
+0xc58,0x6954341e,
+0xc5c,0x433c0094,
+0xc60,0x00000000,
+0xc64,0x5116848b,
+0xc68,0x47c00bff,
+0xc6c,0x00000036,
+0xc70,0x2c7f000d,
+0xc74,0x018610db,
+0xc78,0x0000001f,
+0xc7c,0x00b91612,
+0xc80,0x40000100,
+0xc84,0x20f60000,
+0xc88,0x40000100,
+0xc8c,0x20200000,
+0xc90,0x00121820,
+0xc94,0x00000000,
+0xc98,0x00121820,
+0xc9c,0x00007f7f,
+0xca0,0x00000000,
+0xca4,0x00000080,
+0xca8,0x00000000,
+0xcac,0x00000000,
+0xcb0,0x00000000,
+0xcb4,0x00000000,
+0xcb8,0x00000000,
+0xcbc,0x28000000,
+0xcc0,0x00000000,
+0xcc4,0x00000000,
+0xcc8,0x00000000,
+0xccc,0x00000000,
+0xcd0,0x00000000,
+0xcd4,0x00000000,
+0xcd8,0x64b22427,
+0xcdc,0x00766932,
+0xce0,0x00222222,
+0xce4,0x00000000,
+0xce8,0x37644302,
+0xcec,0x2f97d40c,
+0xd00,0x00080740,
+0xd04,0x00020403,
+0xd08,0x0000907f,
+0xd0c,0x20010201,
+0xd10,0xa0633333,
+0xd14,0x3333bc43,
+0xd18,0x7a8f5b6b,
+0xd2c,0xcc979975,
+0xd30,0x00000000,
+0xd34,0x80608000,
+0xd38,0x00000000,
+0xd3c,0x00027293,
+0xd40,0x00000000,
+0xd44,0x00000000,
+0xd48,0x00000000,
+0xd4c,0x00000000,
+0xd50,0x6437140a,
+0xd54,0x00000000,
+0xd58,0x00000000,
+0xd5c,0x30032064,
+0xd60,0x4653de68,
+0xd64,0x04518a3c,
+0xd68,0x00002101,
+0xd6c,0x2a201c16,
+0xd70,0x1812362e,
+0xd74,0x322c2220,
+0xd78,0x000e3c24,
+0xe00,0x2a2a2a2a,
+0xe04,0x2a2a2a2a,
+0xe08,0x03902a2a,
+0xe10,0x2a2a2a2a,
+0xe14,0x2a2a2a2a,
+0xe18,0x2a2a2a2a,
+0xe1c,0x2a2a2a2a,
+0xe28,0x00000000,
+0xe30,0x1000dc1f,
+0xe34,0x10008c1f,
+0xe38,0x02140102,
+0xe3c,0x681604c2,
+0xe40,0x01007c00,
+0xe44,0x01004800,
+0xe48,0xfb000000,
+0xe4c,0x000028d1,
+0xe50,0x1000dc1f,
+0xe54,0x10008c1f,
+0xe58,0x02140102,
+0xe5c,0x28160d05,
+0xe60,0x00000010,
+0xe68,0x001b25a4,
+0xe6c,0x63db25a4,
+0xe70,0x63db25a4,
+0xe74,0x0c1b25a4,
+0xe78,0x0c1b25a4,
+0xe7c,0x0c1b25a4,
+0xe80,0x0c1b25a4,
+0xe84,0x63db25a4,
+0xe88,0x0c1b25a4,
+0xe8c,0x63db25a4,
+0xed0,0x63db25a4,
+0xed4,0x63db25a4,
+0xed8,0x63db25a4,
+0xedc,0x001b25a4,
+0xee0,0x001b25a4,
+0xeec,0x6fdb25a4,
+0xf14,0x00000003,
+0xf4c,0x00000000,
+0xf00,0x00000300,
+};
+
+u32 Rtl8192CUPHY_REG_Array_PG_HP[PHY_REG_Array_PG_HPLength] = {
+0xe00,0xffffffff,0x06080808,
+0xe04,0xffffffff,0x00040406,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x04060608,
+0xe14,0xffffffff,0x00020204,
+0xe18,0xffffffff,0x04060608,
+0xe1c,0xffffffff,0x00020204,
+0x830,0xffffffff,0x06080808,
+0x834,0xffffffff,0x00040406,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x04060608,
+0x848,0xffffffff,0x00020204,
+0x84c,0xffffffff,0x04060608,
+0x868,0xffffffff,0x00020204,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+0xe00,0xffffffff,0x00000000,
+0xe04,0xffffffff,0x00000000,
+0xe08,0x0000ff00,0x00000000,
+0x86c,0xffffff00,0x00000000,
+0xe10,0xffffffff,0x00000000,
+0xe14,0xffffffff,0x00000000,
+0xe18,0xffffffff,0x00000000,
+0xe1c,0xffffffff,0x00000000,
+0x830,0xffffffff,0x00000000,
+0x834,0xffffffff,0x00000000,
+0x838,0xffffff00,0x00000000,
+0x86c,0x000000ff,0x00000000,
+0x83c,0xffffffff,0x00000000,
+0x848,0xffffffff,0x00000000,
+0x84c,0xffffffff,0x00000000,
+0x868,0xffffffff,0x00000000,
+};
+
+u32 Rtl8192CURadioA_2TArray[RadioA_2TArrayLength] = {
+0x000,0x00030159,
+0x001,0x00031284,
+0x002,0x00098000,
+0x003,0x00018c63,
+0x004,0x000210e7,
+0x009,0x0002044f,
+0x00a,0x0001adb1,
+0x00b,0x00054867,
+0x00c,0x0008992e,
+0x00d,0x0000e52c,
+0x00e,0x00039ce7,
+0x00f,0x00000451,
+0x019,0x00000000,
+0x01a,0x00010255,
+0x01b,0x00060a00,
+0x01c,0x000fc378,
+0x01d,0x000a1250,
+0x01e,0x0004445f,
+0x01f,0x00080001,
+0x020,0x0000b614,
+0x021,0x0006c000,
+0x022,0x00000000,
+0x023,0x00001558,
+0x024,0x00000060,
+0x025,0x00000483,
+0x026,0x0004f000,
+0x027,0x000ec7d9,
+0x028,0x000577c0,
+0x029,0x00004783,
+0x02a,0x00000001,
+0x02b,0x00021334,
+0x02a,0x00000000,
+0x02b,0x00000054,
+0x02a,0x00000001,
+0x02b,0x00000808,
+0x02b,0x00053333,
+0x02c,0x0000000c,
+0x02a,0x00000002,
+0x02b,0x00000808,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000003,
+0x02b,0x00000808,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000004,
+0x02b,0x00000808,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x00000005,
+0x02b,0x00000808,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x00000006,
+0x02b,0x00000709,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000007,
+0x02b,0x00000709,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000008,
+0x02b,0x0000060a,
+0x02b,0x0004b333,
+0x02c,0x0000000d,
+0x02a,0x00000009,
+0x02b,0x0000060a,
+0x02b,0x00053333,
+0x02c,0x0000000d,
+0x02a,0x0000000a,
+0x02b,0x0000060a,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x0000000b,
+0x02b,0x0000060a,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x0000000c,
+0x02b,0x0000060a,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x0000000d,
+0x02b,0x0000060a,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x0000000e,
+0x02b,0x0000050b,
+0x02b,0x00066666,
+0x02c,0x0000001a,
+0x02a,0x000e0000,
+0x010,0x0004000f,
+0x011,0x000e31fc,
+0x010,0x0006000f,
+0x011,0x000ff9f8,
+0x010,0x0002000f,
+0x011,0x000203f9,
+0x010,0x0003000f,
+0x011,0x000ff500,
+0x010,0x00000000,
+0x011,0x00000000,
+0x010,0x0008000f,
+0x011,0x0003f100,
+0x010,0x0009000f,
+0x011,0x00023100,
+0x012,0x00032000,
+0x012,0x00071000,
+0x012,0x000b0000,
+0x012,0x000fc000,
+0x013,0x000287af,
+0x013,0x000244b7,
+0x013,0x000204ab,
+0x013,0x0001c49f,
+0x013,0x00018493,
+0x013,0x00014297,
+0x013,0x00010295,
+0x013,0x0000c298,
+0x013,0x0000819c,
+0x013,0x000040a8,
+0x013,0x0000001c,
+0x014,0x0001944c,
+0x014,0x00059444,
+0x014,0x0009944c,
+0x014,0x000d9444,
+0x015,0x0000f424,
+0x015,0x0004f424,
+0x015,0x0008f424,
+0x015,0x000cf424,
+0x016,0x000e0330,
+0x016,0x000a0330,
+0x016,0x00060330,
+0x016,0x00020330,
+0x000,0x00010159,
+0x018,0x0000f401,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01f,0x00080003,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01e,0x00044457,
+0x01f,0x00080000,
+0x000,0x00030159,
+};
+
+u32 Rtl8192CURadioB_2TArray[RadioB_2TArrayLength] = {
+0x000,0x00030159,
+0x001,0x00031284,
+0x002,0x00098000,
+0x003,0x00018c63,
+0x004,0x000210e7,
+0x009,0x0002044f,
+0x00a,0x0001adb1,
+0x00b,0x00054867,
+0x00c,0x0008992e,
+0x00d,0x0000e52c,
+0x00e,0x00039ce7,
+0x00f,0x00000451,
+0x012,0x00032000,
+0x012,0x00071000,
+0x012,0x000b0000,
+0x012,0x000fc000,
+0x013,0x000287af,
+0x013,0x000244b7,
+0x013,0x000204ab,
+0x013,0x0001c49f,
+0x013,0x00018493,
+0x013,0x00014297,
+0x013,0x00010295,
+0x013,0x0000c298,
+0x013,0x0000819c,
+0x013,0x000040a8,
+0x013,0x0000001c,
+0x014,0x0001944c,
+0x014,0x00059444,
+0x014,0x0009944c,
+0x014,0x000d9444,
+0x015,0x0000f424,
+0x015,0x0004f424,
+0x015,0x0008f424,
+0x015,0x000cf424,
+0x016,0x000e0330,
+0x016,0x000a0330,
+0x016,0x00060330,
+0x016,0x00020330,
+};
+
+u32 Rtl8192CURadioA_1TArray[RadioA_1TArrayLength] = {
+0x000,0x00030159,
+0x001,0x00031284,
+0x002,0x00098000,
+0x003,0x00018c63,
+0x004,0x000210e7,
+0x009,0x0002044f,
+0x00a,0x0001adb1,
+0x00b,0x00054867,
+0x00c,0x0008992e,
+0x00d,0x0000e52c,
+0x00e,0x00039ce7,
+0x00f,0x00000451,
+0x019,0x00000000,
+0x01a,0x00010255,
+0x01b,0x00060a00,
+0x01c,0x000fc378,
+0x01d,0x000a1250,
+0x01e,0x0004445f,
+0x01f,0x00080001,
+0x020,0x0000b614,
+0x021,0x0006c000,
+0x022,0x00000000,
+0x023,0x00001558,
+0x024,0x00000060,
+0x025,0x00000483,
+0x026,0x0004f000,
+0x027,0x000ec7d9,
+0x028,0x000577c0,
+0x029,0x00004783,
+0x02a,0x00000001,
+0x02b,0x00021334,
+0x02a,0x00000000,
+0x02b,0x00000054,
+0x02a,0x00000001,
+0x02b,0x00000808,
+0x02b,0x00053333,
+0x02c,0x0000000c,
+0x02a,0x00000002,
+0x02b,0x00000808,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000003,
+0x02b,0x00000808,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000004,
+0x02b,0x00000808,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x00000005,
+0x02b,0x00000808,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x00000006,
+0x02b,0x00000709,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000007,
+0x02b,0x00000709,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000008,
+0x02b,0x0000060a,
+0x02b,0x0004b333,
+0x02c,0x0000000d,
+0x02a,0x00000009,
+0x02b,0x0000060a,
+0x02b,0x00053333,
+0x02c,0x0000000d,
+0x02a,0x0000000a,
+0x02b,0x0000060a,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x0000000b,
+0x02b,0x0000060a,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x0000000c,
+0x02b,0x0000060a,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x0000000d,
+0x02b,0x0000060a,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x0000000e,
+0x02b,0x0000050b,
+0x02b,0x00066666,
+0x02c,0x0000001a,
+0x02a,0x000e0000,
+0x010,0x0004000f,
+0x011,0x000e31fc,
+0x010,0x0006000f,
+0x011,0x000ff9f8,
+0x010,0x0002000f,
+0x011,0x000203f9,
+0x010,0x0003000f,
+0x011,0x000ff500,
+0x010,0x00000000,
+0x011,0x00000000,
+0x010,0x0008000f,
+0x011,0x0003f100,
+0x010,0x0009000f,
+0x011,0x00023100,
+0x012,0x00032000,
+0x012,0x00071000,
+0x012,0x000b0000,
+0x012,0x000fc000,
+0x013,0x000287b3,
+0x013,0x000244b7,
+0x013,0x000204ab,
+0x013,0x0001c49f,
+0x013,0x00018493,
+0x013,0x0001429b,
+0x013,0x00010299,
+0x013,0x0000c29c,
+0x013,0x000081a0,
+0x013,0x000040ac,
+0x013,0x00000020,
+0x014,0x0001944c,
+0x014,0x00059444,
+0x014,0x0009944c,
+0x014,0x000d9444,
+0x015,0x0000f405,
+0x015,0x0004f405,
+0x015,0x0008f405,
+0x015,0x000cf405,
+0x016,0x000e0330,
+0x016,0x000a0330,
+0x016,0x00060330,
+0x016,0x00020330,
+0x000,0x00010159,
+0x018,0x0000f401,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01f,0x00080003,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01e,0x00044457,
+0x01f,0x00080000,
+0x000,0x00030159,
+};
+
+u32 Rtl8192CURadioB_1TArray[RadioB_1TArrayLength] = {
+0x0, };
+
+
+u32 Rtl8192CURadioA_1T_mCardArray[RadioA_1T_mCardArrayLength] = {
+0x000,0x00030159,
+0x001,0x00031284,
+0x002,0x00098000,
+0x003,0x00018c63,
+0x004,0x000210e7,
+0x009,0x0002044f,
+0x00a,0x0001adb1,
+0x00b,0x00054867,
+0x00c,0x0008992e,
+0x00d,0x0000e52c,
+0x00e,0x00039ce7,
+0x00f,0x00000451,
+0x019,0x00000000,
+0x01a,0x00010255,
+0x01b,0x00060a00,
+0x01c,0x000fc378,
+0x01d,0x000a1250,
+0x01e,0x0004445f,
+0x01f,0x00080001,
+0x020,0x0000b614,
+0x021,0x0006c000,
+0x022,0x00000000,
+0x023,0x00001558,
+0x024,0x00000060,
+0x025,0x00000483,
+0x026,0x0004f200,
+0x027,0x000ec7d9,
+0x028,0x000577c0,
+0x029,0x00004783,
+0x02a,0x00000001,
+0x02b,0x00021334,
+0x02a,0x00000000,
+0x02b,0x00000054,
+0x02a,0x00000001,
+0x02b,0x00000808,
+0x02b,0x00053333,
+0x02c,0x0000000c,
+0x02a,0x00000002,
+0x02b,0x00000808,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000003,
+0x02b,0x00000808,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000004,
+0x02b,0x00000808,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x00000005,
+0x02b,0x00000808,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x00000006,
+0x02b,0x00000709,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000007,
+0x02b,0x00000709,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000008,
+0x02b,0x0000060a,
+0x02b,0x0004b333,
+0x02c,0x0000000d,
+0x02a,0x00000009,
+0x02b,0x0000060a,
+0x02b,0x00053333,
+0x02c,0x0000000d,
+0x02a,0x0000000a,
+0x02b,0x0000060a,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x0000000b,
+0x02b,0x0000060a,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x0000000c,
+0x02b,0x0000060a,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x0000000d,
+0x02b,0x0000060a,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x0000000e,
+0x02b,0x0000050b,
+0x02b,0x00066666,
+0x02c,0x0000001a,
+0x02a,0x000e0000,
+0x010,0x0004000f,
+0x011,0x000e31fc,
+0x010,0x0006000f,
+0x011,0x000ff9f8,
+0x010,0x0002000f,
+0x011,0x000203f9,
+0x010,0x0003000f,
+0x011,0x000ff500,
+0x010,0x00000000,
+0x011,0x00000000,
+0x010,0x0008000f,
+0x011,0x0003f100,
+0x010,0x0009000f,
+0x011,0x00023100,
+0x012,0x00032000,
+0x012,0x00071000,
+0x012,0x000b0000,
+0x012,0x000fc000,
+0x013,0x000287b3,
+0x013,0x000244b7,
+0x013,0x000204ab,
+0x013,0x0001c49f,
+0x013,0x00018493,
+0x013,0x0001429b,
+0x013,0x00010299,
+0x013,0x0000c29c,
+0x013,0x000081a0,
+0x013,0x000040ac,
+0x013,0x00000020,
+0x014,0x0001944c,
+0x014,0x00059444,
+0x014,0x0009944c,
+0x014,0x000d9444,
+0x015,0x0000f424,
+0x015,0x0004f424,
+0x015,0x0008f424,
+0x015,0x000cf424,
+0x016,0x000e0330,
+0x016,0x000a0330,
+0x016,0x00060330,
+0x016,0x00020330,
+0x000,0x00010159,
+0x018,0x0000f401,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01f,0x00080003,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01e,0x00044457,
+0x01f,0x00080000,
+0x000,0x00030159,
+};
+
+u32 Rtl8192CURadioB_1T_mCardArray[RadioB_1T_mCardArrayLength] = {
+0x0, };
+
+u32 Rtl8192CURadioA_1T_HPArray[RadioA_1T_HPArrayLength] = {
+0x000,0x00030159,
+0x001,0x00031284,
+0x002,0x00098000,
+0x003,0x00018c63,
+0x004,0x000210e7,
+0x009,0x0002044f,
+0x00a,0x0001adb0,
+0x00b,0x00054867,
+0x00c,0x0008992e,
+0x00d,0x0000e529,
+0x00e,0x00039ce7,
+0x00f,0x00000451,
+0x019,0x00000000,
+0x01a,0x00000255,
+0x01b,0x00060a00,
+0x01c,0x000fc378,
+0x01d,0x000a1250,
+0x01e,0x0004445f,
+0x01f,0x00080001,
+0x020,0x0000b614,
+0x021,0x0006c000,
+0x022,0x0000083c,
+0x023,0x00001558,
+0x024,0x00000060,
+0x025,0x00000483,
+0x026,0x0004f000,
+0x027,0x000ec7d9,
+0x028,0x000977c0,
+0x029,0x00004783,
+0x02a,0x00000001,
+0x02b,0x00021334,
+0x02a,0x00000000,
+0x02b,0x00000054,
+0x02a,0x00000001,
+0x02b,0x00000808,
+0x02b,0x00053333,
+0x02c,0x0000000c,
+0x02a,0x00000002,
+0x02b,0x00000808,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000003,
+0x02b,0x00000808,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000004,
+0x02b,0x00000808,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x00000005,
+0x02b,0x00000808,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x00000006,
+0x02b,0x00000709,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x00000007,
+0x02b,0x00000709,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x00000008,
+0x02b,0x0000060a,
+0x02b,0x0004b333,
+0x02c,0x0000000d,
+0x02a,0x00000009,
+0x02b,0x0000060a,
+0x02b,0x00053333,
+0x02c,0x0000000d,
+0x02a,0x0000000a,
+0x02b,0x0000060a,
+0x02b,0x0005b333,
+0x02c,0x0000000d,
+0x02a,0x0000000b,
+0x02b,0x0000060a,
+0x02b,0x00063333,
+0x02c,0x0000000d,
+0x02a,0x0000000c,
+0x02b,0x0000060a,
+0x02b,0x0006b333,
+0x02c,0x0000000d,
+0x02a,0x0000000d,
+0x02b,0x0000060a,
+0x02b,0x00073333,
+0x02c,0x0000000d,
+0x02a,0x0000000e,
+0x02b,0x0000050b,
+0x02b,0x00066666,
+0x02c,0x0000001a,
+0x02a,0x000e0000,
+0x010,0x0004000f,
+0x011,0x000e31fc,
+0x010,0x0006000f,
+0x011,0x000ff9f8,
+0x010,0x0002000f,
+0x011,0x000203f9,
+0x010,0x0003000f,
+0x011,0x000ff500,
+0x010,0x00000000,
+0x011,0x00000000,
+0x010,0x0008000f,
+0x011,0x0003f100,
+0x010,0x0009000f,
+0x011,0x00023100,
+0x012,0x000d8000,
+0x012,0x00090000,
+0x012,0x00051000,
+0x012,0x00012000,
+0x013,0x00028fb4,
+0x013,0x00024fa8,
+0x013,0x000207a4,
+0x013,0x0001c798,
+0x013,0x000183a4,
+0x013,0x00014398,
+0x013,0x000101a4,
+0x013,0x0000c198,
+0x013,0x000080a4,
+0x013,0x00004098,
+0x013,0x00000014,
+0x014,0x0001944c,
+0x014,0x00059444,
+0x014,0x0009944c,
+0x014,0x000d9444,
+0x015,0x0000f405,
+0x015,0x0004f405,
+0x015,0x0008f405,
+0x015,0x000cf405,
+0x016,0x000e0330,
+0x016,0x000a0330,
+0x016,0x00060330,
+0x016,0x00020330,
+0x000,0x00010159,
+0x018,0x0000f401,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01f,0x00080003,
+0x0fe,0x00000000,
+0x0fe,0x00000000,
+0x01e,0x00044457,
+0x01f,0x00080000,
+0x000,0x00030159,
+};
+
+u32 Rtl8192CURadioB_GM_Array[RadioB_GM_ArrayLength] = {
+0x0, };
+
+// MAC reg V12 - 2010-07-16
+u32 Rtl8192CUMAC_2T_Array[MAC_2T_ArrayLength] = {
+0x420,0x00000080,
+0x423,0x00000000,
+0x430,0x00000000,
+0x431,0x00000000,
+0x432,0x00000000,
+0x433,0x00000001,
+0x434,0x00000004,
+0x435,0x00000005,
+0x436,0x00000006,
+0x437,0x00000007,
+0x438,0x00000000,
+0x439,0x00000000,
+0x43a,0x00000000,
+0x43b,0x00000001,
+0x43c,0x00000004,
+0x43d,0x00000005,
+0x43e,0x00000006,
+0x43f,0x00000007,
+0x440,0x0000005d,
+0x441,0x00000001,
+0x442,0x00000000,
+0x444,0x00000015,
+0x445,0x000000f0,
+0x446,0x0000000f,
+0x447,0x00000000,
+0x458,0x00000041,
+0x459,0x000000a8,
+0x45a,0x00000072,
+0x45b,0x000000b9,
+0x460,0x00000066,
+0x461,0x00000066,
+0x462,0x00000008,
+0x463,0x00000003,
+0x4c8,0x000000ff,
+0x4c9,0x00000008,
+0x4cc,0x000000ff,
+0x4cd,0x000000ff,
+0x4ce,0x00000001,
+0x500,0x00000026,
+0x501,0x000000a2,
+0x502,0x0000002f,
+0x503,0x00000000,
+0x504,0x00000028,
+0x505,0x000000a3,
+0x506,0x0000005e,
+0x507,0x00000000,
+0x508,0x0000002b,
+0x509,0x000000a4,
+0x50a,0x0000005e,
+0x50b,0x00000000,
+0x50c,0x0000004f,
+0x50d,0x000000a4,
+0x50e,0x00000000,
+0x50f,0x00000000,
+0x512,0x0000001c,
+0x514,0x0000000a,
+0x515,0x00000010,
+0x516,0x0000000a,
+0x517,0x00000010,
+0x51a,0x00000016,
+0x524,0x0000000f,
+0x525,0x0000004f,
+0x546,0x00000040,
+0x547,0x00000000,
+0x550,0x00000010,
+0x551,0x00000010,
+0x559,0x00000002,
+0x55a,0x00000002,
+0x55d,0x000000ff,
+0x605,0x00000030,
+0x608,0x0000000e,
+0x609,0x0000002a,
+0x652,0x00000020,
+0x63c,0x0000000a,
+0x63d,0x0000000e,
+0x63e,0x0000000a,
+0x63f,0x0000000e,
+0x66e,0x00000005,
+0x700,0x00000021,
+0x701,0x00000043,
+0x702,0x00000065,
+0x703,0x00000087,
+0x708,0x00000021,
+0x709,0x00000043,
+0x70a,0x00000065,
+0x70b,0x00000087,
+};
+
+u32 Rtl8192CUMACPHY_Array_PG[MACPHY_Array_PGLength] = {
+0x0, };
+
+u32 Rtl8192CUAGCTAB_2TArray[AGCTAB_2TArrayLength] = {
+0xc78,0x7b000001,
+0xc78,0x7b010001,
+0xc78,0x7b020001,
+0xc78,0x7b030001,
+0xc78,0x7b040001,
+0xc78,0x7b050001,
+0xc78,0x7a060001,
+0xc78,0x79070001,
+0xc78,0x78080001,
+0xc78,0x77090001,
+0xc78,0x760a0001,
+0xc78,0x750b0001,
+0xc78,0x740c0001,
+0xc78,0x730d0001,
+0xc78,0x720e0001,
+0xc78,0x710f0001,
+0xc78,0x70100001,
+0xc78,0x6f110001,
+0xc78,0x6e120001,
+0xc78,0x6d130001,
+0xc78,0x6c140001,
+0xc78,0x6b150001,
+0xc78,0x6a160001,
+0xc78,0x69170001,
+0xc78,0x68180001,
+0xc78,0x67190001,
+0xc78,0x661a0001,
+0xc78,0x651b0001,
+0xc78,0x641c0001,
+0xc78,0x631d0001,
+0xc78,0x621e0001,
+0xc78,0x611f0001,
+0xc78,0x60200001,
+0xc78,0x49210001,
+0xc78,0x48220001,
+0xc78,0x47230001,
+0xc78,0x46240001,
+0xc78,0x45250001,
+0xc78,0x44260001,
+0xc78,0x43270001,
+0xc78,0x42280001,
+0xc78,0x41290001,
+0xc78,0x402a0001,
+0xc78,0x262b0001,
+0xc78,0x252c0001,
+0xc78,0x242d0001,
+0xc78,0x232e0001,
+0xc78,0x222f0001,
+0xc78,0x21300001,
+0xc78,0x20310001,
+0xc78,0x06320001,
+0xc78,0x05330001,
+0xc78,0x04340001,
+0xc78,0x03350001,
+0xc78,0x02360001,
+0xc78,0x01370001,
+0xc78,0x00380001,
+0xc78,0x00390001,
+0xc78,0x003a0001,
+0xc78,0x003b0001,
+0xc78,0x003c0001,
+0xc78,0x003d0001,
+0xc78,0x003e0001,
+0xc78,0x003f0001,
+0xc78,0x7b400001,
+0xc78,0x7b410001,
+0xc78,0x7b420001,
+0xc78,0x7b430001,
+0xc78,0x7b440001,
+0xc78,0x7b450001,
+0xc78,0x7a460001,
+0xc78,0x79470001,
+0xc78,0x78480001,
+0xc78,0x77490001,
+0xc78,0x764a0001,
+0xc78,0x754b0001,
+0xc78,0x744c0001,
+0xc78,0x734d0001,
+0xc78,0x724e0001,
+0xc78,0x714f0001,
+0xc78,0x70500001,
+0xc78,0x6f510001,
+0xc78,0x6e520001,
+0xc78,0x6d530001,
+0xc78,0x6c540001,
+0xc78,0x6b550001,
+0xc78,0x6a560001,
+0xc78,0x69570001,
+0xc78,0x68580001,
+0xc78,0x67590001,
+0xc78,0x665a0001,
+0xc78,0x655b0001,
+0xc78,0x645c0001,
+0xc78,0x635d0001,
+0xc78,0x625e0001,
+0xc78,0x615f0001,
+0xc78,0x60600001,
+0xc78,0x49610001,
+0xc78,0x48620001,
+0xc78,0x47630001,
+0xc78,0x46640001,
+0xc78,0x45650001,
+0xc78,0x44660001,
+0xc78,0x43670001,
+0xc78,0x42680001,
+0xc78,0x41690001,
+0xc78,0x406a0001,
+0xc78,0x266b0001,
+0xc78,0x256c0001,
+0xc78,0x246d0001,
+0xc78,0x236e0001,
+0xc78,0x226f0001,
+0xc78,0x21700001,
+0xc78,0x20710001,
+0xc78,0x06720001,
+0xc78,0x05730001,
+0xc78,0x04740001,
+0xc78,0x03750001,
+0xc78,0x02760001,
+0xc78,0x01770001,
+0xc78,0x00780001,
+0xc78,0x00790001,
+0xc78,0x007a0001,
+0xc78,0x007b0001,
+0xc78,0x007c0001,
+0xc78,0x007d0001,
+0xc78,0x007e0001,
+0xc78,0x007f0001,
+0xc78,0x3800001e,
+0xc78,0x3801001e,
+0xc78,0x3802001e,
+0xc78,0x3803001e,
+0xc78,0x3804001e,
+0xc78,0x3805001e,
+0xc78,0x3806001e,
+0xc78,0x3807001e,
+0xc78,0x3808001e,
+0xc78,0x3c09001e,
+0xc78,0x3e0a001e,
+0xc78,0x400b001e,
+0xc78,0x440c001e,
+0xc78,0x480d001e,
+0xc78,0x4c0e001e,
+0xc78,0x500f001e,
+0xc78,0x5210001e,
+0xc78,0x5611001e,
+0xc78,0x5a12001e,
+0xc78,0x5e13001e,
+0xc78,0x6014001e,
+0xc78,0x6015001e,
+0xc78,0x6016001e,
+0xc78,0x6217001e,
+0xc78,0x6218001e,
+0xc78,0x6219001e,
+0xc78,0x621a001e,
+0xc78,0x621b001e,
+0xc78,0x621c001e,
+0xc78,0x621d001e,
+0xc78,0x621e001e,
+0xc78,0x621f001e,
+};
+
+u32 Rtl8192CUAGCTAB_1TArray[AGCTAB_1TArrayLength] = {
+0xc78,0x7b000001,
+0xc78,0x7b010001,
+0xc78,0x7b020001,
+0xc78,0x7b030001,
+0xc78,0x7b040001,
+0xc78,0x7b050001,
+0xc78,0x7a060001,
+0xc78,0x79070001,
+0xc78,0x78080001,
+0xc78,0x77090001,
+0xc78,0x760a0001,
+0xc78,0x750b0001,
+0xc78,0x740c0001,
+0xc78,0x730d0001,
+0xc78,0x720e0001,
+0xc78,0x710f0001,
+0xc78,0x70100001,
+0xc78,0x6f110001,
+0xc78,0x6e120001,
+0xc78,0x6d130001,
+0xc78,0x6c140001,
+0xc78,0x6b150001,
+0xc78,0x6a160001,
+0xc78,0x69170001,
+0xc78,0x68180001,
+0xc78,0x67190001,
+0xc78,0x661a0001,
+0xc78,0x651b0001,
+0xc78,0x641c0001,
+0xc78,0x631d0001,
+0xc78,0x621e0001,
+0xc78,0x611f0001,
+0xc78,0x60200001,
+0xc78,0x49210001,
+0xc78,0x48220001,
+0xc78,0x47230001,
+0xc78,0x46240001,
+0xc78,0x45250001,
+0xc78,0x44260001,
+0xc78,0x43270001,
+0xc78,0x42280001,
+0xc78,0x41290001,
+0xc78,0x402a0001,
+0xc78,0x262b0001,
+0xc78,0x252c0001,
+0xc78,0x242d0001,
+0xc78,0x232e0001,
+0xc78,0x222f0001,
+0xc78,0x21300001,
+0xc78,0x20310001,
+0xc78,0x06320001,
+0xc78,0x05330001,
+0xc78,0x04340001,
+0xc78,0x03350001,
+0xc78,0x02360001,
+0xc78,0x01370001,
+0xc78,0x00380001,
+0xc78,0x00390001,
+0xc78,0x003a0001,
+0xc78,0x003b0001,
+0xc78,0x003c0001,
+0xc78,0x003d0001,
+0xc78,0x003e0001,
+0xc78,0x003f0001,
+0xc78,0x7b400001,
+0xc78,0x7b410001,
+0xc78,0x7b420001,
+0xc78,0x7b430001,
+0xc78,0x7b440001,
+0xc78,0x7b450001,
+0xc78,0x7a460001,
+0xc78,0x79470001,
+0xc78,0x78480001,
+0xc78,0x77490001,
+0xc78,0x764a0001,
+0xc78,0x754b0001,
+0xc78,0x744c0001,
+0xc78,0x734d0001,
+0xc78,0x724e0001,
+0xc78,0x714f0001,
+0xc78,0x70500001,
+0xc78,0x6f510001,
+0xc78,0x6e520001,
+0xc78,0x6d530001,
+0xc78,0x6c540001,
+0xc78,0x6b550001,
+0xc78,0x6a560001,
+0xc78,0x69570001,
+0xc78,0x68580001,
+0xc78,0x67590001,
+0xc78,0x665a0001,
+0xc78,0x655b0001,
+0xc78,0x645c0001,
+0xc78,0x635d0001,
+0xc78,0x625e0001,
+0xc78,0x615f0001,
+0xc78,0x60600001,
+0xc78,0x49610001,
+0xc78,0x48620001,
+0xc78,0x47630001,
+0xc78,0x46640001,
+0xc78,0x45650001,
+0xc78,0x44660001,
+0xc78,0x43670001,
+0xc78,0x42680001,
+0xc78,0x41690001,
+0xc78,0x406a0001,
+0xc78,0x266b0001,
+0xc78,0x256c0001,
+0xc78,0x246d0001,
+0xc78,0x236e0001,
+0xc78,0x226f0001,
+0xc78,0x21700001,
+0xc78,0x20710001,
+0xc78,0x06720001,
+0xc78,0x05730001,
+0xc78,0x04740001,
+0xc78,0x03750001,
+0xc78,0x02760001,
+0xc78,0x01770001,
+0xc78,0x00780001,
+0xc78,0x00790001,
+0xc78,0x007a0001,
+0xc78,0x007b0001,
+0xc78,0x007c0001,
+0xc78,0x007d0001,
+0xc78,0x007e0001,
+0xc78,0x007f0001,
+0xc78,0x3800001e,
+0xc78,0x3801001e,
+0xc78,0x3802001e,
+0xc78,0x3803001e,
+0xc78,0x3804001e,
+0xc78,0x3805001e,
+0xc78,0x3806001e,
+0xc78,0x3807001e,
+0xc78,0x3808001e,
+0xc78,0x3c09001e,
+0xc78,0x3e0a001e,
+0xc78,0x400b001e,
+0xc78,0x440c001e,
+0xc78,0x480d001e,
+0xc78,0x4c0e001e,
+0xc78,0x500f001e,
+0xc78,0x5210001e,
+0xc78,0x5611001e,
+0xc78,0x5a12001e,
+0xc78,0x5e13001e,
+0xc78,0x6014001e,
+0xc78,0x6015001e,
+0xc78,0x6016001e,
+0xc78,0x6217001e,
+0xc78,0x6218001e,
+0xc78,0x6219001e,
+0xc78,0x621a001e,
+0xc78,0x621b001e,
+0xc78,0x621c001e,
+0xc78,0x621d001e,
+0xc78,0x621e001e,
+0xc78,0x621f001e,
+};
+
+u32 Rtl8192CUAGCTAB_1T_HPArray[AGCTAB_1T_HPArrayLength] = {
+0xc78,0x7b000001,
+0xc78,0x7b010001,
+0xc78,0x7b020001,
+0xc78,0x7b030001,
+0xc78,0x7b040001,
+0xc78,0x7b050001,
+0xc78,0x7b060001,
+0xc78,0x7b070001,
+0xc78,0x7b080001,
+0xc78,0x7a090001,
+0xc78,0x790a0001,
+0xc78,0x780b0001,
+0xc78,0x770c0001,
+0xc78,0x760d0001,
+0xc78,0x750e0001,
+0xc78,0x740f0001,
+0xc78,0x73100001,
+0xc78,0x72110001,
+0xc78,0x71120001,
+0xc78,0x70130001,
+0xc78,0x6f140001,
+0xc78,0x6e150001,
+0xc78,0x6d160001,
+0xc78,0x6c170001,
+0xc78,0x6b180001,
+0xc78,0x6a190001,
+0xc78,0x691a0001,
+0xc78,0x681b0001,
+0xc78,0x671c0001,
+0xc78,0x661d0001,
+0xc78,0x651e0001,
+0xc78,0x641f0001,
+0xc78,0x63200001,
+0xc78,0x62210001,
+0xc78,0x61220001,
+0xc78,0x60230001,
+0xc78,0x46240001,
+0xc78,0x45250001,
+0xc78,0x44260001,
+0xc78,0x43270001,
+0xc78,0x42280001,
+0xc78,0x41290001,
+0xc78,0x402a0001,
+0xc78,0x262b0001,
+0xc78,0x252c0001,
+0xc78,0x242d0001,
+0xc78,0x232e0001,
+0xc78,0x222f0001,
+0xc78,0x21300001,
+0xc78,0x20310001,
+0xc78,0x06320001,
+0xc78,0x05330001,
+0xc78,0x04340001,
+0xc78,0x03350001,
+0xc78,0x02360001,
+0xc78,0x01370001,
+0xc78,0x00380001,
+0xc78,0x00390001,
+0xc78,0x003a0001,
+0xc78,0x003b0001,
+0xc78,0x003c0001,
+0xc78,0x003d0001,
+0xc78,0x003e0001,
+0xc78,0x003f0001,
+0xc78,0x7b400001,
+0xc78,0x7b410001,
+0xc78,0x7b420001,
+0xc78,0x7b430001,
+0xc78,0x7b440001,
+0xc78,0x7b450001,
+0xc78,0x7b460001,
+0xc78,0x7b470001,
+0xc78,0x7b480001,
+0xc78,0x7a490001,
+0xc78,0x794a0001,
+0xc78,0x784b0001,
+0xc78,0x774c0001,
+0xc78,0x764d0001,
+0xc78,0x754e0001,
+0xc78,0x744f0001,
+0xc78,0x73500001,
+0xc78,0x72510001,
+0xc78,0x71520001,
+0xc78,0x70530001,
+0xc78,0x6f540001,
+0xc78,0x6e550001,
+0xc78,0x6d560001,
+0xc78,0x6c570001,
+0xc78,0x6b580001,
+0xc78,0x6a590001,
+0xc78,0x695a0001,
+0xc78,0x685b0001,
+0xc78,0x675c0001,
+0xc78,0x665d0001,
+0xc78,0x655e0001,
+0xc78,0x645f0001,
+0xc78,0x63600001,
+0xc78,0x62610001,
+0xc78,0x61620001,
+0xc78,0x60630001,
+0xc78,0x46640001,
+0xc78,0x45650001,
+0xc78,0x44660001,
+0xc78,0x43670001,
+0xc78,0x42680001,
+0xc78,0x41690001,
+0xc78,0x406a0001,
+0xc78,0x266b0001,
+0xc78,0x256c0001,
+0xc78,0x246d0001,
+0xc78,0x236e0001,
+0xc78,0x226f0001,
+0xc78,0x21700001,
+0xc78,0x20710001,
+0xc78,0x06720001,
+0xc78,0x05730001,
+0xc78,0x04740001,
+0xc78,0x03750001,
+0xc78,0x02760001,
+0xc78,0x01770001,
+0xc78,0x00780001,
+0xc78,0x00790001,
+0xc78,0x007a0001,
+0xc78,0x007b0001,
+0xc78,0x007c0001,
+0xc78,0x007d0001,
+0xc78,0x007e0001,
+0xc78,0x007f0001,
+0xc78,0x3800001e,
+0xc78,0x3801001e,
+0xc78,0x3802001e,
+0xc78,0x3803001e,
+0xc78,0x3804001e,
+0xc78,0x3805001e,
+0xc78,0x3806001e,
+0xc78,0x3807001e,
+0xc78,0x3808001e,
+0xc78,0x3c09001e,
+0xc78,0x3e0a001e,
+0xc78,0x400b001e,
+0xc78,0x440c001e,
+0xc78,0x480d001e,
+0xc78,0x4c0e001e,
+0xc78,0x500f001e,
+0xc78,0x5210001e,
+0xc78,0x5611001e,
+0xc78,0x5a12001e,
+0xc78,0x5e13001e,
+0xc78,0x6014001e,
+0xc78,0x6015001e,
+0xc78,0x6016001e,
+0xc78,0x6217001e,
+0xc78,0x6218001e,
+0xc78,0x6219001e,
+0xc78,0x621a001e,
+0xc78,0x621b001e,
+0xc78,0x621c001e,
+0xc78,0x621d001e,
+0xc78,0x621e001e,
+0xc78,0x621f001e,
+};
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192c_cmd.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192c_cmd.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192c_cmd.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192c_cmd.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,2140 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192C_CMD_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <cmd_osdep.h>
+#include <mlme_osdep.h>
+#include <rtw_byteorder.h>
+#include <circ_buf.h>
+#include <rtw_ioctl_set.h>
+
+
+#ifdef PLATFORM_LINUX
+#ifdef CONFIG_SDIO_HCI
+#include <linux/mmc/sdio_func.h>
+#endif
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/smp_lock.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/rtnetlink.h>
+#endif
+
+
+u32 read_macreg(_adapter *padapter, u32 addr, u32 sz)
+{
+	u32 val = 0;
+
+	switch(sz)
+	{
+		case 1:
+			val = rtw_read8(padapter, addr);
+			break;
+		case 2:
+			val = rtw_read16(padapter, addr);
+			break;
+		case 4:
+			val = rtw_read32(padapter, addr);
+			break;
+		default:
+			val = 0xffffffff;
+			break;
+	}
+
+	return val;
+	
+}
+
+void write_macreg(_adapter *padapter, u32 addr, u32 val, u32 sz)
+{
+	switch(sz)
+	{
+		case 1:
+			rtw_write8(padapter, addr, (u8)val);
+			break;
+		case 2:
+			rtw_write16(padapter, addr, (u16)val);
+			break;
+		case 4:
+			rtw_write32(padapter, addr, val);
+			break;
+		default:
+			break;
+	}
+
+}
+
+u32 read_bbreg(_adapter *padapter, u32 addr, u32 bitmask)
+{
+	return PHY_QueryBBReg(padapter, addr, bitmask);
+}
+
+void write_bbreg(_adapter *padapter, u32 addr, u32 bitmask, u32 val)
+{
+	PHY_SetBBReg(padapter, addr, bitmask, val);
+}
+
+u32 read_rfreg(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask)
+{
+	return PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)rfpath, addr, bitmask);
+}
+
+void write_rfreg(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val)
+{
+	PHY_SetRFReg(padapter, (RF90_RADIO_PATH_E)rfpath, addr, bitmask, val);	
+}
+
+u8 rtl8192c_NULL_hdl(_adapter *padapter, u8 *pbuf)
+{
+	return H2C_SUCCESS;
+}
+
+u8 rtl8192c_setopmode_hdl(_adapter *padapter, u8 *pbuf)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct setopmode_parm *psetop = (struct setopmode_parm *)pbuf;
+
+	rtw_write8(padapter, REG_BCN_MAX_ERR, 0xff);
+	
+	if(psetop->mode == Ndis802_11APMode)
+	{
+		pmlmeinfo->state = WIFI_FW_AP_STATE;
+		rtw_write8(padapter, REG_BCN_CTRL, 0x12);
+		Set_NETYPE0_MSR(padapter, _HW_STATE_AP_);	
+		ResumeTxBeacon(padapter);
+	}
+	else if(psetop->mode == Ndis802_11Infrastructure)
+	{
+		rtw_write8(padapter, REG_BCN_CTRL, 0x18);
+		Set_NETYPE0_MSR(padapter, _HW_STATE_STATION_);	
+		StopTxBeacon(padapter);
+	}
+	else if(psetop->mode == Ndis802_11IBSS)
+	{
+		//rtw_write8(padapter, REG_BCN_CTRL, 0x1a);//0x550[4:3:1] = 111'b
+		rtw_write8(padapter, REG_BCN_CTRL, 0x1E);//Test for Adhoc issue 2011-02-18
+		rtw_write8(padapter,REG_RD_CTRL+1,0x6F);		
+		ResumeTxBeacon(padapter);
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(1));	//disable bcn sub function
+		Set_NETYPE0_MSR(padapter, _HW_STATE_ADHOC_);	
+	}
+	else
+	{
+		rtw_write8(padapter, REG_BCN_CTRL, 0x18);
+		Set_NETYPE0_MSR(padapter, _HW_STATE_NOLINK_);	
+		StopTxBeacon(padapter);
+	}
+
+	return H2C_SUCCESS;
+	
+}
+
+u8 rtl8192c_createbss_hdl(_adapter *padapter, u8 *pbuf)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX	*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	struct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;
+
+	
+	if(pparm->network.InfrastructureMode == Ndis802_11APMode)
+	{
+#ifdef CONFIG_AP_MODE
+	
+		if(pmlmeinfo->state == WIFI_FW_AP_STATE)
+		{		
+			//todo:
+			return H2C_SUCCESS;		
+		}		
+#endif
+	}
+
+
+	//below is for ad-hoc master
+	if(pparm->network.InfrastructureMode == Ndis802_11IBSS)
+	{
+		rtw_joinbss_reset(padapter);
+
+		pmlmeext->linked_to = 0;
+	
+		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;	
+		pmlmeinfo->ERP_enable = 0;
+		pmlmeinfo->WMM_enable = 0;
+		pmlmeinfo->HT_enable = 0;
+		pmlmeinfo->HT_caps_enable = 0;
+		pmlmeinfo->HT_info_enable = 0;
+		pmlmeinfo->agg_enable_bitmap = 0;
+		pmlmeinfo->candidate_tid_bitmap = 0;
+
+		//disable dynamic functions, such as high power, DIG
+		Save_DM_Func_Flag(padapter);
+		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+
+		//config the initial gain under linking, need to write the BB registers
+		write_bbreg(padapter, rOFDM0_XAAGCCore1, bMaskByte0, 0x30);
+		write_bbreg(padapter, rOFDM0_XBAGCCore1, bMaskByte0, 0x30);
+
+		//cancel link timer 
+		_cancel_timer_ex(&pmlmeext->link_timer);
+
+                //clear CAM
+		flush_all_cam_entry(padapter);	
+
+
+		_rtw_memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength)); 
+		pnetwork->IELength = ((WLAN_BSSID_EX *)pbuf)->IELength;
+	
+		if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+			return H2C_PARAMETERS_ERROR;	
+		
+		_rtw_memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength); 
+	
+	
+		start_create_ibss(padapter);
+		
+	}	
+
+	return H2C_SUCCESS;
+
+}
+
+u8 rtl8192c_join_cmd_hdl(_adapter *padapter, u8 *pbuf)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX	*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	struct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;
+	
+	//check already connecting to AP or not
+	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+	{
+		if (pmlmeinfo->state & WIFI_FW_STATION_STATE)
+		{
+			issue_deauth(padapter, pnetwork->MacAddress, WLAN_REASON_DEAUTH_LEAVING);
+		}
+
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		
+		//clear CAM
+		flush_all_cam_entry(padapter);		
+		
+		_cancel_timer_ex(&pmlmeext->link_timer);
+		
+		//set MSR to nolink		
+		Set_NETYPE0_MSR(padapter, _HW_STATE_NOLINK_);	
+
+		//Set RCR to not to receive data frame when NO LINK state
+		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);
+		// reject all data frame
+		rtw_write16(padapter, REG_RXFLTMAP2,0x00);
+		
+		//reset TSF
+		rtw_write8(padapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+
+		//disable update TSF
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));	
+		}
+		else
+		{
+			//rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~(BIT(4)|BIT(5))));	
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4)|BIT(5));				
+		}
+
+	}
+
+	#ifdef CONFIG_ANTENNA_DIVERSITY
+	//switch antenna to Optimum_antenna
+	printk("rtl8192c_join_cmd_hdl cur_ant(%d),opt_ant(%d)\n",pHalData->CurAntenna,pparm->network.PhyInfo.Optimum_antenna);
+	if(pHalData->CurAntenna !=  pparm->network.PhyInfo.Optimum_antenna)		
+	{						
+		//PHY_SetRFPath(adapter,pnetwork->network.PhyInfo.Optimum_antenna);
+		antenna_select_cmd(padapter, pparm->network.PhyInfo.Optimum_antenna, 0);
+		printk("#### Change to Optimum_antenna(%s)\n",(2==pparm->network.PhyInfo.Optimum_antenna)?"A":"B");
+	}
+	#endif
+
+	rtw_joinbss_reset(padapter);
+
+	pmlmeext->linked_to = 0;
+	
+	pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+	pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;	
+	pmlmeinfo->ERP_enable = 0;
+	pmlmeinfo->WMM_enable = 0;
+	pmlmeinfo->HT_enable = 0;
+	pmlmeinfo->HT_caps_enable = 0;
+	pmlmeinfo->HT_info_enable = 0;
+	pmlmeinfo->agg_enable_bitmap = 0;
+	pmlmeinfo->candidate_tid_bitmap = 0;
+	pmlmeinfo->bwmode_updated = _FALSE;
+	
+	//pmlmeinfo->assoc_AP_vendor = maxAP;
+	
+	if (padapter->registrypriv.wifi_spec) {
+		// for WiFi test, follow WMM test plan spec
+		rtw_write32(padapter, REG_EDCA_VO_PARAM, 0x002F431C);
+		rtw_write32(padapter, REG_EDCA_VI_PARAM, 0x005E541C);
+		rtw_write32(padapter, REG_EDCA_BE_PARAM, 0x0000A525);
+		rtw_write32(padapter, REG_EDCA_BK_PARAM, 0x0000A549);
+	
+                // for WiFi test, mixed mode with intel STA under bg mode throughput issue
+	        if (padapter->mlmepriv.htpriv.ht_option == 0)
+		     rtw_write32(padapter, REG_EDCA_BE_PARAM, 0x00004320);
+
+	} else {
+	        rtw_write32(padapter, REG_EDCA_VO_PARAM, 0x002F3217);
+	        rtw_write32(padapter, REG_EDCA_VI_PARAM, 0x005E4317);
+	        rtw_write32(padapter, REG_EDCA_BE_PARAM, 0x00105320);
+	        rtw_write32(padapter, REG_EDCA_BK_PARAM, 0x0000A444);
+	}
+	
+	//disable dynamic functions, such as high power, DIG
+	//Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+
+	//config the initial gain under linking, need to write the BB registers
+	write_bbreg(padapter, rOFDM0_XAAGCCore1, 0x7f, 0x32);
+	write_bbreg(padapter, rOFDM0_XBAGCCore1, 0x7f, 0x32);
+
+	//set MSR to nolink		
+	Set_NETYPE0_MSR(padapter, _HW_STATE_NOLINK_);		
+			
+	if(IS_NORMAL_CHIP(pHalData->VersionID))
+	{
+		//config RCR to receive different BSSID & not to receive data frame during linking				
+		u32 v = rtw_read32(padapter, REG_RCR);
+		v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+		rtw_write32(padapter, REG_RCR, v);
+		rtw_write16(padapter, REG_RXFLTMAP2,0x00);//reject all data frame
+	}	
+	else
+	{
+		//config RCR to receive different BSSID & not to receive data frame during linking	
+		rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & 0xfffff7bf);
+	}
+
+	
+	//cancel link timer 
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+
+	_rtw_memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength)); 
+	pnetwork->IELength = ((WLAN_BSSID_EX *)pbuf)->IELength;
+	
+	if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+		return H2C_PARAMETERS_ERROR;	
+		
+	_rtw_memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength); 
+
+	start_clnt_join(padapter);
+	
+	//only for cisco's AP
+	if(pmlmeinfo->assoc_AP_vendor == ciscoAP)				
+	{	
+		int ie_len;
+		struct registry_priv	 *pregpriv = &padapter->registrypriv;
+		u8 *p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_ADD_INFO_IE_, &ie_len, (pmlmeinfo->network.IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+		if( p && ie_len)
+		{
+			struct HT_info_element *pht_info = (struct HT_info_element *)(p+2);
+					
+			if ((pregpriv->cbw40_enable) &&	 (pht_info->infos[0] & BIT(2)))
+			{
+				//switch to the 40M Hz mode according to the AP
+				pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
+				switch (pht_info->infos[0] & 0x3)
+				{
+					case 1:
+						pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+						break;
+			
+					case 3:
+						pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+						break;
+				
+					default:
+						pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+						break;
+				}		
+						
+				DBG_871X("set ch/bw for cisco's ap before connected\n");
+						
+				set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+						
+			}
+					
+		}
+		
+	}
+	
+	pmlmeinfo->assoc_AP_vendor = maxAP;
+	
+	return H2C_SUCCESS;
+	
+}
+
+u8 rtl8192c_disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	struct	mlme_priv 	*pmlmepriv = &padapter->mlmepriv;	
+
+	if (is_client_associated_to_ap(padapter))
+	{
+		issue_deauth(padapter, pnetwork->MacAddress, WLAN_REASON_DEAUTH_LEAVING);
+	}
+
+	//set_opmode_cmd(padapter, infra_client_with_mlme);
+
+	pmlmeinfo->state = WIFI_FW_NULL_STATE;
+	
+	//switch to the 20M Hz mode after disconnect
+	pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+	pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	
+		
+	//set MSR to no link state
+	Set_NETYPE0_MSR(padapter, _HW_STATE_NOLINK_);		
+		
+	//Set RCR to not to receive data frame when NO LINK state
+	//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);
+	rtw_write16(padapter, REG_RXFLTMAP2,0x00);
+	
+	//reset TSF
+	rtw_write8(padapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+
+	//disable update TSF
+	if(IS_NORMAL_CHIP(pHalData->VersionID))
+	{
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));	
+	}
+	else
+	{
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4)|BIT(5));
+	}
+	
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		//Stop BCN		
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
+	}
+
+	pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+	pmlmepriv->sitesurveyctrl.traffic_busy = _FALSE;		
+	set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+	flush_all_cam_entry(padapter);
+		
+	_cancel_timer_ex(&pmlmeext->link_timer);
+	pmlmeext->linked_to = 0;
+
+	
+	return 	H2C_SUCCESS;
+}
+
+u8 rtl8192c_sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct sitesurvey_parm	*pparm = (struct sitesurvey_parm *)pbuf;
+		
+	if (pmlmeext->sitesurvey_res.state == _FALSE)
+	{
+		//for first time rtw_sitesurvey_cmd
+		pmlmeext->sitesurvey_res.state = _TRUE;
+		pmlmeext->sitesurvey_res.bss_cnt = 0;
+		pmlmeext->sitesurvey_res.channel_idx = 0;
+		
+		if (le32_to_cpu(pparm->ss_ssidlen))
+		{
+			_rtw_memcpy(pmlmeext->sitesurvey_res.ss_ssid, pparm->ss_ssid, le32_to_cpu(pparm->ss_ssidlen));
+		}	
+		else
+		{
+			_rtw_memset(pmlmeext->sitesurvey_res.ss_ssid, 0, (IW_ESSID_MAX_SIZE + 1));
+		}	
+		
+		pmlmeext->sitesurvey_res.ss_ssidlen = le32_to_cpu(pparm->ss_ssidlen);
+	
+		pmlmeext->sitesurvey_res.scan_mode = le32_to_cpu(pparm->scan_mode);		
+
+		//disable dynamic functions, such as high power, DIG
+		Save_DM_Func_Flag(padapter);
+		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+
+		//config the initial gain under scaning, need to write the BB registers
+		write_bbreg(padapter, rOFDM0_XAAGCCore1, 0x7f, 0x20);
+		write_bbreg(padapter, rOFDM0_XBAGCCore1, 0x7f, 0x20);
+		
+		
+		//set MSR to no link state
+		Set_NETYPE0_MSR(padapter, _HW_STATE_NOLINK_);		
+		
+		
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{
+			//config RCR to receive different BSSID & not to receive data frame
+			//pHalData->ReceiveConfig &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));			
+			u32 v = rtw_read32(padapter, REG_RCR);
+			v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+			rtw_write32(padapter, REG_RCR, v);
+			rtw_write16(padapter, REG_RXFLTMAP2,0x00);
+
+			//disable update TSF
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));
+		}	
+		else
+		{
+			//config RCR to receive different BSSID & not to receive data frame			
+			rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & 0xfffff7bf);
+
+			//disable update TSF
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4)|BIT(5));
+		}
+
+		//issue null data if associating to the AP
+		if (is_client_associated_to_ap(padapter) == _TRUE)
+		{
+			issue_nulldata(padapter, 1);
+		}
+		
+	}
+		
+	site_survey(padapter);
+
+	return H2C_SUCCESS;
+	
+}
+
+u8 rtl8192c_setauth_hdl(_adapter *padapter, unsigned char *pbuf)
+{
+	struct setauth_parm		*pparm = (struct setauth_parm *)pbuf;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	if (pparm->mode < 4)
+	{
+		pmlmeinfo->auth_algo = pparm->mode;
+	}
+
+	return 	H2C_SUCCESS;
+}
+
+#define CAM_CFG_VALID BIT15
+u8 rtl8192c_setkey_hdl(_adapter *padapter, u8 *pbuf)
+{
+	unsigned short				ctrl;
+	struct setkey_parm		*pparm = (struct setkey_parm *)pbuf;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	unsigned char					null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	pmlmeinfo->key_index = pparm->keyid;
+	
+	//write cam
+	ctrl = CAM_CFG_VALID | ((pparm->algorithm) << 2) | pparm->keyid;	
+	
+	write_cam(padapter, pparm->keyid, ctrl, null_sta, pparm->key);
+	
+	return H2C_SUCCESS;
+}
+
+u8 rtl8192c_set_stakey_hdl(_adapter *padapter, u8 *pbuf)
+{
+	unsigned short ctrl=0;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct set_stakey_parm	*pparm = (struct set_stakey_parm *)pbuf;
+	
+	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		unsigned char cam_id;//cam_entry
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &padapter->stapriv;
+		
+		psta = rtw_get_stainfo(pstapriv, pparm->addr);
+		if(psta)
+		{			
+			ctrl = (BIT(15) | ((pparm->algorithm) << 2));
+
+			DBG_8192C("r871x_set_stakey_hdl(): enc_algorithm=%d\n", pparm->algorithm);
+
+			if((psta->mac_id<1) || (psta->mac_id>(NUM_STA-4)))
+			{
+				DBG_8192C("r871x_set_stakey_hdl():set_stakey failed, mac_id(aid)=%d\n", psta->mac_id);
+				return H2C_REJECTED;
+			}	
+				 
+			cam_id = (psta->mac_id + 3);//0~3 for default key, cmd_id=aid/macid + 3
+
+			DBG_8192C("Write CAM, mac_addr=%x:%x:%x:%x:%x:%x, cam_entry=%d\n", pparm->addr[0], 
+						pparm->addr[1], pparm->addr[2], pparm->addr[3], pparm->addr[4],
+						pparm->addr[5], cam_id);
+
+			write_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);
+	
+			return H2C_SUCCESS_RSP;
+		
+		}
+		else
+		{
+			DBG_8192C("r871x_set_stakey_hdl(): sta has been free\n");
+			return H2C_REJECTED;
+		}
+		
+	}
+
+	//below for sta mode
+	
+	ctrl = BIT(15) | ((pparm->algorithm) << 2);	
+
+	write_cam(padapter, 4, ctrl, pparm->addr, pparm->key);//CAM_ID(CAM_ENTRY)=4	
+
+	pmlmeinfo->enc_algo = pparm->algorithm;
+	
+	return H2C_SUCCESS;
+}
+
+u8 rtl8192c_add_ba_hdl(_adapter *padapter, unsigned char *pbuf)
+{
+	struct addBaReq_parm 	*pparm = (struct addBaReq_parm *)pbuf;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+	struct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, pparm->addr);
+	
+	if(!psta)
+		return 	H2C_SUCCESS;
+		
+
+	if (((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && (pmlmeinfo->HT_enable)) ||
+		((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{		
+		//pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid);		
+		//psta->htpriv.candidate_tid_bitmap |= BIT(pparm->tid);
+		issue_action_BA(padapter, pparm->addr, WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);		
+		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
+		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
+	}
+	else
+	{		
+		psta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);		
+	}
+	
+	return 	H2C_SUCCESS;
+	
+}
+
+u8 set_tx_beacon_cmd(_adapter* padapter)
+{
+	struct cmd_obj*		ph2c;
+	struct Tx_Beacon_param 	*ptxBeacon_parm;	
+	struct cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8	res = _SUCCESS;
+	
+_func_enter_;	
+	
+	if ((ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		res= _FAIL;
+		goto exit;
+	}
+	
+	if ((ptxBeacon_parm = (struct Tx_Beacon_param *)_rtw_zmalloc(sizeof(struct Tx_Beacon_param))) == NULL)
+	{
+		_rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	_rtw_memcpy(&(ptxBeacon_parm->network), &(pmlmeinfo->network), sizeof(WLAN_BSSID_EX));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, ptxBeacon_parm, GEN_CMD_CODE(_TX_Beacon));
+
+	rtw_enqueue_cmd_ex(pcmdpriv, ph2c);
+
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+}
+
+
+thread_return rtw_cmd_thread(thread_context context)
+{
+	u8 ret;
+	struct cmd_obj *pcmd;
+	u8 *pcmdbuf, *prspbuf;
+	u8 (*cmd_hdl)(_adapter *padapter, u8* pbuf);
+	void (*pcmd_callback)(_adapter *dev, struct cmd_obj *pcmd);
+       _adapter *padapter = (_adapter *)context;
+	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
+	
+_func_enter_;
+
+	thread_enter(padapter);
+
+	pcmdbuf = pcmdpriv->cmd_buf;
+	prspbuf = pcmdpriv->rsp_buf;
+
+	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("start r871x rtw_cmd_thread !!!!\n"));
+
+	while(1)
+	{
+		if ((_rtw_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
+			break;
+
+		if (rtw_register_cmd_alive(padapter) != _SUCCESS)
+		{
+			continue;
+		}
+		
+_next:
+
+             if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		{			
+			printk("###> rtw_cmd_thread break.................\n");
+			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+			break;
+		}
+	
+		if(!(pcmd = rtw_dequeue_cmd(&(pcmdpriv->cmd_queue)))) {
+			rtw_unregister_cmd_alive(padapter);
+			continue;
+		}
+
+		pcmdpriv->cmd_issued_cnt++;
+
+		pcmd->cmdsz = _RND4((pcmd->cmdsz));//_RND4
+
+		_rtw_memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+
+		if(pcmd->cmdcode <= (sizeof(wlancmds) /sizeof(struct cmd_hdl)))
+		{
+			cmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;
+
+			if (cmd_hdl)
+			{			
+				ret = cmd_hdl(padapter, pcmdbuf);
+				pcmd->res = ret;
+			}
+
+			//invoke cmd->callback function		
+			pcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;
+			if(pcmd_callback == NULL)
+			{
+				RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("mlme_cmd_hdl(): pcmd_callback=0x%p, cmdcode=0x%x\n", pcmd_callback, pcmd->cmdcode));
+				rtw_free_cmd_obj(pcmd);
+			}	
+			else
+			{	
+				//todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!=NULL)
+				
+				pcmd_callback(padapter, pcmd);//need conider that free cmd_obj in rtw_cmd_callback
+			}
+
+			pcmdpriv->cmd_seq++;
+			
+		}
+		
+		cmd_hdl = NULL;
+
+		flush_signals_thread();
+		
+		goto _next;
+				
+	}
+	
+
+	// free all cmd_obj resources
+	do{
+
+		pcmd = rtw_dequeue_cmd(&(pcmdpriv->cmd_queue));
+		if(pcmd==NULL)
+			break;
+
+		rtw_free_cmd_obj(pcmd);
+		
+	}while(1);
+
+
+	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
+
+_func_exit_;	
+
+	thread_exit();
+
+}
+
+u8 rtl8192c_mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf)
+{
+	u8 evt_code, evt_seq;
+	u16 evt_sz;
+	uint 	*peventbuf;
+	void (*event_callback)(_adapter *dev, u8 *pbuf);
+	struct evt_priv *pevt_priv = &(padapter->evtpriv);
+
+	peventbuf = (uint*)pbuf;
+	evt_sz = (u16)(*peventbuf&0xffff);
+	evt_seq = (u8)((*peventbuf>>24)&0x7f);
+	evt_code = (u8)((*peventbuf>>16)&0xff);
+	
+		
+	// checking event sequence...		
+	if ((evt_seq & 0x7f) != pevt_priv->event_seq)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("Evetn Seq Error! %d vs %d\n", (evt_seq & 0x7f), pevt_priv->event_seq));
+	
+		pevt_priv->event_seq = (evt_seq+1)&0x7f;
+
+		goto _abort_event_;
+	}
+
+	// checking if event code is valid
+	if (evt_code >= MAX_C2HEVT)
+	{
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent Code(%d) mismatch!\n", evt_code));
+		goto _abort_event_;
+	}
+
+	// checking if event size match the event parm size	
+	if ((rtw_wlanevents[evt_code].parmsize != 0) && 
+			(rtw_wlanevents[evt_code].parmsize != evt_sz))
+	{
+			
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent(%d) Parm Size mismatch (%d vs %d)!\n", 
+			evt_code, rtw_wlanevents[evt_code].parmsize, evt_sz));
+		goto _abort_event_;	
+			
+	}
+
+	pevt_priv->event_seq = (pevt_priv->event_seq+1)&0x7f;//update evt_seq
+
+	peventbuf += 2;
+				
+	if(peventbuf)
+	{
+		event_callback = rtw_wlanevents[evt_code].event_callback;
+		event_callback(padapter, (u8*)peventbuf);
+
+		pevt_priv->evt_done_cnt++;
+	}
+
+
+_abort_event_:
+
+
+	return H2C_SUCCESS;
+		
+}
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+u8 usb_io_chk_cmd(_adapter*padapter)
+{
+	struct cmd_obj*		ph2c;
+	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;	
+	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+	
+_func_enter_;	
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));	
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)_rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
+	if(pdrvextra_cmd_parm==NULL){
+		_rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = USB_IO_CHECK_WK_CID;
+	pdrvextra_cmd_parm->sz = 0;
+	pdrvextra_cmd_parm->pbuf = NULL;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+	
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);	
+	rtw_enqueue_cmd_ex(pcmdpriv, ph2c);
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+}
+
+void xmit_status_check_hdl(_adapter *padapter)
+{
+	unsigned long current_time;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	unsigned int diff_time;
+	
+	if(rtw_read32(padapter, REG_TXDMA_STATUS) !=0x00){
+		silentreset_for_specific_platform(padapter);						
+	}
+	
+	//total xmit irp = 4
+	//printk("==>%s free_xmitbuf_cnt(%d),txirp_cnt(%d)\n",__FUNCTION__,pxmitpriv->free_xmitbuf_cnt,pxmitpriv->txirp_cnt);
+	//if(pxmitpriv->txirp_cnt == NR_XMITBUFF+1)
+	current_time = rtw_get_current_time();
+	if(0==pxmitpriv->free_xmitbuf_cnt)
+	{
+		diff_time = jiffies_to_msecs(current_time - padapter->last_tx_time);
+			
+		if(diff_time > 2000){
+			if(padapter->last_tx_complete_time==0){
+				padapter->last_tx_complete_time = current_time;
+			}
+			else{
+				diff_time = jiffies_to_msecs(current_time - padapter->last_tx_complete_time);
+				if(diff_time > 4000){
+					//padapter->Wifi_Error_Status = WIFI_TX_HANG;
+					printk("tx hang...start reset\n");
+					silentreset_for_specific_platform(padapter);	
+				}
+			}
+		}	
+	}	
+}
+void usb_io_chk_wk_hdl(_adapter *padapter, u8 *pbuf, int sz)
+{
+	silentreset_for_specific_platform(padapter);		
+}
+#endif
+
+void dynamic_chk_wk_hdl(_adapter *padapter, u8 *pbuf, int sz)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM	
+	xmit_status_check_hdl(padapter);	
+	#endif	
+
+	/*
+	 * Commented by Jeff 2010/12/25
+	 * Long-time site survey will occpuy the medium causing no beacon
+	 * or probe respons is received form current AP.
+	 * If under site surveying, we don't decrese the "linked_to" counter
+	 * to prevent "linked_status_chk" 's over killing.
+	*/
+	if(check_fwstate(pmlmepriv, WIFI_SITE_MONITOR) == _FALSE)
+	{
+		if(pmlmeext->linked_to > 0)
+		{
+			pmlmeext->linked_to--;	
+			if(pmlmeext->linked_to==0)
+			    linked_status_chk(padapter);		
+		}
+	}
+
+	if(pHalData->hal_ops.hal_dm_watchdog)
+		pHalData->hal_ops.hal_dm_watchdog(padapter);
+
+	//check_hw_pbc(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);	
+}
+
+u8 rtl8192c_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf)
+{
+	struct drvextra_cmd_parm *pdrvextra_cmd;
+
+	if(!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	pdrvextra_cmd = (struct drvextra_cmd_parm*)pbuf;
+	
+	switch(pdrvextra_cmd->ec_id)
+	{
+		case DYNAMIC_CHK_WK_CID:
+			dynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);
+			break;
+		case DM_CTRL_WK_CID:
+			//HalDmWatchDog(padapter);
+			break;
+		case PBC_POLLING_WK_CID:
+			//check_hw_pbc(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);			
+			break;
+		case POWER_SAVING_CTRL_WK_CID:
+			power_saving_ctrl_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);	
+			break;
+#ifdef CONFIG_LPS
+		case LPS_CTRL_WK_CID:
+			lps_ctrl_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);
+			break;
+#endif
+#ifdef CONFIG_ANTENNA_DIVERSITY
+		case ANT_SELECT_WK_CID:
+			antenna_select_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);
+			break;
+#endif
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+		case USB_IO_CHECK_WK_CID:
+			usb_io_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);
+		break;
+#endif
+
+		default:
+			break;
+
+	}
+
+
+	if(pdrvextra_cmd->pbuf && pdrvextra_cmd->sz>0)
+	{
+		_rtw_mfree(pdrvextra_cmd->pbuf, pdrvextra_cmd->sz);
+	}
+
+
+	return H2C_SUCCESS;
+
+}
+#if 0
+static BOOLEAN
+CheckWriteMSG(
+	IN	PADAPTER		Adapter,
+	IN	u8		BoxNum
+)
+{
+	u8	valHMETFR;
+	BOOLEAN	Result = _FALSE;
+	
+	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
+
+	//DbgPrint("CheckWriteH2C(): Reg[0x%2x] = %x\n",REG_HMETFR, valHMETFR);
+
+	if(((valHMETFR>>BoxNum)&BIT0) == 1)
+		Result = _TRUE;
+	
+	return Result;
+
+}
+
+static BOOLEAN CheckFwReadLastMSG(
+	IN	PADAPTER		Adapter,
+	IN	u8		BoxNum
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u8	valHMETFR, valMCUTST_1;
+	BOOLEAN	 Result = _FALSE;
+	
+	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
+	valMCUTST_1 = rtw_read8(Adapter, (REG_MCUTST_1+BoxNum));
+
+	//DbgPrint("REG[%x] = %x, REG[%x] = %x\n", 
+	//	REG_HMETFR, valHMETFR, REG_MCUTST_1+BoxNum, valMCUTST_1 );
+
+	// Do not seperate to 91C and 88C, we use the same setting. Suggested by SD4 Filen. 2009.12.03.
+	if(IS_NORMAL_CHIP(pHalData->VersionID))
+	{
+		if(((valHMETFR>>BoxNum)&BIT0) == 0)
+			Result = _TRUE;
+	}
+	else
+	{
+		if((((valHMETFR>>BoxNum)&BIT0) == 0) && (valMCUTST_1 == 0))
+		{
+			Result = _TRUE;
+		}
+	}
+	
+	return Result;
+}
+#endif
+
+#define RTL92C_MAX_H2C_BOX_NUMS	4
+#define RTL92C_MAX_CMD_LEN	5
+#define MESSAGE_BOX_SIZE		4
+#define EX_MESSAGE_BOX_SIZE	2
+
+
+static u8 _is_fw_read_cmd_down(_adapter* padapter, u8 isvern, u8 msgbox_num)
+{
+	u8 read_down = _FALSE;
+	int  retry_cnts = 100;
+	
+	u8 valid;
+
+//	DBG_8192C(" _is_fw_read_cmd_down ,isnormal_chip(%x),reg_1cc(%x),msg_box(%d)...\n",isvern,rtw_read8(padapter,REG_HMETFR),msgbox_num);
+	
+	do{
+		valid = rtw_read8(padapter,REG_HMETFR) & BIT(msgbox_num);	
+		if(isvern){
+			if(0 == valid ){
+				read_down = _TRUE;
+			}			
+		}
+		else{
+			if((0 == valid) && (0 == rtw_read8(padapter, REG_MCUTST_1+msgbox_num))){
+				read_down = _TRUE;	
+			}
+		}
+	}while( (!read_down) && (retry_cnts--));
+
+	return read_down;
+	
+}
+
+/*****************************************
+* H2C Msg format :
+*| 31 - 8		|7		| 6 - 0	|	
+*| h2c_msg 	|Ext_bit	|CMD_ID	|
+*
+******************************************/
+void FillH2CCmd(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBuffer)
+{	
+#if 1
+	u8 bcmd_down = _FALSE;
+	int 	retry_cnts = 100;
+	u8	h2c_box_num;
+	u32	msgbox_addr;
+	u32  msgbox_ex_addr;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	u8 isnchip =IS_NORMAL_CHIP(pHalData->VersionID);
+	u32	h2c_cmd = 0;
+	u16	h2c_cmd_ex = 0;
+
+	_func_enter_;	
+	
+	if(!pCmdBuffer){
+		return ;
+	}
+	if(CmdLen > RTL92C_MAX_CMD_LEN){
+		return ;
+	}
+	if(padapter->bFWReady == _FALSE)		
+	{
+		return;
+	}
+	//pay attention to if  race condition happened in  H2C cmd setting.
+	do{
+		h2c_box_num = pHalData->LastHMEBoxNum;
+
+		if(!_is_fw_read_cmd_down(padapter, isnchip, h2c_box_num)){
+			DBG_8192C(" fw read cmd failed...\n");
+			break;
+		}		
+				
+		if(CmdLen<=3)
+		{
+			_rtw_memcpy((u8*)(&h2c_cmd)+1, pCmdBuffer, CmdLen );
+		}
+		else{
+			_rtw_memcpy((u8*)(&h2c_cmd_ex), pCmdBuffer, EX_MESSAGE_BOX_SIZE);
+			_rtw_memcpy((u8*)(&h2c_cmd)+1, pCmdBuffer+2,( CmdLen-EX_MESSAGE_BOX_SIZE));
+			*(u8*)(&h2c_cmd) |= BIT(7);
+		}
+
+		*(u8*)(&h2c_cmd) |= ElementID;
+			
+		if(h2c_cmd & BIT(7)){
+			msgbox_ex_addr = REG_HMEBOX_EXT_0 + (h2c_box_num *EX_MESSAGE_BOX_SIZE);
+			h2c_cmd_ex = cpu_to_le16( h2c_cmd_ex );
+			rtw_write16(padapter, msgbox_ex_addr, h2c_cmd_ex);
+		}
+		msgbox_addr =REG_HMEBOX_0 + (h2c_box_num *MESSAGE_BOX_SIZE);
+		h2c_cmd = cpu_to_le32( h2c_cmd );
+		rtw_write32(padapter,msgbox_addr, h2c_cmd);
+		
+		if(!isnchip){//for Test chip
+			if(! (rtw_read8(padapter, REG_HMETFR) & BIT(h2c_box_num))){
+				DBG_8192C("Chip test  - check fw write failed, write again..\n");
+				continue;
+			}			
+			// Fill H2C protection register.
+			rtw_write8(padapter,REG_MCUTST_1+h2c_box_num, 0xFF);			
+		}
+		bcmd_down = _TRUE;
+
+	//	DBG_8192C("MSG_BOX:%d,CmdLen(%d), reg:0x%x =>h2c_cmd:0x%x, reg:0x%x =>h2c_cmd_ex:0x%x ..\n"
+	//	 	,pHalData->LastHMEBoxNum ,CmdLen,msgbox_addr,h2c_cmd,msgbox_ex_addr,h2c_cmd_ex);
+		
+		 pHalData->LastHMEBoxNum = (h2c_box_num+1) % RTL92C_MAX_H2C_BOX_NUMS ;
+		 
+	}while((!bcmd_down) && (retry_cnts--));
+/*
+	if(bcmd_down)
+		DBG_8192C("H2C Cmd exe down. \n"	);	
+	else
+		DBG_8192C("H2C Cmd exe failed. \n"	);
+*/	
+	_func_exit_;
+
+	
+#else
+	u8	BoxNum;
+	u16	BOXReg, BOXExtReg;
+	u8	BoxContent[4], BoxExtContent[2];
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	u8 	BufIndex=0;
+	u8	bWriteSucess = _FALSE;
+	u8	IsFwRead = _FALSE;
+	u8	WaitH2cLimmit = 100;
+
+	u32	h2c_cmd = 0;
+	u16	h2c_cmd_ex = 0;
+
+_func_enter_;	
+
+	//printk("FillH2CCmd : ElementID=%d \n",ElementID);
+
+	while(!bWriteSucess)
+	{
+		// 2. Find the last BOX number which has been writen.
+		BoxNum = pHalData->LastHMEBoxNum;
+		switch(BoxNum)
+		{
+			case 0:
+				BOXReg = REG_HMEBOX_0;
+				BOXExtReg = REG_HMEBOX_EXT_0;
+				break;
+			case 1:
+				BOXReg = REG_HMEBOX_1;
+				BOXExtReg = REG_HMEBOX_EXT_1;
+				break;
+			case 2:
+				BOXReg = REG_HMEBOX_2;
+				BOXExtReg = REG_HMEBOX_EXT_2;
+				break;
+			case 3:
+				BOXReg = REG_HMEBOX_3;
+				BOXExtReg = REG_HMEBOX_EXT_3;
+				break;
+			default:
+				break;
+		}
+
+		// 3. Check if the box content is empty.
+		IsFwRead = CheckFwReadLastMSG(padapter, BoxNum);
+		while(!IsFwRead)
+		{
+			//wait until Fw read
+			WaitH2cLimmit--;
+			if(WaitH2cLimmit == 0)
+			{
+				DBG_8192C("FillH2CCmd92C(): Wating too long for FW read clear HMEBox(%d)!!!\n", BoxNum);
+				break;
+			}
+			rtw_msleep_os(10); //us
+			IsFwRead = CheckFwReadLastMSG(padapter, BoxNum);
+			//U1btmp = PlatformEFIORead1Byte(Adapter, 0x1BF);
+			//RT_TRACE(COMP_CMD, DBG_LOUD, ("FillH2CCmd92C(): Wating for FW read clear HMEBox(%d)!!! 0x1BF = %2x\n", BoxNum, U1btmp));
+		}
+
+		// If Fw has not read the last H2C cmd, break and give up this H2C.
+		if(!IsFwRead)
+		{
+			DBG_8192C("FillH2CCmd92C():  Write H2C register BOX[%d] fail!!!!! Fw do not read. \n", BoxNum);
+			break;
+		}
+
+		// 4. Fill the H2C cmd into box		
+		_rtw_memset(BoxContent, 0, sizeof(BoxContent));
+		_rtw_memset(BoxExtContent, 0, sizeof(BoxExtContent));
+		
+		BoxContent[0] = ElementID; // Fill element ID
+
+		//DBG_8192C("FillH2CCmd92C():Write ElementID BOXReg(%4x) = %2x \n", BOXReg, ElementID);
+
+		switch(CmdLen)
+		{
+			case 1:
+				{
+					BoxContent[0] &= ~(BIT7);
+					_rtw_memcpy((u8*)(BoxContent)+1, pCmdBuffer+BufIndex, 1);
+					rtw_write32(padapter, BOXReg, *((u32*)BoxContent));
+					h2c_cmd =  *((u32*)BoxContent);
+					break;
+				}
+			case 2:
+				{	
+					BoxContent[0] &= ~(BIT7);
+					_rtw_memcpy((u8*)(BoxContent)+1, pCmdBuffer+BufIndex, 2);
+					rtw_write32(padapter, BOXReg, *((u32*)BoxContent));
+					h2c_cmd =  *((u32*)BoxContent);
+					break;
+				}
+			case 3:
+				{
+					BoxContent[0] &= ~(BIT7);
+					_rtw_memcpy((u8*)(BoxContent)+1, pCmdBuffer+BufIndex, 3);
+					rtw_write32(padapter, BOXReg, *((u32*)BoxContent));
+					h2c_cmd =  *((u32*)BoxContent);
+					break;
+				}
+			case 4:
+				{
+					BoxContent[0] |= (BIT7);
+					_rtw_memcpy((u8*)(BoxExtContent), pCmdBuffer+BufIndex, 2);
+					_rtw_memcpy((u8*)(BoxContent)+1, pCmdBuffer+BufIndex+2, 2);
+					rtw_write16(padapter, BOXExtReg, *((u16*)BoxExtContent));
+					rtw_write32(padapter, BOXReg, *((u32*)BoxContent));
+					h2c_cmd =  *((u32*)BoxContent);
+					h2c_cmd_ex = *((u32*)BoxExtContent);
+					break;
+				}
+			case 5:
+				{
+					BoxContent[0] |= (BIT7);
+					_rtw_memcpy((u8*)(BoxExtContent), pCmdBuffer+BufIndex, 2);
+					_rtw_memcpy((u8*)(BoxContent)+1, pCmdBuffer+BufIndex+2, 3);
+					rtw_write16(padapter, BOXExtReg, *((u16*)BoxExtContent));
+					rtw_write32(padapter, BOXReg, *((u32*)BoxContent));
+					h2c_cmd =  *((u32*)BoxContent);
+					h2c_cmd_ex = *((u32*)BoxExtContent);
+					break;
+				}
+			default:
+					break;
+					
+		}
+
+
+		DBG_8192C("MSG_BOX:%d,CmdLen(%d), reg:0x%x =>h2c_cmd:0x%x, reg:0x%x =>h2c_cmd_ex:0x%x ..\n"
+		 	,pHalData->LastHMEBoxNum ,CmdLen,BOXReg,h2c_cmd,BOXExtReg,h2c_cmd_ex);
+
+		//DBG_8192C("FillH2CCmd(): BoxExtContent=0x%x\n", *(u16*)BoxExtContent);		
+		//DBG_8192C("FillH2CCmd(): BoxContent=0x%x\n", *(u32*)BoxContent);
+			
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{
+			// 5. Normal chip does not need to check if the H2C cmd has be written successfully.
+			bWriteSucess = _TRUE;
+		}
+		else
+		{	
+			// 5. Check if the H2C cmd has be written successfully.
+			bWriteSucess = CheckWriteMSG(padapter, BoxNum);
+			if(!bWriteSucess) //If not then write again.
+				continue;
+			
+			//6. Fill H2C protection register.
+
+			rtw_write8(padapter, REG_MCUTST_1+BoxNum, 0xFF);
+			//RT_TRACE(COMP_CMD, DBG_LOUD, ("FillH2CCmd92C():Write Reg(%4x) = 0xFF \n", REG_MCUTST_1+BoxNum));
+		}
+
+		// Record the next BoxNum
+		pHalData->LastHMEBoxNum = BoxNum+1;
+		if(pHalData->LastHMEBoxNum == 4) // loop to 0
+			pHalData->LastHMEBoxNum = 0;
+		
+		//DBG_8192C("FillH2CCmd92C():pHalData->LastHMEBoxNum  = %d\n", pHalData->LastHMEBoxNum);
+		
+	}
+
+_func_exit_;
+
+#endif
+
+}
+
+u8 rtl8192c_h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf)
+{	
+	u8 ElementID, CmdLen;
+	u8 *pCmdBuffer;
+	struct cmd_msg_parm  *pcmdmsg;
+	
+	if(!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	pcmdmsg = (struct cmd_msg_parm*)pbuf;
+	ElementID = pcmdmsg->eid;
+	CmdLen = pcmdmsg->sz;
+	pCmdBuffer = pcmdmsg->buf;
+
+	FillH2CCmd(padapter, ElementID, CmdLen, pCmdBuffer);
+
+	return H2C_SUCCESS;
+}
+#ifdef CONFIG_AUTOSUSPEND
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+u8 set_FWSelectSuspend_cmd(_adapter *padapter ,u8 bfwpoll, u16 period)
+{
+	u8	res=_SUCCESS;
+	struct H2C_SS_RFOFF_PARAM param;
+	printk("==>%s \n",__FUNCTION__);
+	param.gpio_period = period;//Polling GPIO_11 period time
+	param.ROFOn = (_TRUE == bfwpoll)?1:0;
+	FillH2CCmd(padapter, SELECTIVE_SUSPEND_ROF_CMD, sizeof(param), (u8*)(&param));		
+	return res;
+}
+#endif
+#endif
+
+u8 set_rssi_cmd(_adapter*padapter, u8 *param)
+{	
+	u8	res=_SUCCESS;	
+_func_enter_;	
+
+	*((u32*) param ) = cpu_to_le32( *((u32*) param ) );
+	FillH2CCmd(padapter, RSSI_SETTING_EID, 3, param);
+_func_exit_;
+	return res;
+}
+
+u8 set_raid_cmd(_adapter*padapter, u32 mask, u8 arg)
+{	
+	u8	buf[5];
+	u8	res=_SUCCESS;
+	
+_func_enter_;	
+	
+	_rtw_memset(buf, 0, 5);
+	mask = cpu_to_le32( mask );
+	_rtw_memcpy(buf, &mask, 4);
+	buf[4]  = arg;
+
+	FillH2CCmd(padapter, MACID_CONFIG_EID, 5, buf);
+	
+_func_exit_;
+
+	return res;
+
+}
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+void antenna_select_wk_hdl(_adapter *padapter, u8 *pbuf, int antenna)
+{
+	printk("==> %s  , Ant_(%s)\n",__FUNCTION__,(antenna==2)?"A":"B");
+	PHY_SetRFPath(padapter,antenna);
+}
+u8 antenna_select_cmd(_adapter*padapter, u8 antenna, u8 enqueue)
+{
+	struct cmd_obj		*ph2c;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;	
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	
+	u8	res = _SUCCESS;
+_func_enter_;
+
+	if(IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))	
+		return res;
+
+	if(enqueue)
+	{
+		ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));	
+		if(ph2c==NULL){
+			res= _FAIL;
+			goto exit;
+		}
+		
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)_rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
+		if(pdrvextra_cmd_parm==NULL){
+			_rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+			res= _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm->ec_id = ANT_SELECT_WK_CID;
+		pdrvextra_cmd_parm->sz = antenna;
+		pdrvextra_cmd_parm->pbuf = NULL;
+		printk("==> %s  , enqueue CMD \n",__FUNCTION__);	
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+		rtw_enqueue_cmd_ex(pcmdpriv, ph2c);
+	}
+	else
+	{
+		antenna_select_wk_hdl(padapter, NULL,antenna );
+	}
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+
+}
+#endif
+
+#ifdef CONFIG_LPS
+void lps_ctrl_wk_hdl(_adapter *padapter, u8 *pbuf, int sz)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+_func_enter_;		
+	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)
+		|| (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+	{
+		return;
+	}
+
+	switch(sz)
+	{
+		case LPS_CTRL_SCAN:
+			printk("LPS_CTRL_SCAN \n");
+			LPS_Leave(padapter);
+
+			while( !FWLPS_RF_ON(padapter) )
+			{
+				printk("FW still in PS mode \n");
+				rtw_usleep_os(100);
+			}
+			break;
+		case LPS_CTRL_JOINBSS:
+			printk("LPS_CTRL_JOINBSS \n");
+			LPS_Leave(padapter);
+			break;
+		case LPS_CTRL_CONNECT:
+			printk("LPS_CTRL_CONNECT \n");
+			// Reset LPS Setting
+			padapter->pwrctrlpriv.LpsIdleCount = 0;
+
+			set_FwJoinBssReport_cmd(padapter, 1);
+			break;
+		case LPS_CTRL_DISCONNECT:
+			printk("LPS_CTRL_DISCONNECT \n");
+			LPS_Leave(padapter);
+
+			set_FwJoinBssReport_cmd(padapter, 0);
+			break;
+		case LPS_CTRL_SPECIAL_PACKET:
+			printk("LPS_CTRL_SPECIAL_PACKET \n");
+			pwrpriv->DelayLPSLastTimeStamp = rtw_get_current_time();
+			LPS_Leave(padapter);
+			break;
+
+		default:
+			break;
+	}
+
+_func_exit_;
+}
+
+u8 lps_ctrl_wk_cmd(_adapter*padapter, u8 lps_ctrl_type, u8 enqueue)
+{
+	struct cmd_obj	*ph2c;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;	
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+	u8	res = _SUCCESS;
+	
+_func_enter_;
+	if(!pwrctrlpriv->bLeisurePs)
+		return res;
+
+	if(enqueue)
+	{
+		ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));	
+		if(ph2c==NULL){
+			res= _FAIL;
+			goto exit;
+		}
+		
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)_rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
+		if(pdrvextra_cmd_parm==NULL){
+			_rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+			res= _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm->ec_id = LPS_CTRL_WK_CID;
+		pdrvextra_cmd_parm->sz = lps_ctrl_type;
+		pdrvextra_cmd_parm->pbuf = NULL;
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+		rtw_enqueue_cmd_ex(pcmdpriv, ph2c);
+	}
+	else
+	{
+		lps_ctrl_wk_hdl(padapter, NULL, lps_ctrl_type);
+	}
+	
+exit:
+	
+_func_exit_;
+
+	return res;
+
+}
+
+void set_FwPwrMode_cmd(_adapter*padapter, u8 Mode)
+{
+	SETPWRMODE_PARM H2CSetPwrMode;
+	
+_func_enter_;
+	DBG_871X("%s\n", __FUNCTION__);
+
+	H2CSetPwrMode.Mode = Mode;
+	H2CSetPwrMode.SmartPS = 1;
+	H2CSetPwrMode.AwakeInterval = 1;//pPSC->RegMaxLPSAwakeIntvl;
+
+	FillH2CCmd(padapter, SET_PWRMODE_EID, sizeof(H2CSetPwrMode), (u8 *)&H2CSetPwrMode);
+	
+_func_exit_;
+}
+
+void ConstructBeacon(_adapter *padapter, u8 *pframe, u32 *pLength)
+{
+	struct ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;
+	u32					rate_len, pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	pwlanhdr = (struct ieee80211_hdr *)pframe;	
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	
+	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	//pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_BEACON);
+	
+	pframe += sizeof(struct ieee80211_hdr_3addr);	
+	pktlen = sizeof (struct ieee80211_hdr_3addr);
+	
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	pktlen += 8;
+
+	// beacon interval: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
+	pframe += 2;
+	pktlen += 2;
+
+	// capability info: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+	pframe += 2;
+	pktlen += 2;
+
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		DBG_871X("ie len=%d\n", cur_network->IELength);
+		pktlen += cur_network->IELength - sizeof(NDIS_802_11_FIXED_IEs);
+		_rtw_memcpy(pframe, cur_network->IEs+sizeof(NDIS_802_11_FIXED_IEs), pktlen);
+		
+		goto _ConstructBeacon;
+	}
+
+	//below for ad-hoc mode
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);
+
+	// supported rates...
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pktlen);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		u32 ATIMWindow;
+		// IBSS Parameter Set...
+		//ATIMWindow = cur->Configuration.ATIMWindow;
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
+	}	
+
+
+	//todo: ERP IE
+	
+	
+	// EXTERNDED SUPPORTED RATE
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);
+	}
+
+
+	//todo:HT for adhoc
+
+_ConstructBeacon:
+
+	if ((pktlen + TXDESC_SIZE) > 512)
+	{
+		DBG_871X("beacon frame too large\n");
+		return;
+	}
+
+	*pLength = pktlen;
+
+	DBG_871X("%s bcn_sz=%d\n", __FUNCTION__, pktlen);
+
+}
+
+void ConstructPSPoll(_adapter *padapter, u8 *pframe, u32 *pLength)
+{
+	struct ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;
+	u32					pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	// Frame control.
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	SetPwrMgt(fctrl);
+	SetFrameSubType(pframe, WIFI_PSPOLL);
+
+	// AID.
+	SetDuration(pframe, (pmlmeinfo->aid| 0xc000));
+
+	// BSSID.
+	_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	// TA.
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	*pLength = 16;
+}
+
+void ConstructNullFunctionData(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, BOOLEAN bForcePowerSave)
+{
+	struct ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;
+	u32					pktlen;
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X("%s:%d\n", __FUNCTION__, bForcePowerSave);
+
+	pwlanhdr = (struct ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	if (bForcePowerSave)
+	{
+		SetPwrMgt(fctrl);
+	}
+
+	switch(cur_network->network.InfrastructureMode)
+	{			
+		case Ndis802_11Infrastructure:
+			SetToDs(fctrl);
+			_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);
+			break;
+		case Ndis802_11APMode:
+			SetFrDs(fctrl);
+			_rtw_memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			break;
+		case Ndis802_11IBSS:
+		default:
+			_rtw_memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			break;
+	}
+
+	SetSeqNum(pwlanhdr, 0);
+
+	SetFrameSubType(pframe, WIFI_DATA_NULL);
+
+	pframe += sizeof(struct ieee80211_hdr_3addr);
+	pktlen = sizeof(struct ieee80211_hdr_3addr);
+
+	*pLength = pktlen;
+}
+
+void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, BOOLEAN bHideSSID)
+{
+	struct ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;	
+	u8					*mac, *bssid;
+	u32					pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	
+	
+	DBG_871X("%s\n", __FUNCTION__);
+	
+	pwlanhdr = (struct ieee80211_hdr *)pframe;	
+	
+	mac = myid(&(padapter->eeprompriv));
+	bssid = cur_network->MacAddress;
+	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	_rtw_memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, bssid, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetFrameSubType(fctrl, WIFI_PROBERSP);
+	
+	pktlen = sizeof(struct ieee80211_hdr_3addr);
+	pframe += pktlen;
+
+	if(cur_network->IELength>MAX_IE_SZ)
+		return;
+
+	_rtw_memcpy(pframe, cur_network->IEs, cur_network->IELength);
+	pframe += cur_network->IELength;
+	pktlen += cur_network->IELength;
+	
+	*pLength = pktlen;
+}
+
+//
+// Description: In normal chip, we should send some packet to Hw which will be used by Fw
+//			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then 
+//			Fw can tell Hw to send these packet derectly.
+// Added by tynli. 2009.10.15.
+//
+VOID
+FillFakeTxDescriptor92C(
+	IN PADAPTER		Adapter,
+	IN u8*			pDesc,
+	IN u32			BufferLen,
+	IN BOOLEAN		IsPsPoll
+)
+{
+	struct tx_desc	*ptxdesc = (struct tx_desc *)pDesc;
+
+	// Clear all status
+	_rtw_memset(pDesc, 0, 32);
+
+	//offset 0
+	ptxdesc->txdw0 |= cpu_to_le32( OWN | FSG | LSG); //own, bFirstSeg, bLastSeg;
+
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000); //32 bytes for TX Desc
+
+	ptxdesc->txdw0 |= cpu_to_le32(BufferLen&0x0000ffff); // Buffer size + command header
+
+	//offset 4
+	ptxdesc->txdw1 |= cpu_to_le32((QSLT_MGNT<<QSEL_SHT)&0x00001f00); // Fixed queue of Mgnt queue
+
+	//Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw.
+	if(IsPsPoll)
+	{
+		ptxdesc->txdw1 |= cpu_to_le32(NAVUSEHDR);
+	}
+	else
+	{
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
+		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
+	}
+
+	//offset 16
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+	
+	// USB interface drop packet if the checksum of descriptor isn't correct.
+	// Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.).
+	cal_txdesc_chksum(ptxdesc);
+	
+	//RT_PRINT_DATA(COMP_CMD, DBG_TRACE, "TxFillCmdDesc8192C(): H2C Tx Cmd Content ----->\n", pDesc, TX_DESC_SIZE);
+}
+
+
+//
+// Description: Fill the reserved packets that FW will use to RSVD page. 
+//			Now we just send 4 types packet to rsvd page.
+//			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp.
+//	Input: 
+//	    bDLFinished - FALSE: At the first time we will send all the packets as a large packet to Hw,
+//				 		so we need to set the packet length to total lengh.
+//			      TRUE: At the second time, we should send the first packet (default:beacon)
+//						to Hw again and set the lengh in descriptor to the real beacon lengh.
+// 2009.10.15 by tynli.
+void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
+{
+	struct xmit_frame	*pmgntframe;
+	struct pkt_attrib	*pattrib;
+	struct xmit_priv	*pxmitpriv = &(Adapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u32	BeaconLength, ProbeRspLength, PSPollLength, NullFunctionDataLength;
+	u8	*ReservedPagePacket;	
+	u8	PageNum=0, U1bTmp, TxDescLen=0;
+	u16	BufIndex=0;
+	u32	TotalPacketLen;
+	RSVDPAGE_LOC	RsvdPageLoc;
+	BOOLEAN	bDLOK = _FALSE;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	ReservedPagePacket = (u8*)_rtw_zmalloc(1000);
+	if(ReservedPagePacket == NULL){
+		DBG_871X("%s(): alloc ReservedPagePacket fail !!!\n", __FUNCTION__);
+		return;
+	}
+
+//	_rtw_memset(ReservedPagePacket, 0, 1000);
+
+	if(DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+	{
+		BufIndex = TXDESC_OFFSET;
+	}
+	else
+	{
+		BufIndex = 0;
+	}
+
+	TxDescLen = TXDESC_SIZE;
+
+	//(1) beacon
+	ConstructBeacon(Adapter,&ReservedPagePacket[BufIndex],&BeaconLength);
+
+	//printk("SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: BCN\n", &ReservedPagePacket[BufIndex], (BeaconLength+BufIndex));
+
+//--------------------------------------------------------------------
+
+	// When we count the first page size, we need to reserve description size for the RSVD 
+	// packet, it will be filled in front of the packet in TXPKTBUF.
+	U1bTmp = (u8)PageNum_128(BeaconLength+TxDescLen);
+	PageNum += U1bTmp;
+
+	if(DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+		BufIndex = (PageNum*128) + TxDescLen+8; //Shift index for 8 bytes because the dummy bytes in the first descipstor.
+	else
+		BufIndex = (PageNum*128);
+		
+	//(2) ps-poll
+	ConstructPSPoll(Adapter, &ReservedPagePacket[BufIndex],&PSPollLength);
+	
+	FillFakeTxDescriptor92C(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, _TRUE);
+
+	//printk("SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PS-POLL\n", &ReservedPagePacket[BufIndex-TxDescLen], (PSPollLength+TxDescLen));
+
+	RsvdPageLoc.LocPsPoll = PageNum;
+
+//------------------------------------------------------------------
+			
+	U1bTmp = (u8)PageNum_128(PSPollLength+TxDescLen);
+	PageNum += U1bTmp;
+
+	if(DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+		BufIndex = (PageNum*128) + TxDescLen+8;
+	else
+		BufIndex = (PageNum*128);
+
+	//(3) null data
+	ConstructNullFunctionData(
+		Adapter, 
+		&ReservedPagePacket[BufIndex],
+		&NullFunctionDataLength,
+		get_my_bssid(&(pmlmeinfo->network)),
+		_FALSE);
+	
+	FillFakeTxDescriptor92C(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], NullFunctionDataLength, _FALSE);
+
+	RsvdPageLoc.LocNullData = PageNum;
+	
+	//printk("SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: NULL DATA \n", &ReservedPagePacket[BufIndex-TxDescLen], (NullFunctionDataLength+TxDescLen));
+//------------------------------------------------------------------
+
+	U1bTmp = (u8)PageNum_128(NullFunctionDataLength+TxDescLen);
+	PageNum += U1bTmp;
+	
+	if(DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+		BufIndex = (PageNum*128) + TxDescLen+8;
+	else
+		BufIndex = (PageNum*128);
+	
+	//(4) probe response
+	ConstructProbeRsp(
+		Adapter, 
+		&ReservedPagePacket[BufIndex],
+		&ProbeRspLength,
+		get_my_bssid(&(pmlmeinfo->network)),
+		_FALSE);
+	
+	FillFakeTxDescriptor92C(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], ProbeRspLength, _FALSE);
+
+	RsvdPageLoc.LocProbeRsp = PageNum;
+
+	//printk("SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PROBE RSP \n", &ReservedPagePacket[BufIndex-TxDescLen], (ProbeRspLength-TxDescLen));
+
+//------------------------------------------------------------------
+
+	U1bTmp = (u8)PageNum_128(ProbeRspLength+TxDescLen);
+
+	PageNum += U1bTmp;
+
+	TotalPacketLen = (PageNum*128);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(Adapter, pattrib);
+	pattrib->qsel = 0x10;
+	pattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescLen;
+	_rtw_memcpy(pmgntframe->buf_addr, ReservedPagePacket, TotalPacketLen);
+
+	dump_mgntframe(Adapter, pmgntframe);
+	bDLOK = _TRUE;
+
+	if(bDLOK)
+	{
+		DBG_871X("Set RSVD page location to Fw Len(%d).\n",sizeof(RsvdPageLoc));		
+		FillH2CCmd(Adapter, RSVD_PAGE_EID, sizeof(RsvdPageLoc), (u8 *)&RsvdPageLoc);
+	}
+
+	_rtw_mfree(ReservedPagePacket, 1000);
+
+}
+
+void set_FwJoinBssReport_cmd(_adapter* padapter, u8 mstatus)
+{
+	JOINBSSRPT_PARM	JoinBssRptParm;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	
+_func_enter_;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if(mstatus == 1)
+	{
+		// We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 88/92C.
+		// Suggested by filen. Added by tynli.
+		rtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));
+		// Do not set TSF again here or vWiFi beacon DMA INT will not work.
+		//correct_TSF(padapter, pmlmeext);
+		// Hw sequende enable by dedault. 2010.06.23. by tynli.
+		//rtw_write16(padapter, REG_NQOS_SEQ, ((pmlmeext->mgnt_seq+100)&0xFFF));
+		//rtw_write8(padapter, REG_HWSEQ_CTRL, 0xFF);
+
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{
+			BOOLEAN bRecover = _FALSE;
+
+			//set REG_CR bit 8
+			//U1bTmp = rtw_read8(padapter, REG_CR+1);
+			rtw_write8(padapter,  REG_CR+1, 0x03);
+
+			// Disable Hw protection for a time which revserd for Hw sending beacon.
+			// Fix download reserved page packet fail that access collision with the protection time.
+			// 2010.05.11. Added by tynli.
+			//SetBcnCtrlReg(padapter, 0, BIT3);
+			//SetBcnCtrlReg(padapter, BIT4, 0);
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(3)));
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));
+
+			// Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.
+			if(pHalData->RegFwHwTxQCtrl&BIT6)
+				bRecover = _TRUE;
+
+			// To tell Hw the packet is not a real beacon frame.
+			//U1bTmp = rtw_read8(padapter, REG_FWHW_TXQ_CTRL+2);
+			rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl&(~BIT6)));
+			pHalData->RegFwHwTxQCtrl &= (~BIT6);
+			SetFwRsvdPagePkt(padapter, 0);
+
+			// 2010.05.11. Added by tynli.
+			//SetBcnCtrlReg(padapter, BIT3, 0);
+			//SetBcnCtrlReg(padapter, 0, BIT4);
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(3));
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));
+
+			// To make sure that if there exists an adapter which would like to send beacon.
+			// If exists, the origianl value of 0x422[6] will be 1, we should check this to
+			// prevent from setting 0x422[6] to 0 after download reserved page, or it will cause 
+			// the beacon cannot be sent by HW.
+			// 2010.06.23. Added by tynli.
+			if(bRecover)
+			{
+				rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl|BIT6));
+				pHalData->RegFwHwTxQCtrl |= BIT6;
+			}
+
+			// Clear CR[8] or beacon packet will not be send to TxBuf anymore.
+			rtw_write8(padapter, REG_CR+1, 0x02);
+		}
+	}
+
+	JoinBssRptParm.OpMode = mstatus;
+	printk("%s H2C len(%d)\n",__FUNCTION__,sizeof(JoinBssRptParm));
+	FillH2CCmd(padapter, JOINBSS_RPT_EID, sizeof(JoinBssRptParm), (u8 *)&JoinBssRptParm);
+	
+_func_exit_;
+}
+#endif
+
+void rtw_dummy_event_callback(_adapter *adapter , u8 *pbuf)
+{
+
+}
+static void fwdbg_event_callback(_adapter *adapter , u8 *pbuf)
+{
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,367 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192CU_RECV_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <mlme_osdep.h>
+#include <ip.h>
+#include <if_ether.h>
+#include <ethernet.h>
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#include <wifi.h>
+#include <circ_buf.h>
+
+
+int	rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	//struct recv_reorder_ctrl *preorder_ctrl;
+	int	res=_SUCCESS;
+
+
+	_rtw_init_sema(&precvpriv->recv_sema, 0);//will be removed
+	_rtw_init_sema(&precvpriv->terminate_recvthread_sema, 0);//will be removed
+
+	//init recv_buf
+	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
+
+
+	precvpriv->pallocated_recv_buf = _rtw_zmalloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4);
+	if(precvpriv->pallocated_recv_buf==NULL){
+		res= _FAIL;
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("alloc recv_buf fail!\n"));
+		goto exit;
+	}
+//	_rtw_memset(precvpriv->pallocated_recv_buf, 0, NR_RECVBUFF *sizeof(struct recv_buf) + 4);
+
+	precvpriv->precv_buf = precvpriv->pallocated_recv_buf + 4 -
+							((SIZE_PTR) (precvpriv->pallocated_recv_buf) &(4-1));
+
+
+	precvbuf = (struct recv_buf*)precvpriv->precv_buf;
+
+	for(i=0; i < NR_RECVBUFF ; i++)
+	{
+		_rtw_init_listhead(&precvbuf->list);
+
+		_rtw_spinlock_init(&precvbuf->recvbuf_lock);
+
+		res = rtw_os_recvbuf_resource_alloc(padapter, precvbuf);
+		if(res==_FAIL)
+			break;
+
+		precvbuf->ref_cnt = 0;
+		precvbuf->adapter =padapter;
+
+
+		rtw_list_insert_tail(&precvbuf->list, &(precvpriv->free_recv_buf_queue.queue));
+
+		precvbuf++;
+
+	}
+#ifdef CONFIG_SDIO_HCI
+
+	precvpriv->recvbuf_drop= (struct recv_buf*)_rtw_zmalloc(sizeof(struct recv_buf));
+#ifdef PLATFORM_LINUX
+	((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf = _rtw_zmalloc(MAX_RECVBUF_SZ+4);
+	if(((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf == NULL){
+		res = _FAIL;
+	}
+
+	((struct recv_buf *)precvpriv->recvbuf_drop)->pbuf=((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf + 4 -  ((uint) (((struct recv_buf *)precvpriv->recvbuf_drop)->pallocated_buf) &(4-1));
+
+
+	((struct recv_buf *)precvpriv->recvbuf_drop)->pdata = ((struct recv_buf *)precvpriv->recvbuf_drop)->phead = ((struct recv_buf *)precvpriv->recvbuf_drop)->ptail =((struct recv_buf *)precvpriv->recvbuf_drop)->pbuf;
+
+	((struct recv_buf *)precvpriv->recvbuf_drop)->pend = ((struct recv_buf *)precvpriv->recvbuf_drop)->pdata + MAX_RECVBUF_SZ;
+
+
+
+	((struct recv_buf *)precvpriv->recvbuf_drop)->len = 0;
+
+#else
+	rtw_os_recvbuf_resource_alloc(padapter, precvpriv->recvbuf_drop);
+#endif
+#endif
+
+	precvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;
+
+
+#ifdef PLATFORM_LINUX
+
+	tasklet_init(&precvpriv->recv_tasklet,
+	     (void(*)(unsigned long))rtl8192cu_recv_tasklet,
+	     (unsigned long)padapter);
+
+
+	skb_queue_head_init(&precvpriv->rx_skb_queue);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+	{
+		int i;
+		SIZE_PTR tmpaddr=0;
+		SIZE_PTR alignment=0;
+		struct sk_buff *pskb=NULL;
+
+		skb_queue_head_init(&precvpriv->free_recv_skb_queue);
+
+		for(i=0; i<NR_PREALLOC_RECV_SKB; i++)
+		{
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+			pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+	#else
+			pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+	#endif
+
+			if(pskb)
+			{
+				pskb->dev = padapter->pnetdev;
+
+				tmpaddr = (SIZE_PTR)pskb->data;
+				alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+				skb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));
+
+				skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+			}
+
+			pskb=NULL;
+
+		}
+
+	}
+#endif
+
+#endif
+
+exit:
+
+	return res;
+
+}
+
+void rtw_free_recv_priv (struct recv_priv *precvpriv)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	_adapter *padapter = precvpriv->adapter;
+
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+
+	for(i=0; i < NR_RECVBUFF ; i++)
+	{
+		rtw_os_recvbuf_resource_free(padapter, precvbuf);
+		precvbuf++;
+	}
+
+	if(precvpriv->pallocated_recv_buf)
+		_rtw_mfree(precvpriv->pallocated_recv_buf, NR_RECVBUFF *sizeof(struct recv_buf) + 4);
+
+
+#ifdef PLATFORM_LINUX
+
+	if (skb_queue_len(&precvpriv->rx_skb_queue)) {
+		printk(KERN_WARNING "rx_skb_queue not empty\n");
+	}
+
+	skb_queue_purge(&precvpriv->rx_skb_queue);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+
+	if (skb_queue_len(&precvpriv->free_recv_skb_queue)) {
+		printk(KERN_WARNING "free_recv_skb_queue not empty, %d\n", skb_queue_len(&precvpriv->free_recv_skb_queue));
+	}
+
+	skb_queue_purge(&precvpriv->free_recv_skb_queue);
+
+#endif
+
+#endif
+
+}
+
+int rtw_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res=_SUCCESS;
+#ifdef CONFIG_USB_HCI
+	precvbuf->transfer_len = 0;
+
+	precvbuf->len = 0;
+
+	precvbuf->ref_cnt = 0;
+
+#endif //#ifdef CONFIG_USB_HCI
+	if(precvbuf->pbuf)
+	{
+		precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pbuf;
+		precvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;
+	}
+
+	return res;
+
+}
+
+void rtl8192cu_update_recvframe_attrib_from_recvstat(union recv_frame *precvframe, struct recv_stat *prxstat)
+{
+	u8 physt, qos, shift, icverr, htc,crcerr;
+	u32 *pphy_info;
+	u16 drvinfo_sz=0;
+	struct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;	
+	_adapter *padapter = precvframe->u.hdr.adapter;
+
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	
+	u8 bPacketMatchBSSID=_FALSE;
+	u8 bPacketToSelf = _FALSE;
+	u8 bPacketBeacon = _FALSE;
+	//Offset 0
+	drvinfo_sz = (le32_to_cpu(prxstat->rxdw0)&0x000f0000)>>16;
+	drvinfo_sz = drvinfo_sz<<3;
+
+	pattrib->bdecrypted = ((le32_to_cpu(prxstat->rxdw0) & BIT(27)) >> 27)? 0:1;
+
+	physt = ((le32_to_cpu(prxstat->rxdw0) & BIT(26)) >> 26)? 1:0;
+	pattrib->physt = physt;
+
+	shift = (le32_to_cpu(prxstat->rxdw0)&0x03000000)>>24;
+
+	qos = ((le32_to_cpu(prxstat->rxdw0) & BIT(23)) >> 23)? 1:0;
+
+	icverr = ((le32_to_cpu(prxstat->rxdw0) & BIT(15)) >> 15)? 1:0;
+
+	crcerr =  ((le32_to_cpu(prxstat->rxdw0) & BIT(14)) >> 14 )?1:0;
+
+
+	//Offset 4
+
+	//Offset 8
+
+	//Offset 12
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	if ( le32_to_cpu(prxstat->rxdw3) & BIT(13)) {
+		pattrib->tcpchk_valid = 1; // valid
+		if ( le32_to_cpu(prxstat->rxdw3) & BIT(11) ) {
+			pattrib->tcp_chkrpt = 1; // correct
+			//printk("tcp csum ok\n");
+		} else
+			pattrib->tcp_chkrpt = 0; // incorrect
+
+		if ( le32_to_cpu(prxstat->rxdw3) & BIT(12) )
+			pattrib->ip_chkrpt = 1; // correct
+		else
+			pattrib->ip_chkrpt = 0; // incorrect
+
+	} else {
+		pattrib->tcpchk_valid = 0; // invalid
+	}
+
+#endif
+
+	pattrib->mcs_rate=(u8)((le32_to_cpu(prxstat->rxdw3))&0x3f);
+	pattrib->rxht=(u8)((le32_to_cpu(prxstat->rxdw3) >>6)&0x1);
+
+	htc = (u8)((le32_to_cpu(prxstat->rxdw3) >>10)&0x1);
+
+	//Offset 16
+	//Offset 20
+
+
+#if 0 //dump rxdesc for debug
+	if(pHalData->bDumpRxPkt){
+		printk("### rxdw0=0x%08x #### \n", le32_to_cpu(prxstat->rxdw0));	
+		printk("pkt_len=0x%04x\n",(le32_to_cpu(prxstat->rxdw0)&0x3FFF));
+	printk("drvinfo_sz=%d\n", drvinfo_sz);
+	printk("physt=%d\n", physt);
+	printk("shift=%d\n", shift);
+	printk("qos=%d\n", qos);
+	printk("icverr=%d\n", icverr);
+	printk("htc=%d\n", htc);
+	printk("bdecrypted=%d\n", pattrib->bdecrypted);
+	printk("mcs_rate=%d\n", pattrib->mcs_rate);
+	printk("rxht=%d\n", pattrib->rxht);
+	}
+#endif
+
+	//phy_info
+	if(drvinfo_sz && physt)
+	{
+		bPacketMatchBSSID = ((!IsFrameTypeCtrl(precvframe->u.hdr.rx_data)) && 
+							!icverr && !crcerr && _rtw_memcmp(get_hdr_bssid(precvframe->u.hdr.rx_data), 
+							get_my_bssid(&padapter->mlmeextpriv.mlmext_info.network), ETH_ALEN));
+
+			
+
+		bPacketToSelf = bPacketMatchBSSID &&  (_rtw_memcmp(get_da(precvframe->u.hdr.rx_data), myid(&padapter->eeprompriv), ETH_ALEN));
+
+		bPacketBeacon =bPacketMatchBSSID && (GetFrameSubType(precvframe->u.hdr.rx_data) ==  WIFI_BEACON);
+
+		pphy_info=(u32 *)prxstat+1;
+
+		//printk("pphy_info, of0=0x%08x\n", *pphy_info);
+		//printk("pphy_info, of1=0x%08x\n", *(pphy_info+1));
+		//printk("pphy_info, of2=0x%08x\n", *(pphy_info+2));
+		//printk("pphy_info, of3=0x%08x\n", *(pphy_info+3));
+		//printk("pphy_info, of4=0x%08x\n", *(pphy_info+4));
+		//printk("pphy_info, of5=0x%08x\n", *(pphy_info+5));
+		//printk("pphy_info, of6=0x%08x\n", *(pphy_info+6));
+		//printk("pphy_info, of7=0x%08x\n", *(pphy_info+7));
+		
+		
+		rtl8192c_query_rx_phy_status(precvframe, prxstat);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+		// If we switch to the antenna for testing, the signal strength 
+		// of the packets in this time shall not be counted into total receiving power. 
+		// This prevents error counting Rx signal strength and affecting other dynamic mechanism.
+
+		// Select the packets to do RSSI checking for antenna switching.
+		if(bPacketToSelf || bPacketBeacon)
+		{	
+			SwAntDivRSSICheck(padapter, precvframe->u.hdr.attrib.RxPWDBAll);	
+		}
+		
+#endif
+		if(bPacketToSelf || bPacketBeacon)	
+			rtl8192c_process_phy_info(padapter,precvframe);		
+
+#if 0 //dump phy_status for debug
+
+		printk("signal_qual=%d\n", pattrib->signal_qual);
+		printk("signal_strength=%d\n", pattrib->signal_strength);
+#endif
+
+	}
+
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1162 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192C_XMIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_byteorder.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+#include <circ_buf.h>
+#include <usb_ops.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+u32 rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe)
+{
+	u32 addr;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;	
+	
+	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
+	{
+		switch(pattrib->qsel)
+		{
+			case 0:
+			case 3:
+				addr = BE_QUEUE_INX;
+			 	break;
+			case 1:
+			case 2:
+				addr = BK_QUEUE_INX;
+				break;				
+			case 4:
+			case 5:
+				addr = VI_QUEUE_INX;
+				break;		
+			case 6:
+			case 7:
+				addr = VO_QUEUE_INX;
+				break;
+
+			default:
+				addr = BE_QUEUE_INX;
+				break;		
+				
+		}
+		
+	}	
+	else if((pxmitframe->frame_tag&0x0f) == MGNT_FRAMETAG)
+	{
+		addr = MGT_QUEUE_INX;
+	}
+	else
+	{
+		addr = BE_QUEUE_INX;
+	}
+
+	return addr;
+
+}
+
+void count_tx_stats(_adapter *padapter, struct xmit_frame *pxmitframe, int sz)
+{
+	struct sta_info *psta = NULL;
+	struct stainfo_stats *pstats = NULL;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
+	{
+		pxmitpriv->tx_bytes += sz;
+		pxmitpriv->NumTxOkInPeriod ++;
+
+		psta = pxmitframe->attrib.psta;
+
+		if(psta)
+		{
+			pstats = &psta->sta_stats;
+#if USB_TX_AGGREGATION_92C
+			pstats->tx_pkts += pxmitframe->agg_num;
+#else
+			pstats->tx_pkts++;
+#endif
+			pstats->tx_bytes += sz;
+		}
+	}
+	
+}
+
+void rtw_do_queue_select(_adapter	*padapter, struct pkt_attrib *pattrib)
+{
+	unsigned int qsel;
+		
+	qsel = (uint)pattrib->priority;	
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("### rtw_do_queue_select priority=%d ,qsel = %d\n",pattrib->priority ,qsel));
+	pattrib->qsel = qsel;
+
+}
+
+int urb_zero_packet_chk(_adapter *padapter, int sz)
+{
+	int blnSetTxDescOffset;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv*)&padapter->dvobjpriv;	
+
+	if ( pdvobj->ishighspeed )
+	{
+		if ( ( (sz + TXDESC_SIZE) % 512 ) == 0 ) {
+			blnSetTxDescOffset = 1;
+		} else {
+			blnSetTxDescOffset = 0;
+		}
+	}
+	else
+	{
+		if ( ( (sz + TXDESC_SIZE) % 64 ) == 0 ) 	{
+			blnSetTxDescOffset = 1;
+		} else {
+			blnSetTxDescOffset = 0;
+		}
+	}
+	
+	return blnSetTxDescOffset;
+	
+}
+
+void cal_txdesc_chksum(struct tx_desc	*ptxdesc)
+{
+		u16	*usPtr = (u16*)ptxdesc;
+		u32 count = 16;		// (32 bytes / 2 bytes per XOR) => 16 times
+		u32 index;
+		u16 checksum = 0;
+
+		//Clear first
+		ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
+	
+		for(index = 0 ; index < count ; index++){
+			checksum = checksum ^ le16_to_cpu(*(usPtr + index));
+		}
+
+		ptxdesc->txdw7 |= cpu_to_le32(0x0000ffff&checksum);	
+
+}
+
+void fill_txdesc_for_mp(struct xmit_frame *pxmitframe, struct tx_desc *ptxdesc)
+{		
+#ifdef CONFIG_MP_INCLUDED
+
+		struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+		sint bmcst = IS_MCAST(pattrib->ra);
+
+		if (pattrib->pctrl == 1) // mp tx packets
+		{
+
+			struct tx_desc txdesc, *ptxdesc_mp;
+			struct pkt_file pktfile;
+
+			ptxdesc_mp = &txdesc;
+			_rtw_open_pktfile(pxmitframe->pkt, &pktfile);
+			_rtw_pktfile_read(&pktfile, NULL, ETH_HLEN);
+			_rtw_pktfile_read(&pktfile, (u8*)ptxdesc_mp, TXDESC_SIZE);
+
+			//offset 8
+			ptxdesc->txdw2 = cpu_to_le32(ptxdesc_mp->txdw2);
+			if (bmcst) ptxdesc->txdw2 |= cpu_to_le32(BMC);
+			ptxdesc->txdw2 |= cpu_to_le32(BK);	
+			//RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("mp pkt offset8-txdesc=0x%8x\n", ptxdesc->txdw2));			
+
+			ptxdesc->txdw4 = cpu_to_le32(ptxdesc_mp->txdw4);
+			//RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("mp pkt offset16-txdesc=0x%8x\n", ptxdesc->txdw4));
+
+			//offset 20
+			ptxdesc->txdw5 = cpu_to_le32(ptxdesc_mp->txdw5);
+			//RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("mp pkt offset20-txdesc=0x%8x\n", ptxdesc->txdw5));				
+
+			pattrib->pctrl = 0;//reset to zero;				
+		}
+		
+#endif
+}
+
+void fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc)
+{
+	if ((pattrib->encrypt > 0) && !pattrib->bswenc)
+	{
+		switch (pattrib->encrypt)
+		{	
+			//SEC_TYPE
+			case _WEP40_:
+			case _WEP104_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
+					break;				
+			case _TKIP_:
+			case _TKIP_WTMIC_:	
+					//ptxdesc->txdw1 |= cpu_to_le32((0x02<<22)&0x00c00000);
+					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
+					break;
+			case _AES_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x03<<22)&0x00c00000);
+					break;
+			case _NO_PRIVACY_:
+			default:
+					break;
+		
+		}
+		
+	}
+
+}
+
+void fill_txdesc_vcs(struct pkt_attrib *pattrib, u32 *pdw)
+{
+	//DBG_8192C("cvs_mode=%d\n", pattrib->vcs_mode);	
+
+	switch(pattrib->vcs_mode)
+	{
+		case RTS_CTS:
+			*pdw |= cpu_to_le32(BIT(12));
+			break;
+		case CTS_TO_SELF:
+			*pdw |= cpu_to_le32(BIT(11));
+			break;
+		case NONE_VCS:
+		default:
+			break;		
+	}
+
+	if(pattrib->vcs_mode)
+	{
+		*pdw |= cpu_to_le32(BIT(13));//ENABLE HW RTS
+	}
+
+}
+
+void fill_txdesc_phy(struct pkt_attrib *pattrib, u32 *pdw)
+{
+	//DBG_8192C("bwmode=%d, ch_off=%d\n", pattrib->bwmode, pattrib->ch_offset);
+
+	if(pattrib->ht_en)
+	{
+		*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40)?	cpu_to_le32(BIT(25)):0;
+
+		if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+			*pdw |= cpu_to_le32((0x01<<20)&0x003f0000);
+		else if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
+			*pdw |= cpu_to_le32((0x02<<20)&0x003f0000);
+		else if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
+			*pdw |= 0;
+		else
+			*pdw |= cpu_to_le32((0x03<<20)&0x003f0000);
+	}
+}
+
+#if USB_TX_AGGREGATION_92C
+static void _update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, int sz)
+{
+	uint qsel;
+
+	_adapter		*padapter = pxmitframe->padapter;
+	struct ht_priv		*phtpriv = &padapter->mlmepriv.htpriv;
+	struct mlme_ext_info	*pmlmeinfo = &padapter->mlmeextpriv.mlmext_info;
+
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	struct tx_desc		*ptxdesc = (struct tx_desc*)pmem;
+
+
+	_rtw_memset(ptxdesc, 0, sizeof(struct tx_desc));
+	
+	//4 offset 0
+	ptxdesc->txdw0 |= cpu_to_le32(sz & 0x0000ffff);
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) << OFFSET_SHT) & 0x00ff0000);//32 bytes for TX Desc
+	
+	if (bmcst) ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
+
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+		 ("rtw_update_txdesc: offset0=0x%08x\n", ptxdesc->txdw0));
+
+	//4 offset 4
+	// pkt_offset, unit:8 bytes padding
+	if (pxmitframe->pkt_offset > 0)
+		ptxdesc->txdw1 |= cpu_to_le32((pxmitframe->pkt_offset << 26) & 0x7c000000);
+
+#if USB_TX_AGGREGATION_92C
+	if (pxmitframe->agg_num > 0)
+		ptxdesc->txdw5 |= cpu_to_le32((pxmitframe->agg_num << 24) & 0xff000000);
+#endif
+
+	if (pxmitframe->frame_tag == DATA_FRAMETAG)
+	{
+		//4 offset 4
+		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id & 0x1f);//CAM_ID(MAC_ID)
+
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid << 16) & 0x000f0000);
+
+		fill_txdesc_sectype(pattrib, ptxdesc);
+
+		if(pattrib->ampdu_en==_TRUE)
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));//AGG EN
+		else
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
+
+
+		//4 offset 8
+
+
+		//4 offset 12
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum << 16) & 0xffff0000);
+
+
+		//4 offset 16 , offset 20
+		if (pattrib->qos_en)
+			ptxdesc->txdw4 |= cpu_to_le32(BIT(6));//QoS
+
+		if ((pattrib->ether_type != 0x888e) &&
+		    (pattrib->ether_type != 0x0806) &&
+		    (pattrib->dhcp_pkt != 1))
+		{
+			//Non EAP & ARP & DHCP type data packet
+
+			fill_txdesc_vcs(pattrib, &ptxdesc->txdw4);
+			fill_txdesc_phy(pattrib, &ptxdesc->txdw4);
+
+			
+			ptxdesc->txdw4 |= cpu_to_le32(0x00000008);//RTS Rate=24M
+			ptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);
+			ptxdesc->txdw5 |= cpu_to_le32(0x0000000b);//DataRate - 54M
+
+			if (0)//for driver dbg
+			{
+				ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+
+				if (pattrib->ht_en)
+					ptxdesc->txdw5 |= cpu_to_le32(BIT(6));//SGI
+
+				ptxdesc->txdw5 |= cpu_to_le32(0x00000013);//init rate - mcs7
+			}
+		}
+		else
+		{
+			// EAP data packet and ARP packet.
+			// Use the 1M data rate to send the EAP/ARP packet.
+			// This will maybe make the handshake smooth.
+
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
+		   	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+		}
+
+
+		//4 offset 24
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+		if (pattrib->hw_tcp_csum == 1) {
+			// ptxdesc->txdw6 = 0; // clear TCP_CHECKSUM and IP_CHECKSUM. It's zero already!!
+			u8 ip_hdr_offset = 32 + pattrib->hdrlen + pattrib->iv_len + 8;
+			ptxdesc->txdw7 = (1 << 31) | (ip_hdr_offset << 16);
+			printk("ptxdesc->txdw7 = %08x\n", ptxdesc->txdw7);
+		}
+#endif
+
+		fill_txdesc_for_mp(pxmitframe, ptxdesc);
+	}
+	else if(pxmitframe->frame_tag == MGNT_FRAMETAG)
+	{
+		//printk("pxmitframe->frame_tag == MGNT_FRAMETAG\n");	
+
+		//4 offset 4
+		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id & 0x1f);//(MAC_ID)
+
+		qsel = (uint)(pattrib->qsel&0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
+
+		//fill_txdesc_sectype(pattrib, ptxdesc);
+
+
+		//4 offset 8
+
+
+		//4 offset 12
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
+
+
+		//4 offset 16
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+
+
+		//4 offset 20
+	}
+	else if(pxmitframe->frame_tag == TXAGG_FRAMETAG)
+	{
+		DBG_8192C("pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
+	}
+	else
+	{
+		DBG_8192C("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
+
+		//4 offset 4
+		ptxdesc->txdw1 |= cpu_to_le32((4)&0x1f);//CAM_ID(MAC_ID)
+
+		ptxdesc->txdw1 |= cpu_to_le32((6<< 16) & 0x000f0000);//raid
+
+
+		//4 offset 8
+
+
+		//4 offset 12
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum << 16) & 0xffff0000);
+
+
+		//4 offset 16
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+
+
+		//4 offset 20
+	}
+
+	// 2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS.
+	// (1) The sequence number of each non-Qos frame / broadcast / multicast /
+	// mgnt frame should be controled by Hw because Fw will also send null data
+	// which we cannot control when Fw LPS enable.
+	// --> default enable non-Qos data sequense number. 2010.06.23. by tynli.
+	// (2) Enable HW SEQ control for beacon packet, because we use Hw beacon.
+	// (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets.
+	// 2010.06.23. Added by tynli.
+	if(!pattrib->qos_en)
+	{		
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
+		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
+	}
+
+	cal_txdesc_chksum(ptxdesc);
+}
+#endif
+
+s32 rtw_update_txdesc(struct xmit_frame *pxmitframe, u32 *pmem, s32 sz)
+{
+	int pull=0;
+	uint qsel;
+	_adapter		*padapter = pxmitframe->padapter;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;		
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	struct tx_desc	*ptxdesc = (struct tx_desc *)pmem;
+	sint bmcst = IS_MCAST(pattrib->ra);
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	struct mlme_ext_info *pmlmeinfo = &padapter->mlmeextpriv.mlmext_info;
+
+	if(urb_zero_packet_chk(padapter, sz)==0)
+	{
+		ptxdesc = (struct tx_desc *)(pmem+(PACKET_OFFSET_SZ>>2));
+		pull = 1;
+	}
+	
+		
+	_rtw_memset(ptxdesc, 0, sizeof(struct tx_desc));
+	
+	//offset 0
+	ptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//32 bytes for TX Desc
+	
+	if(bmcst)	
+	{
+		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
+	}	
+
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offset0-txdesc=0x%x\n", ptxdesc->txdw0));
+
+	//offset 4
+	if(!pull) ptxdesc->txdw1 |= cpu_to_le32((0x01<<26)&0xff000000);//pkt_offset, unit:8 bytes padding
+
+
+	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
+	{
+		//printk("pxmitframe->frame_tag == DATA_FRAMETAG\n");			
+
+		//offset 4
+		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id & 0x1f);//(MAC_ID)
+
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
+
+		fill_txdesc_sectype(pattrib, ptxdesc);
+
+	
+		if(pattrib->ampdu_en==_TRUE)
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));//AGG EN
+		else
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
+		
+		//offset 8
+		
+
+		//offset 12
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
+
+
+		//offset 16 , offset 20
+		if (pattrib->qos_en)
+			ptxdesc->txdw4 |= cpu_to_le32(BIT(6));//QoS
+
+		if ((pattrib->ether_type != 0x888e) && (pattrib->ether_type != 0x0806) && (pattrib->dhcp_pkt != 1))
+		{
+              	//Non EAP & ARP & DHCP type data packet
+              	
+			fill_txdesc_vcs(pattrib, &ptxdesc->txdw4);
+			fill_txdesc_phy(pattrib, &ptxdesc->txdw4);
+
+			ptxdesc->txdw4 |= cpu_to_le32(0x00000008);//RTS Rate=24M
+			ptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);//
+			ptxdesc->txdw5 |= cpu_to_le32(0x0000000b);//DataRate - 54M
+				
+              	if(0)//for driver dbg
+			{
+				ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+				
+				if(pattrib->ht_en)
+					ptxdesc->txdw5 |= cpu_to_le32(BIT(6));//SGI
+
+				ptxdesc->txdw5 |= cpu_to_le32(0x00000013);//init rate - mcs7
+			}
+
+		}
+		else
+		{
+			// EAP data packet and ARP packet.
+			// Use the 1M data rate to send the EAP/ARP packet.
+			// This will maybe make the handshake smooth.
+
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
+			
+		   	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+
+		}
+		
+		//offset 24
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+		if ( pattrib->hw_tcp_csum == 1 ) {
+			// ptxdesc->txdw6 = 0; // clear TCP_CHECKSUM and IP_CHECKSUM. It's zero already!!
+			u8 ip_hdr_offset = 32 + pattrib->hdrlen + pattrib->iv_len + 8;
+			ptxdesc->txdw7 = (1 << 31) | (ip_hdr_offset << 16);
+			printk("ptxdesc->txdw7 = %08x\n", ptxdesc->txdw7);
+		}
+#endif
+
+		
+		fill_txdesc_for_mp(pxmitframe, ptxdesc);
+
+                  
+
+	}
+	else if((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG)
+	{
+		//printk("pxmitframe->frame_tag == MGNT_FRAMETAG\n");	
+		
+		//offset 4		
+		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id & 0x1f);//(MAC_ID)
+		
+		qsel = (uint)(pattrib->qsel&0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);
+
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
+		
+		//fill_txdesc_sectype(pattrib, ptxdesc);
+		
+		//offset 8		
+
+		//offset 12
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
+		
+		//offset 16
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+		
+		//offset 20
+		
+	}
+	else if((pxmitframe->frame_tag&0x0f) == TXAGG_FRAMETAG)
+	{
+		DBG_8192C("pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
+	}
+	else
+	{
+		DBG_8192C("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
+		
+		//offset 4	
+		ptxdesc->txdw1 |= cpu_to_le32((4)&0x1f);//CAM_ID(MAC_ID)
+		
+		ptxdesc->txdw1 |= cpu_to_le32((6<< 16) & 0x000f0000);//raid
+		
+		//offset 8		
+
+		//offset 12
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
+		
+		//offset 16
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+		
+		//offset 20
+	}
+
+	// 2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS.
+	// (1) The sequence number of each non-Qos frame / broadcast / multicast /
+	// mgnt frame should be controled by Hw because Fw will also send null data
+	// which we cannot control when Fw LPS enable.
+	// --> default enable non-Qos data sequense number. 2010.06.23. by tynli.
+	// (2) Enable HW SEQ control for beacon packet, because we use Hw beacon.
+	// (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets.
+	// 2010.06.23. Added by tynli.
+	if(!pattrib->qos_en)
+	{		
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
+		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
+	}
+
+	cal_txdesc_chksum(ptxdesc);
+		
+	return pull;
+		
+}
+
+#if USB_TX_AGGREGATION_92C
+static s32 xmitframe_need_length(struct xmit_frame *pxmitframe)
+{
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	int len = 0;
+
+	// no consider fragement
+	len = pattrib->hdrlen + pattrib->iv_len +
+		SNAP_SIZE + sizeof(u16) +
+		pattrib->pktlen +
+		((pattrib->bswenc) ? pattrib->icv_len : 0);
+
+	if(pattrib->encrypt ==_TKIP_)
+		len += 8;
+
+	return len;
+}
+
+#define IDEA_CONDITION 1	// check all packets before enqueue
+s32 rtw_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	struct xmit_frame *pxmitframe = NULL;
+	struct xmit_frame *pfirstframe = NULL;
+
+	// aggregate variable
+//	struct hw_xmit *phwxmit;
+	struct sta_info *psta = NULL;
+	struct tx_servq *ptxservq = NULL;
+
+	_irqL irqL;
+	_list *xmitframe_plist = NULL, *xmitframe_phead = NULL;
+
+	u32 pbuf;	// next pkt address
+	u32 pbuf_tail;	// last pkt tail
+	int len;	// packet length, except TXDESC_SIZE and PKT_OFFSET
+
+	unsigned int bulkSize = padapter->halpriv.UsbBulkOutSize;
+	int descCount;
+	u32 bulkPtr;
+
+	// dump frame variable
+	u32 ff_hwaddr;
+
+#ifndef IDEA_CONDITION
+	int res = _SUCCESS;
+#endif
+
+	RT_TRACE(_module_rtl8192c_xmit_c_, _drv_info_, ("+rtw_xmitframe_complete\n"));
+
+
+	// check xmitbuffer is ok
+	if (pxmitbuf == NULL) {
+		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
+		if (pxmitbuf == NULL) return _FALSE;
+	}
+
+
+	//3 1. pick up first frame
+	do {
+		rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+			
+		pxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitbuf->flags);
+		if (pxmitframe == NULL) {
+			// no more xmit frame, release xmit buffer
+			rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+			return _FALSE;
+		}
+
+
+#ifndef IDEA_CONDITION
+		if (pxmitframe->frame_tag != DATA_FRAMETAG) {
+			RT_TRACE(_module_rtl8192c_xmit_c_, _drv_err_,
+				 ("rtw_xmitframe_complete: frame tag(%d) is not DATA_FRAMETAG(%d)!\n",
+				  pxmitframe->frame_tag, DATA_FRAMETAG));
+//			rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+			continue;
+		}
+
+		// TID 0~15
+		if ((pxmitframe->attrib.priority < 0) ||
+		    (pxmitframe->attrib.priority > 15)) {
+			RT_TRACE(_module_rtl8192c_xmit_c_, _drv_err_,
+				 ("rtw_xmitframe_complete: TID(%d) should be 0~15!\n",
+				  pxmitframe->attrib.priority));
+//			rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+			continue;
+		}
+#endif
+
+		pxmitframe->pxmitbuf = pxmitbuf;
+		pxmitframe->buf_addr = pxmitbuf->pbuf;
+		pxmitbuf->priv_data = pxmitframe;
+
+		pxmitframe->agg_num = 1; // first frame of aggregation
+		pxmitframe->pkt_offset = 1; // first frame of aggregation, reserve offset
+
+#ifdef IDEA_CONDITION
+		rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+#else
+		res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+		if (res == _FALSE) {
+//			rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+			continue;
+		}
+#endif
+
+		// always return ndis_packet after rtw_xmitframe_coalesce
+		rtw_os_xmit_complete(padapter, pxmitframe);
+
+		if ((pxmitframe->attrib.ether_type != 0x0806) &&
+		    (pxmitframe->attrib.ether_type != 0x888e) &&
+		    (pxmitframe->attrib.dhcp_pkt != 1))
+			rtw_issue_addbareq_cmd(padapter, pxmitframe);
+
+		break;
+	} while (1);
+
+	//3 2. aggregate same priority and same DA(AP or STA) frames
+	pfirstframe = pxmitframe;
+	len = xmitframe_need_length(pfirstframe) + TXDESC_OFFSET;
+	pbuf_tail = len;
+	pbuf = _RND8(pbuf_tail);
+
+	// check pkt amount in one bluk
+	descCount = 0;
+	bulkPtr = bulkSize;
+	if (pbuf < bulkPtr)
+		descCount++;
+	else {
+		descCount = 0;
+		bulkPtr = ((pbuf / bulkSize) + 1) * bulkSize; // round to next bulkSize
+	}
+
+	// dequeue same priority packet from station tx queue
+	psta = pfirstframe->attrib.psta;
+	switch (pfirstframe->attrib.priority) {
+		case 1:
+		case 2:
+			ptxservq = &(psta->sta_xmitpriv.bk_q);
+//			phwxmit = pxmitpriv->hwxmits + 3;
+			break;
+
+		case 4:
+		case 5:
+			ptxservq = &(psta->sta_xmitpriv.vi_q);
+//			phwxmit = pxmitpriv->hwxmits + 1;
+			break;
+
+		case 6:
+		case 7:
+			ptxservq = &(psta->sta_xmitpriv.vo_q);
+//			phwxmit = pxmitpriv->hwxmits;
+			break;
+
+		case 0:
+		case 3:
+		default:
+			ptxservq = &(psta->sta_xmitpriv.be_q);
+//			phwxmit = pxmitpriv->hwxmits + 2;
+			break;
+	}
+
+	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+
+	xmitframe_phead = get_list_head(&ptxservq->sta_pending);
+	xmitframe_plist = get_next(xmitframe_phead);
+	while (rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist) == _FALSE)
+	{
+		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
+		xmitframe_plist = get_next(xmitframe_plist);
+
+		len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE; // no offset
+		if (pbuf + len > MAX_XMITBUF_SZ) break;
+
+		list_delete(&pxmitframe->list);
+		ptxservq->qcnt--;
+//		phwxmit->accnt--;	// ?
+//		phwxmit->txcmdcnt++;	// ?
+
+#ifndef IDEA_CONDITION
+		// suppose only data frames would be in queue
+		if (pxmitframe->frame_tag != DATA_FRAMETAG) {
+			RT_TRACE(_module_rtl8192c_xmit_c_, _drv_err_,
+				 ("rtw_xmitframe_complete: frame tag(%d) is not DATA_FRAMETAG(%d)!\n",
+				  pxmitframe->frame_tag, DATA_FRAMETAG));
+			rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+			continue;
+		}
+
+		// TID 0~15
+		if ((pxmitframe->attrib.priority < 0) ||
+		    (pxmitframe->attrib.priority > 15)) {
+			RT_TRACE(_module_rtl8192c_xmit_c_, _drv_err_,
+				 ("rtw_xmitframe_complete: TID(%d) should be 0~15!\n",
+				  pxmitframe->attrib.priority));
+			rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+			continue;
+		}
+#endif
+
+//		pxmitframe->pxmitbuf = pxmitbuf;
+		pxmitframe->buf_addr = pxmitbuf->pbuf + pbuf;
+
+		pxmitframe->agg_num = 0; // not first frame of aggregation
+		pxmitframe->pkt_offset = 0; // not first frame of aggregation, no need to reserve offset
+
+#ifdef IDEA_CONDITION
+		rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+#else
+		res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+		if (res == _FALSE) {
+			rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+			continue;
+		}
+#endif
+
+		// always return ndis_packet after rtw_xmitframe_coalesce
+		rtw_os_xmit_complete(padapter, pxmitframe);
+
+		if ((pxmitframe->attrib.ether_type != 0x0806) &&
+		    (pxmitframe->attrib.ether_type != 0x888e) &&
+		    (pxmitframe->attrib.dhcp_pkt != 1))
+			rtw_issue_addbareq_cmd(padapter, pxmitframe);
+
+		// (len - TXDESC_SIZE) == pxmitframe->attrib.last_txcmdsz
+		_update_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->attrib.last_txcmdsz);
+
+		// don't need xmitframe any more
+		rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+
+		// handle pointer and stop condition
+		pbuf_tail = pbuf + len;
+		pbuf = _RND8(pbuf_tail);
+
+		pfirstframe->agg_num++;
+		if (MAX_TX_AGG_PACKET_NUMBER == pfirstframe->agg_num)
+			break;
+
+		if (pbuf < bulkPtr) {
+			descCount++;
+			if (descCount == padapter->halpriv.UsbTxAggDescNum)
+				break;
+		} else {
+			descCount = 0;
+			bulkPtr = ((pbuf / bulkSize) + 1) * bulkSize;
+		}
+	}
+	
+	if (_rtw_queue_empty(&ptxservq->sta_pending) == _TRUE)
+		list_delete(&ptxservq->tx_pending);
+
+	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+
+	//3 3. update first frame txdesc
+	if ((pbuf_tail % bulkSize) == 0) {
+		// remove pkt_offset
+		pbuf_tail -= PACKET_OFFSET_SZ;
+		pfirstframe->buf_addr += PACKET_OFFSET_SZ;
+		pfirstframe->pkt_offset = 0;
+	}
+	_update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz);
+
+	//3 4. write xmit buffer to USB FIFO
+	ff_hwaddr = rtw_get_ff_hwaddr(pfirstframe);
+
+	// xmit address == ((xmit_frame*)pxmitbuf->priv_data)->buf_addr
+	rtw_write_port(padapter, ff_hwaddr, pbuf_tail, (u8*)pxmitbuf);
+
+
+	//3 5. update statisitc
+	pbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);
+	if (pfirstframe->pkt_offset == 1) pbuf_tail -= PACKET_OFFSET_SZ;
+	
+	count_tx_stats(padapter, pfirstframe, pbuf_tail);
+
+	rtw_free_xmitframe_ex(pxmitpriv, pfirstframe);
+
+	return _TRUE;
+}
+
+#else
+
+s32 rtw_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	struct xmit_frame *pxmitframe=NULL;	
+	int res=_SUCCESS, xcnt = 0;
+
+
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_xmitframe_complete()\n"));
+
+	if(pxmitbuf==NULL)
+	{
+		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);		
+		if(!pxmitbuf)
+		{
+			return _FALSE;
+		}			
+	}	
+
+
+	do
+	{		
+		pxmitframe =  rtw_dequeue_xframe(pxmitpriv, pxmitbuf->flags);
+		
+		if(pxmitframe)
+		{
+			pxmitframe->pxmitbuf = pxmitbuf;				
+
+			pxmitframe->buf_addr = pxmitbuf->pbuf;
+
+			pxmitbuf->priv_data = pxmitframe;	
+
+			if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
+			{	
+				if(pxmitframe->attrib.priority<=15)//TID0~15
+				{
+					res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+				}	
+							
+				rtw_os_xmit_complete(padapter, pxmitframe);//always return ndis_packet after rtw_xmitframe_coalesce 			
+			}	
+
+				
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_xmitframe_complete(): rtw_dump_xframe\n"));
+
+			
+			if(res == _SUCCESS)
+			{
+				rtw_dump_xframe(padapter, pxmitframe);		 
+			}
+			else
+			{
+				rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+				rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);	
+			}
+	 			 		
+			xcnt++;
+			
+		}
+		else
+		{			
+			rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+			return _FALSE;
+		}
+
+		break;
+		
+	}while(0/*xcnt < (NR_XMITFRAME >> 3)*/);
+
+	return _TRUE;
+	
+}
+#endif
+
+void rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int t, sz, w_sz, pull=0;
+	u8 *mem_addr;
+	u32 ff_hwaddr;
+	struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	if ((pxmitframe->frame_tag == DATA_FRAMETAG) &&
+	    (pxmitframe->attrib.ether_type != 0x0806) &&
+	    (pxmitframe->attrib.ether_type != 0x888e) &&
+	    (pxmitframe->attrib.dhcp_pkt != 1))
+		rtw_issue_addbareq_cmd(padapter, pxmitframe);
+
+	mem_addr = pxmitframe->buf_addr;
+
+       RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_dump_xframe()\n"));
+	
+	for (t = 0; t < pattrib->nr_frags; t++)
+	{
+		if (t != (pattrib->nr_frags - 1))
+		{
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("pattrib->nr_frags=%d\n", pattrib->nr_frags));
+
+			sz = pxmitpriv->frag_len;
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);					
+		}
+		else //no frag
+		{
+			sz = pattrib->last_txcmdsz;
+		}
+
+		pull = rtw_update_txdesc(pxmitframe, (uint*)mem_addr, sz);
+		
+		if(pull)
+		{
+			mem_addr += PACKET_OFFSET_SZ; //pull txdesc head
+			
+			//pxmitbuf ->pbuf = mem_addr;			
+			pxmitframe->buf_addr = mem_addr;
+
+			w_sz = sz + TXDESC_SIZE;
+		}
+		else
+		{
+			w_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;
+		}	
+
+		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
+		
+		rtw_write_port(padapter, ff_hwaddr, w_sz, (unsigned char*)pxmitbuf);
+
+		count_tx_stats(padapter, pxmitframe, sz);
+
+
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_write_port, w_sz=%d\n", w_sz));
+		//printk("rtw_write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority);      
+
+		mem_addr += w_sz;
+
+		mem_addr = (u8 *)RND4(((SIZE_PTR)(mem_addr)));
+
+	}
+	
+	rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+	
+}
+
+s32 xmitframe_direct(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	s32 res = _SUCCESS;
+
+
+	res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+	if (res == _SUCCESS) {
+		rtw_dump_xframe(padapter, pxmitframe);
+	}
+	
+	return res;
+}
+
+/*
+ * Return
+ *	_TRUE	dump packet directly
+ *	_FALSE	enqueue packet
+ */
+s32 pre_xmitframe(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	_irqL irqL;
+	s32 res;
+	struct xmit_buf *pxmitbuf = NULL;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+
+
+
+
+	rtw_do_queue_select(padapter, pattrib);
+	
+	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+	
+	if (rtw_txframes_sta_ac_pending(padapter, pattrib) > 0)
+		goto enqueue;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE)
+		goto enqueue;
+
+#ifdef CONFIG_AP_MODE
+	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == _TRUE)
+	{
+		_exit_critical_bh(&pxmitpriv->lock, &irqL);
+		return _FALSE;
+	}
+#endif
+
+	pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);	
+	if (pxmitbuf == NULL)
+		goto enqueue;
+	
+        _exit_critical_bh(&pxmitpriv->lock, &irqL);
+
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitframe->buf_addr = pxmitbuf->pbuf;
+	pxmitbuf->priv_data = pxmitframe;
+
+	if (xmitframe_direct(padapter, pxmitframe) != _SUCCESS) {
+		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+		rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+	}
+
+	return _TRUE;
+
+enqueue:
+	res = xmitframe_enqueue(padapter, pxmitframe);
+	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+
+	if (res != _SUCCESS) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("pre_xmitframe: enqueue xmitframe fail\n"));
+		rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+
+		// Trick, make the statistics correct
+		pxmitpriv->tx_pkts--;
+		pxmitpriv->tx_drop++;
+		return _TRUE;
+	}
+
+	return _FALSE;
+}
+
+/*
+ * Return
+ *	_TRUE	dump packet directly ok
+ *	_FALSE	temporary can't transmit packets to hardware
+ */
+s32 hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	return pre_xmitframe(padapter, pxmitframe);
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,2950 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _HCI_HAL_INIT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <hal_init.h>
+#include <rtl8712_efuse.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#ifndef CONFIG_USB_HCI
+
+#error "CONFIG_USB_HCI shall be on!\n"
+
+#endif
+
+#include <usb_ops.h>
+#include <usb_hal.h>
+#include <usb_osintf.h>
+
+//endpoint number 1,2,3,4,5
+// bult in : 1
+// bult out: 2 (High)
+// bult out: 3 (Normal) for 3 out_ep, (Low) for 2 out_ep
+// interrupt in: 4
+// bult out: 5 (Low) for 3 out_ep
+
+
+static VOID
+_OneOutEpMapping(
+	IN	HAL_DATA_TYPE	*pHalData
+	)
+{
+	//only endpoint number 0x02
+
+	pHalData->Queue2EPNum[0] = 0x02;//VO
+	pHalData->Queue2EPNum[1] = 0x02;//VI
+	pHalData->Queue2EPNum[2] = 0x02;//BE
+	pHalData->Queue2EPNum[3] = 0x02;//BK
+	
+	pHalData->Queue2EPNum[4] = 0x02;//TS
+	pHalData->Queue2EPNum[5] = 0x02;//MGT
+	pHalData->Queue2EPNum[6] = 0x02;//BMC
+	pHalData->Queue2EPNum[7] = 0x02;//BCN
+}
+
+
+static VOID
+_TwoOutEpMapping(
+	IN	BOOLEAN			IsTestChip,
+	IN	HAL_DATA_TYPE	*pHalData,
+	IN	BOOLEAN	 		bWIFICfg
+	)
+{
+
+/*
+#define VO_QUEUE_INX	0
+#define VI_QUEUE_INX		1
+#define BE_QUEUE_INX		2
+#define BK_QUEUE_INX		3
+#define TS_QUEUE_INX		4
+#define MGT_QUEUE_INX	5
+#define BMC_QUEUE_INX	6
+#define BCN_QUEUE_INX	7
+*/
+
+	if(IsTestChip && bWIFICfg){ // test chip && wmm
+	
+		
+		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
+		//{  1, 	0, 	1, 	0, 	0, 	0, 	0, 	0, 		0	};			
+		//0:H(end_number=0x02), 1:L (end_number=0x03)
+
+		pHalData->Queue2EPNum[0] = 0x02;//VO
+		pHalData->Queue2EPNum[1] = 0x03;//VI
+		pHalData->Queue2EPNum[2] = 0x02;//BE
+		pHalData->Queue2EPNum[3] = 0x03;//BK
+		
+		pHalData->Queue2EPNum[4] = 0x02;//TS
+		pHalData->Queue2EPNum[5] = 0x02;//MGT
+		pHalData->Queue2EPNum[6] = 0x02;//BMC
+		pHalData->Queue2EPNum[7] = 0x02;//BCN
+	
+	}
+	else if(!IsTestChip && bWIFICfg){ // Normal chip && wmm
+		
+		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
+		//{  0, 	1, 	0, 	1, 	0, 	0, 	0, 	0, 		0	};
+		//0:H(end_number=0x02), 1:L (end_number=0x03)
+		
+		pHalData->Queue2EPNum[0] = 0x02;//VO
+		pHalData->Queue2EPNum[1] = 0x03;//VI
+		pHalData->Queue2EPNum[2] = 0x02;//BE
+		pHalData->Queue2EPNum[3] = 0x03;//BK
+		
+		pHalData->Queue2EPNum[4] = 0x02;//TS
+		pHalData->Queue2EPNum[5] = 0x02;//MGT
+		pHalData->Queue2EPNum[6] = 0x02;//BMC
+		pHalData->Queue2EPNum[7] = 0x02;//BCN
+		
+	}
+	else{//typical setting
+
+		
+		//BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
+		//{  1, 	1, 	0, 	0, 	0, 	0, 	0, 	0, 		0	};			
+		//0:H(end_number=0x02), 1:L (end_number=0x03)
+		
+		pHalData->Queue2EPNum[0] = 0x02;//VO
+		pHalData->Queue2EPNum[1] = 0x02;//VI
+		pHalData->Queue2EPNum[2] = 0x03;//BE
+		pHalData->Queue2EPNum[3] = 0x03;//BK
+		
+		pHalData->Queue2EPNum[4] = 0x02;//TS
+		pHalData->Queue2EPNum[5] = 0x02;//MGT
+		pHalData->Queue2EPNum[6] = 0x02;//BMC
+		pHalData->Queue2EPNum[7] = 0x02;//BCN	
+		
+	}
+	
+}
+
+
+static VOID _ThreeOutEpMapping(
+	IN	HAL_DATA_TYPE	*pHalData,
+	IN	BOOLEAN	 		bWIFICfg
+	)
+{
+	if(bWIFICfg){//for WMM
+		
+		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
+		//{  1, 	2, 	1, 	0, 	0, 	0, 	0, 	0, 		0	};
+		//0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05)
+		
+		pHalData->Queue2EPNum[0] = 0x02;//VO
+		pHalData->Queue2EPNum[1] = 0x03;//VI
+		pHalData->Queue2EPNum[2] = 0x05;//BE
+		pHalData->Queue2EPNum[3] = 0x03;//BK
+		
+		pHalData->Queue2EPNum[4] = 0x02;//TS
+		pHalData->Queue2EPNum[5] = 0x02;//MGT
+		pHalData->Queue2EPNum[6] = 0x02;//BMC
+		pHalData->Queue2EPNum[7] = 0x02;//BCN
+		
+	}
+	else{//typical setting
+
+		
+		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
+		//{  2, 	2, 	1, 	0, 	0, 	0, 	0, 	0, 		0	};			
+		//0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05)
+		
+		pHalData->Queue2EPNum[0] = 0x02;//VO
+		pHalData->Queue2EPNum[1] = 0x03;//VI
+		pHalData->Queue2EPNum[2] = 0x05;//BE
+		pHalData->Queue2EPNum[3] = 0x05;//BK
+		
+		pHalData->Queue2EPNum[4] = 0x02;//TS
+		pHalData->Queue2EPNum[5] = 0x02;//MGT
+		pHalData->Queue2EPNum[6] = 0x02;//BMC
+		pHalData->Queue2EPNum[7] = 0x02;//BCN	
+	}
+
+}
+
+static BOOLEAN
+_MappingOutEP(
+	IN	PADAPTER	pAdapter,
+	IN	u8		NumOutPipe,
+	IN	BOOLEAN		IsTestChip
+	)
+{		
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	struct registry_priv *pregistrypriv = &pAdapter->registrypriv;
+
+	BOOLEAN	 bWIFICfg = (pregistrypriv->wifi_spec) ?_TRUE:_FALSE;
+	
+	BOOLEAN result = _TRUE;
+
+	switch(NumOutPipe)
+	{
+		case 2:
+			_TwoOutEpMapping(IsTestChip, pHalData, bWIFICfg);
+			break;
+		case 3:
+			// Test chip doesn't support three out EPs.
+			if(IsTestChip){
+				return _FALSE;
+			}			
+			_ThreeOutEpMapping(pHalData, bWIFICfg);
+			break;
+		case 1:
+			_OneOutEpMapping(pHalData);
+			break;
+		default:
+			result = _FALSE;
+			break;
+	}
+
+	return result;
+	
+}
+
+static VOID
+_ConfigTestChipOutEP(
+	IN	PADAPTER	pAdapter,
+	IN	u8		NumOutPipe
+	)
+{
+	u8			value8,txqsele;
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(pAdapter);
+
+	pHalData->OutEpQueueSel = 0;
+	pHalData->OutEpNumber	= 0;
+
+	value8 = rtw_read8(pAdapter, REG_TEST_SIE_OPTIONAL);
+	value8 = (value8 & USB_TEST_EP_MASK) >> USB_TEST_EP_SHIFT;
+	
+	switch(value8)
+	{
+		case 0:		// 2 bulk OUT, 1 bulk IN
+		case 3:		
+			pHalData->OutEpQueueSel = TX_SELE_HQ | TX_SELE_LQ;
+			pHalData->OutEpNumber	= 2;
+			//RT_TRACE(COMP_INIT,  DBG_LOUD, ("EP Config: 2 bulk OUT, 1 bulk IN\n"));
+			break;
+		case 1:		// 1 bulk IN/OUT => map all endpoint to Low queue
+		case 2:		// 1 bulk IN, 1 bulk OUT => map all endpoint to High queue
+			txqsele = rtw_read8(pAdapter, REG_TEST_USB_TXQS);
+			if(txqsele & 0x0F){//map all endpoint to High queue
+				pHalData->OutEpQueueSel  = TX_SELE_HQ;
+			}
+			else if(txqsele&0xF0){//map all endpoint to Low queue
+				pHalData->OutEpQueueSel  =  TX_SELE_LQ;
+			}
+			pHalData->OutEpNumber	= 1;
+			//RT_TRACE(COMP_INIT,  DBG_LOUD, ("%s\n", ((1 == value8) ? "1 bulk IN/OUT" : "1 bulk IN, 1 bulk OUT")));
+			break;
+		default:
+			break;
+	}
+
+	// TODO: Error recovery for this case
+	//RT_ASSERT((NumOutPipe == pHalData->OutEpNumber), ("Out EP number isn't match! %d(Descriptor) != %d (SIE reg)\n", (u4Byte)NumOutPipe, (u4Byte)pHalData->OutEpNumber));
+
+}
+
+
+
+static VOID
+_ConfigNormalChipOutEP(
+	IN	PADAPTER	pAdapter,
+	IN	u8		NumOutPipe
+	)
+{
+	u8			value8;
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(pAdapter);
+
+	pHalData->OutEpQueueSel = 0;
+	pHalData->OutEpNumber	= 0;
+		
+	// Normal and High queue
+	value8 = rtw_read8(pAdapter, (REG_NORMAL_SIE_EP + 1));
+	
+	if(value8 & USB_NORMAL_SIE_EP_MASK){
+		pHalData->OutEpQueueSel |= TX_SELE_HQ;
+		pHalData->OutEpNumber++;
+	}
+	
+	if((value8 >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK){
+		pHalData->OutEpQueueSel |= TX_SELE_NQ;
+		pHalData->OutEpNumber++;
+	}
+	
+	// Low queue
+	value8 = rtw_read8(pAdapter, (REG_NORMAL_SIE_EP + 2));
+	if(value8 & USB_NORMAL_SIE_EP_MASK){
+		pHalData->OutEpQueueSel |= TX_SELE_LQ;
+		pHalData->OutEpNumber++;
+	}
+
+	// TODO: Error recovery for this case
+	//RT_ASSERT((NumOutPipe == pHalData->OutEpNumber), ("Out EP number isn't match! %d(Descriptor) != %d (SIE reg)\n", (u4Byte)NumOutPipe, (u4Byte)pHalData->OutEpNumber));
+
+}
+
+static BOOLEAN HalUsbSetQueuePipeMapping8192CUsb(
+	IN	PADAPTER	pAdapter,
+	IN	u8		NumInPipe,
+	IN	u8		NumOutPipe
+	)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(pAdapter);
+	BOOLEAN			result		= _FALSE;
+	BOOLEAN			isNormalChip;
+
+	// ReadAdapterInfo8192C also call _ReadChipVersion too.
+	// Since we need dynamic config EP mapping, so we call this function to get chip version.
+	// We can remove _ReadChipVersion from ReadAdapterInfo8192C later.
+	rtl8192c_ReadChipVersion(pAdapter);
+
+	isNormalChip = IS_NORMAL_CHIP(pHalData->VersionID);
+
+	if(isNormalChip){
+		_ConfigNormalChipOutEP(pAdapter, NumOutPipe);
+	}
+	else{
+		_ConfigTestChipOutEP(pAdapter, NumOutPipe);
+	}
+
+	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
+	if(isNormalChip && (1 == pHalData->OutEpNumber)){
+		if(1 != NumInPipe){
+			return result;
+		}
+	}
+
+	// All config other than above support one Bulk IN and one Interrupt IN.
+	//if(2 != NumInPipe){
+	//	return result;
+	//}
+
+	result = _MappingOutEP(pAdapter, NumOutPipe, !isNormalChip);
+	
+	return result;
+
+}
+
+void rtl8192cu_interface_configure(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+
+#if USB_TX_AGGREGATION_92C
+	pHalData->UsbTxAggMode		= 1;
+	pHalData->UsbTxAggDescNum	= 0x6;	// only 4 bits
+#endif
+
+#if USB_RX_AGGREGATION_92C
+	pHalData->UsbRxAggMode		=USB_RX_AGG_DMA;  // USB_RX_AGG_MIX;
+	pHalData->UsbRxAggBlockCount	= 8; //unit : 512b
+	pHalData->UsbRxAggBlockTimeout	= 0x6;
+	pHalData->UsbRxAggPageCount	= 48; //uint :128 b //0x0A;	// 10 = MAX_RX_DMA_BUFFER_SIZE/2/pHalData->UsbBulkOutSize
+	pHalData->UsbRxAggPageTimeout	= 0x4; //6, absolute time = 34ms/(2^6)
+#endif
+
+	HalUsbSetQueuePipeMapping8192CUsb(padapter,
+				(u8)pHalData->RtNumInPipes, (u8)pHalData->RtNumOutPipes);
+
+}
+
+static u8 _InitPowerOn(_adapter *padapter)
+{
+	u8	ret = _SUCCESS;
+	u32 value32=0;
+	u16	value16=0;
+	u8	value8 = 0;
+
+	// polling autoload done.
+	u32	pollingCount = 0;
+
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	do
+	{
+		if(rtw_read8(padapter, REG_APS_FSMCO) & PFM_ALDN){
+			//RT_TRACE(COMP_INIT,DBG_LOUD,("Autoload Done!\n"));
+			break;
+		}
+
+		if(pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n"));
+			return _FAIL;
+		}
+				
+	}while(_TRUE);
+
+
+//	For hardware power on sequence.
+
+	//0.	RSV_CTRL 0x1C[7:0] = 0x00			// unlock ISO/CLK/Power control register
+	rtw_write8(padapter, REG_RSV_CTRL, 0x0);	
+	// Power on when re-enter from IPS/Radio off/card disable
+	rtw_write8(padapter, REG_SPS0_CTRL, 0x2b);//enable SPS into PWM mode
+/*
+	value16 = PlatformIORead2Byte(Adapter, REG_AFE_XTAL_CTRL);//enable AFE clock
+	value16 &=  (~XTAL_GATE_AFE);
+	PlatformIOWrite2Byte(Adapter,REG_AFE_XTAL_CTRL, value16 );		
+*/
+	
+	rtw_udelay_os(100);//PlatformSleepUs(150);//this is not necessary when initially power on
+
+	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);	
+	if(0== (value8 & LDV12_EN) ){
+		value8 |= LDV12_EN;
+		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);	
+		//RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
+		rtw_udelay_os(100);//PlatformSleepUs(100);//this is not necessary when initially power on
+		value8 = rtw_read8(padapter, REG_SYS_ISO_CTRL);
+		value8 &= ~ISO_MD2PP;
+		rtw_write8(padapter, REG_SYS_ISO_CTRL, value8);			
+	}	
+	
+	// auto enable WLAN
+	pollingCount = 0;
+	value16 = rtw_read16(padapter, REG_APS_FSMCO);
+	value16 |= APFM_ONMAC;
+	rtw_write16(padapter, REG_APS_FSMCO, value16);
+
+	do
+	{
+		if(0 == (rtw_read16(padapter, REG_APS_FSMCO) & APFM_ONMAC)){
+			//RT_TRACE(COMP_INIT,DBG_LOUD,("MAC auto ON okay!\n"));
+			break;
+		}
+
+		if(pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n"));
+			return _FAIL;
+		}
+				
+	}while(_TRUE);
+
+	//Enable Radio ,GPIO ,and LED function
+	rtw_write16(padapter,REG_APS_FSMCO,0x0812);
+
+#ifdef CONFIG_AUTOSUSPEND
+	//for usb Combo card ,BT
+	if((BOARD_USB_COMBO == pHalData->BoardType)&&(padapter->registrypriv.usbss_enable))
+	{
+		value32 =  rtw_read32(padapter, REG_APS_FSMCO);
+		value32 |= (SOP_ABG|SOP_AMB|XOP_BTCK);
+		rtw_write32(padapter, REG_APS_FSMCO, value32);		
+	}
+#endif	
+
+	// release RF digital isolation
+	value16 = rtw_read16(padapter, REG_SYS_ISO_CTRL);
+	value16 &= ~ISO_DIOR;
+	rtw_write16(padapter, REG_SYS_ISO_CTRL, value16);
+
+#if 0
+	// Reconsider when to do this operation after asking HWSD.
+	pollingCount = 0;
+	rtw_write8(padapter, REG_APSD_CTRL, (rtw_read8(padapter, REG_APSD_CTRL) & ~BIT6));
+	do{
+		pollingCount++;	
+	}while((pollingCount<200) && (rtw_read8(padapter, REG_APSD_CTRL)&BIT7)); //polling until BIT7 is 0. by tynli
+#endif
+
+	// Enable MAC DMA/WMAC/SCHEDULE/SEC block
+	value16 = rtw_read16(padapter, REG_CR);
+	value16 |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN
+				| PROTOCOL_EN | SCHEDULE_EN | MACTXEN | MACRXEN | ENSEC);
+	rtw_write16(padapter, REG_CR, value16);
+	
+	//tynli_test for suspend mode.
+	{
+		rtw_write8(padapter,  0xfe10, 0x19);
+	}
+	
+	return ret;
+
+}
+
+
+static void _dbg_dump_macreg(_adapter *padapter)
+{
+	u32 offset = 0;
+	u32 val32 = 0;
+	u32 index =0 ;
+	for(index=0;index<64;index++)
+	{
+		offset = index*4;
+		val32 = rtw_read32(padapter,offset);
+		printk("offset : 0x%02x ,val:0x%08x\n",offset,val32);
+	}
+}
+
+
+static void _InitPABias(_adapter *padapter)
+{
+	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(padapter);
+	u8			pa_setting;
+	BOOLEAN		isNormal = IS_NORMAL_CHIP(pHalData->VersionID);
+	BOOLEAN		is92C = IS_92C_SERIAL(pHalData->VersionID);
+	
+	//FIXED PA current issue	
+	efuse_one_byte_read(padapter, 0x1FA, &pa_setting);
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("_InitPABias 0x1FA 0x%x \n",pa_setting));
+
+	if(!(pa_setting & BIT0))
+	{
+		PHY_SetRFReg(padapter, RF90_PATH_A, 0x15, 0x0FFFFF, 0x0F406);
+		PHY_SetRFReg(padapter, RF90_PATH_A, 0x15, 0x0FFFFF, 0x4F406);		
+		PHY_SetRFReg(padapter, RF90_PATH_A, 0x15, 0x0FFFFF, 0x8F406);		
+		PHY_SetRFReg(padapter, RF90_PATH_A, 0x15, 0x0FFFFF, 0xCF406);		
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("PA BIAS path A\n"));
+	}	
+
+	if(!(pa_setting & BIT1) && isNormal && is92C)
+	{
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0x15, 0x0FFFFF, 0x0F406);
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0x15, 0x0FFFFF, 0x4F406);		
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0x15, 0x0FFFFF, 0x8F406);		
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0x15, 0x0FFFFF, 0xCF406);
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("PA BIAS path B\n"));	
+	}
+
+	if(!(pa_setting & BIT4))
+	{
+		pa_setting = rtw_read8(padapter, 0x16);
+		pa_setting &= 0x0F; 
+		rtw_write8(padapter, 0x16, pa_setting | 0x90);		
+	}
+}
+
+
+//-------------------------------------------------------------------------
+//
+// LLT R/W/Init function
+//
+//-------------------------------------------------------------------------
+static u8 _LLTWrite(
+	IN  PADAPTER	Adapter,
+	IN	u32		address,
+	IN	u32		data
+	)
+{
+	u8	status = _SUCCESS;
+	int 		count = 0;
+	u32 		value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);
+
+	rtw_write32(Adapter, REG_LLT_INIT, value);
+	
+	//polling
+	do{
+		
+		value = rtw_read32(Adapter, REG_LLT_INIT);
+		if(_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
+			break;
+		}
+		
+		if(count > POLLING_LLT_THRESHOLD){
+			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling write LLT done at address %d!\n", address));
+			status = _FAIL;
+			break;
+		}
+	}while(count++);
+
+	return status;
+	
+}
+
+
+static u8 _LLTRead(
+	IN  PADAPTER	Adapter,
+	IN	u32		address
+	)
+{
+	int		count = 0;
+	u32		value = _LLT_INIT_ADDR(address) | _LLT_OP(_LLT_READ_ACCESS);
+
+	rtw_write32(Adapter, REG_LLT_INIT, value);
+
+	//polling and get value
+	do{
+		
+		value = rtw_read32(Adapter, REG_LLT_INIT);
+		if(_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
+			return (u8)value;
+		}
+		
+		if(count > POLLING_LLT_THRESHOLD){
+			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling read LLT done at address %d!\n", address));
+			break;
+		}
+	}while(count++);
+
+	return 0xFF;
+
+}
+
+
+static u8 InitLLTTable(
+	IN  PADAPTER	Adapter,
+	IN	u32		boundary
+	)
+{
+	u8	status = _SUCCESS;
+	u32		i;
+
+	for(i = 0 ; i < (boundary - 1) ; i++){
+		status = _LLTWrite(Adapter, i , i + 1);
+		if(_SUCCESS != status){
+			return status;
+		}
+	}
+
+	// end of list
+	status = _LLTWrite(Adapter, (boundary - 1), 0xFF); 
+	if(_SUCCESS != status){
+		return status;
+	}
+
+	// Make the other pages as ring buffer
+	// This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer.
+	// Otherwise used as local loopback buffer. 
+	for(i = boundary ; i < LAST_ENTRY_OF_TX_PKT_BUFFER ; i++){
+		status = _LLTWrite(Adapter, i, (i + 1)); 
+		if(_SUCCESS != status){
+			return status;
+		}
+	}
+	
+	// Let last entry point to the start entry of ring buffer
+	status = _LLTWrite(Adapter, LAST_ENTRY_OF_TX_PKT_BUFFER, boundary);
+	if(_SUCCESS != status){
+		return status;
+	}
+
+	return status;
+	
+}
+
+
+//---------------------------------------------------------------
+//
+//	MAC init functions
+//
+//---------------------------------------------------------------
+static VOID
+_SetMacID(
+	IN  PADAPTER Adapter, u8* MacID
+	)
+{
+	u32 i;
+	for(i=0 ; i< MAC_ADDR_LEN ; i++){
+		rtw_write32(Adapter, REG_MACID+i, MacID[i]);
+	}
+}
+
+static VOID
+_SetBSSID(
+	IN  PADAPTER Adapter, u8* BSSID
+	)
+{
+	u32 i;
+	for(i=0 ; i< MAC_ADDR_LEN ; i++){
+		rtw_write32(Adapter, REG_BSSID+i, BSSID[i]);
+	}
+}
+
+
+// Shall USB interface init this?
+static VOID
+_InitInterrupt(
+	IN  PADAPTER Adapter
+	)
+{
+	u32	value32;
+
+	// HISR - turn all on
+	value32 = 0xFFFFFFFF;
+	rtw_write32(Adapter, REG_HISR, value32);
+
+	// HIMR - turn all on
+	rtw_write32(Adapter, REG_HIMR, value32);
+}
+
+
+static VOID
+_InitQueueReservedPage(
+	IN  PADAPTER Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	BOOLEAN			isNormalChip = IS_NORMAL_CHIP(pHalData->VersionID);
+	
+	u32			outEPNum	= (u32)pHalData->OutEpNumber;
+	u32			numHQ		= 0;
+	u32			numLQ		= 0;
+	u32			numNQ		= 0;
+	u32			numPubQ;
+	u32			value32;
+	u8			value8;
+	u32			txQPageNum, txQPageUnit,txQRemainPage;
+
+	if(!pregistrypriv->wifi_spec){		
+		numPubQ = (isNormalChip) ? NORMAL_PAGE_NUM_PUBQ : TEST_PAGE_NUM_PUBQ;
+		//RT_ASSERT((numPubQ < TX_TOTAL_PAGE_NUMBER), ("Public queue page number is great than total tx page number.\n"));
+		txQPageNum = TX_TOTAL_PAGE_NUMBER - numPubQ;
+
+		//RT_ASSERT((0 == txQPageNum%txQPageNum), ("Total tx page number is not dividable!\n"));
+		
+		txQPageUnit = txQPageNum/outEPNum;
+		txQRemainPage = txQPageNum % outEPNum;
+
+		if(pHalData->OutEpQueueSel & TX_SELE_HQ){
+			numHQ = txQPageUnit;
+		}
+		if(pHalData->OutEpQueueSel & TX_SELE_LQ){
+			numLQ = txQPageUnit;
+		}
+		// HIGH priority queue always present in the configuration of 2 or 3 out-ep 
+		// so ,remainder pages have assigned to High queue
+		if((outEPNum>1) && (txQRemainPage)){			
+			numHQ += txQRemainPage;
+		}
+
+		// NOTE: This step shall be proceed before writting REG_RQPN.
+		if(isNormalChip){
+			if(pHalData->OutEpQueueSel & TX_SELE_NQ){
+				numNQ = txQPageUnit;
+			}
+			value8 = (u8)_NPQ(numNQ);
+			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
+		}
+		//RT_ASSERT(((numHQ + numLQ + numNQ + numPubQ) < TX_PAGE_BOUNDARY), ("Total tx page number is greater than tx boundary!\n"));
+	}
+	else{ //for WMM 
+		//RT_ASSERT((outEPNum>=2), ("for WMM ,number of out-ep must more than or equal to 2!\n"));
+		
+		numPubQ = (isNormalChip) 	?WMM_NORMAL_PAGE_NUM_PUBQ
+								:WMM_TEST_PAGE_NUM_PUBQ;		
+		
+		if(pHalData->OutEpQueueSel & TX_SELE_HQ){
+			numHQ = (isNormalChip)?WMM_NORMAL_PAGE_NUM_HPQ
+								:WMM_TEST_PAGE_NUM_HPQ;
+		}
+
+		if(pHalData->OutEpQueueSel & TX_SELE_LQ){
+			numLQ = (isNormalChip)?WMM_NORMAL_PAGE_NUM_LPQ
+								:WMM_TEST_PAGE_NUM_LPQ;
+		}
+		// NOTE: This step shall be proceed before writting REG_RQPN.
+		if(isNormalChip){			
+			if(pHalData->OutEpQueueSel & TX_SELE_NQ){
+				numNQ = WMM_NORMAL_PAGE_NUM_NPQ;
+			}
+			value8 = (u8)_NPQ(numNQ);
+			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
+		}
+	}
+
+	// TX DMA
+	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;	
+	rtw_write32(Adapter, REG_RQPN, value32);	
+}
+
+static void _InitID(IN  PADAPTER Adapter)
+{
+	int i;	 
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	
+	for(i=0; i<6; i++)
+	{
+		rtw_write8(Adapter, (REG_MACID+i), pEEPROM->mac_addr[i]);		 	
+	}
+
+/*
+	NicIFSetMacAddress(Adapter, Adapter->PermanentAddress);
+	//Ziv test
+#if 1
+	{
+		u1Byte sMacAddr[6] = {0};
+		u4Byte i;
+		
+		for(i = 0 ; i < MAC_ADDR_LEN ; i++){
+			sMacAddr[i] = PlatformIORead1Byte(Adapter, (REG_MACID + i));
+		}
+		RT_PRINT_ADDR(COMP_INIT|COMP_EFUSE, DBG_LOUD, "Read back MAC Addr: ", sMacAddr);
+	}
+#endif
+
+#if 0
+	u4Byte nMAR 	= 0xFFFFFFFF;
+	u8 m_MacID[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
+	u8 m_BSSID[] = {0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
+	int i;
+	
+	_SetMacID(Adapter, Adapter->PermanentAddress);
+	_SetBSSID(Adapter, m_BSSID);
+
+	//set MAR
+	PlatformIOWrite4Byte(Adapter, REG_MAR, nMAR);
+	PlatformIOWrite4Byte(Adapter, REG_MAR+4, nMAR);
+#endif
+*/
+}
+
+
+static VOID
+_InitTxBufferBoundary(
+	IN  PADAPTER Adapter
+	)
+{	
+	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+	
+	u8	txpktbuf_bndy; 
+
+	if(!pregistrypriv->wifi_spec){
+		txpktbuf_bndy = TX_PAGE_BOUNDARY;
+	}
+	else{//for WMM
+		txpktbuf_bndy = ( IS_NORMAL_CHIP( pHalData->VersionID))?WMM_NORMAL_TX_PAGE_BOUNDARY
+															:WMM_TEST_TX_PAGE_BOUNDARY;
+	}
+
+	rtw_write8(Adapter, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
+	rtw_write8(Adapter, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);
+	rtw_write8(Adapter, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);
+	rtw_write8(Adapter, REG_TRXFF_BNDY, txpktbuf_bndy);	
+#if 1
+	rtw_write8(Adapter, REG_TDECTRL+1, txpktbuf_bndy);
+#else
+	txdmactrl = PlatformIORead2Byte(Adapter, REG_TDECTRL);
+	txdmactrl &= ~BCN_HEAD_MASK;
+	txdmactrl |= BCN_HEAD(txpktbuf_bndy);
+	PlatformIOWrite2Byte(Adapter, REG_TDECTRL, txdmactrl);
+#endif
+}
+
+static VOID
+_InitPageBoundary(
+	IN  PADAPTER Adapter
+	)
+{
+	// RX Page Boundary
+	//srand(static_cast<unsigned int>(time(NULL)) );
+	u16 rxff_bndy = 0x27FF;//(rand() % 1) ? 0x27FF : 0x23FF;
+
+	rtw_write16(Adapter, (REG_TRXFF_BNDY + 2), rxff_bndy);
+
+	// TODO: ?? shall we set tx boundary?
+}
+
+
+static VOID
+_InitNormalChipRegPriority(
+	IN	PADAPTER	Adapter,
+	IN	u16		beQ,
+	IN	u16		bkQ,
+	IN	u16		viQ,
+	IN	u16		voQ,
+	IN	u16		mgtQ,
+	IN	u16		hiQ
+	)
+{
+	u16 value16		= (rtw_read16(Adapter, REG_TRXDMA_CTRL) & 0x7);
+
+	value16 |=	_TXDMA_BEQ_MAP(beQ) 	| _TXDMA_BKQ_MAP(bkQ) |
+				_TXDMA_VIQ_MAP(viQ) 	| _TXDMA_VOQ_MAP(voQ) |
+				_TXDMA_MGQ_MAP(mgtQ)| _TXDMA_HIQ_MAP(hiQ);
+	
+	rtw_write16(Adapter, REG_TRXDMA_CTRL, value16);
+}
+
+static VOID
+_InitNormalChipOneOutEpPriority(
+	IN	PADAPTER Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+
+	u16	value = 0;
+	switch(pHalData->OutEpQueueSel)
+	{
+		case TX_SELE_HQ:
+			value = QUEUE_HIGH;
+			break;
+		case TX_SELE_LQ:
+			value = QUEUE_LOW;
+			break;
+		case TX_SELE_NQ:
+			value = QUEUE_NORMAL;
+			break;
+		default:
+			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
+			break;
+	}
+	
+	_InitNormalChipRegPriority(Adapter,
+								value,
+								value,
+								value,
+								value,
+								value,
+								value
+								);
+
+}
+
+static VOID
+_InitNormalChipTwoOutEpPriority(
+	IN	PADAPTER Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
+	
+
+	u16	valueHi = 0;
+	u16	valueLow = 0;
+	
+	switch(pHalData->OutEpQueueSel)
+	{
+		case (TX_SELE_HQ | TX_SELE_LQ):
+			valueHi = QUEUE_HIGH;
+			valueLow = QUEUE_LOW;
+			break;
+		case (TX_SELE_NQ | TX_SELE_LQ):
+			valueHi = QUEUE_NORMAL;
+			valueLow = QUEUE_LOW;
+			break;
+		case (TX_SELE_HQ | TX_SELE_NQ):
+			valueHi = QUEUE_HIGH;
+			valueLow = QUEUE_NORMAL;
+			break;
+		default:
+			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
+			break;
+	}
+
+	if(!pregistrypriv->wifi_spec ){
+		beQ 		= valueLow;
+		bkQ 		= valueLow;
+		viQ		= valueHi;
+		voQ 		= valueHi;
+		mgtQ 	= valueHi; 
+		hiQ 		= valueHi;								
+	}
+	else{//for WMM ,CONFIG_OUT_EP_WIFI_MODE
+		beQ		= valueHi;
+		bkQ 		= valueLow;		
+		viQ 		= valueLow;
+		voQ 		= valueHi;
+		mgtQ 	= valueHi;
+		hiQ 		= valueHi;							
+	}
+	
+	_InitNormalChipRegPriority(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
+
+}
+
+static VOID
+_InitNormalChipThreeOutEpPriority(
+	IN	PADAPTER Adapter
+	)
+{
+	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
+
+	if(!pregistrypriv->wifi_spec ){// typical setting
+		beQ		= QUEUE_LOW;
+		bkQ 		= QUEUE_LOW;
+		viQ 		= QUEUE_NORMAL;
+		voQ 		= QUEUE_HIGH;
+		mgtQ 	= QUEUE_HIGH;
+		hiQ 		= QUEUE_HIGH;			
+	}
+	else{// for WMM
+		beQ		= QUEUE_LOW;
+		bkQ 		= QUEUE_NORMAL;
+		viQ 		= QUEUE_NORMAL;
+		voQ 		= QUEUE_HIGH;
+		mgtQ 	= QUEUE_HIGH;
+		hiQ 		= QUEUE_HIGH;			
+	}
+	_InitNormalChipRegPriority(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
+}
+
+static VOID
+_InitNormalChipQueuePriority(
+	IN	PADAPTER Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+
+	switch(pHalData->OutEpNumber)
+	{
+		case 1:
+			_InitNormalChipOneOutEpPriority(Adapter);
+			break;
+		case 2:
+			_InitNormalChipTwoOutEpPriority(Adapter);
+			break;
+		case 3:
+			_InitNormalChipThreeOutEpPriority(Adapter);
+			break;
+		default:
+			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
+			break;
+	}
+
+
+}
+
+static VOID
+_InitTestChipQueuePriority(
+	IN	PADAPTER Adapter
+	)
+{
+	u8	hq_sele ;
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	
+	switch(pHalData->OutEpNumber)
+	{
+		case 2:	// (TX_SELE_HQ|TX_SELE_LQ)
+			if(!pregistrypriv->wifi_spec)//typical setting			
+				hq_sele =  HQSEL_VOQ | HQSEL_VIQ | HQSEL_MGTQ | HQSEL_HIQ ;
+			else	//for WMM
+				hq_sele = HQSEL_VOQ | HQSEL_BEQ | HQSEL_MGTQ | HQSEL_HIQ ;
+			break;
+		case 1:
+			if(TX_SELE_LQ == pHalData->OutEpQueueSel ){//map all endpoint to Low queue
+				 hq_sele = 0;
+			}
+			else if(TX_SELE_HQ == pHalData->OutEpQueueSel){//map all endpoint to High queue
+				hq_sele =  HQSEL_VOQ | HQSEL_VIQ | HQSEL_BEQ | HQSEL_BKQ | HQSEL_MGTQ | HQSEL_HIQ ;
+			}		
+			break;
+		default:
+			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
+			break;
+	}
+	rtw_write8(Adapter, (REG_TRXDMA_CTRL+1), hq_sele);
+}
+
+
+static VOID
+_InitQueuePriority(
+	IN  PADAPTER Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+
+	if(IS_NORMAL_CHIP( pHalData->VersionID)){
+		_InitNormalChipQueuePriority(Adapter);
+	}
+	else{
+		_InitTestChipQueuePriority(Adapter);
+	}
+}
+
+static VOID
+_InitHardwareDropIncorrectBulkOut(
+	IN  PADAPTER Adapter
+	)
+{
+	u32	value32 = rtw_read32(Adapter, REG_TXDMA_OFFSET_CHK);
+	value32 |= DROP_DATA_EN;
+	rtw_write32(Adapter, REG_TXDMA_OFFSET_CHK, value32);
+}
+
+static VOID
+_InitNetworkType(
+	IN  PADAPTER Adapter
+	)
+{
+	u32	value32;
+
+	value32 = rtw_read32(Adapter, REG_CR);
+
+	// TODO: use the other function to set network type
+#if RTL8191C_FPGA_NETWORKTYPE_ADHOC
+	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AD_HOC);
+#else
+	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);
+#endif
+	rtw_write32(Adapter, REG_CR, value32);
+//	RASSERT(pIoBase->rtw_read8(REG_CR + 2) == 0x2);
+}
+
+static VOID
+_InitTransferPageSize(
+	IN  PADAPTER Adapter
+	)
+{
+	// Tx page size is always 128.
+	
+	u8	value8;
+	value8 = _PSRX(PBP_128) | _PSTX(PBP_128);
+	rtw_write8(Adapter, REG_PBP, value8);
+}
+
+static VOID
+_InitDriverInfoSize(
+	IN  PADAPTER	Adapter,
+	IN	u8		drvInfoSize
+	)
+{
+	rtw_write8(Adapter,REG_RX_DRVINFO_SZ, drvInfoSize);
+}
+
+static VOID
+_InitWMACSetting(
+	IN  PADAPTER Adapter
+	)
+{
+	//u4Byte			value32;
+	u16			value16;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	//pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
+	pHalData->ReceiveConfig = RCR_AAP | RCR_APM | RCR_AM | RCR_AB | RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYSTS;
+#if (0 == RTL8192C_RX_PACKET_NO_INCLUDE_CRC)
+	pHalData->ReceiveConfig |= ACRC32;
+#endif
+
+	// some REG_RCR will be modified later by phy_ConfigMACWithHeaderFile()
+	rtw_write32(Adapter, REG_RCR, pHalData->ReceiveConfig);
+
+	// Accept all multicast address
+	rtw_write32(Adapter, REG_MAR, 0xFFFFFFFF);
+	rtw_write32(Adapter, REG_MAR + 4, 0xFFFFFFFF);
+
+	// Accept all management frames
+	value16 = 0xFFFF;
+	rtw_write16(Adapter, REG_RXFLTMAP0, value16);
+
+	//Reject all control frame - default value is 0
+	rtw_write16(Adapter,REG_RXFLTMAP1,0x0);
+
+	// Accept all data frames
+	value16 = 0xFFFF;
+	rtw_write16(Adapter, REG_RXFLTMAP2, value16);
+	
+	//enable RX_SHIFT bits
+	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));
+	
+}
+
+static VOID
+_InitAdaptiveCtrl(
+	IN  PADAPTER Adapter
+	)
+{
+	u16	value16;
+	u32	value32;
+
+	// Response Rate Set
+	value32 = rtw_read32(Adapter, REG_RRSR);
+	value32 &= ~RATE_BITMAP_ALL;
+	value32 |= RATE_RRSR_CCK_ONLY_1M;
+	rtw_write32(Adapter, REG_RRSR, value32);
+
+	// CF-END Threshold
+	//m_spIoBase->rtw_write8(REG_CFEND_TH, 0x1);
+
+	// SIFS (used in NAV)
+	value16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);
+	rtw_write16(Adapter, REG_SPEC_SIFS, value16);
+
+	// Retry Limit
+	value16 = _LRL(0x30) | _SRL(0x30);
+	rtw_write16(Adapter, REG_RL, value16);
+	
+}
+
+static VOID
+_InitRateFallback(
+	IN  PADAPTER Adapter
+	)
+{
+	// Set Data Auto Rate Fallback Retry Count register.
+	rtw_write32(Adapter, REG_DARFRC, 0x00000000);
+	rtw_write32(Adapter, REG_DARFRC+4, 0x10080404);
+	rtw_write32(Adapter, REG_RARFRC, 0x04030201);
+	rtw_write32(Adapter, REG_RARFRC+4, 0x08070605);
+
+}
+
+
+static VOID
+_InitEDCA(
+	IN  PADAPTER Adapter
+	)
+{
+	//PHAL_DATA_8192CUSB	pHalData = GetHalData8192CUsb(Adapter);
+	u16				value16;
+
+#if 0
+#if 1
+	//disable EDCCA count down, to reduce collison and retry
+	value16 = rtw_read16(Adapter, REG_RD_CTRL);
+	value16 |= DIS_EDCA_CNT_DWN;
+	rtw_write16(Adapter, REG_RD_CTRL, value16);	
+
+
+	// Update SIFS timing.  ??????????
+	//pHalData->SifsTime = 0x0e0e0a0a;
+	//Adapter->HalFunc.SetHwRegHandler( Adapter, HW_VAR_SIFS,  (pu1Byte)&pHalData->SifsTime);
+
+	// Set CCK/OFDM SIFS
+	rtw_write16(Adapter, REG_SIFS_CCK, 0x0a0a); // CCK SIFS shall always be 10us.
+	rtw_write16(Adapter, REG_SIFS_OFDM, 0x1010);
+#endif
+
+	rtw_write16(Adapter, REG_PROT_MODE_CTRL, 0x0204);
+
+	rtw_write32(Adapter, REG_BAR_MODE_CTRL, 0x014004);
+
+
+	// TXOP
+	rtw_write32(Adapter, REG_EDCA_BE_PARAM, 0x005EA42B);
+	rtw_write32(Adapter, REG_EDCA_BK_PARAM, 0x0000A44F);
+	rtw_write32(Adapter, REG_EDCA_VI_PARAM, 0x005EA324);
+	rtw_write32(Adapter, REG_EDCA_VO_PARAM, 0x002FA226);
+
+	// PIFS
+	rtw_write8(Adapter, REG_PIFS, 0x1C);
+		
+	//AGGR BREAK TIME Register
+	rtw_write8(Adapter, REG_AGGR_BREAK_TIME, 0x16);
+
+	rtw_write16(Adapter, REG_NAV_PROT_LEN, 0x0040);
+	
+	rtw_write8(Adapter, REG_BCNDMATIM, 0x02);
+
+	rtw_write8(Adapter, REG_ATIMWND, 0x02);
+#else
+
+	// Set Spec SIFS (used in NAV)
+	rtw_write16(Adapter,REG_SPEC_SIFS, 0x100a);
+	rtw_write16(Adapter,REG_MAC_SPEC_SIFS, 0x100a);
+
+	// Set SIFS for CCK
+	rtw_write16(Adapter,REG_SIFS_CCK, 0x100a);	
+
+	// Set SIFS for OFDM
+	rtw_write16(Adapter,REG_SIFS_OFDM, 0x100a);
+	
+
+	// TXOP
+	rtw_write32(Adapter, REG_EDCA_BE_PARAM, 0x005EA42B);
+	rtw_write32(Adapter, REG_EDCA_BK_PARAM, 0x0000A44F);
+	rtw_write32(Adapter, REG_EDCA_VI_PARAM, 0x005EA324);
+	rtw_write32(Adapter, REG_EDCA_VO_PARAM, 0x002FA226);
+#endif
+}
+
+
+static VOID
+_InitAMPDUAggregation(
+	IN  PADAPTER Adapter
+	)
+{
+	rtw_write32(Adapter, REG_AGGLEN_LMT, 0x99997631);
+	rtw_write8(Adapter, REG_AGGR_BREAK_TIME, 0x16);
+
+	// init AMPDU aggregation number, tuning for Tx's TP, suggested by Scott.
+	rtw_write16(Adapter, 0x4CA, 0x0708);	
+}
+
+static VOID
+_InitBeaconMaxError(
+	IN  PADAPTER	Adapter,
+	IN	BOOLEAN		InfraMode
+	)
+{
+	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));	
+	rtw_write8(Adapter, REG_BCN_MAX_ERR,  0xFF );
+}
+
+static VOID
+_InitRDGSetting(
+	IN	PADAPTER Adapter
+	)
+{
+	rtw_write8(Adapter,REG_RD_CTRL,0xFF);
+	rtw_write16(Adapter, REG_RD_NAV_NXT, 0x200);
+	rtw_write8(Adapter,REG_RD_RESP_PKT_TH,0x05);
+}
+
+
+
+static VOID
+_InitRetryFunction(
+	IN  PADAPTER Adapter
+	)
+{
+	u8	value8;
+	
+	value8 = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL);
+	value8 |= EN_AMPDU_RTY_NEW;
+	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
+
+	// Set ACK timeout
+	rtw_write8(Adapter, REG_ACKTO, 0x40);
+}
+
+
+static VOID
+_InitUsbAggregationSetting(
+	IN  PADAPTER Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+#if USB_TX_AGGREGATION_92C
+{
+	u32			value32;
+
+	if(pHalData->UsbTxAggMode){
+		value32 = rtw_read32(Adapter, REG_TDECTRL);
+		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
+		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
+		
+		rtw_write32(Adapter, REG_TDECTRL, value32);
+	}
+}
+#endif
+
+	// Rx aggregation setting
+#if USB_RX_AGGREGATION_92C
+{
+	u8		valueDMA;
+	u8		valueUSB;
+
+	valueDMA = rtw_read8(Adapter, REG_TRXDMA_CTRL);
+	valueUSB = rtw_read8(Adapter, REG_USB_SPECIAL_OPTION);
+
+	switch(pHalData->UsbRxAggMode)
+	{
+		case USB_RX_AGG_DMA:
+			valueDMA |= RXDMA_AGG_EN;
+			valueUSB &= ~USB_AGG_EN;
+			break;
+		case USB_RX_AGG_USB:
+			valueDMA &= ~RXDMA_AGG_EN;
+			valueUSB |= USB_AGG_EN;
+			break;
+		case USB_RX_AGG_MIX:
+			valueDMA |= RXDMA_AGG_EN;
+			valueUSB |= USB_AGG_EN;
+			break;
+		case USB_RX_AGG_DISABLE:
+		default:
+			valueDMA &= ~RXDMA_AGG_EN;
+			valueUSB &= ~USB_AGG_EN;
+			break;
+	}
+
+	rtw_write8(Adapter, REG_TRXDMA_CTRL, valueDMA);
+	rtw_write8(Adapter, REG_USB_SPECIAL_OPTION, valueUSB);
+
+	switch(pHalData->UsbRxAggMode)
+	{
+		case USB_RX_AGG_DMA:
+			rtw_write8(Adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
+			rtw_write8(Adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
+			break;
+		case USB_RX_AGG_USB:
+			rtw_write8(Adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
+			rtw_write8(Adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
+			break;
+		case USB_RX_AGG_MIX:
+			rtw_write8(Adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
+			rtw_write8(Adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
+			rtw_write8(Adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
+			rtw_write8(Adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
+			break;
+		case USB_RX_AGG_DISABLE:
+		default:
+			// TODO: 
+			break;
+	}
+
+	switch(PBP_128)
+	{
+		case PBP_128:
+			pHalData->HwRxPageSize = 128;
+			break;
+		case PBP_64:
+			pHalData->HwRxPageSize = 64;
+			break;
+		case PBP_256:
+			pHalData->HwRxPageSize = 256;
+			break;
+		case PBP_512:
+			pHalData->HwRxPageSize = 512;
+			break;
+		case PBP_1024:
+			pHalData->HwRxPageSize = 1024;
+			break;
+		default:
+			//RT_ASSERT(FALSE, ("RX_PAGE_SIZE_REG_VALUE definition is incorrect!\n"));
+			break;
+	}
+
+}
+#endif
+
+}
+
+
+static VOID
+_InitOperationMode(
+	IN	PADAPTER			Adapter
+	)
+{
+#if 0//gtest
+	PHAL_DATA_8192CUSB	pHalData = GetHalData8192CUsb(Adapter);
+	u1Byte				regBwOpMode = 0;
+	u4Byte				regRATR = 0, regRRSR = 0;
+
+
+	//1 This part need to modified according to the rate set we filtered!!
+	//
+	// Set RRSR, RATR, and REG_BWOPMODE registers
+	//
+	switch(Adapter->RegWirelessMode)
+	{
+		case WIRELESS_MODE_B:
+			regBwOpMode = BW_OPMODE_20MHZ;
+			regRATR = RATE_ALL_CCK;
+			regRRSR = RATE_ALL_CCK;
+			break;
+		case WIRELESS_MODE_A:
+			ASSERT(FALSE);
+#if 0
+			regBwOpMode = BW_OPMODE_5G |BW_OPMODE_20MHZ;
+			regRATR = RATE_ALL_OFDM_AG;
+			regRRSR = RATE_ALL_OFDM_AG;
+#endif
+			break;
+		case WIRELESS_MODE_G:
+			regBwOpMode = BW_OPMODE_20MHZ;
+			regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
+			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
+			break;
+		case WIRELESS_MODE_AUTO:
+			if (Adapter->bInHctTest)
+			{
+			    regBwOpMode = BW_OPMODE_20MHZ;
+			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
+			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
+			}
+			else
+			{
+			    regBwOpMode = BW_OPMODE_20MHZ;
+			    regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
+			    regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
+			}
+			break;
+		case WIRELESS_MODE_N_24G:
+			// It support CCK rate by default.
+			// CCK rate will be filtered out only when associated AP does not support it.
+			regBwOpMode = BW_OPMODE_20MHZ;
+				regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
+				regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
+			break;
+		case WIRELESS_MODE_N_5G:
+			ASSERT(FALSE);
+#if 0
+			regBwOpMode = BW_OPMODE_5G;
+			regRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
+			regRRSR = RATE_ALL_OFDM_AG;
+#endif
+			break;
+	}
+
+	// Ziv ????????
+	//PlatformEFIOWrite4Byte(Adapter, REG_INIRTS_RATE_SEL, regRRSR);
+	PlatformEFIOWrite1Byte(Adapter, REG_BWOPMODE, regBwOpMode);
+
+	// For Min Spacing configuration.
+	switch(pHalData->RF_Type)
+	{
+		case RF_1T2R:
+		case RF_1T1R:
+			RT_TRACE(COMP_INIT, DBG_LOUD, ("Initializeadapter: RF_Type%s\n", (pHalData->RF_Type==RF_1T1R? "(1T1R)":"(1T2R)")));
+			Adapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_1T<<3);						
+			break;
+		case RF_2T2R:
+		case RF_2T2R_GREEN:
+			RT_TRACE(COMP_INIT, DBG_LOUD, ("Initializeadapter:RF_Type(2T2R)\n"));
+			Adapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_2T<<3);			
+			break;
+	}
+	
+	PlatformEFIOWrite1Byte(Adapter, REG_AMPDU_MIN_SPACE, Adapter->MgntInfo.MinSpaceCfg);
+#endif
+}
+
+
+static VOID
+_InitSecuritySetting(
+	IN  PADAPTER Adapter
+	)
+{
+#if 0
+	//Security related.
+	//-----------------------------------------------------------------------------
+	// Set up security related. 070106, by rcnjko:
+	// 1. Clear all H/W keys.
+	// 2. Enable H/W encryption/decryption.
+	//-----------------------------------------------------------------------------
+	if(Adapter->ResetProgress == RESET_TYPE_NORESET && Adapter->bInSetPower == FALSE)
+	{
+		SecClearAllKeys(Adapter);	
+		CamResetAllEntry(Adapter);
+		SecInit(Adapter);    
+	}
+#else
+
+	u8 ucIndex;
+
+	// 1. Clear all H/W keys.
+	for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
+		CAM_mark_invalid(Adapter, ucIndex);
+	
+	for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
+		CAM_empty_entry(Adapter, ucIndex);
+
+	//
+	invalidate_cam_all(Adapter);
+
+
+#endif	
+}
+
+ static VOID
+_InitBeaconParameters(
+	IN  PADAPTER Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	// TODO: Remove these magic number
+	rtw_write16(Adapter, REG_TBTT_PROHIBIT,0x6404);// ms
+	rtw_write8(Adapter, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME);//ms
+	rtw_write8(Adapter, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME);
+
+	// Suggested by designer timchen. Change beacon AIFS to the largest number
+	// beacause test chip does not contension before sending beacon. by tynli. 2009.11.03
+	if(IS_NORMAL_CHIP( pHalData->VersionID)){
+		rtw_write16(Adapter, REG_BCNTCFG, 0x660F);
+	}
+	else{		
+		rtw_write16(Adapter, REG_BCNTCFG, 0x66FF);
+	}
+
+}
+
+static VOID
+_InitRFType(
+	IN	PADAPTER Adapter
+	)
+{
+	struct registry_priv	 *pregpriv = &Adapter->registrypriv;
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+
+#if	DISABLE_BB_RF
+	pHalData->rf_chip	= RF_PSEUDO_11N;
+	return;
+#endif
+
+	pHalData->rf_chip	= RF_6052;
+
+	if(pregpriv->rf_config != RF_819X_MAX_TYPE)
+	{
+		pHalData->rf_type = pregpriv->rf_config;
+		DBG_8192C("Set RF Chip ID to RF_6052 and RF type to %d.\n", pHalData->rf_type);
+		return;
+	}	
+
+	if(IS_92C_1T2R(pHalData->VersionID))
+	{		
+		pHalData->rf_type = RF_1T2R;
+		DBG_8192C("Set RF Chip ID to RF_6052 and RF type to 1T2R.\n");
+	}
+	else if(IS_92C_SERIAL(pHalData->VersionID))
+	{
+		pHalData->rf_type = RF_2T2R;	
+		DBG_8192C("Set RF Chip ID to RF_6052 and RF type to 2T2R.\n");
+		//return;
+	}
+	else
+	{
+		pHalData->rf_type = RF_1T1R;
+		DBG_8192C("Set RF Chip ID to RF_6052 and RF type to 1T1R.\n");
+	}
+
+
+	// TODO: Consider that EEPROM set 92CU to 1T1R later.
+	// Force to overwrite setting according to chip version. Ignore EEPROM setting.
+	//pHalData->RF_Type = is92CU ? RF_2T2R : RF_1T1R;
+	//RT_TRACE(COMP_INIT,DBG_TRACE,("Set RF Chip ID to RF_6052 and RF type to %d.\n", pHalData->RF_Type));
+
+
+	MSG_8192C("rf_chip=0x%x, rf_type=0x%x\n",  pHalData->rf_chip, pHalData->rf_type);
+
+}
+
+static VOID _InitAdhocWorkaroundParams(IN PADAPTER Adapter)
+{
+#if RTL8192CU_ADHOC_WORKAROUND_SETTING
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	pHalData->RegBcnCtrlVal 	= rtw_read8(Adapter, REG_BCN_CTRL);
+	pHalData->RegTxPause = rtw_read8(Adapter, REG_TXPAUSE); 
+	pHalData->RegFwHwTxQCtrl = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL+2);
+	pHalData->RegReg542 = rtw_read8(Adapter, REG_TBTT_PROHIBIT+2);
+#endif	
+}
+
+static VOID
+_BeaconFunctionEnable(
+	IN	PADAPTER		Adapter,
+	IN	BOOLEAN			Enable,
+	IN	BOOLEAN			Linked
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u8			value8 = 0;
+
+	//value8 = Enable ? (EN_BCN_FUNCTION | EN_TXBCN_RPT) : EN_BCN_FUNCTION;
+
+	if(_FALSE == Linked){		
+		if(IS_NORMAL_CHIP( pHalData->VersionID)){
+			value8 |= DIS_TSF_UDT0_NORMAL_CHIP;
+		}
+		else{
+			value8 |= DIS_TSF_UDT0_TEST_CHIP;
+		}
+	}
+
+	rtw_write8(Adapter, REG_BCN_CTRL, value8);
+}
+
+
+// Set CCK and OFDM Block "ON"
+static VOID _BBTurnOnBlock(
+	IN	PADAPTER		Adapter
+	)
+{
+#if (DISABLE_BB_RF)
+	return;
+#endif
+
+	PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bCCKEn, 0x1);
+	PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bOFDMEn, 0x1);
+}
+
+static VOID _RfPowerSave(
+	IN	PADAPTER		Adapter
+	)
+{
+#if 0
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo	= &(Adapter->MgntInfo);
+	u1Byte			eRFPath;
+
+#if (DISABLE_BB_RF)
+	return;
+#endif
+
+	if(pMgntInfo->RegRfOff == TRUE){ // User disable RF via registry.
+		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
+		MgntActSet_RF_State(Adapter, eRfOff, RF_CHANGE_BY_SW);
+		// Those action will be discard in MgntActSet_RF_State because off the same state
+		for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+			PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
+	}
+	else if(pMgntInfo->RfOffReason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
+		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
+		MgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);
+	}
+	else{
+		pHalData->eRFPowerState = eRfOn;
+		pMgntInfo->RfOffReason = 0; 
+		if(Adapter->bInSetPower || Adapter->bResetInProgress)
+			PlatformUsbEnableInPipes(Adapter);
+		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
+	}
+#endif
+}
+
+
+static VOID
+_InitAntenna_Selection(IN PADAPTER Adapter)
+{
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
+
+	if(pHalData->AntDivCfg==0)
+		return;
+	printk("==>  %s ....\n",__FUNCTION__);
+	
+	if((RF_1T1R == pHalData->rf_type))
+	{	
+		rtw_write32(Adapter, REG_LEDCFG0, rtw_read32(Adapter, REG_LEDCFG0)|BIT23);	
+		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
+		
+		if(PHY_QueryBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == Antenna_A)
+			pHalData->CurAntenna = Antenna_A;
+		else
+			pHalData->CurAntenna = Antenna_B;
+		printk("%s,Cur_ant:(%x)%s\n",__FUNCTION__,pHalData->CurAntenna,(pHalData->CurAntenna == Antenna_A)?"Antenna_A":"Antenna_B");
+			
+	}
+	
+#endif
+}
+
+
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+
+// 1 = original SS power ver 2 = Improved pwr version.
+// We will provide several power consumption type for user to use.
+#define	CU_SS_MODE			1
+
+void _ps_open_RF(_adapter *padapter)
+{
+	
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+
+	printk("==> %s \n",__FUNCTION__);
+#if (CU_SS_MODE == 1)
+	// 1. Enable MAC Clock
+	//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) | BIT(3));
+	//delay_us(WAIT_US_WRITE_POWERON);
+
+	// 2. Force PWM, Enable SPS18_LDO_Marco_Block
+	rtw_write8(padapter, REG_SPS0_CTRL, rtw_read8(padapter,REG_SPS0_CTRL) | (BIT(0)|BIT(3)));
+	//delay_us(WAIT_US_WRITE_POWERON);
+	
+	// 3. restore BB, AFE control register.
+	//RF
+	//PHY_SetBBReg(padapter,rFPGA0_XAB_RFParameter,bMaskDWord, pwrpriv->PS_BBRegBackup[PSBBREG_RF0]);
+	//PHY_SetBBReg(padapter,rOFDM0_TRxPathEnable, bMaskDWord,pwrpriv->PS_BBRegBackup[PSBBREG_RF1]);
+	//PHY_SetBBReg(padapter,rFPGA0_RFMOD, bMaskDWord,pwrpriv->PS_BBRegBackup[PSBBREG_RF2]);
+
+	if (pHalData->rf_type==  RF_2T2R)
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x380038, 1);							
+	else								
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x38, 1);							
+
+	PHY_SetBBReg(padapter, rOFDM0_TRxPathEnable, 0xf0, 1);
+	PHY_SetBBReg(padapter, rFPGA0_RFMOD, BIT1, 0);
+								
+
+	//AFE
+	//PHY_SetBBReg(padapter,0x0e70, bMaskDWord,pwrpriv->PS_BBRegBackup[PSBBREG_AFE0]);
+	PHY_SetBBReg(padapter, 0x0e70, bMaskDWord ,0x631B25A0 );
+	
+	// 4. issue 3-wire command that RF set to Rx idle mode.
+	// We can only prvide a usual value instead and then HW will modify the value by itself.
+	PHY_SetRFReg(padapter,RF90_PATH_A, 0,bMaskDWord, 0x32D95);
+	if ( pHalData->rf_type ==  RF_2T2R )
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0, bMaskDWord,0x32D95);
+
+#elif (CU_SS_MODE == 2)
+
+	//h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			//disable AFE PLL
+	rtw_write8(padapter, REG_AFE_PLL_CTRL, 0x81);
+
+	// i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		//gated AFE DIG_CLOCK
+	rtw_write16(padapter,  REG_AFE_XTAL_CTRL, 0x800F);
+	rtw_mdelay_os(1);			
+			
+	// 1. Enable MAC Clock. Can not be enabled now.
+	//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) | BIT(3));
+			
+	// 2. Force PWM, Enable SPS18_LDO_Marco_Block
+	rtw_write8(padapter,  REG_SPS0_CTRL,rtw_read8(padapter, REG_SPS0_CTRL) | (BIT0|BIT3));
+
+	// 3. restore BB, AFE control register.
+	//RF
+	if (pHalData->rf_type ==  RF_2T2R)
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x380038, 1);							
+	else								
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x38, 1);							
+
+	PHY_SetBBReg(padapter, rOFDM0_TRxPathEnable, 0xf0, 1);
+	PHY_SetBBReg(padapter, rFPGA0_RFMOD, BIT1, 0);
+
+	//AFE
+	PHY_SetBBReg(padapter, 0x0e70, bMaskDWord ,0x631B25A0 );
+
+	// 4. issue 3-wire command that RF set to Rx idle mode. This is used to re-write the RX idle mode.
+	// We can only prvide a usual value instead and then HW will modify the value by itself.
+	PHY_SetRFReg(padapter,RF90_PATH_A, 0, bRFRegOffsetMask,0x32D95);
+	if (pHalData->rf_type ==  RF_2T2R)
+	{
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0, bRFRegOffsetMask,0x32D95);
+	}
+
+	// 5. gated MAC Clock
+	//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) & ~(BIT(3)));
+	//PlatformEFIOWrite1Byte(Adapter, REG_SYS_CLKR+1, PlatformEFIORead1Byte(Adapter, REG_SYS_CLKR+1)|(BIT3));
+
+	{
+		u8 eRFPath = RF90_PATH_A,value8 = 0, u1bTmp, bytetmp, retry = 0;
+				
+		//PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x0, bMaskByte0, 0x0);
+		// 2010/08/12 MH Add for B path under SS test. 
+		//if (pHalData->rf_type ==  RF_2T2R)
+			//PHY_SetRFReg(Adapter, RF90_PATH_B, 0x0, bMaskByte0, 0x0);
+
+		bytetmp = rtw_read8(padapter, REG_APSD_CTRL);
+		rtw_write8(padapter, REG_APSD_CTRL, bytetmp & ~BIT6);
+			
+		rtw_mdelay_os(10);
+
+		// Set BB reset at first
+		rtw_write8(padapter, REG_SYS_FUNC_EN, 0x17 );//0x16		
+
+		// Enable TX
+		rtw_write8(padapter,  REG_TXPAUSE, 0x0);
+	}
+	//Adapter->HalFunc.InitializeAdapterHandler(Adapter, Adapter->MgntInfo.dot11CurrentChannelNumber);
+	//CardSelectiveSuspendLeave(Adapter);
+#endif
+
+}
+
+
+
+void _ps_close_RF(_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
+	printk("==> %s \n",__FUNCTION__);
+
+#if (CU_SS_MODE == 1)	
+	// 1. Set BB/RF to shutdown.
+	//	(1) Reg878[5:3]= 0 	// RF rx_code for preamble power saving
+	//	(2) Reg878[21:19]= 0	//Turn off RF-B
+	//	(3) RegC04[7:4]= 0 	// turn off all paths for packet detection
+	//	(4) Reg800[1] = 1 		// enable preamble power saving
+	pwrpriv->PS_BBRegBackup[PSBBREG_RF0] = PHY_QueryBBReg(padapter,rFPGA0_XAB_RFParameter, bMaskDWord);
+	pwrpriv->PS_BBRegBackup[PSBBREG_RF1] = PHY_QueryBBReg(padapter,rOFDM0_TRxPathEnable, bMaskDWord);
+	pwrpriv->PS_BBRegBackup[PSBBREG_RF2] = PHY_QueryBBReg(padapter,rFPGA0_RFMOD, bMaskDWord);
+
+	if (pHalData->rf_type ==  RF_2T2R)
+	{
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x380038, 0);							
+	}
+	else if (pHalData->rf_type ==  RF_1T1R)
+	{
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x38, 0);							
+	}
+	PHY_SetBBReg(padapter, rOFDM0_TRxPathEnable, 0xf0, 0);						
+	PHY_SetBBReg(padapter, rFPGA0_RFMOD, BIT1,1);
+
+	// 2 .AFE control register to power down. bit[30:22]
+	pwrpriv->PS_BBRegBackup[PSBBREG_AFE0] = PHY_QueryBBReg(padapter,0x0e70, bMaskDWord);	
+	PHY_SetBBReg(padapter,0x0e70,bMaskDWord,0x001B25A0);
+
+	// 3. issue 3-wire command that RF set to power down.
+	PHY_SetRFReg(padapter,RF90_PATH_A, 0, bMaskDWord, 0);
+	if (pHalData->rf_type ==  RF_2T2R)
+	{
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0, bRFRegOffsetMask,0);
+	}
+	
+	// 4. Force PFM , disable SPS18_LDO_Marco_Block
+	rtw_write8(padapter,REG_SPS0_CTRL,rtw_read8(padapter,REG_SPS0_CTRL) & ~(BIT(0)|BIT(3)));
+	
+
+	// 5. gated MAC Clock
+	//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) & ~(BIT(3)));
+	//delay_us(WAIT_US_WRITE_POWERON);
+
+	// 6. Because Alfred said that USB SS mode will cause the power domain to being shut down. All the
+	// 8051 function will be turned off. So we need to prevent the situation. Designer provide three ways 
+	// for us to test. But only one WOL can work now.
+	// Solution A: Enable WOL
+	rtw_write8(padapter, 0x690, rtw_read8(padapter, 0x690)|BIT1);	
+	
+#elif (CU_SS_MODE == 2)
+	{
+		u8 eRFPath = RF90_PATH_A,value8 = 0, u1bTmp;
+		rtw_write8(padapter, REG_TXPAUSE, 0xFF);
+		PHY_SetRFReg(padapter, (RF90_RADIO_PATH_E)eRFPath, 0x0, bMaskByte0, 0x0);
+		// 2010/08/12 MH Add for B path under SS test. 
+		//if (pHalData->rf_type ==  RF_2T2R)
+				//PHY_SetRFReg(Adapter, RF90_PATH_B, 0x0, bMaskByte0, 0x0);
+
+		value8 |= APSDOFF;
+		rtw_write8(padapter,REG_APSD_CTRL, value8);//0x40
+
+		// After switch APSD, we need to delay for stability
+		rtw_mdelay_os(10);
+
+		// Set BB reset at first
+		value8 = 0 ; 
+		value8 |=( FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
+		rtw_write8(padapter, REG_SYS_FUNC_EN,value8 );//0x16			
+	}
+
+	// Disable RF and BB only for SelectSuspend.
+
+	// 1. Set BB/RF to shutdown.
+	//	(1) Reg878[5:3]= 0 	// RF rx_code for preamble power saving
+	//	(2)Reg878[21:19]= 0	//Turn off RF-B
+	//	(3) RegC04[7:4]= 0 	// turn off all paths for packet detection
+	//	(4) Reg800[1] = 1 		// enable preamble power saving
+
+	pwrpriv->PS_BBRegBackup[PSBBREG_RF0] = PHY_QueryBBReg(padapter, rFPGA0_XAB_RFParameter, bMaskDWord);
+	pwrpriv->PS_BBRegBackup[PSBBREG_RF1] = PHY_QueryBBReg(padapter, rOFDM0_TRxPathEnable, bMaskDWord);
+	pwrpriv->PS_BBRegBackup[PSBBREG_RF2] = PHY_QueryBBReg(padapter, rFPGA0_RFMOD, bMaskDWord);
+
+	if (pHalData->rf_type ==  RF_2T2R)
+	{
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x380038, 0);							
+	}
+	else if (pHalData->rf_type ==  RF_1T1R)
+	{
+		PHY_SetBBReg(padapter, rFPGA0_XAB_RFParameter, 0x38, 0);							
+	}
+	
+	PHY_SetBBReg(padapter, rOFDM0_TRxPathEnable, 0xf0, 0);						
+	PHY_SetBBReg(padapter, rFPGA0_RFMOD, BIT1,1);
+				
+	// 2 .AFE control register to power down. bit[30:22]
+	pwrpriv->PS_BBRegBackup[PSBBREG_AFE0] = PHY_QueryBBReg(padapter, 0xe70, bMaskDWord);	
+	PHY_SetBBReg(padapter, 0x0e70, bMaskDWord ,0x001B25A0);
+				
+	// 3. issue 3-wire command that RF set to power down.
+	PHY_SetRFReg(padapter,RF90_PATH_A, 0, bRFRegOffsetMask,0);
+	if (pHalData->rf_type ==  RF_2T2R)
+	{
+		PHY_SetRFReg(padapter,RF90_PATH_B, 0, bRFRegOffsetMask,0);
+	}
+
+	// 4. Force PFM , disable SPS18_LDO_Marco_Block
+	rtw_write8(padapter, REG_SPS0_CTRL, rtw_read8(padapter,REG_SPS0_CTRL) & ~(BIT0|BIT3));
+					
+	//h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			//disable AFE PLL
+	rtw_write8(padapter,  REG_AFE_PLL_CTRL, 0x80);
+	rtw_mdelay_os(1);
+
+	// i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		//gated AFE DIG_CLOCK
+	rtw_write16(padapter, REG_AFE_XTAL_CTRL, 0xA80F);
+
+
+	// 5. gated MAC Clock
+	//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) & ~(BIT(3)));
+	//PlatformEFIOWrite1Byte(Adapter, REG_SYS_CLKR+1, PlatformEFIORead1Byte(Adapter, REG_SYS_CLKR+1)& ~(BIT3))
+
+	// 6. Because Alfred said that USB SS mode will cause the power domain to being shut down. All the
+	// 8051 function will be turned off. So we need to prevent the situation. Designer provide three ways 
+	// for us to test. But only one WOL can work now.
+	// Solution A: Enable WOL
+	rtw_write8(padapter, 0x690, rtw_read8(padapter, 0x690)|BIT1);
+	
+#endif
+}
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+//===========================================
+// Bluetooth related
+//===========================================
+
+VOID BT_HW_INIT(
+	IN	PADAPTER			Adapter
+	)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	struct btcoexist_priv	 *pbtpriv = &(Adapter->halpriv.bt_coexist);
+
+	u8 u1Tmp;
+
+	if(pHalData->bt_coexist.BT_Coexist && 
+		((pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC4) ||
+		pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC8))
+	{
+#if 1//cosa
+		if(0)//pHalData->bt_coexist.BT_Ant_isolation)
+		{
+			rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);
+			//RTPRINT(FBT, BT_TRACE, ("BT write 0x%x = 0x%x\n", REG_GPIO_MUXCFG, 0xa0));
+		}
+
+		u1Tmp = rtw_read8(Adapter, 0x4fd) & BIT0;
+		u1Tmp = u1Tmp | 
+				((pHalData->bt_coexist.BT_Ant_isolation==1)?0:BIT1) | 
+				((pHalData->bt_coexist.BT_Service==BT_SCO)?0:BIT2);
+		rtw_write8(Adapter, 0x4fd, u1Tmp);
+		//RTPRINT(FBT, BT_TRACE, ("BT write 0x%x = 0x%x for non-isolation\n", 0x4fd, u1Tmp));
+		
+		
+		rtw_write32(Adapter, REG_BT_COEX_TABLE+4, 0xaaaa9aaa);
+		//RTPRINT(FBT, BT_TRACE, ("BT write 0x%x = 0x%x\n", REG_BT_COEX_TABLE+4, 0xaaaa9aaa));
+		
+		rtw_write32(Adapter, REG_BT_COEX_TABLE+8, 0xffbd0040);
+		//RTPRINT(FBT, BT_TRACE, ("BT write 0x%x = 0x%x\n", REG_BT_COEX_TABLE+8, 0xffbd0040));
+
+		rtw_write32(Adapter, REG_BT_COEX_TABLE+0xc, 0x40000010);
+		//RTPRINT(FBT, BT_TRACE, ("BT write 0x%x = 0x%x\n", REG_BT_COEX_TABLE+0xc, 0x40000010));
+
+		if(pHalData->rf_type == RF_1T1R)
+		{
+		//Config to 1T1R
+		u1Tmp = rtw_read8(Adapter, rOFDM0_TRxPathEnable);
+		u1Tmp &= ~(BIT1);
+		rtw_write8(Adapter, rOFDM0_TRxPathEnable, u1Tmp);
+		//RTPRINT(FBT, BT_TRACE, ("BT write 0xC04 = 0x%x\n", u1Tmp));
+			
+		u1Tmp = rtw_read8(Adapter, rOFDM1_TRxPathEnable);
+		u1Tmp &= ~(BIT1);
+		rtw_write8(Adapter, rOFDM1_TRxPathEnable, u1Tmp);
+		//RTPRINT(FBT, BT_TRACE, ("BT write 0xD04 = 0x%x\n", u1Tmp));
+		}
+#else
+		PlatformEFIOWrite1Byte(Adapter, SYSF_CFG, 0x1);	//Enable Bluetooth
+		if(pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC4)
+		{
+			u1Byte u1Tmp;
+			u4Byte u4Tmp;
+			// set GPIO [7:6] = 10b to BT
+			u1Tmp = PlatformEFIORead1Byte(Adapter, GPIO_OUT);
+			u1Tmp &= ~BIT7;
+			u1Tmp |= BIT6;
+			PlatformEFIOWrite1Byte(Adapter, GPIO_OUT, u1Tmp);
+			RTPRINT(FBT, BT_TRACE, ("BT write 0x%x = 0x%x\n", GPIO_OUT, u1Tmp));
+
+			//Config to 1T1R
+			u1Tmp = PlatformEFIORead1Byte(Adapter, 0xC04);
+			u1Tmp &= ~(BIT1);
+			PlatformEFIOWrite1Byte(Adapter, 0xC04, u1Tmp);
+			RTPRINT(FBT, BT_TRACE, ("BT write 0xC04 = 0x%x\n", u1Tmp));
+			
+			u1Tmp = PlatformEFIORead1Byte(Adapter, 0xD04);
+			u1Tmp &= ~(BIT1);
+			PlatformEFIOWrite1Byte(Adapter, 0xD04, u1Tmp);
+			RTPRINT(FBT, BT_TRACE, ("BT write 0xD04 = 0x%x\n", u1Tmp));
+
+			// set Ant-B Rx to standby mode
+			PHY_SetBBReg(Adapter, rFPGA0_XB_HSSIParameter2, 0x700000, 1);	//[22:20] agc_rx
+			RTPRINT(FBT, BT_TRACE, ("BT write 0x%x[22:20] = 1 (Ant-B standby mode)\n", rFPGA0_XB_HSSIParameter2));
+
+			// gpio output enable/ da6 output disable, set ck_test clk to xtal, enable test clk
+			// set ck_monh clk to DA6O=CK40M, [13:8] = 110101
+			u1Tmp = PlatformEFIORead1Byte(Adapter, rFPGA0_AnalogParameter2);
+			u1Tmp |= (BIT1|BIT0);
+			PlatformEFIOWrite1Byte(Adapter, rFPGA0_AnalogParameter2, u1Tmp);
+			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, 0x3f00, 0x35);	//[13:8]
+		}
+#endif
+	}
+}
+#endif
+
+u32 rtl8192cu_hal_init(_adapter *padapter)
+{
+	u8	val8 = 0;
+	u32	boundary, status = _SUCCESS;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	u8	isNormal = IS_NORMAL_CHIP(pHalData->VersionID);
+	u8	is92C = IS_92C_SERIAL(pHalData->VersionID);
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	 *pbtpriv = &(padapter->halpriv.bt_coexist);
+#endif
+_func_enter_;
+
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	if(padapter->pwrctrlpriv.bkeepfwalive)
+	{
+		_ps_open_RF(padapter);
+		
+		if(pHalData->IQKInitialized ){
+			PHY_IQCalibrate(padapter,_TRUE);
+		}
+		else{
+			PHY_IQCalibrate(padapter,_FALSE);
+			pHalData->IQKInitialized = _TRUE;
+		}
+		dm_CheckTXPowerTracking(padapter);
+		PHY_LCCalibrate(padapter);	
+		return status;
+	}
+#endif
+	status = _InitPowerOn(padapter);
+	if(status == _FAIL){
+		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
+		goto exit;
+	}
+
+	if(!pregistrypriv->wifi_spec){
+		boundary = TX_PAGE_BOUNDARY;
+	}
+	else{// for WMM
+		boundary = (IS_NORMAL_CHIP(pHalData->VersionID))	?WMM_NORMAL_TX_PAGE_BOUNDARY
+													:WMM_TEST_TX_PAGE_BOUNDARY;
+	}															
+
+	status =  InitLLTTable(padapter, boundary);
+	if(status == _FAIL){
+		//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to init power on!\n"));
+		return status;
+	}		
+	
+	_InitQueueReservedPage(padapter);
+	_InitTxBufferBoundary(padapter);		
+	_InitQueuePriority(padapter);
+	_InitPageBoundary(padapter);	
+	_InitTransferPageSize(padapter);	
+	_InitDriverInfoSize(padapter, 4);// Get Rx PHY status in order to report RSSI and others.
+	_InitInterrupt(padapter);	
+	_InitID(padapter);//set mac_address
+	_InitNetworkType(padapter);//set msr	
+	_InitWMACSetting(padapter);
+	_InitAdaptiveCtrl(padapter);
+	_InitEDCA(padapter);
+	_InitRateFallback(padapter);
+	_InitRetryFunction(padapter);
+	_InitUsbAggregationSetting(padapter);
+	_InitOperationMode(padapter);//todo
+	_InitBeaconParameters(padapter);
+	_InitAMPDUAggregation(padapter);
+	_InitBeaconMaxError(padapter, _TRUE);
+	_BeaconFunctionEnable(padapter, _FALSE, _FALSE);
+	
+#if ENABLE_USB_DROP_INCORRECT_OUT
+	_InitHardwareDropIncorrectBulkOut(padapter);
+#endif
+
+	if(pHalData->bRDGEnable){
+		_InitRDGSetting(padapter);
+	}
+#if ((0 == MP_DRIVER) && RTL8192CU_FW_DOWNLOAD_ENABLE)
+	status = FirmwareDownload92C(padapter);
+	if(status == _FAIL)
+	{
+
+		padapter->bFWReady = _FALSE;
+
+		pHalData->fw_ractrl = _FALSE;
+
+		DBG_8192C("fw download fail!\n");
+
+		goto exit;
+	}	
+	else
+	{
+
+		padapter->bFWReady = _TRUE;
+
+		pHalData->fw_ractrl = _TRUE;
+
+		DBG_8192C("fw download ok!\n");	
+	}
+#endif
+	//if(pMgntInfo->RegRfOff == TRUE){
+	//	pHalData->eRFPowerState = eRfOff;
+	//}
+
+	// Set RF type for BB/RF configuration	
+	_InitRFType(padapter);//->_ReadRFType()
+	// Save target channel
+	// <Roger_Notes> Current Channel will be updated again later.
+	pHalData->CurrentChannel = 6;//default set to 6
+
+	status = PHY_MACConfig8192C(padapter);
+	rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);
+	
+	
+	if(status == _FAIL)
+	{
+		goto exit;
+	}
+	//d. Initialize BB related configurations.
+	//
+	status = PHY_BBConfig8192C(padapter);
+	if(status == _FAIL)
+	{
+		goto exit;
+	}
+	// 92CU use 3-wire to r/w RF
+	//pHalData->Rf_Mode = RF_OP_By_SW_3wire;
+#ifdef CONFIG_AUTOSUSPEND	
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	// The FW command register update must after MAC and FW init ready.
+	if((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
+	{
+		set_FWSelectSuspend_cmd(padapter,_TRUE ,500);//note fw to support hw power down ping detect
+	}
+#endif
+#endif
+
+	status = PHY_RFConfig8192C(padapter);	
+	if(status == _FAIL)
+	{
+		goto exit;
+	}
+	if(IS_VENDOR_UMC_A_CUT(pHalData->VersionID) && !IS_92C_SERIAL(pHalData->VersionID))
+	{
+		PHY_SetRFReg(padapter, RF90_PATH_A, RF_RX_G1, bMaskDWord, 0x30255);
+		PHY_SetRFReg(padapter, RF90_PATH_A, RF_RX_G2, bMaskDWord, 0x50a00);		
+	}
+	
+	//
+	// Joseph Note: Keep RfRegChnlVal for later use.
+	//
+	pHalData->RfRegChnlVal[0] = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)0, RF_CHNLBW, bRFRegOffsetMask);
+	pHalData->RfRegChnlVal[1] = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)1, RF_CHNLBW, bRFRegOffsetMask);
+
+	_BBTurnOnBlock(padapter);
+	//NicIFSetMacAddress(padapter, padapter->PermanentAddress);
+	_InitSecuritySetting(padapter);
+	_RfPowerSave(padapter);
+
+	// HW SEQ CTRL
+	//set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
+	rtw_write8(padapter,REG_HWSEQ_CTRL, 0xFF); 
+
+
+	if(pregistrypriv->wifi_spec)
+		rtw_write16(padapter,REG_FAST_EDCA_CTRL ,0);
+
+
+#if (MP_DRIVER == 1)
+	//MPT_InitializeAdapter(padapter, Channel);
+#endif
+	
+	if(pHalData->IQKInitialized ){
+		PHY_IQCalibrate(padapter,_TRUE);
+	}
+	else{
+		PHY_IQCalibrate(padapter,_FALSE);
+		pHalData->IQKInitialized = _TRUE;
+	}
+	dm_CheckTXPowerTracking(padapter);
+	PHY_LCCalibrate(padapter);
+
+
+#if RTL8192CU_ADHOC_WORKAROUND_SETTING
+	_InitAdhocWorkaroundParams(padapter);
+#endif
+
+#ifdef CONFIG_USB_HCI //fixed USB interface interference issue
+	rtw_write8(padapter, 0xfe40, 0xe0);
+	rtw_write8(padapter, 0xfe41, 0x8d);
+	rtw_write8(padapter, 0xfe42, 0x80);
+	rtw_write32(padapter,0x20c,0xfd0320);
+#if 1
+	//2011/01/07 ,suggest by Johnny,for solved the problem that too many protocol error on USB bus
+	if(!IS_VENDOR_UMC_A_CUT(pHalData->VersionID) )//&& !IS_92C_SERIAL(pHalData->VersionID))// TSMC , 8188
+	{		
+	    	// 0xE6=0x94
+	    	rtw_write8(padapter, 0xFE40, 0xE6);
+		rtw_write8(padapter, 0xFE41, 0x94);
+		rtw_write8(padapter, 0xFE42, 0x80); 
+
+		// 0xE0=0x19
+		rtw_write8(padapter, 0xFE40, 0xE0);
+		rtw_write8(padapter, 0xFE41, 0x19);
+		rtw_write8(padapter, 0xFE42, 0x80);
+
+		// 0xE5=0x91
+		rtw_write8(padapter, 0xFE40, 0xE5);
+		rtw_write8(padapter, 0xFE41, 0x91);
+		rtw_write8(padapter, 0xFE42, 0x80); 
+
+		// 0xE2=0x81
+		rtw_write8(padapter, 0xFE40, 0xE2);
+		rtw_write8(padapter, 0xFE41, 0x81);
+		rtw_write8(padapter, 0xFE42, 0x80);    
+	
+	}
+#endif
+
+#endif
+
+	//misc
+	{
+		int i;		
+		u8 mac_addr[6];
+		for(i=0; i<6; i++)
+		{			
+			mac_addr[i] = rtw_read8(padapter, REG_MACID+i);		
+		}
+		
+		DBG_8192C("MAC Address from REG = %x-%x-%x-%x-%x-%x\n", 
+			mac_addr[0],	mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
+	}
+
+	_InitPABias(padapter);
+
+#ifdef CONFIG_BT_COEXIST
+	BT_HW_INIT(padapter);		
+#endif
+
+	_InitAntenna_Selection(padapter);
+
+	rtl8192c_InitHalDm(padapter);
+
+	rtw_write8(padapter, 0x15, 0xe9);//suggest by Johnny for lower temperature
+	//_dbg_dump_macreg(padapter);
+	pHalData->bDumpRxPkt = _FAIL;
+
+	#ifdef RTL8192C_RECONFIG_TO_1T1R
+	if(IS_92C_SERIAL(pHalData->VersionID))
+	{
+		PHY_Reconfig_To_1T1R(padapter);
+		rtw_write8(padapter, 0x40, 0x04);//suggest by SzuyiTasi for turn on TR_Switch of PathA
+	}
+	#endif
+
+exit:
+
+_func_exit_;
+
+	return status;
+}
+
+
+static VOID 
+_DisableGPIO(
+	IN	PADAPTER	Adapter
+	)
+{
+/***************************************
+j. GPIO_PIN_CTRL 0x44[31:0]=0x000		// 
+k. Value = GPIO_PIN_CTRL[7:0]
+l.  GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8); //write external PIN level
+m. GPIO_MUXCFG 0x42 [15:0] = 0x0780
+n. LEDCFG 0x4C[15:0] = 0x8080
+***************************************/
+	u8	value8;
+	u16	value16;
+	u32	value32;
+
+	//1. Disable GPIO[7:0]
+	rtw_write16(Adapter, REG_GPIO_PIN_CTRL+2, 0x0000);
+    	value32 = rtw_read32(Adapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;  
+	value8 = (u8) (value32&0x000000FF);
+	value32 |= ((value8<<8) | 0x00FF0000);
+	rtw_write32(Adapter, REG_GPIO_PIN_CTRL, value32);
+	      
+	//2. Disable GPIO[10:8]          
+
+	rtw_write8(Adapter, REG_GPIO_MUXCFG+3, 0x00);
+  	value16 = rtw_read16(Adapter, REG_GPIO_MUXCFG+2) & 0xFF0F;  
+
+	value8 = (u8) (value16&0x000F);
+	value16 |= ((value8<<4) | 0x0780);
+	rtw_write16(Adapter, REG_GPIO_MUXCFG+2, value16);
+
+	//3. Disable LED0 & 1
+	rtw_write16(Adapter, REG_LEDCFG0, 0x8080);
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n"));
+ 
+} //end of _DisableGPIO()
+
+static VOID
+_ResetFWDownloadRegister(
+	IN PADAPTER			Adapter
+	)
+{
+	u32	value32;
+
+	value32 = rtw_read32(Adapter, REG_MCUFWDL);
+	value32 &= ~(MCUFWDL_EN | MCUFWDL_RDY);
+	rtw_write32(Adapter, REG_MCUFWDL, value32);
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset FW download register.\n"));
+}
+
+
+static int
+_DisableRF_AFE(
+	IN PADAPTER			Adapter
+	)
+{
+	int		rtStatus = _SUCCESS;
+	u32			pollingCount = 0;
+	u8			value8;
+	
+	//disable RF/ AFE AD/DA
+	value8 = APSDOFF;
+	rtw_write8(Adapter, REG_APSD_CTRL, value8);
+
+
+#if (RTL8192CU_ASIC_VERIFICATION)
+
+	do
+	{
+		if(rtw_read8(Adapter, REG_APSD_CTRL) & APSDOFF_STATUS){
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA Done!\n"));
+			break;
+		}
+
+		if(pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling APSDOFF_STATUS done!\n"));
+			return _FAIL;
+		}
+				
+	}while(_TRUE);
+	
+#endif
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE,AD, DA.\n"));
+	return rtStatus;
+
+}
+
+static VOID
+_ResetBB(
+	IN PADAPTER			Adapter
+	)
+{
+	u16	value16;
+
+	//reset BB
+	value16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
+	value16 &= ~(FEN_BBRSTB | FEN_BB_GLB_RSTn);
+	rtw_write16(Adapter, REG_SYS_FUNC_EN, value16);
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset BB.\n"));
+}
+
+static VOID
+_ResetMCU(
+	IN PADAPTER			Adapter
+	)
+{
+	u16	value16;
+	
+	// reset MCU
+	value16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
+	value16 &= ~FEN_CPUEN;
+	rtw_write16(Adapter, REG_SYS_FUNC_EN, value16);
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset MCU.\n"));
+}
+
+static VOID
+_DisableMAC_AFE_PLL(
+	IN PADAPTER			Adapter
+	)
+{
+	u32	value32;
+	
+	//disable MAC/ AFE PLL
+	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
+	value32 |= APDM_MAC;
+	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	
+	value32 |= APFM_OFF;
+	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable MAC, AFE PLL.\n"));
+}
+
+static VOID
+_AutoPowerDownToHostOff(
+	IN	PADAPTER		Adapter
+	)
+{
+	u32			value32;
+	rtw_write8(Adapter, REG_SPS0_CTRL, 0x22);
+
+	value32 = rtw_read32(Adapter, REG_APS_FSMCO);	
+	
+	value32 |= APDM_HOST;//card disable
+	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Auto Power Down to Host-off state.\n"));
+
+	// set USB suspend
+	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
+	value32 &= ~AFSM_PCIE;
+	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+
+}
+
+static VOID
+_SetUsbSuspend(
+	IN PADAPTER			Adapter
+	)
+{
+	u32			value32;
+
+	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
+	
+	// set USB suspend
+	value32 |= AFSM_HSUS;
+	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+
+	//RT_ASSERT(0 == (rtw_read32(Adapter, REG_APS_FSMCO) & BIT(12)),(""));
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n"));
+	
+}
+
+static VOID
+_DisableRFAFEAndResetBB(
+	IN PADAPTER			Adapter
+	)
+{
+/**************************************
+a.	TXPAUSE 0x522[7:0] = 0xFF             //Pause MAC TX queue
+b.	RF path 0 offset 0x00 = 0x00            // disable RF
+c. 	APSD_CTRL 0x600[7:0] = 0x40
+d.	SYS_FUNC_EN 0x02[7:0] = 0x16		//reset BB state machine
+e.	SYS_FUNC_EN 0x02[7:0] = 0x14		//reset BB state machine
+***************************************/
+	u8 eRFPath = 0,value8 = 0;
+	rtw_write8(Adapter, REG_TXPAUSE, 0xFF);
+	PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x0, bMaskByte0, 0x0);
+
+	value8 |= APSDOFF;
+	rtw_write8(Adapter, REG_APSD_CTRL, value8);//0x40
+	
+	value8 = 0 ; 
+	value8 |=( FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
+	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8 );//0x16		
+	
+	value8 &=( ~FEN_BB_GLB_RSTn );
+	rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14		
+	
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> RF off and reset BB.\n"));
+}
+
+static VOID
+_ResetDigitalProcedure1(
+	IN 	PADAPTER			Adapter,
+	IN	BOOLEAN				bWithoutHWSM	
+	)
+{
+
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+
+	if(pHalData->FirmwareVersion <=  0x20){
+		#if 0
+		/*****************************
+		f.	SYS_FUNC_EN 0x03[7:0]=0x54		// reset MAC register, DCORE
+		g.	MCUFWDL 0x80[7:0]=0				// reset MCU ready status
+		******************************/
+		u4Byte	value32 = 0;
+		PlatformIOWrite1Byte(Adapter, REG_SYS_FUNC_EN+1, 0x54);
+		PlatformIOWrite1Byte(Adapter, REG_MCUFWDL, 0);	
+		#else
+		/*****************************
+		f.	MCUFWDL 0x80[7:0]=0				// reset MCU ready status
+		g.	SYS_FUNC_EN 0x02[10]= 0			// reset MCU register, (8051 reset)
+		h.	SYS_FUNC_EN 0x02[15-12]= 5		// reset MAC register, DCORE
+		i.     SYS_FUNC_EN 0x02[10]= 1			// enable MCU register, (8051 enable)
+		******************************/
+			u16 valu16 = 0;
+			rtw_write8(Adapter, REG_MCUFWDL, 0);
+
+			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);	
+			rtw_write16(Adapter, REG_SYS_FUNC_EN, (valu16 & (~FEN_CPUEN)));//reset MCU ,8051
+
+			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN)&0x0FFF;	
+			rtw_write16(Adapter, REG_SYS_FUNC_EN, (valu16 |(FEN_HWPDN|FEN_ELDR)));//reset MAC
+			
+			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);	
+			rtw_write16(Adapter, REG_SYS_FUNC_EN, (valu16 | FEN_CPUEN));//enable MCU ,8051	
+
+		
+		#endif
+	}
+	else{
+		u8 retry_cnts = 0;	
+		
+		if(rtw_read8(Adapter, REG_MCUFWDL) & BIT1)
+		{ //IF fw in RAM code, do reset 
+
+			rtw_write8(Adapter, REG_MCUFWDL, 0);//reset MCU ready status
+			if(Adapter->bFWReady){
+
+				// 2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other
+				// HRCV INT to influence 8051 reset.
+				rtw_write8(Adapter, REG_FWIMR, 0x20);
+
+				rtw_write8(Adapter, REG_HMETFR+3, 0x20);//8051 reset by self
+				while( (retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(Adapter, REG_SYS_FUNC_EN)))
+				{					
+					rtw_mdelay_os(50);//PlatformStallExecution(50);//us
+				}
+				if(retry_cnts >= 100){				
+					printk("#####=> 8051 reset failed!.........................\n");
+					// 2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly.
+					rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x50);	
+					rtw_mdelay_os(10);					
+				}
+				
+				//RT_ASSERT((retry_cnts < 100), );			
+				//RT_TRACE(COMP_INIT, DBG_LOUD, ("=====> 8051 reset success (%d) .\n",retry_cnts));
+			}
+		}
+	
+		rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x54);	//Reset MAC and Enable 8051
+	//	rtw_write8(Adapter, REG_MCUFWDL, 0);//reset MCU ready status
+
+	}			
+
+	if(bWithoutHWSM){
+	/*****************************
+		Without HW auto state machine
+	g.	SYS_CLKR 0x08[15:0] = 0x30A3			//disable MAC clock
+	h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			//disable AFE PLL
+	i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		//gated AFE DIG_CLOCK
+	j.	SYS_ISO_CTRL 0x00[7:0] = 0xF9			// isolated digital to PON
+	******************************/	
+	//	rtw_write16(Adapter, REG_SYS_CLKR, 0x30A3);
+		rtw_write16(Adapter, REG_SYS_CLKR, 0x70A3);//modify to 0x70A3 by Scott.
+		rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x80);		
+		rtw_write16(Adapter, REG_AFE_XTAL_CTRL, 0x880F);
+		rtw_write8(Adapter, REG_SYS_ISO_CTRL, 0xF9);		
+	}
+	else
+	{		
+		// Disable all RF/BB power 
+		//rtw_write8(Adapter, REG_RF_CTRL, 0x00);
+	}
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n"));
+
+}
+
+static VOID
+_ResetDigitalProcedure2(
+	IN 	PADAPTER			Adapter
+)
+{
+/*****************************
+k.	SYS_FUNC_EN 0x03[7:0] = 0x44			// disable ELDR runction
+l.	SYS_CLKR 0x08[15:0] = 0x3083			// disable ELDR clock
+m.	SYS_ISO_CTRL 0x01[7:0] = 0x83			// isolated ELDR to PON
+******************************/
+	//rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x44);//V11 2010-08-13.
+
+
+	rtw_write16(Adapter, REG_SYS_CLKR, 0x70a3); //modify to 0x70a3 by Scott.
+ 	rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x82); //modify to 0x82 by Scott.
+}
+
+static VOID
+_DisableAnalog(
+	IN PADAPTER			Adapter,
+	IN BOOLEAN			bWithoutHWSM	
+	)
+{	
+    	u16 value16 = 0;	
+	u8 value8=0;	
+	if(bWithoutHWSM){
+	/*****************************
+	n.	LDOA15_CTRL 0x20[7:0] = 0x04		// disable A15 power
+	o.	LDOV12D_CTRL 0x21[7:0] = 0x54		// disable digital core power
+	r.	When driver call disable, the ASIC will turn off remaining clock automatically 
+	******************************/
+	
+		rtw_write8(Adapter, REG_LDOA15_CTRL, 0x04);
+		//rtw_write8(Adapter, REG_LDOV12D_CTRL, 0x54);		
+		
+		value8 = rtw_read8(Adapter, REG_LDOV12D_CTRL);	
+		value8 &= (~LDV12_EN);		
+		rtw_write8(Adapter, REG_LDOV12D_CTRL, value8);			
+		//RT_TRACE(COMP_INIT, DBG_LOUD, (" REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
+	}
+	
+/*****************************
+h.	SPS0_CTRL 0x11[7:0] = 0x23			//enter PFM mode
+i.	APS_FSMCO 0x04[15:0] = 0x4802		// set USB suspend 
+******************************/	
+	rtw_write8(Adapter, REG_SPS0_CTRL, 0x23);
+	
+	value16 |= (APDM_HOST | AFSM_HSUS |PFM_ALDN);
+
+	
+	rtw_write16(Adapter, REG_APS_FSMCO,(u16)value16 );
+
+	rtw_write8(Adapter, REG_RSV_CTRL, 0x0e);
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n",value16));
+}
+
+static int	
+CardDisableHWSM( // HW Auto state machine
+	IN	PADAPTER		Adapter,
+	IN	BOOLEAN			resetMCU
+	)
+{
+	int		rtStatus = _SUCCESS;
+	if(Adapter->bSurpriseRemoved){
+		return rtStatus;
+	}
+#if 1
+	//==== RF Off Sequence ====
+	_DisableRFAFEAndResetBB(Adapter);
+
+	//  ==== Reset digital sequence   ======
+	_ResetDigitalProcedure1(Adapter, _FALSE);
+	
+	//  ==== Pull GPIO PIN to balance level and LED control ======
+	_DisableGPIO(Adapter);
+
+	//  ==== Disable analog sequence ===
+	_DisableAnalog(Adapter, _FALSE);
+
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("======> Card disable finished.\n"));
+#else
+	_DisableGPIO(Adapter);
+	
+	//reset FW download register
+	_ResetFWDownloadRegister(Adapter);
+
+
+	//disable RF/ AFE AD/DA
+	rtStatus = _DisableRF_AFE(Adapter);
+	if(RT_STATUS_SUCCESS != rtStatus){
+		RT_TRACE(COMP_INIT, DBG_SERIOUS, ("_DisableRF_AFE failed!\n"));
+		goto Exit;
+	}
+	_ResetBB(Adapter);
+
+	if(resetMCU){
+		_ResetMCU(Adapter);
+	}
+
+	_AutoPowerDownToHostOff(Adapter);
+	//_DisableMAC_AFE_PLL(Adapter);
+	
+	_SetUsbSuspend(Adapter);
+Exit:
+#endif
+	return rtStatus;
+	
+}
+
+static int	
+CardDisableWithoutHWSM( // without HW Auto state machine
+	IN	PADAPTER		Adapter	
+	)
+{
+	int		rtStatus = _SUCCESS;
+
+	if(Adapter->bSurpriseRemoved){
+		return rtStatus;
+	}
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Card Disable Without HWSM .\n"));
+	//==== RF Off Sequence ====
+	_DisableRFAFEAndResetBB(Adapter);
+
+	//  ==== Reset digital sequence   ======
+	_ResetDigitalProcedure1(Adapter, _TRUE);
+
+	//  ==== Pull GPIO PIN to balance level and LED control ======
+	_DisableGPIO(Adapter);
+
+	//  ==== Reset digital sequence   ======
+	_ResetDigitalProcedure2(Adapter);
+
+	//  ==== Disable analog sequence ===
+	_DisableAnalog(Adapter, _TRUE);
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("<====== Card Disable Without HWSM .\n"));
+	return rtStatus;
+}
+
+
+VOID HwSuspendModeEnable92Cu(
+	IN	PADAPTER		pAdapter,
+	IN	u8			Type
+	)
+{	
+	u16	reg = rtw_read16(pAdapter, REG_GPIO_MUXCFG);	
+
+	//if (!pDevice->RegUsbSS)
+	{
+		return;
+	}
+
+	//
+	// 2010/08/23 MH According to Alfred's suggestion, we need to to prevent HW
+	// to enter suspend mode automatically. Otherwise, it will shut down major power 
+	// domain and 8051 will stop. When we try to enter selective suspend mode, we
+	// need to prevent HW to enter D2 mode aumotmatically. Another way, Host will
+	// issue a S10 signal to power domain. Then it will cleat SIC setting(from Yngli).
+	// We need to enable HW suspend mode when enter S3/S4 or disable. We need 
+	// to disable HW suspend mode for IPS/radio_off.
+	//
+	//RT_TRACE(COMP_RF, DBG_LOUD, ("HwSuspendModeEnable92Cu = %d\n", Type));
+	if (Type == _FALSE)
+	{
+		reg |= BIT14;
+		printk("REG_GPIO_MUXCFG = %x\n", reg);
+		rtw_write16(pAdapter, REG_GPIO_MUXCFG, reg);
+		reg |= BIT12;
+		printk("REG_GPIO_MUXCFG = %x\n", reg);
+		rtw_write16(pAdapter, REG_GPIO_MUXCFG, reg);
+	}
+	else
+	{
+		reg &= (~BIT12);
+		rtw_write16(pAdapter, REG_GPIO_MUXCFG, reg);
+		reg &= (~BIT14);
+		rtw_write16(pAdapter, REG_GPIO_MUXCFG, reg);
+	}
+	
+}	// HwSuspendModeEnable92Cu
+
+static void rtl8192cu_hw_power_down(_adapter *padapter)
+{
+	// 2010/-8/09 MH For power down module, we need to enable register block contrl reg at 0x1c.
+	// Then enable power down control bit of register 0x04 BIT4 and BIT15 as 1.
+		
+	// Enable register area 0x0-0xc.
+	rtw_write8(padapter,REG_RSV_CTRL, 0x0);			
+	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
+}
+
+u32 rtl8192cu_hal_deinit(_adapter *padapter)
+ {
+        printk("==> %s \n",__FUNCTION__);
+ 
+ #ifdef SUPPORT_HW_RFOFF_DETECTED
+ 	printk("bkeepfwalive(%x)\n",padapter->pwrctrlpriv.bkeepfwalive);
+ 	if(padapter->pwrctrlpriv.bkeepfwalive)
+ 	{
+		_ps_close_RF(padapter);		
+		if(padapter->pwrctrlpriv.bHWPowerdown)		
+			rtl8192cu_hw_power_down(padapter);
+		
+ 	}
+	else
+#endif
+	{
+		if( padapter->bCardDisableWOHSM == _FALSE)
+		{
+			printk("card disble HWSM...........\n");
+			CardDisableHWSM(padapter, _FALSE);
+		}
+		else
+		{
+			printk("card disble without HWSM...........\n");
+			CardDisableWithoutHWSM(padapter); // without HW Auto state machine	
+
+			if(padapter->pwrctrlpriv.bHWPowerdown)		
+				rtl8192cu_hw_power_down(padapter);
+		}
+	}	
+	
+	return _SUCCESS;
+ }
+
+
+unsigned int rtl8192cu_inirp_init(_adapter * padapter)
+{	
+	u8 i;	
+	struct recv_buf *precvbuf;
+	uint	status;
+	struct dvobj_priv *pdev=&padapter->dvobjpriv;
+	struct intf_hdl * pintfhdl=&padapter->iopriv.intf;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+_func_enter_;
+
+	_read_port = pintfhdl->io_ops._read_port;
+
+	status = _SUCCESS;
+
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));	
+		
+	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
+
+	//issue Rx irp to receive data	
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;	
+	for(i=0; i<NR_RECVBUFF; i++)
+	{
+		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
+		{
+			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
+			status = _FAIL;
+			goto exit;
+		}
+		
+		precvbuf++;		
+		precvpriv->free_recv_buf_queue_cnt--;
+	}
+		
+exit:
+	
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init \n"));
+
+_func_exit_;
+
+	return status;
+
+}
+
+unsigned int rtl8192cu_inirp_deinit(_adapter * padapter)
+{	
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n ===> usb_rx_deinit \n"));
+	
+	read_port_cancel(padapter);
+
+
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit \n"));
+
+	return _SUCCESS;
+}
+
+
+void rtl8192cu_set_hal_ops(_adapter * padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+_func_enter_;
+
+	pHalData->hal_ops.hal_init = &rtl8192cu_hal_init;
+	pHalData->hal_ops.hal_deinit = &rtl8192cu_hal_deinit;
+
+	pHalData->hal_ops.inirp_init = &rtl8192cu_inirp_init;
+	pHalData->hal_ops.inirp_deinit = &rtl8192cu_inirp_deinit;
+
+	pHalData->hal_ops.intf_chip_configure = &rtl8192cu_interface_configure;
+	pHalData->hal_ops.read_adapter_info = &NicIFReadAdapterInfo8192C;
+
+	pHalData->hal_ops.set_bwmode_handler = &PHY_SetBWMode8192C;
+	pHalData->hal_ops.set_channel_handler = &PHY_SwChnl8192C;
+
+	pHalData->hal_ops.process_phy_info = &rtl8192c_process_phy_info;
+	pHalData->hal_ops.hal_dm_watchdog = &rtl8192c_HalDmWatchDog;
+
+_func_exit_;
+}
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1206 @@
+/******************************************************************************
+* usb_ops_ce.c                                                                                                                                 *
+*                                                                                                                                          *
+* Description :                                                                                                                       *
+*                                                                                                                                           *
+* Author :                                                                                                                       *
+*                                                                                                                                         *
+* History :
+*
+*
+*                                                                                                                                       *
+* Copyright 2007, Realtek Corp.                                                                                                  *
+*                                                                                                                                        *
+* The contents of this file is the sole property of Realtek Corp.  It can not be                                     *
+* be used, copied or modified without written permission from Realtek Corp.                                         *
+*                                                                                                                                          *
+*******************************************************************************/
+#define _HCI_OPS_OS_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#ifndef PLATFORM_OS_CE
+    #error "PLATFORM_OS_CE shall be set \n"
+#endif
+
+#ifndef CONFIG_USB_HCI
+	#error "CONFIG_USB_HCI shall be on!\n"
+#endif
+
+#include <rtl8712_spec.h>
+#include <usb_ops.h>
+#include <recv_osdep.h>
+
+#include <circ_buf.h>
+
+
+struct zero_bulkout_context
+{
+	void *pbuf;
+	void *purb;
+	void *pirp;
+	void *padapter;
+};
+
+
+
+#define PUSB_ERROR LPDWORD
+#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)
+
+
+USB_PIPE ffaddr2pipehdl(struct dvobj_priv *pNdisCEDvice, u32 addr);
+
+
+static NTSTATUS usb_async_interrupt_in_complete( LPVOID Context );
+static NTSTATUS usb_async_interrupt_out_complete( LPVOID Context );
+
+DWORD usb_write_port_complete( LPVOID Context );
+DWORD usb_read_port_complete( LPVOID Context );
+
+void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+_func_enter_;
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+_func_exit_;
+}
+
+
+
+BOOL
+CloseTransferHandle(
+    LPCUSB_FUNCS   pUsbFuncs,
+    USB_TRANSFER   hTransfer
+    )
+{
+    BOOL bRc = TRUE;
+
+    // This assert may fail on suprise remove,
+    // but should pass during normal I/O.
+    // ASSERT( pUsbFuncs->lpIsTransferComplete(hTransfer) ); 
+
+    // CloseTransfer aborts any pending transfers
+    if ( !pUsbFuncs->lpCloseTransfer(hTransfer) ) {
+     
+	RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("*** CloseTransfer ERROR:%d ***\n", GetLastError()));	
+        bRc = FALSE;
+    }
+
+    return bRc;
+}
+
+
+BOOL
+GetTransferStatus(
+    LPCUSB_FUNCS   pUsbFuncs,
+    USB_TRANSFER   hTransfer,
+    LPDWORD        pBytesTransferred , // OPTIONAL returns number of bytes transferred
+    PUSB_ERROR     pUsbError  	 // returns USB error code
+    )
+{
+
+    BOOL bRc = TRUE;
+
+    if ( pUsbFuncs->lpGetTransferStatus(hTransfer, pBytesTransferred, pUsbError) ) {
+        if ( USB_NO_ERROR != *pUsbError ) {
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("*** CloseTransfer ERROR:%d ***\n", GetLastError()));		
+            RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("GetTransferStatus (BytesTransferred:%d, UsbError:0x%x)\n", pBytesTransferred?*pBytesTransferred:-1, pUsbError?*pUsbError:-1 )); 
+        }
+    } else {
+        RT_TRACE( _module_hci_ops_os_c_, _drv_err_,("*** GetTransferStatus ERROR:%d ***\n", GetLastError())); 
+        *pUsbError = USB_CANCELED_ERROR;
+        bRc = FALSE;
+    }
+
+    return bRc;
+}
+
+
+// The driver should never read RxCmd register. We have to set
+// RCR CMDHAT0 (bit6) to append Rx status before the Rx frame.
+//
+// |<--------  pBulkUrb->TransferBufferLength  ------------>|
+// +------------------+-------------------+------------+
+//  | Rx status (16 bytes)  | Rx frame .....             | CRC(4 bytes) |
+// +------------------+-------------------+------------+
+// ^
+// ^pRfd->Buffer.VirtualAddress
+//
+/*! \brief USB RX IRP Complete Routine.
+	@param Context pointer of RT_RFD
+*/
+u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+    struct intf_priv	*pintfpriv		= pintfhdl->pintfpriv;
+    struct dvobj_priv	*pdvobj_priv	= (struct dvobj_priv*)pintfpriv->intf_dev;
+    _adapter			*adapter		= (_adapter *)pdvobj_priv->padapter;
+
+	struct recv_priv	*precvpriv	= &adapter->recvpriv;
+
+	struct recv_buf		*precvbuf	= (struct recv_buf *)rmem;
+	DWORD dwErr = ERROR_SUCCESS ;
+	DWORD dwBytesTransferred = 0 ;
+	USB_TRANSFER hTransfer = NULL;
+	USB_PIPE	hPipe;
+	LPCUSB_FUNCS usb_funcs_vp = pdvobj_priv->usb_extension._lpUsbFuncs;
+
+_func_enter_;
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_read_port(%u)\n", __LINE__));
+
+#if (CONFIG_PWRCTRL == 1)
+    if (adapter->pwrctrlpriv.pnp_bstop_trx)
+	{
+        return _FALSE;
+    }
+#endif
+
+	if(adapter->bDriverStopped || adapter->bSurpriseRemoved) 
+	{
+		RT_TRACE(_module_hci_ops_os_c_, _drv_info_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved)!!!\n"));
+		return _FALSE;
+	}
+
+	if(precvbuf !=NULL)
+	{
+
+		// get a recv buffer
+		rtw_init_recvbuf(adapter, precvbuf);
+	
+
+
+		_rtw_spinlock(&precvpriv->lock);
+		precvpriv->rx_pending_cnt++;
+		precvbuf->irp_pending = _TRUE;
+		_rtw_spinunlock(&precvpriv->lock);
+
+
+		//translate DMA FIFO addr to pipehandle
+		hPipe = ffaddr2pipehdl(pdvobj_priv, addr);
+		
+
+		RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_read_port(%u)\n", __LINE__));
+
+		precvbuf->usb_transfer_read_port = (*usb_funcs_vp->lpIssueBulkTransfer)(
+			hPipe,
+			usb_read_port_complete,
+			precvbuf,
+			USB_IN_TRANSFER|USB_SHORT_TRANSFER_OK,
+			MAX_RECVBUF_SZ,
+			precvbuf->pbuf,
+			0);
+
+
+		if(precvbuf->usb_transfer_read_port)
+		{
+			
+		//	  GetTransferStatus(usb_funcs_vp, hTransfer, &dwBytesTransferred,&UsbRc);
+
+		//	  CloseTransferHandle(usb_funcs_vp, hTransfer);
+
+		}
+		else
+		{
+
+			dwErr = GetLastError();
+			//RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port ERROR : %d\n", dwErr));		 
+
+		}
+
+//	 	if (  USB_NO_ERROR != UsbRc && ERROR_SUCCESS == dwErr) {
+//	        dwErr = ERROR_GEN_FAILURE;
+//	    }
+
+
+		if ( ERROR_SUCCESS != dwErr ) {
+
+			SetLastError(dwErr);
+			RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port ERROR : %d\n", dwErr));	
+		}
+	
+		RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("-usb_read_port(%u)\n", __LINE__));
+
+	}
+	else // if(precvbuf !=NULL)
+	{
+		
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precv_frame ==NULL\n"));
+	}
+
+	return _TRUE;
+
+}
+
+DWORD usb_read_port_complete( PVOID context )
+{
+	struct recv_buf 	*precvbuf	= (struct recv_buf *)context;
+	_adapter			*adapter	= (_adapter *)precvbuf->adapter;
+	struct recv_priv	*precvpriv	= &adapter->recvpriv;
+
+
+	struct intf_hdl		*pintfhdl = &adapter->pio_queue->intf;
+    struct intf_priv	*pintfpriv    = pintfhdl->pintfpriv;
+    struct dvobj_priv	*pdvobj_priv  = (struct dvobj_priv*)pintfpriv->intf_dev;
+
+
+	LPCUSB_FUNCS usb_funcs_vp = pdvobj_priv->usb_extension._lpUsbFuncs;
+
+    DWORD dwBytesTransferred    = 0;
+    DWORD dwErr                 = USB_CANCELED_ERROR;
+
+	uint isevt, *pbuf;
+	int fComplete =_FALSE;
+
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_read_port_complete(%u)\n", __LINE__));
+
+_func_enter_;
+
+
+	_rtw_spinlock_ex(&precvpriv->lock);
+	precvbuf->irp_pending=_FALSE;
+	precvpriv->rx_pending_cnt --;
+	_rtw_spinunlock_ex(&precvpriv->lock);	
+
+
+#if 1
+		
+	(*usb_funcs_vp->lpGetTransferStatus)(precvbuf->usb_transfer_read_port, &dwBytesTransferred, &dwErr);
+	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(precvbuf->usb_transfer_read_port);
+	if(fComplete!=_TRUE)
+	{
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port_complete CloseTransfer before complete\n"));
+	}
+	(*usb_funcs_vp->lpCloseTransfer)(precvbuf->usb_transfer_read_port);
+	
+	
+#endif
+
+
+	if(USB_NO_ERROR != dwErr)
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port_complete Fail :%d\n",dwErr));
+	
+	{
+
+		if ( dwBytesTransferred > MAX_RECVBUF_SZ || dwBytesTransferred < RXDESC_SIZE )
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,
+				("\n usb_read_port_complete: (pbulkurb->TransferBufferLength > MAX_RECVBUF_SZ) || (pbulkurb->TransferBufferLength < RXDESC_SIZE): %d\n",dwBytesTransferred));
+			rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+
+    	    //usb_read_port(pintfhdl, 0, 0, (unsigned char *)precvframe);
+    	}
+		else
+		{
+			precvbuf->transfer_len = dwBytesTransferred;
+
+			pbuf = (uint*)precvbuf->pbuf;
+
+			if((isevt = *(pbuf+1)&0x1ff) == 0x1ff)
+			{
+				RT_TRACE(_module_hci_ops_os_c_,_drv_info_,
+					("\n usb_read_port_complete: get a event\n"));
+				rxcmd_event_hdl(adapter, pbuf);//rx c2h events
+
+				rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+			}
+			else
+			{
+				if(recvbuf2recvframe(adapter, precvbuf)==_FAIL)//rx packets
+				{
+					//precvbuf->reuse = _TRUE;		
+					rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+				}
+			}
+	    }
+	}
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("-usb_read_port_complete(%u)\n", __LINE__));
+
+_func_exit_;
+	return ERROR_SUCCESS;
+//	return STATUS_MORE_PROCESSING_REQUIRED;
+}
+
+void usb_read_port_cancel(_adapter *padapter){
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_read_port_cancel(%u)\n",__FUNCTION__, __LINE__));
+}
+
+DWORD usb_write_mem_complete( LPVOID Context )
+{
+	int fComplete =_FALSE;
+	DWORD	dwBytes 	= 0;
+	DWORD	dwErr		= USB_CANCELED_ERROR;
+
+	_irqL irqL;
+	_list	*head;
+	_list *plist;
+	struct io_req	*pio_req;	
+	struct io_queue *pio_q = (struct io_queue *) Context;
+	struct intf_hdl *pintf = &(pio_q->intf);	
+	struct intf_priv *pintfpriv = pintf->pintfpriv;	
+	_adapter *padapter = (_adapter *)pintf->adapter;
+	NTSTATUS status = STATUS_SUCCESS;
+    struct xmit_priv * pxmitpriv	= &padapter->xmitpriv;
+
+	struct dvobj_priv * pdvobj_priv	= (struct dvobj_priv*)pintfpriv->intf_dev;
+
+    USB_HANDLE		usbHandle		= pdvobj_priv->usb_extension._hDevice;
+    LPCUSB_FUNCS	usb_funcs_vp	= pdvobj_priv->usb_extension._lpUsbFuncs;
+
+	// get the head from the processing io_queue
+	head = &(pio_q->processing);
+	
+_func_enter_;
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("+usb_write_mem_complete %p\n", Context));
+
+#if 1
+	_enter_critical_bh(&(pio_q->lock), &irqL);
+	
+
+	//free irp in processing list...	
+	while(rtw_is_list_empty(head) != _TRUE)
+	{
+		plist = get_next(head);	
+		list_delete(plist);
+		pio_req = LIST_CONTAINOR(plist, struct io_req, list);
+		_rtw_up_sema(&pio_req->sema);
+	}
+
+	_exit_critical_bh(&(pio_q->lock), &irqL);
+#endif
+
+
+#if 1
+		
+	(*usb_funcs_vp->lpGetTransferStatus)(pio_req->usb_transfer_write_mem , &dwBytes, &dwErr);
+	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(pio_req->usb_transfer_write_mem);
+	if(fComplete!=_TRUE)
+	{
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_write_mem_complete CloseTransfer before complete\n"));
+	}
+	(*usb_funcs_vp->lpCloseTransfer)(pio_req->usb_transfer_write_mem );
+	
+#endif
+	
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("-usb_write_mem_complete\n"));
+
+_func_exit_;
+
+
+	return STATUS_MORE_PROCESSING_REQUIRED;
+
+}
+
+
+void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+
+	NTSTATUS NtStatus = STATUS_SUCCESS;
+    USB_PIPE	hPipe;
+	_irqL	irqL;
+
+	int 	fComplete	= _FALSE;
+	DWORD	dwBytes 	= 0;
+	DWORD	dwErr		= USB_CANCELED_ERROR;
+
+
+	struct io_req 		*pio_req;
+
+	_adapter 			*adapter 	= (_adapter *)pintfhdl->adapter;
+	struct intf_priv 	*pintfpriv	= pintfhdl->pintfpriv;
+	struct dvobj_priv   * pdvobj_priv   = (struct dvobj_priv*)pintfpriv->intf_dev;
+
+	 
+    struct xmit_priv	*pxmitpriv	= &adapter->xmitpriv;
+	struct io_queue 	*pio_queue 	= (struct io_queue *)adapter->pio_queue; 
+
+	LPCUSB_FUNCS usb_funcs_vp = pdvobj_priv->usb_extension._lpUsbFuncs;
+
+
+_func_enter_;
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_write_mem(%u) pintfhdl %p wmem %p\n", __LINE__, pintfhdl, wmem));
+
+	// fetch a io_request from the io_queue
+	pio_req = alloc_ioreq(pio_queue);
+		
+	if ((pio_req == NULL)||(adapter->bSurpriseRemoved))
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("async_irp_write32 : pio_req =0x%x adapter->bSurpriseRemoved=0x%x",pio_req,adapter->bSurpriseRemoved ));
+		goto exit;
+	}	
+
+	_enter_critical_bh(&(pio_queue->lock), &irqL);
+
+
+	// insert the io_request into processing io_queue
+	rtw_list_insert_tail(&(pio_req->list),&(pio_queue->processing));
+	
+	
+	if((adapter->bDriverStopped) || (adapter->bSurpriseRemoved) ||(adapter->pwrctrlpriv.pnp_bstop_trx)) 
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\npadapter->pwrctrlpriv.pnp_bstop_trx==_TRUE\n"));
+		goto exit;
+	}
+	
+	//translate DMA FIFO addr to pipehandle
+	hPipe = ffaddr2pipehdl(pdvobj_priv, addr);	
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_,("usb_write_mem(%u)\n",__LINE__));
+
+	pio_req->usb_transfer_write_mem = (*usb_funcs_vp->lpIssueBulkTransfer)(
+		hPipe,
+		usb_write_mem_complete, 
+		pio_queue,
+		USB_OUT_TRANSFER,
+		cnt,
+		wmem,
+		0);
+
+#if 0
+
+	(*usb_funcs_vp->lpGetTransferStatus)(pio_req->usb_transfer_write_mem , &dwBytes, &dwErr);
+
+	while( fComplete != _TRUE)
+	{
+		fComplete = (*usb_funcs_vp->lpIsTransferComplete)(pio_req->usb_transfer_write_mem);
+		if(fComplete==_TRUE)
+		{
+			(*usb_funcs_vp->lpCloseTransfer)(pio_req->usb_transfer_write_mem );
+			RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_write_mem finished\n"));
+			break;
+		}
+		else
+		{
+			RT_TRACE( _module_hci_ops_os_c_, _drv_err_, 
+				("usb_write_mem not yet finished %X\n", 
+				pio_req->usb_transfer_write_mem));
+			rtw_msleep_os(10);
+		}
+		
+	}
+
+#endif
+
+
+//	_rtw_down_sema(&pio_req->sema);	
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("-usb_write_mem(%X)\n",pio_req->usb_transfer_write_mem));
+
+	_exit_critical_bh(&(pio_queue->lock), &irqL);
+
+	_rtw_down_sema(&pio_req->sema); 
+	free_ioreq(pio_req, pio_queue);
+
+exit:
+_func_exit_;
+	return;
+}
+
+u32 usb_write_cnt=0;
+u32 usb_complete_cnt=0;
+
+USB_PIPE ffaddr2pipehdl(struct dvobj_priv *pNdisCEDvice, u32 addr)
+{
+	USB_PIPE	PipeHandle = NULL;
+	_adapter	*padapter = pNdisCEDvice->padapter;
+
+	
+	if(pNdisCEDvice->nr_endpoint == 11)
+	{		
+		switch(addr)
+		{	    
+	     		case RTL8712_DMA_BEQ:
+		 		PipeHandle= padapter->halpriv.pipehdls_r8712[3] ; 
+				break;
+	     		case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
+				break;
+	     		case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
+				break;
+	    		case RTL8712_DMA_VOQ:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;					
+                     case RTL8712_DMA_BCNQ:	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[6]; 
+				break;	 	
+			case RTL8712_DMA_BMCQ:	//HI Queue
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[7]; 
+				break;	
+			case RTL8712_DMA_MGTQ:				
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[8]; 
+				break;
+                     case RTL8712_DMA_RX0FF:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;	 	
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
+				break;
+			case RTL8712_DMA_H2CCMD:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[9]; 
+				break;	
+				
+		}
+
+	}
+	else if(pNdisCEDvice->nr_endpoint == 6)
+	{
+		switch(addr)
+		{	    
+			case RTL8712_DMA_BEQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
+				break;
+	     	case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
+				break;
+	     	case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
+				break;
+	    	case RTL8712_DMA_VOQ:                   		
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;
+			case RTL8712_DMA_RX0FF:
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;
+			case RTL8712_DMA_H2CCMD:
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:			
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
+				break;	
+				
+		}
+
+	}
+	else if(pNdisCEDvice->nr_endpoint == 4)
+	{
+		switch(addr)
+		{	    
+	     	case RTL8712_DMA_BEQ:
+		 	case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
+				break;
+     		case RTL8712_DMA_VIQ:
+		 	case RTL8712_DMA_VOQ:					
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;
+			case RTL8712_DMA_RX0FF:
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;
+			case RTL8712_DMA_H2CCMD:	
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:				
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
+				break;	
+		}
+	
+	}
+	else
+	{
+	   RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ffaddr2pipehdl():nr_endpoint=%d error!\n", pNdisCEDvice->nr_endpoint));	   
+	}
+		
+	return PipeHandle;
+
+}
+
+DWORD usb_bulkout_zero_complete( LPVOID pZeroContext )
+{
+	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)pZeroContext;
+	_adapter * padapter = pcontext->padapter;
+    struct dvobj_priv *	pdvobj_priv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	LPCUSB_FUNCS usb_funcs_vp = pdvobj_priv->usb_extension._lpUsbFuncs;
+	struct xmit_priv  * pxmitpriv	= &padapter->xmitpriv;
+
+	int 	fComplete			=_FALSE;
+	DWORD	dwBytesTransferred	= 0;
+	DWORD	dwErr				= USB_CANCELED_ERROR;
+
+_func_enter_;
+
+#if 1
+				
+	(*usb_funcs_vp->lpGetTransferStatus)(pxmitpriv->usb_transfer_write_port, &dwBytesTransferred, &dwErr);
+	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(pxmitpriv->usb_transfer_write_port);
+	if(fComplete!=_TRUE)
+	{
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_bulkout_zero_complete CloseTransfer before complete\n"));
+	}
+	(*usb_funcs_vp->lpCloseTransfer)(pxmitpriv->usb_transfer_write_port);
+	
+#endif
+
+	if(pcontext)
+	{
+		if(pcontext->pbuf)
+		{			
+			_rtw_mfree(pcontext->pbuf, sizeof(int));	
+		}	
+
+		_rtw_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));	
+	}	
+
+_func_exit_;
+
+	return ERROR_SUCCESS;
+	
+
+}
+
+u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
+{	
+	struct zero_bulkout_context *pcontext;
+	unsigned char *pbuf;
+	u8 len = 0 ;
+	_adapter *padapter = (_adapter *)pintfhdl->adapter;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;	
+	struct xmit_priv	* pxmitpriv     = &padapter->xmitpriv;
+     
+
+	LPCUSB_FUNCS usb_funcs_vp = pdvobj->usb_extension._lpUsbFuncs;
+
+	USB_PIPE	hPipe;
+
+_func_enter_;
+
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{		
+		return _FAIL;
+	}
+
+
+	pcontext = (struct zero_bulkout_context *)_rtw_zmalloc(sizeof(struct zero_bulkout_context));
+
+	pbuf = (unsigned char *)_rtw_zmalloc(sizeof(int));	
+
+	len = 0;
+	
+	pcontext->pbuf = pbuf;
+	pcontext->purb = NULL;
+	pcontext->pirp = NULL;
+	pcontext->padapter = padapter;
+                    
+
+//translate DMA FIFO addr to pipehandle
+	hPipe = ffaddr2pipehdl(pdvobj, addr);
+
+
+
+
+	pxmitpriv->usb_transfer_write_port = (*usb_funcs_vp->lpIssueBulkTransfer)(
+						        hPipe, usb_bulkout_zero_complete, 
+						        pcontext, USB_OUT_TRANSFER,
+					    	    len, pbuf, 0);
+
+	
+_func_exit_;
+	
+	return _SUCCESS;
+
+}
+
+u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+
+    u32	i, bwritezero = _FALSE;
+	u32	ac_tag = addr;
+
+    u8*	ptr;
+
+	struct intf_priv    * pintfpriv     = pintfhdl->pintfpriv;
+	struct dvobj_priv   * pdvobj_priv   = (struct dvobj_priv*)pintfpriv->intf_dev;
+	_adapter            * padapter      = pdvobj_priv->padapter;
+
+    struct xmit_priv	* pxmitpriv     = &padapter->xmitpriv;
+    struct xmit_frame   * pxmitframe    = (struct xmit_frame *)wmem;
+
+	LPCUSB_FUNCS usb_funcs_vp = pdvobj_priv->usb_extension._lpUsbFuncs;
+
+    USB_PIPE	hPipe;
+
+	u32			bResult = _FALSE;
+
+_func_enter_;
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("+usb_write_port\n"));
+
+#if (CONFIG_PWRCTRL == 1)
+    if(padapter->pwrctrlpriv.pnp_bstop_trx==_TRUE){
+       	RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("\npadapter->pwrctrlpriv.pnp_bstop_trx==_TRUE\n"));
+
+    }
+#endif
+
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		bResult = _FALSE;
+		goto exit;
+	}
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_write_port(%u)\n", __LINE__));
+
+	for(i=0; i<8; i++)
+	{
+		if(pxmitframe->bpending[i] == _FALSE)
+		{
+			_rtw_spinlock(&pxmitpriv->lock);	
+			pxmitpriv->txirp_cnt++;
+			pxmitframe->bpending[i]  = _TRUE;
+			_rtw_spinunlock(&pxmitpriv->lock);
+			
+			pxmitframe->sz[i] = cnt;
+			pxmitframe->ac_tag[i] = ac_tag;
+
+			break;
+		}
+	}	
+
+
+	//TODO:
+	if (pdvobj_priv->ishighspeed)
+	{
+		if(cnt> 0 && cnt%512 == 0)
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ishighspeed, cnt=%d\n", cnt));
+		//	cnt=cnt+1;
+			bwritezero = _TRUE;
+
+		}	
+	}
+	else
+	{
+		if(cnt > 0 && cnt%64 == 0)
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("cnt=%d\n", cnt));
+		//	cnt=cnt+1;
+			bwritezero = _TRUE;
+
+		}	
+	}
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_write_port: pipe handle convert\n"));
+
+	//translate DMA FIFO addr to pipehandle
+	hPipe = ffaddr2pipehdl(pdvobj_priv, addr);
+
+
+#if 0
+	// for tx fifo, the maximum payload number is 8,
+	// we workaround this issue here by separate whole fifo into 8 segments.
+	if (cnt <= 500)
+		cnt = 500;
+#endif
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_,
+		("usb_write_port(%u): pxmitframe %X  pxmitframe->padapter %X\n",__LINE__, pxmitframe, pxmitframe->padapter));
+
+	pxmitpriv->usb_transfer_write_port = (*usb_funcs_vp->lpIssueBulkTransfer)(
+						        hPipe, usb_write_port_complete, 
+						        pxmitframe, USB_OUT_TRANSFER,
+					    	    cnt, pxmitframe->mem_addr, 0);
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+
+	ptr=(u8 *)&pxmitframe->mem;
+
+#if 0
+	if (pdvobj_priv->ishighspeed)
+	{
+		ptr=ptr+512;
+	}
+	else
+	{
+		ptr=ptr+64;
+
+	}
+#endif
+	if(bwritezero == _TRUE)
+	{
+		usb_bulkout_zero(pintfhdl, addr);
+	}
+
+//	if (!pxmitframe->usb_transfer_xmit)
+//	    padapter->bSurpriseRemoved=_TRUE;
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+	bResult = _SUCCESS;
+
+exit:
+_func_exit_;
+	return bResult;
+}
+
+DWORD usb_write_port_complete( LPVOID Context )
+{
+
+//    u8 *ptr;
+
+    struct xmit_frame *	pxmitframe  = (struct xmit_frame *) Context;
+    _adapter          * padapter    = pxmitframe->padapter;
+    struct dvobj_priv *	pdvobj_priv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct xmit_priv  * pxmitpriv   = &padapter->xmitpriv;
+	struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	LPCUSB_FUNCS usb_funcs_vp = pdvobj_priv->usb_extension._lpUsbFuncs;
+
+	int		fComplete			=_FALSE;
+	DWORD	dwBytesTransferred	= 0;
+	DWORD	dwErr				= USB_CANCELED_ERROR;
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u), pxmitframe %X\n",__FUNCTION__, __LINE__, Context));
+
+_func_enter_;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("+usb_write_port_complete\n"));
+
+	_rtw_spinlock_ex(&pxmitpriv->lock);	
+	pxmitpriv->txirp_cnt--;
+	_rtw_spinunlock_ex(&pxmitpriv->lock);
+
+	if(pxmitpriv->txirp_cnt==0){
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));		
+		_rtw_up_sema(&(pxmitpriv->tx_retevt));
+	}
+
+
+	//not to consider tx fragment
+	rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);		
+
+
+#if 1
+			
+	(*usb_funcs_vp->lpGetTransferStatus)(pxmitpriv->usb_transfer_write_port, &dwBytesTransferred, &dwErr);
+	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(pxmitpriv->usb_transfer_write_port);
+	if(fComplete!=_TRUE)
+	{
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_write_port_complete CloseTransfer before complete\n"));
+	}
+	(*usb_funcs_vp->lpCloseTransfer)(pxmitpriv->usb_transfer_write_port);
+
+#else
+
+	if((*usb_funcs_vp->lpIsTransferComplete)(pxmitpriv->usb_transfer_write_port))
+	{
+		(*usb_funcs_vp->lpCloseTransfer)(pxmitpriv->usb_transfer_write_port);
+	}
+
+#endif
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, 
+		("%s(%u): pxmitpriv %X pxmitpriv->free_xmitframe_cnt %X pxmitframe->padapter %X pxmitframe->padapter %X\n", 
+		__LINE__, pxmitpriv, pxmitpriv->free_xmitframe_cnt, pxmitframe->padapter));
+
+    rtw_xmitframe_complete(padapter, pxmitpriv, pxmitbuf);
+
+_func_exit_;
+
+    return STATUS_SUCCESS;
+}
+
+DWORD usb_write_scsi_complete(LPVOID pTxContext) 
+{
+#ifndef PLATFORM_OS_CE
+	struct SCSI_BUFFER_ENTRY *psb_entry = (struct SCSI_BUFFER_ENTRY *)pTxContext;
+	_adapter 				 *padapter 	= psb_entry->padapter;
+	struct SCSI_BUFFER 		 *psb 		= padapter->pscsi_buf;
+	struct xmit_priv 		 *pxmitpriv = &(padapter->xmitpriv);
+    struct dvobj_priv 		*pdvobj_priv = (struct dvobj_priv *)&padapter->dvobjpriv;
+	LPCUSB_FUNCS 		  	 lpUsbFuncs = pdvobj_priv->pUsbExtension->_lpUsbFuncs;
+
+	int 	fComplete			=_FALSE;
+	DWORD	dwBytesTransferred	= 0;
+	DWORD	dwErr				= USB_CANCELED_ERROR;
+
+_func_enter_;
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u): circ_space = %d\n",__FUNCTION__, __LINE__, CIRC_SPACE( psb->head,psb->tail,  SCSI_BUFFER_NUMBER)));
+
+#if 1
+				
+	(*lpUsbFuncs->lpGetTransferStatus)(psb_entry->usb_transfer_scsi_txcmd, &dwBytesTransferred, &dwErr);
+	fComplete = (*lpUsbFuncs->lpIsTransferComplete)(psb_entry->usb_transfer_scsi_txcmd);
+	if(fComplete!=_TRUE)
+	{
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_write_scsi_complete CloseTransfer before complete\n"));
+	}
+	(*lpUsbFuncs->lpCloseTransfer)(psb_entry->usb_transfer_scsi_txcmd);
+	
+#else
+
+	if((*lpUsbFuncs->lpIsTransferComplete)(psb_entry->usb_transfer_scsi_txcmd))
+		(*lpUsbFuncs->lpCloseTransfer)(psb_entry->usb_transfer_scsi_txcmd);
+#endif
+
+	memset(psb_entry->entry_memory, 0, 8);
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+	if((psb->tail+1)==SCSI_BUFFER_NUMBER)
+		psb->tail=0;
+	else 
+		psb->tail++;
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+	if(CIRC_CNT(psb->head,psb->tail,SCSI_BUFFER_NUMBER)==0){
+		RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("write_txcmd_scsififo_callback: up_sema\n"));
+		_rtw_up_sema(&pxmitpriv->xmit_sema);
+	}
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+	if(padapter->bSurpriseRemoved) {
+		return STATUS_MORE_PROCESSING_REQUIRED;
+	}
+
+_func_exit_;
+#endif
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+	return STATUS_MORE_PROCESSING_REQUIRED;
+}
+
+uint usb_write_scsi(struct intf_hdl *pintfhdl, u32 cnt, u8 *wmem)
+{
+
+#ifndef PLATFORM_OS_CE
+
+	_adapter 		  *padapter = (_adapter *)pintfhdl->adapter;
+	struct dvobj_priv *pdev 	= (struct dvobj_priv*)&padapter->dvobjpriv;
+
+	struct SCSI_BUFFER       *psb      =padapter->pscsi_buf;
+	struct SCSI_BUFFER_ENTRY *psb_entry=LIST_CONTAINOR(wmem,struct SCSI_BUFFER_ENTRY,entry_memory);
+
+_func_enter_;
+	if(padapter->bSurpriseRemoved||padapter->bDriverStopped)
+		return 0;
+	
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+	psb_entry->usb_transfer_scsi_txcmd=pdev->pUsbExtension->_lpUsbFuncs->lpIssueBulkTransfer(
+			pdev->scsi_out_pipehandle,
+			usb_write_scsi_complete,
+			psb_entry,
+			USB_OUT_TRANSFER,
+			cnt,
+			wmem,
+			0);
+	
+_func_exit_;
+#endif
+
+   return _SUCCESS;  
+}
+
+
+/*
+ */
+uint usb_init_intf_priv(struct intf_priv *pintfpriv)
+{
+    // get the dvobj_priv object
+	struct dvobj_priv * pNdisCEDvice = (struct dvobj_priv *) pintfpriv->intf_dev;
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+    // set init intf_priv init status as _IOREADY
+	pintfpriv->intf_status = _IOREADY;
+
+    //  determine the max io size by dvobj_priv.ishighspeed
+    if(pNdisCEDvice->ishighspeed)
+        pintfpriv->max_iosz =  128;
+	else
+        pintfpriv->max_iosz =  64;
+
+    //  read/write size set as 0
+	pintfpriv->io_wsz = 0;
+	pintfpriv->io_rsz = 0;
+
+    //  init io_rwmem buffer
+	pintfpriv->allocated_io_rwmem = _rtw_zmalloc(pintfpriv->max_iosz +4);
+    if (pintfpriv->allocated_io_rwmem == NULL)
+    {
+	    _rtw_mfree((u8 *)(pintfpriv->allocated_io_rwmem), pintfpriv->max_iosz +4);
+	    return _FAIL;
+    }
+    else
+    {
+        // word align the io_rwmem
+	    pintfpriv->io_rwmem = pintfpriv->allocated_io_rwmem + 4 - ( (u32)(pintfpriv->allocated_io_rwmem) & 3);
+    }
+
+#ifndef PLATFORM_OS_CE
+
+    //  init io_r_mem buffer
+	pintfpriv->allocated_io_r_mem = _rtw_zmalloc(pintfpriv->max_iosz +4);
+    if (pintfpriv->allocated_io_r_mem == NULL)
+    {
+	    _rtw_mfree((u8 *)(pintfpriv->allocated_io_r_mem), pintfpriv->max_iosz +4);
+	    return _FAIL;
+    }
+    else
+    {
+        // word align the io_rwmem
+	    pintfpriv->io_r_mem = pintfpriv->allocated_io_r_mem + 4 - ( (u32)(pintfpriv->allocated_io_r_mem) & 3);
+    }
+#endif
+
+    return _SUCCESS;
+}
+
+void usb_unload_intf_priv(struct intf_priv *pintfpriv)
+{
+#ifndef PLATFORM_OS_CE
+
+	_rtw_mfree((u8 *)(pintfpriv->allocated_io_rwmem), pintfpriv->max_iosz+4);
+    _rtw_mfree((u8 *)(pintfpriv->allocated_io_r_mem), pintfpriv->max_iosz+4);
+#endif
+
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
+}
+
+
+
+void usb_write_port_cancel(_adapter *padapter)
+{
+
+	sint i,j;
+	struct dvobj_priv   *pdev = &padapter->dvobjpriv;
+	struct xmit_priv *pxmitpriv=&padapter->xmitpriv;
+	struct xmit_frame *pxmitframe;
+
+	_rtw_spinlock(&pxmitpriv->lock);
+	pxmitpriv->txirp_cnt--; //decrease 1 for Initialize ++
+	_rtw_spinunlock(&pxmitpriv->lock);
+	
+	if (pxmitpriv->txirp_cnt) 
+	{
+		// Canceling Pending Recv Irp
+		pxmitframe= (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
+		
+		for( i = 0; i < NR_XMITFRAME; i++ )
+		{
+			for(j=0;j<8;j++)
+			{
+				if (pxmitframe->bpending[j]==_TRUE)
+				{			
+
+					RT_TRACE(_module_hci_ops_os_c_,_drv_err_,(" usb_write_port_cancel() :IoCancelIrp\n"));
+
+				}
+			}
+			
+			pxmitframe++;
+		}
+
+		_rtw_down_sema(&(pxmitpriv->tx_retevt));
+		
+	}
+
+}
+
+DWORD usbctrl_vendorreq_complete(LPVOID lpvNotifyParameter)
+{
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv*)lpvNotifyParameter;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_debug_,("+usbctrl_vendorreq_complete\n"));
+	
+    return STATUS_SUCCESS;
+}
+
+
+int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	u8			ret=_TRUE;
+//	NTSTATUS	ntstatus;
+//	int 		fComplete;
+//	LPCUSB_DEVICE		lpDeviceInfo;
+
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfpriv->intf_dev;   
+
+    USB_TRANSFER        usbTrans;
+    USB_DEVICE_REQUEST  usb_device_req;
+    USB_HANDLE      usbHandle   = pdvobjpriv->usb_extension._hDevice;
+    LPCUSB_FUNCS    usbFuncs    = pdvobjpriv->usb_extension._lpUsbFuncs;
+
+	u32	transfer_flags = 0;
+
+	_func_enter_;
+
+    memset( &usb_device_req, 0, sizeof( USB_DEVICE_REQUEST ) );
+
+    if( 0x01 == requesttype )
+	{
+        usb_device_req.bmRequestType = USB_REQUEST_DEVICE_TO_HOST | USB_REQUEST_VENDOR | USB_REQUEST_FOR_DEVICE;
+    }
+	else
+    {
+        usb_device_req.bmRequestType = USB_REQUEST_HOST_TO_DEVICE | USB_REQUEST_VENDOR | USB_REQUEST_FOR_DEVICE;
+    }
+
+	usb_device_req.bRequest 		= request;
+	usb_device_req.wValue 			= value;
+	usb_device_req.wIndex 	    	= index;
+	usb_device_req.wLength 	    	= len;    
+
+	if (requesttype == 0x01)
+	{
+		transfer_flags = USB_IN_TRANSFER;//read_in
+	}
+	else
+	{
+		transfer_flags= USB_OUT_TRANSFER;//write_out
+	}
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_debug_,("+usbctrl_vendorreq\n",__FUNCTION__,__LINE__));
+
+#if 0
+	// Remember to add callback for sync
+	usbTrans = (*usbFuncs->lpIssueVendorTransfer)(usbHandle, 
+							usbctrl_vendorreq_complete, pdvobjpriv, 
+							transfer_flags, &usb_device_req, pdata, 0);
+#else
+	// Remember to add callback for sync
+	usbTrans = (*usbFuncs->lpIssueVendorTransfer)(usbHandle, 
+							NULL, 0, 
+							transfer_flags, &usb_device_req, pdata, 0);
+#endif
+
+//	rtw_usleep_os(10);
+
+	if ( usbTrans )
+	{
+		DWORD	dwBytes 	= 0;
+		DWORD	dwErr		= USB_CANCELED_ERROR;
+		int 	fComplete;
+
+		(*usbFuncs->lpGetTransferStatus)(usbTrans, &dwBytes, &dwErr);
+
+		fComplete = (*usbFuncs->lpIsTransferComplete)(usbTrans);
+
+		if (fComplete== _TRUE)
+		{
+			(*usbFuncs->lpCloseTransfer)(usbTrans);
+			RT_TRACE(_module_hci_ops_os_c_,_drv_debug_,("usbctrl_vendorreq lpCloseTransfer\n"));
+		}
+
+		if ( dwErr != USB_NO_ERROR || fComplete != _TRUE)
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq lpCloseTransfer without complete\n"));
+			ret = _FALSE;
+			goto exit;
+		}
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq without usbTrans\n"));
+		ret = _FALSE;
+		goto exit;
+
+	}
+
+exit:
+	RT_TRACE(_module_hci_ops_os_c_,_drv_debug_,("-usbctrl_vendorreq\n"));
+_func_exit_;
+	
+	return ret;	
+
+}
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1815 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _HCI_OPS_OS_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+#include <usb_ops.h>
+#include <circ_buf.h>
+#include <recv_osdep.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+struct zero_bulkout_context{
+	void *pbuf;
+	void *purb;
+	void *pirp;
+	void *padapter;
+};
+
+#define REALTEK_USB_VENQT_MAX_BUF_SIZE	254
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+#define USB_CONTROL_MSG_TIMEOUT	500		//ms
+#else
+#define USB_CONTROL_MSG_TIMEOUT	HZ/2	//jiffies
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
+#define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
+#define usb_bulkout_zero_complete(purb, regs)	usb_bulkout_zero_complete(purb)
+#define usb_write_mem_complete(purb, regs)	usb_write_mem_complete(purb)
+#define usb_write_port_complete(purb, regs)	usb_write_port_complete(purb)
+#define usb_read_port_complete(purb, regs)	usb_read_port_complete(purb)
+#endif
+
+
+
+#define ALIGNMENT_UNIT				16
+#define MAX_VENDOR_REQ_CMD_SIZE	254		//8188cu SIE Support
+#define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE +ALIGNMENT_UNIT)
+
+static int usbctrl_vendorreq(struct dvobj_priv  *pdvobjpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	unsigned int pipe;
+	int status = 0;
+	u32 tmp_buflen=0;
+	u8 reqtype;
+#if (DYNAMIC_ALLOCIATE_VENDOR_CMD==0)
+	u8 tmp_buf[MAX_USB_IO_CTL_SIZE];
+#endif
+	
+	struct usb_device *udev=pdvobjpriv->pusbdev;
+		
+	// Added by Albert 2010/02/09
+	// For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment.
+	// Trying to fix it here.
+
+	u8 *palloc_buf, *pIo_buf;
+
+	if(len>MAX_VENDOR_REQ_CMD_SIZE)
+	{
+		printk( "[%s] Buffer len error ,vendor request failed\n", __FUNCTION__ );
+		return(-1);
+	}
+	
+#if (DYNAMIC_ALLOCIATE_VENDOR_CMD==1)
+	palloc_buf = _rtw_malloc( (u32) len + ALIGNMENT_UNIT);
+	tmp_buflen =  (u32)len + ALIGNMENT_UNIT;
+#else
+	palloc_buf = tmp_buf;
+	tmp_buflen = MAX_USB_IO_CTL_SIZE;
+#endif
+
+	if ( palloc_buf== NULL)
+	{
+		printk( "[%s] Can't alloc memory for vendor request\n", __FUNCTION__ );
+		return(-1);
+	}
+	
+	_rtw_memset(palloc_buf, 0, tmp_buflen);		
+		
+	pIo_buf = palloc_buf + ALIGNMENT_UNIT -((SIZE_PTR)(palloc_buf) & 0x0f );	
+		
+	if (requesttype == 0x01)
+	{
+		pipe = usb_rcvctrlpipe(udev, 0);//read_in
+		reqtype =  REALTEK_USB_VENQT_READ;		
+	} 
+	else 
+	{
+		pipe = usb_sndctrlpipe(udev, 0);//write_out
+		reqtype =  REALTEK_USB_VENQT_WRITE;		
+		_rtw_memcpy( pIo_buf, pdata, len);
+	}		
+	
+	status = usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, USB_CONTROL_MSG_TIMEOUT);
+	
+	if (status < 0)
+       {
+		printk("reg 0x%x, usb %s  fail ,status:%d value=0x%x\n", value,(requesttype == 0x01)?"read":"write" , status, *(u32*)pdata);		
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+		{
+			_adapter *padapter =  pdvobjpriv->padapter;
+			padapter->Wifi_Error_Status = USB_VEN_REQ_CMD_FAIL;
+		}
+#endif
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("reg 0x%x, usb_read8 TimeOut! status:0x%x value=0x%x\n", value, status, *(u32*)pdata));
+       }
+	else if ( status > 0 )   // Success this control transfer.
+	{
+               if ( requesttype == 0x01 )
+               {   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
+                       _rtw_memcpy( pdata, pIo_buf,  status );
+               }
+	}
+	#if(DYNAMIC_ALLOCIATE_VENDOR_CMD==1)
+	_rtw_mfree( palloc_buf,tmp_buflen);
+	#endif
+
+	return status;
+
+}
+
+static void _usbctrl_vendorreq_async_callback(struct urb *urb, struct pt_regs *regs)
+{
+	if(urb){
+		if(urb->context){
+			kfree(urb->context);
+		}
+	}
+}
+
+static int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	int rc;
+	unsigned int pipe;	
+	u8 reqtype;
+	struct usb_ctrlrequest *dr;
+	struct urb *urb;
+	struct rtl819x_async_write_data {
+		u8 data[REALTEK_USB_VENQT_MAX_BUF_SIZE];
+		struct usb_ctrlrequest dr;
+	} *buf;
+	
+				
+	if (requesttype == VENDOR_READ){
+		pipe = usb_rcvctrlpipe(udev, 0);//read_in
+		reqtype =  REALTEK_USB_VENQT_READ;		
+	} 
+	else {
+		pipe = usb_sndctrlpipe(udev, 0);//write_out
+		reqtype =  REALTEK_USB_VENQT_WRITE;		
+	}		
+	
+	buf = kmalloc(sizeof(*buf), GFP_ATOMIC);
+	if (!buf)
+		return -ENOMEM;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	dr = &buf->dr;
+
+	dr->bRequestType = reqtype;
+	dr->bRequest = request;
+	dr->wValue = cpu_to_le16(value);
+	dr->wIndex = cpu_to_le16(index);
+	dr->wLength = cpu_to_le16(len);
+
+	memcpy(buf, pdata, len);
+
+	usb_fill_control_urb(urb, udev, pipe,
+			     (unsigned char *)dr, buf, len,
+			     _usbctrl_vendorreq_async_callback, buf);
+
+	rc = usb_submit_urb(urb, GFP_ATOMIC);
+	if (rc < 0) {
+		kfree(buf);
+	}
+	
+	usb_free_urb(urb);
+
+	return rc;
+
+}
+
+static void usb_write_async(struct usb_device *udev, u32 addr, u32 val, u16 len)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u32 data;
+	
+	requesttype = VENDOR_WRITE;//write_out	
+	request = REALTEK_USB_VENQT_CMD_REQ;
+	index = REALTEK_USB_VENQT_CMD_IDX;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	data = val & (0xffffffff >> ((4 - len) * 8));
+	data = cpu_to_le32(data);
+	
+	_usbctrl_vendorreq_async_write(udev, request, wvalue, index, &data, len, requesttype);
+}
+
+static u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data=0;	
+	int result;
+	u8	return_value = 0;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x01;//read_in
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;	
+	
+	result = usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	if(result<0)//for catc trigger
+	{
+		//printk("%s...error(%d)\n",__FUNCTION__,result);		
+	}
+	return_value = (u8)(le32_to_cpu(data)&0x0ff);
+
+	_func_exit_;
+	return return_value;
+		
+}
+
+static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
+{       
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data=0;
+	int result;
+
+	u16	return_value = 0;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x01;//read_in
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;	
+	
+	result = usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype) ;
+	if(result<0)
+	{
+		printk("%s...error(%d)\n",__FUNCTION__,result);
+		wvalue = 0xf0;
+		requesttype = 0x01;//read_in
+		len = 1;
+	        usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	}
+	return_value = (u16)(le32_to_cpu(data)&0xffff);
+	
+	_func_exit_;
+	return return_value;
+	
+}
+
+static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data=0;
+	int result;
+
+	u32	return_value = 0;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;  
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x01;//read_in
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;	
+	
+	result = usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	if(result<0)
+	{
+		printk("%s...error(%d)\n",__FUNCTION__,result);
+		wvalue = 0xf0;
+		requesttype = 0x01;//read_in
+		len = 1;
+	        usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	}
+	
+	return_value =le32_to_cpu(data);
+
+	
+	_func_exit_;
+	return return_value;
+	
+}
+
+static void usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	int result;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x00;//write_out
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+	
+	data = val;
+	data = cpu_to_le32(data&0x000000ff);
+	
+	result = usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	if(result<0)
+	{
+		printk("%s...error(%d)\n",__FUNCTION__,result);
+		wvalue = 0xf0;
+		requesttype = 0x01;//read_in
+		len = 1;
+	        usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	}
+	_func_exit_;
+	
+}
+
+static void usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
+{	
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	int result;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x00;//write_out
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+	
+	data = val;
+	data = cpu_to_le32(data&0x0000ffff);
+	
+	result = usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	if(result<0)//for catc trigger
+	{
+		//printk("%s...error(%d)\n",__FUNCTION__,result);		
+	}
+	
+	_func_exit_;
+	
+}
+
+static void usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	int result;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x00;//write_out
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	data = cpu_to_le32(val);	
+	
+	result = usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
+	if(result<0)//for catc trigger
+	{
+		//printk("%s...error(%d)\n",__FUNCTION__,result);		
+	}
+	_func_exit_;
+	
+}
+#define VENDOR_CMD_MAX_DATA_LEN	254
+void usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u8 buf[VENDOR_CMD_MAX_DATA_LEN]={0};
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;  
+	
+	_func_enter_;
+
+	request = 0x05;
+	requesttype = 0x00;//write_out
+	index = 0;//n/a
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = length;
+	 _rtw_memcpy(buf, pdata, len );
+	
+	usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, buf, len, requesttype);
+	
+	_func_exit_;
+	
+}
+
+static void usb_async_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
+{	
+	u32 data;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	struct usb_device *udev=pdvobjpriv->pusbdev;
+
+	_func_enter_;
+	data = cpu_to_le32(val & 0xFF);	
+	usb_write_async(udev, addr, val, 1);
+	_func_exit_;	
+}
+
+static void usb_async_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
+{	
+	u32 data;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	struct usb_device *udev=pdvobjpriv->pusbdev;
+
+	_func_enter_;
+	data = cpu_to_le32(val & 0xFFFF);	
+	usb_write_async(udev, addr, val, 2);
+	_func_exit_;	
+}
+static void usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
+{	
+	u32 data;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;   
+	struct usb_device *udev=pdvobjpriv->pusbdev;
+
+	_func_enter_;
+	data = cpu_to_le32(val);	
+	usb_write_async(udev, addr, val, 4);
+	_func_exit_;	
+}
+
+
+static int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
+{
+	int pipe=0, ep_num=0;
+	_adapter *padapter = pdvobj->padapter;
+	struct usb_device *pusbd = pdvobj->pusbdev;	
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+
+	if(addr == RECV_BULK_IN_ADDR)
+	{	
+		pipe=usb_rcvbulkpipe(pusbd, 0x01);
+
+		return pipe;
+	}
+
+	if(addr == RECV_INT_IN_ADDR)
+	{	
+		pipe=usb_rcvbulkpipe(pusbd, 0x04);
+
+		return pipe;
+	}
+
+	if(addr < HW_QUEUE_ENTRY) 
+	{
+		ep_num = (pHalData->Queue2EPNum[(u8)addr] & 0x0f);
+		
+		pipe = usb_sndbulkpipe(pusbd, ep_num);
+
+		return pipe;
+	}
+
+	return pipe;
+
+}
+
+static void usb_bulkout_zero_complete(struct urb *purb, struct pt_regs *regs)
+{	
+	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)purb->context;
+
+	//printk("+usb_bulkout_zero_complete\n");
+	
+	if(pcontext)
+	{
+		if(pcontext->pbuf)
+		{			
+			_rtw_mfree(pcontext->pbuf, sizeof(int));	
+		}	
+
+		if(pcontext->purb && (pcontext->purb==purb))
+		{
+			usb_free_urb(pcontext->purb);
+		}
+
+	
+		_rtw_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));	
+	}	
+	
+
+}
+
+static u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
+{	
+	int pipe, status, len;
+	u32 ret;
+	unsigned char *pbuf;
+	struct zero_bulkout_context *pcontext;
+	PURB	purb = NULL;	
+	_adapter *padapter = (_adapter *)pintfhdl->padapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;	
+	struct usb_device *pusbd = pdvobj->pusbdev;
+
+	//printk("+usb_bulkout_zero\n");
+	
+		
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{		
+		return _FAIL;
+	}
+	
+
+	pcontext = (struct zero_bulkout_context *)_rtw_zmalloc(sizeof(struct zero_bulkout_context));
+
+	pbuf = (unsigned char *)_rtw_zmalloc(sizeof(int));	
+    	purb = usb_alloc_urb(0, GFP_ATOMIC);
+      	
+	len = 0;
+	pcontext->pbuf = pbuf;
+	pcontext->purb = purb;
+	pcontext->pirp = NULL;
+	pcontext->padapter = padapter;
+
+	
+	//translate DMA FIFO addr to pipehandle
+	//pipe = ffaddr2pipehdl(pdvobj, addr);	
+
+	usb_fill_bulk_urb(purb, pusbd, pipe, 
+       				pbuf,
+              			len,
+              			usb_bulkout_zero_complete,
+              			pcontext);//context is pcontext
+
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+
+	if (!status)
+	{		
+		ret= _SUCCESS;
+	}
+	else
+	{
+		ret= _FAIL;
+	}
+	
+	
+	return _SUCCESS;
+
+}
+
+static void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+	
+}
+
+static void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	
+}
+
+#ifndef CONFIG_NON_SKB_TRANSFER_BUFFER
+static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
+{
+	u8	*pbuf;
+	u8	qos, shift_sz = 0;
+	u16	pkt_cnt, drvinfo_sz;
+	u32	pkt_len, pkt_offset;
+	s32	transfer_len;
+	SIZE_PTR tmpaddr = 0;
+	SIZE_PTR alignment = 0;
+	struct recv_stat	*prxstat;
+	_pkt			*pkt_copy = NULL;	
+	union recv_frame	*precvframe = NULL; 
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	_queue			*pfree_recv_queue = &precvpriv->free_recv_queue;
+
+
+	transfer_len = (s32)pskb->len;	
+	pbuf = pskb->data;
+
+	prxstat = (struct recv_stat *)pbuf;	
+	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
+	
+#if 0 //temp remove when disable usb rx aggregation
+	if((pkt_cnt > 10) || (pkt_cnt < 1) || (transfer_len<RXDESC_SIZE) ||(pkt_len<=0))
+	{		
+		return _FAIL;
+	}
+#endif
+	
+	do{		
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
+			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
+
+		prxstat = (struct recv_stat *)pbuf;	   
+		pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;	
+		
+
+		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;//uint 2^3 = 8 bytes
+		drvinfo_sz = drvinfo_sz << 3;
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: DRV_INFO_SIZE=%d\n", drvinfo_sz));
+
+		pkt_offset = pkt_len + drvinfo_sz + RXDESC_SIZE;
+
+		if((pkt_len<=0) || (pkt_offset>transfer_len))
+		{	
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
+			goto _exit_recvbuf2recvframe;
+		}		
+	
+#if 0
+		shift_sz = (le32_to_cpu(prxstat->rxdw0) & 0x03000000) >> 24;
+#else
+		//shift_sz deponds on qos bit
+		qos = (le32_to_cpu(prxstat->rxdw0) & 0x00800000) >> 23;
+		//	Modified by Albert 20101213
+		//	For 8 bytes IP header alignment.
+		shift_sz = (qos==1) ? 6:0;
+#endif
+
+		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
+		if(precvframe==NULL)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
+			goto _exit_recvbuf2recvframe;
+		}
+
+		_rtw_init_listhead(&precvframe->u.hdr.list);	
+		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
+		precvframe->u.hdr.len=0;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+		pkt_copy = dev_alloc_skb((pkt_offset>1612?pkt_offset:1612) + shift_sz + 8);		
+#else			
+		pkt_copy = netdev_alloc_skb(padapter->pnetdev, (pkt_offset>1612?pkt_offset:1612) + shift_sz + 8);
+#endif		
+
+		if(pkt_copy)
+		{					
+			tmpaddr = (SIZE_PTR)pkt_copy->data;	
+			alignment = tmpaddr & (7);			
+			skb_reserve(pkt_copy, (8 - alignment));//force pkt_copy->data at 8-byte alignment address
+			
+			skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
+			
+			//pkt_copy->dev = padapter->pnetdev;
+			
+			_rtw_memcpy(pkt_copy->data, pbuf, pkt_offset);
+			precvframe->u.hdr.pkt = pkt_copy;
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
+			precvframe->u.hdr.rx_end = pkt_copy->data + (pkt_offset>1612?pkt_offset:1612);
+		}
+		else
+		{	
+			//printk("recvbuf2recvframe:can not allocate memory for skb copy\n");				
+			precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);	
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
+			precvframe->u.hdr.rx_end = pbuf + (pkt_offset>1612?pkt_offset:1612);
+		}
+
+		recvframe_put(precvframe, pkt_len + drvinfo_sz + RXDESC_SIZE);
+		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);	
+
+#if USB_RX_AGGREGATION_92C	
+		switch(pHalData->UsbRxAggMode)
+		{
+			case USB_RX_AGG_DMA:
+			case USB_RX_AGG_MIX:
+				pkt_offset = (u16)_RND128(pkt_offset);
+				break;
+				case USB_RX_AGG_USB:
+				pkt_offset = (u16)_RND4(pkt_offset);
+				break;
+			case USB_RX_AGG_DISABLE:			
+			default:				
+				break;
+		}
+#endif
+
+		//because the endian issue, driver avoid reference to the rxstat after calling update_recvframe_attrib_from_recvstat();
+		rtl8192cu_update_recvframe_attrib_from_recvstat(precvframe, prxstat);		
+		
+		if(rtw_recv_entry(precvframe) != _SUCCESS)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
+		}
+
+		pkt_cnt--;
+	
+		transfer_len -= pkt_offset;
+		pbuf += pkt_offset;	
+		precvframe = NULL;
+		pkt_copy = NULL;
+
+		if(transfer_len>0 && pkt_cnt==0)
+			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
+
+	}while((transfer_len>0) && (pkt_cnt>0));
+
+_exit_recvbuf2recvframe:
+
+	return _SUCCESS;	
+}
+
+void rtl8192cu_recv_tasklet(void *priv)
+{
+	_pkt			*pskb;
+	_adapter		*padapter = (_adapter*)priv;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	
+	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue)))
+	{
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		{
+			printk("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
+			dev_kfree_skb_any(pskb);
+			break;
+		}
+	
+		recvbuf2recvframe(padapter, pskb);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+		
+#ifdef NET_SKBUFF_DATA_USES_OFFSET			
+		skb_reset_tail_pointer(pskb);
+#else
+		pskb->tail = pskb->data;
+#endif
+		pskb->len = 0;
+		
+		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+		
+#else
+		dev_kfree_skb_any(pskb);
+#endif
+				
+	}
+	
+}
+
+
+static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
+{
+	_irqL irqL;
+	uint isevt, *pbuf;
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;	
+	_adapter 			*padapter =(_adapter *)precvbuf->adapter;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;	
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
+	
+	//_enter_critical(&precvpriv->lock, &irqL);
+	//precvbuf->irp_pending=_FALSE;
+	//precvpriv->rx_pending_cnt --;
+	//_exit_critical(&precvpriv->lock, &irqL);
+		
+	precvpriv->rx_pending_cnt --;
+		
+	//if(precvpriv->rx_pending_cnt== 0)
+	//{		
+	//	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: rx_pending_cnt== 0, set allrxreturnevt!\n"));
+	//	_rtw_up_sema(&precvpriv->allrxreturnevt);	
+	//}
+
+	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+		
+	#ifdef CONFIG_PREALLOC_RECV_SKB
+		precvbuf->reuse = _TRUE;
+	#else
+		if(precvbuf->pskb){
+			printk("==> free skb(%p)\n",precvbuf->pskb);
+			dev_kfree_skb_any(precvbuf->pskb);				
+		}	
+	#endif
+	
+		goto exit;
+	}
+
+	if(purb->status==0)//SUCCESS
+	{
+		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
+			precvbuf->reuse = _TRUE;
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+		}
+		else 
+		{	
+			precvbuf->transfer_len = purb->actual_length;			
+
+			skb_put(precvbuf->pskb, purb->actual_length);	
+			skb_queue_tail(&precvpriv->rx_skb_queue, precvbuf->pskb);
+
+			if (skb_queue_len(&precvpriv->rx_skb_queue)<=1)
+				tasklet_schedule(&precvpriv->recv_tasklet);
+
+			precvbuf->pskb = NULL;
+			precvbuf->reuse = _FALSE;
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);			
+		}		
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0 \n", purb->status));
+	
+		printk("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
+
+		switch(purb->status) {
+			case -EINVAL:
+			case -EPIPE:			
+			case -ENODEV:
+			case -ESHUTDOWN:
+				//padapter->bSurpriseRemoved=_TRUE;
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
+			case -ENOENT:
+				padapter->bDriverStopped=_TRUE;			
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
+				break;
+			case -EPROTO:
+				#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM							
+				//usb_io_chk_cmd(padapter);
+				padapter->Wifi_Error_Status = USB_READ_PORT_FAIL;			
+				#endif
+				
+				precvbuf->reuse = _TRUE;
+				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);			
+				break;
+			case -EINPROGRESS:
+				printk("ERROR: URB IS IN PROGRESS!/n");
+				break;
+			default:
+				break;				
+		}
+		
+	}	
+
+exit:	
+	
+_func_exit_;
+	
+}
+
+static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{	
+	_irqL irqL;
+	int err, pipe;
+	SIZE_PTR tmpaddr=0;
+	SIZE_PTR alignment=0;
+	u32 ret = _SUCCESS;
+	PURB purb = NULL;	
+	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)pintfhdl->pintf_dev;
+	_adapter		*adapter = (_adapter *)pdvobj->padapter;
+	struct recv_priv	*precvpriv = &adapter->recvpriv;
+	struct usb_device	*pusbd = pdvobj->pusbdev;
+	
+
+_func_enter_;
+	
+	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return _FAIL;
+	}
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+	if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
+	{
+		if (NULL != (precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue)))
+		{
+			precvbuf->reuse = _TRUE;
+		}
+	}
+#endif
+	
+
+	if(precvbuf !=NULL)
+	{	
+		rtw_init_recvbuf(adapter, precvbuf);		
+
+		//re-assign for linux based on skb
+		if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
+		{
+			//precvbuf->pskb = alloc_skb(MAX_RECVBUF_SZ, GFP_ATOMIC);//don't use this after v2.6.25
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+			precvbuf->pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#else			
+			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#endif			
+			if(precvbuf->pskb == NULL)		
+			{
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("rtw_init_recvbuf(): alloc_skb fail!\n"));
+				return _FAIL;
+			}	
+
+			tmpaddr = (SIZE_PTR)precvbuf->pskb->data;
+	        	alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+	       	        skb_reserve(precvbuf->pskb, (RECVBUFF_ALIGN_SZ - alignment));			
+
+			precvbuf->phead = precvbuf->pskb->head;
+		   	precvbuf->pdata = precvbuf->pskb->data;
+
+#ifdef NET_SKBUFF_DATA_USES_OFFSET
+			precvbuf->ptail = precvbuf->pskb->head + precvbuf->pskb->tail;		
+			precvbuf->pend = precvbuf->ptail + (MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#else
+			precvbuf->ptail = precvbuf->pskb->tail;
+			precvbuf->pend = precvbuf->pskb->end;
+#endif			
+       		        precvbuf->pbuf = precvbuf->pskb->data;		
+			
+		}	
+		else//reuse skb
+		{
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			
+#ifdef NET_SKBUFF_DATA_USES_OFFSET
+			precvbuf->ptail = precvbuf->pskb->head + precvbuf->pskb->tail;		
+			precvbuf->pend = precvbuf->ptail + (MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#else
+			precvbuf->ptail = precvbuf->pskb->tail;
+			precvbuf->pend = precvbuf->pskb->end;
+#endif			
+
+       		precvbuf->pbuf = precvbuf->pskb->data;
+		
+			precvbuf->reuse = _FALSE;
+		}
+	
+		//_enter_critical(&precvpriv->lock, &irqL);
+		//precvpriv->rx_pending_cnt++;
+		//precvbuf->irp_pending = _TRUE;
+		//_exit_critical(&precvpriv->lock, &irqL);
+				
+		precvpriv->rx_pending_cnt++;
+		
+		purb = precvbuf->purb;		
+
+		//translate DMA FIFO addr to pipehandle
+		pipe = ffaddr2pipehdl(pdvobj, addr);	
+
+		usb_fill_bulk_urb(purb, pusbd, pipe, 
+						precvbuf->pbuf,
+                				MAX_RECVBUF_SZ,
+                				usb_read_port_complete,
+                				precvbuf);//context is precvbuf
+
+		err = usb_submit_urb(purb, GFP_ATOMIC);	
+		if((err) && (err != (-EPERM)))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
+			printk("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
+			ret = _FAIL;
+		}
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
+		ret = _FAIL;
+	}
+
+_func_exit_;
+	
+	return ret;	
+}
+#else
+static int recvbuf2recvframe(_adapter *padapter, struct rtw_transfer_buffer *rx_transfer_buf)
+{
+	u8	*pbuf;
+	u8	qos, shift_sz = 0;
+	u16	pkt_cnt, drvinfo_sz;
+	u32	pkt_len, pkt_offset;
+	s32	transfer_len;
+        SIZE_PTR        tmpaddr = 0;
+	SIZE_PTR	alignment = 0;
+	struct recv_stat	*prxstat;
+	_pkt	*pkt_copy = NULL;	
+	union recv_frame	*precvframe = NULL; 
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	_queue			*pfree_recv_queue = &precvpriv->free_recv_queue;
+
+
+	transfer_len = (s32)rx_transfer_buf->transfer_len;	
+	pbuf = rx_transfer_buf->transfer_buf;
+
+	prxstat = (struct recv_stat *)pbuf;	
+	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
+	
+#if 0 //temp remove when disable usb rx aggregation
+	if((pkt_cnt > 10) || (pkt_cnt < 1) || (transfer_len<RXDESC_SIZE) ||(pkt_len<=0))
+	{		
+		return _FAIL;
+	}
+#endif
+	
+	do{		
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
+			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
+
+		prxstat = (struct recv_stat *)pbuf;	   
+		pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;	
+		
+
+		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;//uint 2^3 = 8 bytes
+		drvinfo_sz = drvinfo_sz << 3;
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: DRV_INFO_SIZE=%d\n", drvinfo_sz));
+
+		pkt_offset = pkt_len + drvinfo_sz + RXDESC_SIZE;
+
+		if((pkt_len<=0) || (pkt_offset>transfer_len))
+		{	
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
+			goto _exit_recvbuf2recvframe;
+		}		
+	
+#if 0
+		shift_sz = (le32_to_cpu(prxstat->rxdw0) & 0x03000000) >> 24;
+#else
+		//shift_sz deponds on qos bit
+		qos = (le32_to_cpu(prxstat->rxdw0) & 0x00800000) >> 23;
+		//	Modified by Albert 20101213
+		//	For 8 bytes IP header alignment.
+		shift_sz = (qos==1) ? 6:0;
+#endif
+
+		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
+		if(precvframe==NULL)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
+			goto _exit_recvbuf2recvframe;
+		}
+
+		_rtw_init_listhead(&precvframe->u.hdr.list);	
+		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
+		precvframe->u.hdr.len=0;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+		pkt_copy = dev_alloc_skb((pkt_offset>1612?pkt_offset:1612) + shift_sz + 8);		
+#else			
+		pkt_copy = netdev_alloc_skb(padapter->pnetdev, (pkt_offset>1612?pkt_offset:1612) + shift_sz + 8);
+#endif		
+
+		if(pkt_copy)
+		{					
+			tmpaddr = (SIZE_PTR)pkt_copy->data;	
+			alignment = tmpaddr & (7);			
+			skb_reserve(pkt_copy, (8 - alignment));//force pkt_copy->data at 8-byte alignment address
+			
+			skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
+			
+			//pkt_copy->dev = padapter->pnetdev;
+			
+			_rtw_memcpy(pkt_copy->data, pbuf, pkt_offset);
+			precvframe->u.hdr.pkt = pkt_copy;
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
+			precvframe->u.hdr.rx_end = pkt_copy->data + (pkt_offset>1612?pkt_offset:1612);
+		}
+		else
+		{	
+			printk("recvbuf2recvframe:can not allocate memory for skb copy\n");				
+			//precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);	
+			//precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
+			//precvframe->u.hdr.rx_end = pbuf + (pkt_offset>1612?pkt_offset:1612);
+
+			precvframe->u.hdr.pkt = NULL;
+			rtw_free_recvframe(precvframe, pfree_recv_queue);
+
+			goto _exit_recvbuf2recvframe;
+		}
+
+		recvframe_put(precvframe, pkt_len + drvinfo_sz + RXDESC_SIZE);
+		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);	
+
+#if USB_RX_AGGREGATION_92C	
+		switch(pHalData->UsbRxAggMode)
+		{
+			case USB_RX_AGG_DMA:
+			case USB_RX_AGG_MIX:
+				pkt_offset = (u16)_RND128(pkt_offset);
+				break;
+				case USB_RX_AGG_USB:
+				pkt_offset = (u16)_RND4(pkt_offset);
+				break;
+			case USB_RX_AGG_DISABLE:			
+			default:				
+				break;
+		}
+#endif
+
+		//because the endian issue, driver avoid reference to the rxstat after calling update_recvframe_attrib_from_recvstat();
+		rtl8192cu_update_recvframe_attrib_from_recvstat(precvframe, prxstat);		
+		
+		if(rtw_recv_entry(precvframe) != _SUCCESS)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
+		}
+
+		pkt_cnt--;
+	
+		transfer_len -= pkt_offset;
+		pbuf += pkt_offset;	
+		precvframe = NULL;
+		pkt_copy = NULL;
+
+		if(transfer_len>0 && pkt_cnt==0)
+			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
+
+	}while((transfer_len>0) && (pkt_cnt>0));
+
+_exit_recvbuf2recvframe:
+
+	return _SUCCESS;
+	
+}
+
+void rtl8192cu_recv_tasklet(void *priv)
+{	
+	struct rtw_transfer_buffer *rx_transfer_buf=NULL;
+	_adapter	*padapter = (_adapter*)priv;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+
+	while (NULL != (rx_transfer_buf = rtw_dequeue_rx_transfer_buffer(precvpriv)))
+	{
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		{
+			printk("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
+			
+			rtw_free_transfer_buffer(rx_transfer_buf); 
+			
+			break;
+		}
+		
+
+		recvbuf2recvframe(padapter, rx_transfer_buf);
+
+		rtw_free_transfer_buffer(rx_transfer_buf); 
+
+	}	
+	
+}
+
+
+static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
+{
+	_irqL irqL;
+	uint isevt, *pbuf;
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;	
+	_adapter 			*padapter =(_adapter *)precvbuf->adapter;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+
+	struct rtw_transfer_buffer *rx_transfer_buf = precvbuf->rx_transfer_buf;
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
+	
+	precvpriv->rx_pending_cnt --;
+		
+	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+
+		rtw_free_transfer_buffer(rx_transfer_buf);              	
+	
+		goto exit;
+	}
+
+	if(purb->status==0)//SUCCESS
+	{
+		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
+
+			precvbuf->reuse = _TRUE;
+
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+		}
+		else 
+		{			
+			precvbuf->transfer_len = purb->actual_length;	
+
+			rx_transfer_buf->transfer_len = purb->actual_length;
+
+			rtw_enqueue_rx_transfer_buffer(precvpriv, rx_transfer_buf);			
+
+			tasklet_schedule(&precvpriv->recv_tasklet);
+			
+
+			precvbuf->rx_transfer_buf = NULL;
+			
+			precvbuf->reuse = _FALSE;
+			
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);			
+		}		
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0 \n", purb->status));
+	
+		printk("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
+
+		switch(purb->status) {
+			case -EINVAL:
+			case -EPIPE:			
+			case -ENODEV:
+			case -ESHUTDOWN:
+				//padapter->bSurpriseRemoved=_TRUE;
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
+			case -ENOENT:
+				padapter->bDriverStopped=_TRUE;			
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
+				break;
+			case -EPROTO:
+				precvbuf->reuse = _TRUE;
+				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);			
+				break;
+			case -EINPROGRESS:
+				printk("ERROR: URB IS IN PROGRESS!/n");
+				break;
+			default:
+				break;				
+		}
+		
+	}	
+
+exit:	
+	
+_func_exit_;
+	
+}
+static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{		
+	int err, pipe;	
+	u32 ret = _SUCCESS;
+	PURB purb = NULL;
+	struct rtw_transfer_buffer *rx_transfer_buf;
+	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)pintfhdl->pintf_dev;
+	_adapter		*adapter = (_adapter *)pdvobj->padapter;
+	struct recv_priv	*precvpriv = &adapter->recvpriv;
+	struct usb_device	*pusbd = pdvobj->pusbdev;
+
+	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return _FAIL;
+	}
+
+	if(precvbuf !=NULL)
+	{	
+		rtw_init_recvbuf(adapter, precvbuf);		
+
+		if((precvbuf->reuse == _FALSE) || (precvbuf->rx_transfer_buf == NULL))
+		{
+			rx_transfer_buf = rtw_alloc_transfer_buffer(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+
+			if(rx_transfer_buf  == NULL)
+			{
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port(): rtw_alloc_transfer_buffer fail!\n"));
+				return _FAIL;
+			}
+
+			precvbuf->rx_transfer_buf = rx_transfer_buf;
+
+			precvbuf->pbuf = rx_transfer_buf->transfer_buf;
+
+			precvbuf->pskb = NULL;
+
+		}
+		else
+		{
+			precvbuf->pskb = NULL;
+			rx_transfer_buf->transfer_len = 0;
+			precvbuf->reuse = _FALSE;
+		}
+
+		precvpriv->rx_pending_cnt++;
+		
+		purb = precvbuf->purb;		
+
+		//translate DMA FIFO addr to pipehandle
+		pipe = ffaddr2pipehdl(pdvobj, addr);	
+
+		usb_fill_bulk_urb(purb, pusbd, pipe, 
+						precvbuf->pbuf,
+                				MAX_RECVBUF_SZ,
+                				usb_read_port_complete,
+                				precvbuf);//context is precvbuf
+
+		err = usb_submit_urb(purb, GFP_ATOMIC);	
+		if((err) && (err != (-EPERM)))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
+			printk("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
+			ret = _FAIL;
+		}
+			
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
+		ret = _FAIL;
+	}
+			
+	return ret;
+	
+}
+#endif
+
+static void usb_read_port_cancel(struct intf_hdl *pintfhdl)
+{
+	int i;	
+
+	struct recv_buf *precvbuf;	
+
+	_adapter	*padapter = pintfhdl->padapter;
+	precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;	
+
+	printk("usb_read_port_cancel \n");
+
+	padapter->bReadPortCancel = _TRUE;	
+	
+	for(i=0; i < NR_RECVBUFF ; i++)	
+	{		
+		precvbuf->reuse == _TRUE;		
+		if(precvbuf->purb)		
+		{
+			//printk("usb_read_port_cancel : usb_kill_urb \n");			
+			usb_kill_urb(precvbuf->purb);		
+		}		
+
+		precvbuf++;		
+	}
+
+}
+
+void xmit_tasklet(void *priv)
+{	
+	int ret = _FALSE;
+	_adapter *padapter = (_adapter*)priv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	
+	while(1)
+	{
+		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE)||(padapter->bWritePortCancel== _TRUE))
+		{
+			printk("xmit_tasklet => bDriverStopped or bSurpriseRemoved \n");
+			break;
+		}
+
+		ret = rtw_xmitframe_complete(padapter, pxmitpriv, NULL);
+
+		if(ret==_FALSE)
+			break;
+		
+	}
+	
+}
+
+static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
+{
+	_irqL irqL;
+	int i;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)purb->context;
+	//struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
+	//_adapter			*padapter = pxmitframe->padapter;
+	_adapter	*padapter = pxmitbuf->padapter;
+       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;		
+	//struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	   
+_func_enter_;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port_complete\n"));
+	
+
+	switch(pxmitbuf->flags)
+	{
+		case XMIT_VO_QUEUE:
+			pxmitpriv->voq_cnt--;			
+			break;
+		case XMIT_VI_QUEUE:
+			pxmitpriv->viq_cnt--;		
+			break;
+		case XMIT_BE_QUEUE:
+			pxmitpriv->beq_cnt--;			
+			break;
+		case XMIT_BK_QUEUE:
+			pxmitpriv->bkq_cnt--;			
+			break;
+		default:			
+			break;
+	}
+		
+
+/*	
+	_enter_critical(&pxmitpriv->lock, &irqL);
+
+	pxmitpriv->txirp_cnt--;
+	
+	switch(pattrib->priority) 
+	{
+		case 1:				
+		case 2:
+			pxmitpriv->bkq_cnt--;
+			//printk("pxmitpriv->bkq_cnt=%d\n", pxmitpriv->bkq_cnt);
+			break;
+		case 4:
+		case 5:
+			pxmitpriv->viq_cnt--;
+			//printk("pxmitpriv->viq_cnt=%d\n", pxmitpriv->viq_cnt);
+			break;
+		case 6:
+		case 7:
+			pxmitpriv->voq_cnt--;
+			//printk("pxmitpriv->voq_cnt=%d\n", pxmitpriv->voq_cnt);
+			break;
+		case 0:
+		case 3:			
+		default:
+			pxmitpriv->beq_cnt--;
+			//printk("pxmitpriv->beq_cnt=%d\n", pxmitpriv->beq_cnt);
+			break;
+			
+	}	
+	
+	_exit_critical(&pxmitpriv->lock, &irqL);
+	
+	
+	if(pxmitpriv->txirp_cnt==0)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));		
+		_rtw_up_sema(&(pxmitpriv->tx_retevt));
+	}
+*/
+        //rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);
+
+	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+	
+	
+	if(padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		goto exit;
+	}
+
+
+	if(purb->status==0)
+	{
+	
+	}
+	else
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete : purb->status(%d) != 0 \n", purb->status));
+		printk("###=> urb_write_port_complete status(%d)\n",purb->status);
+		if((purb->status==-EPIPE)||(purb->status==-EPROTO))
+		{
+			//usb_clear_halt(pusbdev, purb->pipe);	
+			//msleep(10);
+			#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM							
+			//usb_io_chk_cmd(padapter);
+			padapter->Wifi_Error_Status = USB_WRITE_PORT_FAIL;			
+			#endif
+		}		
+		else if(purb->status == (-ESHUTDOWN))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: ESHUTDOWN\n"));
+						
+			padapter->bDriverStopped=_TRUE;
+			
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped=TRUE\n"));
+
+			goto exit;
+		}
+		else
+		{					
+			padapter->bSurpriseRemoved=_TRUE;
+			printk("bSurpriseRemoved=TRUE\n");
+			//rtl8192cu_trigger_gpio_0(padapter);
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
+
+			goto exit;
+		}		
+
+		
+
+	}
+
+	#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+	padapter->last_tx_complete_time = rtw_get_current_time();		
+	#endif
+	
+	//if(rtw_txframes_pending(padapter))	
+	//{
+		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	//}
+	
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port_complete\n"));
+
+exit:
+
+_func_exit_;	
+
+}
+
+static u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{    
+	_irqL irqL;
+	int pipe, status;
+	u32 ret, bwritezero = _FALSE;
+	PURB	purb = NULL;
+	_adapter *padapter = (_adapter *)pintfhdl->padapter;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;	
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)wmem;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	
+_func_enter_;	
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
+	
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return _FAIL;
+	}
+
+	_enter_critical(&pxmitpriv->lock, &irqL);
+
+	switch(addr)
+	{
+		case VO_QUEUE_INX:
+			pxmitpriv->voq_cnt++;
+			pxmitbuf->flags = XMIT_VO_QUEUE;
+			break;
+		case VI_QUEUE_INX:
+			pxmitpriv->viq_cnt++;
+			pxmitbuf->flags = XMIT_VI_QUEUE;
+			break;
+		case BE_QUEUE_INX:
+			pxmitpriv->beq_cnt++;
+			pxmitbuf->flags = XMIT_BE_QUEUE;
+			break;
+		case BK_QUEUE_INX:
+			pxmitpriv->bkq_cnt++;
+			pxmitbuf->flags = XMIT_BK_QUEUE;
+			break;
+		default:
+			pxmitbuf->flags = XMIT_VO_QUEUE;
+			break;
+	}
+		
+	_exit_critical(&pxmitpriv->lock, &irqL);
+		
+/*
+	_enter_critical(&pxmitpriv->lock, &irqL);
+	
+	//total irp 
+	pxmitpriv->txirp_cnt++;
+
+	//per ac irp
+	switch(pattrib->priority) 
+	{
+		case 1:				
+		case 2:				
+			pxmitpriv->bkq_cnt++;
+			break;
+		case 4:
+		case 5:
+			pxmitpriv->viq_cnt++;
+			break;
+		case 6:
+		case 7:
+			pxmitpriv->voq_cnt++;
+			break;
+		case 0:
+		case 3:			
+		default:
+			pxmitpriv->beq_cnt++;
+			break;		
+	}
+
+
+	_exit_critical(&pxmitpriv->lock, &irqL);
+*/
+
+	purb	= pxmitbuf->pxmit_urb[0];
+
+#if 0
+	if(pdvobj->ishighspeed)
+	{
+		if(cnt> 0 && cnt%512 == 0)
+		{
+			//printk("ishighspeed, cnt=%d\n", cnt);
+			bwritezero = _TRUE;			
+		}	
+	}
+	else
+	{
+		if(cnt > 0 && cnt%64 == 0)
+		{
+			//printk("cnt=%d\n", cnt);
+			bwritezero = _TRUE;			
+		}	
+	}
+#endif
+
+	//translate DMA FIFO addr to pipehandle
+	pipe = ffaddr2pipehdl(pdvobj, addr);	
+
+#ifdef CONFIG_REDUCE_USB_TX_INT	
+	if ( pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0 )
+	{
+		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
+	} else {
+		purb->transfer_flags  |=  URB_NO_INTERRUPT;
+		//printk("URB_NO_INTERRUPT ");
+	}
+#endif
+
+
+	usb_fill_bulk_urb(purb, pusbd, pipe, 
+       				pxmitframe->buf_addr,
+              			cnt,
+              			usb_write_port_complete,
+              			pxmitbuf);//context is pxmitbuf
+#if 0
+	if (bwritezero)
+        {
+            purb->transfer_flags |= URB_ZERO_PACKET;           
+        }			
+#endif
+
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+
+	if (!status)
+	{		
+		ret= _SUCCESS;
+		#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM		
+		padapter->last_tx_time = rtw_get_current_time();		
+		#endif
+	}
+	else
+	{
+		printk("usb_write_port, status=%d\n", status);
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port(): usb_submit_urb, status=%x\n", status));
+		ret= _FAIL;
+	}
+	
+//   Commented by Albert 2009/10/13
+//   We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
+/*	
+	if(bwritezero == _TRUE)
+	{
+		usb_bulkout_zero(pintfhdl, addr);
+	}
+*/
+
+_func_exit_;
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port\n"));
+	
+	return ret;
+
+}
+
+static void usb_write_port_cancel(struct intf_hdl *pintfhdl)
+{
+	int i, j;
+	_adapter	*padapter = pintfhdl->padapter;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)padapter->xmitpriv.pxmitbuf;
+
+	printk("usb_write_port_cancel \n");
+	
+	padapter->bWritePortCancel = _TRUE;	
+	
+	for(i=0; i<NR_XMITBUFF; i++)
+	{
+		for(j=0; j<8; j++)
+		{
+		        if(pxmitbuf->pxmit_urb[j])
+		        {
+		                usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+		        }
+		}
+		
+		pxmitbuf++;
+	}
+
+}
+
+
+#define GPIO_DEBUG_PORT_NUM 0
+void rtl8192cu_trigger_gpio_0(_adapter *padapter)
+{
+
+	u32 gpioctrl;
+	printk("==> trigger_gpio_0...\n");
+	write16_async(padapter,REG_GPIO_PIN_CTRL,0);
+	write8_async(padapter,REG_GPIO_PIN_CTRL+2,0xFF);
+	gpioctrl = (BIT(GPIO_DEBUG_PORT_NUM)<<24 )|(BIT(GPIO_DEBUG_PORT_NUM)<<16);
+	write32_async(padapter,REG_GPIO_PIN_CTRL,gpioctrl);
+	gpioctrl |= (BIT(GPIO_DEBUG_PORT_NUM)<<8);
+	write32_async(padapter,REG_GPIO_PIN_CTRL,gpioctrl);
+	printk("<=== trigger_gpio_0...\n");
+
+}
+
+void rtl8192cu_set_intf_ops(struct _io_ops	*pops)
+{
+	_func_enter_;
+	
+	_rtw_memset((u8 *)pops, 0, sizeof(struct _io_ops));	
+
+	pops->_read8 = &usb_read8;
+	pops->_read16 = &usb_read16;
+	pops->_read32 = &usb_read32;
+	pops->_read_mem = &usb_read_mem;
+	pops->_read_port = &usb_read_port;	
+	
+	pops->_write8 = &usb_write8;
+	pops->_write16 = &usb_write16;
+	pops->_write32 = &usb_write32;
+	pops->_writeN = &usb_writeN;
+	
+	pops->_write8_async= &usb_async_write8;
+	pops->_write16_async = &usb_async_write16;
+	pops->_write32_async = &usb_async_write32;
+	
+	pops->_write_mem = &usb_write_mem;
+	pops->_write_port = &usb_write_port;
+
+
+	pops->_read_port_cancel = &usb_read_port_cancel;
+	pops->_write_port_cancel = &usb_write_port_cancel;
+		
+	_func_exit_;
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1263 @@
+/******************************************************************************
+* usb_ops_xp.c                                                                                                                                 *
+*                                                                                                                                          *
+* Description :                                                                                                                       *
+*                                                                                                                                           *
+* Author :                                                                                                                       *
+*                                                                                                                                         *
+* History :                                                          
+*
+*                                        
+*                                                                                                                                       *
+* Copyright 2007, Realtek Corp.                                                                                                  *
+*                                                                                                                                        *
+* The contents of this file is the sole property of Realtek Corp.  It can not be                                     *
+* be used, copied or modified without written permission from Realtek Corp.                                         *
+*                                                                                                                                          *
+*******************************************************************************/
+#define _HCI_OPS_OS_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+#include <circ_buf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+	#error "Shall be Linux or Windows, but not both!\n"
+#endif
+
+#ifndef CONFIG_USB_HCI
+	#error "CONFIG_USB_HCI shall be on!\n"
+#endif
+
+
+#include <usb.h>
+#include <usbdlib.h>
+#include <usbioctl.h>
+
+#include <usb_ops.h>
+#include <recv_osdep.h>
+
+#include <usb_osintf.h>
+
+
+struct zero_bulkout_context
+{
+	void *pbuf;
+	void *purb;
+	void *pirp;
+	void *padapter;
+};
+
+#define usb_write_cmd usb_write_mem 
+#define usb_read_cmd usb_read_mem
+#define usb_write_cmd_complete usb_write_mem_complete
+//#define usb_read_cmd_complete usb_read_mem_complete
+
+
+
+uint usb_init_intf_priv(struct intf_priv *pintfpriv)
+{
+	        
+	PURB	piorw_urb;
+	u8		NextDeviceStackSize;
+	struct dvobj_priv   *pdev = (struct dvobj_priv   *)pintfpriv->intf_dev;
+	_adapter * padapter=pdev->padapter;
+
+_func_enter_;
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("\n +usb_init_intf_priv\n"));
+
+	pintfpriv->intf_status = _IOREADY;
+
+       if(pdev->ishighspeed) pintfpriv->max_iosz =  128;
+	else pintfpriv->max_iosz =  64;	
+
+
+	_init_timer(&pintfpriv->io_timer, padapter->hndis_adapter, io_irp_timeout_handler, pintfpriv);
+
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("usb_init_intf_priv:pintfpriv->max_iosz:%d\n",pintfpriv->max_iosz));
+
+	pintfpriv->io_wsz = 0;
+	pintfpriv->io_rsz = 0;	
+	
+ 	pintfpriv->allocated_io_rwmem = _rtw_zmalloc(pintfpriv->max_iosz +4); 
+	
+   	if (pintfpriv->allocated_io_rwmem == NULL){
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_init_intf_priv:pintfpriv->allocated_io_rwmem == NULL\n"));
+    		goto usb_init_intf_priv_fail;
+   	}
+
+	pintfpriv->io_rwmem = pintfpriv->allocated_io_rwmem +  4 \
+					-( (u32)(pintfpriv->allocated_io_rwmem) & 3);
+	
+
+     
+     NextDeviceStackSize = (u8)pdev->nextdevstacksz;//pintfpriv->pUsbDevObj->StackSize + 1; 
+
+      piorw_urb = (PURB)ExAllocatePool(NonPagedPool, sizeof(URB) ); 
+      if(piorw_urb == NULL) 
+	  goto usb_init_intf_priv_fail;
+	  
+      pintfpriv->piorw_urb = piorw_urb;
+
+      pintfpriv->piorw_irp = IoAllocateIrp(NextDeviceStackSize , FALSE);	 
+    
+
+      pintfpriv->io_irp_cnt=1;
+      pintfpriv->bio_irp_pending=_FALSE;
+	 
+     _rtw_init_sema(&(pintfpriv->io_retevt), 0);//NdisInitializeEvent(&pintfpriv->io_irp_return_evt);
+
+_func_exit_;
+	return _SUCCESS;
+
+usb_init_intf_priv_fail:
+
+	if (pintfpriv->allocated_io_rwmem)
+		_rtw_mfree((u8 *)(pintfpriv->allocated_io_rwmem), pintfpriv->max_iosz +4);
+	
+	if(piorw_urb)
+		ExFreePool(piorw_urb);	
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("\n -usb_init_intf_priv(usb_init_intf_priv_fail)\n"));
+
+_func_exit_;	
+	return _FAIL;
+		
+}
+
+void usb_unload_intf_priv(struct intf_priv *pintfpriv)
+{
+
+_func_enter_;
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n+usb_unload_intf_priv\n"));
+	
+	_rtw_mfree((u8 *)(pintfpriv->allocated_io_rwmem), pintfpriv->max_iosz+4);
+	
+#ifdef PLATFORM_WINDOWS
+	if(pintfpriv->piorw_urb)
+		ExFreePool(pintfpriv->piorw_urb);	
+
+	if(pintfpriv->piorw_irp)
+		IoFreeIrp(pintfpriv->piorw_irp);
+#endif		
+
+
+#ifdef PLATFORM_LINUX
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\npintfpriv->io_irp_cnt=%d\n",pintfpriv->io_irp_cnt));
+	pintfpriv->io_irp_cnt--;
+	if(pintfpriv->io_irp_cnt){
+		if(pintfpriv->bio_irp_pending==_TRUE){
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\nkill iorw_urb\n"));
+		usb_kill_urb(pintfpriv->piorw_urb);
+		}
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n wait io_retevt\n"));
+		_rtw_down_sema(&(pintfpriv->io_retevt));
+	}
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n cancel io_urb ok\n"));
+#endif
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n-usb_unload_intf_priv\n"));
+
+_func_exit_;
+	
+}
+
+void *ffaddr2pipehdl(struct dvobj_priv *pNdisCEDvice, u32 addr)
+{
+	HANDLE PipeHandle = NULL;
+	_adapter	*padapter = pNdisCEDvice->padapter;
+
+	
+	if(pNdisCEDvice->nr_endpoint == 11)
+	{		
+		switch(addr)
+		{	    
+	     		case RTL8712_DMA_BEQ:
+		 		PipeHandle= padapter->halpriv.pipehdls_r8712[3] ; 
+				break;
+	     		case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
+				break;
+	     		case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
+				break;
+	    		case RTL8712_DMA_VOQ:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;					
+                     case RTL8712_DMA_BCNQ:	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[6]; 
+				break;	 	
+			case RTL8712_DMA_BMCQ:	//HI Queue
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[7]; 
+				break;	
+			case RTL8712_DMA_MGTQ:				
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[8]; 
+				break;
+                     case RTL8712_DMA_RX0FF:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;	 	
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
+				break;
+			case RTL8712_DMA_H2CCMD:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[9]; 
+				break;	
+				
+		}
+
+	}
+	else if(pNdisCEDvice->nr_endpoint == 6)
+	{
+		switch(addr)
+		{	    
+	     		case RTL8712_DMA_BEQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
+				break;
+	     		case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
+				break;
+	     		case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
+				break;
+	    		case RTL8712_DMA_VOQ:                   		
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;
+                     case RTL8712_DMA_RX0FF:
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;
+			case RTL8712_DMA_H2CCMD:
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:			
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
+				break;	
+				
+		}
+
+	}
+	else if(pNdisCEDvice->nr_endpoint == 4)
+	{
+		switch(addr)
+		{		
+	     		case RTL8712_DMA_BEQ:
+		 	//case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
+				break;
+	     		//case RTL8712_DMA_VIQ:
+		 	case RTL8712_DMA_VOQ:					
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;
+			case RTL8712_DMA_RX0FF:
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;
+			case RTL8712_DMA_H2CCMD:	
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:				
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
+				break;	
+		}
+	
+	}
+	else
+	{
+	   RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ffaddr2pipehdl():nr_endpoint=%d error!\n", pNdisCEDvice->nr_endpoint));	   
+	}
+		
+	return PipeHandle;
+
+}
+
+
+NTSTATUS usb_bulkout_zero_complete(
+	PDEVICE_OBJECT	pUsbDevObj, 
+	PIRP		pIrp, void*	pZeroContext)
+{	
+	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)pZeroContext;
+			   
+_func_enter_;
+
+	if(pcontext)
+	{
+		if(pcontext->pbuf)
+		{
+			ExFreePool(pcontext->pbuf);	  
+		}	
+
+		if(pcontext->purb)
+		{
+			ExFreePool(pcontext->purb);	
+		}
+
+		if(pcontext->pirp && (pIrp ==pcontext->pirp))
+		{			
+			IoFreeIrp(pIrp);
+		}
+
+		ExFreePool(pcontext);	
+	}	
+
+_func_exit_;
+
+	return STATUS_MORE_PROCESSING_REQUIRED;
+	
+
+}
+
+u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
+{	
+	struct zero_bulkout_context *pcontext;
+	unsigned char *pbuf;
+	char NextDeviceStackSize, len;
+	PIO_STACK_LOCATION	nextStack;
+	USBD_STATUS		usbdstatus;
+	HANDLE				PipeHandle;	
+	PIRP					pirp = NULL;
+	PURB				purb = NULL;	
+	NDIS_STATUS			ndisStatus = NDIS_STATUS_SUCCESS;
+	_adapter *padapter = (_adapter *)pintfhdl->adapter;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;	
+
+
+_func_enter_;
+
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{		
+		return _FAIL;
+	}
+
+	len = 0;
+	NextDeviceStackSize = (char)pdvobj->nextdevstacksz;
+
+	pcontext = (struct zero_bulkout_context *)ExAllocatePool(NonPagedPool, sizeof(struct zero_bulkout_context));
+	pbuf = (unsigned char *)ExAllocatePool(NonPagedPool, sizeof(int));	
+    	purb = (PURB)ExAllocatePool(NonPagedPool, sizeof(URB));
+      	pirp = IoAllocateIrp(NextDeviceStackSize, FALSE);
+
+	pcontext->pbuf = pbuf;
+	pcontext->purb = purb;
+	pcontext->pirp = pirp;
+	pcontext->padapter = padapter;
+                    
+	//translate DMA FIFO addr to pipehandle
+	PipeHandle = ffaddr2pipehdl(pdvobj, addr);	
+
+
+	// Build our URB for USBD
+	UsbBuildInterruptOrBulkTransferRequest(
+				purb,
+				sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
+				PipeHandle,
+				pbuf, 
+				NULL, 
+				len, 
+				0, 
+				NULL);
+	
+	//
+	// call the calss driver to perform the operation
+	// pass the URB to the USB driver stack
+	//
+	nextStack = IoGetNextIrpStackLocation(pirp);
+	nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
+	nextStack->Parameters.Others.Argument1 = purb;
+	nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
+
+	//Set Completion Routine
+	IoSetCompletionRoutine(pirp,					// irp to use
+				               usb_bulkout_zero_complete,	// callback routine
+				               pcontext,				// context 
+				               TRUE,					// call on success
+				               TRUE,					// call on error
+				               TRUE);					// call on cancel
+
+	
+	// Call IoCallDriver to send the irp to the usb bus driver
+	//
+	ndisStatus = IoCallDriver(pdvobj->pnextdevobj, pirp);
+	usbdstatus = URB_STATUS(purb);
+
+	if( USBD_HALTED(usbdstatus) )
+	{		
+		padapter->bDriverStopped=_TRUE;
+		padapter->bSurpriseRemoved=_TRUE;
+	}
+
+	//
+	// The usb bus driver should always return STATUS_PENDING when bulk out irp async
+	//
+	if ( ndisStatus != STATUS_PENDING )
+	{		
+		return _FAIL;
+	} 	
+	
+_func_exit_;
+	
+	return _SUCCESS;
+
+}
+
+void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+	_func_enter_;
+	
+
+	
+	_func_exit_;
+}
+
+NTSTATUS usb_write_mem_complete(PDEVICE_OBJECT	pUsbDevObj, PIRP piowrite_irp, PVOID pusb_cnxt)
+{
+		
+	_irqL irqL;
+	_list	*head, *plist;
+	struct io_req	*pio_req;	
+	struct io_queue *pio_q = (struct io_queue *) pusb_cnxt;
+	struct intf_hdl *pintf = &(pio_q->intf);	
+	struct intf_priv *pintfpriv = pintf->pintfpriv;	
+	_adapter *padapter = (_adapter *)pintf->adapter;
+	NTSTATUS status = STATUS_SUCCESS;
+
+	head = &(pio_q->processing);
+	
+	_func_enter_;
+	
+	_enter_critical_bh(&(pio_q->lock), &irqL);
+	
+	pintfpriv->io_irp_cnt--;
+	if(pintfpriv->io_irp_cnt ==0){		
+		_rtw_up_sema(&(pintfpriv->io_retevt));
+	}	
+	
+	pintfpriv->bio_irp_pending=_FALSE;
+	
+	switch(piowrite_irp->IoStatus.Status)
+	{		
+		case STATUS_SUCCESS:
+			break;
+			
+		default:
+			padapter->bSurpriseRemoved=_TRUE;
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usbAsynIntOutComplete:pioread_irp->IoStatus.Status !=STATUS_SUCCESS\n"));
+			break;
+	}				
+
+	//free irp in processing list...	
+	while(rtw_is_list_empty(head) != _TRUE)
+	{
+		plist = get_next(head);	
+		list_delete(plist);
+		pio_req = LIST_CONTAINOR(plist, struct io_req, list);
+		_rtw_up_sema(&pio_req->sema);
+	}	
+						
+	_exit_critical_bh(&(pio_q->lock), &irqL);
+
+	_func_exit_;
+	
+	return STATUS_MORE_PROCESSING_REQUIRED;
+
+}
+
+void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	u32 bwritezero;
+	_irqL	irqL;
+	USBD_STATUS			usbdstatus;		
+	PIO_STACK_LOCATION		nextStack;
+	HANDLE				PipeHandle;	
+	struct io_req *pio_req;
+	
+	_adapter *adapter = (_adapter *)pintfhdl->adapter;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	struct dvobj_priv   *pdev = (struct dvobj_priv   *)pintfpriv->intf_dev;      
+	PURB	piorw_urb = pintfpriv->piorw_urb;
+	PIRP		piorw_irp  = pintfpriv->piorw_irp; 	
+	struct io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;	
+	NTSTATUS NtStatus = STATUS_SUCCESS;	
+	
+	_func_enter_;	
+
+	pio_req = alloc_ioreq(pio_queue);
+	
+	if ((pio_req == NULL)||(adapter->bSurpriseRemoved)){
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("async_irp_write32 : pio_req =0x%x adapter->bSurpriseRemoved=0x%x",pio_req,adapter->bSurpriseRemoved ));
+		goto exit;
+	}	
+	
+	_enter_critical_bh(&(pio_queue->lock), &irqL);
+	
+	rtw_list_insert_tail(&(pio_req->list),&(pio_queue->processing));
+
+
+#ifdef NDIS51_MINIPORT
+	IoReuseIrp(piorw_irp, STATUS_SUCCESS);
+#else
+	piorw_irp->Cancel = _FALSE;
+#endif
+
+	if((adapter->bDriverStopped) || (adapter->bSurpriseRemoved) ||(adapter->pwrctrlpriv.pnp_bstop_trx))	
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\npadapter->pwrctrlpriv.pnp_bstop_trx==_TRUE\n"));
+		_func_exit_;
+		return;
+	}
+
+	//translate DMA FIFO addr to pipehandle
+	PipeHandle = ffaddr2pipehdl(pdev, addr);	
+
+	
+	pintfpriv->io_irp_cnt++;
+	pintfpriv->bio_irp_pending=_TRUE;	
+	// Build our URB for USBD
+	UsbBuildInterruptOrBulkTransferRequest(
+				piorw_urb,
+				sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
+				PipeHandle,
+				(PVOID)wmem,
+				NULL, 
+				cnt, 
+				0, 
+				NULL);  
+
+	//
+	// call the calss driver to perform the operation
+	// pass the URB to the USB driver stack
+	//
+	nextStack = IoGetNextIrpStackLocation(piorw_irp);
+	nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
+	nextStack->Parameters.Others.Argument1 = (PURB)piorw_urb;
+	nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
+
+	IoSetCompletionRoutine(
+				piorw_irp,				// irp to use				
+				usb_write_mem_complete,		// routine to call when irp is done
+				pio_queue,				// context to pass routine
+				TRUE,					// call on success
+				TRUE,					// call on error
+				TRUE);					// call on cancel
+	
+	// 
+	// Call IoCallDriver to send the irp to the usb port
+	//
+	NtStatus	= IoCallDriver(pdev->pnextdevobj, piorw_irp);
+	usbdstatus = URB_STATUS(piorw_urb);
+
+	//
+	// The USB driver should always return STATUS_PENDING when
+	// it receives a write irp
+	//
+	if ((NtStatus != STATUS_PENDING) || USBD_HALTED(usbdstatus) ) {
+
+		if( USBD_HALTED(usbdstatus) ) {
+
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_mem():USBD_HALTED(usbdstatus)=%X!\n",USBD_HALTED(usbdstatus)) );
+		}
+		_func_exit_;
+		return;//STATUS_UNSUCCESSFUL;
+	}
+
+	_exit_critical_bh(&(pio_queue->lock), &irqL);
+	
+	_rtw_down_sema(&pio_req->sema);	
+	free_ioreq(pio_req, pio_queue);
+	
+
+	bwritezero = _FALSE;
+       if (pdev->ishighspeed)
+	{
+		if(cnt> 0 && cnt%512 == 0)
+			bwritezero = _TRUE;
+			
+	}
+	else
+	{
+		if(cnt > 0 && cnt%64 == 0)
+			bwritezero = _TRUE;		
+	}
+
+	
+	if(bwritezero == _TRUE)
+	{
+		usb_bulkout_zero(pintfhdl, addr);
+	}
+	
+exit:
+	
+	_func_exit_;
+	
+}
+
+NTSTATUS usb_read_port_complete(PDEVICE_OBJECT pUsbDevObj, PIRP pIrp, PVOID context)
+{	
+	uint isevt, *pbuf;
+	struct _URB_BULK_OR_INTERRUPT_TRANSFER	*pbulkurb;
+	USBD_STATUS		usbdstatus;	
+	struct recv_buf		*precvbuf = (struct recv_buf *)context;	
+	_adapter 				*adapter =(_adapter *)precvbuf->adapter;
+	struct recv_priv		*precvpriv = &adapter->recvpriv;
+	struct dvobj_priv   	*dev = (struct dvobj_priv   *)&adapter->dvobjpriv;
+	PURB				purb = precvbuf->purb;
+	struct intf_hdl 		*pintfhdl = &adapter->pio_queue->intf;
+	
+	//RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
+
+	usbdstatus = URB_STATUS(purb);
+	
+	_rtw_spinlock_ex(&precvpriv->lock);
+	precvbuf->irp_pending=_FALSE;
+	precvpriv->rx_pending_cnt --;
+	_rtw_spinunlock_ex(&precvpriv->lock);	
+	
+	if(precvpriv->rx_pending_cnt== 0) {		
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: rx_pending_cnt== 0, set allrxreturnevt!\n"));
+		_rtw_up_sema(&precvpriv->allrxreturnevt);	
+	}
+
+
+	if( pIrp->Cancel == _TRUE ) {
+		
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: One IRP has been cancelled succesfully\n"));
+		return STATUS_MORE_PROCESSING_REQUIRED;
+	}
+	if(adapter->bSurpriseRemoved) {
+
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
+		return STATUS_MORE_PROCESSING_REQUIRED;
+	}
+
+	switch(pIrp->IoStatus.Status) 
+	{
+		case STATUS_SUCCESS:
+			
+			pbulkurb = &(precvbuf->purb)->UrbBulkOrInterruptTransfer;
+			if((pbulkurb->TransferBufferLength >(MAX_RECVBUF_SZ)) || (pbulkurb->TransferBufferLength < RXDESC_SIZE) ) 
+			{								
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port_complete: (pbulkurb->TransferBufferLength > MAX_RECVBUF_SZ) || (pbulkurb->TransferBufferLength < RXDESC_SIZE)\n"));
+				rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+			}
+			else 
+			{	
+			       precvbuf->transfer_len = pbulkurb->TransferBufferLength;
+
+				pbuf = (uint*)precvbuf->pbuf;
+
+				if((isevt = *(pbuf+1)&0x1ff) == 0x1ff)
+				{								
+					rxcmd_event_hdl(adapter, pbuf);//rx c2h events
+					
+					rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+				}
+				else
+				{
+					if(recvbuf2recvframe(adapter, precvbuf)==_FAIL)//rx packets
+					{
+						//precvbuf->reuse = _TRUE;		
+						rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+					}
+				}
+				
+			}
+	
+			break;
+			
+		default:
+			
+			if( !USBD_HALTED(usbdstatus) )
+			{				
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port_complete():USBD_HALTED(usbdstatus)=%x  (need to handle ) \n",USBD_HALTED(usbdstatus)));				
+			
+			}
+			else 
+			{				
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port_complete(): USBD_HALTED(usbdstatus)=%x \n\n", USBD_HALTED(usbdstatus)) );
+				adapter->bDriverStopped = _TRUE;
+				adapter->bSurpriseRemoved = _TRUE;
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete(): USBD_HALTED(usbdstatus)=%x \n\n", USBD_HALTED(usbdstatus))) ;
+			}
+
+		      break;
+			  
+	}
+
+	return STATUS_MORE_PROCESSING_REQUIRED;
+	
+}
+
+u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+	u8 					*pdata;
+	u16					size;
+	PURB				purb;
+	PIRP					pirp;
+	PIO_STACK_LOCATION	nextStack;
+	NTSTATUS			ntstatus;
+	USBD_STATUS		usbdstatus;
+	HANDLE				PipeHandle;	
+	struct recv_buf		*precvbuf = (struct recv_buf *)rmem;
+	struct intf_priv		*pintfpriv = pintfhdl->pintfpriv;
+	struct dvobj_priv		*pdev = (struct dvobj_priv   *)pintfpriv->intf_dev;
+	_adapter				*adapter = (_adapter *)pdev->padapter;
+	struct recv_priv		*precvpriv = &adapter->recvpriv;
+	u32					bResult = _FALSE;
+
+_func_enter_;
+	
+	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx) {
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return bResult;
+	}
+
+	if(precvbuf !=NULL)
+	{
+
+		rtw_init_recvbuf(adapter, precvbuf);
+	
+		_rtw_spinlock(&precvpriv->lock);
+		precvpriv->rx_pending_cnt++;
+		precvbuf->irp_pending = _TRUE;
+		_rtw_spinunlock(&precvpriv->lock);
+
+	       pdata = (u8*)precvbuf->pbuf;
+
+		size	 = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
+		purb = precvbuf->purb;	
+
+		//translate DMA FIFO addr to pipehandle
+		PipeHandle = ffaddr2pipehdl(pdev, addr);	
+		 
+		UsbBuildInterruptOrBulkTransferRequest(
+			purb,
+			(USHORT)size,
+			PipeHandle,
+			pdata,
+			NULL, 
+			MAX_RECVBUF_SZ,
+			USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK, 
+			NULL
+			);
+
+		pirp = precvbuf->pirp;
+
+#if NDIS51_MINIPORT
+		IoReuseIrp(pirp, STATUS_SUCCESS);
+#else
+		pirp->Cancel = _FALSE;
+#endif
+
+		// call the class driver to perform the operation
+		// and pass the URB to the USB driver stack
+		nextStack = IoGetNextIrpStackLocation(pirp);
+		nextStack->Parameters.Others.Argument1 = purb;
+		nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
+		nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
+
+		IoSetCompletionRoutine(
+			pirp,					// irp to use
+			usb_read_port_complete,	// routine to call when irp is done
+			precvbuf,					// context to pass routine 
+			TRUE,					// call on success
+			TRUE,					// call on error
+			TRUE);					// call on cancel
+
+		//
+		// The IoCallDriver routine  
+		// sends an IRP to the driver associated with a specified device object.
+		//
+		ntstatus = IoCallDriver(pdev->pnextdevobj, pirp);
+		usbdstatus = URB_STATUS(purb);
+
+		if( USBD_HALTED(usbdstatus) ) {
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port(): USBD_HALTED(usbdstatus=0x%.8x)=%.8x  \n\n", usbdstatus, USBD_HALTED(usbdstatus)));
+			pdev->padapter->bDriverStopped=_TRUE;
+			pdev->padapter->bSurpriseRemoved=_TRUE;
+		}
+
+		if( ntstatus == STATUS_PENDING )
+		{ 
+			bResult = _TRUE;// The IRP is pended in USBD as we expected.
+		}
+		else {
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port(): IoCallDriver failed!!! IRP STATUS: %X\n", ntstatus));
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port(): IoCallDriver failed!!! USB STATUS: %X\n", usbdstatus));
+		}
+
+	}
+	else{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precv_frame ==NULL\n"));
+	}
+
+_func_exit_;
+	
+	return bResult;
+	
+}
+
+void usb_read_port_cancel(_adapter *padapter)
+{	
+	struct recv_buf  *precvbuf;
+	sint i;
+	struct dvobj_priv   *pdev = &padapter->dvobjpriv;
+	struct recv_priv *precvpriv=&padapter->recvpriv;	
+		
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n ==>usb_read_port_cancel\n"));
+
+	_rtw_spinlock(&precvpriv->lock);
+	precvpriv->rx_pending_cnt--; //decrease 1 for Initialize ++ 
+	_rtw_spinunlock(&precvpriv->lock);
+
+	if (precvpriv->rx_pending_cnt)
+	{
+		// Canceling Pending Recv Irp
+		precvbuf = (struct recv_buf  *)precvpriv->precv_buf;
+		
+		for( i = 0; i < NR_RECVBUFF; i++ )
+		{
+			if (precvbuf->irp_pending == _TRUE)
+			{	
+				IoCancelIrp(precvbuf->pirp);
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_cancel() :IoCancelIrp\n"));
+			}
+			
+			precvbuf++;
+		}
+		
+		_rtw_down_sema(&precvpriv->allrxreturnevt);
+		
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_cancel:down sema\n"));
+
+	}
+	
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("<==usb_read_port_cancel\n"));
+	
+}
+
+NTSTATUS usb_write_port_complete(
+	PDEVICE_OBJECT	pUsbDevObj,
+	PIRP				pIrp,
+	PVOID			pTxContext
+) 
+{	
+	u32	i, bIrpSuccess, sz;
+	NTSTATUS	status = STATUS_SUCCESS;
+	u8 *ptr;
+	struct xmit_frame	*pxmitframe = (struct xmit_frame *) pTxContext;
+        struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	_adapter			*padapter = pxmitframe->padapter;
+	struct dvobj_priv	*pdev =	(struct dvobj_priv *)&padapter->dvobjpriv;	
+	struct io_queue	*pio_queue = (struct io_queue *)padapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &(pio_queue->intf);
+       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;		
+	   
+_func_enter_;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port_complete\n"));
+
+	_rtw_spinlock_ex(&pxmitpriv->lock);	
+	pxmitpriv->txirp_cnt--;
+	_rtw_spinunlock_ex(&pxmitpriv->lock);
+	
+	if(pxmitpriv->txirp_cnt==0){
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));		
+		_rtw_up_sema(&(pxmitpriv->tx_retevt));
+	}
+	
+	status = pIrp->IoStatus.Status;
+
+	if( status == STATUS_SUCCESS ) 
+		bIrpSuccess = _TRUE;	
+	else	
+		bIrpSuccess = _FALSE;
+	
+	if( pIrp->Cancel == _TRUE )
+	{		
+	    if(pxmitframe !=NULL)
+	    {	       
+	    		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port_complete:pIrp->Cancel == _TRUE,(pxmitframe !=NULL\n"));
+			rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);			
+	    }
+		  	 
+	     return STATUS_MORE_PROCESSING_REQUIRED;
+	}
+
+	if(padapter->bSurpriseRemoved)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		return STATUS_MORE_PROCESSING_REQUIRED;
+	}
+
+
+	//
+	// Send 0-byte here if necessary.
+	//
+	// <Note> 
+	// 1. We MUST keep at most one IRP pending in each endpoint, otherwise USB host controler driver will hang.
+	// Besides, even 0-byte IRP shall be count into #IRP sent down, so, we send 0-byte here instead of TxFillDescriptor8187().
+	// 2. If we don't count 0-byte IRP into an #IRP sent down, Tx will stuck when we download files via BT and 
+	// play online video on XP SP1 EHCU.
+	// 2005.12.26, by rcnjko.
+	//
+
+	
+	for(i=0; i< 8; i++)
+	{
+            if(pIrp == pxmitframe->pxmit_irp[i])
+            {
+		    pxmitframe->bpending[i] = _FALSE;//
+		    //ac_tag = pxmitframe->ac_tag[i];
+                  sz = pxmitframe->sz[i];
+		    break;		  
+            }
+	}
+
+#if 0	
+	pxmitframe->fragcnt--;
+	if(pxmitframe->fragcnt == 0)// if((pxmitframe->fragcnt == 0) && (pxmitframe->irpcnt == 8)){
+	{
+		//RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port_complete:pxmitframe->fragcnt == 0\n"));
+		rtw_free_xmitframe(pxmitpriv,pxmitframe);	          
+      	}
+#else	
+
+	//not to consider tx fragment
+	rtw_free_xmitframe_ex(pxmitpriv, pxmitframe);		
+
+#endif	
+
+	rtw_xmitframe_complete(padapter, pxmitpriv, pxmitbuf);
+
+_func_exit_;
+
+	return STATUS_MORE_PROCESSING_REQUIRED;
+
+}
+
+u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+       u32 i, bwritezero;      	
+	u8 *ptr;
+	PIO_STACK_LOCATION	nextStack;
+	USBD_STATUS		usbdstatus;
+	HANDLE				PipeHandle;	
+	PIRP					pirp = NULL;
+	PURB				purb = NULL;	
+	NDIS_STATUS			ndisStatus = NDIS_STATUS_SUCCESS;
+	_adapter *padapter = (_adapter *)pintfhdl->adapter;
+	struct dvobj_priv	*pNdisCEDvice = (struct dvobj_priv   *)&padapter->dvobjpriv;	
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)wmem;
+
+_func_enter_;
+
+	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return _FAIL;
+	}
+	
+
+	for(i=0; i<8; i++)
+       {
+		if(pxmitframe->bpending[i] == _FALSE)
+		{
+			_rtw_spinlock(&pxmitpriv->lock);	
+			pxmitpriv->txirp_cnt++;
+			pxmitframe->bpending[i]  = _TRUE;
+			_rtw_spinunlock(&pxmitpriv->lock);
+			
+			pxmitframe->sz[i] = cnt;
+			purb	= pxmitframe->pxmit_urb[i];
+			pirp	= pxmitframe->pxmit_irp[i];
+			
+			//pxmitframe->ac_tag[i] = ac_tag;
+			
+			break;	 
+		}
+       }	
+
+	bwritezero = _FALSE;
+       if (pNdisCEDvice->ishighspeed)
+	{
+		if(cnt> 0 && cnt%512 == 0)
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ishighspeed, cnt=%d\n", cnt));
+			//cnt=cnt+1;
+			bwritezero = _TRUE;
+		}	
+	}
+	else
+	{
+		if(cnt > 0 && cnt%64 == 0)
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cnt=%d\n", cnt));
+			//cnt=cnt+1;
+			bwritezero = _TRUE;
+		}	
+	}
+	
+
+#ifdef NDIS51_MINIPORT
+	IoReuseIrp(pirp, STATUS_SUCCESS);
+#else
+	pirp->Cancel = _FALSE;
+#endif
+
+
+	//translate DMA FIFO addr to pipehandle
+	PipeHandle = ffaddr2pipehdl(pNdisCEDvice, addr);	
+
+
+	// Build our URB for USBD
+	UsbBuildInterruptOrBulkTransferRequest(
+				purb,
+				sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
+				PipeHandle,
+				pxmitframe->mem_addr, 
+				NULL, 
+				cnt, 
+				0, 
+				NULL);
+	
+	//
+	// call the calss driver to perform the operation
+	// pass the URB to the USB driver stack
+	//
+	nextStack = IoGetNextIrpStackLocation(pirp);
+	nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
+	nextStack->Parameters.Others.Argument1 = purb;
+	nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
+
+	//Set Completion Routine
+	IoSetCompletionRoutine(pirp,					// irp to use
+				               usb_write_port_complete,	// callback routine
+				               pxmitframe,				// context 
+				               TRUE,					// call on success
+				               TRUE,					// call on error
+				               TRUE);					// call on cancel
+
+	
+	// Call IoCallDriver to send the irp to the usb bus driver
+	//
+	ndisStatus = IoCallDriver(pNdisCEDvice->pnextdevobj, pirp);
+	usbdstatus = URB_STATUS(purb);
+
+	if( USBD_HALTED(usbdstatus) )
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port(): USBD_HALTED(usbdstatus)=%x set bDriverStopped TRUE!\n\n",USBD_HALTED(usbdstatus)) );
+		padapter->bDriverStopped=_TRUE;
+		padapter->bSurpriseRemoved=_TRUE;
+	}
+
+	//
+	// The usb bus driver should always return STATUS_PENDING when bulk out irp async
+	//
+	if ( ndisStatus != STATUS_PENDING )
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port(): ndisStatus(%x) != STATUS_PENDING!\n\n", ndisStatus));
+		
+		_func_exit_;
+		
+		return _FAIL;
+	} 	
+	
+	if(bwritezero == _TRUE)
+	{
+		usb_bulkout_zero(pintfhdl, addr);
+	}
+
+	
+_func_exit_;
+	
+	return _SUCCESS;
+
+}
+
+
+void usb_write_port_cancel(_adapter *padapter)
+{
+
+	sint i,j;
+	struct dvobj_priv   *pdev = &padapter->dvobjpriv;
+	struct xmit_priv *pxmitpriv=&padapter->xmitpriv;
+	struct xmit_frame *pxmitframe;
+
+	_rtw_spinlock(&pxmitpriv->lock);
+	pxmitpriv->txirp_cnt--; //decrease 1 for Initialize ++
+	_rtw_spinunlock(&pxmitpriv->lock);
+	
+	if (pxmitpriv->txirp_cnt) 
+	{
+		// Canceling Pending Recv Irp
+		pxmitframe= (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
+		
+		for( i = 0; i < NR_XMITFRAME; i++ )
+		{
+			for(j=0;j<8;j++)
+			{
+				if (pxmitframe->bpending[j]==_TRUE)
+				{			
+					IoCancelIrp(pxmitframe->pxmit_irp[j]);		
+					RT_TRACE(_module_hci_ops_os_c_,_drv_err_,(" usb_write_port_cancel() :IoCancelIrp\n"));
+
+				}
+			}
+			
+			pxmitframe++;
+		}
+
+		_rtw_down_sema(&(pxmitpriv->tx_retevt));
+		
+	}
+
+}
+
+
+/*! \brief Wrap the pUrb to an IRP and send this IRP to Bus Driver. Then wait for this IRP completion.
+	The Caller shall be at Passive Level.
+*/
+NTSTATUS  sync_callusbd(struct dvobj_priv *pdvobjpriv, PURB purb)
+{
+
+	KEVENT					kevent;
+	PIRP						irp;
+	IO_STATUS_BLOCK		iostatusblock;
+	PIO_STACK_LOCATION		nextstack;
+	USBD_STATUS			usbdstatus;
+	LARGE_INTEGER			waittime;
+	NTSTATUS ntstatus = STATUS_SUCCESS;
+	_adapter *padapter = pdvobjpriv->padapter;
+	
+
+	_func_enter_;
+
+//	if(padapter->bDriverStopped) {
+//		goto exit;
+//	}
+	
+	KeInitializeEvent(&kevent, NotificationEvent, _FALSE);
+	irp = IoBuildDeviceIoControlRequest(
+			IOCTL_INTERNAL_USB_SUBMIT_URB,
+			pdvobjpriv->pphysdevobj,//CEdevice->pUsbDevObj, 
+			NULL, 
+			0, 
+			NULL, 
+			0, 
+			_TRUE, 
+			&kevent, 
+			&iostatusblock);
+
+	if(irp == NULL) {
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("SyncCallUSBD: memory alloc for irp failed\n"));
+		ntstatus=STATUS_INSUFFICIENT_RESOURCES;
+		goto exit;
+	}
+	
+	nextstack = IoGetNextIrpStackLocation(irp);
+	if(nextstack == NULL)	
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("IoGetNextIrpStackLocation fail\n"));
+
+	nextstack->Parameters.Others.Argument1 = purb;
+	
+	// Issue an IRP for Sync IO.
+	ntstatus = IoCallDriver(pdvobjpriv->pphysdevobj, irp);
+	usbdstatus = URB_STATUS(purb);
+
+	if(ntstatus == STATUS_PENDING)
+	{		
+		// Method 1
+		waittime.QuadPart = -10000 * 50000;
+		ntstatus = KeWaitForSingleObject(&kevent, Executive, KernelMode, _FALSE, &waittime); //8150 code
+		
+		// Method 2
+		//ntStatus = KeWaitForSingleObject(&Kevent, Executive, KernelMode, FALSE, NULL); //DDK sample
+		
+		usbdstatus = URB_STATUS(purb);
+
+		if(ntstatus == STATUS_TIMEOUT) 
+		{			
+			//usbdevice->nIoStuckCnt++;
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("SyncCallUSBD: TIMEOUT....5000ms\n"));
+
+			// Method 2
+			IoCancelIrp(irp);
+			ntstatus = KeWaitForSingleObject(&kevent, Executive, KernelMode, _FALSE, NULL); //DDK sample
+			usbdstatus = URB_STATUS(purb);
+
+			usbdstatus = USBD_STATUS_SUCCESS;
+		}
+		
+	}
+	
+exit:	
+	
+	_func_exit_;
+	
+	return ntstatus;
+	
+}
+int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	PURB			purb;
+	u8				ret;
+	unsigned long		transferflags;
+	NTSTATUS		ntstatus;
+
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfpriv->intf_dev;   
+	
+	_func_enter_;
+
+	ret=_TRUE;
+	purb = (PURB)ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST) );
+	if(purb == NULL) {
+		
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq(): Failed to allocate urb !!!\n"));
+		ret =_FALSE;
+		goto exit;
+	}
+
+	if (requesttype == 0x01) {
+		transferflags = USBD_TRANSFER_DIRECTION_IN;//read_in
+	} else {
+		transferflags= 0;//write_out
+	}
+
+	UsbBuildVendorRequest(
+			purb, 		//Pointer to an URB that is to be formatted as a vendor or class request. 
+			URB_FUNCTION_VENDOR_DEVICE,	//Indicates the URB is a vendor-defined request for a USB device. 
+			sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),  //Specifies the length, in bytes, of the URB. 
+			transferflags, 	//TransferFlags 
+			0,			//ReservedBits 
+			request, 	//Request 
+			value, 		//Value 
+			index,		//Index
+			pdata,		//TransferBuffer 
+			NULL,		//TransferBufferMDL 
+			len,			//TransferBufferLength 
+			NULL		//Link 
+	);
+
+	ntstatus = sync_callusbd(pdvobjpriv, purb);
+	if(!NT_SUCCESS(ntstatus))
+	{
+		ExFreePool(purb);
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,(" usbctrl_vendorreq() : SOMETHING WRONG\n") );
+		ret = _FALSE;
+		goto exit;
+	}
+
+	ExFreePool(purb);
+
+exit:	
+	_func_exit_;
+	
+	return ret;	
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c_d_hal_init.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c_d_hal_init.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/hal/rtl8192c_d_hal_init.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/hal/rtl8192c_d_hal_init.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1660 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#define _RTL8192C_D_HAL_INIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_byteorder.h>
+
+#include <hal_init.h>
+#include <rtl8712_efuse.h>
+
+#ifdef CONFIG_SDIO_HCI
+			#include <sdio_hal.h>
+#ifdef PLATFORM_LINUX
+	#include <linux/mmc/sdio_func.h>
+#endif
+#elif defined(CONFIG_USB_HCI)
+			#include <usb_hal.h>
+#endif	
+
+
+static VOID
+_FWDownloadEnable(
+	IN	PADAPTER		Adapter,
+	IN	BOOLEAN			enable
+	)
+{
+	u8	tmp;
+	if(enable)
+	{
+		// 8051 with wrapper enable
+		tmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
+		rtw_write8(Adapter, REG_SYS_FUNC_EN+1, tmp|0x04);
+
+		// MCU firmware download enable.
+		tmp = rtw_read8(Adapter, REG_MCUFWDL);
+		rtw_write8(Adapter, REG_MCUFWDL, tmp|0x01);
+
+		// 8051 enable
+		tmp = rtw_read8(Adapter, REG_MCUFWDL+2);
+		rtw_write8(Adapter, REG_MCUFWDL+2, tmp&0xf7);
+	}
+	else
+	{
+		// MCU firmware download enable.
+		tmp = rtw_read8(Adapter, REG_MCUFWDL);
+		rtw_write8(Adapter, REG_MCUFWDL, tmp&0xfe);
+
+		// Reserved for fw extension.
+		rtw_write8(Adapter, REG_MCUFWDL+1, 0x00);
+	}
+
+}
+
+
+#define MAX_REG_BOLCK_SIZE	196
+#define MIN_REG_BOLCK_SIZE	4
+
+
+static VOID
+_BlockWrite(
+	IN		PADAPTER		Adapter,
+	IN		PVOID		buffer,
+	IN		u32			size
+	)
+{
+ #if 1
+  
+#ifdef SUPPORTED_BLOCK_IO
+	u32			blockSize		= MAX_REG_BOLCK_SIZE;	// Use 196-byte write to download FW	
+	u32			blockSize2  	= MIN_REG_BOLCK_SIZE;	
+#else
+	u32			blockSize		= sizeof(u32);	// Use 4-byte write to download FW
+	u32*			pu4BytePtr	= (u32*)buffer;
+	u32			blockSize2  	= sizeof(u8);
+#endif
+	u8*			bufferPtr	= (u8*)buffer;
+	u32			i, offset, offset2, blockCount, remainSize, remainSize2;
+
+	blockCount = size / blockSize;
+	remainSize = size % blockSize;
+
+	for(i = 0 ; i < blockCount ; i++){
+		offset = i * blockSize;
+		#ifdef SUPPORTED_BLOCK_IO
+		writeN(Adapter, (FW_8192C_START_ADDRESS + offset), blockSize, (bufferPtr + offset));
+		#else
+		rtw_write32(Adapter, (FW_8192C_START_ADDRESS + offset), le32_to_cpu(*(pu4BytePtr + i)));
+		#endif
+	}
+
+	if(remainSize){
+		offset2 = blockCount * blockSize;		
+		blockCount = remainSize / blockSize2;
+		remainSize2 = remainSize % blockSize2;
+
+		for(i = 0 ; i < blockCount ; i++){
+			offset = offset2 + i * blockSize2;
+			#ifdef SUPPORTED_BLOCK_IO
+			writeN(Adapter, (FW_8192C_START_ADDRESS + offset), blockSize2, (bufferPtr + offset));
+			#else
+			rtw_write8(Adapter, (FW_8192C_START_ADDRESS + offset ), *(bufferPtr + offset));
+			#endif
+		}		
+
+		if(remainSize2)
+		{
+			offset += blockSize2;
+			bufferPtr += offset;
+			
+			for(i = 0 ; i < remainSize2 ; i++){
+				rtw_write8(Adapter, (FW_8192C_START_ADDRESS + offset + i), *(bufferPtr + i));
+			}
+		}
+	}
+
+#else
+	u32			blockSize	= sizeof(u32);	// Use 4-byte write to download FW
+	u8*			bufferPtr	= (u8*)buffer;
+	u32*			pu4BytePtr	= (u32*)buffer;
+	u32			i, offset, blockCount, remainSize;
+
+	blockCount = size / blockSize;
+	remainSize = size % blockSize;
+
+	for(i = 0 ; i < blockCount ; i++){
+		offset = i * blockSize;
+		rtw_write32(Adapter, (FW_8192C_START_ADDRESS + offset), le32_to_cpu(*(pu4BytePtr + i)));
+	}
+
+	if(remainSize){
+		offset = blockCount * blockSize;
+		bufferPtr += offset;
+		
+		for(i = 0 ; i < remainSize ; i++){
+			rtw_write8(Adapter, (FW_8192C_START_ADDRESS + offset + i), *(bufferPtr + i));
+		}
+	}
+#endif
+}
+
+static VOID
+_PageWrite(
+	IN		PADAPTER		Adapter,
+	IN		u32			page,
+	IN		PVOID			buffer,
+	IN		u32			size
+	)
+{
+	u8 value8;
+	u8 u8Page = (u8) (page & 0x07) ;
+
+	value8 = rtw_read8(Adapter, REG_MCUFWDL+2);
+	//printk("%s,REG_%02x(0x%02x),wvalue(0x%02x)\n",__FUNCTION__,(REG_MCUFWDL+2),value8,(value8 & 0xF8) |u8Page);
+
+	value8 = (value8 & 0xF8) |u8Page;
+	 
+	rtw_write8(Adapter, REG_MCUFWDL+2,value8);
+	_BlockWrite(Adapter,buffer,size);
+}
+
+static VOID
+_WriteFW(
+	IN		PADAPTER		Adapter,
+	IN		PVOID			buffer,
+	IN		u32			size
+	)
+{
+	// Since we need dynamic decide method of dwonload fw, so we call this function to get chip version.
+	// We can remove _ReadChipVersion from ReadAdapterInfo8192C later.
+
+	BOOLEAN			isNormalChip;	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	
+	isNormalChip = IS_NORMAL_CHIP(pHalData->VersionID);
+
+	if(isNormalChip){
+		u32 	pageNums,remainSize ;
+		u32 	page,offset;
+		u8*	bufferPtr = (u8*)buffer;
+		
+		pageNums = size / MAX_PAGE_SIZE ;		
+		//RT_ASSERT((pageNums <= 4), ("Page numbers should not greater then 4 \n"));			
+		remainSize = size % MAX_PAGE_SIZE;		
+		
+		for(page = 0; page < pageNums;  page++){
+			offset = page *MAX_PAGE_SIZE;
+			_PageWrite(Adapter,page, (bufferPtr+offset),MAX_PAGE_SIZE);			
+		}
+		if(remainSize){
+			offset = pageNums *MAX_PAGE_SIZE;
+			page = pageNums;
+			_PageWrite(Adapter,page, (bufferPtr+offset),remainSize);
+		}	
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("_WriteFW Done- for Normal chip.\n"));
+	}
+	else	{
+		_BlockWrite(Adapter,buffer,size);
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("_WriteFW Done- for Test chip.\n"));
+	}
+}
+
+static int _FWFreeToGo(
+	IN		PADAPTER		Adapter
+	)
+{
+	u32			counter = 0;
+	u32			value32;
+	
+	// polling CheckSum report
+	do{
+		value32 = rtw_read32(Adapter, REG_MCUFWDL);
+	}while((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt)));	
+
+	if(counter >= POLLING_READY_TIMEOUT_COUNT){	
+		DBG_8192C("chksum report faill ! REG_MCUFWDL:0x%08x .\n",value32);		
+		return _FAIL;
+	}
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Checksum report OK ! REG_MCUFWDL:0x%08x .\n",value32));
+
+
+	value32 = rtw_read32(Adapter, REG_MCUFWDL);
+	value32 |= MCUFWDL_RDY;
+	value32 &= ~WINTINI_RDY;
+	rtw_write32(Adapter, REG_MCUFWDL, value32);
+	
+	// polling for FW ready
+	counter = 0;
+	do
+	{
+		if(rtw_read32(Adapter, REG_MCUFWDL) & WINTINI_RDY){
+			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Polling FW ready success!! REG_MCUFWDL:0x%08x .\n",PlatformIORead4Byte(Adapter, REG_MCUFWDL)) );
+			return _SUCCESS;
+		}
+		rtw_mdelay_os(5);
+	}while(counter++ < POLLING_READY_TIMEOUT_COUNT);
+
+	DBG_8192C("Polling FW ready fail!! REG_MCUFWDL:0x%08x .\n",rtw_read32(Adapter, REG_MCUFWDL));
+	return _FAIL;
+	
+}
+
+
+static void  _FirmwareSelfReset(PADAPTER Adapter)
+{
+	u8	u1bTmp;
+	u8	Delay = 100;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+		
+	
+	if((pHalData->FirmwareVersion > 0x21) ||
+		(pHalData->FirmwareVersion == 0x21 &&
+		pHalData->FirmwareSubVersion >= 0x01))
+	{
+/*
+	printk("==> %s REG 02(0x%04x),80(0x%08x),130(0x%08x),134(0x%08x),138(0x%08x),13c(0x%08x),\
+		1c0(0x%08x),1c4(0x%08x),1c8(0x%08x),1cc(0x%08x),\n",
+		__FUNCTION__,rtw_read16(Adapter,0x02),rtw_read32(Adapter,0x80),
+		rtw_read32(Adapter,0x130),
+		rtw_read32(Adapter,0x134),
+		rtw_read32(Adapter,0x138),
+		rtw_read32(Adapter,0x13c),
+		rtw_read32(Adapter,0x1c0),
+		rtw_read32(Adapter,0x1c4),
+		rtw_read32(Adapter,0x1c8),
+		rtw_read32(Adapter,0x1cc));
+*/		
+		//0x1cf=0x20. Inform 8051 to reset. 2009.12.25. tynli_test
+		rtw_write8(Adapter, REG_HMETFR+3, 0x20);
+	
+		u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
+		while(u1bTmp&BIT2)
+		{
+			Delay--;
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PowerOffAdapter8192CE(): polling 0x03[2] Delay = %d \n", Delay));
+			if(Delay == 0)
+				break;
+			//delay_us(50);
+			rtw_udelay_os(50);
+			u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
+		}
+	
+		if((u1bTmp&BIT2) && (Delay == 0))
+		{
+			DBG_8192C("FirmwareDownload92C():fw reset by itself Fail!!!!!! 0x03 = %x\n", u1bTmp);
+			//RT_ASSERT(FALSE, ("PowerOffAdapter8192CE(): 0x03 = %x\n", u1bTmp));
+			rtw_write8(Adapter,REG_SYS_FUNC_EN+1,(rtw_read8(Adapter, REG_SYS_FUNC_EN+1)&~BIT2));
+		}
+/*
+		printk("==> %s REG 02(0x%04x),80(0x%08x),130(0x%08x),134(0x%08x),138(0x%08x),13c(0x%08x),\
+		1c0(0x%08x),1c4(0x%08x),1c8(0x%08x),1cc(0x%08x),\n",
+		__FUNCTION__,rtw_read16(Adapter,0x02),rtw_read32(Adapter,0x80),
+		rtw_read32(Adapter,0x130),
+		rtw_read32(Adapter,0x134),
+		rtw_read32(Adapter,0x138),
+		rtw_read32(Adapter,0x13c),
+		rtw_read32(Adapter,0x1c0),
+		rtw_read32(Adapter,0x1c4),
+		rtw_read32(Adapter,0x1c8),
+		rtw_read32(Adapter,0x1cc));
+*/		
+	}
+}
+
+//
+//	Description:
+//		Download 8192C firmware code.
+//
+//
+int FirmwareDownload92C(
+	IN	PADAPTER			Adapter
+)
+{	
+	int	rtStatus = _SUCCESS;	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	char 			R92CFwImageFileName_TSMC[] ={RTL8192C_FW_TSMC_IMG};
+	char 			R92CFwImageFileName_UMC[] ={RTL8192C_FW_UMC_IMG};
+	char 			R8723FwImageFileName_UMC[] ={RTL8723_FW_UMC_IMG};
+
+	char *			FwImage;
+	u32				FwImageLen;	
+	
+	char*			pFwImageFileName;	
+
+	//vivi, merge 92c and 92s into one driver, 20090817
+	//vivi modify this temply, consider it later!!!!!!!!
+	//PRT_FIRMWARE	pFirmware = GET_FIRMWARE_819X(Adapter);	
+	//PRT_FIRMWARE_92C	pFirmware = GET_FIRMWARE_8192C(Adapter);
+	PRT_FIRMWARE_92C	pFirmware = NULL;
+	PRT_8192C_FIRMWARE_HDR		pFwHdr = NULL;
+	u8		*pFirmwareBuf;
+	u32		FirmwareLen;
+
+	pFirmware = (PRT_FIRMWARE_92C)_rtw_zmalloc(sizeof(RT_FIRMWARE_92C));
+	if(!pFirmware)
+	{
+		rtStatus = _FAIL;
+		goto Exit;
+	}
+	
+	
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> FirmwareDownload91C() fw:%s\n", pFwImageFileName));
+
+#ifdef CONFIG_EMBEDDED_FWIMG
+	pFirmware->eFWSource = FW_SOURCE_HEADER_FILE;
+#else
+	pFirmware->eFWSource = FW_SOURCE_IMG_FILE; 
+#endif
+	if(IS_NORMAL_CHIP(pHalData->VersionID))
+	{
+		if(IS_VENDOR_UMC_A_CUT(pHalData->VersionID) && !IS_92C_SERIAL(pHalData->VersionID))// UMC , 8188
+		{						
+			pFwImageFileName = R92CFwImageFileName_UMC;
+			FwImage = Rtl819XFwUMCACutImageArray;
+			FwImageLen = UMCACutImgArrayLength;
+			DBG_871X(" ===> FirmwareDownload91C() fw:Rtl819XFwImageArray_UMC\n");
+
+			//FwImage = Rtl819XFwUMCBCutImageArray;
+			//FwImageLen = UMCBCutImgArrayLength;
+		}
+		else
+		{
+			pFwImageFileName = R92CFwImageFileName_TSMC;
+			FwImage = Rtl819XFwTSMCImageArray;
+			FwImageLen = TSMCImgArrayLength;
+			DBG_871X(" ===> FirmwareDownload91C() fw:Rtl819XFwImageArray_TSMC\n");
+		}
+	}
+	else
+	{
+	#if 0
+		pFwImageFileName = TestChipFwFile;
+		FwImage = Rtl8192CTestFwImg;
+		FwImageLen = Rtl8192CTestFwImgLen;
+		RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> FirmwareDownload91C() fw:Rtl8192CTestFwImg\n"));
+	#endif
+	}
+		
+
+	switch(pFirmware->eFWSource)
+	{
+		case FW_SOURCE_IMG_FILE:
+			//TODO:load fw bin file
+			break;
+		case FW_SOURCE_HEADER_FILE:
+			if(TSMCImgArrayLength > FW_8192C_SIZE){
+				rtStatus = _FAIL;
+				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Firmware size exceed 0x%X. Check it.\n", FW_8192C_SIZE) );
+				DBG_871X("Firmware size exceed 0x%X. Check it.\n", FW_8192C_SIZE);
+				goto Exit;
+			}
+			_rtw_memcpy(pFirmware->szFwBuffer, FwImage, FwImageLen);
+			pFirmware->ulFwLength = FwImageLen;
+			break;
+	}
+
+	pFirmwareBuf = pFirmware->szFwBuffer;
+	FirmwareLen = pFirmware->ulFwLength;
+
+	// To Check Fw header. 
+	pFwHdr = (PRT_8192C_FIRMWARE_HDR)pFirmware->szFwBuffer;
+
+	pHalData->FirmwareVersion =  le16_to_cpu(pFwHdr->Version); 
+	pHalData->FirmwareSubVersion = le16_to_cpu(pFwHdr->Subversion); 
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, (" FirmwareVersion(%#x), Signature(%#x)\n", 
+	//	Adapter->MgntInfo.FirmwareVersion, pFwHdr->Signature));
+
+	DBG_8192C("fw_ver=v%d, fw_subver=%d, sig=0x%x\n", 
+		pHalData->FirmwareVersion, pHalData->FirmwareSubVersion, le16_to_cpu(pFwHdr->Signature)&0xFFF0);
+
+	if(IS_FW_HEADER_EXIST(pFwHdr))
+	{
+		//RT_TRACE(COMP_INIT, DBG_LOUD,("Shift 32 bytes for FW header!!\n"));
+		pFirmwareBuf = pFirmwareBuf + 32;
+		FirmwareLen = FirmwareLen -32;
+	}
+		
+	// Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself,
+	// or it will cause download Fw fail. 2010.02.01. by tynli.
+	if(rtw_read8(Adapter, REG_MCUFWDL)&BIT7) //8051 RAM code
+	{	
+		DBG_8192C("8051 in Ram......prepare to reset by itself\n");
+		_FirmwareSelfReset(Adapter);
+		rtw_write8(Adapter, REG_MCUFWDL, 0x00);		
+	}
+
+		
+	_FWDownloadEnable(Adapter, _TRUE);
+	_WriteFW(Adapter, pFirmwareBuf, FirmwareLen);
+	_FWDownloadEnable(Adapter, _FALSE);
+
+	rtStatus = _FWFreeToGo(Adapter);
+	if(_SUCCESS != rtStatus){
+		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("DL Firmware failed!\n") );	
+		goto Exit;
+	}	
+	//RT_TRACE(COMP_INIT, DBG_LOUD, (" Firmware is ready to run!\n"));
+
+Exit:
+
+	if(pFirmware)
+		_rtw_mfree((u8*)pFirmware, sizeof(RT_FIRMWARE_92C));
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, (" <=== FirmwareDownload91C()\n"));
+	return rtStatus;
+
+}
+
+
+//-------------------------------------------------------------------------
+//
+//	Channel Plan
+//
+//-------------------------------------------------------------------------
+
+RT_CHANNEL_DOMAIN
+_HalMapChannelPlan8192C(
+	IN	PADAPTER	Adapter,
+	IN	u8		HalChannelPlan
+	)
+{
+	RT_CHANNEL_DOMAIN	rtChannelDomain;
+
+	switch(HalChannelPlan)
+	{
+		case EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN:
+			rtChannelDomain = RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN;
+			break;
+		case EEPROM_CHANNEL_PLAN_WORLD_WIDE_13:
+			rtChannelDomain = RT_CHANNEL_DOMAIN_WORLD_WIDE_13;
+			break;			
+		default:
+			rtChannelDomain = (RT_CHANNEL_DOMAIN)HalChannelPlan;
+			break;
+	}
+	
+	return 	rtChannelDomain;
+
+}
+
+static VOID
+ReadChannelPlan(
+	IN	PADAPTER 		Adapter,
+	IN	u8*			PROMContent,
+	IN	BOOLEAN			AutoLoadFail
+	)
+{
+
+#define EEPROM_TEST_CHANNEL_PLAN	 (0x7D)
+#define EEPROM_NORMAL_CHANNEL_PLAN (0x75)
+
+	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
+	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	u8			channelPlan;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	if(AutoLoadFail){
+		channelPlan = CHPL_FCC;
+	}
+	else{
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)		
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		 	channelPlan = PROMContent[EEPROM_NORMAL_CHANNEL_PLAN];
+		else
+			channelPlan = PROMContent[EEPROM_TEST_CHANNEL_PLAN];
+#else
+		 channelPlan = PROMContent[EEPROM_CHANNEL_PLAN];
+#endif
+	}
+
+	if((pregistrypriv->channel_plan>= RT_CHANNEL_DOMAIN_MAX) || (channelPlan & EEPROM_CHANNEL_PLAN_BY_HW_MASK))
+	{
+		pmlmepriv->ChannelPlan = _HalMapChannelPlan8192C(Adapter, (channelPlan & (~(EEPROM_CHANNEL_PLAN_BY_HW_MASK))));
+		//pMgntInfo->bChnlPlanFromHW = (channelPlan & EEPROM_CHANNEL_PLAN_BY_HW_MASK) ? _TRUE : _FALSE; // User cannot change  channel plan.
+	}
+	else
+	{
+		pmlmepriv->ChannelPlan = (RT_CHANNEL_DOMAIN)pregistrypriv->channel_plan;
+	}
+
+#if 0 //todo:
+	switch(pMgntInfo->ChannelPlan)
+	{
+		case RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN:
+		{
+			PRT_DOT11D_INFO	pDot11dInfo = GET_DOT11D_INFO(pMgntInfo);
+	
+			pDot11dInfo->bEnabled = _TRUE;
+		}
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("Enable dot11d when RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN!\n"));
+		break;
+	}
+#endif
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("RegChannelPlan(%d) EEPROMChannelPlan(%ld)", pMgntInfo->RegChannelPlan, (u4Byte)channelPlan));
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("ChannelPlan = %d\n" , pMgntInfo->ChannelPlan));
+
+	MSG_8192C("RT_ChannelPlan: 0x%02x\n", pmlmepriv->ChannelPlan);
+
+}
+
+
+//-------------------------------------------------------------------------
+//
+//	EEPROM Power index mapping
+//
+//-------------------------------------------------------------------------
+
+ static VOID
+_ReadPowerValueFromPROM(
+	IN	PTxPowerInfo	pwrInfo,
+	IN	u8*			PROMContent,
+	IN	BOOLEAN			AutoLoadFail
+	)
+{
+	u32 rfPath, eeAddr, group;
+
+	_rtw_memset(pwrInfo, 0, sizeof(TxPowerInfo));
+
+	if(AutoLoadFail){		
+		for(group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
+			for(rfPath = 0 ; rfPath < RF90_PATH_MAX ; rfPath++){
+				pwrInfo->CCKIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel;	
+				pwrInfo->HT40_1SIndex[rfPath][group]	= EEPROM_Default_TxPowerLevel;
+				pwrInfo->HT40_2SIndexDiff[rfPath][group]= EEPROM_Default_HT40_2SDiff;
+				pwrInfo->HT20IndexDiff[rfPath][group]	= EEPROM_Default_HT20_Diff;
+				pwrInfo->OFDMIndexDiff[rfPath][group]	= EEPROM_Default_LegacyHTTxPowerDiff;
+				pwrInfo->HT40MaxOffset[rfPath][group]	= EEPROM_Default_HT40_PwrMaxOffset;		
+				pwrInfo->HT20MaxOffset[rfPath][group]	= EEPROM_Default_HT20_PwrMaxOffset;
+			}
+		}
+
+		pwrInfo->TSSI_A = EEPROM_Default_TSSI;
+		pwrInfo->TSSI_B = EEPROM_Default_TSSI;
+		
+		return;
+	}
+	
+	for(rfPath = 0 ; rfPath < RF90_PATH_MAX ; rfPath++){
+		for(group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
+			eeAddr = EEPROM_CCK_TX_PWR_INX + (rfPath * 3) + group;
+			pwrInfo->CCKIndex[rfPath][group] = PROMContent[eeAddr];
+
+			eeAddr = EEPROM_HT40_1S_TX_PWR_INX + (rfPath * 3) + group;
+			pwrInfo->HT40_1SIndex[rfPath][group] = PROMContent[eeAddr];
+		}
+	}
+
+	for(group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
+		for(rfPath = 0 ; rfPath < RF90_PATH_MAX ; rfPath++){
+			pwrInfo->HT40_2SIndexDiff[rfPath][group] = 
+			(PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF + group] >> (rfPath * 4)) & 0xF;
+
+			pwrInfo->HT20IndexDiff[rfPath][group] =
+			(PROMContent[EEPROM_HT20_TX_PWR_INX_DIFF + group] >> (rfPath * 4)) & 0xF;
+			
+			pwrInfo->OFDMIndexDiff[rfPath][group] =
+			(PROMContent[EEPROM_OFDM_TX_PWR_INX_DIFF+ group] >> (rfPath * 4)) & 0xF;
+
+			pwrInfo->HT40MaxOffset[rfPath][group] =
+			(PROMContent[EEPROM_HT40_MAX_PWR_OFFSET+ group] >> (rfPath * 4)) & 0xF;
+
+			pwrInfo->HT20MaxOffset[rfPath][group] =
+			(PROMContent[EEPROM_HT20_MAX_PWR_OFFSET+ group] >> (rfPath * 4)) & 0xF;
+		}
+	}
+
+	pwrInfo->TSSI_A = PROMContent[EEPROM_TSSI_A];
+	pwrInfo->TSSI_B = PROMContent[EEPROM_TSSI_B];
+
+}
+
+
+static u32
+_GetChannelGroup(
+	IN	u32	channel
+	)
+{
+	//RT_ASSERT((channel < 14), ("Channel %d no is supported!\n"));
+
+	if(channel < 3){ 	// Channel 1~3
+		return 0;
+	}
+	else if(channel < 9){ // Channel 4~9
+		return 1;
+	}
+
+	return 2;				// Channel 10~14	
+}
+
+
+static VOID
+ReadTxPowerInfo(
+	IN	PADAPTER 		Adapter,
+	IN	u8*			PROMContent,
+	IN	BOOLEAN			AutoLoadFail
+	)
+{	
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	TxPowerInfo		pwrInfo;
+	u32			rfPath, ch, group;
+	u8			pwr, diff;
+
+	_ReadPowerValueFromPROM(&pwrInfo, PROMContent, AutoLoadFail);
+
+	for(rfPath = 0 ; rfPath < RF90_PATH_MAX ; rfPath++){
+		for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+			group = _GetChannelGroup(ch);
+
+			pEEPROM->TxPwrLevelCck[rfPath][ch]		= pwrInfo.CCKIndex[rfPath][group];
+			pEEPROM->TxPwrLevelHT40_1S[rfPath][ch]	= pwrInfo.HT40_1SIndex[rfPath][group];
+
+			pEEPROM->TxPwrHt20Diff[rfPath][ch]		= pwrInfo.HT20IndexDiff[rfPath][group];
+			pEEPROM->TxPwrLegacyHtDiff[rfPath][ch]	= pwrInfo.OFDMIndexDiff[rfPath][group];
+			pEEPROM->PwrGroupHT20[rfPath][ch]		= pwrInfo.HT20MaxOffset[rfPath][group];
+			pEEPROM->PwrGroupHT40[rfPath][ch]		= pwrInfo.HT40MaxOffset[rfPath][group];
+
+			pwr		= pwrInfo.HT40_1SIndex[rfPath][group];
+			diff	= pwrInfo.HT40_2SIndexDiff[rfPath][group];
+
+			pEEPROM->TxPwrLevelHT40_2S[rfPath][ch]  = (pwr > diff) ? (pwr - diff) : 0;
+		}
+	}
+
+	if(AutoLoadFail)
+	{
+		pEEPROM->EEPROMRegulatory= 0;	
+	}
+	else
+	{
+		pEEPROM->EEPROMRegulatory = (PROMContent[EEPROM_RF_OPT1]&0x7);	//bit0~2
+		
+	}
+	
+#if DBG
+
+	for(rfPath = 0 ; rfPath < RF90_PATH_MAX ; rfPath++){
+		for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+			RTPRINT(FINIT, INIT_TxPower, 
+				("RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n", 
+				rfPath, ch, pHalData->TxPwrLevelCck[rfPath][ch], 
+				pHalData->TxPwrLevelHT40_1S[rfPath][ch], 
+				pHalData->TxPwrLevelHT40_2S[rfPath][ch]));
+
+		}
+	}
+
+	for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+		RTPRINT(FINIT, INIT_TxPower, ("RF-A Ht20 to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrHt20Diff[RF90_PATH_A][ch]));
+	}
+
+	for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+		RTPRINT(FINIT, INIT_TxPower, ("RF-A Legacy to Ht40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF90_PATH_A][ch]));
+	}
+	
+	for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+		RTPRINT(FINIT, INIT_TxPower, ("RF-B Ht20 to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrHt20Diff[RF90_PATH_B][ch]));
+	}
+	
+	for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+		RTPRINT(FINIT, INIT_TxPower, ("RF-B Legacy to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF90_PATH_B][ch]));
+	}
+	
+#endif
+
+}
+
+
+//-------------------------------------------------------------------
+//
+//	EEPROM/EFUSE Content Parsing
+//
+//-------------------------------------------------------------------
+static VERSION_8192C
+ReadChipVersion(
+	IN	PADAPTER	Adapter
+	)
+{
+	u32				value32;
+	VERSION_8192C	version;
+	u8				ChipVersion=0;	
+	
+	value32 = rtw_read32(Adapter, REG_SYS_CFG);
+
+	if (value32 & TRP_VAUX_EN){		
+		version = (value32 & TYPE_ID) ?VERSION_TEST_CHIP_92C :VERSION_TEST_CHIP_88C;		
+	}
+	else{		
+		ChipVersion = NORMAL_CHIP;
+		ChipVersion |= ((value32 & TYPE_ID) ? CHIP_92C : 0);
+		ChipVersion |= ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : 0);
+		ChipVersion |= ((value32 & BT_FUNC) ? CHIP_8723: 0); // RTL8723 with BT function.
+		if(IS_VENDOR_UMC(ChipVersion))
+			ChipVersion |= ((value32 & CHIP_VER_RTL_MASK) ? CHIP_VENDOR_UMC_B_CUT : 0);
+
+		if(IS_92C_SERIAL(ChipVersion))
+		{
+			value32 = rtw_read32(Adapter, REG_HPON_FSM);
+			ChipVersion |= ((CHIP_BONDING_IDENTIFIER(value32) == CHIP_BONDING_92C_1T2R) ? CHIP_92C_1T2R : 0);			
+		}
+		else if(IS_8723_SERIES(ChipVersion))
+		{
+			value32 = rtw_read32(Adapter, REG_GPIO_OUTSTS);
+			ChipVersion |= ((value32 & RF_RL_ID) ? CHIP_8723_DRV_REV : 0);			
+		}
+		version = (VERSION_8192C)ChipVersion;
+	}
+
+
+	switch(version)
+	{
+		case VERSION_NORMAL_TSMC_CHIP_92C_1T2R:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_TSMC_CHIP_92C_1T2R.\n");
+			break;
+		case VERSION_NORMAL_TSMC_CHIP_92C:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_TSMC_CHIP_92C.\n");
+			break;
+		case VERSION_NORMAL_TSMC_CHIP_88C:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_TSMC_CHIP_88C.\n");
+			break;
+		case VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT.\n");
+			break;
+		case VERSION_NORMAL_UMC_CHIP_92C_A_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_92C_A_CUT.\n");
+			break;
+		case VERSION_NORMAL_UMC_CHIP_88C_A_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_88C_A_CUT.\n");
+			break;			
+		case VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT.\n");
+			break;
+		case VERSION_NORMAL_UMC_CHIP_92C_B_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_92C_B_CUT.\n");
+			break;
+		case VERSION_NORMAL_UMC_CHIP_88C_B_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_88C_B_CUT.\n");
+			break;
+		case VERSION_TEST_CHIP_92C:
+			MSG_8192C("Chip Version ID: VERSION_TEST_CHIP_92C.\n");
+			break;
+		case VERSION_TEST_CHIP_88C:
+			MSG_8192C("Chip Version ID: VERSION_TEST_CHIP_88C.\n");
+			break;
+		case VERSION_NORMA_UMC_CHIP_8723_1T1R_A_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMA_UMC_CHIP_8723_1T1R_A_CUT.\n");
+			break;
+		case VERSION_NORMA_UMC_CHIP_8723_1T1R_B_CUT:
+			MSG_8192C("Chip Version ID: VERSION_NORMA_UMC_CHIP_8723_1T1R_B_CUT.\n");
+			break;
+		default:
+			MSG_8192C("Chip Version ID: ???????????????.\n");
+			break;
+	}
+
+
+	return version;
+}
+
+static void
+_ReadIDs(
+	IN	PADAPTER	Adapter,
+	IN	u8*		PROMContent,
+	IN	BOOLEAN		AutoloadFail
+	)
+{
+	//PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	if(_FALSE == AutoloadFail){
+		// VID, PID 
+		#if 1 //for Funai BD's alignment error		
+		u16 tmp = 0;		
+		_rtw_memcpy( &tmp , (void*) &PROMContent[EEPROM_VID], 2 );		
+		tmp = le16_to_cpu( tmp );		
+		pEEPROM->EEPROMVID = tmp;		
+		tmp = 0;		
+		_rtw_memcpy( &tmp , (void*) &PROMContent[EEPROM_PID], 2 );		
+		tmp = le16_to_cpu( tmp );		
+		pEEPROM->EEPROMPID = tmp;	
+		#else
+		pEEPROM->EEPROMVID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_VID]);
+		pEEPROM->EEPROMPID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_PID]);		
+		#endif
+		
+		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		pEEPROM->EEPROMCustomerID = *(u8 *)&PROMContent[EEPROM_CUSTOMER_ID];
+		pEEPROM->EEPROMSubCustomerID = *(u8 *)&PROMContent[EEPROM_SUBCUSTOMER_ID];
+
+	}
+	else{
+		pEEPROM->EEPROMVID	 = EEPROM_Default_VID;
+		pEEPROM->EEPROMPID	 = EEPROM_Default_PID;
+
+		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
+		pEEPROM->EEPROMCustomerID	= EEPROM_Default_CustomerID;
+		pEEPROM->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
+
+	}
+
+
+	switch(pEEPROM->EEPROMCustomerID)
+	{
+		case EEPROM_CID_ALPHA:
+				pHalData->CustomerID = RT_CID_819x_ALPHA;
+				break;
+				
+		case EEPROM_CID_CAMEO:
+				pHalData->CustomerID = RT_CID_819x_CAMEO;
+				break;			
+					
+		case EEPROM_CID_SITECOM:
+				pHalData->CustomerID = RT_CID_819x_Sitecom;
+				break;	
+					
+		case EEPROM_CID_COREGA:
+				pHalData->CustomerID = RT_CID_COREGA;						
+				break;			
+			
+		case EEPROM_CID_Senao:
+				pHalData->CustomerID = RT_CID_819x_Senao;
+				break;
+		
+		case EEPROM_CID_EDIMAX_BELKIN:
+				pHalData->CustomerID = RT_CID_819x_Edimax_Belkin;
+				break;
+		
+		case EEPROM_CID_SERCOMM_BELKIN:
+				pHalData->CustomerID = RT_CID_819x_Sercomm_Belkin;
+				break;
+					
+		case EEPROM_CID_WNC_COREGA:
+				pHalData->CustomerID = RT_CID_819x_WNC_COREGA;
+				break;
+		
+		case EEPROM_CID_WHQL:
+/*			
+			Adapter->bInHctTest = TRUE;
+
+			pMgntInfo->bSupportTurboMode = FALSE;
+			pMgntInfo->bAutoTurboBy8186 = FALSE;
+
+			pMgntInfo->PowerSaveControl.bInactivePs = FALSE;
+			pMgntInfo->PowerSaveControl.bIPSModeBackup = FALSE;
+			pMgntInfo->PowerSaveControl.bLeisurePs = FALSE;
+				
+			pMgntInfo->keepAliveLevel = 0;
+
+			Adapter->bUnloadDriverwhenS3S4 = FALSE;
+*/				
+				break;
+					
+		case EEPROM_CID_NetCore:
+				pHalData->CustomerID = RT_CID_819x_Netcore;
+				break;
+		
+		case EEPROM_CID_CAMEO1:
+				pHalData->CustomerID = RT_CID_819x_CAMEO1;
+				break;
+					
+		case EEPROM_CID_CLEVO:
+				pHalData->CustomerID = RT_CID_819x_CLEVO;
+			break;			
+		
+		default:
+				pHalData->CustomerID = RT_CID_DEFAULT;
+			break;
+			
+	}
+
+	// For customized behavior.
+	if((pEEPROM->EEPROMVID == 0x103C) && (pEEPROM->EEPROMPID == 0x1629))// HP Lite-On for RTL8188CUS Slim Combo.
+		pHalData->CustomerID = RT_CID_819x_HP;	
+
+	MSG_8192C("EEPROMVID = 0x%04x\n", pEEPROM->EEPROMVID);
+	MSG_8192C("EEPROMPID = 0x%04x\n", pEEPROM->EEPROMPID);
+	MSG_8192C("EEPROMCustomerID : 0x%02x\n", pEEPROM->EEPROMCustomerID);
+	MSG_8192C("EEPROMSubCustomerID: 0x%02x\n", pEEPROM->EEPROMSubCustomerID);
+
+	MSG_8192C("RT_CustomerID: 0x%02x\n", pHalData->CustomerID);
+
+}
+
+
+static VOID
+_ReadMACAddress(
+	IN	PADAPTER	Adapter,	
+	IN	u8*		PROMContent,
+	IN	BOOLEAN		AutoloadFail
+	)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+
+	if(_FALSE == AutoloadFail){
+		//Read Permanent MAC address and set value to hardware
+		_rtw_memcpy(pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR], ETH_ALEN);		
+	}
+	else{
+		//Random assigh MAC address
+		u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
+		//sMacAddr[5] = (u8)GetRandomNumber(1, 254);		
+		_rtw_memcpy(pEEPROM->mac_addr, sMacAddr, ETH_ALEN);	
+	}
+	
+	//NicIFSetMacAddress(Adapter, Adapter->PermanentAddress);
+	//RT_PRINT_ADDR(COMP_INIT|COMP_EFUSE, DBG_LOUD, "MAC Addr: %s", Adapter->PermanentAddress);
+
+}
+#ifdef CONFIG_BT_COEXIST
+static void _update_bt_param(_adapter *padapter)
+{
+	struct btcoexist_priv	 *pbtpriv = &(padapter->halpriv.bt_coexist);
+	struct registry_priv  	*registry_par = &padapter->registrypriv;
+	if(2 != registry_par->bt_iso)
+		pbtpriv->BT_Ant_isolation = registry_par->bt_iso;// 0:Low, 1:High, 2:From Efuse
+
+
+	if(registry_par->bt_sco == 1) // 0:Idle, 1:None-SCO, 2:SCO, 3:From Counter, 4.Busy, 5.OtherBusy
+		pbtpriv->BT_Service = BT_OtherAction;
+	else if(registry_par->bt_sco==2)
+		pbtpriv->BT_Service = BT_SCO;
+	else if(registry_par->bt_sco==4)
+		pbtpriv->BT_Service = BT_Busy;
+	else if(registry_par->bt_sco==5)
+		pbtpriv->BT_Service = BT_OtherBusy;		
+	else
+		pbtpriv->BT_Service = BT_Idle;
+
+	pbtpriv->BT_Ampdu = registry_par->bt_ampdu;
+	pbtpriv->bCOBT = _TRUE;
+
+	pbtpriv->BtEdcaUL = 0;
+	pbtpriv->BtEdcaDL = 0;
+	pbtpriv->BtRssiState = 0xff;
+
+	pbtpriv->bInitSet = _FALSE;
+	pbtpriv->bBTBusyTraffic = _FALSE;
+	pbtpriv->bBTTrafficModeSet = _FALSE;
+	pbtpriv->bBTNonTrafficModeSet = _FALSE;
+	pbtpriv->CurrentState = 0;
+	pbtpriv->PreviousState = 0;
+		
+	
+#if 1
+	printk("BT Coexistance = %s\n", (pbtpriv->BT_Coexist==_TRUE)?"enable":"disable");
+	if(pbtpriv->BT_Coexist)
+	{
+		if(pbtpriv->BT_Ant_Num == Ant_x2)
+		{
+			printk("BlueTooth BT_Ant_Num = Antx2\n");
+		}
+		else if(pbtpriv->BT_Ant_Num == Ant_x1)
+		{
+			printk("BlueTooth BT_Ant_Num = Antx1\n");
+		}
+		switch(pbtpriv->BT_CoexistType)
+		{
+			case BT_2Wire:
+				printk("BlueTooth BT_CoexistType = BT_2Wire\n");
+				break;
+			case BT_ISSC_3Wire:
+				printk("BlueTooth BT_CoexistType = BT_ISSC_3Wire\n");
+				break;
+			case BT_Accel:
+				printk("BlueTooth BT_CoexistType = BT_Accel\n");
+				break;
+			case BT_CSR_BC4:
+				printk("BlueTooth BT_CoexistType = BT_CSR_BC4\n");
+				break;
+			case BT_CSR_BC8:
+				printk("BlueTooth BT_CoexistType = BT_CSR_BC8\n");
+				break;			
+			case BT_RTL8756:
+				printk("BlueTooth BT_CoexistType = BT_RTL8756\n");
+				break;
+			default:
+				printk("BlueTooth BT_CoexistType = Unknown\n");
+				break;
+		}
+		printk("BlueTooth BT_Ant_isolation = %d\n", pbtpriv->BT_Ant_isolation);
+
+
+		switch(pbtpriv->BT_Service)
+		{
+			case BT_OtherAction:
+				printk("BlueTooth BT_Service = BT_OtherAction\n");
+				break;
+			case BT_SCO:
+				printk("BlueTooth BT_Service = BT_SCO\n");
+				break;
+			case BT_Busy:
+				printk("BlueTooth BT_Service = BT_Busy\n");
+				break;
+			case BT_OtherBusy:
+				printk("BlueTooth BT_Service = BT_OtherBusy\n");
+				break;			
+			default:
+				printk("BlueTooth BT_Service = BT_Idle\n");
+				break;
+		}
+
+		printk("BT_RadioSharedType = 0x%x\n", pbtpriv->BT_RadioSharedType);
+	}
+#endif
+
+}
+
+
+#define GET_BT_COEXIST(priv) (&priv->bt_coexist)
+
+void _ReadBluetoothCoexistInfo(
+	IN	PADAPTER	Adapter,	
+	IN	u8*		PROMContent,
+	IN	BOOLEAN		AutoloadFail
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	BOOLEAN			isNormal = IS_NORMAL_CHIP(pHalData->VersionID);
+	struct btcoexist_priv	 *pbtpriv = &pHalData->bt_coexist;
+	
+	u8	rf_opt4;
+	_rtw_memset(pbtpriv, 0,sizeof(struct btcoexist_priv));
+
+	if(AutoloadFail){
+		pbtpriv->BT_Coexist = _FALSE;
+		pbtpriv->BT_CoexistType= BT_2Wire;
+		pbtpriv->BT_Ant_Num = Ant_x2;
+		pbtpriv->BT_Ant_isolation= 0;
+		pbtpriv->BT_RadioSharedType = BT_Radio_Shared;		
+		return;
+	}
+
+	if(isNormal)
+	{
+		if(pHalData->BoardType == BOARD_USB_COMBO)
+			pbtpriv->BT_Coexist = _TRUE;
+		else
+			pbtpriv->BT_Coexist = ((PROMContent[EEPROM_RF_OPT3]&0x20)>>5);	//bit[5]
+		
+		rf_opt4 = PROMContent[EEPROM_RF_OPT4];
+		pbtpriv->BT_CoexistType 	= ((rf_opt4&0xe)>>1);				// bit [3:1]
+		pbtpriv->BT_Ant_Num 		= (rf_opt4&0x1);					// bit [0]
+		pbtpriv->BT_Ant_isolation 	= ((rf_opt4&0x10)>>4);			// bit [4]
+		pbtpriv->BT_RadioSharedType 	= ((rf_opt4&0x20)>>5);		// bit [5]
+	}
+	else
+	{
+		pbtpriv->BT_Coexist = (PROMContent[EEPROM_RF_OPT4] >> 4) ? _TRUE : _FALSE;	
+	}
+	_update_bt_param(Adapter);
+
+}
+#endif
+static VOID
+_ReadBoardType(
+	IN	PADAPTER	Adapter,	
+	IN	u8*		PROMContent,
+	IN	BOOLEAN		AutoloadFail
+	)
+{	
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	BOOLEAN			isNormal = IS_NORMAL_CHIP(pHalData->VersionID);
+	struct registry_priv  *registry_par = &Adapter->registrypriv;
+	u8			boardType;
+
+	if(AutoloadFail){
+		pHalData->rf_type = RF_1T1R;
+		pHalData->BluetoothCoexist = _FALSE;
+		return;
+	}
+
+	if(isNormal) 
+	{
+		boardType = ((PROMContent[EEPROM_RF_OPT1])&BOARD_TYPE_NORMAL_MASK)>>5 ; //bit[7:5]
+	}
+	else
+	{
+		boardType = PROMContent[EEPROM_RF_OPT4];
+		boardType &= BOARD_TYPE_TEST_MASK;		
+		}
+
+	pHalData->BoardType = boardType;
+	printk("_ReadBoardType(%x)\n",pHalData->BoardType);
+
+	
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	// Antenna Diversity setting. 
+	if(registry_par->antdiv_cfg == 2) // 2: From Efuse
+		pHalData->AntDivCfg = (PROMContent[EEPROM_RF_OPT1]&0x18)>>3;
+	else
+		pHalData->AntDivCfg = registry_par->antdiv_cfg ;  // 0:OFF , 1:ON,
+
+	printk("### AntDivCfg(%x)\n",pHalData->AntDivCfg);	
+#endif
+	
+
+}
+
+
+static VOID
+_ReadLEDSetting(
+	IN	PADAPTER	Adapter,	
+	IN	u8*		PROMContent,
+	IN	BOOLEAN		AutoloadFail
+	)
+{
+	struct led_priv *pledpriv = &(Adapter->ledpriv);
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	//
+	// Led mode
+	//
+	switch(pHalData->CustomerID)
+	{
+		case RT_CID_DEFAULT:
+			pledpriv->LedStrategy = SW_LED_MODE1;
+			pledpriv->bRegUseLed = _TRUE;			
+			break;
+
+		case RT_CID_819x_HP:
+			pledpriv->LedStrategy = SW_LED_MODE6; // Customize Led mode	
+			pledpriv->bLedOpenDrain = _TRUE;// Support Open-drain arrangement for controlling the LED. Added by Roger, 2009.10.16.
+			break;
+			
+		default:
+			pledpriv->LedStrategy = SW_LED_MODE1;
+			break;			
+	}
+
+	if( BOARD_MINICARD == pHalData->BoardType )
+	{
+		pledpriv->LedStrategy = SW_LED_MODE6;
+	}
+}
+
+static VOID
+_ReadThermalMeter(
+	IN	PADAPTER	Adapter,	
+	IN	u8* 	PROMContent,
+	IN	BOOLEAN 	AutoloadFail
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);	
+	u8			tempval;
+
+	//
+	// ThermalMeter from EEPROM
+	//
+	if(!AutoloadFail)	
+		tempval = PROMContent[EEPROM_THERMAL_METER];
+	else
+		tempval = EEPROM_Default_ThermalMeter;
+	
+	pEEPROM->EEPROMThermalMeter = (tempval&0x1f);	//[4:0]
+
+	if(pEEPROM->EEPROMThermalMeter < 0x06 || pEEPROM->EEPROMThermalMeter > 0x1c)
+		pEEPROM->EEPROMThermalMeter = 0x12;
+	
+	//pHalData->ThermalMeter[0] = pEEPROM->EEPROMThermalMeter;//?
+	pHalData->ThermalValue = pEEPROM->EEPROMThermalMeter;
+
+//	pHalData->ThermalValue = 0;//set to 0, will be update when do dm_txpower_tracking
+	
+	//RTPRINT(FINIT, INIT_TxPower, ("ThermalMeter = 0x%x\n", pHalData->EEPROMThermalMeter));
+	
+}
+
+static VOID
+_ReadRFSetting(
+	IN	PADAPTER	Adapter,	
+	IN	u8* 	PROMContent,
+	IN	BOOLEAN 	AutoloadFail
+	)
+{
+}
+
+static void
+_ReadPROMVersion(
+	IN	PADAPTER	Adapter,	
+	IN	u8* 	PROMContent,
+	IN	BOOLEAN 	AutoloadFail
+	)
+{
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	if(AutoloadFail){
+		pEEPROM->EEPROMVersion = EEPROM_Default_Version;		
+	}
+	else{
+		pEEPROM->EEPROMVersion = *(u8 *)&PROMContent[EEPROM_VERSION];
+	}
+}
+
+// Read HW power down mode selection 
+static void _ReadHWPDSelection(IN PADAPTER Adapter,IN u8*PROMContent,IN	u8	AutoloadFail)
+{
+	if(AutoloadFail){
+		Adapter->pwrctrlpriv.bHWPowerdown = _FALSE;
+		Adapter->pwrctrlpriv.bSupportRemoteWakeup = _FALSE;
+	}
+	else	{
+		//if(SUPPORT_HW_RADIO_DETECT(Adapter))
+			Adapter->pwrctrlpriv.bHWPwrPindetect = Adapter->registrypriv.hwpwrp_detect;
+		//else
+			//Adapter->pwrctrlpriv.bHWPwrPindetect = _FALSE;//dongle not support new
+			
+			
+		//hw power down mode selection , 0:rf-off / 1:power down
+
+		if(Adapter->registrypriv.hwpdn_mode==2)
+			Adapter->pwrctrlpriv.bHWPowerdown = (PROMContent[EEPROM_RF_OPT3] & BIT4);
+		else
+			Adapter->pwrctrlpriv.bHWPowerdown = Adapter->registrypriv.hwpdn_mode;
+				
+		// decide hw if support remote wakeup function
+		// if hw supported, 8051 (SIE) will generate WeakUP signal( D+/D- toggle) when autoresume
+		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_TEST_USB_OPT] & BIT1)?_TRUE :_FALSE;
+
+		//if(SUPPORT_HW_RADIO_DETECT(Adapter))	
+			//Adapter->registrypriv.usbss_enable = Adapter->pwrctrlpriv.bSupportRemoteWakeup ;
+		
+		DBG_8192C("%s...bHWPwrPindetect(%x)-bHWPowerdown(%x) ,bSupportRemoteWakeup(%x)\n",__FUNCTION__,
+		Adapter->pwrctrlpriv.bHWPwrPindetect,Adapter->pwrctrlpriv.bHWPowerdown ,Adapter->pwrctrlpriv.bSupportRemoteWakeup);
+
+		DBG_8192C("### PS params=>  power_mgnt(%x),usbss_enable(%x) ###\n",Adapter->registrypriv.power_mgnt,Adapter->registrypriv.usbss_enable);
+		
+	}
+	
+}
+
+
+static void _InitAdapterVariablesByPROM(IN	PADAPTER Adapter)
+{
+	u8 *PROMContent = Adapter->eeprompriv.efuse_eeprom_data;
+	u8 bAutoload = Adapter->eeprompriv.bAutoload ;
+	
+	_ReadPROMVersion(Adapter, PROMContent, !bAutoload);
+	_ReadIDs(Adapter, PROMContent, !bAutoload);
+	_ReadMACAddress(Adapter, PROMContent, !bAutoload);	
+	
+	ReadTxPowerInfo(Adapter, PROMContent, !bAutoload);
+	
+	ReadChannelPlan(Adapter, PROMContent, !bAutoload);//todo:	
+	_ReadBoardType(Adapter, PROMContent, !bAutoload);//get rf_type !!!
+#ifdef CONFIG_BT_COEXIST
+	_ReadBluetoothCoexistInfo(Adapter, PROMContent, !bAutoload);
+#endif
+	
+	_ReadThermalMeter(Adapter, PROMContent, !bAutoload);
+	_ReadLEDSetting(Adapter, PROMContent, !bAutoload);	
+	_ReadRFSetting(Adapter, PROMContent, !bAutoload);
+	_ReadHWPDSelection(Adapter, PROMContent, !bAutoload);
+
+	Adapter->bDongle = !(PROMContent[EEPROM_EASY_REPLACEMENT]);
+	DBG_8192C("%s(): REPLACEMENT = %x\n",__FUNCTION__,Adapter->bDongle);	
+}
+
+static void efuse_ReadAllMap(
+	IN		PADAPTER	pAdapter, 
+	IN OUT	u8		*Efuse)
+{	
+	int i, offset;	
+
+	rtw_efuse_reg_init(pAdapter);
+	rtw_efuse_get_max_phy_size(pAdapter);//init
+	
+	for(i=0, offset=0 ; i<128; i+=8, offset++)
+	{		
+		rtw_efuse_pg_packet_read(pAdapter, offset, Efuse+i);			
+/*
+		printk("offset(%d),data:[%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:]\n",offset,
+			*(Efuse+i),*(Efuse+i+1),*(Efuse+i+2),*(Efuse+i+3),
+			*(Efuse+i+4),	*(Efuse+i+5),*(Efuse+i+6),*(Efuse+i+7));
+*/
+	}
+	
+	rtw_efuse_reg_uninit(pAdapter);
+
+}// efuse_ReadAllMap
+static void EFUSE_ShadowMapUpdate(
+	IN		PADAPTER	pAdapter)
+{	
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);	
+		
+	if (pEEPROM->bAutoload == _SUCCESS)
+	{			
+		efuse_ReadAllMap(pAdapter, pEEPROM->efuse_eeprom_data);		
+	}	
+	
+}// EFUSE_ShadowMapUpdate
+
+
+#define EEPROM_ADDRESS_LEN	6
+
+
+
+static void _EnableEepromPG( PADAPTER Adapter,u8 enable)
+{
+	u8 eeValue,value;
+	eeValue = rtw_read8(Adapter, REG_9346CR);	
+	value = enable ? (eeValue | EEM1) : (eeValue & ~EEM1);	
+	 rtw_write8(Adapter, REG_9346CR,value);		
+}
+//-----------------------------------------------------------------------------
+// Procedure:   RaiseClock
+//
+// Description: This routine raises the EEPOM's clock input (EESK)
+//
+// Arguments:
+//      pValue - Ptr to the EEPROM control register's current value
+//
+// Returns: (none)
+//-----------------------------------------------------------------------------
+static void _RaiseClock(PADAPTER Adapter,u16* pValue)
+{
+	*pValue = *pValue | EESK;
+	rtw_write16(Adapter,REG_9346CR, *pValue);
+}
+
+//-----------------------------------------------------------------------------
+// Procedure:   LowerClock
+//
+// Description: This routine lower's the EEPOM's clock input (EESK)
+//
+// Arguments:
+//      pValue - Ptr to the EEPROM control register's current value
+//
+// Returns: (none)
+//-----------------------------------------------------------------------------
+static void _LowerClock(PADAPTER Adapter,u16* pValue)
+{
+	*pValue = (*pValue & ~EESK);
+	rtw_write16(Adapter,REG_9346CR, *pValue);
+}
+
+static void _ShiftOutBits(PADAPTER Adapter,u16 data, u16 count)
+{
+	unsigned short mask;
+	unsigned short value = rtw_read16(Adapter,REG_9346CR);
+
+	mask = 0x01 << (count - 1);
+
+	value &= ~(EEDO | EEDI);
+
+	do
+	{
+		value &= ~EEDI;
+		if(data & mask){
+		    value |= EEDI;
+		}
+		
+		rtw_write16(Adapter,REG_9346CR, value);
+		_RaiseClock(Adapter,&value);
+		_LowerClock(Adapter,&value);
+		mask = mask >> 1;
+	} while(mask);
+
+	value&= ~EEDI;
+
+	rtw_write16(Adapter,REG_9346CR, value);
+	
+}
+static void _EEpromCleanup(PADAPTER Adapter)
+{
+	unsigned short value = rtw_read16(Adapter,REG_9346CR);
+
+	value &= ~(EECS | EEDI);
+	rtw_write16(Adapter,REG_9346CR, value);
+
+	_RaiseClock(Adapter,&value);
+	_LowerClock(Adapter,&value);
+}
+//-----------------------------------------------------------------------------
+// Procedure:   ShiftInBits
+//
+// Description: This routine shifts data bits in from the EEPROM.
+//
+// Arguments:
+//
+// Returns:
+//      The contents of that particular EEPROM word
+//-----------------------------------------------------------------------------
+
+static u16 _ShiftInBits(PADAPTER Adapter)
+{
+	u16 d = 0;
+	int i;
+	u16 value = rtw_read16(Adapter,REG_9346CR);
+	value &= ~( EEDO | EEDI);
+
+	for(i = 0 ; i < 16 ; i++){
+		d = d << 1;
+		_RaiseClock(Adapter,&value);
+
+		value = rtw_read16(Adapter,REG_9346CR);
+
+		value &= ~(EEDI);
+		if(value & EEDO){
+			d |= 1;
+		}
+		
+		_LowerClock(Adapter,&value);
+	}
+
+	return d;
+}
+
+static u16 _EERead2Byte(PADAPTER Adapter,u32 address)
+{
+	u16 data;
+	u16 value =rtw_read16(Adapter, REG_9346CR);
+
+	value &= ~(EEDI | EEDO | EESK | EEM0);
+	value|= (EEM1 | EECS);
+	rtw_write16(Adapter,REG_9346CR, value);
+	
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 6 bits long
+	_ShiftOutBits(Adapter,EEPROM_READ_OPCODE, 3);
+	_ShiftOutBits(Adapter,address, EEPROM_ADDRESS_LEN);
+
+	// Now read the data (16 bits) in from the selected EEPROM word
+	data = _ShiftInBits(Adapter);
+
+	_EEpromCleanup(Adapter);
+	return data;
+	
+}
+
+static void EEPROM_ShadowMapUpdate( PADAPTER Adapter)
+{
+	
+	u8 *PROMContent = Adapter->eeprompriv.efuse_eeprom_data;
+
+	u32			i;
+	u16 value16;
+	_EnableEepromPG(Adapter,_TRUE);	
+	// Read all Content from EEPROM
+	for(i = 0; i < HWSET_MAX_SIZE; i += 2)
+	{
+		//todo:
+		//value16 = EF2Byte(ReadEEprom(Adapter, (u16) (i>>1)));
+		//*((u16*)(&PROMContent[i])) = value16; 				
+		value16 =  _EERead2Byte(Adapter, (u16) (i>>1));
+		value16  = le16_to_cpu(value16 );
+		*((u16*)(&PROMContent[i])) = value16; 
+		
+	}
+	_EnableEepromPG(Adapter,_FALSE);
+	
+}
+static void _ReadPROMContent(
+	IN PADAPTER 		Adapter
+	)
+{	
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	u8			eeValue;
+	
+
+	_rtw_memset(pEEPROM->efuse_eeprom_data, 0xff, HWSET_MAX_SIZE);	
+	
+	eeValue = rtw_read8(Adapter, REG_9346CR);
+	// To check system boot selection.
+	pEEPROM->bBootFromEEPROM	= (eeValue & BOOT_FROM_EEPROM) ? _TRUE : _FALSE;
+	pEEPROM->bAutoload			= (eeValue & EEPROM_EN) ? _SUCCESS:_FAIL;
+
+
+	DBG_8192C("Boot from %s, Autoload %s !\n", (pEEPROM->bBootFromEEPROM ? "EEPROM" : "EFUSE"),
+				(pEEPROM->bAutoload ? "Success" : "Fail") );
+
+	//pHalData->EEType = IS_BOOT_FROM_EEPROM(Adapter) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE;
+
+	if(_SUCCESS == pEEPROM->bAutoload)
+	{
+		
+		if (_TRUE == pEEPROM->bBootFromEEPROM)
+		{
+			EEPROM_ShadowMapUpdate(Adapter);			
+		}
+		else
+		{
+			// Read EFUSE real map to shadow.
+			EFUSE_ShadowMapUpdate(Adapter);						
+		}		
+	}	
+	
+	_InitAdapterVariablesByPROM(Adapter);
+	
+}
+
+
+static VOID
+_InitOtherVariable(
+	IN PADAPTER 		Adapter
+	)
+{
+#if 0
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+
+
+	if(Adapter->bInHctTest){
+		pMgntInfo->PowerSaveControl.bInactivePs = FALSE;
+		pMgntInfo->PowerSaveControl.bIPSModeBackup = FALSE;
+		pMgntInfo->PowerSaveControl.bLeisurePs = FALSE;
+		pMgntInfo->keepAliveLevel = 0;
+	}
+
+	// 2009/06/10 MH For 92S 1*1=1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A
+	// So if you want to use radio B. Please modify RF path enable bit for correct signal
+	// strength calculate.
+	if (pHalData->rf_type == RF_1T1R){
+		pHalData->bRFPathRxEnable[0] = TRUE;
+	}
+	else{
+		pHalData->bRFPathRxEnable[0] = pHalData->bRFPathRxEnable[1] = TRUE;
+	}
+
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("RegChannelPlan(%d) EEPROMChannelPlan(%d)", pMgntInfo->RegChannelPlan, pHalData->EEPROMChannelPlan));
+	RT_TRACE(COMP_INIT, DBG_LOUD, ("ChannelPlan = %d\n" , pMgntInfo->ChannelPlan));
+#endif
+}
+
+static VOID
+_ReadRFChipType(
+	IN	PADAPTER	Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+#if DISABLE_BB_RF
+	pHalData->rf_chip = RF_PSEUDO_11N;
+#else
+	pHalData->rf_chip = RF_6052;
+#endif
+}
+
+void rtl8192c_ReadChipVersion(
+	IN PADAPTER			Adapter
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	pHalData->VersionID = ReadChipVersion(Adapter);
+}
+
+
+int ReadAdapterInfo8192C(PADAPTER	Adapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	MSG_8192C("====> ReadAdapterInfo8192C\n");
+
+#ifdef CONFIG_USB_HCI
+	//_ReadChipVersion(Adapter);
+
+	_ReadRFChipType(Adapter);//rf_chip -> _InitRFType()
+	
+	_ReadPROMContent(Adapter);
+
+	_InitOtherVariable(Adapter);
+#endif
+
+	//MSG_8192C("%s()(done), rf_chip=0x%x, rf_type=0x%x\n",  __FUNCTION__, pHalData->rf_chip, pHalData->rf_type);
+
+	MSG_8192C("<==== ReadAdapterInfo8192C\n");
+	
+	return _SUCCESS;
+}
+
+u8 GetEEPROMSize8192C(PADAPTER Adapter)
+{
+	u8	size = 0;
+	u32	curRCR;
+
+	curRCR = rtw_read16(Adapter, REG_9346CR);
+	size = (curRCR & BOOT_FROM_EEPROM) ? 6 : 4; // 6: EEPROM used is 93C46, 4: boot from E-Fuse.
+	
+	MSG_8192C("EEPROM type is %s\n", size==4 ? "E-FUSE" : "93C46");
+	
+	return size;
+}
+
+void NicIFReadAdapterInfo8192C(PADAPTER Adapter)
+{
+	// Read EEPROM size before call any EEPROM function
+	//Adapter->EepromAddressSize=Adapter->HalFunc.GetEEPROMSizeHandler(Adapter);
+	Adapter->EepromAddressSize = GetEEPROMSize8192C(Adapter);
+	
+	ReadAdapterInfo8192C(Adapter);
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/ifcfg-wlan0 linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/ifcfg-wlan0
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/ifcfg-wlan0	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/ifcfg-wlan0	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,4 @@
+#DHCP client
+DEVICE=wlan0
+BOOTPROTO=dhcp
+ONBOOT=yes
\ No newline at end of file
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/autoconf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/autoconf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/autoconf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/autoconf.h	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,157 @@
+/*
+ * Automatically generated C config: don't edit
+ */
+
+#define AUTOCONF_INCLUDED
+#define RTL871X_MODULE_NAME "92CU"
+
+//#define CONFIG_DEBUG_RTL871X 1
+
+#define CONFIG_USB_HCI	1
+#undef  CONFIG_SDIO_HCI
+#undef CONFIG_PCIE_HCI
+
+#undef CONFIG_RTL8711
+#undef  CONFIG_RTL8712
+#define	CONFIG_RTL8192C 1
+#define	CONFIG_RTL8192D 1
+
+
+//#define CONFIG_LITTLE_ENDIAN 1 //move to Makefile depends on platforms
+//#undef CONFIG_BIG_ENDIAN
+
+#undef PLATFORM_WINDOWS
+#undef PLATFORM_OS_XP 
+#undef PLATFORM_OS_CE
+
+
+#define PLATFORM_LINUX 1
+
+//#define CONFIG_PWRCTRL	1
+//#define CONFIG_H2CLBK 1
+
+//#define CONFIG_MP_INCLUDED 1
+
+//#undef CONFIG_EMBEDDED_FWIMG
+#define CONFIG_EMBEDDED_FWIMG 1
+
+#define CONFIG_R871X_TEST 1
+
+#define CONFIG_80211N_HT 1
+
+#define CONFIG_RECV_REORDERING_CTRL 1
+
+//#define CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX 1
+
+//#define CONFIG_DRVEXT_MODULE 1
+
+
+#define CONFIG_IPS	1
+#define CONFIG_LPS	1
+#define CONFIG_BT_COEXIST  	1
+#define CONFIG_ANTENNA_DIVERSITY	1
+//#define CONFIG_WOWLAN 1
+
+#define SUPPORT_HW_RFOFF_DETECTED	1
+
+#ifdef PLATFORM_LINUX
+//	#define CONFIG_PROC_DEBUG 1
+#endif
+
+#ifdef CONFIG_RTL8192C
+
+	#define DBG 0
+
+	#define CONFIG_DEBUG_RTL8192C				1
+
+	#define DEV_BUS_PCI_INTERFACE				1
+	#define DEV_BUS_USB_INTERFACE				2	
+
+	#define RTL8192C_WEP_ISSUE					0
+	
+	#define RTL8192C_RX_PACKET_NO_INCLUDE_CRC	1
+
+	#define SUPPORTED_BLOCK_IO
+	
+	#ifdef CONFIG_USB_HCI
+
+		#define DEV_BUS_TYPE	DEV_BUS_USB_INTERFACE
+
+		#define USB_TX_AGGREGATION_92C	1
+		#define USB_RX_AGGREGATION_92C	1		
+		#define CONFIG_PS_CMD				1
+
+		#ifdef CONFIG_WISTRON_PLATFORM	
+			#define SILENT_RESET_FOR_SPECIFIC_PLATFOM	1				
+		#endif
+		
+		#define RTL8192CU_FW_DOWNLOAD_ENABLE	1
+
+		#define CONFIG_ONLY_ONE_OUT_EP_TO_LOW	0
+	
+		#define CONFIG_OUT_EP_WIFI_MODE	0
+
+		#define ENABLE_USB_DROP_INCORRECT_OUT	0
+
+		#define RTL8192CU_ASIC_VERIFICATION	0	// For ASIC verification.
+
+		#define RTL8192CU_ADHOC_WORKAROUND_SETTING 1
+
+		#ifdef PLATFORM_LINUX
+			#define CONFIG_SKB_COPY 			1//for amsdu
+			#define CONFIG_PREALLOC_RECV_SKB	1			
+			#define CONFIG_REDUCE_USB_TX_INT	1
+			#define CONFIG_EASY_REPLACEMENT	1
+			#ifdef CONFIG_WISTRON_PLATFORM
+			#define DYNAMIC_ALLOCIATE_VENDOR_CMD	0
+			#else
+			#define DYNAMIC_ALLOCIATE_VENDOR_CMD	1
+			#endif
+		#endif		
+
+		#ifdef CONFIG_R871X_TEST
+
+			//#define CONFIG_AP_MODE 1
+			//#define CONFIG_NATIVEAP_MLME 1
+
+			#ifdef CONFIG_AP_MODE
+
+				#ifndef CONFIG_NATIVEAP_MLME
+					#define CONFIG_HOSTAPD_MLME 1
+				#endif
+			
+			#endif
+		
+		#endif
+    
+	
+	#endif
+
+	#ifdef CONFIG_PCIE_HCI
+
+		#define DEV_BUS_TYPE	DEV_BUS_PCI_INTERFACE
+		
+	#endif
+
+	
+	#define DISABLE_BB_RF	0	
+
+	#define RTL8191C_FPGA_NETWORKTYPE_ADHOC 0
+
+	//#define FW_PROCESS_VENDOR_CMD 1
+
+	#ifdef CONFIG_MP_INCLUDED
+		#define MP_DRIVER 1
+	#else
+		#define MP_DRIVER 0
+	#endif
+
+#endif
+
+
+//#define CONFIG_NON_SKB_TRANSFER_BUFFER 1
+
+#ifdef CONFIG_NON_SKB_TRANSFER_BUFFER
+#undef CONFIG_PREALLOC_RECV_SKB
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/basic_types.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/basic_types.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/basic_types.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/basic_types.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+#include <drv_conf.h>
+
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+#ifndef TRUE
+	#define _TRUE	1
+#else
+	#define _TRUE	TRUE	
+#endif
+		
+#ifndef FALSE		
+	#define _FALSE	0
+#else
+	#define _FALSE	FALSE	
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+	typedef signed char s8;
+	typedef unsigned char u8;
+
+	typedef signed short s16;
+	typedef unsigned short u16;
+
+	typedef signed long s32;
+	typedef unsigned long u32;
+	
+	typedef unsigned int	uint;
+	typedef	signed int		sint;
+
+
+	typedef signed long long s64;
+	typedef unsigned long long u64;
+
+	#ifdef NDIS50_MINIPORT
+	
+		#define NDIS_MAJOR_VERSION       5
+		#define NDIS_MINOR_VERSION       0
+
+	#endif
+
+	#ifdef NDIS51_MINIPORT
+
+		#define NDIS_MAJOR_VERSION       5
+		#define NDIS_MINOR_VERSION       1
+
+	#endif
+
+	typedef NDIS_PROC proc_t;
+
+#endif
+
+
+#ifdef PLATFORM_LINUX
+
+	#include <linux/types.h>
+	#define IN
+	#define OUT
+	#define VOID void
+	#define NDIS_OID uint
+	#define NDIS_STATUS uint
+		
+	typedef	signed int sint;
+
+	#ifndef	PVOID
+	typedef void * PVOID;
+	//#define PVOID	(void *)
+	#endif
+
+        #define UCHAR u8
+	#define USHORT u16
+	#define UINT u32
+	#define ULONG u32	
+
+	typedef void (*proc_t)(void*);
+
+	typedef 	__kernel_size_t	SIZE_T;	
+	typedef	__kernel_ssize_t	SSIZE_T;
+	#define FIELD_OFFSET(s,field)	((SSIZE_T)&((s*)(0))->field)
+	
+#endif
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
+#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
+
+#define SIZE_PTR SIZE_T
+#define SSIZE_PTR SSIZE_T
+
+typedef unsigned char	BOOLEAN,*PBOOLEAN;
+
+#endif //__BASIC_TYPES_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/big_endian.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/big_endian.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/big_endian.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/big_endian.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
+#define _LINUX_BYTEORDER_BIG_ENDIAN_H
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __BIG_ENDIAN_BITFIELD
+#define __BIG_ENDIAN_BITFIELD
+#endif
+
+#include <byteorder/swab.h>
+
+#define __constant_htonl(x) ((__u32)(x))
+#define __constant_ntohl(x) ((__u32)(x))
+#define __constant_htons(x) ((__u16)(x))
+#define __constant_ntohs(x) ((__u16)(x))
+#define __constant_cpu_to_le64(x) ___constant_swab64((x))
+#define __constant_le64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_le32(x) ___constant_swab32((x))
+#define __constant_le32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_le16(x) ___constant_swab16((x))
+#define __constant_le16_to_cpu(x) ___constant_swab16((x))
+#define __constant_cpu_to_be64(x) ((__u64)(x))
+#define __constant_be64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_be32(x) ((__u32)(x))
+#define __constant_be32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_be16(x) ((__u16)(x))
+#define __constant_be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64(x) __swab64((x))
+#define __le64_to_cpu(x) __swab64((x))
+#define __cpu_to_le32(x) __swab32((x))
+#define __le32_to_cpu(x) __swab32((x))
+#define __cpu_to_le16(x) __swab16((x))
+#define __le16_to_cpu(x) __swab16((x))
+#define __cpu_to_be64(x) ((__u64)(x))
+#define __be64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_be32(x) ((__u32)(x))
+#define __be32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_be16(x) ((__u16)(x))
+#define __be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64p(x) __swab64p((x))
+#define __le64_to_cpup(x) __swab64p((x))
+#define __cpu_to_le32p(x) __swab32p((x))
+#define __le32_to_cpup(x) __swab32p((x))
+#define __cpu_to_le16p(x) __swab16p((x))
+#define __le16_to_cpup(x) __swab16p((x))
+#define __cpu_to_be64p(x) (*(__u64*)(x))
+#define __be64_to_cpup(x) (*(__u64*)(x))
+#define __cpu_to_be32p(x) (*(__u32*)(x))
+#define __be32_to_cpup(x) (*(__u32*)(x))
+#define __cpu_to_be16p(x) (*(__u16*)(x))
+#define __be16_to_cpup(x) (*(__u16*)(x))
+#define __cpu_to_le64s(x) __swab64s((x))
+#define __le64_to_cpus(x) __swab64s((x))
+#define __cpu_to_le32s(x) __swab32s((x))
+#define __le32_to_cpus(x) __swab32s((x))
+#define __cpu_to_le16s(x) __swab16s((x))
+#define __le16_to_cpus(x) __swab16s((x))
+#define __cpu_to_be64s(x) do {} while (0)
+#define __be64_to_cpus(x) do {} while (0)
+#define __cpu_to_be32s(x) do {} while (0)
+#define __be32_to_cpus(x) do {} while (0)
+#define __cpu_to_be16s(x) do {} while (0)
+#define __be16_to_cpus(x) do {} while (0)
+
+#include <byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/generic.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/generic.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/generic.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/generic.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,209 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+#define _LINUX_BYTEORDER_GENERIC_H
+
+/*
+ * linux/byteorder_generic.h
+ * Generic Byte-reordering support
+ *
+ * Francois-Rene Rideau <fare@tunes.org> 19970707
+ *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
+ *    cleaned them up.
+ *    I hope it is compliant with non-GCC compilers.
+ *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
+ *    because I wasn't sure it would be ok to put it in types.h
+ *    Upgraded it to 2.1.43
+ * Francois-Rene Rideau <fare@tunes.org> 19971012
+ *    Upgraded it to 2.1.57
+ *    to please Linus T., replaced huge #ifdef's between little/big endian
+ *    by nestedly #include'd files.
+ * Francois-Rene Rideau <fare@tunes.org> 19971205
+ *    Made it to 2.1.71; now a facelift:
+ *    Put files under include/linux/byteorder/
+ *    Split swab from generic support.
+ *
+ * TODO:
+ *   = Regular kernel maintainers could also replace all these manual
+ *    byteswap macros that remain, disseminated among drivers,
+ *    after some grep or the sources...
+ *   = Linus might want to rename all these macros and files to fit his taste,
+ *    to fit his personal naming scheme.
+ *   = it seems that a few drivers would also appreciate
+ *    nybble swapping support...
+ *   = every architecture could add their byteswap macro in asm/byteorder.h
+ *    see how some architectures already do (i386, alpha, ppc, etc)
+ *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
+ *    distinguished throughout the kernel. This is not the case currently,
+ *    since little endian, big endian, and pdp endian machines needn't it.
+ *    But this might be the case for, say, a port of Linux to 20/21 bit
+ *    architectures (and F21 Linux addict around?).
+ */
+
+/*
+ * The following macros are to be defined by <asm/byteorder.h>:
+ *
+ * Conversion of long and short int between network and host format
+ *	ntohl(__u32 x)
+ *	ntohs(__u16 x)
+ *	htonl(__u32 x)
+ *	htons(__u16 x)
+ * It seems that some programs (which? where? or perhaps a standard? POSIX?)
+ * might like the above to be functions, not macros (why?).
+ * if that's true, then detect them, and take measures.
+ * Anyway, the measure is: define only ___ntohl as a macro instead,
+ * and in a separate file, have
+ * unsigned long inline ntohl(x){return ___ntohl(x);}
+ *
+ * The same for constant arguments
+ *	__constant_ntohl(__u32 x)
+ *	__constant_ntohs(__u16 x)
+ *	__constant_htonl(__u32 x)
+ *	__constant_htons(__u16 x)
+ *
+ * Conversion of XX-bit integers (16- 32- or 64-)
+ * between native CPU format and little/big endian format
+ * 64-bit stuff only defined for proper architectures
+ *	cpu_to_[bl]eXX(__uXX x)
+ *	[bl]eXX_to_cpu(__uXX x)
+ *
+ * The same, but takes a pointer to the value to convert
+ *	cpu_to_[bl]eXXp(__uXX x)
+ *	[bl]eXX_to_cpup(__uXX x)
+ *
+ * The same, but change in situ
+ *	cpu_to_[bl]eXXs(__uXX x)
+ *	[bl]eXX_to_cpus(__uXX x)
+ *
+ * See asm-foo/byteorder.h for examples of how to provide
+ * architecture-optimized versions
+ *
+ */
+
+
+#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS) || defined(PLATFORM_MPIXEL)
+/*
+ * inside the kernel, we can use nicknames;
+ * outside of it, we must avoid POSIX namespace pollution...
+ */
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+#endif
+
+
+/*
+ * Handle ntohl and suches. These have various compatibility
+ * issues - like we want to give the prototype even though we
+ * also have a macro for them in case some strange program
+ * wants to take the address of the thing or something..
+ *
+ * Note that these used to return a "long" in libc5, even though
+ * long is often 64-bit these days.. Thus the casts.
+ *
+ * They have to be macros in order to do the constant folding
+ * correctly - if the argument passed into a inline function
+ * it is no longer constant according to gcc..
+ */
+
+#undef ntohl
+#undef ntohs
+#undef htonl
+#undef htons
+
+/*
+ * Do the prototypes. Somebody might want to take the
+ * address or some such sick thing..
+ */
+#if defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2)
+extern __u32			ntohl(__u32);
+extern __u32			htonl(__u32);
+#else
+extern unsigned long int	ntohl(unsigned long int);
+extern unsigned long int	htonl(unsigned long int);
+#endif
+extern unsigned short int	ntohs(unsigned short int);
+extern unsigned short int	htons(unsigned short int);
+
+
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) ||  defined(PLATFORM_MPIXEL)
+
+#define ___htonl(x) __cpu_to_be32(x)
+#define ___htons(x) __cpu_to_be16(x)
+#define ___ntohl(x) __be32_to_cpu(x)
+#define ___ntohs(x) __be16_to_cpu(x)
+
+#if defined(PLATFORM_LINUX) || (defined (__GLIBC__) && __GLIBC__ >= 2)
+#define htonl(x) ___htonl(x)
+#define ntohl(x) ___ntohl(x)
+#else
+#define htonl(x) ((unsigned long)___htonl(x))
+#define ntohl(x) ((unsigned long)___ntohl(x))
+#endif
+#define htons(x) ___htons(x)
+#define ntohs(x) ___ntohs(x)
+
+#endif /* OPTIMIZE */
+
+
+#if defined (PLATFORM_WINDOWS)
+
+#define htonl(x) __cpu_to_be32(x)
+#define ntohl(x) __be32_to_cpu(x)
+#define htons(x) __cpu_to_be16(x)
+#define ntohs(x) __be16_to_cpu(x)
+
+
+#endif
+
+#endif /* _LINUX_BYTEORDER_GENERIC_H */
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/little_endian.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/little_endian.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/little_endian.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/little_endian.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+#ifndef __LITTLE_ENDIAN_BITFIELD
+#define __LITTLE_ENDIAN_BITFIELD
+#endif
+
+#include <byteorder/swab.h>
+
+#define __constant_htonl(x) ___constant_swab32((x))
+#define __constant_ntohl(x) ___constant_swab32((x))
+#define __constant_htons(x) ___constant_swab16((x))
+#define __constant_ntohs(x) ___constant_swab16((x))
+#define __constant_cpu_to_le64(x) ((__u64)(x))
+#define __constant_le64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_le32(x) ((__u32)(x))
+#define __constant_le32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_le16(x) ((__u16)(x))
+#define __constant_le16_to_cpu(x) ((__u16)(x))
+#define __constant_cpu_to_be64(x) ___constant_swab64((x))
+#define __constant_be64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_be32(x) ___constant_swab32((x))
+#define __constant_be32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_be16(x) ___constant_swab16((x))
+#define __constant_be16_to_cpu(x) ___constant_swab16((x))
+#define __cpu_to_le64(x) ((__u64)(x))
+#define __le64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_le32(x) ((__u32)(x))
+#define __le32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_le16(x) ((__u16)(x))
+#define __le16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_be64(x) __swab64((x))
+#define __be64_to_cpu(x) __swab64((x))
+#define __cpu_to_be32(x) __swab32((x))
+#define __be32_to_cpu(x) __swab32((x))
+#define __cpu_to_be16(x) __swab16((x))
+#define __be16_to_cpu(x) __swab16((x))
+#define __cpu_to_le64p(x) (*(__u64*)(x))
+#define __le64_to_cpup(x) (*(__u64*)(x))
+#define __cpu_to_le32p(x) (*(__u32*)(x))
+#define __le32_to_cpup(x) (*(__u32*)(x))
+#define __cpu_to_le16p(x) (*(__u16*)(x))
+#define __le16_to_cpup(x) (*(__u16*)(x))
+#define __cpu_to_be64p(x) __swab64p((x))
+#define __be64_to_cpup(x) __swab64p((x))
+#define __cpu_to_be32p(x) __swab32p((x))
+#define __be32_to_cpup(x) __swab32p((x))
+#define __cpu_to_be16p(x) __swab16p((x))
+#define __be16_to_cpup(x) __swab16p((x))
+#define __cpu_to_le64s(x) do {} while (0)
+#define __le64_to_cpus(x) do {} while (0)
+#define __cpu_to_le32s(x) do {} while (0)
+#define __le32_to_cpus(x) do {} while (0)
+#define __cpu_to_le16s(x) do {} while (0)
+#define __le16_to_cpus(x) do {} while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+
+#include <byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/swabb.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/swabb.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/swabb.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/swabb.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,156 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_SWABB_H
+#define _LINUX_BYTEORDER_SWABB_H
+
+/*
+ * linux/byteorder/swabb.h
+ * SWAp Bytes Bizarrely
+ *	swaHHXX[ps]?(foo)
+ *
+ * Support for obNUXIous pdp-endian and other bizarre architectures.
+ * Will Linux ever run on such ancient beasts? if not, this file
+ * will be but a programming pearl. Still, it's a reminder that we
+ * shouldn't be making too many assumptions when trying to be portable.
+ *
+ */
+
+/*
+ * Meaning of the names I chose (vaxlinux people feel free to correct them):
+ * swahw32	swap 16-bit half-words in a 32-bit word
+ * swahb32	swap 8-bit halves of each 16-bit half-word in a 32-bit word
+ *
+ * No 64-bit support yet. I don't know NUXI conventions for long longs.
+ * I guarantee it will be a mess when it's there, though :->
+ * It will be even worse if there are conflicting 64-bit conventions.
+ * Hopefully, no one ever used 64-bit objects on NUXI machines.
+ *
+ */
+
+#define ___swahw32(x) \
+({ \
+	__u32 __x = (x); \
+	((__u32)( \
+		(((__u32)(__x) & (__u32)0x0000ffffUL) << 16) | \
+		(((__u32)(__x) & (__u32)0xffff0000UL) >> 16) )); \
+})
+#define ___swahb32(x) \
+({ \
+	__u32 __x = (x); \
+	((__u32)( \
+		(((__u32)(__x) & (__u32)0x00ff00ffUL) << 8) | \
+		(((__u32)(__x) & (__u32)0xff00ff00UL) >> 8) )); \
+})
+
+#define ___constant_swahw32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x0000ffffUL) << 16) | \
+		(((__u32)(x) & (__u32)0xffff0000UL) >> 16) ))
+#define ___constant_swahb32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x00ff00ffUL) << 8) | \
+		(((__u32)(x) & (__u32)0xff00ff00UL) >> 8) ))
+
+/*
+ * provide defaults when no architecture-specific optimization is detected
+ */
+#ifndef __arch__swahw32
+#  define __arch__swahw32(x) ___swahw32(x)
+#endif
+#ifndef __arch__swahb32
+#  define __arch__swahb32(x) ___swahb32(x)
+#endif
+
+#ifndef __arch__swahw32p
+#  define __arch__swahw32p(x) __swahw32(*(x))
+#endif
+#ifndef __arch__swahb32p
+#  define __arch__swahb32p(x) __swahb32(*(x))
+#endif
+
+#ifndef __arch__swahw32s
+#  define __arch__swahw32s(x) do { *(x) = __swahw32p((x)); } while (0)
+#endif
+#ifndef __arch__swahb32s
+#  define __arch__swahb32s(x) do { *(x) = __swahb32p((x)); } while (0)
+#endif
+
+
+/*
+ * Allow constant folding
+ */
+#if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__)
+#  define __swahw32(x) \
+(__builtin_constant_p((__u32)(x)) ? \
+ ___swahw32((x)) : \
+ __fswahw32((x)))
+#  define __swahb32(x) \
+(__builtin_constant_p((__u32)(x)) ? \
+ ___swahb32((x)) : \
+ __fswahb32((x)))
+#else
+#  define __swahw32(x) __fswahw32(x)
+#  define __swahb32(x) __fswahb32(x)
+#endif /* OPTIMIZE */
+
+
+__inline static__ __const__ __u32 __fswahw32(__u32 x)
+{
+	return __arch__swahw32(x);
+}
+__inline static__ __u32 __swahw32p(__u32 *x)
+{
+	return __arch__swahw32p(x);
+}
+__inline static__ void __swahw32s(__u32 *addr)
+{
+	__arch__swahw32s(addr);
+}
+
+
+__inline static__ __const__ __u32 __fswahb32(__u32 x)
+{
+	return __arch__swahb32(x);
+}
+__inline static__ __u32 __swahb32p(__u32 *x)
+{
+	return __arch__swahb32p(x);
+}
+__inline static__ void __swahb32s(__u32 *addr)
+{
+	__arch__swahb32s(addr);
+}
+
+#ifdef __BYTEORDER_HAS_U64__
+/*
+ * Not supported yet
+ */
+#endif /* __BYTEORDER_HAS_U64__ */
+
+#if defined(PLATFORM_LINUX)
+#define swahw32 __swahw32
+#define swahb32 __swahb32
+#define swahw32p __swahw32p
+#define swahb32p __swahb32p
+#define swahw32s __swahw32s
+#define swahb32s __swahb32s
+#endif
+
+#endif /* _LINUX_BYTEORDER_SWABB_H */
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/swab.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/swab.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/byteorder/swab.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/byteorder/swab.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,128 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_SWAB_H
+#define _LINUX_BYTEORDER_SWAB_H
+
+#ifndef __u16
+typedef unsigned short __u16;
+#endif
+
+#ifndef __u32
+typedef unsigned int	__u32;
+#endif
+
+#ifndef __u8
+typedef unsigned char __u8;
+#endif
+
+#ifndef __u64
+typedef unsigned long long	__u64;	
+#endif
+
+
+__inline static __u16  ___swab16(__u16 x)
+{
+	__u16 __x = x; 
+	return 
+	((__u16)( 
+		(((__u16)(__x) & (__u16)0x00ffU) << 8) |
+		(((__u16)(__x) & (__u16)0xff00U) >> 8) ));
+
+}
+
+__inline static __u32  ___swab32(__u32 x)
+{
+	__u32 __x = (x);
+	return ((__u32)(
+		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
+		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
+		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
+		(((__u32)(__x) & (__u32)0xff000000UL) >> 24) ));
+}
+
+__inline static __u64  ___swab64(__u64 x)
+{
+	__u64 __x = (x);
+	
+	return 
+	((__u64)( \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+	        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
+}
+
+#ifndef __arch__swab16
+__inline static __u16 __arch__swab16(__u16 x)
+{
+	return ___swab16(x);
+}
+
+#endif
+
+#ifndef __arch__swab32
+__inline static __u32 __arch__swab32(__u32 x)
+{
+	__u32 __tmp = (x) ; 
+	return ___swab32(__tmp);
+}
+#endif
+
+#ifndef __arch__swab64
+
+__inline static __u64 __arch__swab64(__u64 x)
+{
+	__u64 __tmp = (x) ; 
+	return ___swab64(__tmp);
+}
+
+
+#endif
+
+#define __swab16(x) __fswab16(x)
+#define __swab32(x) __fswab32(x)
+#define __swab64(x) __fswab64(x)
+
+__inline static const __u16 __fswab16(__u16 x)
+{
+	return __arch__swab16(x);
+}
+__inline static const __u32 __fswab32(__u32 x)
+{
+	return __arch__swab32(x);
+}
+
+#if defined(PLATFORM_LINUX) || defined(PLATFORM_WINDOWS)
+#define swab16 __swab16
+#define swab32 __swab32
+#define swab64 __swab64
+#define swab16p __swab16p
+#define swab32p __swab32p
+#define swab64p __swab64p
+#define swab16s __swab16s
+#define swab32s __swab32s
+#define swab64s __swab64s
+#endif
+
+#endif /* _LINUX_BYTEORDER_SWAB_H */
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/circ_buf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/circ_buf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/circ_buf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/circ_buf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __CIRC_BUF_H_
+#define __CIRC_BUF_H_ 1
+
+#define CIRC_CNT(head,tail,size) (((head) - (tail)) & ((size)-1))
+
+#define CIRC_SPACE(head,tail,size) CIRC_CNT((tail),((head)+1),(size))
+
+#endif //_CIRC_BUF_H_
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/cmd_osdep.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/cmd_osdep.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/cmd_osdep.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/cmd_osdep.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __CMD_OSDEP_H_
+#define __CMD_OSDEP_H_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+extern sint _rtw_init_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern sint _rtw_init_evt_priv(struct evt_priv *pevtpriv);
+extern void _rtw_free_evt_priv (struct	evt_priv *pevtpriv);
+extern void _rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern sint _rtw_enqueue_cmd(_queue *queue, struct cmd_obj *obj);
+extern struct	cmd_obj	*_rtw_dequeue_cmd(_queue *queue);
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_conf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_conf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_conf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_conf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_CONF_H__
+#define __DRV_CONF_H__
+#include "autoconf.h"
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+//#include <rtl871x_byteorder.h>
+
+#endif // __DRV_CONF_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types_ce.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types_ce.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types_ce.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types_ce.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,74 @@
+
+#ifndef __DRV_TYPES_CE_H__
+#define __DRV_TYPES_CE_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#include <Sdcardddk.h>
+
+#define MAX_ACTIVE_REG_PATH 256
+
+#define MAX_MCAST_LIST_NUM					32
+
+
+
+//for ioctl
+#define MAKE_DRIVER_VERSION(_MainVer,_MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)
+
+#define NIC_HEADER_SIZE				14			//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+#define NIC_MAX_SEND_PACKETS			10		// max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h
+#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0,001)	//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+
+typedef struct _MP_REG_ENTRY
+{
+
+	NDIS_STRING		RegName;	// variable name text
+	BOOLEAN			bRequired;	// 1 -> required, 0 -> optional
+
+	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
+	uint			FieldOffset;	// offset to MP_ADAPTER field
+	uint			FieldSize;	// size (in bytes) of the field
+	
+#ifdef UNDER_AMD64
+	u64			Default;
+#else
+	u32			Default;		// default value to use
+#endif
+
+	u32			Min;			// minimum value allowed
+	u32			Max;		// maximum value allowed
+} MP_REG_ENTRY, *PMP_REG_ENTRY;
+
+#ifdef CONFIG_USB_HCI
+typedef struct _USB_EXTENSION {
+    LPCUSB_FUNCS    _lpUsbFuncs;
+	USB_HANDLE	    _hDevice;
+    PVOID 		    pAdapter;
+
+#if 0
+	USB_ENDPOINT_DESCRIPTOR		_endpACLIn;
+    USB_ENDPOINT_DESCRIPTOR		_endpACLOutHigh;
+	USB_ENDPOINT_DESCRIPTOR		_endpACLOutNormal;
+
+	USB_PIPE        pPipeIn;
+    USB_PIPE        pPipeOutNormal;
+    USB_PIPE        pPipeOutHigh;
+#endif
+
+} USB_EXTENSION, *PUSB_EXTENSION;
+#endif
+
+
+typedef struct _OCTET_STRING{
+	u8      *Octet;
+	u16      Length;
+} OCTET_STRING, *POCTET_STRING;
+
+
+
+
+
+#endif
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,403 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*-------------------------------------------------------------------------------
+	
+	For type defines and data structure defines
+
+--------------------------------------------------------------------------------*/
+
+
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+
+
+#ifdef CONFIG_RTL8711
+#include <rtl8711_spec.h>
+#endif
+#ifdef CONFIG_RTL8712
+#include <rtl8712_spec.h>
+#endif
+#ifdef CONFIG_RTL8192C
+#include <rtl8192c_spec.h>
+#endif
+
+
+#ifdef PLATFORM_OS_XP
+#include <drv_types_xp.h>
+#endif
+
+#ifdef PLATFORM_OS_CE
+#include <drv_types_ce.h>
+#endif
+
+#ifdef PLATFORM_LINUX
+#include <drv_types_linux.h>
+#endif
+
+enum _NIC_VERSION {
+	
+	RTL8711_NIC,
+	RTL8712_NIC,
+	RTL8713_NIC,
+	RTL8716_NIC
+		
+};
+
+enum{
+	UP_LINK,
+	DOWN_LINK,	
+};
+typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
+
+#ifdef CONFIG_80211N_HT
+#include <rtw_ht.h>
+#endif
+
+#include <rtw_cmd.h>
+#include <wlan_bssdef.h>
+#include <rtw_xmit.h>
+#include <rtw_recv.h>
+#include <hal_init.h>
+#include <rtw_qos.h>
+#include <rtw_security.h>
+#include <rtw_pwrctrl.h>
+#include <rtw_io.h>
+#include <rtw_eeprom.h>
+#include <sta_info.h>
+#include <rtw_mlme.h>
+#include <rtw_mp.h>
+#include <rtw_debug.h>
+#include <rtw_rf.h>
+#include <rtw_event.h>
+#include <rtw_led.h>
+#include <rtw_mlme_ext.h>
+
+#ifdef CONFIG_DRVEXT_MODULE
+#include <rtl871x_drvext.h>
+#include <wsc_api.h>
+#endif
+
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+#define SPEC_DEV_ID_RF_CONFIG_1T1R BIT(3)
+#define SPEC_DEV_ID_RF_CONFIG_2T2R BIT(4)
+
+struct specific_device_id{
+	
+	u32		flags;
+	
+	u16		idVendor;
+	u16		idProduct;
+
+};
+
+struct registry_priv
+{    
+	u8	chip_version;
+	u8	rfintfs;
+	u8	lbkmode;
+	u8	hci;
+	u8	network_mode;	//infra, ad-hoc, auto	  
+	NDIS_802_11_SSID	ssid;
+	u8	channel;//ad-hoc support requirement 
+	u8	wireless_mode;//A, B, G, auto
+	u8	vrtl_carrier_sense;//Enable, Disable, Auto
+	u8	vcs_type;//RTS/CTS, CTS-to-self
+	u16	rts_thresh;
+	u16  frag_thresh;	
+	u8	preamble;//long, short, auto
+	u8  scan_mode;//active, passive
+	u8  adhoc_tx_pwr;
+	u8      	     soft_ap;
+	u8      	     smart_ps;  
+	 u8                  power_mgnt;
+	 u8                  radio_enable;
+	 u8                  long_retry_lmt;
+	 u8                  short_retry_lmt;
+  	 u16                 busy_thresh;
+
+    	 u8                  ack_policy;
+	 u8		     mp_mode;	
+	 u8 		     software_encrypt;
+	 u8 		     software_decrypt;	  
+
+	  //UAPSD
+	  u8		     wmm_enable;
+	  u8		     uapsd_enable;	  
+	  u8		     uapsd_max_sp;
+	  u8		     uapsd_acbk_en;
+	  u8		     uapsd_acbe_en;
+	  u8		     uapsd_acvi_en;
+	  u8		     uapsd_acvo_en;	  
+
+	  WLAN_BSSID_EX    dev_network;
+
+#ifdef CONFIG_80211N_HT
+
+	u8		ht_enable;
+	u8		cbw40_enable;
+	u8		ampdu_enable;//for tx
+	
+
+#endif
+	u8		rf_config ;
+	u8		low_power ;
+
+	u8 		wifi_spec;// !turbo_mode	  
+	  
+	u8 		channel_plan;
+#ifdef CONFIG_BT_COEXIST
+	u8		bt_iso;
+	u8		bt_sco;
+	u8		bt_ampdu;
+#endif
+	BOOLEAN	bAcceptAddbaReq;	
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	u8		antdiv_cfg;
+#endif
+	  
+	u8		usbss_enable;//0:disable,1:enable
+	u8		hwpdn_mode;//0:disable,1:enable,2:deside by EFUSE config
+	u8		hwpwrp_detect;//0:disable,1:enable
+	  
+};
+
+
+//For registry parameters
+#define RGTRY_OFT(field) ((ULONG)FIELD_OFFSET(struct registry_priv,field))
+#define RGTRY_SZ(field)   sizeof(((struct registry_priv*) 0)->field)
+#define BSSID_OFT(field) ((ULONG)FIELD_OFFSET(WLAN_BSSID_EX,field))
+#define BSSID_SZ(field)   sizeof(((PWLAN_BSSID_EX) 0)->field)
+
+
+struct dvobj_priv {
+
+	_adapter * padapter;
+
+/*-------- below is for SDIO INTERFACE --------*/
+
+#ifdef CONFIG_SDIO_HCI
+
+#ifdef PLATFORM_OS_XP
+	PDEVICE_OBJECT	pphysdevobj;//pPhysDevObj;
+	PDEVICE_OBJECT	pfuncdevobj;//pFuncDevObj;
+	PDEVICE_OBJECT	pnextdevobj;//pNextDevObj;
+	SDBUS_INTERFACE_STANDARD	sdbusinft;//SdBusInterface;
+	u8	nextdevstacksz;//unsigned char			 NextDeviceStackSize;
+#endif//PLATFORM_OS_XP
+
+#ifdef PLATFORM_OS_CE
+	SD_DEVICE_HANDLE hDevice;     
+	SD_CARD_RCA                 sd_rca;
+	SD_CARD_INTERFACE           card_intf;
+	BOOLEAN                     enableIsarWithStatus;
+	WCHAR	active_path[MAX_ACTIVE_REG_PATH];
+	SD_HOST_BLOCK_CAPABILITY    sd_host_blk_cap;
+#endif//PLATFORM_OS_CE
+
+#ifdef PLATFORM_LINUX
+	struct sdio_func	*func;	
+#endif//PLATFORM_LINUX
+
+	u8	func_number;//unsigned char			FunctionNumber;
+	u32	block_transfer_len;//unsigned long			BLOCK_TRANSFER_LEN;
+	u32	blk_shiftbits;
+	u16	driver_version;
+	u16	rxblknum;
+	u16	rxblknum_rd;
+	u16	c2hblknum; 
+	u8  tx_block_mode;
+	u8  rx_block_mode;
+	u8 cmdfifo_cnt;
+	u8 rxfifo_cnt;
+	u16	sdio_hisr;
+	u16	sdio_himr;
+#endif//	CONFIG_SDIO_HCI
+
+/*-------- below is for USB INTERFACE --------*/
+ 
+#ifdef CONFIG_USB_HCI
+
+	u32 nr_endpoint;
+	u8   ishighspeed;	
+	
+	_sema	usb_suspend_sema;
+	
+#ifdef PLATFORM_WINDOWS
+	//related device objects
+	PDEVICE_OBJECT	pphysdevobj;//pPhysDevObj;
+	PDEVICE_OBJECT	pfuncdevobj;//pFuncDevObj;
+	PDEVICE_OBJECT	pnextdevobj;//pNextDevObj;
+
+	u8	nextdevstacksz;//unsigned char NextDeviceStackSize;	//= (CHAR)CEdevice->pUsbDevObj->StackSize + 1; 
+
+	//urb for control diescriptor request
+
+#ifdef PLATFORM_OS_XP
+	struct _URB_CONTROL_DESCRIPTOR_REQUEST descriptor_urb;
+	PUSB_CONFIGURATION_DESCRIPTOR	pconfig_descriptor;//UsbConfigurationDescriptor;
+#endif
+
+#ifdef PLATFORM_OS_CE
+	WCHAR			active_path[MAX_ACTIVE_REG_PATH];	// adapter regpath
+	USB_EXTENSION	usb_extension;
+
+	_nic_hdl		pipehdls_r8192c[0x10];
+#endif
+
+	u32	config_descriptor_len;//ULONG UsbConfigurationDescriptorLength;	
+#endif//PLATFORM_WINDOWS
+
+#ifdef PLATFORM_LINUX
+	struct usb_interface *pusbintf;
+	struct usb_device *pusbdev;
+#endif//PLATFORM_LINUX
+
+#endif//CONFIG_USB_HCI
+	
+};
+
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+#define	WIFI_STATUS_SUCCESS 		0
+#define	USB_VEN_REQ_CMD_FAIL 	BIT0
+#define	USB_READ_PORT_FAIL 		BIT1
+#define	USB_WRITE_PORT_FAIL		BIT2
+#define	WIFI_MAC_TXDMA_ERROR 	BIT3			
+#define   WIFI_TX_HANG				BIT4
+#define	WIFI_RX_HANG				BIT5
+#define 	WIFI_IF_NOT_EXIST			BIT6
+#endif	
+
+typedef enum _DRIVER_STATE{
+	DRIVER_NORMAL = 0,
+	DRIVER_DISAPPEAR = 1,
+	DRIVER_REPLACE_DONGLE = 2,
+}DRIVER_STATE;
+
+struct _ADAPTER{
+	int	DriverState;// for disable driver using module, use dongle to replace module.
+	int 	chip_type;
+	int	pid;//process id from UI
+	int	bDongle;//build-in module or external dongle
+ 	
+	struct 	dvobj_priv dvobjpriv;
+	struct	mlme_priv mlmepriv;
+	struct	mlme_ext_priv mlmeextpriv;
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	//struct	io_queue	*pio_queue;
+	struct 	io_priv	iopriv;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;	
+	struct	registry_priv	registrypriv;
+	struct	wlan_acl_pool	acl_list;
+	struct	pwrctrl_priv	pwrctrlpriv;
+	struct 	eeprom_priv eeprompriv;
+	struct	hal_priv	halpriv;			
+	struct	led_priv	ledpriv;
+	struct 	dm_priv	dmpriv;
+	
+#ifdef CONFIG_MP_INCLUDED
+       struct mp_priv  mppriv;
+#endif
+
+#ifdef CONFIG_DRVEXT_MODULE
+	struct	drvext_priv	drvextpriv;
+#endif
+	
+#ifdef CONFIG_AP_MODE
+	struct	hostapd_priv	*phostapdpriv;		
+#endif
+
+	s32	bDriverStopped; 
+	s32	bSurpriseRemoved;
+	s32  bCardDisableWOHSM;
+	_mutex 	silentreset_mutex;
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+	u8 	silent_reset_inprogress;
+	u8	Wifi_Error_Status;
+	unsigned long last_tx_time;
+	unsigned long last_tx_complete_time;
+#endif		
+
+	u32	IsrContent;
+	u32	ImrContent;	
+	
+	u8	EepromAddressSize;		
+	u8	hw_init_completed;	
+	
+	_thread_hdl_	cmdThread;
+	_thread_hdl_	evtThread;
+	_thread_hdl_	xmitThread;
+	_thread_hdl_	recvThread;
+
+
+	NDIS_STATUS (*dvobj_init)(_adapter * adapter);
+	void  (*dvobj_deinit)(_adapter * adapter);
+	
+
+#ifdef PLATFORM_WINDOWS
+	_nic_hdl		hndis_adapter;//hNdisAdapter(NDISMiniportAdapterHandle);
+	_nic_hdl		hndis_config;//hNdisConfiguration;
+	NDIS_STRING fw_img;
+
+	u32	NdisPacketFilter;	
+	u8	MCList[MAX_MCAST_LIST_NUM][6];
+	u32	MCAddrCount;	
+#endif //end of PLATFORM_WINDOWS
+
+
+#ifdef PLATFORM_LINUX	
+	_nic_hdl pnetdev;
+	int bup;
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+	struct proc_dir_entry *dir_dev;// for proc directory
+#endif //end of PLATFORM_LINUX
+
+	int net_closed;
+
+	u8 bFWReady;
+	u8 bReadPortCancel;
+	u8 bWritePortCancel;	
+
+#ifdef CONFIG_AUTOSUSPEND
+	u8	bDisableAutosuspend;
+#endif
+};	
+  
+__inline static u8 *myid(struct eeprom_priv *peepriv)
+{
+	return (peepriv->mac_addr);
+}
+
+
+#endif //__DRV_TYPES_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types_linux.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types_linux.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types_linux.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types_linux.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,25 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_TYPES_LINUX_H__
+#define __DRV_TYPES_LINUX_H__
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types_xp.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types_xp.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/drv_types_xp.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/drv_types_xp.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,77 @@
+
+#ifndef __DRV_TYPES_XP_H__
+#define __DRV_TYPES_XP_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+
+#define MAX_MCAST_LIST_NUM					32
+
+
+
+//for ioctl
+#define MAKE_DRIVER_VERSION(_MainVer,_MinorVer)	((((u32)(_MainVer))<<16)+_MinorVer)
+
+#define NIC_HEADER_SIZE				14			//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+#define NIC_MAX_SEND_PACKETS			10		// max number of send packets the MiniportSendPackets function can accept, can be moved to typedef.h
+#define NIC_VENDOR_DRIVER_VERSION       MAKE_DRIVER_VERSION(0,001)	//!< can be moved to typedef.h
+#define NIC_MAX_PACKET_SIZE			1514		//!< can be moved to typedef.h
+
+
+#undef ON_VISTA
+//added by Jackson
+#ifndef ON_VISTA
+//
+// Bus driver versions
+//
+
+#define SDBUS_DRIVER_VERSION_1          0x100
+#define SDBUS_DRIVER_VERSION_2          0x200
+
+#define    SDP_FUNCTION_TYPE	4
+#define    SDP_BUS_DRIVER_VERSION 5
+#define    SDP_BUS_WIDTH 6
+#define    SDP_BUS_CLOCK 7
+#define    SDP_BUS_INTERFACE_CONTROL 8
+#define    SDP_HOST_BLOCK_LENGTH 9
+#define    SDP_FUNCTION_BLOCK_LENGTH 10
+#define    SDP_FN0_BLOCK_LENGTH 11
+#define    SDP_FUNCTION_INT_ENABLE 12
+#endif
+
+
+typedef struct _MP_REG_ENTRY
+{
+
+	NDIS_STRING		RegName;	// variable name text
+	BOOLEAN			bRequired;	// 1 -> required, 0 -> optional
+
+	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
+	uint			FieldOffset;	// offset to MP_ADAPTER field
+	uint			FieldSize;	// size (in bytes) of the field
+	
+#ifdef UNDER_AMD64
+	u64			Default;
+#else
+	u32			Default;		// default value to use
+#endif
+
+	u32			Min;			// minimum value allowed
+	u32			Max;		// maximum value allowed
+} MP_REG_ENTRY, *PMP_REG_ENTRY;
+
+
+typedef struct _OCTET_STRING{
+	u8      *Octet;
+	u16      Length;
+} OCTET_STRING, *POCTET_STRING;
+
+
+
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ethernet.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ethernet.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ethernet.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ethernet.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*! \file */ 
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH				6		//!< Ethernet Address Length
+#define ETHERNET_HEADER_SIZE				14		//!< Ethernet Header Length
+#define LLC_HEADER_SIZE						6		//!< LLC Header Length
+#define TYPE_LENGTH_FIELD_SIZE				2		//!< Type/Length Size
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		//!< Minimum Ethernet Packet Size
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	//!< Maximum Ethernet Packet Size
+
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((UCHAR *)(_pAddr))[0]&0x01)!=0)		//!< Is Multicast Address?
+#define RT_ETH_IS_BROADCAST(_pAddr)	(										\
+											((UCHAR *)(_pAddr))[0]==0xff	&& 		\
+											((UCHAR *)(_pAddr))[1]==0xff	&&		\
+											((UCHAR *)(_pAddr))[2]==0xff	&&		\
+											((UCHAR *)(_pAddr))[3]==0xff	&&		\
+											((UCHAR *)(_pAddr))[4]==0xff	&&		\
+											((UCHAR *)(_pAddr))[5]==0xff		)	//!< Is Broadcast Address?
+
+
+#endif // #ifndef __INC_ETHERNET_H
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/farray.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/farray.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/farray.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/farray.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,31500 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+unsigned char f_array[125912] = {
+0x12,0x87,0x09,0x10,
+0x30,0x00,0x00,0x00,
+0x08,0xF8,0x00,0x00,
+0x50,0xF3,0x00,0x00,
+0x30,0x00,0x00,0x00,
+0xB8,0xF1,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x27,0x17,0x41,
+0x87,0x12,0x12,0x01,
+0x00,0x00,0x12,0x06,
+0x00,0x00,0x00,0x00,
+0x00,0x07,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x01,0x01,0x00,0x01,
+0x01,0x01,0x00,0x00,
+0x01,0x00,0x01,0x00,
+0x00,0x00,0x01,0x01,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x7F,0x00,0x00,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x1F,0x00,0x00,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x1A,0x3C,
+0x80,0x03,0x5A,0x37,
+0x00,0x80,0x1B,0x3C,
+0x80,0x00,0x7B,0x37,
+0x00,0x00,0x5B,0xAF,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x37,
+0x00,0x80,0x1B,0x3C,
+0x80,0x00,0x7B,0x37,
+0x00,0x00,0x5B,0xAF,
+0x01,0x80,0x1A,0x3C,
+0x90,0xEE,0x5A,0x27,
+0x08,0x00,0x40,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xA1,0xAF,
+0x08,0x00,0xA2,0xAF,
+0x0C,0x00,0xA3,0xAF,
+0x10,0x00,0xA4,0xAF,
+0x14,0x00,0xA5,0xAF,
+0x18,0x00,0xA6,0xAF,
+0x1C,0x00,0xA7,0xAF,
+0x20,0x00,0xA8,0xAF,
+0x24,0x00,0xA9,0xAF,
+0x28,0x00,0xAA,0xAF,
+0x2C,0x00,0xAB,0xAF,
+0x30,0x00,0xAC,0xAF,
+0x34,0x00,0xAD,0xAF,
+0x38,0x00,0xAE,0xAF,
+0x3C,0x00,0xAF,0xAF,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x70,0x0A,0x40,
+0x40,0x00,0xB0,0xAF,
+0x44,0x00,0xB1,0xAF,
+0x48,0x00,0xB2,0xAF,
+0x4C,0x00,0xB3,0xAF,
+0x50,0x00,0xB4,0xAF,
+0x54,0x00,0xB5,0xAF,
+0x58,0x00,0xB6,0xAF,
+0x5C,0x00,0xB7,0xAF,
+0x60,0x00,0xB8,0xAF,
+0x64,0x00,0xB9,0xAF,
+0x68,0x00,0xBC,0xAF,
+0x6C,0x00,0xBD,0xAF,
+0x70,0x00,0xBE,0xAF,
+0x74,0x00,0xBF,0xAF,
+0x78,0x00,0xA8,0xAF,
+0x7C,0x00,0xA9,0xAF,
+0x80,0x00,0xAA,0xAF,
+0x32,0x3B,0x00,0x08,
+0x21,0x20,0xA0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x05,0x3C,
+0x00,0x80,0x02,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x03,0xA3,0x34,
+0x00,0x03,0x42,0x24,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x42,0xB0,0x02,0x3C,
+0x03,0x00,0x46,0x34,
+0x00,0x00,0xC3,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x70,0x30,
+0x10,0x00,0x02,0x32,
+0x18,0x00,0x40,0x10,
+0x02,0x80,0x11,0x3C,
+0x30,0x1F,0x27,0x26,
+0x78,0x36,0xE4,0x94,
+0x10,0x00,0x02,0x24,
+0x00,0x00,0xC2,0xA0,
+0x08,0x00,0x80,0x10,
+0x1C,0x03,0xA3,0x34,
+0x7C,0x36,0xE2,0x94,
+0xB0,0x03,0xA4,0x34,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0x80,0xAC,
+0x78,0x36,0xE0,0xA4,
+0x7C,0x36,0xE0,0xA4,
+0x00,0x00,0x04,0x24,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x06,0x3C,
+0x14,0x5E,0xA2,0x8C,
+0x18,0x5F,0xC3,0x8C,
+0x01,0x00,0x84,0x24,
+0x01,0x00,0x42,0x24,
+0x01,0x00,0x63,0x24,
+0x78,0x36,0xE4,0xA4,
+0x14,0x5E,0xA2,0xAC,
+0x18,0x5F,0xC3,0xAC,
+0x00,0x16,0x10,0x00,
+0x03,0x16,0x02,0x00,
+0x7B,0x00,0x40,0x04,
+0x42,0xB0,0x02,0x3C,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x40,0x00,0x02,0x32,
+0x16,0x00,0x40,0x10,
+0x30,0x1F,0x24,0x26,
+0x42,0xB0,0x0B,0x3C,
+0x03,0x00,0x62,0x35,
+0x40,0x00,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0x02,0x80,0x03,0x3C,
+0x12,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x1A,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x12,0x5F,0x60,0xA0,
+0x02,0x80,0x04,0x3C,
+0x0E,0x5F,0x83,0x90,
+0xFD,0xFF,0x02,0x24,
+0x24,0x18,0x62,0x00,
+0x0E,0x5F,0x83,0xA0,
+0x0E,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x42,0x30,
+0x5D,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x24,0x26,
+0xE0,0x1B,0x83,0x94,
+0xDC,0x1B,0x85,0x94,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x80,0x00,0x63,0x30,
+0x41,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0x08,0x00,0x42,0x34,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA4,
+0x08,0x00,0xE0,0x03,
+0xDC,0x1B,0x83,0xA4,
+0xFA,0x5E,0x82,0x90,
+0x02,0x80,0x05,0x3C,
+0x01,0x00,0x42,0x24,
+0xFA,0x5E,0x82,0xA0,
+0x0E,0x5F,0xA3,0x90,
+0xEF,0xFF,0x02,0x24,
+0x24,0x18,0x62,0x00,
+0x0E,0x5F,0xA3,0xA0,
+0xFA,0x5E,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x2C,
+0x32,0x00,0x40,0x10,
+0x30,0x1F,0x23,0x26,
+0x25,0xB0,0x06,0x3C,
+0x84,0x00,0xC4,0x34,
+0x80,0x00,0xC6,0x34,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0xC4,0x8C,
+0x02,0x80,0x08,0x3C,
+0x21,0x10,0x00,0x00,
+0x1C,0x5F,0x06,0x8D,
+0x25,0x10,0x44,0x00,
+0x02,0x80,0x04,0x3C,
+0x20,0x5F,0x88,0x8C,
+0x24,0x5F,0x89,0x8C,
+0x00,0x00,0x65,0x91,
+0x21,0x10,0x46,0x00,
+0xFB,0xFF,0x04,0x24,
+0x24,0x28,0xA4,0x00,
+0x23,0x40,0x02,0x01,
+0x00,0x00,0x65,0xA1,
+0x04,0x00,0x00,0x11,
+0x01,0x00,0x06,0x24,
+0x80,0x10,0x08,0x00,
+0x21,0x10,0x48,0x00,
+0x80,0x30,0x02,0x00,
+0x01,0x00,0x04,0x24,
+0x8C,0x23,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x04,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x44,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x64,0x90,
+0x01,0x00,0x05,0x24,
+0x64,0x31,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x30,0x1F,0x24,0x26,
+0xE0,0x1B,0x83,0x94,
+0xDC,0x1B,0x85,0x94,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x80,0x00,0x63,0x30,
+0x41,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0x08,0x00,0x42,0x34,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA4,
+0x08,0x00,0xE0,0x03,
+0xDC,0x1B,0x83,0xA4,
+0xB0,0x1B,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x16,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x15,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xAB,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x15,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x15,0x5F,0x62,0xA0,
+0x0B,0x01,0x00,0x08,
+0x30,0x1F,0x24,0x26,
+0x0C,0x5F,0x40,0xA0,
+0x44,0x01,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x80,0xFF,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x9E,0x25,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0x00,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x15,0x5F,0x40,0xA0,
+0x0B,0x01,0x00,0x08,
+0x30,0x1F,0x24,0x26,
+0xFF,0x00,0x84,0x30,
+0x0B,0x00,0x82,0x2C,
+0xFF,0xFF,0xE7,0x30,
+0x10,0x00,0xA8,0x93,
+0x19,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x04,0x00,
+0xD8,0xE9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x43,0xB0,0x02,0x3C,
+0x78,0x00,0x44,0x34,
+0x07,0x00,0xE2,0x30,
+0x00,0x00,0x85,0xAC,
+0x04,0x00,0x86,0xAC,
+0x04,0x00,0x40,0x18,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0xE2,0x30,
+0x08,0x00,0x42,0x24,
+0xFF,0xFF,0x47,0x30,
+0x21,0x10,0xE8,0x00,
+0x00,0x80,0x03,0x3C,
+0x08,0x00,0x82,0xAC,
+0x25,0x10,0x43,0x00,
+0x08,0x00,0x82,0xAC,
+0x01,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x6C,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x60,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x54,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x48,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x3C,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x30,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x24,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x18,0x00,0x44,0x34,
+0x43,0xB0,0x02,0x3C,
+0x83,0x01,0x00,0x08,
+0x0C,0x00,0x44,0x34,
+0x83,0x01,0x00,0x08,
+0x43,0xB0,0x04,0x3C,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0xC0,0x06,0x63,0x24,
+0x00,0x00,0x43,0xAC,
+0x01,0x00,0x05,0x24,
+0x43,0xB0,0x02,0x3C,
+0x04,0x28,0x85,0x00,
+0x88,0x00,0x44,0x34,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0x05,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0x82,0x94,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x42,0x30,
+0x24,0x10,0x45,0x00,
+0xF5,0xFF,0x40,0x1C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x08,0x3C,
+0x00,0x80,0x02,0x3C,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x03,0x03,0x35,
+0x1C,0x07,0x42,0x24,
+0x00,0x00,0x62,0xAC,
+0x30,0x00,0xB6,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x0C,0x00,0xF2,0x84,
+0x08,0x00,0xF5,0x8C,
+0xFF,0x00,0xC6,0x30,
+0x00,0x01,0x02,0x24,
+0x23,0x10,0x46,0x00,
+0xFF,0xFF,0x51,0x30,
+0xD0,0x03,0x08,0x35,
+0xFF,0x00,0x96,0x30,
+0x00,0x00,0x12,0xAD,
+0x21,0xA0,0xA0,0x00,
+0x21,0x30,0xC5,0x00,
+0x00,0x00,0x15,0xAD,
+0x21,0x20,0xC0,0x02,
+0x21,0x28,0xA0,0x02,
+0x21,0x38,0x20,0x02,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x23,0x18,0x51,0x02,
+0xFF,0xFF,0x82,0x32,
+0x00,0x94,0x03,0x00,
+0x03,0x94,0x12,0x00,
+0x09,0x02,0x00,0x08,
+0x02,0x9A,0x02,0x00,
+0x28,0xB0,0x03,0x3C,
+0xC0,0x10,0x13,0x00,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x25,0xB0,0x10,0x3C,
+0x20,0x10,0x02,0x3C,
+0xFF,0x00,0x93,0x30,
+0x00,0x22,0x13,0x00,
+0xFF,0xFF,0x43,0x32,
+0x01,0x01,0x45,0x2A,
+0x21,0xA0,0x82,0x00,
+0x21,0xA8,0xB1,0x02,
+0xD0,0x03,0x02,0x36,
+0x00,0x01,0x11,0x24,
+0x0B,0x88,0x65,0x00,
+0x21,0x20,0xC0,0x02,
+0x00,0x00,0x53,0xAC,
+0xB0,0x01,0x00,0x0C,
+0xB0,0x03,0x10,0x36,
+0x21,0x30,0x80,0x02,
+0x21,0x20,0xC0,0x02,
+0x21,0x28,0xA0,0x02,
+0x21,0x38,0x20,0x02,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x23,0x18,0x51,0x02,
+0x00,0x94,0x03,0x00,
+0x03,0x94,0x12,0x00,
+0x00,0x00,0x12,0xAE,
+0xE2,0xFF,0x40,0x1E,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x04,0x00,0x8B,0x8C,
+0x21,0x80,0x80,0x00,
+0x08,0x00,0x84,0x8C,
+0x0E,0x00,0x07,0x96,
+0xFF,0xE0,0x02,0x3C,
+0x10,0x00,0x08,0x8E,
+0x1F,0x00,0x6A,0x31,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x00,0x1E,0x0A,0x00,
+0x25,0x48,0x83,0x00,
+0x21,0x90,0xA0,0x00,
+0x21,0x60,0xC0,0x00,
+0x10,0x01,0x00,0x05,
+0x07,0x00,0xE7,0x30,
+0x00,0x00,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0xFD,0x0F,0x42,0x28,
+0xC0,0x00,0x40,0x14,
+0x02,0x80,0x11,0x3C,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x48,0x22,0x01,
+0x1C,0x00,0x02,0x8E,
+0x00,0x40,0x03,0x3C,
+0x25,0x48,0x23,0x01,
+0x02,0x80,0x11,0x3C,
+0xC5,0x00,0x40,0x04,
+0x08,0x00,0x09,0xAE,
+0xC0,0x30,0x0A,0x00,
+0x21,0x10,0xCA,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x4A,0x00,
+0x80,0x10,0x02,0x00,
+0x30,0x1F,0x27,0x26,
+0x21,0x28,0x47,0x00,
+0x1C,0x24,0xA3,0x8C,
+0x01,0x00,0x0A,0x24,
+0x02,0x13,0x03,0x00,
+0x01,0x00,0x42,0x30,
+0xDB,0x00,0x4A,0x10,
+0x42,0x18,0x03,0x00,
+0x82,0x11,0x09,0x00,
+0x01,0x00,0x42,0x30,
+0x06,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0xC0,0xFF,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0x04,0x00,0x49,0x34,
+0x08,0x00,0x09,0xAE,
+0x02,0x80,0x02,0x3C,
+0xE9,0x5D,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x6C,0x00,0x60,0x14,
+0x21,0x28,0xC7,0x00,
+0xE8,0x22,0xA4,0x8C,
+0x10,0x00,0x02,0x8E,
+0xBF,0xFF,0x03,0x24,
+0x40,0x00,0x84,0x30,
+0x24,0x10,0x43,0x00,
+0x25,0x40,0x44,0x00,
+0x10,0x00,0x08,0xAE,
+0xE8,0x22,0xA3,0x8C,
+0x7F,0xF8,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x80,0x07,0x63,0x30,
+0x42,0x27,0x09,0x00,
+0x25,0x40,0x43,0x00,
+0x01,0x00,0x84,0x30,
+0xE1,0x00,0x8A,0x10,
+0x10,0x00,0x08,0xAE,
+0x30,0x1F,0x24,0x26,
+0x21,0x20,0xC4,0x00,
+0xE8,0x22,0x83,0x8C,
+0xFF,0xF7,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x00,0x08,0x63,0x30,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xE8,0x22,0x83,0x8C,
+0xFF,0xEF,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x00,0x10,0x63,0x30,
+0x30,0x1F,0x25,0x26,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0x21,0x30,0xC5,0x00,
+0xE8,0x22,0xC4,0x8C,
+0xFD,0xFF,0x02,0x3C,
+0x02,0x00,0x03,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x83,0x00,
+0x24,0x10,0x02,0x01,
+0x25,0x40,0x44,0x00,
+0x10,0x00,0x08,0xAE,
+0xB0,0x1B,0xA3,0x94,
+0xFB,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC2,0x1B,0x03,0x00,
+0x24,0x10,0x02,0x01,
+0x80,0x1C,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0x8F,0x3E,0xA3,0x90,
+0xE7,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x03,0x00,0x63,0x30,
+0x24,0x10,0x02,0x01,
+0xC0,0x1C,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xE8,0x22,0xC4,0x8C,
+0xFF,0xFD,0x02,0x3C,
+0x00,0x02,0x03,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x83,0x00,
+0x24,0x10,0x02,0x01,
+0x25,0x40,0x44,0x00,
+0x10,0x00,0x08,0xAE,
+0xB0,0x1B,0xA3,0x94,
+0xFF,0xFB,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC2,0x1B,0x03,0x00,
+0x24,0x10,0x02,0x01,
+0x80,0x1E,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0x8F,0x3E,0xA3,0x90,
+0xFF,0xE7,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x03,0x00,0x63,0x30,
+0x24,0x10,0x02,0x01,
+0xC0,0x1E,0x03,0x00,
+0x25,0x40,0x43,0x00,
+0x10,0x00,0x08,0xAE,
+0xE8,0x22,0xC3,0x8C,
+0xC0,0xFF,0x02,0x24,
+0x24,0x10,0x02,0x01,
+0x3F,0x00,0x63,0x30,
+0x25,0x10,0x43,0x00,
+0x10,0x00,0x02,0xAE,
+0xEC,0x22,0xC5,0x8C,
+0x14,0x00,0x03,0x8E,
+0xFF,0xFF,0x04,0x3C,
+0xFF,0x7F,0x84,0x34,
+0x24,0x18,0x64,0x00,
+0x00,0x80,0xA5,0x30,
+0x25,0x18,0x65,0x00,
+0x14,0x00,0x03,0xAE,
+0xEC,0x22,0xC2,0x8C,
+0x24,0x18,0x64,0x00,
+0x00,0x80,0x42,0x30,
+0x25,0x18,0x62,0x00,
+0x14,0x00,0x03,0xAE,
+0xEE,0x22,0xC4,0x94,
+0xE0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x1F,0x00,0x84,0x30,
+0x24,0x18,0x62,0x00,
+0x00,0x24,0x04,0x00,
+0x25,0x18,0x64,0x00,
+0x14,0x00,0x03,0xAE,
+0x02,0x00,0x02,0x92,
+0x02,0x24,0x0B,0x00,
+0x02,0x80,0x03,0x3C,
+0x21,0x10,0x4C,0x00,
+0xFF,0xFF,0x42,0x30,
+0x01,0x00,0x84,0x30,
+0x6A,0x00,0x80,0x10,
+0x25,0x30,0x43,0x00,
+0x30,0x1F,0x23,0x26,
+0xF8,0x1D,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0xFF,0x0F,0x45,0x30,
+0x01,0x00,0x42,0x24,
+0xF8,0x1D,0x62,0xA4,
+0x0C,0x00,0x03,0x8E,
+0x00,0xF0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x00,0x24,0x05,0x00,
+0x24,0x18,0x62,0x00,
+0x25,0x18,0x64,0x00,
+0x0C,0x00,0x03,0xAE,
+0x16,0x00,0xC2,0x94,
+0x00,0x19,0x05,0x00,
+0x02,0x00,0x04,0x24,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x16,0x00,0xC2,0xA4,
+0x21,0x28,0x80,0x01,
+0x21,0x30,0x40,0x02,
+0x80,0x00,0x07,0x24,
+0x01,0x00,0x02,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x52,0xAC,
+0xB0,0x01,0x00,0x0C,
+0x02,0x00,0x04,0x24,
+0x30,0x1F,0x24,0x26,
+0x00,0x00,0x03,0x96,
+0x94,0x3E,0x82,0x8C,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x43,0x00,
+0x28,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x94,0x3E,0x82,0xAC,
+0x08,0x00,0x09,0xAE,
+0x30,0x1F,0x22,0x26,
+0x1A,0x3E,0x43,0x90,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x07,0x18,0xE3,0x00,
+0x01,0x00,0x63,0x30,
+0x24,0x10,0x22,0x01,
+0x40,0x1F,0x03,0x00,
+0x25,0x48,0x43,0x00,
+0x1C,0x00,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x3D,0xFF,0x41,0x04,
+0x08,0x00,0x09,0xAE,
+0x1E,0x00,0x02,0x92,
+0x04,0x00,0x03,0x24,
+0x21,0x30,0x50,0x00,
+0x00,0x00,0xC4,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x82,0x30,
+0x02,0x29,0x02,0x00,
+0x50,0x00,0xA3,0x10,
+0x06,0x00,0x02,0x24,
+0x32,0xFF,0xA2,0x14,
+0x00,0x00,0x00,0x00,
+0x1A,0x00,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x39,0x00,0xC2,0xA0,
+0x1E,0x00,0x03,0x92,
+0x1A,0x00,0x02,0x96,
+0x21,0x18,0x70,0x00,
+0x03,0x12,0x02,0x00,
+0x38,0x00,0x62,0xA0,
+0x04,0x00,0x0B,0x8E,
+0x08,0x00,0x09,0x8E,
+0xC0,0x30,0x0A,0x00,
+0x21,0x10,0xCA,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x4A,0x00,
+0x80,0x10,0x02,0x00,
+0x30,0x1F,0x27,0x26,
+0x21,0x28,0x47,0x00,
+0x1C,0x24,0xA3,0x8C,
+0x01,0x00,0x0A,0x24,
+0x02,0x13,0x03,0x00,
+0x01,0x00,0x42,0x30,
+0x29,0xFF,0x4A,0x14,
+0x82,0x11,0x09,0x00,
+0x42,0x18,0x03,0x00,
+0x7F,0xFF,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0x80,0x00,0x63,0x30,
+0x25,0x48,0x43,0x00,
+0x08,0x00,0x09,0xAE,
+0x1C,0x24,0xA3,0x8C,
+0x10,0x00,0x04,0x8E,
+0xFF,0xFF,0x02,0x3C,
+0x07,0x00,0x63,0x30,
+0xFF,0x1F,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x40,0x1B,0x03,0x00,
+0x25,0x40,0x83,0x00,
+0x44,0x02,0x00,0x08,
+0x10,0x00,0x08,0xAE,
+0x0E,0x00,0x02,0x96,
+0x30,0x1F,0x23,0x26,
+0x07,0x00,0x42,0x30,
+0x40,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0xE8,0x1D,0x44,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x83,0x24,
+0xFF,0x0F,0x85,0x30,
+0xCA,0x02,0x00,0x08,
+0xE8,0x1D,0x43,0xA4,
+0x14,0x00,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x42,0x12,0x02,0x00,
+0x3F,0x00,0x42,0x30,
+0x0C,0x00,0x42,0x28,
+0xF1,0xFE,0x40,0x14,
+0xFF,0xDF,0x02,0x3C,
+0x29,0x02,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xE6,0x5D,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x1D,0xFF,0x64,0x14,
+0x30,0x1F,0x24,0x26,
+0x90,0x3E,0xE2,0x90,
+0xFF,0xF7,0x03,0x24,
+0x24,0x18,0x03,0x01,
+0x01,0x00,0x42,0x30,
+0xC0,0x12,0x02,0x00,
+0x25,0x40,0x62,0x00,
+0x10,0x00,0x08,0xAE,
+0x91,0x3E,0xE2,0x90,
+0xFF,0xEF,0x03,0x24,
+0x24,0x18,0x03,0x01,
+0x01,0x00,0x42,0x30,
+0x6D,0x02,0x00,0x08,
+0x00,0x13,0x02,0x00,
+0x1A,0x00,0x05,0x96,
+0x0F,0x00,0x84,0x30,
+0x80,0x20,0x04,0x00,
+0x21,0x18,0xC4,0x00,
+0x11,0x00,0x65,0xA0,
+0x1E,0x00,0x02,0x92,
+0x1A,0x00,0x03,0x96,
+0x21,0x10,0x50,0x00,
+0x21,0x10,0x44,0x00,
+0x03,0x1A,0x03,0x00,
+0x10,0x00,0x43,0xA0,
+0x04,0x00,0x0B,0x8E,
+0x08,0x00,0x09,0x8E,
+0x11,0x03,0x00,0x08,
+0xC0,0x30,0x0A,0x00,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x88,0x0D,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x00,0x80,0x02,0x3C,
+0xC0,0xFF,0xBD,0x27,
+0x18,0x03,0x83,0x34,
+0xA4,0x0D,0x42,0x24,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x34,0x00,0xB7,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x02,0x3C,
+0xB0,0x03,0x9E,0x34,
+0x98,0x03,0x00,0x08,
+0x30,0x1F,0x55,0x24,
+0x08,0x00,0x04,0xAE,
+0x14,0x37,0x46,0x8E,
+0x21,0x28,0x60,0x02,
+0x80,0x00,0x07,0x24,
+0x01,0x00,0x04,0x24,
+0x01,0x00,0x14,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xB4,0xAF,
+0x14,0x37,0x43,0x8E,
+0x01,0x00,0x04,0x24,
+0x00,0x00,0xC3,0xAE,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0x1C,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x5F,0x00,0x40,0x10,
+0x2A,0xB0,0x02,0x3C,
+0x09,0x00,0x42,0x34,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x54,0xA0,
+0x00,0x00,0x43,0xA0,
+0xFF,0x00,0x03,0x24,
+0x74,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0x10,0x37,0xA2,0x8E,
+0x7C,0x37,0xB3,0x8E,
+0x01,0x00,0x04,0x24,
+0x00,0x00,0xC2,0xAF,
+0x14,0x37,0xA2,0xAE,
+0x00,0x00,0xD3,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x7C,0x37,0xA4,0x8E,
+0x80,0x37,0xA3,0x8E,
+0x02,0x80,0x02,0x3C,
+0x04,0xEA,0x42,0x24,
+0x00,0x00,0x52,0x8C,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x7C,0x37,0xA3,0xAE,
+0x02,0x80,0x03,0x3C,
+0x08,0xEA,0x63,0x24,
+0x7C,0x37,0x42,0x8E,
+0x00,0x00,0x76,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0xAE,
+0x02,0x80,0x17,0x3C,
+0xFF,0xFF,0x62,0x32,
+0x25,0x80,0x57,0x00,
+0x00,0x00,0xD0,0xAE,
+0x0C,0x00,0x02,0x92,
+0x21,0x28,0x00,0x00,
+0x00,0x00,0xC2,0xAE,
+0x02,0x00,0x04,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x93,0x00,
+0xFF,0xFF,0x84,0x30,
+0xFB,0x60,0x00,0x0C,
+0x25,0x20,0x97,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0x01,0x00,0x04,0x24,
+0x00,0x1A,0x11,0x00,
+0x21,0x18,0x62,0x00,
+0xFF,0x00,0x02,0x24,
+0x21,0x30,0x60,0x00,
+0x06,0x00,0x22,0x12,
+0x80,0x00,0x07,0x24,
+0x7C,0x37,0x45,0x8E,
+0x10,0x37,0x43,0xAE,
+0xB4,0x36,0x51,0xA2,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x04,0x00,0x04,0x8E,
+0x08,0x00,0x03,0x8E,
+0xFF,0xE0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x1F,0x00,0x84,0x30,
+0x24,0x18,0x62,0x00,
+0x00,0x26,0x04,0x00,
+0xFF,0xDF,0x02,0x3C,
+0x25,0x18,0x64,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x40,0x04,0x3C,
+0x25,0x18,0x64,0x00,
+0xC0,0xFF,0x05,0x24,
+0x82,0x11,0x03,0x00,
+0x24,0x20,0x65,0x00,
+0x01,0x00,0x42,0x30,
+0xA3,0xFF,0x40,0x10,
+0x04,0x00,0x84,0x34,
+0x08,0x00,0x03,0xAE,
+0x14,0x37,0x46,0x8E,
+0x21,0x28,0x60,0x02,
+0x80,0x00,0x07,0x24,
+0x01,0x00,0x04,0x24,
+0x01,0x00,0x14,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xB4,0xAF,
+0x14,0x37,0x43,0x8E,
+0x01,0x00,0x04,0x24,
+0x00,0x00,0xC3,0xAE,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0x1C,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0xA3,0xFF,0x40,0x14,
+0x2A,0xB0,0x02,0x3C,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x2A,0x1C,0x54,0xA2,
+0x02,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x53,0x00,
+0xFF,0xFF,0x42,0x30,
+0x25,0x10,0x57,0x00,
+0x02,0x00,0x43,0x94,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x64,0x30,
+0x00,0xC0,0x84,0x24,
+0xFF,0xFF,0x84,0x30,
+0xC2,0x34,0x00,0x0C,
+0x2B,0x1C,0x43,0xA2,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x2A,0xB0,0x02,0x3C,
+0x09,0x00,0x42,0x34,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x54,0xA0,
+0x00,0x00,0x43,0xA0,
+0xFF,0x00,0x03,0x24,
+0x8E,0xFF,0x23,0x16,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x62,0x24,
+0xD0,0x1B,0x43,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x00,0x38,0x63,0x34,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x83,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0x43,0xAC,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x88,0x10,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0xCC,0x5E,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0xA4,0x10,0x63,0x24,
+0x40,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0x7F,0x00,0xA2,0x30,
+0xBF,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0xCC,0x5E,0xC2,0xA0,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x1E,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x30,0x1F,0xD3,0x27,
+0xB0,0x03,0x55,0x34,
+0x6A,0x04,0x00,0x08,
+0x02,0x80,0x16,0x3C,
+0x90,0x36,0x91,0xA2,
+0x30,0x1F,0xC2,0x27,
+0xC8,0x36,0x46,0x8C,
+0x34,0x37,0x45,0x8C,
+0x03,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x30,0x1F,0xD4,0x27,
+0xCC,0x36,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0x15,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x07,0x3C,
+0x0D,0x00,0xE2,0x34,
+0x04,0x00,0x43,0x24,
+0x0B,0x10,0x77,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x44,0xA0,
+0x00,0x00,0x43,0xA0,
+0x1A,0x5E,0xC4,0x96,
+0x25,0xB0,0x06,0x3C,
+0x66,0x03,0xC5,0x34,
+0x01,0x00,0x84,0x24,
+0x1A,0x5E,0xC4,0xA6,
+0x1A,0x5E,0xC2,0x96,
+0xFF,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xA4,
+0x2F,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xC8,0x36,0x62,0x8E,
+0x34,0x37,0x72,0x8E,
+0x03,0x00,0x04,0x24,
+0x00,0x00,0xA2,0xAE,
+0xCC,0x36,0x62,0xAE,
+0x00,0x00,0xB2,0xAE,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x34,0x37,0x64,0x8E,
+0x38,0x37,0x63,0x8E,
+0x02,0x80,0x02,0x3C,
+0x0C,0xEA,0x42,0x24,
+0x00,0x00,0x54,0x8C,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x34,0x37,0x63,0xAE,
+0x34,0x37,0x82,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x00,0x00,0xB0,0xAE,
+0x0C,0x00,0x02,0x92,
+0x01,0x00,0x05,0x24,
+0x00,0x00,0xA2,0xAE,
+0x02,0x00,0x04,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0xFB,0x60,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0xFF,0x00,0x03,0x24,
+0x00,0x22,0x11,0x00,
+0xC2,0xFF,0x23,0x12,
+0x21,0x20,0x82,0x00,
+0xB8,0xFF,0xE0,0x16,
+0xC8,0x36,0x84,0xAE,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x4C,0x04,0x00,0x08,
+0x8C,0x36,0x51,0xA0,
+0x21,0x00,0xE0,0x12,
+0x40,0x00,0xE4,0x34,
+0x90,0x36,0x83,0x92,
+0x41,0x00,0xE4,0x34,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA4,0x8C,
+0x01,0x00,0x02,0x3C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x00,0x80,0x42,0x34,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0x8C,0x36,0x83,0x92,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA4,0x8C,
+0x01,0x00,0x02,0x3C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x00,0x80,0x42,0x34,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0xCC,0x5E,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x64,0x13,0x63,0x24,
+0x10,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0xDF,0x00,0xA2,0x30,
+0xEF,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0xCC,0x5E,0xC2,0xA0,
+0xCC,0x5E,0xC3,0x90,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x00,0x00,0x43,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x1E,0x3C,
+0x30,0x1F,0xD3,0x27,
+0x21,0xA8,0x40,0x00,
+0x1E,0x05,0x00,0x08,
+0x02,0x80,0x16,0x3C,
+0x98,0x36,0x91,0xA2,
+0x30,0x1F,0xC2,0x27,
+0xD4,0x36,0x46,0x8C,
+0x40,0x37,0x45,0x8C,
+0x04,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x30,0x1F,0xD4,0x27,
+0xD8,0x36,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0x15,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x07,0x3C,
+0x15,0x00,0xE2,0x34,
+0x04,0x00,0x43,0x24,
+0x0B,0x10,0x77,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x44,0xA0,
+0x00,0x00,0x43,0xA0,
+0x1A,0x5E,0xC4,0x96,
+0x25,0xB0,0x06,0x3C,
+0x66,0x03,0xC5,0x34,
+0x01,0x00,0x84,0x24,
+0x1A,0x5E,0xC4,0xA6,
+0x1A,0x5E,0xC2,0x96,
+0xFF,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xA4,
+0x2F,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xD4,0x36,0x62,0x8E,
+0x40,0x37,0x72,0x8E,
+0x04,0x00,0x04,0x24,
+0x00,0x00,0xA2,0xAE,
+0xD8,0x36,0x62,0xAE,
+0x00,0x00,0xB2,0xAE,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x40,0x37,0x64,0x8E,
+0x44,0x37,0x63,0x8E,
+0x02,0x80,0x02,0x3C,
+0x10,0xEA,0x42,0x24,
+0x00,0x00,0x54,0x8C,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x40,0x37,0x63,0xAE,
+0x40,0x37,0x82,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x00,0x00,0xB0,0xAE,
+0x0C,0x00,0x02,0x92,
+0x02,0x00,0x05,0x24,
+0x00,0x00,0xA2,0xAE,
+0x02,0x00,0x04,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0xFB,0x60,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0xFF,0x00,0x03,0x24,
+0x00,0x22,0x11,0x00,
+0xC2,0xFF,0x23,0x12,
+0x21,0x20,0x82,0x00,
+0xB8,0xFF,0xE0,0x16,
+0xD4,0x36,0x84,0xAE,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x00,0x05,0x00,0x08,
+0x94,0x36,0x51,0xA0,
+0x20,0x00,0xE0,0x12,
+0x42,0x00,0xE4,0x34,
+0x98,0x36,0x83,0x92,
+0x43,0x00,0xE4,0x34,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA2,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x06,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x94,0x36,0x83,0x92,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA2,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x06,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0xCC,0x5E,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x2C,0x16,0x63,0x24,
+0x01,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0xF7,0x00,0xA2,0x30,
+0xFE,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0xCC,0x5E,0xC2,0xA0,
+0xCC,0x5E,0xC3,0x90,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x1E,0x3C,
+0x30,0x1F,0xD3,0x27,
+0x21,0xA8,0x40,0x00,
+0xCF,0x05,0x00,0x08,
+0x02,0x80,0x16,0x3C,
+0xA8,0x36,0x91,0xA2,
+0x30,0x1F,0xC2,0x27,
+0xE0,0x36,0x46,0x8C,
+0x4C,0x37,0x45,0x8C,
+0x05,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x30,0x1F,0xD4,0x27,
+0xE4,0x36,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0x15,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x07,0x3C,
+0x1D,0x00,0xE2,0x34,
+0x04,0x00,0x43,0x24,
+0x0B,0x10,0x77,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x44,0xA0,
+0x00,0x00,0x43,0xA0,
+0x1A,0x5E,0xC4,0x96,
+0x25,0xB0,0x06,0x3C,
+0x66,0x03,0xC5,0x34,
+0x01,0x00,0x84,0x24,
+0x1A,0x5E,0xC4,0xA6,
+0x1A,0x5E,0xC2,0x96,
+0xFF,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xA4,
+0x2F,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xE0,0x36,0x62,0x8E,
+0x4C,0x37,0x72,0x8E,
+0x05,0x00,0x04,0x24,
+0x00,0x00,0xA2,0xAE,
+0xE4,0x36,0x62,0xAE,
+0x00,0x00,0xB2,0xAE,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x4C,0x37,0x64,0x8E,
+0x50,0x37,0x63,0x8E,
+0x02,0x80,0x02,0x3C,
+0x14,0xEA,0x42,0x24,
+0x00,0x00,0x54,0x8C,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x4C,0x37,0x63,0xAE,
+0x4C,0x37,0x82,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x00,0x00,0xB0,0xAE,
+0x0C,0x00,0x02,0x92,
+0x08,0x00,0x05,0x24,
+0x00,0x00,0xA2,0xAE,
+0x02,0x00,0x04,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0xFB,0x60,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0xFF,0x00,0x03,0x24,
+0x00,0x22,0x11,0x00,
+0xC2,0xFF,0x23,0x12,
+0x21,0x20,0x82,0x00,
+0xB8,0xFF,0xE0,0x16,
+0xE0,0x36,0x84,0xAE,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0xB1,0x05,0x00,0x08,
+0x9C,0x36,0x51,0xA0,
+0x20,0x00,0xE0,0x12,
+0x44,0x00,0xE4,0x34,
+0xA8,0x36,0x83,0x92,
+0x45,0x00,0xE4,0x34,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA2,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x18,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x9C,0x36,0x83,0x92,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA2,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x18,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB7,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x06,0x3C,
+0xCC,0x5E,0xC5,0x90,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0xF0,0x18,0x63,0x24,
+0x02,0x00,0xA4,0x30,
+0x00,0x00,0x43,0xAC,
+0x21,0xB8,0x00,0x00,
+0x03,0x00,0x80,0x10,
+0xFB,0x00,0xA2,0x30,
+0xFD,0x00,0xA2,0x30,
+0x01,0x00,0x17,0x24,
+0xCC,0x5E,0xC2,0xA0,
+0xCC,0x5E,0xC3,0x90,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x1E,0x3C,
+0x30,0x1F,0xD3,0x27,
+0x21,0xA8,0x40,0x00,
+0x80,0x06,0x00,0x08,
+0x02,0x80,0x16,0x3C,
+0xA4,0x36,0x91,0xA2,
+0x30,0x1F,0xC2,0x27,
+0xEC,0x36,0x46,0x8C,
+0x58,0x37,0x45,0x8C,
+0x06,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x30,0x1F,0xD4,0x27,
+0xF0,0x36,0x85,0x8E,
+0x21,0x20,0x00,0x02,
+0x15,0x02,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x2A,0xB0,0x07,0x3C,
+0x25,0x00,0xE2,0x34,
+0x04,0x00,0x43,0x24,
+0x0B,0x10,0x77,0x00,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x44,0xA0,
+0x00,0x00,0x43,0xA0,
+0x1A,0x5E,0xC4,0x96,
+0x25,0xB0,0x06,0x3C,
+0x66,0x03,0xC5,0x34,
+0x01,0x00,0x84,0x24,
+0x1A,0x5E,0xC4,0xA6,
+0x1A,0x5E,0xC2,0x96,
+0xFF,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xA4,
+0x2F,0x00,0x23,0x12,
+0x00,0x00,0x00,0x00,
+0xEC,0x36,0x62,0x8E,
+0x58,0x37,0x72,0x8E,
+0x06,0x00,0x04,0x24,
+0x00,0x00,0xA2,0xAE,
+0xF0,0x36,0x62,0xAE,
+0x00,0x00,0xB2,0xAE,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x58,0x37,0x64,0x8E,
+0x5C,0x37,0x63,0x8E,
+0x02,0x80,0x02,0x3C,
+0x18,0xEA,0x42,0x24,
+0x00,0x00,0x54,0x8C,
+0x80,0x00,0x84,0x24,
+0xFF,0x00,0x62,0x24,
+0x2B,0x10,0x44,0x00,
+0x0A,0x18,0x82,0x00,
+0x58,0x37,0x63,0xAE,
+0x58,0x37,0x82,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xAE,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x42,0x32,
+0x25,0x80,0x43,0x00,
+0x00,0x00,0xB0,0xAE,
+0x0C,0x00,0x02,0x92,
+0x04,0x00,0x05,0x24,
+0x00,0x00,0xA2,0xAE,
+0x02,0x00,0x04,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x92,0x00,
+0xFF,0xFF,0x84,0x30,
+0xFB,0x60,0x00,0x0C,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0x11,0x92,
+0x20,0x10,0x02,0x3C,
+0xFF,0x00,0x03,0x24,
+0x00,0x22,0x11,0x00,
+0xC2,0xFF,0x23,0x12,
+0x21,0x20,0x82,0x00,
+0xB8,0xFF,0xE0,0x16,
+0xEC,0x36,0x84,0xAE,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x62,0x06,0x00,0x08,
+0xA0,0x36,0x51,0xA0,
+0x20,0x00,0xE0,0x12,
+0x46,0x00,0xE4,0x34,
+0xA4,0x36,0x83,0x92,
+0x47,0x00,0xE4,0x34,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA2,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x60,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0xA0,0x36,0x83,0x92,
+0xB0,0x03,0xC5,0x34,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xA3,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA2,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x60,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xB4,0x1B,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x05,0x3C,
+0x30,0x1F,0xA5,0x24,
+0xD8,0x1B,0xA2,0x8C,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x08,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0x25,0xB0,0x04,0x3C,
+0x00,0x80,0x02,0x3C,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x03,0x83,0x34,
+0x10,0x1C,0x42,0x24,
+0x30,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x14,0x3C,
+0x30,0x1F,0x93,0x26,
+0xFC,0x00,0x82,0x34,
+0x00,0x00,0x45,0x8C,
+0xAC,0x1B,0x66,0x96,
+0xD8,0x37,0x63,0x96,
+0xD0,0x37,0x67,0x8E,
+0x23,0x28,0xA6,0x00,
+0x21,0x10,0xA3,0x00,
+0x23,0x88,0x47,0x00,
+0xB0,0x03,0x84,0x34,
+0x23,0x30,0x23,0x02,
+0x2B,0x10,0x71,0x00,
+0x00,0x00,0x83,0xAC,
+0x00,0x00,0x91,0xAC,
+0x0B,0x88,0xC2,0x00,
+0x21,0x20,0x20,0x02,
+0x25,0x24,0x00,0x0C,
+0xD4,0x37,0x65,0xAE,
+0x4B,0x00,0x40,0x10,
+0x21,0x90,0x40,0x00,
+0x0C,0x00,0x51,0xAC,
+0xD0,0x37,0x68,0x8E,
+0xD4,0x37,0x62,0x8E,
+0x08,0x00,0x45,0x8E,
+0x20,0xBD,0x03,0x3C,
+0x88,0x03,0x63,0x34,
+0x2B,0x10,0x48,0x00,
+0x40,0x10,0x15,0x3C,
+0x21,0x20,0x00,0x00,
+0xFF,0xFF,0x27,0x32,
+0x00,0x00,0x65,0xAC,
+0x28,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xAC,0x1B,0x66,0x96,
+0x08,0x00,0x42,0x96,
+0x40,0x10,0x05,0x3C,
+0x21,0x20,0x00,0x00,
+0x21,0x30,0x06,0x01,
+0x25,0x28,0x45,0x00,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x64,0x57,0x42,0x24,
+0x30,0x1F,0x84,0x26,
+0xD4,0x37,0x83,0x8C,
+0x04,0x00,0x45,0x8C,
+0xD0,0x37,0x83,0xAC,
+0x00,0x00,0x42,0xAE,
+0x04,0x00,0x52,0xAC,
+0x00,0x00,0xB2,0xAC,
+0x04,0x00,0x45,0xAE,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0x85,0x26,
+0xD8,0x1B,0xA2,0x8C,
+0xD0,0x1B,0xA3,0x8C,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x04,0x00,0x42,0x30,
+0x25,0x18,0x62,0x00,
+0x41,0xB0,0x04,0x3C,
+0x38,0x00,0xBD,0x27,
+0x00,0x00,0x83,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA3,0xAC,
+0xD8,0x37,0x70,0x8E,
+0x08,0x00,0x45,0x96,
+0xAC,0x1B,0x66,0x96,
+0x23,0x80,0x08,0x02,
+0xFF,0xFF,0x10,0x32,
+0x21,0x30,0x06,0x01,
+0x25,0x28,0xB5,0x00,
+0x21,0x38,0x00,0x02,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x08,0x00,0x45,0x96,
+0xAC,0x1B,0x62,0x96,
+0x23,0x38,0x30,0x02,
+0x25,0x28,0xB5,0x00,
+0x21,0x10,0x06,0x3C,
+0x21,0x28,0xB0,0x00,
+0x21,0x30,0x46,0x00,
+0xFF,0xFF,0xE7,0x30,
+0x3C,0x07,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x00,0x60,0x02,0x40,
+0x01,0x00,0x41,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x04,0x3C,
+0xD0,0x5E,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x63,0x34,
+0xD0,0x5E,0x83,0xAC,
+0x00,0x60,0x82,0x40,
+0x48,0x07,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x00,0x80,0x02,0x3C,
+0xC0,0xFF,0xBD,0x27,
+0x18,0x03,0x83,0x34,
+0xFC,0x1D,0x42,0x24,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x34,0x00,0xB7,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x1E,0x3C,
+0x02,0x80,0x02,0x3C,
+0x2A,0xB0,0x03,0x3C,
+0xB0,0x03,0x96,0x34,
+0x80,0xD5,0x57,0x24,
+0x2C,0x00,0x73,0x34,
+0x30,0x1F,0xD1,0x27,
+0x02,0x80,0x15,0x3C,
+0xD1,0x07,0x00,0x08,
+0x02,0x80,0x14,0x3C,
+0x54,0xF3,0x90,0xAE,
+0x02,0x80,0x04,0x3C,
+0x03,0x00,0xC3,0x90,
+0x7C,0xD5,0x82,0x90,
+0x7F,0x00,0x63,0x30,
+0xFF,0x00,0x42,0x30,
+0x6B,0x00,0x62,0x10,
+0x08,0x00,0x10,0x26,
+0x02,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x37,0x00,0x42,0x28,
+0x5E,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0xC5,0x90,
+0x03,0x00,0xC3,0x90,
+0xFF,0x00,0xA5,0x30,
+0x7F,0x00,0x63,0x30,
+0x7C,0xD5,0x83,0xA0,
+0x02,0x00,0xC2,0x90,
+0x0E,0x00,0xA5,0x38,
+0x0A,0x80,0xE5,0x00,
+0xFF,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x10,0x57,0x00,
+0x04,0x00,0x43,0x8C,
+0x02,0x80,0x04,0x3C,
+0x8C,0xD7,0x84,0x24,
+0x4C,0xF3,0xA3,0xAE,
+0x02,0x00,0xC5,0x90,
+0x2F,0x55,0x00,0x0C,
+0xFF,0x00,0xA5,0x30,
+0x4C,0xF3,0xA2,0x8E,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x40,0x00,
+0x21,0x20,0x00,0x02,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0x03,0x24,
+0x01,0x00,0x62,0xA2,
+0x01,0x00,0x63,0xA2,
+0x2B,0x00,0x40,0x12,
+0x00,0x00,0x00,0x00,
+0xB8,0x36,0x22,0x92,
+0x20,0x10,0x03,0x3C,
+0x88,0x37,0x25,0x8E,
+0x00,0x12,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x21,0x30,0x40,0x00,
+0x0A,0x00,0x04,0x24,
+0x00,0x01,0x07,0x24,
+0x1C,0x37,0x22,0xAE,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x88,0x37,0x30,0x8E,
+0xB0,0x01,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0xFF,0xFF,0x10,0x32,
+0x02,0x80,0x02,0x3C,
+0x25,0x80,0x02,0x02,
+0x0C,0x00,0x04,0x92,
+0xFF,0x00,0x02,0x24,
+0x21,0x38,0x00,0x02,
+0xFF,0x00,0x83,0x30,
+0x20,0x00,0x10,0x26,
+0x04,0x00,0x62,0x10,
+0x21,0x90,0x00,0x00,
+0xB8,0x36,0x24,0xA2,
+0x01,0x00,0x12,0x24,
+0x00,0x00,0xC3,0xAE,
+0x04,0x00,0xE2,0x8C,
+0x13,0x00,0x03,0x24,
+0x02,0x12,0x02,0x00,
+0x1F,0x00,0x45,0x30,
+0xB6,0xFF,0xA3,0x10,
+0x21,0x30,0x00,0x02,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x38,0xD7,0x84,0x24,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0x03,0x24,
+0x01,0x00,0x62,0xA2,
+0x01,0x00,0x63,0xA2,
+0xD7,0xFF,0x40,0x16,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA2,0x8C,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x00,0x04,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x41,0xB0,0x04,0x3C,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA2,0xAC,
+0x02,0x00,0xC5,0x90,
+0x02,0x80,0x04,0x3C,
+0x78,0xD7,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0xFF,0x00,0xA5,0x30,
+0xEB,0x07,0x00,0x08,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0xC5,0x90,
+0x02,0x00,0xC6,0x90,
+0x7C,0xD5,0x87,0x90,
+0x02,0x80,0x04,0x3C,
+0x48,0xD7,0x84,0x24,
+0xFF,0x00,0xA5,0x30,
+0xFF,0x00,0xC6,0x30,
+0x2F,0x55,0x00,0x0C,
+0xFF,0x00,0xE7,0x30,
+0xC1,0x07,0x00,0x08,
+0x01,0x00,0x02,0x24,
+0xC8,0xFF,0xBD,0x27,
+0xFF,0xFF,0xA8,0x30,
+0x02,0x80,0x02,0x3C,
+0x25,0x40,0x02,0x01,
+0x30,0x00,0xB6,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x03,0x8D,
+0xFF,0xFF,0xD2,0x30,
+0x21,0xB0,0xA0,0x00,
+0x00,0xC0,0x02,0x24,
+0x08,0x00,0x45,0x26,
+0x04,0x00,0x06,0x8D,
+0x24,0x18,0x62,0x00,
+0xFF,0x3F,0xA5,0x30,
+0xF0,0xFF,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x80,0x05,0x3C,
+0x25,0x18,0x65,0x00,
+0xFF,0x01,0xC6,0x34,
+0x00,0x00,0x03,0xAD,
+0x04,0x00,0x06,0xAD,
+0x21,0x48,0x80,0x00,
+0xFF,0xFF,0xE7,0x30,
+0x18,0x00,0x12,0xA5,
+0x1A,0x00,0x07,0xA1,
+0x18,0x00,0x03,0x8D,
+0xFF,0x7F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x02,0x80,0x15,0x3C,
+0x18,0x00,0x03,0xAD,
+0x30,0x1F,0xA5,0x26,
+0x7A,0x36,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x24,
+0x7A,0x36,0xA2,0xA0,
+0x18,0x00,0x04,0x8D,
+0xFF,0x80,0x02,0x3C,
+0x20,0x00,0x45,0x26,
+0xFF,0xFF,0x42,0x34,
+0x7F,0x00,0x63,0x30,
+0xFF,0xFF,0xB2,0x30,
+0x24,0x20,0x82,0x00,
+0x00,0x1E,0x03,0x00,
+0x25,0xB0,0x02,0x3C,
+0xC0,0x00,0x42,0x34,
+0x25,0x20,0x83,0x00,
+0x07,0x00,0x45,0x32,
+0x18,0x00,0x04,0xAD,
+0x00,0x00,0x52,0xA4,
+0x03,0x00,0xA0,0x10,
+0xFF,0xFF,0x42,0x32,
+0x08,0x00,0x42,0x26,
+0xFF,0xFF,0x42,0x30,
+0x30,0x1F,0xB4,0x26,
+0xF8,0x37,0x86,0x8E,
+0xFC,0x37,0x90,0x8E,
+0xF8,0xFF,0x52,0x30,
+0x21,0x10,0xD2,0x00,
+0x2B,0x10,0x02,0x02,
+0x31,0x00,0x40,0x10,
+0xFF,0x00,0x33,0x31,
+0x23,0x80,0x06,0x02,
+0x21,0x28,0xC0,0x02,
+0xFF,0xFF,0x07,0x32,
+0x01,0x00,0x11,0x24,
+0x21,0x20,0x60,0x02,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xB1,0xAF,
+0x23,0x18,0x50,0x02,
+0xFF,0xFF,0x72,0x30,
+0x22,0x10,0x02,0x3C,
+0x21,0x10,0x42,0x02,
+0x21,0x20,0x60,0x02,
+0xB0,0x01,0x00,0x0C,
+0xF8,0x37,0x82,0xAE,
+0x21,0x28,0xD0,0x02,
+0x21,0x38,0x40,0x02,
+0x21,0x20,0x60,0x02,
+0x10,0x00,0xB1,0xAF,
+0x22,0x10,0x06,0x3C,
+0x73,0x01,0x00,0x0C,
+0x30,0x1F,0xB1,0x26,
+0xF8,0x37,0x23,0x8E,
+0x25,0xB0,0x10,0x3C,
+0xB0,0x03,0x02,0x36,
+0x21,0x20,0x60,0x02,
+0x00,0x00,0x43,0xAC,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF8,0x37,0x25,0x8E,
+0xEC,0x00,0x02,0x36,
+0xBD,0x00,0x04,0x36,
+0x00,0x00,0x45,0xAC,
+0x00,0x00,0x83,0x90,
+0xC2,0x00,0x10,0x36,
+0x34,0x00,0xBF,0x8F,
+0x10,0x00,0x63,0x34,
+0x00,0x00,0x83,0xA0,
+0x30,0x00,0xB6,0x8F,
+0x00,0x00,0x05,0xA6,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x21,0x28,0xC0,0x02,
+0x21,0x20,0x60,0x02,
+0x21,0x38,0x40,0x02,
+0x01,0x00,0x02,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0xF8,0x37,0x83,0x8E,
+0x30,0x1F,0xB1,0x26,
+0x25,0xB0,0x10,0x3C,
+0x21,0x18,0x72,0x00,
+0xF8,0x37,0x83,0xAE,
+0xF8,0x37,0x23,0x8E,
+0xB0,0x03,0x02,0x36,
+0x21,0x20,0x60,0x02,
+0x00,0x00,0x43,0xAC,
+0xB0,0x01,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF8,0x37,0x25,0x8E,
+0xEC,0x00,0x02,0x36,
+0xBD,0x00,0x04,0x36,
+0x00,0x00,0x45,0xAC,
+0x00,0x00,0x83,0x90,
+0xC2,0x00,0x10,0x36,
+0x34,0x00,0xBF,0x8F,
+0x10,0x00,0x63,0x34,
+0x00,0x00,0x83,0xA0,
+0x30,0x00,0xB6,0x8F,
+0x00,0x00,0x05,0xA6,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x21,0x80,0x80,0x00,
+0x00,0x60,0x14,0x40,
+0x01,0x00,0x81,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x14,0x00,0x83,0x8C,
+0x02,0x80,0x15,0x3C,
+0x16,0x00,0x02,0x24,
+0x30,0x1F,0xB3,0x26,
+0x21,0x28,0x00,0x00,
+0x1D,0x00,0x62,0x10,
+0x08,0x00,0x06,0x24,
+0x08,0x00,0x82,0x94,
+0x02,0x80,0x04,0x3C,
+0x08,0x52,0x00,0x0C,
+0x25,0x20,0x44,0x00,
+0x08,0x00,0x05,0x8E,
+0x0C,0x00,0x06,0x96,
+0x14,0x00,0x07,0x96,
+0x19,0x08,0x00,0x0C,
+0x09,0x00,0x04,0x24,
+0x04,0x00,0x02,0x8E,
+0x00,0x00,0x03,0x8E,
+0x21,0x20,0x00,0x02,
+0x00,0x00,0x43,0xAC,
+0x04,0x00,0x62,0xAC,
+0x00,0x00,0x10,0xAE,
+0x3D,0x24,0x00,0x0C,
+0x04,0x00,0x10,0xAE,
+0x00,0x60,0x94,0x40,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xF8,0x37,0x68,0x8E,
+0x0C,0x00,0x11,0x8E,
+0xFC,0x37,0x62,0x8E,
+0x25,0xB0,0x03,0x3C,
+0x21,0x28,0x11,0x01,
+0xC0,0x00,0x63,0x34,
+0x23,0x90,0x48,0x00,
+0x2B,0x10,0x45,0x00,
+0x01,0x00,0x16,0x24,
+0x09,0x00,0x04,0x24,
+0xFF,0xFF,0x27,0x32,
+0x21,0x30,0x00,0x01,
+0x00,0x00,0x71,0xA4,
+0x33,0x00,0x40,0x10,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x05,0x8E,
+0xFF,0xFF,0x47,0x32,
+0x23,0x88,0x32,0x02,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xB6,0xAF,
+0x22,0x10,0x03,0x3C,
+0x21,0x18,0x23,0x02,
+0x09,0x00,0x04,0x24,
+0xB0,0x01,0x00,0x0C,
+0xF8,0x37,0x63,0xAE,
+0x08,0x00,0x05,0x8E,
+0xFF,0xFF,0x27,0x32,
+0x09,0x00,0x04,0x24,
+0x21,0x28,0xB2,0x00,
+0x22,0x10,0x06,0x3C,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xB6,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x09,0x00,0x04,0x24,
+0x30,0x1F,0xA2,0x26,
+0xF8,0x37,0x46,0x8C,
+0x25,0xB0,0x03,0x3C,
+0xEC,0x00,0x64,0x34,
+0x00,0x00,0x86,0xAC,
+0xBD,0x00,0x65,0x34,
+0x00,0x00,0xA2,0x90,
+0xC2,0x00,0x63,0x34,
+0x21,0x20,0x00,0x02,
+0x10,0x00,0x42,0x34,
+0x00,0x00,0xA2,0xA0,
+0x00,0x00,0x66,0xA4,
+0x04,0x00,0x02,0x8E,
+0x00,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xAC,
+0x04,0x00,0x62,0xAC,
+0x00,0x00,0x10,0xAE,
+0x3D,0x24,0x00,0x0C,
+0x04,0x00,0x10,0xAE,
+0x00,0x60,0x94,0x40,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x08,0x00,0x05,0x8E,
+0x21,0x30,0x00,0x01,
+0x09,0x00,0x04,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0xF8,0x37,0x63,0x8E,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x71,0x00,
+0x05,0x09,0x00,0x08,
+0xF8,0x37,0x63,0xAE,
+0xE8,0xFF,0xBD,0x27,
+0x14,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x28,0x80,0x00,
+0x00,0x60,0x10,0x40,
+0x01,0x00,0x01,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x25,0xB0,0x02,0x3C,
+0xBF,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x63,0x2C,
+0x05,0x00,0x60,0x10,
+0x02,0x80,0x06,0x3C,
+0x6C,0x57,0xC3,0x8C,
+0x6C,0x57,0xC2,0x24,
+0x0C,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x6C,0x57,0xC2,0x24,
+0x04,0x00,0x43,0x8C,
+0x00,0x00,0xA2,0xAC,
+0x04,0x00,0x45,0xAC,
+0x00,0x00,0x65,0xAC,
+0x04,0x00,0xA3,0xAC,
+0x00,0x60,0x90,0x40,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xB4,0x08,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x90,0x40,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x98,0xD7,0x84,0x24,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x2F,0x55,0x00,0x0C,
+0x14,0x00,0xB1,0xAF,
+0x00,0x00,0x04,0x96,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x83,0x24,
+0x07,0x00,0x62,0x30,
+0x49,0x00,0x40,0x10,
+0xC2,0x10,0x03,0x00,
+0x28,0x00,0x82,0x24,
+0xC2,0x10,0x02,0x00,
+0x25,0x24,0x00,0x0C,
+0xC0,0x20,0x02,0x00,
+0x47,0x00,0x40,0x10,
+0x21,0x88,0x40,0x00,
+0x02,0x80,0x12,0x3C,
+0x30,0x1F,0x50,0x26,
+0x1C,0x37,0x05,0x8E,
+0x0A,0x00,0x04,0x24,
+0x28,0x00,0x06,0x24,
+0xC7,0x01,0x00,0x0C,
+0x21,0x38,0x40,0x00,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x62,0x30,
+0x47,0x00,0x40,0x14,
+0x01,0x00,0x62,0x30,
+0x02,0x80,0x02,0x3C,
+0xEA,0x5D,0x48,0x90,
+0x25,0xB0,0x04,0x3C,
+0x2F,0x00,0x02,0x3C,
+0xD0,0x01,0x85,0x34,
+0x17,0x32,0x42,0x34,
+0x00,0x00,0xA2,0xAC,
+0x5E,0x00,0x03,0x3C,
+0x10,0x00,0x02,0x3C,
+0xDC,0x01,0x87,0x34,
+0xD4,0x01,0x86,0x34,
+0x17,0x43,0x63,0x34,
+0x20,0x53,0x42,0x34,
+0xD8,0x01,0x84,0x34,
+0x00,0x00,0xC3,0xAC,
+0x30,0x1F,0x49,0x26,
+0x00,0x00,0x82,0xAC,
+0x44,0xA4,0x03,0x34,
+0x01,0x00,0x02,0x24,
+0x00,0x00,0xE3,0xAC,
+0xEC,0x38,0x20,0xAD,
+0x08,0x39,0x20,0xAD,
+0x50,0x3E,0x20,0xAD,
+0x10,0x3E,0x20,0xAD,
+0x51,0x00,0x02,0x11,
+0x1A,0x3E,0x20,0xA1,
+0x10,0x23,0x22,0x8D,
+0xFF,0xF7,0x03,0x24,
+0xFF,0xEF,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x10,0x23,0x22,0xAD,
+0xB0,0x01,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0x08,0x00,0x22,0x96,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x04,0x3C,
+0x25,0x28,0x45,0x00,
+0xDC,0x01,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0x84,0x58,0x84,0x24,
+0x3D,0x24,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x30,0x1F,0x43,0x26,
+0x9C,0x39,0x62,0x8C,
+0xD1,0x11,0x00,0x0C,
+0x30,0x3B,0x62,0xA0,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x25,0x24,0x00,0x0C,
+0xC0,0x20,0x02,0x00,
+0xBB,0xFF,0x40,0x14,
+0x21,0x88,0x40,0x00,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0xA8,0xD7,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x1C,0xEA,0xA5,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x32,0x00,0x40,0x14,
+0x02,0x80,0x04,0x3C,
+0xA3,0x51,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x02,0x96,
+0x25,0xB0,0x03,0x3C,
+0x4C,0x00,0x63,0x34,
+0xFF,0xFE,0x42,0x30,
+0xB0,0x1B,0x02,0xA6,
+0x00,0x00,0x60,0xA0,
+0x02,0x80,0x02,0x3C,
+0xEA,0x5D,0x48,0x90,
+0x25,0xB0,0x04,0x3C,
+0x2F,0x00,0x02,0x3C,
+0xD0,0x01,0x85,0x34,
+0x17,0x32,0x42,0x34,
+0x00,0x00,0xA2,0xAC,
+0x5E,0x00,0x03,0x3C,
+0x10,0x00,0x02,0x3C,
+0xDC,0x01,0x87,0x34,
+0xD4,0x01,0x86,0x34,
+0x17,0x43,0x63,0x34,
+0x20,0x53,0x42,0x34,
+0xD8,0x01,0x84,0x34,
+0x00,0x00,0xC3,0xAC,
+0x30,0x1F,0x49,0x26,
+0x00,0x00,0x82,0xAC,
+0x44,0xA4,0x03,0x34,
+0x01,0x00,0x02,0x24,
+0x00,0x00,0xE3,0xAC,
+0xEC,0x38,0x20,0xAD,
+0x08,0x39,0x20,0xAD,
+0x50,0x3E,0x20,0xAD,
+0x10,0x3E,0x20,0xAD,
+0xB1,0xFF,0x02,0x15,
+0x1A,0x3E,0x20,0xA1,
+0x02,0x80,0x02,0x3C,
+0xEB,0x5D,0x44,0x90,
+0x02,0x00,0x03,0x24,
+0x06,0x00,0x83,0x10,
+0xFF,0xF7,0x03,0x24,
+0x10,0x23,0x22,0x8D,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x43,0x00,
+0x95,0x09,0x00,0x08,
+0x00,0x10,0x42,0x34,
+0x10,0x23,0x22,0x8D,
+0xFF,0xEF,0x03,0x24,
+0x00,0x08,0x42,0x34,
+0x95,0x09,0x00,0x08,
+0x24,0x10,0x43,0x00,
+0x88,0x58,0x84,0x24,
+0x6C,0x4C,0x00,0x0C,
+0x03,0x00,0x05,0x24,
+0xBE,0x09,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x02,0x80,0x12,0x3C,
+0x1C,0x00,0xB3,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x43,0x26,
+0xB0,0x1B,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x30,
+0x76,0x00,0x40,0x14,
+0x21,0x98,0x80,0x00,
+0x00,0x60,0x10,0x40,
+0x01,0x00,0x01,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x14,0x3C,
+0xF6,0x5E,0x82,0x92,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x74,0x00,0x40,0x14,
+0x04,0x00,0x04,0x24,
+0x00,0x60,0x90,0x40,
+0x30,0x1F,0x42,0x8E,
+0xFF,0xF0,0x03,0x24,
+0x0F,0xFF,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x25,0xB0,0x05,0x3C,
+0xF0,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x64,0x03,0xA4,0x34,
+0x17,0x00,0x03,0x24,
+0x00,0x00,0x80,0xA0,
+0x50,0x0C,0xA3,0xA0,
+0x30,0x1F,0x42,0xAE,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x25,0xB0,0x02,0x3C,
+0x17,0x00,0x03,0x24,
+0x58,0x0C,0x43,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x51,0x26,
+0xB0,0x1B,0x22,0x96,
+0x02,0x80,0x04,0x3C,
+0xB4,0xD7,0x84,0x24,
+0x00,0x10,0x42,0x34,
+0x2F,0x55,0x00,0x0C,
+0xB0,0x1B,0x22,0xA6,
+0x01,0x00,0x02,0x24,
+0x25,0xB0,0x03,0x3C,
+0x6C,0x3B,0x22,0xAE,
+0x4C,0x00,0x63,0x34,
+0x08,0x00,0x66,0x8E,
+0x00,0x00,0x67,0x90,
+0xB0,0x1B,0x22,0x96,
+0x30,0x3B,0x28,0x92,
+0x31,0x3B,0x29,0x92,
+0x8F,0x3E,0x2A,0x92,
+0x38,0x3B,0x2B,0x92,
+0x67,0x3B,0x2C,0x92,
+0x74,0x3B,0x26,0xAE,
+0x00,0x80,0x42,0x30,
+0xA1,0x3B,0x27,0xA2,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x60,0xA0,
+0x21,0x28,0x00,0x00,
+0x99,0x3B,0x28,0xA2,
+0x9A,0x3B,0x29,0xA2,
+0x9E,0x3B,0x22,0xA6,
+0xA0,0x3B,0x2A,0xA2,
+0x30,0x3B,0x2B,0xA2,
+0x31,0x3B,0x2C,0xA2,
+0xA4,0x3B,0x20,0xAE,
+0xA8,0x3B,0x20,0xAE,
+0x9C,0x3B,0x20,0xA2,
+0x12,0x0D,0x00,0x0C,
+0x9B,0x3B,0x20,0xA2,
+0x08,0x00,0x66,0x8E,
+0x00,0x00,0x00,0x00,
+0x33,0x00,0xC0,0x14,
+0x0C,0x00,0x70,0x26,
+0x00,0x00,0x62,0x8E,
+0x21,0x20,0x20,0x02,
+0xAC,0x3B,0x23,0x26,
+0x70,0x3B,0x22,0xAE,
+0x3F,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0x00,0x00,0x60,0xA0,
+0xFD,0xFF,0x41,0x04,
+0x07,0x00,0x63,0x24,
+0xB0,0x1B,0x83,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x62,0x30,
+0x09,0x00,0x40,0x10,
+0x30,0x1F,0x50,0x26,
+0x01,0x00,0x62,0x30,
+0x06,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x82,0x92,
+0x0C,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0x2C,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x30,0x3B,0x04,0x92,
+0x4F,0x0C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x48,0x00,0x84,0x34,
+0x00,0x00,0x83,0x8C,
+0x70,0x3B,0x05,0x8E,
+0x7B,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x01,0x00,0x02,0x24,
+0x00,0x00,0x83,0xAC,
+0x19,0x00,0xA2,0x10,
+0x3C,0x00,0x02,0x24,
+0x98,0x38,0x02,0xAE,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x64,0x31,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x0F,0x0A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x00,0x02,
+0x10,0x52,0x00,0x0C,
+0xA8,0x5A,0x84,0x24,
+0x02,0x80,0x04,0x3C,
+0xC4,0xD7,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0x54,0x0A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x13,0x0F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x3C,0x00,0x02,0x24,
+0x79,0x0A,0x00,0x08,
+0x98,0x38,0x02,0xAE,
+0xCD,0x4E,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x6A,0x0A,0x00,0x08,
+0x30,0x1F,0x50,0x26,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x00,0x00,0x02,0x92,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x40,0x00,
+0x03,0x00,0x42,0x2C,
+0x06,0x00,0x40,0x14,
+0xD0,0xD7,0x84,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x03,0x92,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x80,0x02,0x3C,
+0xA8,0x5C,0x43,0xAC,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xD0,0xFF,0xBD,0x27,
+0x18,0x03,0x42,0x34,
+0xC8,0x2A,0x63,0x24,
+0x24,0x00,0xB3,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x04,0x3C,
+0xF4,0x5E,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x12,0x00,0x40,0x10,
+0x02,0x80,0x13,0x3C,
+0x02,0x80,0x02,0x3C,
+0x0D,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x66,0x00,0x60,0x14,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x16,0x5F,0x44,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x64,0x90,
+0x01,0x00,0x05,0x24,
+0x64,0x31,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x02,0x80,0x02,0x3C,
+0x74,0x57,0x43,0x8C,
+0x74,0x57,0x42,0x24,
+0xA7,0x00,0x62,0x10,
+0x02,0x80,0x13,0x3C,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x2A,0xB0,0x02,0x3C,
+0x36,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x30,0x1F,0x66,0x26,
+0x00,0x38,0xC5,0x8C,
+0xC0,0x18,0x03,0x00,
+0x23,0xB0,0x04,0x3C,
+0xF0,0x07,0x63,0x30,
+0xFF,0x1F,0x02,0x3C,
+0x21,0x18,0x64,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x62,0x00,
+0x23,0x88,0x85,0x00,
+0x00,0x04,0x22,0x26,
+0x2B,0x28,0x85,0x00,
+0xA4,0x37,0xC3,0x8C,
+0x0B,0x88,0x45,0x00,
+0xE1,0x01,0x22,0x2E,
+0xA0,0x37,0xC3,0xAC,
+0x04,0x38,0xC4,0xAC,
+0xAA,0x37,0xC0,0xA4,
+0x14,0x00,0x40,0x14,
+0xA9,0x37,0xC0,0xA0,
+0x20,0xFE,0x82,0x24,
+0x20,0x02,0x83,0x24,
+0x0A,0x18,0x45,0x00,
+0x23,0x10,0x02,0x3C,
+0xFF,0x03,0x42,0x34,
+0x2B,0x10,0x43,0x00,
+0x21,0x28,0x60,0x00,
+0x34,0x00,0x40,0x14,
+0x00,0x38,0xC3,0xAC,
+0x04,0x38,0xC2,0x8C,
+0x00,0x00,0x00,0x00,
+0x2B,0x18,0x45,0x00,
+0x23,0x88,0x45,0x00,
+0x03,0x00,0x60,0x10,
+0xE1,0x01,0x22,0x2E,
+0x00,0x04,0x31,0x26,
+0xE1,0x01,0x22,0x2E,
+0x0E,0x00,0x40,0x10,
+0x30,0x1F,0x70,0x26,
+0x30,0x1F,0x70,0x26,
+0x04,0x38,0x03,0x8E,
+0x00,0x38,0x04,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x83,0x00,
+0x2E,0x00,0x40,0x14,
+0x2B,0x10,0x64,0x00,
+0x5A,0x00,0x40,0x14,
+0x25,0xB0,0x02,0x3C,
+0x80,0x00,0x03,0x24,
+0xD0,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x30,0x1F,0x70,0x26,
+0x00,0x38,0x03,0x96,
+0x2A,0xB0,0x02,0x3C,
+0x35,0x00,0x42,0x34,
+0xC2,0x88,0x03,0x00,
+0x00,0x00,0x51,0xA0,
+0x5D,0x27,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAA,0x37,0x03,0x96,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xD0,0x1B,0x02,0x8E,
+0x80,0x00,0x03,0x3C,
+0x41,0xB0,0x04,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x82,0xAC,
+0x28,0x00,0xBF,0x8F,
+0xD0,0x1B,0x02,0xAE,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x00,0xFC,0xA5,0x24,
+0xF6,0x0A,0x00,0x08,
+0x00,0x38,0xC5,0xAC,
+0x17,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9F,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x0D,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xCF,0x0A,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0xA0,0x37,0x05,0x8E,
+0x21,0x30,0x80,0x00,
+0xFF,0xFF,0x27,0x32,
+0x09,0x00,0x04,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xA0,0x37,0x03,0x8E,
+0xAA,0x37,0x05,0x96,
+0x00,0x38,0x02,0x8E,
+0x21,0x18,0x71,0x00,
+0x21,0x28,0x25,0x02,
+0x21,0x10,0x51,0x00,
+0x09,0x00,0x04,0x24,
+0x00,0x38,0x02,0xAE,
+0xA0,0x37,0x03,0xAE,
+0xB0,0x01,0x00,0x0C,
+0xAA,0x37,0x05,0xA6,
+0x30,0x1F,0x70,0x26,
+0x00,0x38,0x03,0x96,
+0x2A,0xB0,0x02,0x3C,
+0x35,0x00,0x42,0x34,
+0xC2,0x88,0x03,0x00,
+0x00,0x00,0x51,0xA0,
+0x5D,0x27,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xAA,0x37,0x03,0x96,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xD0,0x1B,0x02,0x8E,
+0x80,0x00,0x03,0x3C,
+0x41,0xB0,0x04,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x82,0xAC,
+0x28,0x00,0xBF,0x8F,
+0xD0,0x1B,0x02,0xAE,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x08,0x38,0x02,0x8E,
+0xA0,0x37,0x05,0x8E,
+0x21,0x30,0x80,0x00,
+0x23,0x88,0x44,0x00,
+0xFF,0xFF,0x27,0x32,
+0x09,0x00,0x04,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xA0,0x37,0x03,0x8E,
+0xAA,0x37,0x02,0x96,
+0x04,0x38,0x12,0x96,
+0x21,0x18,0x71,0x00,
+0x21,0x10,0x22,0x02,
+0x23,0x10,0x11,0x3C,
+0xA0,0x37,0x03,0xAE,
+0xAA,0x37,0x02,0xA6,
+0x15,0x00,0x40,0x16,
+0x00,0x38,0x11,0xAE,
+0x09,0x00,0x04,0x24,
+0xB0,0x01,0x00,0x0C,
+0x30,0x1F,0x70,0x26,
+0x46,0x0B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x17,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x57,0xFF,0x40,0x10,
+0x30,0x1F,0x63,0x26,
+0x2A,0x1C,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x53,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x50,0x39,0x64,0x94,
+0x2A,0x1C,0x60,0xA0,
+0x00,0xC0,0x84,0x24,
+0xC2,0x34,0x00,0x0C,
+0xFF,0xFF,0x84,0x30,
+0xD3,0x0A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xB0,0x01,0x00,0x0C,
+0x09,0x00,0x04,0x24,
+0xA0,0x37,0x05,0x8E,
+0x09,0x00,0x04,0x24,
+0x23,0x10,0x06,0x3C,
+0x21,0x38,0x40,0x02,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xA0,0x37,0x03,0x8E,
+0xAA,0x37,0x02,0x96,
+0x21,0x20,0x51,0x02,
+0x21,0x18,0x72,0x00,
+0x21,0x10,0x42,0x02,
+0x00,0x38,0x04,0xAE,
+0x09,0x00,0x04,0x24,
+0xA0,0x37,0x03,0xAE,
+0x75,0x0B,0x00,0x08,
+0xAA,0x37,0x02,0xA6,
+0xFF,0x00,0x86,0x30,
+0x02,0x80,0x02,0x3C,
+0x40,0x00,0xC3,0x2C,
+0x4A,0xF3,0x47,0x90,
+0x00,0x00,0x63,0x38,
+0x3F,0x00,0x02,0x24,
+0x0A,0x30,0x43,0x00,
+0x01,0x00,0x02,0x24,
+0x08,0x0E,0x04,0x24,
+0x00,0x7F,0x05,0x24,
+0x03,0x00,0xE2,0x10,
+0x31,0x00,0xC3,0x2C,
+0xA9,0x45,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x30,0x00,0x02,0x24,
+0xA9,0x45,0x00,0x08,
+0x0A,0x30,0x43,0x00,
+0xC0,0xFF,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x38,0x00,0xB4,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x28,0x00,0xB0,0xAF,
+0x28,0xEA,0x62,0x24,
+0x3C,0x00,0xBF,0xAF,
+0x0A,0x00,0x4A,0x94,
+0x02,0x00,0x48,0x94,
+0x06,0x00,0x49,0x94,
+0xFF,0x00,0x84,0x30,
+0xFF,0x00,0xA5,0x30,
+0x28,0xEA,0x6B,0x94,
+0x04,0x00,0x4C,0x94,
+0x08,0x00,0x4D,0x94,
+0x00,0x1C,0x05,0x00,
+0x00,0x14,0x04,0x00,
+0x00,0x3E,0x05,0x00,
+0x00,0x36,0x04,0x00,
+0x25,0x38,0xE3,0x00,
+0x25,0x30,0xC2,0x00,
+0x00,0x44,0x08,0x00,
+0x00,0x12,0x05,0x00,
+0x00,0x4C,0x09,0x00,
+0x00,0x54,0x0A,0x00,
+0x00,0x1A,0x04,0x00,
+0x25,0x38,0xE2,0x00,
+0x25,0x40,0x0B,0x01,
+0x25,0x48,0x2C,0x01,
+0x25,0x50,0x4D,0x01,
+0x25,0x30,0xC3,0x00,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xA8,0xAF,
+0x14,0x00,0xA9,0xAF,
+0x18,0x00,0xAA,0xAF,
+0x25,0x98,0xE5,0x00,
+0x25,0x90,0xC4,0x00,
+0x30,0x1F,0x54,0x24,
+0x21,0x80,0x00,0x00,
+0x10,0x00,0xB1,0x27,
+0x02,0x00,0x02,0x2E,
+0x32,0x00,0x40,0x10,
+0x80,0x10,0x10,0x00,
+0x21,0x10,0x54,0x00,
+0xF0,0x1C,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x40,0x73,0x00,
+0x21,0x38,0x00,0x00,
+0x7F,0x00,0x09,0x24,
+0xC0,0x20,0x07,0x00,
+0x04,0x10,0x89,0x00,
+0x24,0x10,0x48,0x00,
+0x06,0x10,0x82,0x00,
+0x01,0x00,0xE5,0x24,
+0xFF,0x00,0x43,0x30,
+0x21,0x30,0x27,0x02,
+0x40,0x00,0x63,0x2C,
+0xFF,0x00,0xA7,0x30,
+0x02,0x00,0x60,0x14,
+0x04,0x00,0xE4,0x2C,
+0x3F,0x00,0x02,0x24,
+0xF3,0xFF,0x80,0x14,
+0x10,0x00,0xC2,0xA0,
+0x23,0x00,0xA6,0x93,
+0x22,0x00,0xA2,0x93,
+0x21,0x00,0xA5,0x93,
+0x40,0x18,0x10,0x00,
+0x00,0x14,0x02,0x00,
+0x21,0x18,0x71,0x00,
+0x20,0x00,0xA7,0x93,
+0x00,0x36,0x06,0x00,
+0x25,0x30,0xC2,0x00,
+0x00,0x2A,0x05,0x00,
+0x00,0x00,0x64,0x94,
+0x25,0x30,0xC5,0x00,
+0x7F,0x7F,0x05,0x3C,
+0x25,0x30,0xC7,0x00,
+0xA9,0x45,0x00,0x0C,
+0x7F,0x7F,0xA5,0x34,
+0x01,0x00,0x02,0x26,
+0xFF,0x00,0x50,0x30,
+0x06,0x00,0x03,0x2E,
+0xD5,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0x21,0x10,0x54,0x00,
+0xF0,0x1C,0x43,0x8C,
+0xDC,0x0B,0x00,0x08,
+0x21,0x40,0x72,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x02,0x80,0x09,0x3C,
+0x1C,0x00,0xB3,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x30,0x1F,0x27,0x25,
+0x02,0x80,0x02,0x3C,
+0xB0,0x1B,0xE3,0x94,
+0xDE,0x5D,0x46,0x90,
+0xFF,0x00,0x90,0x30,
+0x00,0x10,0x63,0x30,
+0x20,0x00,0xC5,0x30,
+0x21,0x20,0x07,0x02,
+0x10,0x00,0xC6,0x30,
+0x02,0x00,0x60,0x14,
+0x3F,0x00,0x13,0x24,
+0x63,0x1D,0x93,0x90,
+0x28,0x00,0xC0,0x10,
+0x30,0x1F,0x22,0x25,
+0x8D,0x1D,0x82,0x90,
+0x7F,0x1D,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x23,0x10,0x43,0x00,
+0x00,0x46,0x02,0x00,
+0x03,0x46,0x08,0x00,
+0xFF,0x00,0x71,0x30,
+0x30,0x1F,0x27,0x25,
+0x0F,0x00,0x08,0x31,
+0x21,0x30,0x00,0x01,
+0x21,0x40,0x07,0x02,
+0xB7,0x1D,0x02,0x91,
+0xB0,0x1B,0xE3,0x84,
+0x0F,0x00,0x05,0x3C,
+0x0F,0x00,0x42,0x30,
+0x21,0x10,0x51,0x00,
+0x0C,0x08,0x04,0x24,
+0x00,0xFF,0xA5,0x34,
+0x06,0x00,0x60,0x04,
+0xFF,0x00,0x52,0x30,
+0xC5,0x1D,0x02,0x91,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x21,0x10,0x51,0x00,
+0xFF,0x00,0x51,0x30,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9A,0x0B,0x00,0x0C,
+0x21,0x20,0x60,0x02,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x40,0x02,
+0x21,0x30,0x00,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xAB,0x0B,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0xDF,0xFF,0xA0,0x10,
+0x21,0x18,0x02,0x02,
+0xA9,0x1D,0x62,0x90,
+0x9B,0x1D,0x63,0x90,
+0x26,0x0C,0x00,0x08,
+0x23,0x10,0x43,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x02,0x3C,
+0x18,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xE9,0x5D,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0x0D,0x00,0x62,0x10,
+0xFF,0x00,0x91,0x30,
+0x0D,0x0C,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x21,0x30,0x20,0x02,
+0x18,0x00,0x04,0x24,
+0x5F,0x47,0x00,0x0C,
+0xFF,0x03,0x05,0x24,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x0A,0x00,0x04,0x24,
+0x25,0x22,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x1A,0x00,0x23,0x12,
+0x0B,0x00,0x02,0x24,
+0x1D,0x00,0x22,0x12,
+0x0F,0x00,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x15,0x00,0x04,0x24,
+0xF4,0xF8,0x06,0x34,
+0x5F,0x47,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x48,0xF3,0x44,0x90,
+0xFE,0x00,0x03,0x24,
+0xE9,0xFF,0x83,0x14,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0x8A,0x47,0x00,0x0C,
+0x15,0x00,0x04,0x24,
+0xFF,0x00,0x46,0x30,
+0x00,0xFF,0x03,0x36,
+0x24,0x10,0x43,0x00,
+0x01,0x00,0xC6,0x24,
+0x25,0x30,0x46,0x00,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x15,0x00,0x04,0x24,
+0x5B,0x0C,0x00,0x08,
+0x21,0x30,0x20,0x02,
+0x0F,0x00,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x15,0x00,0x04,0x24,
+0x6B,0x0C,0x00,0x08,
+0xF4,0xA8,0x06,0x34,
+0xFF,0xFF,0xA5,0x34,
+0x15,0x00,0x04,0x24,
+0x6B,0x0C,0x00,0x08,
+0xF5,0xF8,0x06,0x34,
+0xFC,0x00,0x84,0x30,
+0x50,0x00,0x02,0x24,
+0x11,0x00,0x82,0x10,
+0x05,0x00,0x03,0x24,
+0x51,0x00,0x82,0x28,
+0x10,0x00,0x40,0x10,
+0xA0,0x00,0x02,0x24,
+0x20,0x00,0x02,0x24,
+0x0B,0x00,0x82,0x10,
+0x02,0x00,0x03,0x24,
+0x21,0x00,0x82,0x28,
+0x15,0x00,0x40,0x14,
+0x30,0x00,0x02,0x24,
+0x06,0x00,0x82,0x10,
+0x03,0x00,0x03,0x24,
+0x04,0x00,0x03,0x24,
+0x40,0x00,0x02,0x24,
+0x02,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xFD,0xFF,0x82,0x10,
+0x08,0x00,0x03,0x24,
+0xA1,0x00,0x82,0x28,
+0x0C,0x00,0x40,0x10,
+0xC0,0x00,0x02,0x24,
+0x80,0x00,0x02,0x24,
+0xF7,0xFF,0x82,0x10,
+0x06,0x00,0x03,0x24,
+0x07,0x00,0x03,0x24,
+0x99,0x0C,0x00,0x08,
+0x90,0x00,0x02,0x24,
+0xF2,0xFF,0x80,0x10,
+0x21,0x18,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x99,0x0C,0x00,0x08,
+0x10,0x00,0x02,0x24,
+0xED,0xFF,0x82,0x10,
+0x0A,0x00,0x03,0x24,
+0xC1,0x00,0x82,0x28,
+0x04,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x03,0x24,
+0x99,0x0C,0x00,0x08,
+0xB0,0x00,0x02,0x24,
+0x0B,0x00,0x03,0x24,
+0x99,0x0C,0x00,0x08,
+0xD0,0x00,0x02,0x24,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x08,0x00,0x83,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0x90,0x94,
+0x02,0x80,0x02,0x3C,
+0x21,0x98,0x80,0x00,
+0x25,0x80,0x02,0x02,
+0x21,0x20,0x00,0x02,
+0xFF,0x00,0xB2,0x30,
+0xFF,0x00,0xD1,0x30,
+0x21,0x28,0x00,0x00,
+0x08,0x52,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x08,0x00,0x04,0x8E,
+0x04,0x00,0x05,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xFF,0xE0,0x03,0x24,
+0x24,0x20,0x82,0x00,
+0x00,0x40,0x02,0x3C,
+0x10,0x00,0x06,0x8E,
+0x24,0x28,0xA3,0x00,
+0x25,0x20,0x82,0x00,
+0x3F,0xFF,0x02,0x3C,
+0x0C,0x00,0x67,0x8E,
+0x7F,0xFF,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x00,0x12,0xA5,0x34,
+0x01,0x00,0x52,0x32,
+0x03,0x00,0x31,0x32,
+0x24,0x20,0x83,0x00,
+0x24,0x28,0xA2,0x00,
+0xC0,0x91,0x12,0x00,
+0x80,0x8D,0x11,0x00,
+0x00,0x80,0x02,0x3C,
+0x25,0x30,0xC2,0x00,
+0x25,0x20,0x92,0x00,
+0x25,0x28,0xB1,0x00,
+0x20,0x00,0x02,0x24,
+0x10,0x00,0x06,0xAE,
+0x02,0x00,0x02,0xA2,
+0x08,0x00,0x04,0xAE,
+0x04,0x00,0x05,0xAE,
+0x00,0x00,0x07,0xA6,
+0x02,0x80,0x02,0x3C,
+0xE0,0x3A,0x43,0x94,
+0xFB,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC2,0x1B,0x03,0x00,
+0x24,0x30,0xC2,0x00,
+0x80,0x1C,0x03,0x00,
+0x25,0x30,0xC3,0x00,
+0x14,0x00,0x05,0x8E,
+0x82,0x24,0x06,0x00,
+0x01,0x00,0x84,0x30,
+0x0C,0x00,0x02,0x24,
+0x0A,0x10,0x04,0x00,
+0xFF,0x81,0x03,0x24,
+0x24,0x28,0xA3,0x00,
+0x40,0x12,0x02,0x00,
+0x25,0x28,0xA2,0x00,
+0x14,0x00,0x05,0xAE,
+0x10,0x00,0x06,0xAE,
+0x00,0x60,0x03,0x40,
+0x01,0x00,0x61,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x02,0x3C,
+0x74,0x57,0x42,0x24,
+0x04,0x00,0x44,0x8C,
+0x00,0x00,0x62,0xAE,
+0x04,0x00,0x53,0xAC,
+0x00,0x00,0x93,0xAC,
+0x04,0x00,0x64,0xAE,
+0x00,0x60,0x83,0x40,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xFF,0xFF,0x83,0x30,
+0xFF,0x00,0xB1,0x30,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x13,0x3C,
+0x30,0x1F,0x70,0x26,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x42,0x30,
+0x2F,0x00,0x43,0x10,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x02,0x34,
+0x50,0xDF,0x84,0x24,
+0x33,0x00,0x62,0x10,
+0x21,0x30,0x20,0x02,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x30,0x3B,0x04,0x92,
+0x4F,0x0C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0x03,0x02,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x00,0x08,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x04,0x00,0x42,0x30,
+0x00,0x00,0x62,0xA0,
+0x1B,0x47,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x09,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x1B,0x47,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x84,0x08,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0x1B,0x47,0x00,0x0C,
+0x58,0x00,0x06,0x24,
+0x00,0x0C,0x05,0x24,
+0x01,0x00,0x06,0x24,
+0x5F,0x47,0x00,0x0C,
+0x18,0x00,0x04,0x24,
+0xB0,0x1B,0x02,0x96,
+0x8F,0x3E,0x11,0xA2,
+0xFF,0x7F,0x42,0x30,
+0xB0,0x1B,0x02,0xA6,
+0x30,0x1F,0x62,0x26,
+0x30,0x3B,0x44,0x90,
+0x0D,0x0C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x92,0x40,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x00,0x60,0x92,0x40,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x30,0x3B,0x05,0x92,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x30,0xDF,0x84,0x24,
+0x01,0x00,0x02,0x24,
+0x2C,0x00,0x22,0x12,
+0x00,0x00,0x00,0x00,
+0x30,0x3B,0x04,0x92,
+0x00,0x00,0x00,0x00,
+0xFE,0xFF,0x84,0x24,
+0x4F,0x0C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x07,0x3C,
+0x03,0x02,0xE7,0x34,
+0x00,0x00,0xE2,0x90,
+0xFB,0xFF,0x03,0x24,
+0x00,0x08,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0xE2,0xA0,
+0x01,0x00,0x05,0x24,
+0x1B,0x47,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x03,0x00,0x30,0x32,
+0x00,0x09,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x1B,0x47,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0A,0x04,0x24,
+0x10,0x00,0x05,0x24,
+0x1B,0x47,0x00,0x0C,
+0x42,0x30,0x10,0x00,
+0x21,0x30,0x00,0x02,
+0x00,0x0D,0x04,0x24,
+0x1B,0x47,0x00,0x0C,
+0x00,0x0C,0x05,0x24,
+0x84,0x08,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0x1B,0x47,0x00,0x0C,
+0x18,0x00,0x06,0x24,
+0x18,0x00,0x04,0x24,
+0x00,0x0C,0x05,0x24,
+0x5F,0x47,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x30,0x1F,0x64,0x26,
+0xB0,0x1B,0x82,0x94,
+0x00,0x80,0x03,0x24,
+0x8F,0x3E,0x91,0xA0,
+0x25,0x10,0x43,0x00,
+0x47,0x0D,0x00,0x08,
+0xB0,0x1B,0x82,0xA4,
+0x30,0x3B,0x04,0x92,
+0x65,0x0D,0x00,0x08,
+0x02,0x00,0x84,0x24,
+0xC8,0xFF,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x28,0x00,0xB0,0xAF,
+0x34,0xEA,0x62,0x24,
+0x01,0x00,0x44,0x90,
+0x05,0x00,0x45,0x90,
+0x09,0x00,0x46,0x90,
+0x0D,0x00,0x47,0x90,
+0x04,0x00,0x51,0x90,
+0x08,0x00,0x50,0x90,
+0x34,0xEA,0x72,0x90,
+0x02,0x00,0x4F,0x90,
+0x0C,0x00,0x43,0x90,
+0x06,0x00,0x4E,0x90,
+0x0A,0x00,0x4D,0x90,
+0x0E,0x00,0x48,0x90,
+0x03,0x00,0x49,0x90,
+0x07,0x00,0x4A,0x90,
+0x0B,0x00,0x4B,0x90,
+0x0F,0x00,0x4C,0x90,
+0x00,0x22,0x04,0x00,
+0x00,0x2A,0x05,0x00,
+0x00,0x32,0x06,0x00,
+0x00,0x3A,0x07,0x00,
+0x02,0x80,0x18,0x3C,
+0x25,0x28,0xB1,0x00,
+0x25,0x30,0xD0,0x00,
+0x25,0x38,0xE3,0x00,
+0x25,0x20,0x92,0x00,
+0x11,0x00,0x51,0x90,
+0x10,0x00,0x50,0x90,
+0x30,0x1F,0x03,0x27,
+0x00,0x7C,0x0F,0x00,
+0x00,0x74,0x0E,0x00,
+0x00,0x6C,0x0D,0x00,
+0x00,0x44,0x08,0x00,
+0x25,0x78,0xE4,0x01,
+0x25,0x70,0xC5,0x01,
+0x25,0x68,0xA6,0x01,
+0x25,0x40,0x07,0x01,
+0x5A,0x3E,0x66,0x90,
+0x00,0x4E,0x09,0x00,
+0x00,0x56,0x0A,0x00,
+0x00,0x5E,0x0B,0x00,
+0x00,0x66,0x0C,0x00,
+0x25,0x48,0x2F,0x01,
+0x25,0x50,0x4E,0x01,
+0x25,0x58,0x6D,0x01,
+0x25,0x60,0x88,0x01,
+0x25,0xB0,0x05,0x3C,
+0x37,0x02,0xA5,0x34,
+0x10,0x00,0xA9,0xAF,
+0x14,0x00,0xAA,0xAF,
+0x18,0x00,0xAB,0xAF,
+0x1C,0x00,0xAC,0xAF,
+0x20,0x00,0xB0,0xA3,
+0x21,0x00,0xB1,0xA3,
+0x03,0x00,0xC7,0x30,
+0x00,0x00,0xA4,0x90,
+0x02,0x00,0xE2,0x24,
+0x01,0x00,0x03,0x24,
+0x04,0x18,0x43,0x00,
+0x1C,0x00,0xC6,0x30,
+0xF8,0xFF,0x02,0x24,
+0x24,0x20,0x82,0x00,
+0xFF,0x00,0x67,0x30,
+0x82,0x30,0x06,0x00,
+0x10,0x00,0xE3,0x2C,
+0x25,0x20,0x86,0x00,
+0x0F,0x00,0x02,0x24,
+0x00,0x00,0xA4,0xA0,
+0x0A,0x38,0x43,0x00,
+0x21,0x28,0x00,0x00,
+0x10,0x00,0xA3,0x27,
+0x21,0x30,0x65,0x00,
+0x00,0x00,0xC2,0x90,
+0x01,0x00,0xA5,0x24,
+0x2B,0x10,0xE2,0x00,
+0x02,0x00,0x40,0x10,
+0x11,0x00,0xA4,0x2C,
+0x00,0x00,0xC7,0xA0,
+0xF8,0xFF,0x80,0x14,
+0x21,0x30,0x60,0x00,
+0x21,0x28,0x00,0x00,
+0x25,0xB0,0x07,0x3C,
+0x01,0x00,0xC2,0x90,
+0x00,0x00,0xC3,0x90,
+0x21,0x20,0xA7,0x00,
+0x00,0x11,0x02,0x00,
+0x25,0x10,0x43,0x00,
+0x01,0x00,0xA5,0x24,
+0xFF,0x00,0x42,0x30,
+0x08,0x00,0xA3,0x2C,
+0xA8,0x01,0x82,0xA0,
+0xF6,0xFF,0x60,0x14,
+0x02,0x00,0xC6,0x24,
+0x21,0x00,0xA2,0x93,
+0x20,0x00,0xA4,0x93,
+0x02,0x80,0x03,0x3C,
+0x00,0x11,0x02,0x00,
+0xF1,0x5D,0x65,0x90,
+0x25,0x10,0x44,0x00,
+0xFF,0x00,0x42,0x30,
+0xA7,0x01,0xE3,0x34,
+0x00,0x00,0x62,0xA0,
+0x01,0x00,0x02,0x24,
+0x07,0x00,0xA2,0x10,
+0x30,0x1F,0x03,0x27,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x58,0x3E,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0xF6,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x79,0x3E,0x63,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x62,0x30,
+0xF1,0xFF,0x40,0x10,
+0x03,0x00,0x63,0x30,
+0x0C,0x00,0x65,0x10,
+0x03,0x00,0x02,0x24,
+0x05,0x00,0x62,0x10,
+0x21,0x20,0x00,0x00,
+0x12,0x0D,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0xFF,0x0D,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x04,0x34,
+0x12,0x0D,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0xFF,0x0D,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x04,0x34,
+0x12,0x0D,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0xFF,0x0D,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x06,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x88,0x58,0xC2,0x24,
+0x01,0x00,0x44,0x90,
+0x88,0x58,0xC3,0x90,
+0x02,0x00,0x45,0x90,
+0x03,0x00,0x46,0x90,
+0x05,0x00,0x47,0x90,
+0x04,0x00,0x48,0x90,
+0x00,0x22,0x04,0x00,
+0x25,0x18,0x64,0x00,
+0x00,0x2C,0x05,0x00,
+0x25,0xB0,0x10,0x3C,
+0x25,0x18,0x65,0x00,
+0x00,0x36,0x06,0x00,
+0x00,0x3A,0x07,0x00,
+0x25,0x18,0x66,0x00,
+0x58,0x00,0x02,0x36,
+0x5C,0x00,0x05,0x36,
+0x25,0x40,0x07,0x01,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x43,0xAC,
+0x84,0x58,0x84,0x24,
+0x00,0x00,0xA8,0xAC,
+0x19,0x4F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x94,0x00,0x03,0x36,
+0x00,0x00,0x62,0xA4,
+0x48,0x00,0x10,0x36,
+0x00,0x00,0x02,0x8E,
+0x04,0x00,0x03,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x02,0xAE,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x21,0x90,0x80,0x00,
+0x18,0x02,0x04,0x24,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x25,0x24,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x84,0x58,0xA5,0x24,
+0xDC,0x01,0x06,0x24,
+0x18,0x00,0x40,0x10,
+0x98,0xDF,0x84,0x24,
+0x08,0x00,0x50,0x94,
+0xF8,0x01,0x02,0x24,
+0x0C,0x00,0x22,0xAE,
+0x02,0x80,0x02,0x3C,
+0x0A,0x00,0x03,0x24,
+0x25,0x80,0x02,0x02,
+0x14,0x00,0x23,0xAE,
+0x3C,0x00,0x04,0x26,
+0x10,0x52,0x00,0x0C,
+0x20,0x00,0x10,0x26,
+0x18,0x00,0x12,0xAE,
+0x21,0x20,0x20,0x02,
+0x30,0x09,0x00,0x0C,
+0x14,0x00,0x12,0xAE,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x40,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xA4,0xDF,0x84,0x24,
+0x2F,0x55,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x05,0x3C,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x5C,0xEA,0xA5,0x24,
+0x2F,0x55,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x14,0x00,0xB1,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x25,0x24,0x00,0x0C,
+0x28,0x00,0x04,0x24,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x21,0x28,0x00,0x02,
+0x06,0x00,0x06,0x24,
+0x15,0x00,0x40,0x10,
+0xB4,0xDF,0x84,0x24,
+0x08,0x00,0x44,0x94,
+0x08,0x00,0x02,0x24,
+0x0C,0x00,0x22,0xAE,
+0x02,0x80,0x02,0x3C,
+0x0C,0x00,0x03,0x24,
+0x25,0x20,0x82,0x00,
+0x14,0x00,0x23,0xAE,
+0x10,0x52,0x00,0x0C,
+0x20,0x00,0x84,0x24,
+0x30,0x09,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0xC0,0xDF,0x84,0x24,
+0x21,0x10,0x00,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x05,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x6C,0xEA,0xA5,0x24,
+0x92,0x0E,0x00,0x08,
+0xFF,0xFF,0x02,0x24,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x21,0x98,0x80,0x00,
+0x2C,0x00,0x04,0x24,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x21,0x90,0xA0,0x00,
+0x20,0x00,0xBF,0xAF,
+0x25,0x24,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x21,0x88,0x40,0x00,
+0xD8,0xDF,0x84,0x24,
+0x21,0x30,0x40,0x02,
+0x19,0x00,0x40,0x10,
+0x84,0xEA,0xA5,0x24,
+0x05,0x00,0x65,0x92,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x0B,0x00,0x03,0x24,
+0x25,0x80,0x02,0x02,
+0x20,0x00,0x10,0x26,
+0x0C,0x00,0x02,0x24,
+0x21,0x20,0x00,0x02,
+0x0C,0x00,0x22,0xAE,
+0x14,0x00,0x23,0xAE,
+0x21,0x28,0x60,0x02,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x08,0x00,0x12,0xAE,
+0x21,0x20,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x30,0x09,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xCC,0xDF,0x84,0x24,
+0x2F,0x55,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0xF6,0x5E,0x43,0x90,
+0x02,0x80,0x11,0x3C,
+0x04,0x00,0x04,0x24,
+0x0F,0x00,0x63,0x30,
+0x04,0x00,0x63,0x28,
+0x36,0x00,0x60,0x14,
+0x01,0x00,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x50,0x24,
+0x2C,0xE0,0x22,0x8E,
+0x0F,0x00,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x24,0x00,0x04,0x24,
+0x12,0x00,0x40,0x14,
+0x60,0x00,0x06,0x24,
+0x0F,0x00,0x05,0x3C,
+0x5F,0x47,0x00,0x0C,
+0xFF,0xFF,0xA5,0x34,
+0x01,0x00,0x02,0x24,
+0x2C,0xE0,0x22,0xAE,
+0xD0,0x07,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x70,0x58,0x43,0xAC,
+0x02,0x80,0x02,0x3C,
+0xF5,0x5E,0x44,0x90,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0x64,0x31,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x8A,0x47,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9C,0x3E,0x04,0x92,
+0xFF,0x00,0x43,0x30,
+0x00,0x2C,0x03,0x00,
+0x0A,0x00,0x64,0x10,
+0x9D,0x3E,0x02,0xA2,
+0x02,0x80,0x02,0x3C,
+0x49,0xF3,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x22,0x04,0x00,
+0x6B,0x1E,0x00,0x0C,
+0x25,0x20,0xA4,0x00,
+0x9D,0x3E,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0x9C,0x3E,0x03,0xA2,
+0x10,0x27,0x02,0x24,
+0x40,0x39,0x02,0xAE,
+0x02,0x80,0x02,0x3C,
+0xF5,0x5E,0x44,0x90,
+0x2C,0xE0,0x20,0xAE,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0x64,0x31,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x64,0x31,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xDB,0x0E,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0xB8,0xFF,0xBD,0x27,
+0x00,0x01,0x04,0x24,
+0x3C,0x00,0xB3,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x40,0x00,0xBF,0xAF,
+0x30,0x00,0xB0,0xAF,
+0x25,0x24,0x00,0x0C,
+0x02,0x80,0x13,0x3C,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0xF0,0xDD,0x65,0x26,
+0x06,0x00,0x06,0x24,
+0x0C,0x00,0x52,0x24,
+0x4C,0x00,0x40,0x10,
+0x30,0xE0,0x84,0x24,
+0x08,0x00,0x50,0x94,
+0x02,0x80,0x02,0x3C,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0x10,0x52,0x00,0x0C,
+0x20,0x00,0x00,0xA6,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x30,0x00,0x04,0x26,
+0xF0,0xDD,0x65,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x04,0x3C,
+0x03,0xFF,0x63,0x30,
+0x40,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x30,0x1F,0x84,0x24,
+0x0C,0x00,0x22,0xAE,
+0xF8,0x1D,0x82,0x94,
+0x20,0x00,0x06,0x26,
+0x02,0x80,0x07,0x3C,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x02,0x2A,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xF8,0x1D,0x82,0xA4,
+0x16,0x00,0xC3,0xA0,
+0x17,0x00,0xC5,0xA0,
+0x74,0x3B,0x86,0x8C,
+0xA8,0x5A,0xE7,0x24,
+0x38,0x00,0x04,0x26,
+0x21,0x28,0x00,0x00,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB2,0xAF,
+0x18,0x00,0xA4,0x27,
+0x28,0x00,0xA5,0x27,
+0x21,0x50,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x28,0x00,0xA3,0x8F,
+0x21,0x20,0x00,0x02,
+0x18,0x00,0xA7,0x27,
+0x09,0x00,0x62,0x28,
+0x01,0x00,0x05,0x24,
+0x12,0x00,0x40,0x10,
+0x08,0x00,0x06,0x24,
+0x21,0x20,0x00,0x02,
+0x21,0x30,0x60,0x00,
+0x01,0x00,0x05,0x24,
+0x18,0x00,0xA7,0x27,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB2,0xAF,
+0x21,0x20,0x20,0x02,
+0x01,0x00,0x05,0x24,
+0xB9,0x0C,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB2,0xAF,
+0x28,0x00,0xA6,0x8F,
+0x21,0x20,0x40,0x00,
+0x32,0x00,0x05,0x24,
+0xF8,0xFF,0xC6,0x24,
+0x59,0x0F,0x00,0x08,
+0x20,0x00,0xA7,0x27,
+0x02,0x80,0x05,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x9C,0xEA,0xA5,0x24,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x21,0x80,0x80,0x00,
+0x45,0x00,0xA0,0x14,
+0x21,0x90,0x00,0x00,
+0x08,0x00,0x82,0x90,
+0x02,0x80,0x13,0x3C,
+0x30,0x1F,0x63,0x26,
+0x0F,0x00,0x42,0x30,
+0x14,0x3E,0x62,0xAC,
+0x25,0xB0,0x02,0x3C,
+0x0A,0x00,0x10,0x26,
+0xD0,0x01,0x57,0x34,
+0x02,0x80,0x14,0x3C,
+0xD8,0x01,0x5E,0x34,
+0xDC,0x01,0x55,0x34,
+0xD4,0x01,0x56,0x34,
+0x03,0x00,0x11,0x24,
+0x00,0x00,0x06,0x92,
+0x30,0x1F,0x62,0x26,
+0x0C,0x3E,0x47,0x90,
+0x0F,0x00,0xC3,0x30,
+0x01,0x00,0x05,0x92,
+0x18,0x00,0x67,0x00,
+0x03,0x00,0x04,0x92,
+0x02,0x00,0x02,0x92,
+0x0F,0x00,0xA7,0x30,
+0x00,0x3A,0x07,0x00,
+0x02,0x29,0x05,0x00,
+0x00,0x22,0x04,0x00,
+0x25,0x20,0x82,0x00,
+0x00,0x2B,0x05,0x00,
+0x42,0x11,0x06,0x00,
+0x00,0x24,0x04,0x00,
+0x03,0x00,0x49,0x30,
+0x02,0x31,0x06,0x00,
+0x01,0x00,0x02,0x24,
+0x01,0x00,0xC6,0x30,
+0x12,0x18,0x00,0x00,
+0x0A,0x00,0x63,0x24,
+0xFF,0x00,0x63,0x30,
+0x25,0x18,0x67,0x00,
+0x25,0x18,0x65,0x00,
+0x30,0x00,0x22,0x11,
+0x25,0x38,0x64,0x00,
+0x02,0x00,0x22,0x29,
+0x3E,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x38,0x00,0x22,0x11,
+0x03,0x00,0x02,0x24,
+0x40,0x00,0x22,0x11,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0x20,0x01,
+0x3C,0xE0,0x84,0x26,
+0x2F,0x55,0x00,0x0C,
+0xFF,0xFF,0x31,0x26,
+0xD9,0xFF,0x21,0x06,
+0x04,0x00,0x10,0x26,
+0x25,0xB0,0x02,0x3C,
+0xE7,0x01,0x42,0x34,
+0x00,0x00,0x52,0xA0,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x13,0x3C,
+0x08,0x00,0x83,0x90,
+0x30,0x1F,0x62,0x26,
+0x14,0x3E,0x44,0x8C,
+0x0F,0x00,0x63,0x30,
+0xBB,0xFF,0x83,0x14,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x00,0x00,0xA7,0xAE,
+0x21,0x20,0x00,0x00,
+0x25,0xB0,0x08,0x3C,
+0x07,0x10,0x92,0x00,
+0x01,0x00,0x42,0x30,
+0x01,0x00,0x84,0x24,
+0x02,0x00,0x40,0x10,
+0x03,0x00,0x85,0x2C,
+0xD0,0x01,0x07,0xAD,
+0xF9,0xFF,0xA0,0x14,
+0x04,0x00,0x08,0x25,
+0xB6,0x0F,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0x0D,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0xB5,0x0F,0x00,0x08,
+0x02,0x00,0x52,0x36,
+0xC7,0xFF,0x20,0x15,
+0x21,0x28,0x20,0x01,
+0x0D,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0xB6,0x0F,0x00,0x08,
+0x04,0x00,0x52,0x36,
+0x06,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0xB5,0x0F,0x00,0x08,
+0x01,0x00,0x52,0x36,
+0x00,0x00,0xC7,0xAE,
+0xB6,0x0F,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0x00,0x00,0xE7,0xAE,
+0xB6,0x0F,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0x00,0x00,0xC7,0xAF,
+0xB6,0x0F,0x00,0x08,
+0x21,0x28,0x20,0x01,
+0xC8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x02,0x80,0x02,0x3C,
+0x21,0x88,0x80,0x00,
+0x00,0x01,0x04,0x24,
+0x30,0x00,0xB6,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x25,0x24,0x00,0x0C,
+0x84,0x58,0x56,0x24,
+0x74,0x00,0x40,0x10,
+0x21,0x98,0x40,0x00,
+0x08,0x00,0x50,0x94,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x20,0x02,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0x20,0x00,0x00,0xA6,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x06,0x00,0x06,0x24,
+0x30,0x00,0x04,0x26,
+0x10,0x52,0x00,0x0C,
+0x88,0x58,0xA5,0x24,
+0x20,0x00,0x03,0x96,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x84,0x24,
+0x03,0xFF,0x63,0x30,
+0x50,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0xF8,0x1D,0x82,0x94,
+0x20,0x00,0x12,0x26,
+0x74,0x00,0xD1,0x26,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xF8,0x1D,0x82,0xA4,
+0x02,0x2A,0x03,0x00,
+0x20,0x00,0x02,0x24,
+0x16,0x00,0x43,0xA2,
+0x17,0x00,0x45,0xA2,
+0x21,0x20,0x20,0x02,
+0x17,0x4F,0x00,0x0C,
+0x0C,0x00,0x62,0xAE,
+0x40,0x00,0x12,0x26,
+0x21,0x20,0x40,0x02,
+0x21,0x28,0x40,0x00,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x0C,0x00,0x63,0x8E,
+0x21,0x20,0x20,0x02,
+0x42,0x00,0x12,0x26,
+0x02,0x00,0x63,0x24,
+0x32,0x4F,0x00,0x0C,
+0x0C,0x00,0x63,0xAE,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0x40,0x02,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x0C,0x00,0x63,0x8E,
+0x44,0x00,0x04,0x26,
+0x0C,0x00,0x75,0x26,
+0x02,0x00,0x63,0x24,
+0x0C,0x00,0x63,0xAE,
+0x0C,0x00,0xC6,0x8E,
+0x21,0x28,0x00,0x00,
+0x10,0x00,0xC7,0x26,
+0x60,0x00,0xD0,0x26,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB5,0xAF,
+0x21,0x20,0x00,0x02,
+0x37,0x50,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x09,0x00,0x51,0x2C,
+0x08,0x00,0x06,0x24,
+0x21,0x20,0x40,0x02,
+0x0B,0x30,0x51,0x00,
+0x21,0x38,0x00,0x02,
+0x01,0x00,0x05,0x24,
+0x21,0xA0,0x40,0x00,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB5,0xAF,
+0x21,0x20,0x40,0x00,
+0x03,0x00,0x05,0x24,
+0x01,0x00,0x06,0x24,
+0x48,0x00,0xC7,0x26,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB5,0xAF,
+0x0D,0x00,0x20,0x12,
+0x21,0x20,0x60,0x02,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0xB9,0x0C,0x00,0x08,
+0x38,0x00,0xBD,0x27,
+0xF8,0xFF,0x86,0x26,
+0x21,0x20,0x40,0x00,
+0x68,0x00,0xC7,0x26,
+0x32,0x00,0x05,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB5,0xAF,
+0x21,0x20,0x60,0x02,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0xB9,0x0C,0x00,0x08,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x98,0xE0,0x84,0x24,
+0xAC,0xEA,0xA5,0x24,
+0x2F,0x55,0x00,0x08,
+0x38,0x00,0xBD,0x27,
+0xB0,0xFF,0xBD,0x27,
+0x50,0x00,0xA4,0xAF,
+0xFC,0x01,0x04,0x24,
+0x4C,0x00,0xBF,0xAF,
+0x48,0x00,0xBE,0xAF,
+0x44,0x00,0xB7,0xAF,
+0x40,0x00,0xB6,0xAF,
+0x3C,0x00,0xB5,0xAF,
+0x38,0x00,0xB4,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x25,0x24,0x00,0x0C,
+0x28,0x00,0xB0,0xAF,
+0xE3,0x00,0x40,0x10,
+0x1C,0x00,0xA2,0xAF,
+0x50,0x00,0xA6,0x8F,
+0x02,0x80,0x03,0x3C,
+0xD0,0xEA,0x62,0x24,
+0xD0,0xEA,0x68,0x90,
+0x01,0x00,0x44,0x90,
+0x02,0x00,0xC3,0x90,
+0x02,0x00,0x45,0x90,
+0x03,0x00,0x46,0x90,
+0x1C,0x00,0xA2,0x8F,
+0x00,0x22,0x04,0x00,
+0x25,0x20,0x88,0x00,
+0x08,0x00,0x47,0x94,
+0x50,0x00,0xA2,0x8F,
+0x00,0x2C,0x05,0x00,
+0x0F,0x00,0x63,0x30,
+0x00,0x00,0x48,0x8C,
+0x02,0x80,0x02,0x3C,
+0x25,0x38,0xE2,0x00,
+0x50,0x00,0xA2,0x8F,
+0x25,0x28,0xA4,0x00,
+0x00,0x36,0x06,0x00,
+0xC0,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x25,0x30,0xC5,0x00,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xA6,0xAF,
+0xDD,0x5A,0x55,0x24,
+0x22,0x00,0x66,0x24,
+0x18,0x00,0x62,0x24,
+0x28,0x00,0x76,0x24,
+0x02,0x80,0x03,0x3C,
+0x20,0x00,0xF7,0x24,
+0xFF,0x3F,0x1E,0x31,
+0x21,0x90,0x00,0x00,
+0x30,0x1F,0x73,0x24,
+0x01,0x00,0x14,0x24,
+0x21,0x80,0x00,0x00,
+0x24,0x00,0xA6,0xAF,
+0xD0,0x10,0x00,0x08,
+0x20,0x00,0xA2,0xAF,
+0x39,0x52,0x00,0x0C,
+0x07,0x00,0x10,0x26,
+0x19,0x00,0x40,0x10,
+0x40,0x00,0x43,0x2A,
+0x0E,0x00,0x60,0x10,
+0xE8,0xFF,0xC2,0x27,
+0x21,0x88,0x13,0x02,
+0xAC,0x3B,0x22,0x92,
+0x01,0x00,0x52,0x26,
+0x21,0x20,0x15,0x02,
+0x21,0x28,0xC0,0x02,
+0xF4,0xFF,0x54,0x10,
+0x06,0x00,0x06,0x24,
+0x21,0x20,0x15,0x02,
+0x21,0x28,0xC0,0x02,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xAC,0x3B,0x34,0xA2,
+0xE8,0xFF,0xC2,0x27,
+0x69,0x01,0x43,0x28,
+0x16,0x00,0x60,0x14,
+0x18,0x00,0xA2,0xAF,
+0x02,0x80,0x06,0x3C,
+0x30,0x1F,0xC3,0x24,
+0xA8,0x3B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xA8,0x3B,0x62,0xAC,
+0x1C,0x00,0xA4,0x8F,
+0x3D,0x24,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x4C,0x00,0xBF,0x8F,
+0x48,0x00,0xBE,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0x21,0x20,0xE0,0x02,
+0x21,0x28,0x00,0x00,
+0xFF,0x51,0x00,0x0C,
+0xDC,0x01,0x06,0x24,
+0x20,0x00,0xA2,0x8F,
+0x74,0x00,0xF4,0x26,
+0x21,0x20,0x80,0x02,
+0x18,0x00,0x45,0x24,
+0x18,0x00,0xA2,0x8F,
+0x80,0x00,0xF1,0x26,
+0x74,0x00,0x42,0x24,
+0x00,0x00,0xE2,0xAE,
+0x18,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x30,0x60,0x00,
+0x10,0x52,0x00,0x0C,
+0x70,0x00,0xE3,0xAE,
+0x70,0x00,0xE7,0x8E,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x00,0x00,
+0xF4,0xFF,0xE7,0x24,
+0x55,0x1D,0x00,0x0C,
+0x18,0x00,0xA6,0x27,
+0xD9,0xFF,0x40,0x10,
+0x21,0x80,0x40,0x00,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x62,0x24,
+0x74,0x3B,0x46,0x8C,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0xC0,0x18,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0xCF,0xFF,0xC2,0x14,
+0x02,0x80,0x04,0x3C,
+0xA8,0x5A,0x84,0x24,
+0x39,0x52,0x00,0x0C,
+0x02,0x00,0x05,0x26,
+0xCA,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x06,0x92,
+0x00,0x00,0x00,0x00,
+0x77,0x00,0xC0,0x14,
+0x10,0x00,0xE4,0x26,
+0x0C,0x00,0xE0,0xAE,
+0x50,0x00,0xA6,0x8F,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0xC2,0x94,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x68,0x00,0x40,0x10,
+0x21,0x20,0xC0,0x00,
+0x34,0x00,0xE0,0xAE,
+0x60,0x00,0xF3,0x26,
+0x21,0x20,0x60,0x02,
+0x21,0x28,0x00,0x00,
+0xFF,0x51,0x00,0x0C,
+0x10,0x00,0x06,0x24,
+0x70,0x00,0xE7,0x8E,
+0x21,0x20,0x20,0x02,
+0x01,0x00,0x05,0x24,
+0xF4,0xFF,0xE7,0x24,
+0x55,0x1D,0x00,0x0C,
+0x18,0x00,0xA6,0x27,
+0x06,0x00,0x40,0x10,
+0x21,0x90,0x00,0x00,
+0x18,0x00,0xA6,0x8F,
+0x02,0x00,0x45,0x24,
+0x10,0x52,0x00,0x0C,
+0x21,0x20,0x60,0x02,
+0x18,0x00,0xB2,0x8F,
+0x70,0x00,0xE7,0x8E,
+0x21,0x20,0x20,0x02,
+0x32,0x00,0x05,0x24,
+0xF4,0xFF,0xE7,0x24,
+0x55,0x1D,0x00,0x0C,
+0x18,0x00,0xA6,0x27,
+0x05,0x00,0x40,0x10,
+0x21,0x20,0xF2,0x02,
+0x18,0x00,0xA6,0x8F,
+0x60,0x00,0x84,0x24,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0x18,0x00,0xA5,0x8F,
+0x21,0x20,0x60,0x02,
+0x7D,0x50,0x00,0x0C,
+0x21,0x28,0xB2,0x00,
+0x21,0x18,0x40,0x00,
+0x01,0x00,0x02,0x24,
+0x3F,0x00,0x62,0x10,
+0x03,0x00,0x02,0x24,
+0x38,0x00,0xE2,0xAE,
+0x70,0x00,0xE7,0x8E,
+0x21,0x20,0x20,0x02,
+0x03,0x00,0x05,0x24,
+0xF4,0xFF,0xE7,0x24,
+0x55,0x1D,0x00,0x0C,
+0x18,0x00,0xA6,0x27,
+0x48,0x00,0xE0,0xAE,
+0x04,0x00,0x40,0x10,
+0x3C,0x00,0xE0,0xAE,
+0x02,0x00,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x48,0x00,0xE2,0xAE,
+0x17,0x4F,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0x21,0x28,0x40,0x00,
+0x40,0x00,0xE4,0x26,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x34,0x4F,0x00,0x0C,
+0x21,0x20,0xE0,0x02,
+0xFF,0xFF,0x50,0x30,
+0x01,0x00,0x02,0x32,
+0x22,0x00,0x40,0x10,
+0x21,0x28,0xC0,0x02,
+0x01,0x00,0x02,0x24,
+0x5C,0x00,0xE2,0xAE,
+0x24,0x00,0xA5,0x8F,
+0x04,0x00,0xE4,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x10,0x00,0x02,0x32,
+0x1B,0x00,0x40,0x10,
+0x01,0x00,0x02,0x24,
+0x30,0x00,0xE2,0xAE,
+0x02,0x80,0x02,0x3C,
+0x44,0x00,0xE0,0xAE,
+0x30,0x1F,0x44,0x24,
+0xA4,0x3B,0x82,0x8C,
+0x1C,0x00,0xA6,0x8F,
+0xDC,0x01,0x03,0x24,
+0x01,0x00,0x42,0x24,
+0xA4,0x3B,0x82,0xAC,
+0x08,0x00,0x02,0x24,
+0x0C,0x00,0xC3,0xAC,
+0x14,0x00,0xC2,0xAC,
+0x1C,0x00,0xA4,0x8F,
+0x30,0x09,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE9,0x10,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0xA4,0xE0,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0xBC,0xEA,0xA5,0x24,
+0xE9,0x10,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x6D,0x11,0x00,0x08,
+0x5C,0x00,0xE0,0xAE,
+0x74,0x11,0x00,0x08,
+0x30,0x00,0xE0,0xAE,
+0x52,0x11,0x00,0x08,
+0x38,0x00,0xE3,0xAE,
+0xF7,0x19,0x00,0x0C,
+0x18,0x00,0xC5,0x24,
+0x4C,0x1A,0x00,0x0C,
+0x21,0x20,0x40,0x00,
+0x2B,0x11,0x00,0x08,
+0x34,0x00,0xE2,0xAE,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x05,0x26,
+0x01,0x00,0x03,0x92,
+0x22,0x11,0x00,0x08,
+0x0C,0x00,0xE3,0xAE,
+0x02,0x80,0x04,0x3C,
+0x84,0x58,0x84,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x17,0x4F,0x00,0x0C,
+0x74,0x00,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x10,0x00,0xA4,0x27,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA2,0x97,
+0x25,0xB0,0x04,0x3C,
+0x94,0x00,0x85,0x34,
+0x9A,0x00,0x87,0x34,
+0x26,0xB0,0x06,0x3C,
+0x00,0x08,0x03,0x24,
+0x00,0x00,0xA2,0xA4,
+0x0A,0x00,0x0B,0x24,
+0x00,0x00,0xE3,0xA4,
+0x98,0x00,0x88,0x34,
+0x96,0x00,0x89,0x34,
+0x7A,0x00,0xCA,0x34,
+0x50,0x00,0x02,0x24,
+0x04,0x00,0x03,0x24,
+0x00,0x00,0x02,0xA5,
+0x00,0x00,0x2B,0xA5,
+0x00,0x00,0x43,0xA1,
+0x10,0x00,0xA2,0x97,
+0x89,0x00,0x83,0x34,
+0x14,0x00,0x07,0x24,
+0x40,0x11,0x02,0x00,
+0xA0,0xFF,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0x9C,0x00,0x85,0x34,
+0x7C,0x00,0xC6,0x34,
+0x00,0x00,0xC2,0xA4,
+0x44,0x00,0x84,0x34,
+0x00,0x00,0x67,0xA0,
+0x00,0x00,0xAB,0xA0,
+0x00,0x00,0x82,0x94,
+0xFF,0xFD,0x03,0x24,
+0x18,0x00,0xBF,0x8F,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA4,
+0x00,0x00,0x83,0x94,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x00,0x02,0x63,0x34,
+0x20,0x00,0xBD,0x27,
+0x8E,0x3E,0x40,0xA0,
+0x00,0x00,0x83,0xA4,
+0x08,0x00,0xE0,0x03,
+0x0C,0x3E,0x47,0xA0,
+0xD8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0x84,0x58,0x04,0x26,
+0x24,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x34,0x4F,0x00,0x0C,
+0x18,0x00,0xB2,0xAF,
+0xFF,0xFF,0x51,0x30,
+0x84,0x58,0x04,0x26,
+0x19,0x4F,0x00,0x0C,
+0x02,0x80,0x10,0x3C,
+0x30,0x1F,0x03,0x26,
+0x01,0x00,0x24,0x32,
+0x08,0x3E,0x62,0xA4,
+0x03,0x00,0x80,0x14,
+0x02,0x00,0x05,0x24,
+0x40,0x10,0x11,0x00,
+0x04,0x00,0x45,0x30,
+0x02,0x00,0x02,0x24,
+0x59,0x00,0xA2,0x10,
+0x30,0x1F,0x02,0x26,
+0x0F,0x00,0x80,0x10,
+0x02,0x00,0x03,0x24,
+0x04,0x00,0x02,0x24,
+0x11,0x00,0x62,0x10,
+0x30,0x1F,0x13,0x26,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x20,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x18,0xE1,0x84,0x24,
+0x2F,0x55,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0x40,0x10,0x11,0x00,
+0x04,0x00,0x43,0x30,
+0x04,0x00,0x02,0x24,
+0xF1,0xFF,0x62,0x14,
+0x30,0x1F,0x13,0x26,
+0x08,0x3E,0x66,0x96,
+0x30,0x3B,0x65,0x92,
+0x02,0x80,0x04,0x3C,
+0xB0,0x1B,0x63,0xA6,
+0xD4,0xE0,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x25,0xB0,0x10,0x3C,
+0x50,0x02,0x03,0x36,
+0x0F,0x00,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0x21,0x28,0x00,0x00,
+0x12,0x0D,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x30,0x3B,0x64,0x92,
+0x01,0x00,0x14,0x24,
+0x4F,0x0C,0x00,0x0C,
+0x4C,0x00,0x10,0x36,
+0x02,0x80,0x11,0x3C,
+0x00,0x00,0x14,0xA2,
+0x21,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x37,0x50,0x00,0x0C,
+0xE4,0x58,0x24,0x26,
+0x21,0x28,0x40,0x00,
+0xE4,0x58,0x24,0x26,
+0x7D,0x50,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x0F,0x00,0x50,0x30,
+0xE4,0x58,0x24,0x26,
+0x96,0x50,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x40,0x02,0x10,0x36,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x21,0x30,0x40,0x00,
+0x21,0x28,0x00,0x02,
+0x2F,0x55,0x00,0x0C,
+0x04,0xE1,0x84,0x24,
+0x21,0x20,0x00,0x02,
+0xC1,0x5B,0x00,0x0C,
+0x21,0x28,0x20,0x02,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0xF3,0x3D,0x84,0x24,
+0x88,0x58,0xA5,0x24,
+0x06,0x00,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0xC2,0x1E,0x74,0xA2,
+0x0F,0x48,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9C,0x11,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x62,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x34,
+0x53,0x1E,0x00,0x0C,
+0xB0,0x1B,0x62,0xA6,
+0xEC,0x38,0x62,0xAE,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x04,0x24,
+0x48,0x0E,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0x78,0x3D,0x44,0x8C,
+0x01,0x20,0x03,0x24,
+0xB0,0x1B,0x43,0xA4,
+0x02,0x00,0x85,0x10,
+0x0C,0x00,0x03,0x24,
+0x0F,0x00,0x03,0x24,
+0x25,0xB0,0x02,0x3C,
+0x50,0x02,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x30,0x1F,0x10,0x26,
+0xB0,0x1B,0x02,0x96,
+0x08,0x3E,0x06,0x96,
+0x30,0x3B,0x05,0x92,
+0x10,0x00,0x42,0x34,
+0x02,0x80,0x04,0x3C,
+0xB0,0x1B,0x02,0xA6,
+0x2F,0x55,0x00,0x0C,
+0xB0,0xE0,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0x12,0x0D,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x30,0x3B,0x04,0x92,
+0x4F,0x0C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x53,0x1E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEC,0x38,0x02,0xAE,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x65,0x24,
+0x50,0x3E,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x1F,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x0A,0x3E,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x42,0x2C,
+0x1A,0x00,0x40,0x10,
+0x21,0x38,0xA0,0x00,
+0x98,0x3E,0xA4,0x8C,
+0x94,0x3E,0xA5,0x8C,
+0x21,0x30,0x00,0x00,
+0x80,0x10,0x04,0x00,
+0x80,0x18,0x05,0x00,
+0x2B,0x10,0x45,0x00,
+0x04,0x00,0x40,0x14,
+0x2B,0x18,0x64,0x00,
+0x01,0x00,0x06,0x24,
+0x02,0x00,0x02,0x24,
+0x0A,0x30,0x43,0x00,
+0x0A,0x3E,0xE2,0x90,
+0x94,0x3E,0xE0,0xAC,
+0x98,0x3E,0xE0,0xAC,
+0x40,0x18,0x02,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x18,0x66,0x00,
+0x02,0x80,0x02,0x3C,
+0x48,0xDD,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x64,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xD8,0x01,0x42,0x34,
+0x00,0x00,0x44,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x00,0x84,0x90,
+0x02,0x80,0x05,0x3C,
+0x18,0x3B,0xA5,0x24,
+0x0F,0x00,0x84,0x30,
+0xC0,0x20,0x04,0x00,
+0x21,0x20,0x90,0x00,
+0x1C,0x00,0x84,0x24,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x06,0x00,0x40,0x10,
+0x21,0x20,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x92,0x10,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x80,0xFF,0xBD,0x27,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x08,0x3C,
+0x78,0x00,0xBE,0xAF,
+0x7C,0x00,0xBF,0xAF,
+0x74,0x00,0xB7,0xAF,
+0x70,0x00,0xB6,0xAF,
+0x6C,0x00,0xB5,0xAF,
+0x68,0x00,0xB4,0xAF,
+0x64,0x00,0xB3,0xAF,
+0x60,0x00,0xB2,0xAF,
+0x5C,0x00,0xB1,0xAF,
+0x58,0x00,0xB0,0xAF,
+0xD0,0xEA,0xC2,0x24,
+0xE4,0xEA,0x03,0x25,
+0x01,0x00,0x44,0x90,
+0x01,0x00,0x65,0x90,
+0xD0,0xEA,0xCB,0x90,
+0xE4,0xEA,0x0A,0x91,
+0x02,0x00,0x47,0x90,
+0x02,0x00,0x66,0x90,
+0x03,0x00,0x48,0x90,
+0x03,0x00,0x69,0x90,
+0x00,0x22,0x04,0x00,
+0x00,0x2A,0x05,0x00,
+0x25,0x20,0x8B,0x00,
+0x25,0x28,0xAA,0x00,
+0x00,0x3C,0x07,0x00,
+0x00,0x34,0x06,0x00,
+0x25,0x38,0xE4,0x00,
+0x25,0x30,0xC5,0x00,
+0x00,0x46,0x08,0x00,
+0x00,0x4E,0x09,0x00,
+0x25,0x40,0x07,0x01,
+0x25,0x48,0x26,0x01,
+0x00,0x02,0x04,0x24,
+0x40,0x00,0xA8,0xAF,
+0x25,0x24,0x00,0x0C,
+0x48,0x00,0xA9,0xAF,
+0xB0,0x01,0x40,0x10,
+0x21,0xF0,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x52,0x24,
+0xC4,0x39,0x45,0x8E,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x34,0xE1,0x84,0x24,
+0x08,0x00,0xD1,0x97,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x10,0x3C,
+0x25,0x88,0x22,0x02,
+0x88,0x58,0x10,0x26,
+0x24,0x00,0x24,0x26,
+0x21,0x28,0x00,0x02,
+0x20,0x00,0x20,0xA6,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x24,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x21,0x28,0x00,0x02,
+0x06,0x00,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0x30,0x00,0x24,0x26,
+0x18,0x00,0x03,0x24,
+0x0C,0x00,0xC3,0xAF,
+0xF8,0x1D,0x42,0x96,
+0x20,0x00,0x25,0x26,
+0x38,0x00,0x37,0x26,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x02,0x22,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xF8,0x1D,0x42,0xA6,
+0x17,0x00,0xA4,0xA0,
+0x02,0x80,0x04,0x3C,
+0x16,0x00,0xA3,0xA0,
+0x32,0x4F,0x00,0x0C,
+0xF8,0x58,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0xE0,0x02,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x3A,0x00,0x24,0x26,
+0x18,0x00,0xA5,0x27,
+0x02,0x00,0x06,0x24,
+0x03,0x00,0x02,0x24,
+0x10,0x52,0x00,0x0C,
+0x18,0x00,0xA2,0xA7,
+0x0C,0x00,0xC3,0x8F,
+0x02,0x80,0x07,0x3C,
+0x3C,0x00,0x24,0x26,
+0x04,0x00,0x63,0x24,
+0x0C,0x00,0xC3,0xAF,
+0x60,0x39,0x46,0x8E,
+0x0C,0x00,0xC2,0x27,
+0x94,0x58,0xE7,0x24,
+0x21,0x28,0x00,0x00,
+0x54,0x00,0xA2,0xAF,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x20,0x00,0xA4,0x27,
+0x50,0x00,0xA5,0x27,
+0x21,0x50,0x00,0x0C,
+0x21,0xB8,0x40,0x00,
+0x50,0x00,0xA8,0x8F,
+0x21,0x88,0x00,0x00,
+0x52,0x00,0x00,0x11,
+0x21,0x80,0x00,0x00,
+0x21,0x38,0x40,0x02,
+0x18,0x00,0xA9,0x27,
+0x21,0x10,0x31,0x01,
+0x08,0x00,0x46,0x90,
+0x21,0x20,0x00,0x00,
+0x7F,0x00,0xC5,0x30,
+0x21,0x10,0x87,0x00,
+0xB4,0x39,0x43,0x90,
+0x01,0x00,0x84,0x24,
+0x7F,0x00,0x63,0x30,
+0x3D,0x00,0xA3,0x10,
+0x0D,0x00,0x82,0x2C,
+0xFA,0xFF,0x40,0x14,
+0x21,0x10,0x87,0x00,
+0x01,0x00,0x31,0x26,
+0x2B,0x10,0x28,0x02,
+0xF2,0xFF,0x40,0x14,
+0x21,0x10,0x31,0x01,
+0x09,0x00,0x02,0x2E,
+0x3D,0x00,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x54,0x00,0xA2,0x8F,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0x06,0x24,
+0x30,0x00,0xA7,0x27,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x21,0x20,0x40,0x00,
+0x54,0x00,0xA2,0x8F,
+0xF8,0xFF,0x06,0x26,
+0x32,0x00,0x05,0x24,
+0x38,0x00,0xA7,0x27,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x44,0x24,
+0x78,0x3D,0x83,0x8C,
+0x02,0x00,0x02,0x24,
+0x37,0x00,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0xC4,0x39,0x83,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x23,0x02,
+0x32,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xF8,0x58,0x46,0x24,
+0x21,0x20,0x60,0x00,
+0x4D,0x13,0x00,0x08,
+0x30,0x00,0x05,0x24,
+0x01,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x24,0x02,
+0x27,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x26,0x02,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xF5,0xFF,0x45,0x14,
+0x02,0x80,0x07,0x3C,
+0x01,0x00,0x66,0x90,
+0x54,0x00,0xA2,0x8F,
+0xFA,0x58,0xE7,0x24,
+0x21,0x20,0xE0,0x02,
+0x21,0x38,0x27,0x02,
+0x30,0x00,0x05,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x73,0x13,0x00,0x08,
+0x21,0xB8,0x40,0x00,
+0x21,0x10,0x30,0x01,
+0x18,0x00,0x46,0xA0,
+0x50,0x00,0xA8,0x8F,
+0x01,0x00,0x31,0x26,
+0x2B,0x10,0x28,0x02,
+0xB4,0xFF,0x40,0x14,
+0x01,0x00,0x10,0x26,
+0x27,0x13,0x00,0x08,
+0x09,0x00,0x02,0x2E,
+0x54,0x00,0xA2,0x8F,
+0x21,0x20,0xE0,0x02,
+0x21,0x30,0x00,0x02,
+0x01,0x00,0x05,0x24,
+0x30,0x00,0xA7,0x27,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x44,0x24,
+0x78,0x3D,0x83,0x8C,
+0x02,0x00,0x02,0x24,
+0xCB,0xFF,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0xD5,0x1D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x16,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x43,0x24,
+0xC4,0x39,0x62,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x10,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xF8,0x58,0x52,0x24,
+0x21,0x80,0x60,0x00,
+0x02,0x80,0x13,0x3C,
+0x21,0x20,0x32,0x02,
+0x00,0x00,0x83,0x90,
+0x2D,0x00,0x02,0x24,
+0xCB,0x00,0x62,0x10,
+0x02,0x80,0x05,0x3C,
+0x01,0x00,0x82,0x90,
+0xC4,0x39,0x03,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0xF6,0xFF,0x60,0x14,
+0x21,0x20,0x32,0x02,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x44,0x24,
+0x78,0x3D,0x83,0x8C,
+0x02,0x00,0x02,0x24,
+0x82,0x00,0x62,0x10,
+0x0C,0x00,0x11,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x43,0x24,
+0xC4,0x39,0x62,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x26,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xF8,0x58,0x56,0x24,
+0x21,0xA8,0x60,0x00,
+0xDD,0x00,0x14,0x24,
+0xA5,0x13,0x00,0x08,
+0x02,0x80,0x13,0x3C,
+0x01,0x00,0x02,0x92,
+0xC4,0x39,0xA3,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0x1B,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x36,0x02,
+0x00,0x00,0x02,0x92,
+0x02,0x00,0x12,0x26,
+0x21,0x20,0x40,0x02,
+0xD0,0xDD,0x65,0x26,
+0xF3,0xFF,0x54,0x14,
+0x06,0x00,0x06,0x24,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x54,0x00,0xA2,0x8F,
+0xDD,0x00,0x05,0x24,
+0x21,0x38,0x40,0x02,
+0x07,0x00,0x06,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x08,0x00,0x04,0x92,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x45,0x24,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x0F,0x5F,0x44,0xA0,
+0x10,0x3E,0xA3,0xAC,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x44,0x24,
+0xC4,0x39,0x82,0x8C,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x22,0x02,
+0x20,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF8,0x58,0x56,0x24,
+0xFA,0x58,0x75,0x24,
+0x21,0xA0,0x80,0x00,
+0xD2,0x13,0x00,0x08,
+0xDD,0x00,0x13,0x24,
+0x01,0x00,0x02,0x92,
+0xC4,0x39,0x83,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0x14,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x36,0x02,
+0x00,0x00,0x02,0x92,
+0x21,0x90,0x35,0x02,
+0x21,0x20,0x40,0x02,
+0x48,0x00,0xA5,0x27,
+0xF3,0xFF,0x53,0x14,
+0x04,0x00,0x06,0x24,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x01,0x00,0x06,0x92,
+0x54,0x00,0xA2,0x8F,
+0x21,0x38,0x40,0x02,
+0xDD,0x00,0x05,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x50,0x24,
+0x0A,0x3E,0x02,0x92,
+0x50,0x3E,0x03,0x8E,
+0x05,0x00,0x42,0x38,
+0x01,0x00,0x63,0x38,
+0x01,0x00,0x42,0x2C,
+0x01,0x00,0x63,0x2C,
+0x24,0x10,0x43,0x00,
+0x58,0x00,0x40,0x14,
+0x02,0x80,0x07,0x3C,
+0xC4,0x39,0x05,0x8E,
+0x0C,0x00,0x11,0x24,
+0x2B,0x10,0x25,0x02,
+0x0F,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xF8,0x58,0x46,0x24,
+0x44,0x00,0x04,0x24,
+0x21,0x80,0x26,0x02,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x3E,0x00,0x44,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x25,0x02,
+0xF6,0xFF,0x60,0x14,
+0x21,0x80,0x26,0x02,
+0x21,0x20,0xC0,0x03,
+0x21,0x28,0x00,0x00,
+0xB9,0x0C,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x21,0x10,0x00,0x00,
+0x7C,0x00,0xBF,0x8F,
+0x78,0x00,0xBE,0x8F,
+0x74,0x00,0xB7,0x8F,
+0x70,0x00,0xB6,0x8F,
+0x6C,0x00,0xB5,0x8F,
+0x68,0x00,0xB4,0x8F,
+0x64,0x00,0xB3,0x8F,
+0x60,0x00,0xB2,0x8F,
+0x5C,0x00,0xB1,0x8F,
+0x58,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x80,0x00,0xBD,0x27,
+0xC4,0x39,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x22,0x02,
+0x7B,0xFF,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF8,0x58,0x56,0x24,
+0xFA,0x58,0x75,0x24,
+0x21,0xA0,0x80,0x00,
+0x25,0x14,0x00,0x08,
+0xDD,0x00,0x13,0x24,
+0x01,0x00,0x02,0x92,
+0xC4,0x39,0x83,0x8E,
+0x21,0x10,0x51,0x00,
+0x02,0x00,0x51,0x24,
+0x2B,0x18,0x23,0x02,
+0x6F,0xFF,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x36,0x02,
+0x00,0x00,0x02,0x92,
+0x21,0x90,0x35,0x02,
+0x21,0x20,0x40,0x02,
+0x40,0x00,0xA5,0x27,
+0xF3,0xFF,0x53,0x14,
+0x04,0x00,0x06,0x24,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0xE0,0x02,
+0x01,0x00,0x06,0x92,
+0x54,0x00,0xA2,0x8F,
+0x21,0x38,0x40,0x02,
+0xDD,0x00,0x05,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x92,0x13,0x00,0x08,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x48,0xE1,0x84,0x24,
+0x01,0x00,0x06,0x92,
+0x54,0x00,0xA2,0x8F,
+0x02,0x80,0x07,0x3C,
+0xFA,0x58,0xE7,0x24,
+0x21,0x38,0x27,0x02,
+0x21,0x20,0xE0,0x02,
+0x44,0x00,0x05,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x03,0x14,0x00,0x08,
+0x21,0x20,0xC0,0x03,
+0x54,0x00,0xA2,0x8F,
+0x21,0x20,0xE0,0x02,
+0x9C,0xDD,0xE7,0x24,
+0xDD,0x00,0x05,0x24,
+0x06,0x00,0x06,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0xEF,0x13,0x00,0x08,
+0x21,0xB8,0x40,0x00,
+0x02,0x80,0x14,0x3C,
+0xFA,0x58,0xA5,0x24,
+0x21,0x28,0x25,0x02,
+0x88,0x5D,0x84,0x26,
+0x10,0x52,0x00,0x0C,
+0x20,0x00,0x06,0x24,
+0x02,0x80,0x03,0x3C,
+0xF1,0x5D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x1D,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x58,0x3E,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0xBD,0xFF,0x42,0x30,
+0x58,0x3E,0x02,0xA6,
+0x02,0x80,0x02,0x3C,
+0x58,0x3E,0x03,0x96,
+0xDE,0x5D,0x44,0x90,
+0x0C,0x00,0x63,0x34,
+0x01,0x00,0x84,0x30,
+0x15,0x00,0x80,0x10,
+0x58,0x3E,0x03,0xA6,
+0x02,0x80,0x05,0x3C,
+0x8B,0x5D,0x64,0x26,
+0x3C,0xE3,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x10,0x00,0x06,0x24,
+0x21,0x10,0x32,0x02,
+0x01,0x00,0x46,0x90,
+0x54,0x00,0xA2,0x8F,
+0x21,0x20,0xE0,0x02,
+0x88,0x5D,0x87,0x26,
+0x2D,0x00,0x05,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x21,0xB8,0x40,0x00,
+0x01,0x00,0x02,0x24,
+0x8C,0x13,0x00,0x08,
+0x50,0x3E,0x02,0xAE,
+0x58,0x3E,0x02,0x96,
+0x5D,0x14,0x00,0x08,
+0x02,0x00,0x42,0x34,
+0x02,0x80,0x05,0x3C,
+0x8B,0x5D,0x64,0x26,
+0x68,0x14,0x00,0x08,
+0x4C,0xE3,0xA5,0x24,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x28,0xE1,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0xD4,0xEA,0xA5,0x24,
+0x07,0x14,0x00,0x08,
+0xFF,0xFF,0x02,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0xB0,0x1B,0x43,0x94,
+0xC8,0x00,0x04,0x24,
+0xD0,0x38,0x44,0xAC,
+0x9F,0xFE,0x63,0x30,
+0x80,0x00,0x63,0x34,
+0xB0,0x1B,0x43,0xA4,
+0x6C,0x3D,0x40,0xAC,
+0x70,0x3D,0x40,0xAC,
+0xA5,0x12,0x00,0x08,
+0xB4,0x38,0x40,0xAC,
+0xD8,0xFF,0xBD,0x27,
+0x28,0x00,0xA4,0xA3,
+0x00,0x01,0x04,0x24,
+0x18,0x00,0xB2,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x2C,0x00,0xA5,0xA3,
+0x25,0x24,0x00,0x0C,
+0x30,0x00,0xA6,0xA7,
+0x94,0x00,0x40,0x10,
+0x21,0x90,0x40,0x00,
+0x30,0x00,0xA7,0x97,
+0x28,0x00,0xA5,0x93,
+0x2C,0x00,0xA6,0x93,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x68,0xE1,0x84,0x24,
+0x08,0x00,0x50,0x96,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x11,0x3C,
+0x25,0x80,0x02,0x02,
+0x88,0x58,0x31,0x26,
+0x21,0x28,0x20,0x02,
+0x24,0x00,0x04,0x26,
+0x06,0x00,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0x20,0x00,0x00,0xA6,
+0x02,0x80,0x05,0x3C,
+0x18,0x3B,0xA5,0x24,
+0x2A,0x00,0x04,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x21,0x28,0x20,0x02,
+0x30,0x00,0x04,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x20,0x00,0x05,0x26,
+0x03,0xFF,0x63,0x30,
+0xD0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x02,0x80,0x03,0x3C,
+0x0C,0x00,0x42,0xAE,
+0x30,0x1F,0x73,0x24,
+0xF8,0x1D,0x62,0x96,
+0x0C,0x00,0x51,0x26,
+0x28,0x00,0xA6,0x27,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x02,0x22,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xF8,0x1D,0x62,0xA6,
+0x21,0x38,0x20,0x02,
+0x16,0x00,0xA3,0xA0,
+0x17,0x00,0xA4,0xA0,
+0x38,0x00,0x04,0x26,
+0x68,0x4F,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x21,0x20,0x40,0x00,
+0x01,0x00,0x05,0x24,
+0x2C,0x00,0xA6,0x27,
+0x68,0x4F,0x00,0x0C,
+0x21,0x38,0x20,0x02,
+0x28,0x00,0xA3,0x93,
+0x21,0x20,0x40,0x00,
+0x03,0x00,0x02,0x24,
+0x0C,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x40,0x02,
+0x21,0x28,0x00,0x00,
+0xB9,0x0C,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x2C,0x00,0xA3,0x93,
+0x00,0x00,0x00,0x00,
+0x2E,0x00,0x60,0x14,
+0x01,0x00,0x02,0x24,
+0x19,0x3E,0x63,0x92,
+0x21,0x80,0x60,0x02,
+0x01,0x00,0x68,0x24,
+0xFF,0x00,0x02,0x31,
+0xFD,0xFF,0x40,0x10,
+0x21,0x18,0x00,0x01,
+0x02,0x80,0x06,0x3C,
+0x19,0x3E,0x08,0xA2,
+0x21,0x38,0x20,0x02,
+0x49,0x5D,0xC6,0x24,
+0x68,0x4F,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x30,0x00,0xA3,0x97,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x0F,0x00,0x63,0x30,
+0x80,0x18,0x03,0x00,
+0x02,0x08,0x63,0x34,
+0x1C,0x3E,0x03,0xA6,
+0x4C,0x5D,0xC6,0x24,
+0x21,0x20,0x40,0x00,
+0x68,0x4F,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x4E,0x5D,0xC6,0x24,
+0x21,0x20,0x40,0x00,
+0x02,0x00,0x05,0x24,
+0x68,0x4F,0x00,0x0C,
+0x1E,0x3E,0x00,0xA6,
+0x30,0x00,0xA3,0x97,
+0x21,0x20,0x40,0x00,
+0x02,0x80,0x06,0x3C,
+0x07,0x00,0x63,0x30,
+0x40,0x18,0x03,0x00,
+0x21,0x18,0x70,0x00,
+0xE8,0x1D,0x62,0x94,
+0x50,0x5D,0xC6,0x24,
+0x21,0x38,0x20,0x02,
+0x00,0x11,0x02,0x00,
+0x02,0x00,0x05,0x24,
+0x68,0x4F,0x00,0x0C,
+0x20,0x3E,0x02,0xA6,
+0xD8,0x14,0x00,0x08,
+0x21,0x20,0x40,0x02,
+0xC3,0xFF,0x62,0x14,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x48,0x5D,0xC6,0x24,
+0x68,0x4F,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x21,0x20,0x40,0x00,
+0x30,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x68,0x4F,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0x1C,0x3E,0x63,0x96,
+0x02,0x80,0x06,0x3C,
+0x21,0x38,0x20,0x02,
+0x3F,0x00,0x63,0x30,
+0x00,0x08,0x63,0x34,
+0x21,0x20,0x40,0x00,
+0x4C,0x5D,0xC6,0x24,
+0x02,0x00,0x05,0x24,
+0x68,0x4F,0x00,0x0C,
+0x1C,0x3E,0x63,0xA6,
+0x02,0x80,0x06,0x3C,
+0x21,0x20,0x40,0x00,
+0x4E,0x5D,0xC6,0x24,
+0x21,0x38,0x20,0x02,
+0x68,0x4F,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0xD8,0x14,0x00,0x08,
+0x21,0x20,0x40,0x02,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x5C,0xE1,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0xE8,0xEA,0xA5,0x24,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x00,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x03,0x42,0x34,
+0xF0,0x54,0x63,0x24,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x00,0x00,0x43,0xAC,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x05,0x3C,
+0x88,0x58,0xA5,0x24,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x80,0x44,0x00,
+0x28,0x00,0x04,0x26,
+0x06,0x00,0x06,0x24,
+0x39,0x52,0x00,0x0C,
+0x18,0x00,0x11,0x26,
+0x08,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x55,0x50,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x02,0x80,0x04,0x3C,
+0x18,0x3B,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xF1,0xFF,0x40,0x14,
+0x03,0x00,0x02,0x24,
+0x30,0x00,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0xED,0xFF,0x62,0x14,
+0x30,0x00,0x07,0x26,
+0x02,0x80,0x06,0x3C,
+0x30,0x1F,0xC8,0x24,
+0x50,0x3E,0x02,0x8D,
+0x00,0x00,0x00,0x00,
+0xE7,0xFF,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0x01,0x00,0xE3,0x90,
+0x00,0x00,0x00,0x00,
+0x1A,0x00,0x65,0x10,
+0x02,0x00,0x62,0x28,
+0x2E,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0xDF,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0xE3,0x90,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x62,0x30,
+0x0A,0x00,0x40,0x14,
+0x02,0x11,0x03,0x00,
+0x1A,0x3E,0x03,0x91,
+0x04,0x10,0x45,0x00,
+0x27,0x10,0x02,0x00,
+0x24,0x10,0x43,0x00,
+0x1A,0x3E,0x02,0xA1,
+0x05,0x00,0xE3,0x90,
+0x04,0x00,0xE2,0x90,
+0x00,0x1A,0x03,0x00,
+0x25,0x90,0x62,0x00,
+0x1A,0x3E,0x05,0x91,
+0x02,0x80,0x04,0x3C,
+0x94,0xE1,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x21,0x30,0x40,0x02,
+0x52,0x15,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xE2,0x90,
+0x03,0x00,0xE4,0x90,
+0x05,0x00,0xE3,0x90,
+0x00,0x12,0x02,0x00,
+0x25,0x10,0x44,0x00,
+0x82,0x18,0x03,0x00,
+0x27,0x00,0x40,0x14,
+0x07,0x00,0x64,0x30,
+0x1A,0x3E,0x03,0x91,
+0x04,0x10,0x85,0x00,
+0x25,0x10,0x43,0x00,
+0x1A,0x3E,0x02,0xA1,
+0x30,0x1F,0xC2,0x24,
+0x4C,0x3E,0x43,0x90,
+0x1A,0x3E,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x21,0x18,0x62,0x00,
+0x84,0xE1,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x44,0x3E,0x60,0xA0,
+0x52,0x15,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xB2,0xFF,0x60,0x14,
+0x03,0x00,0x04,0x24,
+0x02,0x00,0xE2,0x90,
+0x01,0x00,0x05,0x24,
+0x18,0x3E,0x02,0xA1,
+0x04,0x00,0xE3,0x90,
+0x03,0x00,0xE2,0x90,
+0x21,0x30,0x00,0x00,
+0x00,0x1A,0x03,0x00,
+0x25,0x18,0x62,0x00,
+0x1C,0x3E,0x03,0xA5,
+0x06,0x00,0xE2,0x90,
+0x05,0x00,0xE3,0x90,
+0x00,0x12,0x02,0x00,
+0x25,0x10,0x43,0x00,
+0x1E,0x3E,0x02,0xA5,
+0x08,0x00,0xE3,0x90,
+0x07,0x00,0xE2,0x90,
+0x00,0x1A,0x03,0x00,
+0x25,0x18,0x62,0x00,
+0x90,0x14,0x00,0x0C,
+0x20,0x3E,0x03,0xA5,
+0x52,0x15,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x1A,0x3E,0x03,0x91,
+0x04,0x10,0x85,0x00,
+0x27,0x10,0x02,0x00,
+0x94,0x15,0x00,0x08,
+0x24,0x10,0x43,0x00,
+0xC0,0xFF,0xBD,0x27,
+0x34,0x00,0xB5,0xAF,
+0xFF,0xFF,0x95,0x30,
+0x00,0x01,0x04,0x24,
+0x38,0x00,0xB6,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x25,0x24,0x00,0x0C,
+0x20,0x00,0xB0,0xAF,
+0x21,0x90,0x40,0x00,
+0x7A,0x00,0x40,0x10,
+0x21,0xB0,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0xB0,0xE1,0x84,0x24,
+0x08,0x00,0x50,0x96,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x11,0x3C,
+0x25,0x80,0x02,0x02,
+0x88,0x58,0x31,0x26,
+0x24,0x00,0x04,0x26,
+0x21,0x28,0x20,0x02,
+0x20,0x00,0x00,0xA6,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x30,0x00,0x04,0x26,
+0x21,0x28,0x20,0x02,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x13,0x3C,
+0x03,0xFF,0x63,0x30,
+0xB0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x30,0x1F,0x68,0x26,
+0x0C,0x00,0x42,0xAE,
+0xF8,0x1D,0x02,0x95,
+0x20,0x00,0x14,0x26,
+0x0C,0x00,0x51,0x26,
+0xFF,0x0F,0x43,0x30,
+0x00,0x19,0x03,0x00,
+0x02,0x22,0x03,0x00,
+0x01,0x00,0x42,0x24,
+0xF8,0x1D,0x02,0xA5,
+0x17,0x00,0x84,0xA2,
+0x16,0x00,0x83,0xA2,
+0x74,0x3D,0x04,0x8D,
+0x03,0x00,0x02,0x24,
+0x3C,0x00,0x82,0x10,
+0x38,0x00,0x10,0x26,
+0x30,0x1F,0x73,0x26,
+0x78,0x3D,0x62,0x8E,
+0x21,0x20,0x00,0x02,
+0x02,0x00,0x05,0x24,
+0x01,0x00,0x42,0x38,
+0x01,0x00,0x42,0x2C,
+0x18,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x68,0x4F,0x00,0x0C,
+0x18,0x00,0xA2,0xA7,
+0x74,0x3D,0x63,0x8E,
+0x21,0x20,0x40,0x00,
+0x02,0x00,0x05,0x24,
+0x18,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x68,0x4F,0x00,0x0C,
+0x18,0x00,0xA3,0xA7,
+0x21,0x20,0x40,0x00,
+0x02,0x00,0x05,0x24,
+0x18,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x68,0x4F,0x00,0x0C,
+0x18,0x00,0xB5,0xA7,
+0x74,0x3D,0x63,0x8E,
+0x21,0x80,0x40,0x00,
+0x03,0x00,0x02,0x24,
+0x0F,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x40,0x02,
+0x21,0x30,0xC0,0x02,
+0xB9,0x0C,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0xB0,0x1B,0x62,0x96,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0xEF,0xFF,0x40,0x10,
+0x21,0x20,0x40,0x02,
+0x02,0x80,0x07,0x3C,
+0x21,0x20,0x00,0x02,
+0xB8,0x5C,0xE7,0x24,
+0x10,0x00,0x05,0x24,
+0x80,0x00,0x06,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB1,0xAF,
+0x00,0x00,0x83,0x96,
+0x01,0x00,0x16,0x24,
+0x00,0x40,0x63,0x34,
+0x13,0x16,0x00,0x08,
+0x00,0x00,0x83,0xA6,
+0xB0,0x1B,0x02,0x95,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0xC1,0xFF,0x40,0x10,
+0x21,0x20,0x00,0x02,
+0x80,0x3D,0x03,0x8D,
+0x84,0x3D,0x02,0x8D,
+0x80,0x1F,0x03,0x00,
+0x25,0x18,0x43,0x00,
+0x04,0x00,0x05,0x24,
+0x01,0x00,0x42,0x24,
+0x1C,0x00,0xA6,0x27,
+0x21,0x38,0x20,0x02,
+0x84,0x3D,0x02,0xAD,
+0x68,0x4F,0x00,0x0C,
+0x1C,0x00,0xA3,0xAF,
+0xF7,0x15,0x00,0x08,
+0x21,0x80,0x40,0x00,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0xA4,0xE1,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0xF8,0xEA,0xA5,0x24,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x63,0x24,
+0xB0,0x1B,0x62,0x94,
+0x01,0x00,0x05,0x24,
+0x21,0x20,0x00,0x00,
+0xEF,0xFF,0x42,0x30,
+0x20,0x00,0x42,0x34,
+0xB0,0x1B,0x62,0xA4,
+0xC8,0x00,0x02,0x24,
+0x74,0x3D,0x65,0xAC,
+0xB4,0x38,0x62,0xAC,
+0xD0,0x38,0x60,0xAC,
+0x6C,0x3D,0x60,0xAC,
+0xBC,0x15,0x00,0x08,
+0x70,0x3D,0x60,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xA8,0xFF,0xBD,0x27,
+0x50,0x00,0xBE,0xAF,
+0x40,0x00,0xB4,0xAF,
+0x3C,0x00,0xB3,0xAF,
+0x54,0x00,0xBF,0xAF,
+0x4C,0x00,0xB7,0xAF,
+0x48,0x00,0xB6,0xAF,
+0x44,0x00,0xB5,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x30,0x00,0xB0,0xAF,
+0x21,0xA0,0x80,0x00,
+0x02,0x00,0x84,0x90,
+0x21,0xF0,0x00,0x00,
+0x24,0x00,0xA0,0xAF,
+0x0F,0x00,0x84,0x30,
+0xC0,0x20,0x04,0x00,
+0x21,0x20,0x94,0x00,
+0x18,0x00,0x93,0x24,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x15,0x3C,
+0x28,0x00,0x84,0x24,
+0x88,0x58,0xA5,0x26,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x0F,0x00,0x40,0x14,
+0x02,0x80,0x16,0x3C,
+0xF4,0x5E,0xC2,0x92,
+0x00,0x00,0x00,0x00,
+0x29,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0xC2,0x92,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x50,0x24,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x3C,0x01,0x40,0x14,
+0x05,0x00,0x05,0x24,
+0x00,0x60,0x92,0x40,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x70,0x24,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x62,0x30,
+0x24,0x01,0x40,0x14,
+0x10,0x00,0x62,0x30,
+0xCB,0x00,0x40,0x14,
+0x10,0x00,0x64,0x26,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x92,0x24,
+0xB0,0x1B,0x42,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x4E,0x01,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0x30,0x1F,0x43,0x24,
+0xB0,0x1B,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0xD3,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x6C,0x3B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0xCF,0xFF,0x40,0x14,
+0x02,0x80,0x0B,0x3C,
+0x15,0x5F,0x62,0x91,
+0x00,0x00,0x00,0x00,
+0x55,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xFA,0x5E,0x40,0xA0,
+0x1C,0x5F,0x60,0xAC,
+0x02,0x80,0x03,0x3C,
+0x0E,0x5F,0x62,0x90,
+0xFD,0xFF,0x03,0x24,
+0x02,0x80,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x0E,0x5F,0x82,0xA0,
+0x42,0xB0,0x17,0x3C,
+0x00,0x00,0xE3,0x92,
+0xEF,0xFF,0x02,0x24,
+0x03,0x00,0xE4,0x36,
+0x24,0x18,0x62,0x00,
+0x40,0x00,0x02,0x24,
+0x00,0x00,0xE3,0xA2,
+0x00,0x00,0x82,0xA0,
+0x02,0x80,0x04,0x3C,
+0xFC,0x5E,0x82,0x94,
+0x20,0x00,0x63,0x96,
+0xFF,0xFF,0x42,0x30,
+0x0A,0x00,0x43,0x10,
+0x02,0x80,0x07,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x94,0x00,0x42,0x34,
+0xFC,0x5E,0x83,0xA4,
+0x00,0x00,0x43,0xA4,
+0xFC,0x5E,0x83,0x94,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x63,0x30,
+0x80,0x1A,0x03,0x00,
+0x00,0x5F,0xE3,0xAC,
+0x25,0xB0,0x04,0x3C,
+0x84,0x00,0x82,0x34,
+0x00,0x00,0x50,0x8C,
+0x80,0x00,0x84,0x34,
+0x00,0x00,0x82,0x8C,
+0x21,0x18,0x00,0x00,
+0x00,0x5F,0xE6,0x8C,
+0x00,0x88,0x10,0x00,
+0x21,0x80,0x00,0x00,
+0x25,0x80,0x02,0x02,
+0x25,0x88,0x23,0x02,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x20,0x02,
+0x28,0x00,0xA7,0xAF,
+0xBA,0x34,0x00,0x0C,
+0x2C,0x00,0xAB,0xAF,
+0x28,0x00,0xA7,0x8F,
+0x02,0x80,0x0A,0x3C,
+0x21,0x28,0x00,0x00,
+0x00,0x5F,0xE8,0x8C,
+0x04,0x5F,0x43,0x95,
+0x21,0x28,0xB1,0x00,
+0x23,0x48,0x02,0x01,
+0x21,0x20,0x30,0x01,
+0x2B,0x10,0x90,0x00,
+0xFF,0xFF,0x63,0x30,
+0x80,0x1A,0x03,0x00,
+0x21,0x28,0xA2,0x00,
+0x21,0x38,0x00,0x00,
+0x2B,0x40,0x83,0x00,
+0x23,0x28,0xA7,0x00,
+0x23,0x20,0x83,0x00,
+0x23,0x28,0xA8,0x00,
+0x02,0x80,0x03,0x3C,
+0x20,0x5F,0x64,0xAC,
+0x24,0x5F,0x65,0xAC,
+0x04,0x5F,0x42,0x95,
+0x2C,0x00,0xAB,0x8F,
+0xFF,0xFF,0x42,0x30,
+0x80,0x12,0x02,0x00,
+0x2B,0x10,0x49,0x00,
+0x31,0x01,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x04,0x5F,0x42,0x95,
+0x00,0x00,0xE4,0x92,
+0xFB,0xFF,0x03,0x24,
+0xFF,0xFF,0x42,0x30,
+0x80,0x12,0x02,0x00,
+0x24,0x20,0x83,0x00,
+0x23,0x48,0x22,0x01,
+0x00,0x00,0xE4,0xA2,
+0x01,0x00,0x06,0x24,
+0x04,0x00,0x20,0x11,
+0x01,0x00,0x04,0x24,
+0x80,0x10,0x09,0x00,
+0x21,0x10,0x49,0x00,
+0x80,0x30,0x02,0x00,
+0x8C,0x23,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x00,0x00,0x87,0x8E,
+0x05,0x00,0x05,0x24,
+0x24,0x00,0x64,0x26,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x55,0x1D,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0x2E,0x00,0x40,0x10,
+0x21,0x28,0x40,0x00,
+0xF4,0x5E,0xC2,0x92,
+0x02,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x45,0x01,0x43,0x10,
+0x02,0x80,0x07,0x3C,
+0x02,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x30,
+0x04,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x1E,0x24,
+0x12,0x5F,0x5E,0xA0,
+0x04,0x00,0xA3,0x90,
+0x20,0x00,0xA7,0x8F,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0xE2,0x28,
+0x18,0x00,0x40,0x14,
+0xFE,0x00,0x66,0x30,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x43,0x24,
+0x50,0x39,0x64,0x94,
+0xC0,0x10,0x06,0x00,
+0x2A,0x10,0x82,0x00,
+0x12,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x21,0x10,0xC7,0x00,
+0xFD,0xFF,0x42,0x24,
+0xC0,0x10,0x02,0x00,
+0x2A,0x10,0x44,0x00,
+0x0C,0x00,0x40,0x14,
+0xC2,0x10,0x04,0x00,
+0x23,0x30,0x46,0x00,
+0x21,0x18,0xA6,0x00,
+0x05,0x00,0x62,0x90,
+0x07,0x00,0x84,0x30,
+0x01,0x00,0x03,0x24,
+0x07,0x10,0x82,0x00,
+0x24,0x00,0xA4,0x8F,
+0x01,0x00,0x42,0x30,
+0x0B,0x20,0x62,0x00,
+0x24,0x00,0xA4,0xAF,
+0x02,0x80,0x03,0x3C,
+0x0E,0x5F,0x62,0x90,
+0xEF,0xFF,0x03,0x24,
+0x02,0x80,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x0E,0x5F,0x82,0xA0,
+0xF4,0x5E,0xC3,0x92,
+0x02,0x80,0x02,0x3C,
+0x24,0xE9,0x42,0x24,
+0xFF,0x00,0x63,0x30,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x66,0x8C,
+0x24,0x00,0xA5,0x8F,
+0x09,0xF8,0xC0,0x00,
+0x21,0x20,0xC0,0x03,
+0x90,0x16,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x88,0x58,0xA5,0x26,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x33,0xFF,0x40,0x14,
+0x02,0x80,0x04,0x3C,
+0x06,0x00,0x02,0x24,
+0x0A,0x3E,0x02,0xA2,
+0xEC,0x38,0x00,0xAE,
+0x00,0x00,0x84,0x8E,
+0x0C,0x00,0x12,0x24,
+0xFF,0x3F,0x82,0x30,
+0xE8,0xFF,0x42,0x24,
+0x2A,0x10,0x42,0x02,
+0xA4,0x00,0x40,0x10,
+0x21,0xA8,0x00,0x02,
+0x7D,0x17,0x00,0x08,
+0x21,0x80,0x72,0x02,
+0x19,0x00,0x03,0x92,
+0xFF,0x3F,0x82,0x30,
+0xE8,0xFF,0x42,0x24,
+0x21,0x18,0x72,0x00,
+0x02,0x00,0x72,0x24,
+0x2A,0x10,0x42,0x02,
+0x9A,0x00,0x40,0x10,
+0x21,0x80,0x72,0x02,
+0x18,0x00,0x03,0x92,
+0xDD,0x00,0x02,0x24,
+0xF5,0xFF,0x62,0x14,
+0x1A,0x00,0x11,0x26,
+0x02,0x80,0x05,0x3C,
+0xC4,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x20,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0xC0,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x1A,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0xBC,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x0F,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0xB8,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x09,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0xB4,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x03,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0xAC,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x64,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0xA8,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x57,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0xB0,0xDD,0xA5,0x24,
+0x21,0x20,0x20,0x02,
+0x39,0x52,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x4A,0x01,0x40,0x10,
+0x02,0x80,0x05,0x3C,
+0x21,0x20,0x20,0x02,
+0x9C,0xDD,0xA5,0x24,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x3E,0x01,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0x84,0x8E,
+0x75,0x17,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x92,0x10,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0x21,0x18,0x00,0x00,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0x00,0x00,0x87,0x8E,
+0x24,0x00,0x64,0x26,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x55,0x1D,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0xBE,0xFE,0x40,0x10,
+0x21,0x28,0x40,0x00,
+0x20,0x00,0xA7,0x8F,
+0x04,0x00,0x42,0x90,
+0x04,0x00,0xE3,0x28,
+0xB9,0xFE,0x60,0x14,
+0xFE,0x00,0x46,0x30,
+0x50,0x39,0x04,0x96,
+0xC0,0x10,0x06,0x00,
+0x2A,0x10,0x82,0x00,
+0xB4,0xFE,0x40,0x14,
+0x21,0x10,0xC7,0x00,
+0xFD,0xFF,0x42,0x24,
+0xC0,0x10,0x02,0x00,
+0x2A,0x10,0x44,0x00,
+0xAF,0xFE,0x40,0x14,
+0xC2,0x10,0x04,0x00,
+0x23,0x30,0x46,0x00,
+0x21,0x18,0xA6,0x00,
+0x05,0x00,0x62,0x90,
+0x07,0x00,0x84,0x30,
+0x07,0x10,0x82,0x00,
+0x01,0x00,0x42,0x30,
+0xA7,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xCD,0x4E,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x90,0x16,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x88,0x58,0xA5,0x26,
+0x10,0x00,0x64,0x26,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xCB,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0xB0,0x1B,0x43,0x96,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x30,
+0x0D,0x00,0x40,0x14,
+0x04,0x00,0x62,0x30,
+0x83,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x70,0x24,
+0x0B,0x3E,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x44,0x24,
+0xFF,0x00,0x83,0x30,
+0x0B,0x00,0x02,0x24,
+0x45,0x00,0x62,0x10,
+0x21,0x18,0x00,0x00,
+0xA1,0x16,0x00,0x08,
+0x0B,0x3E,0x04,0xA2,
+0x00,0x60,0x03,0x40,
+0x01,0x00,0x61,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xD4,0x1E,0x42,0x8E,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xD4,0x1E,0x42,0xAE,
+0x00,0x60,0x83,0x40,
+0xFB,0x17,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x15,0x5F,0x62,0x91,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x42,0x24,
+0x15,0x5F,0x62,0xA1,
+0xBD,0x16,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0xFC,0xE2,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xE6,0x5D,0x46,0x90,
+0x01,0x00,0x03,0x24,
+0x10,0x00,0xC3,0x10,
+0x02,0x80,0x03,0x3C,
+0x53,0x16,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0x30,0x1F,0x64,0x24,
+0x0A,0x3E,0x83,0x90,
+0x03,0x00,0x02,0x24,
+0x62,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x91,0x3E,0x86,0xA0,
+0x53,0x16,0x00,0x0C,
+0x90,0x3E,0x80,0xA0,
+0x21,0x18,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x15,0x5F,0x62,0x91,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x15,0x5F,0x62,0x91,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x15,0x5F,0x62,0xA1,
+0x00,0x00,0xE2,0x92,
+0xFB,0xFF,0x03,0x24,
+0x01,0x00,0x06,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0xE2,0xA2,
+0x11,0x17,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xE6,0x5D,0x43,0x90,
+0x01,0x00,0x11,0x24,
+0x53,0x00,0x71,0x10,
+0x0B,0x3E,0x00,0xA2,
+0x02,0x80,0x02,0x3C,
+0xEA,0x5D,0x44,0x90,
+0x02,0x00,0x03,0x24,
+0x6E,0xFF,0x83,0x14,
+0x21,0x18,0x00,0x00,
+0x00,0x00,0x87,0x8E,
+0x24,0x00,0x64,0x26,
+0x2A,0x00,0x05,0x24,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x55,0x1D,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0x65,0xFF,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x62,0x30,
+0x4D,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x01,0x00,0x62,0x30,
+0x4B,0x00,0x40,0x14,
+0x30,0x1F,0x85,0x24,
+0x02,0x80,0x02,0x3C,
+0xEB,0x5D,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xAA,0x00,0x71,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x23,0x02,0x8E,
+0xFF,0xEF,0x03,0x24,
+0x00,0x08,0x42,0x34,
+0x24,0x10,0x43,0x00,
+0x10,0x23,0x02,0xAE,
+0xBE,0x17,0x00,0x08,
+0x21,0x18,0x00,0x00,
+0x03,0x00,0xA2,0x90,
+0x02,0x80,0x04,0x3C,
+0x10,0x5F,0xE2,0xA0,
+0x02,0x00,0xA3,0x90,
+0x21,0x30,0x80,0x00,
+0x11,0x5F,0x83,0xA0,
+0x11,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x22,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x10,0x5F,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x11,0x5F,0xC2,0xA0,
+0x2A,0x17,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x76,0x26,
+0x3B,0x51,0x00,0x0C,
+0x21,0x20,0xC0,0x02,
+0x20,0x00,0x10,0x24,
+0x32,0x00,0x50,0x10,
+0x21,0xA8,0x40,0x00,
+0x00,0x60,0x05,0x40,
+0x01,0x00,0xA1,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x80,0x18,0x15,0x00,
+0x21,0x18,0x75,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x44,0x24,
+0xC0,0x18,0x03,0x00,
+0x21,0x18,0x64,0x00,
+0x0C,0x1E,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x0C,0x1E,0x62,0xAC,
+0x00,0x60,0x85,0x40,
+0xBE,0x17,0x00,0x08,
+0x21,0x18,0x00,0x00,
+0x90,0x3E,0x86,0xA0,
+0x53,0x16,0x00,0x0C,
+0x91,0x3E,0x80,0xA0,
+0x21,0x18,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x11,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x11,0x5F,0xC2,0xA0,
+0x2A,0x17,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x64,0x12,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x4D,0x18,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0x01,0x00,0x02,0x24,
+0x90,0xE2,0x84,0x24,
+0x18,0x18,0x00,0x08,
+0x0A,0x3E,0xA2,0xA2,
+0x02,0x80,0x04,0x3C,
+0x78,0xE2,0x84,0x24,
+0x18,0x18,0x00,0x08,
+0x0A,0x3E,0xA0,0xA2,
+0x30,0x1F,0x85,0x24,
+0x10,0x23,0xA2,0x8C,
+0xFF,0xEF,0x03,0x24,
+0xFF,0xF7,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x21,0x18,0x00,0x00,
+0xBE,0x17,0x00,0x08,
+0x10,0x23,0xA2,0xAC,
+0xFF,0xFF,0x04,0x24,
+0xE3,0x50,0x00,0x0C,
+0x21,0x28,0xC0,0x02,
+0xCB,0xFF,0x50,0x10,
+0x21,0xA8,0x40,0x00,
+0x00,0x00,0x87,0x8E,
+0x24,0x00,0x70,0x26,
+0x21,0x20,0x00,0x02,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x01,0x00,0x05,0x24,
+0x55,0x1D,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0xDF,0xFD,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x20,0x00,0xA6,0x8F,
+0x02,0x00,0x45,0x24,
+0x10,0x52,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x87,0x8E,
+0x21,0x20,0x00,0x02,
+0x32,0x00,0x05,0x24,
+0xFF,0x3F,0xE7,0x30,
+0xDC,0xFF,0xE7,0x24,
+0x20,0x00,0xB1,0x8F,
+0x55,0x1D,0x00,0x0C,
+0x20,0x00,0xA6,0x27,
+0x09,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0xA6,0x8F,
+0x10,0x00,0xA4,0x27,
+0x21,0x20,0x91,0x00,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0x20,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x88,0x23,0x02,
+0x10,0x00,0xA4,0x27,
+0x7D,0x50,0x00,0x0C,
+0x21,0x28,0x20,0x02,
+0x0F,0x00,0x42,0x30,
+0x00,0x81,0x15,0x00,
+0x21,0x28,0x20,0x02,
+0x10,0x00,0xA4,0x27,
+0x25,0x80,0x02,0x02,
+0xC2,0x50,0x00,0x0C,
+0xFF,0xFF,0x10,0x32,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x21,0x38,0x40,0x00,
+0x21,0x28,0xA0,0x02,
+0x21,0x30,0x00,0x02,
+0x2F,0x55,0x00,0x0C,
+0x10,0xE3,0x84,0x24,
+0x21,0x20,0x00,0x02,
+0xC1,0x5B,0x00,0x0C,
+0x21,0x28,0x20,0x02,
+0x8E,0x3E,0x42,0x92,
+0x21,0x20,0xC0,0x02,
+0x21,0x28,0xA0,0x02,
+0x01,0x00,0x42,0x24,
+0x9C,0x0E,0x00,0x0C,
+0x8E,0x3E,0x42,0xA2,
+0x83,0x18,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x43,0x24,
+0xE4,0xE2,0x84,0x24,
+0x05,0x00,0x02,0x24,
+0x18,0x18,0x00,0x08,
+0x0A,0x3E,0x62,0xA0,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x43,0x24,
+0xD0,0xE2,0x84,0x24,
+0x02,0x00,0x02,0x24,
+0x18,0x18,0x00,0x08,
+0x0A,0x3E,0x62,0xA0,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x43,0x24,
+0xBC,0xE2,0x84,0x24,
+0x04,0x00,0x02,0x24,
+0x18,0x18,0x00,0x08,
+0x0A,0x3E,0x62,0xA0,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x43,0x24,
+0xA8,0xE2,0x84,0x24,
+0x03,0x00,0x02,0x24,
+0x18,0x18,0x00,0x08,
+0x0A,0x3E,0x62,0xA0,
+0x10,0x23,0x02,0x8E,
+0xFF,0xF7,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x10,0x42,0x34,
+0x6C,0x18,0x00,0x08,
+0x10,0x23,0x02,0xAE,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0x30,0x1F,0x02,0x26,
+0x14,0x00,0xBF,0xAF,
+0xB0,0x1B,0x43,0x94,
+0x21,0x28,0x00,0x00,
+0x00,0x01,0x62,0x30,
+0x03,0x00,0x40,0x10,
+0x01,0x00,0x64,0x30,
+0x06,0x00,0x80,0x14,
+0x00,0x10,0x62,0x30,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0x40,0x14,
+0x02,0x00,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xF6,0x5E,0x43,0x90,
+0x0C,0x00,0x02,0x24,
+0x0F,0x00,0x63,0x30,
+0x0A,0x00,0x62,0x10,
+0x21,0x20,0x00,0x00,
+0x02,0x00,0x03,0x3C,
+0x30,0x1F,0x04,0x26,
+0x20,0xBF,0x63,0x34,
+0x08,0x39,0x83,0xAC,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xCD,0x4E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x03,0x3C,
+0x30,0x1F,0x04,0x26,
+0x20,0xBF,0x63,0x34,
+0x33,0x19,0x00,0x08,
+0x08,0x39,0x83,0xAC,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x25,0x26,
+0x6C,0x3B,0xA2,0x8C,
+0x00,0x10,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0x21,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x9B,0x3B,0xA6,0x90,
+0x9C,0x3B,0xA4,0x90,
+0xFF,0x00,0xC3,0x30,
+0x40,0x10,0x03,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x01,0x00,0x84,0x24,
+0x80,0x10,0x02,0x00,
+0xFF,0x00,0x83,0x30,
+0x21,0x10,0x45,0x00,
+0x21,0x10,0x43,0x00,
+0x9C,0x3B,0xA4,0xA0,
+0x38,0x3B,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x00,0x60,0x10,
+0x01,0x00,0xC2,0x24,
+0xFF,0x00,0xC2,0x30,
+0x22,0x00,0x40,0x14,
+0x30,0x1F,0x30,0x26,
+0x9C,0x3B,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x45,0x00,
+0x38,0x3B,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x64,0x30,
+0x1A,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x67,0x3B,0xA2,0x90,
+0x30,0x3B,0xA3,0xA0,
+0x4F,0x0C,0x00,0x0C,
+0x31,0x3B,0xA2,0xA0,
+0x30,0x1F,0x30,0x26,
+0x70,0x3B,0x03,0x8E,
+0x01,0x00,0x02,0x24,
+0x7C,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x6C,0x3B,0x03,0x8E,
+0x00,0x10,0x02,0x3C,
+0x3C,0x00,0x04,0x24,
+0x26,0x18,0x62,0x00,
+0x98,0x38,0x04,0xAE,
+0x6C,0x3B,0x03,0xAE,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x21,0x30,0x40,0x00,
+0x9B,0x3B,0xA2,0xA0,
+0x5C,0x19,0x00,0x08,
+0x9C,0x3B,0xA0,0xA0,
+0x99,0x3B,0x03,0x92,
+0x9A,0x3B,0x02,0x92,
+0xFF,0x00,0x64,0x30,
+0x30,0x3B,0x03,0xA2,
+0x4F,0x0C,0x00,0x0C,
+0x31,0x3B,0x02,0xA2,
+0xB0,0x1B,0x03,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x62,0x30,
+0x09,0x00,0x40,0x10,
+0x01,0x00,0x62,0x30,
+0x08,0x00,0x40,0x10,
+0x30,0x1F,0x30,0x26,
+0x02,0x80,0x02,0x3C,
+0xF6,0x5E,0x43,0x90,
+0x0C,0x00,0x02,0x24,
+0x0F,0x00,0x63,0x30,
+0x61,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x30,0x26,
+0x9E,0x3B,0x04,0x96,
+0xA0,0x3B,0x05,0x92,
+0x12,0x0D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xC1,0x48,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x6C,0x3B,0x00,0xAE,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x3F,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x3C,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF6,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x41,0x00,0x40,0x14,
+0x04,0x00,0x04,0x24,
+0x02,0x80,0x03,0x3C,
+0x15,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x15,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x15,0x5F,0x62,0xA0,
+0x00,0x60,0x92,0x40,
+0x25,0xB0,0x07,0x3C,
+0x30,0x1F,0x30,0x26,
+0xB0,0x1B,0x04,0x96,
+0x48,0x00,0xE6,0x34,
+0x00,0x00,0xC3,0x8C,
+0xFF,0xEF,0x84,0x30,
+0x80,0x00,0x02,0x3C,
+0x25,0x18,0x62,0x00,
+0x00,0x01,0x85,0x30,
+0x00,0x00,0xC3,0xAC,
+0x02,0x80,0x08,0x3C,
+0x05,0x00,0xA0,0x10,
+0xB0,0x1B,0x04,0xA6,
+0x00,0x00,0xC2,0x8C,
+0x04,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0xC2,0xAC,
+0x30,0x1F,0x02,0x8D,
+0xFF,0xF0,0x03,0x24,
+0xA1,0x3B,0x05,0x92,
+0x24,0x10,0x43,0x00,
+0x00,0x01,0x42,0x34,
+0x0F,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x10,0x00,0x42,0x34,
+0xF0,0xFF,0x03,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x24,0x10,0x43,0x00,
+0x4C,0x00,0xE3,0x34,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0x65,0xA0,
+0x64,0x03,0xE4,0x34,
+0x07,0x00,0x03,0x24,
+0x20,0x00,0xBD,0x27,
+0x30,0x1F,0x02,0xAD,
+0x00,0x00,0x83,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x15,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x64,0x90,
+0x01,0x00,0x05,0x24,
+0x64,0x31,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0xB8,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x13,0x0F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x70,0x19,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x64,0x31,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0xB0,0x19,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0xCD,0x4E,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x94,0x19,0x00,0x08,
+0x30,0x1F,0x30,0x26,
+0x0C,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x3F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x17,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x24,0x08,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x02,0x63,0x30,
+0x15,0x00,0x60,0x14,
+0x01,0x00,0x02,0x24,
+0x05,0x00,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x82,0x21,0x03,0x00,
+0x28,0x00,0x82,0x10,
+0xF5,0xFF,0x02,0x24,
+0x02,0x00,0x82,0x28,
+0x3B,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x2F,0x00,0x82,0x10,
+0xE9,0xFF,0x02,0x24,
+0x03,0x00,0x02,0x24,
+0x24,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x05,0x00,0xC2,0x24,
+0x04,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x42,0x10,0x02,0x00,
+0x08,0x00,0xE0,0x03,
+0x96,0xFF,0x42,0x24,
+0x05,0x00,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x60,0x00,0x64,0x30,
+0x42,0x21,0x04,0x00,
+0x0F,0x00,0x82,0x10,
+0x1F,0x00,0x62,0x30,
+0x02,0x00,0x82,0x28,
+0x1F,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x16,0x00,0x82,0x10,
+0x1F,0x00,0x62,0x30,
+0x03,0x00,0x02,0x24,
+0xEC,0xFF,0x82,0x14,
+0x00,0x00,0x00,0x00,
+0x1F,0x00,0x62,0x30,
+0x40,0x10,0x02,0x00,
+0xDD,0xFF,0x03,0x24,
+0x23,0x30,0x62,0x00,
+0x08,0x00,0xE0,0x03,
+0x05,0x00,0xC2,0x24,
+0x40,0x10,0x02,0x00,
+0xF5,0xFF,0x03,0x24,
+0x2A,0x1A,0x00,0x08,
+0x23,0x30,0x62,0x00,
+0x3E,0x00,0x63,0x30,
+0x23,0x30,0x43,0x00,
+0x08,0x00,0xE0,0x03,
+0x05,0x00,0xC2,0x24,
+0x3E,0x00,0x63,0x30,
+0xDD,0xFF,0x02,0x24,
+0x32,0x1A,0x00,0x08,
+0x23,0x30,0x43,0x00,
+0x40,0x10,0x02,0x00,
+0xE9,0xFF,0x03,0x24,
+0x2A,0x1A,0x00,0x08,
+0x23,0x30,0x62,0x00,
+0x3E,0x00,0x63,0x30,
+0x32,0x1A,0x00,0x08,
+0x23,0x30,0x43,0x00,
+0xD1,0xFF,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x1F,0x00,0x62,0x30,
+0x40,0x10,0x02,0x00,
+0xF8,0xFF,0x03,0x24,
+0x2A,0x1A,0x00,0x08,
+0x23,0x30,0x62,0x00,
+0xCA,0xFF,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x3E,0x00,0x63,0x30,
+0xF8,0xFF,0x02,0x24,
+0x32,0x1A,0x00,0x08,
+0x23,0x30,0x43,0x00,
+0x63,0x00,0x82,0x24,
+0x77,0x00,0x42,0x2C,
+0x00,0x00,0x85,0x28,
+0x04,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x64,0x00,0x82,0x24,
+0x64,0x00,0x03,0x24,
+0x0B,0x18,0x45,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x02,0x80,0x09,0x3C,
+0x30,0x1F,0x28,0x25,
+0x80,0x36,0x06,0x8D,
+0xFF,0xFF,0x02,0x34,
+0x3F,0x00,0xC2,0x10,
+0x21,0x38,0x80,0x00,
+0x2B,0x10,0xC7,0x00,
+0x30,0x00,0x40,0x10,
+0x02,0x19,0x06,0x00,
+0x21,0x10,0xC7,0x00,
+0x23,0x10,0x43,0x00,
+0x10,0x00,0x46,0x24,
+0x80,0x36,0x06,0xAD,
+0x30,0x1F,0x26,0x25,
+0x04,0x00,0xC4,0x8C,
+0x84,0x36,0x02,0xAD,
+0xFF,0xFF,0x02,0x34,
+0x2F,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x87,0x00,
+0x1F,0x00,0x40,0x10,
+0x02,0x19,0x04,0x00,
+0x21,0x10,0x87,0x00,
+0x23,0x10,0x43,0x00,
+0x10,0x00,0x44,0x24,
+0x04,0x00,0xC4,0xAC,
+0x84,0x36,0xC2,0xAC,
+0xC0,0x10,0x05,0x00,
+0x21,0x10,0x45,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x45,0x00,
+0x30,0x1F,0x23,0x25,
+0x80,0x10,0x02,0x00,
+0x21,0x28,0x43,0x00,
+0x0C,0x24,0xA6,0x8C,
+0x00,0x21,0x07,0x00,
+0xFF,0xFF,0xC2,0x38,
+0x0A,0x30,0x82,0x00,
+0x2B,0x18,0xC7,0x00,
+0x07,0x00,0x60,0x10,
+0x21,0x10,0xC7,0x00,
+0x02,0x19,0x06,0x00,
+0x23,0x10,0x43,0x00,
+0x10,0x00,0x46,0x24,
+0x0C,0x24,0xA6,0xAC,
+0x08,0x00,0xE0,0x03,
+0x10,0x24,0xA2,0xAC,
+0x02,0x19,0x06,0x00,
+0x23,0x10,0x43,0x00,
+0x0C,0x24,0xA2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x10,0x24,0xA2,0xAC,
+0x21,0x10,0x87,0x00,
+0x23,0x10,0x43,0x00,
+0x70,0x1A,0x00,0x08,
+0x04,0x00,0xC2,0xAC,
+0x21,0x10,0xC7,0x00,
+0x30,0x1F,0x26,0x25,
+0x04,0x00,0xC4,0x8C,
+0x23,0x10,0x43,0x00,
+0x80,0x36,0x02,0xAD,
+0x84,0x36,0x02,0xAD,
+0xFF,0xFF,0x02,0x34,
+0xD4,0xFF,0x82,0x14,
+0x2B,0x10,0x87,0x00,
+0x00,0x21,0x07,0x00,
+0x69,0x1A,0x00,0x08,
+0x04,0x00,0xC4,0xAC,
+0x00,0x31,0x04,0x00,
+0x5C,0x1A,0x00,0x08,
+0x80,0x36,0x06,0xAD,
+0xA0,0xFF,0xBD,0x27,
+0x54,0x00,0xB7,0xAF,
+0x5C,0x00,0xBF,0xAF,
+0x58,0x00,0xBE,0xAF,
+0x50,0x00,0xB6,0xAF,
+0x4C,0x00,0xB5,0xAF,
+0x48,0x00,0xB4,0xAF,
+0x44,0x00,0xB3,0xAF,
+0x40,0x00,0xB2,0xAF,
+0x3C,0x00,0xB1,0xAF,
+0x38,0x00,0xB0,0xAF,
+0x02,0x80,0x17,0x3C,
+0x02,0x80,0x02,0x3C,
+0x64,0x57,0x45,0x8C,
+0x00,0x80,0x04,0x3C,
+0x74,0x6A,0x83,0x24,
+0x64,0x57,0x44,0x24,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x7F,0x00,0xA4,0x10,
+0x02,0x80,0x09,0x3C,
+0x02,0x80,0x02,0x3C,
+0x40,0xEB,0x29,0x25,
+0x44,0xEB,0x42,0x24,
+0x00,0x00,0x35,0x8D,
+0x00,0x00,0x53,0x8C,
+0x02,0x80,0x03,0x3C,
+0x48,0xEB,0x63,0x24,
+0x00,0x00,0x7E,0x8C,
+0x34,0x38,0xB4,0x8E,
+0x21,0x20,0x00,0x00,
+0x21,0xB0,0x00,0x00,
+0x08,0x00,0x82,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x62,0xAE,
+0x08,0x00,0x83,0x96,
+0x02,0x80,0x02,0x3C,
+0xB0,0x01,0x00,0x0C,
+0x25,0x90,0x62,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xAC,0x1B,0xA3,0x96,
+0xD0,0x37,0xA2,0x8E,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0xC2,0xAF,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0xF4,0x1A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x17,0x00,0xC7,0x90,
+0x16,0x00,0xC8,0x90,
+0x32,0x3B,0xA2,0x96,
+0xFF,0x00,0xE3,0x30,
+0x00,0x1A,0x03,0x00,
+0xFF,0x00,0x05,0x31,
+0x25,0x18,0x65,0x00,
+0xB7,0x00,0x43,0x10,
+0x24,0xE3,0x24,0x25,
+0xFF,0x00,0xE2,0x30,
+0xFF,0x00,0x03,0x31,
+0x00,0x12,0x02,0x00,
+0x25,0x10,0x43,0x00,
+0x32,0x3B,0xA2,0xA6,
+0x01,0x00,0xC4,0x90,
+0x00,0x00,0xC2,0x90,
+0x00,0x22,0x04,0x00,
+0x88,0x0C,0x00,0x0C,
+0x25,0x20,0x82,0x00,
+0x40,0x18,0x02,0x00,
+0x21,0x18,0x62,0x00,
+0x80,0x18,0x03,0x00,
+0x94,0xDE,0xE2,0x26,
+0x21,0x18,0x62,0x00,
+0x08,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x40,0x00,
+0x21,0x20,0x20,0x02,
+0x0C,0x00,0x82,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0xC2,0x02,
+0x2C,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x42,0x8E,
+0x21,0x88,0x40,0x02,
+0x42,0x1B,0x02,0x00,
+0x78,0x00,0x63,0x30,
+0x02,0x26,0x02,0x00,
+0xFF,0x3F,0x42,0x30,
+0x21,0x10,0x43,0x00,
+0x03,0x00,0x84,0x30,
+0x21,0x10,0x44,0x00,
+0x18,0x00,0x42,0x24,
+0xFF,0xFF,0x50,0x30,
+0x7F,0x00,0x02,0x32,
+0x80,0x00,0x03,0x26,
+0x00,0x00,0x70,0xAE,
+0x02,0x00,0x40,0x10,
+0x80,0xFF,0x05,0x32,
+0x80,0xFF,0x65,0x30,
+0x00,0x00,0x65,0xAE,
+0x02,0x00,0x22,0x96,
+0x21,0x18,0xC5,0x02,
+0xFF,0xFF,0x76,0x30,
+0x0F,0x00,0x42,0x30,
+0x00,0x00,0x62,0xAE,
+0x00,0x00,0x23,0x8E,
+0x21,0x90,0x45,0x02,
+0x42,0x13,0x03,0x00,
+0x78,0x00,0x42,0x30,
+0x02,0x1E,0x03,0x00,
+0x21,0x10,0x51,0x00,
+0x03,0x00,0x63,0x30,
+0x21,0x10,0x43,0x00,
+0x18,0x00,0x46,0x24,
+0x00,0x00,0x66,0xAE,
+0x01,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x12,0x02,0x00,
+0x00,0x08,0x42,0x30,
+0xB9,0xFF,0x40,0x14,
+0x02,0x80,0x09,0x3C,
+0x16,0x00,0xC8,0x90,
+0x17,0x00,0xC7,0x90,
+0xDD,0x1A,0x00,0x08,
+0xFF,0x00,0xE2,0x30,
+0x00,0x60,0x10,0x40,
+0x01,0x00,0x01,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x04,0x00,0x83,0x8E,
+0x00,0x00,0x82,0x8E,
+0x21,0x20,0x80,0x02,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0x94,0xAE,
+0x3D,0x24,0x00,0x0C,
+0x04,0x00,0x94,0xAE,
+0x00,0x60,0x90,0x40,
+0x02,0x80,0x02,0x3C,
+0x64,0x57,0x43,0x8C,
+0x64,0x57,0x42,0x24,
+0x8B,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x40,0xEB,0x63,0x24,
+0x00,0x00,0x71,0x8C,
+0x25,0xB0,0x10,0x3C,
+0x04,0x01,0x02,0x36,
+0x00,0x00,0x43,0x8C,
+0xE8,0x37,0x27,0x8E,
+0x00,0x00,0x00,0x00,
+0xC8,0x00,0xE3,0x10,
+0xEC,0x37,0x23,0xAE,
+0x2B,0x10,0x67,0x00,
+0xD2,0x00,0x40,0x14,
+0x2B,0x10,0xE3,0x00,
+0x08,0x01,0x40,0x14,
+0x02,0x80,0x09,0x3C,
+0x30,0x1F,0x24,0x25,
+0xBC,0x37,0x83,0x94,
+0x02,0x80,0x02,0x3C,
+0x21,0x80,0x00,0x00,
+0x2F,0x00,0xC0,0x1A,
+0x25,0xA8,0x62,0x00,
+0x21,0x98,0x80,0x00,
+0x21,0x90,0x00,0x00,
+0x01,0x00,0x1E,0x24,
+0x21,0x88,0x55,0x02,
+0x00,0x00,0x22,0x8E,
+0x98,0x3E,0x63,0x8E,
+0xFF,0x3F,0x42,0x30,
+0x21,0x18,0x62,0x00,
+0x98,0x3E,0x63,0xAE,
+0x00,0x60,0x04,0x40,
+0x01,0x00,0x81,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xD4,0x1E,0x62,0x8E,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xD4,0x1E,0x62,0xAE,
+0x00,0x60,0x84,0x40,
+0x04,0x00,0x22,0x8E,
+0x02,0x00,0x03,0x24,
+0x02,0x17,0x02,0x00,
+0x03,0x00,0x42,0x30,
+0x39,0x00,0x43,0x10,
+0x02,0x80,0x03,0x3C,
+0x21,0x10,0x55,0x02,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x60,0x10,
+0x01,0x00,0x02,0x26,
+0x04,0x00,0x22,0x8E,
+0x00,0xF0,0x03,0x3C,
+0x00,0x20,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x10,0x00,0x44,0x10,
+0x02,0x80,0x09,0x3C,
+0x06,0x00,0x02,0x26,
+0x00,0x00,0x23,0x8E,
+0xFF,0xFF,0x50,0x30,
+0x82,0x16,0x03,0x00,
+0x01,0x00,0x42,0x30,
+0x52,0x00,0x5E,0x10,
+0x02,0x80,0x04,0x3C,
+0x80,0x90,0x10,0x00,
+0x2A,0x10,0x56,0x02,
+0xD7,0xFF,0x40,0x14,
+0x21,0x88,0x55,0x02,
+0x3D,0x24,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0x08,0x1C,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x40,0xEB,0x29,0x25,
+0x00,0x00,0x25,0x8D,
+0x00,0x00,0x00,0x00,
+0xD4,0x1D,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xD4,0x1D,0xA2,0xAC,
+0x0C,0x00,0x24,0x8E,
+0x0C,0x00,0x02,0x24,
+0x3F,0x00,0x83,0x30,
+0xBD,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x02,0x24,
+0xB3,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x3F,0x00,0x83,0x30,
+0x0E,0x00,0x02,0x24,
+0xE0,0xFF,0x62,0x14,
+0x06,0x00,0x02,0x26,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x63,0x24,
+0xE0,0x1D,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x69,0x1B,0x00,0x08,
+0xE0,0x1D,0x62,0xAC,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0x1A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xF4,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xC6,0xFF,0x40,0x10,
+0x21,0x10,0x55,0x02,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xF4,0x5E,0x62,0x90,
+0x02,0x80,0x04,0x3C,
+0xF8,0xE8,0x85,0x24,
+0xFF,0x00,0x42,0x30,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x45,0x00,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0x24,0x8E,
+0x04,0x00,0x25,0x8E,
+0x09,0xF8,0x60,0x00,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x09,0x3C,
+0xF6,0x5E,0x22,0x91,
+0x0C,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x10,
+0x02,0x80,0x03,0x3C,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x5F,0x1B,0x00,0x08,
+0x21,0x10,0x55,0x02,
+0x0D,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x13,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x13,0x5F,0x82,0xA0,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x5F,0x1B,0x00,0x08,
+0x21,0x10,0x55,0x02,
+0x30,0x1F,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x0F,0x00,0x42,0x30,
+0x05,0x00,0x5E,0x10,
+0xC2,0x13,0x03,0x00,
+0x1E,0x00,0x42,0x30,
+0x21,0x10,0x50,0x00,
+0x70,0x1B,0x00,0x08,
+0xFF,0xFF,0x50,0x30,
+0x02,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x23,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x14,0x03,0x00,
+0x0F,0x00,0x42,0x30,
+0x14,0x00,0x40,0x14,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x44,0x30,
+0x08,0x00,0x80,0x10,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0x62,0x00,
+0x0E,0x00,0x40,0x14,
+0x03,0x00,0x02,0x24,
+0x0C,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x80,0x28,0x10,0x00,
+0x21,0x28,0xB5,0x00,
+0xF7,0x19,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x4C,0x1A,0x00,0x0C,
+0x21,0x20,0x40,0x00,
+0x21,0x20,0x40,0x00,
+0x56,0x1A,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x02,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x8B,0x00,0x5E,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x63,0x92,
+0x02,0x00,0x02,0x24,
+0x71,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x63,0x30,
+0x08,0x00,0x7E,0x10,
+0xD0,0x02,0x02,0x24,
+0x00,0x00,0x23,0x8E,
+0x00,0x00,0x00,0x00,
+0xC2,0x13,0x03,0x00,
+0x1E,0x00,0x42,0x30,
+0x21,0x10,0x50,0x00,
+0x70,0x1B,0x00,0x08,
+0xFF,0xFF,0x50,0x30,
+0x80,0x36,0x62,0xAE,
+0x00,0x00,0x23,0x8E,
+0xFA,0x1B,0x00,0x08,
+0xC2,0x13,0x03,0x00,
+0x02,0x80,0x09,0x3C,
+0x00,0x01,0x02,0x36,
+0x30,0x1F,0x29,0x25,
+0x00,0x00,0x47,0xAC,
+0xE8,0x37,0x27,0xAD,
+0x02,0x80,0x02,0x3C,
+0x08,0x04,0x44,0x24,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x91,0x3C,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0xAA,0x1A,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0xF0,0x37,0x22,0x8E,
+0xFF,0xFF,0x73,0x30,
+0x23,0x10,0x47,0x00,
+0xFF,0xFF,0x52,0x30,
+0x21,0x18,0x53,0x02,
+0xFF,0xFF,0x76,0x30,
+0x25,0x24,0x00,0x0C,
+0x21,0x20,0xC0,0x02,
+0xEF,0xFF,0x40,0x10,
+0x21,0xA0,0x40,0x00,
+0x08,0x00,0x42,0x8C,
+0xE8,0x37,0x26,0x8E,
+0x21,0x38,0x40,0x02,
+0x21,0x18,0x56,0x00,
+0xB8,0x37,0x23,0xAE,
+0x21,0x28,0x40,0x00,
+0x08,0x00,0x04,0x24,
+0xBC,0x37,0x22,0xAE,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x08,0x00,0x04,0x24,
+0xBC,0x37,0x25,0x8E,
+0x24,0x10,0x02,0x3C,
+0x00,0x01,0x10,0x36,
+0x00,0x00,0x02,0xAE,
+0x21,0x38,0x60,0x02,
+0x21,0x28,0xB2,0x00,
+0x08,0x00,0x04,0x24,
+0x24,0x10,0x06,0x3C,
+0xE8,0x37,0x22,0xAE,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xEC,0x37,0x23,0x8E,
+0x08,0x00,0x04,0x24,
+0xB0,0x01,0x00,0x0C,
+0xE8,0x37,0x23,0xAE,
+0xE8,0x37,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x02,0xAE,
+0x40,0x1B,0x00,0x08,
+0x02,0x80,0x09,0x3C,
+0xDC,0x1D,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xDC,0x1D,0xA2,0xAC,
+0x0C,0x00,0x24,0x8E,
+0x88,0x1B,0x00,0x08,
+0x3F,0x00,0x83,0x30,
+0xD8,0x1D,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xD8,0x1D,0xA2,0xAC,
+0x0C,0x00,0x24,0x8E,
+0x84,0x1B,0x00,0x08,
+0x3F,0x00,0x83,0x30,
+0x23,0x10,0x67,0x00,
+0xFF,0xFF,0x56,0x30,
+0x25,0x24,0x00,0x0C,
+0x21,0x20,0xC0,0x02,
+0x4A,0x00,0x40,0x10,
+0x21,0xA0,0x40,0x00,
+0x08,0x00,0x42,0x8C,
+0xE8,0x37,0x26,0x8E,
+0x08,0x00,0x04,0x24,
+0x21,0x18,0x56,0x00,
+0xB8,0x37,0x23,0xAE,
+0x21,0x28,0x40,0x00,
+0x21,0x38,0xC0,0x02,
+0xBC,0x37,0x22,0xAE,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xEC,0x37,0x23,0x8E,
+0x08,0x00,0x04,0x24,
+0xB0,0x01,0x00,0x0C,
+0xE8,0x37,0x23,0xAE,
+0xE8,0x37,0x23,0x8E,
+0x00,0x01,0x02,0x36,
+0x00,0x00,0x43,0xAC,
+0x40,0x1B,0x00,0x08,
+0x02,0x80,0x09,0x3C,
+0x04,0x00,0x23,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x14,0x03,0x00,
+0x0F,0x00,0x42,0x30,
+0x08,0x00,0x42,0x28,
+0x8B,0xFF,0x40,0x10,
+0x25,0xB0,0x02,0x3C,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x42,0x30,
+0x86,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x80,0x28,0x10,0x00,
+0x21,0x28,0xB5,0x00,
+0xF7,0x19,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x4C,0x1A,0x00,0x0C,
+0x21,0x20,0x40,0x00,
+0x21,0x20,0x40,0x00,
+0x56,0x1A,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0xF1,0x1B,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x04,0x00,0x23,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x14,0x03,0x00,
+0x0F,0x00,0x42,0x30,
+0x08,0x00,0x42,0x28,
+0x06,0x00,0x40,0x10,
+0x00,0xC0,0x02,0x3C,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x42,0x30,
+0x0C,0x00,0x40,0x10,
+0x80,0x28,0x10,0x00,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0x62,0x00,
+0x68,0xFF,0x40,0x14,
+0x02,0x17,0x03,0x00,
+0x03,0x00,0x42,0x30,
+0x03,0x00,0x03,0x24,
+0x64,0xFF,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x62,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x80,0x28,0x10,0x00,
+0x21,0x28,0xB5,0x00,
+0xF7,0x19,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x4C,0x1A,0x00,0x0C,
+0x21,0x20,0x40,0x00,
+0x21,0x20,0x40,0x00,
+0x56,0x1A,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0xEC,0x1B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xEC,0x37,0x23,0x8E,
+0x00,0x01,0x02,0x36,
+0x00,0x00,0x43,0xAC,
+0x07,0x1C,0x00,0x08,
+0xE8,0x37,0x23,0xAE,
+0xB8,0xFF,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x44,0x00,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x0E,0x00,0x40,0x04,
+0x18,0x00,0xA0,0xAF,
+0x21,0x20,0x60,0x00,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0x64,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0xF6,0xFF,0x41,0x04,
+0x21,0x10,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x74,0x57,0x43,0x8C,
+0x00,0x80,0x06,0x3C,
+0x6C,0x72,0xC2,0x24,
+0x25,0xB0,0x05,0x3C,
+0x02,0x80,0x06,0x3C,
+0x18,0x03,0xA4,0x34,
+0x74,0x57,0xD2,0x24,
+0x00,0x00,0x82,0xAC,
+0x67,0x00,0x72,0x10,
+0x01,0x00,0x16,0x24,
+0x11,0x11,0x02,0x3C,
+0x2A,0xB0,0x03,0x3C,
+0x22,0x22,0x5E,0x34,
+0x02,0x80,0x02,0x3C,
+0x21,0xB8,0x80,0x00,
+0x05,0x00,0x74,0x34,
+0x30,0x1F,0x55,0x24,
+0x01,0x00,0x13,0x24,
+0x00,0x00,0xFE,0xAE,
+0x21,0x00,0xC0,0x12,
+0x2A,0xB0,0x03,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF4,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x40,0x10,
+0x21,0xB0,0x00,0x00,
+0x01,0x00,0x06,0x24,
+0x18,0x00,0xA6,0xAF,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x03,0x3C,
+0xF6,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x5F,0x00,0x40,0x14,
+0x04,0x00,0x04,0x24,
+0x02,0x80,0x06,0x3C,
+0xDE,0x5D,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x55,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x2A,0xB0,0x03,0x3C,
+0x06,0x00,0x63,0x34,
+0x00,0x00,0x62,0x94,
+0x44,0x38,0xB1,0x8E,
+0x25,0xB0,0x06,0x3C,
+0xB0,0x03,0xC6,0x34,
+0x00,0xFF,0x42,0x30,
+0x00,0x00,0xD1,0xAC,
+0x0F,0x00,0x40,0x18,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x4C,0xEB,0x42,0x24,
+0x50,0xEB,0x63,0x24,
+0x00,0x00,0x45,0x8C,
+0x00,0x00,0x64,0x8C,
+0x02,0x80,0x06,0x3C,
+0x54,0xEB,0xC6,0x24,
+0x00,0x00,0xC3,0x8C,
+0x00,0x00,0xA4,0xAC,
+0x00,0x00,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0xFF,0x42,0x30,
+0xFB,0xFF,0x40,0x1C,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x23,0x8E,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x62,0x30,
+0x47,0x00,0x40,0x14,
+0x08,0x00,0x62,0x24,
+0xC2,0x10,0x03,0x00,
+0x08,0x00,0x25,0x8E,
+0x04,0x37,0xA6,0x8E,
+0xC0,0x10,0x02,0x00,
+0x20,0x00,0x42,0x24,
+0xFF,0xFF,0x47,0x30,
+0x01,0x00,0x04,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xB3,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x02,0x24,
+0x00,0x00,0x93,0xA2,
+0x00,0x00,0x82,0xA2,
+0x00,0x60,0x10,0x40,
+0x01,0x00,0x01,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x04,0x00,0x23,0x8E,
+0x00,0x00,0x22,0x8E,
+0x21,0x20,0x20,0x02,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0x31,0xAE,
+0x3D,0x24,0x00,0x0C,
+0x04,0x00,0x31,0xAE,
+0x00,0x60,0x90,0x40,
+0x00,0x00,0x42,0x8E,
+0x00,0x00,0x00,0x00,
+0xA3,0xFF,0x52,0x14,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF4,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x11,0x00,0x40,0x14,
+0x18,0x00,0xA0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x08,0x08,0x44,0x24,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x91,0x3C,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0xBC,0x1C,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x9B,0x30,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xEA,0x1C,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0x64,0x31,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0xE4,0x1C,0x00,0x08,
+0x02,0x80,0x06,0x3C,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x06,0x3C,
+0xF5,0x5E,0xC4,0x90,
+0x01,0x00,0x05,0x24,
+0x64,0x31,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x36,0x1D,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x0E,0x1D,0x00,0x08,
+0xC2,0x10,0x02,0x00,
+0x10,0x00,0xE0,0x18,
+0x21,0x18,0x00,0x00,
+0x00,0x00,0xC0,0xAC,
+0x21,0x40,0x00,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x45,0x10,
+0x21,0x18,0x80,0x00,
+0x01,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x48,0x00,
+0x02,0x00,0x68,0x24,
+0x21,0x10,0x82,0x00,
+0x2B,0x18,0x07,0x01,
+0xF5,0xFF,0x60,0x14,
+0x02,0x00,0x44,0x24,
+0x21,0x18,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x01,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x02,0x80,0x07,0x3C,
+0x30,0x1F,0xE5,0x24,
+0x22,0x3E,0xA3,0x90,
+0xFF,0x00,0x84,0x30,
+0x80,0x10,0x04,0x00,
+0x0C,0x00,0x60,0x14,
+0x21,0x30,0x45,0x00,
+0xC8,0x00,0x02,0x24,
+0x24,0x39,0xA2,0xAC,
+0x01,0x00,0x03,0x24,
+0x30,0x1F,0xE2,0x24,
+0x04,0x18,0x83,0x00,
+0x4C,0x3E,0xA4,0xA0,
+0x22,0x3E,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x64,0x00,
+0x08,0x00,0xE0,0x03,
+0x22,0x3E,0x43,0xA0,
+0x24,0x39,0xA3,0x8C,
+0xC8,0x00,0x02,0x24,
+0x23,0x10,0x43,0x00,
+0x24,0x3E,0xC2,0xAC,
+0x01,0x00,0x03,0x24,
+0x30,0x1F,0xE2,0x24,
+0x04,0x18,0x83,0x00,
+0x22,0x3E,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x64,0x00,
+0x08,0x00,0xE0,0x03,
+0x22,0x3E,0x43,0xA0,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x30,0x1F,0x25,0x26,
+0x4C,0x3E,0xA6,0x90,
+0x01,0x00,0x02,0x24,
+0x04,0x10,0xC2,0x00,
+0x06,0x00,0x40,0x14,
+0xC9,0x00,0x10,0x24,
+0x1A,0x3E,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x23,0x00,0x40,0x14,
+0x21,0x20,0xC5,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x46,0x24,
+0x21,0x20,0x00,0x00,
+0x24,0x3E,0xC5,0x24,
+0x00,0x00,0xA2,0x8C,
+0x04,0x00,0xA5,0x24,
+0x05,0x00,0x40,0x10,
+0x2B,0x18,0x50,0x00,
+0x03,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x40,0x00,
+0x4C,0x3E,0xC4,0xA0,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0x82,0x2C,
+0xF5,0xFF,0x40,0x14,
+0xC9,0x00,0x02,0x24,
+0x21,0x00,0x02,0x12,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x45,0x24,
+0x07,0x00,0x04,0x24,
+0x24,0x3E,0xA2,0x8C,
+0xFF,0xFF,0x84,0x24,
+0x02,0x00,0x40,0x10,
+0x23,0x18,0x50,0x00,
+0x24,0x3E,0xA3,0xAC,
+0xFA,0xFF,0x81,0x04,
+0x04,0x00,0xA5,0x24,
+0x30,0x1F,0x22,0x26,
+0x24,0x39,0x50,0xAC,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x44,0x3E,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x63,0x24,
+0xFF,0x00,0x62,0x30,
+0x03,0x00,0x42,0x2C,
+0xD8,0xFF,0x40,0x10,
+0x44,0x3E,0x83,0xA0,
+0x80,0x18,0x06,0x00,
+0x21,0x18,0x65,0x00,
+0xC8,0x00,0x02,0x24,
+0x03,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x90,0x14,0x00,0x0C,
+0x24,0x3E,0x62,0xAC,
+0x9C,0x1D,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x22,0x26,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x20,0x00,0xBD,0x27,
+0x22,0x3E,0x40,0xA0,
+0x08,0x00,0xE0,0x03,
+0x24,0x39,0x40,0xAC,
+0xB8,0xFF,0xBD,0x27,
+0x02,0x80,0x08,0x3C,
+0x02,0x80,0x0B,0x3C,
+0x02,0x80,0x0C,0x3C,
+0x40,0x00,0xBF,0xAF,
+0x3C,0x00,0xB5,0xAF,
+0x38,0x00,0xB4,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x2C,0x00,0xB1,0xAF,
+0x28,0x00,0xB0,0xAF,
+0x40,0xED,0x63,0x25,
+0x3C,0xED,0x02,0x25,
+0x44,0xED,0x84,0x25,
+0x01,0x00,0x45,0x90,
+0x01,0x00,0x66,0x90,
+0x01,0x00,0x87,0x90,
+0x3C,0xED,0x0F,0x91,
+0x02,0x00,0x4A,0x90,
+0x40,0xED,0x6E,0x91,
+0x02,0x00,0x69,0x90,
+0x44,0xED,0x8D,0x91,
+0x02,0x00,0x88,0x90,
+0x03,0x00,0x4B,0x90,
+0x03,0x00,0x6C,0x90,
+0x03,0x00,0x82,0x90,
+0x00,0x2A,0x05,0x00,
+0x00,0x32,0x06,0x00,
+0x00,0x3A,0x07,0x00,
+0x25,0x28,0xAF,0x00,
+0x25,0x30,0xCE,0x00,
+0x25,0x38,0xED,0x00,
+0x00,0x54,0x0A,0x00,
+0x00,0x4C,0x09,0x00,
+0x00,0x44,0x08,0x00,
+0x25,0x50,0x45,0x01,
+0x25,0x48,0x26,0x01,
+0x25,0x40,0x07,0x01,
+0x00,0x5E,0x0B,0x00,
+0x00,0x66,0x0C,0x00,
+0x00,0x16,0x02,0x00,
+0x02,0x80,0x04,0x3C,
+0x25,0x58,0x6A,0x01,
+0x25,0x60,0x89,0x01,
+0x25,0x10,0x48,0x00,
+0x84,0x58,0x84,0x24,
+0x10,0x00,0xAB,0xAF,
+0x18,0x00,0xAC,0xAF,
+0x34,0x4F,0x00,0x0C,
+0x20,0x00,0xA2,0xAF,
+0x10,0x00,0x42,0x30,
+0x29,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x13,0x3C,
+0x30,0x1F,0x63,0x26,
+0xC4,0x39,0x62,0x8C,
+0x0C,0x00,0x10,0x24,
+0x2B,0x10,0x02,0x02,
+0x2C,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF8,0x58,0x51,0x24,
+0x02,0x59,0x72,0x24,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xFA,0x58,0x54,0x24,
+0x26,0x1E,0x00,0x08,
+0x06,0x59,0x75,0x24,
+0xDD,0x00,0x02,0x24,
+0x21,0x20,0x14,0x02,
+0x2B,0x00,0x62,0x10,
+0x10,0x00,0xA5,0x27,
+0x21,0x10,0x11,0x02,
+0x01,0x00,0x43,0x90,
+0x30,0x1F,0x64,0x26,
+0xC4,0x39,0x82,0x8C,
+0x21,0x18,0x70,0x00,
+0x02,0x00,0x70,0x24,
+0x2B,0x10,0x02,0x02,
+0x17,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x11,0x02,
+0x00,0x00,0x43,0x90,
+0x30,0x00,0x02,0x24,
+0x21,0x20,0x12,0x02,
+0x20,0x00,0xA5,0x27,
+0xED,0xFF,0x62,0x14,
+0x04,0x00,0x06,0x24,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEE,0xFF,0x40,0x14,
+0x21,0x10,0x11,0x02,
+0x01,0x00,0x03,0x24,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x40,0x00,0xBF,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x21,0x18,0x00,0x00,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x15,0x02,
+0x18,0x00,0xA5,0x27,
+0xD1,0xFF,0x40,0x14,
+0x04,0x00,0x06,0x24,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xCE,0xFF,0x40,0x14,
+0x21,0x10,0x11,0x02,
+0x32,0x1E,0x00,0x08,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x38,0x5D,0x43,0x94,
+0x00,0x00,0x00,0x00,
+0x80,0x18,0x03,0x00,
+0xB8,0x0B,0x62,0x28,
+0x04,0x00,0x40,0x14,
+0xB8,0x0B,0x04,0x24,
+0x21,0x4E,0x62,0x28,
+0x20,0x4E,0x04,0x24,
+0x0B,0x20,0x62,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x21,0x38,0x80,0x00,
+0x08,0x00,0xC0,0x10,
+0xFF,0xFF,0xC3,0x24,
+0xFF,0xFF,0x06,0x24,
+0x00,0x00,0xA2,0x8C,
+0xFF,0xFF,0x63,0x24,
+0x04,0x00,0xA5,0x24,
+0x00,0x00,0xE2,0xAC,
+0xFB,0xFF,0x66,0x14,
+0x04,0x00,0xE7,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x25,0xB0,0x03,0x3C,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x94,0x0E,0x65,0x34,
+0x9C,0x0E,0x66,0x34,
+0xA4,0x0E,0x67,0x34,
+0xAC,0x0E,0x68,0x34,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0xA9,0x8C,
+0x30,0x1F,0x58,0x24,
+0x00,0x00,0xCC,0x8C,
+0x00,0x00,0xF1,0x8C,
+0x00,0x00,0x05,0x8D,
+0x0C,0x00,0x07,0x8F,
+0x10,0x00,0x08,0x8F,
+0xFF,0x03,0x0A,0x3C,
+0xB4,0x0E,0x62,0x34,
+0x00,0x00,0x4B,0x8C,
+0x24,0x48,0x2A,0x01,
+0x00,0xFC,0x02,0x24,
+0x24,0x28,0xAA,0x00,
+0xBC,0x0E,0x66,0x34,
+0x24,0x40,0x02,0x01,
+0x02,0x4C,0x09,0x00,
+0x24,0x38,0xE2,0x00,
+0x02,0x2C,0x05,0x00,
+0xF0,0xFF,0x02,0x3C,
+0x00,0x00,0xD0,0x8C,
+0xFF,0x03,0x42,0x34,
+0xCC,0x0E,0x66,0x34,
+0x25,0x38,0xE9,0x00,
+0xC4,0x0E,0x63,0x34,
+0x25,0x40,0x05,0x01,
+0x08,0x00,0x0D,0x8F,
+0x00,0x00,0x6F,0x8C,
+0x24,0x40,0x02,0x01,
+0x00,0x00,0xCE,0x8C,
+0x24,0x38,0xE2,0x00,
+0x24,0x60,0x8A,0x01,
+0x24,0x58,0x6A,0x01,
+0xFF,0x9F,0x02,0x3C,
+0x82,0x61,0x0C,0x00,
+0x82,0x59,0x0B,0x00,
+0xFF,0xFF,0x42,0x34,
+0x0F,0xC0,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x25,0x38,0xEC,0x00,
+0x25,0x40,0x0B,0x01,
+0x24,0x68,0xA2,0x01,
+0xFF,0x00,0x0B,0x3C,
+0x00,0xFF,0x82,0x30,
+0x24,0x88,0x2A,0x02,
+0x24,0x80,0x0A,0x02,
+0x24,0x18,0x8B,0x00,
+0x24,0x40,0x05,0x01,
+0x21,0x48,0x80,0x00,
+0x02,0x62,0x02,0x00,
+0x24,0x38,0xE5,0x00,
+0x00,0x20,0x02,0x3C,
+0x24,0x70,0xCA,0x01,
+0x00,0x89,0x11,0x00,
+0x00,0x81,0x10,0x00,
+0x24,0x78,0xEA,0x01,
+0x00,0xFF,0x6B,0x35,
+0x25,0x68,0xA2,0x01,
+0x02,0x1C,0x03,0x00,
+0x02,0x80,0x04,0x3C,
+0x25,0x38,0xF1,0x00,
+0x25,0x40,0x10,0x01,
+0x02,0x7C,0x0F,0x00,
+0x02,0x74,0x0E,0x00,
+0x24,0x48,0x2B,0x01,
+0xDC,0xE3,0x84,0x24,
+0x21,0x28,0x80,0x01,
+0x21,0x30,0x60,0x00,
+0x12,0x00,0x02,0x24,
+0x08,0x00,0x0D,0xAF,
+0x0C,0x00,0x07,0xAF,
+0x10,0x00,0x08,0xAF,
+0x14,0x00,0x0F,0xA7,
+0x0A,0x00,0x20,0x15,
+0x16,0x00,0x0E,0xA7,
+0x10,0x00,0xA4,0x27,
+0xC7,0x02,0x02,0xA3,
+0xC8,0x5C,0x00,0x0C,
+0xC3,0x02,0x02,0xA3,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xC7,0x02,0x03,0xA3,
+0x2F,0x55,0x00,0x0C,
+0xC3,0x02,0x0C,0xA3,
+0xC8,0x5C,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x28,0x00,0xB6,0xAF,
+0x25,0xB0,0x02,0x3C,
+0x00,0x80,0x16,0x3C,
+0x48,0x7B,0xC3,0x26,
+0x18,0x03,0x42,0x34,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x43,0xAC,
+0x21,0x98,0x00,0x00,
+0x02,0x80,0x15,0x3C,
+0x00,0x80,0x1E,0x3C,
+0x02,0x80,0x14,0x3C,
+0x02,0x80,0x17,0x3C,
+0x25,0xB0,0x10,0x3C,
+0x18,0x03,0x02,0x36,
+0x48,0x7B,0xC3,0x26,
+0x00,0x00,0x43,0xAC,
+0x30,0x1F,0xB1,0x26,
+0x7C,0x36,0x24,0x96,
+0x70,0x03,0x05,0x36,
+0x00,0x00,0xB2,0x8C,
+0x01,0x00,0x84,0x24,
+0x03,0x00,0x40,0x12,
+0x7C,0x36,0x24,0xA6,
+0x01,0x00,0x62,0x26,
+0xFF,0xFF,0x53,0x30,
+0xFF,0x00,0x04,0x3C,
+0xFF,0xFF,0x82,0x34,
+0x2B,0x10,0x52,0x00,
+0x47,0x00,0x40,0x10,
+0x00,0x50,0x62,0x2E,
+0x00,0xFF,0x06,0x3C,
+0xFF,0x00,0xC2,0x34,
+0x00,0xFD,0x05,0x3C,
+0x24,0x18,0x42,0x02,
+0x29,0x00,0xA2,0x34,
+0xA7,0x01,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0x46,0x00,0x40,0x14,
+0xAC,0x00,0xA2,0x34,
+0x00,0xF2,0x06,0x3C,
+0x01,0x00,0xC2,0x34,
+0xB8,0x01,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0x7D,0x00,0x40,0x14,
+0x07,0x00,0xA2,0x34,
+0x00,0xF0,0x05,0x3C,
+0x03,0x00,0xA2,0x34,
+0xD5,0x01,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0xC8,0x00,0x40,0x14,
+0x00,0xF1,0x07,0x3C,
+0x21,0x02,0x65,0x10,
+0x00,0xFF,0x82,0x34,
+0x2B,0x10,0xA3,0x00,
+0x48,0x01,0x40,0x14,
+0x01,0x00,0xA2,0x34,
+0x00,0xE0,0x02,0x3C,
+0x73,0x01,0x62,0x10,
+0x00,0xFF,0x48,0x32,
+0x25,0xB0,0x02,0x3C,
+0x70,0x03,0x42,0x34,
+0x21,0x98,0x00,0x00,
+0x00,0x00,0x40,0xAC,
+0x25,0xB0,0x04,0x3C,
+0x18,0x03,0x82,0x34,
+0x48,0x7C,0xC3,0x27,
+0x00,0x00,0x43,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x6C,0x57,0x82,0x8E,
+0x6C,0x57,0x83,0x26,
+0x10,0x00,0x43,0x10,
+0x02,0x80,0x02,0x3C,
+0xBF,0x00,0x92,0x34,
+0x30,0x1F,0x51,0x24,
+0x21,0x80,0x60,0x00,
+0x00,0x00,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x2C,
+0x08,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x3C,0x38,0x24,0x8E,
+0xB4,0x08,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x6C,0x57,0x83,0x8E,
+0x00,0x00,0x00,0x00,
+0xF5,0xFF,0x70,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x21,0x28,0x00,0x00,
+0x08,0x10,0xE4,0x26,
+0x21,0x30,0x00,0x00,
+0x91,0x3C,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0xE8,0x1E,0x00,0x08,
+0x25,0xB0,0x10,0x3C,
+0xDA,0xFF,0x40,0x14,
+0x74,0x03,0x03,0x36,
+0xFF,0xFF,0x02,0x24,
+0x21,0x98,0x00,0x00,
+0x00,0x00,0xA0,0xAC,
+0x00,0x00,0x62,0xAC,
+0x1B,0x1F,0x00,0x08,
+0x25,0xB0,0x04,0x3C,
+0x84,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0x1E,0x00,0x40,0x14,
+0x00,0xFE,0x07,0x3C,
+0xA4,0x00,0xA2,0x34,
+0x8F,0x01,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0x47,0x00,0x40,0x14,
+0xA7,0x00,0xA2,0x34,
+0xA1,0x00,0xA2,0x34,
+0xEA,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0xAD,0x00,0x40,0x14,
+0xA2,0x00,0xA2,0x34,
+0xA0,0x00,0xA2,0x34,
+0xBE,0xFF,0x62,0x14,
+0x25,0xB0,0x02,0x3C,
+0x00,0x0F,0x42,0x32,
+0x02,0x22,0x02,0x00,
+0x01,0x00,0x03,0x24,
+0x96,0x02,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x02,0x24,
+0x8F,0x02,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x02,0x24,
+0x88,0x02,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0xCD,0x5A,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x12,0x00,0xE2,0x34,
+0x65,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0x37,0x00,0x40,0x14,
+0x1A,0x00,0xE2,0x34,
+0xAF,0x00,0xA2,0x34,
+0xC8,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0x97,0x00,0x40,0x14,
+0x10,0x00,0xE2,0x34,
+0xAD,0x00,0xA2,0x34,
+0x44,0x02,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0xAE,0x00,0xA2,0x34,
+0x9C,0xFF,0x62,0x14,
+0x02,0x24,0x12,0x00,
+0x00,0xFF,0x45,0x32,
+0xFF,0x00,0x84,0x30,
+0x58,0x5A,0x00,0x0C,
+0x02,0x2A,0x05,0x00,
+0x25,0xB0,0x03,0x3C,
+0x74,0x03,0x63,0x34,
+0x00,0x00,0x62,0xA0,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x73,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0x35,0x00,0x40,0x14,
+0x18,0x00,0xA2,0x34,
+0x00,0xF8,0x04,0x3C,
+0x16,0x00,0x82,0x34,
+0xB6,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0x90,0x00,0x40,0x14,
+0x17,0x00,0x82,0x34,
+0x15,0x00,0x82,0x34,
+0x84,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0xA7,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x6A,0x01,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0xB7,0x00,0x40,0x14,
+0xAA,0x00,0xA2,0x34,
+0xA5,0x00,0xA2,0x34,
+0x35,0x02,0x62,0x10,
+0x24,0x20,0x44,0x02,
+0xA6,0x00,0xA2,0x34,
+0x76,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0xF7,0x5B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x75,0x01,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0x80,0x00,0x40,0x14,
+0x0F,0x00,0xC2,0x34,
+0x18,0x00,0xE2,0x34,
+0xC1,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0xE2,0x34,
+0x68,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xA2,0x26,
+0x2A,0x1C,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x74,0x03,0x63,0x34,
+0x00,0x00,0x64,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x3E,0x01,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0x74,0x00,0x40,0x14,
+0x19,0x00,0xA2,0x34,
+0x14,0x00,0xA2,0x34,
+0x96,0x01,0x62,0x10,
+0x17,0x00,0xA2,0x34,
+0x51,0xFF,0x62,0x14,
+0x25,0xB0,0x04,0x3C,
+0x68,0x03,0x85,0x34,
+0x00,0x00,0xA3,0x8C,
+0x00,0xFF,0x42,0x32,
+0x00,0x12,0x02,0x00,
+0xFF,0xFF,0x73,0x30,
+0x25,0x10,0x53,0x00,
+0x00,0x00,0xA2,0xAC,
+0x64,0x03,0x84,0x34,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x53,0x30,
+0x40,0x00,0x63,0x36,
+0x00,0x00,0x83,0xA0,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x02,0x00,0xE2,0x34,
+0x3F,0xFF,0x62,0x10,
+0x2B,0x10,0x43,0x00,
+0x9B,0x00,0x40,0x14,
+0x04,0x00,0xE2,0x34,
+0x08,0x00,0xA2,0x34,
+0xA3,0x01,0x62,0x10,
+0x00,0xFF,0x42,0x32,
+0x38,0xFF,0x67,0x14,
+0x25,0xB0,0x04,0x3C,
+0xFF,0x00,0x05,0x3C,
+0x00,0xFF,0xA5,0x34,
+0x24,0x28,0x45,0x02,
+0x02,0x2A,0x05,0x00,
+0x94,0x00,0x83,0x34,
+0x40,0x11,0x05,0x00,
+0x26,0xB0,0x06,0x3C,
+0x00,0x00,0x65,0xA4,
+0xC0,0xFF,0x53,0x24,
+0x7C,0x00,0xCC,0x34,
+0x04,0x00,0x07,0x24,
+0x9A,0x00,0x88,0x34,
+0x98,0x00,0x89,0x34,
+0x96,0x00,0x8A,0x34,
+0x7A,0x00,0xC6,0x34,
+0xB0,0x03,0x8B,0x34,
+0x00,0x04,0x02,0x24,
+0xA0,0x00,0x03,0x24,
+0x00,0x00,0x02,0xA5,
+0x44,0x00,0x84,0x34,
+0x00,0x00,0x23,0xA5,
+0x00,0x00,0x47,0xA5,
+0x00,0x00,0xC7,0xA0,
+0x00,0x00,0x73,0xAD,
+0x00,0x00,0x93,0xA5,
+0x00,0x00,0x83,0x94,
+0xFF,0xFD,0x02,0x24,
+0x30,0x1F,0xA6,0x26,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0x83,0xA4,
+0x00,0x00,0x82,0x94,
+0xBA,0x1B,0xC5,0xA4,
+0x00,0x02,0x42,0x34,
+0x00,0x00,0x82,0xA4,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xBF,0x01,0x62,0x10,
+0x25,0xB0,0x02,0x3C,
+0xA3,0x00,0xA2,0x34,
+0x10,0xFF,0x62,0x14,
+0x25,0xB0,0x02,0x3C,
+0x30,0x1F,0xA2,0x26,
+0x16,0x1F,0x00,0x08,
+0x30,0x38,0x40,0xAC,
+0x3A,0x01,0x62,0x10,
+0x11,0x00,0xE2,0x34,
+0x08,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xFF,0x00,0x04,0x3C,
+0x00,0xFF,0x84,0x34,
+0x24,0x20,0x44,0x02,
+0x30,0x1F,0xA2,0x26,
+0x02,0x22,0x04,0x00,
+0xC2,0x34,0x00,0x0C,
+0x2A,0x1C,0x40,0xA0,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x9F,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x82,0x34,
+0xF3,0xFE,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x0A,0x23,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x4E,0x01,0x62,0x10,
+0x10,0x00,0xC2,0x34,
+0xEC,0xFE,0x62,0x14,
+0x25,0xB0,0x02,0x3C,
+0x00,0xFF,0x43,0x32,
+0x00,0xFF,0x02,0x34,
+0xDA,0xFF,0x62,0x14,
+0x30,0x1F,0xA2,0x26,
+0x30,0x1F,0xA3,0x26,
+0xFF,0xFF,0x02,0x34,
+0x16,0x1F,0x00,0x08,
+0x30,0x38,0x62,0xAC,
+0x96,0x01,0x62,0x10,
+0x25,0xB0,0x02,0x3C,
+0x28,0x00,0xA2,0x34,
+0xDE,0xFE,0x62,0x14,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0x60,0x00,0x06,0x24,
+0x5F,0x47,0x00,0x0C,
+0x24,0x00,0x04,0x24,
+0x25,0x22,0x00,0x0C,
+0xE8,0x03,0x04,0x24,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x24,0x00,0x04,0x24,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x05,0x36,
+0x1F,0x00,0x53,0x30,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x25,0xB0,0x02,0x3C,
+0x74,0x03,0x42,0x34,
+0x00,0x00,0x53,0xA0,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x84,0x01,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0xAB,0x00,0xA2,0x34,
+0xC1,0xFE,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0xE6,0x5F,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x01,0x62,0x10,
+0x25,0xB0,0x02,0x3C,
+0x02,0x00,0xA2,0x34,
+0xB9,0xFE,0x62,0x14,
+0x25,0xB0,0x02,0x3C,
+0x02,0x14,0x12,0x00,
+0x00,0xFF,0x43,0x32,
+0xFF,0x00,0x45,0x30,
+0x04,0x00,0xA0,0x10,
+0x02,0x92,0x03,0x00,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0xA2,0x10,
+0x01,0x00,0x04,0x24,
+0x21,0x20,0x00,0x00,
+0xE6,0x44,0x00,0x0C,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0x8A,0x47,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0xFF,0xFF,0x10,0x36,
+0x24,0x98,0x50,0x00,
+0x25,0xB0,0x02,0x3C,
+0x74,0x03,0x42,0x34,
+0x00,0x00,0x53,0xAC,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x15,0x01,0x62,0x10,
+0x24,0x10,0x44,0x02,
+0xA0,0xFE,0x66,0x14,
+0x25,0xB0,0x02,0x3C,
+0x25,0xB0,0x05,0x3C,
+0x74,0x03,0xA3,0x34,
+0x00,0x00,0x64,0x8C,
+0xFF,0x0F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x90,0x82,0x00,
+0x01,0x00,0x03,0x3C,
+0x2B,0x18,0x72,0x00,
+0x95,0xFE,0x60,0x10,
+0x00,0xB0,0x02,0x3C,
+0x25,0x90,0x42,0x02,
+0x00,0x00,0x53,0x8E,
+0x78,0x03,0xA2,0x34,
+0x00,0x00,0x53,0xAC,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x02,0x1A,0x08,0x00,
+0xFF,0x00,0x02,0x24,
+0x56,0x01,0x62,0x10,
+0x25,0xB0,0x05,0x3C,
+0x0E,0x00,0x60,0x14,
+0x00,0xCC,0x02,0x34,
+0x25,0xB0,0x04,0x3C,
+0x64,0x03,0x84,0x34,
+0x30,0x1F,0xA7,0x26,
+0x00,0x00,0x85,0x94,
+0xE4,0x02,0xE6,0x8C,
+0xFF,0xCF,0x02,0x3C,
+0xFF,0xFE,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x24,0x28,0xA3,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x00,0x85,0xA4,
+0xE4,0x02,0xE6,0xAC,
+0x00,0xCC,0x02,0x34,
+0x7B,0xFE,0x02,0x15,
+0x25,0xB0,0x02,0x3C,
+0x30,0x1F,0xA5,0x26,
+0xE4,0x02,0xA3,0x8C,
+0xFF,0xCF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x10,0x04,0x3C,
+0x25,0x18,0x64,0x00,
+0x16,0x1F,0x00,0x08,
+0xE4,0x02,0xA3,0xAC,
+0x02,0x14,0x12,0x00,
+0x00,0x1F,0x43,0x32,
+0x02,0x9A,0x03,0x00,
+0x3F,0x00,0x42,0x30,
+0xC1,0x02,0x22,0xA2,
+0xBC,0x02,0x33,0xA2,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x76,0x2C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x98,0x40,0x00,
+0x74,0x03,0x02,0x36,
+0x00,0x00,0x53,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x03,0x00,0x22,0x92,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x16,0x1F,0x00,0x08,
+0x03,0x00,0x22,0xA2,
+0x74,0x03,0x03,0x36,
+0x00,0x00,0x64,0x8C,
+0xFF,0x0F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x90,0x82,0x00,
+0x01,0x00,0x03,0x3C,
+0x2B,0x18,0x72,0x00,
+0x51,0xFE,0x60,0x10,
+0x78,0x03,0x02,0x36,
+0x00,0x00,0x53,0x8C,
+0x00,0xB0,0x03,0x3C,
+0x25,0x90,0x43,0x02,
+0x00,0x00,0x53,0xAE,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xBE,0x59,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x00,0xFF,0x82,0x34,
+0x24,0x10,0x42,0x02,
+0x02,0x2A,0x02,0x00,
+0x2B,0x1C,0x25,0xA2,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xFF,0xFF,0x02,0x34,
+0x16,0x1F,0x00,0x08,
+0x30,0x38,0x22,0xAE,
+0x24,0x10,0x44,0x02,
+0x00,0xFF,0x43,0x32,
+0x02,0x2C,0x02,0x00,
+0x04,0x00,0xA0,0x10,
+0x02,0x92,0x03,0x00,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0xA2,0x10,
+0x01,0x00,0x04,0x24,
+0x21,0x20,0x00,0x00,
+0x25,0xB0,0x10,0x3C,
+0xE6,0x44,0x00,0x0C,
+0x74,0x03,0x10,0x36,
+0x00,0x00,0x13,0x8E,
+0x0F,0x00,0x11,0x3C,
+0x21,0x20,0x40,0x02,
+0x21,0x30,0x60,0x02,
+0x5F,0x47,0x00,0x0C,
+0xFF,0xFF,0x25,0x36,
+0x21,0x20,0x40,0x02,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x25,0x36,
+0x00,0x00,0x02,0xAE,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x85,0x5F,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x08,0x00,0x23,0x8E,
+0xFF,0x9F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x16,0x1F,0x00,0x08,
+0x08,0x00,0x23,0xAE,
+0x00,0xFF,0x42,0x32,
+0x24,0x18,0x44,0x02,
+0x02,0x9A,0x02,0x00,
+0x01,0x00,0x02,0x24,
+0x95,0x00,0x62,0x12,
+0x02,0x1C,0x03,0x00,
+0x02,0x00,0x02,0x24,
+0xA9,0x00,0x62,0x12,
+0xC0,0x10,0x03,0x00,
+0x03,0x00,0x02,0x24,
+0x09,0xFE,0x62,0x16,
+0xC0,0x10,0x03,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x02,0x80,0x04,0x3C,
+0x4C,0x43,0x83,0x24,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x25,0xB0,0x03,0x3C,
+0x74,0x03,0x63,0x34,
+0x00,0x00,0x64,0xAC,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0xFF,0x82,0x34,
+0x24,0x10,0x42,0x02,
+0x02,0x2A,0x02,0x00,
+0x01,0x00,0x03,0x24,
+0x77,0x00,0xA3,0x10,
+0x74,0x03,0x02,0x36,
+0x02,0x00,0xA2,0x28,
+0xB7,0x00,0x40,0x14,
+0x03,0x00,0x02,0x24,
+0x06,0x00,0xA2,0x10,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0xA2,0x26,
+0x24,0x1C,0x44,0x94,
+0x25,0xB0,0x03,0x3C,
+0x18,0x21,0x00,0x08,
+0x74,0x03,0x63,0x34,
+0x30,0x1F,0xA2,0x26,
+0x26,0x1C,0x44,0x94,
+0x25,0xB0,0x03,0x3C,
+0x18,0x21,0x00,0x08,
+0x74,0x03,0x63,0x34,
+0x24,0x10,0x42,0x02,
+0x02,0x92,0x02,0x00,
+0x21,0x18,0x50,0x02,
+0x00,0x00,0x73,0x8C,
+0x74,0x03,0x02,0x36,
+0x00,0x00,0x53,0xAC,
+0x00,0x00,0x73,0x8C,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xA6,0x5A,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x24,0x20,0x44,0x02,
+0x56,0x25,0x00,0x0C,
+0x02,0x24,0x04,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xD7,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xA3,0x26,
+0x2A,0x1C,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x6A,0xFE,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0xFF,0x82,0x34,
+0x24,0x10,0x42,0x02,
+0x02,0x2A,0x02,0x00,
+0x01,0x00,0x02,0x24,
+0x21,0x20,0xA0,0x00,
+0x2A,0x1C,0x62,0xA0,
+0xC2,0x34,0x00,0x0C,
+0x2B,0x1C,0x65,0xA0,
+0x1A,0x20,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0xFF,0x82,0x34,
+0x24,0x10,0x42,0x02,
+0xBB,0xFD,0x40,0x10,
+0x25,0xB0,0x02,0x3C,
+0x30,0x1F,0xA3,0x26,
+0x04,0x03,0x66,0x90,
+0x24,0x20,0x44,0x02,
+0x00,0xFF,0x45,0x32,
+0x02,0x24,0x04,0x00,
+0x02,0x2A,0x05,0x00,
+0x00,0x01,0xC6,0x34,
+0xFB,0xFF,0x87,0x24,
+0xFB,0xFF,0xA2,0x24,
+0x1F,0x03,0x62,0xA0,
+0x04,0x03,0x66,0xAC,
+0x1D,0x03,0x67,0xA0,
+0x1C,0x03,0x64,0xA0,
+0x16,0x1F,0x00,0x08,
+0x1E,0x03,0x65,0xA0,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0xA2,0x26,
+0x2B,0x1C,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x74,0x03,0x63,0x34,
+0x00,0x00,0x64,0xAC,
+0xB8,0x1F,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0xFF,0x00,0x02,0x24,
+0x56,0x01,0x63,0x34,
+0x00,0x00,0x62,0xA4,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x16,0x1F,0x00,0x08,
+0x08,0x5E,0x44,0xA0,
+0x02,0x92,0x02,0x00,
+0x05,0x00,0x40,0x12,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0x42,0x12,
+0x01,0x00,0x04,0x24,
+0x21,0x20,0x00,0x00,
+0xE6,0x44,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x02,0x9C,0x02,0x00,
+0x00,0xFF,0x43,0x32,
+0x07,0x00,0x62,0x2E,
+0x88,0xFD,0x40,0x10,
+0x02,0x2A,0x03,0x00,
+0x02,0x80,0x04,0x3C,
+0x50,0xED,0x83,0x24,
+0x80,0x10,0x13,0x00,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x22,0x1C,0x23,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xAC,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xC0,0x10,0x03,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x51,0x00,
+0x14,0x24,0x44,0x8C,
+0x74,0x03,0x03,0x36,
+0x00,0x00,0x64,0xAC,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0xFF,0x83,0x34,
+0x74,0x03,0x44,0x34,
+0x00,0x00,0x93,0x8C,
+0x24,0x18,0x43,0x02,
+0x02,0x92,0x03,0x00,
+0x21,0x10,0x42,0x02,
+0x00,0x00,0x53,0xAC,
+0x00,0x00,0x53,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x93,0xAC,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x51,0x00,
+0x18,0x24,0x44,0x8C,
+0xA4,0x21,0x00,0x08,
+0x74,0x03,0x03,0x36,
+0xCD,0x59,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x3D,0x23,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x74,0x03,0x42,0x34,
+0x00,0x00,0x45,0x8C,
+0x00,0xFF,0x84,0x34,
+0x24,0x20,0x44,0x02,
+0xC1,0x5B,0x00,0x0C,
+0x02,0x22,0x04,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x70,0x03,0x42,0x34,
+0x21,0x20,0x40,0x02,
+0x00,0x00,0x40,0xAC,
+0x6B,0x1E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xF5,0x5B,0x00,0x0C,
+0x02,0x24,0x04,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x4B,0xFF,0xA0,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0xA2,0x26,
+0x20,0x1C,0x44,0x94,
+0x25,0xB0,0x03,0x3C,
+0x18,0x21,0x00,0x08,
+0x74,0x03,0x63,0x34,
+0x64,0x03,0xA5,0x34,
+0x30,0x1F,0xA6,0x26,
+0x00,0x00,0xA3,0x94,
+0xE4,0x02,0xC4,0x8C,
+0xFF,0xCF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x00,0x01,0x63,0x34,
+0x00,0x00,0xA3,0xA4,
+0x9A,0x20,0x00,0x08,
+0xE4,0x02,0xC4,0xAC,
+0xCD,0x5A,0x00,0x0C,
+0x03,0x00,0x04,0x24,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xCD,0x5A,0x00,0x0C,
+0x02,0x00,0x04,0x24,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0xCD,0x5A,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x19,0x05,0x00,
+0x30,0x1F,0xA2,0x26,
+0x21,0x18,0x62,0x00,
+0x36,0x03,0x64,0x94,
+0x25,0xB0,0x02,0x3C,
+0x74,0x03,0x42,0x34,
+0x00,0x00,0x44,0xAC,
+0x17,0x1F,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x19,0x05,0x00,
+0x30,0x1F,0xA2,0x26,
+0x21,0x18,0x62,0x00,
+0x35,0x03,0x64,0x90,
+0xFD,0x21,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x19,0x05,0x00,
+0x30,0x1F,0xA2,0x26,
+0x21,0x18,0x62,0x00,
+0x34,0x03,0x64,0x90,
+0xFD,0x21,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x19,0x05,0x00,
+0x30,0x1F,0xA2,0x26,
+0x21,0x18,0x62,0x00,
+0x32,0x03,0x64,0x94,
+0xFD,0x21,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x19,0x05,0x00,
+0x30,0x1F,0xA2,0x26,
+0x21,0x18,0x62,0x00,
+0x30,0x03,0x64,0x94,
+0xFD,0x21,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x00,0x11,0x05,0x00,
+0x30,0x1F,0xA3,0x26,
+0x21,0x10,0x43,0x00,
+0x2C,0x03,0x44,0x8C,
+0xFC,0x21,0x00,0x08,
+0x42,0x26,0x04,0x00,
+0x00,0x11,0x05,0x00,
+0x30,0x1F,0xA3,0x26,
+0x21,0x10,0x43,0x00,
+0x2F,0x03,0x44,0x90,
+0xFC,0x21,0x00,0x08,
+0x01,0x00,0x84,0x30,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x18,0x03,0x42,0x34,
+0x94,0x88,0x63,0x24,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x05,0x3C,
+0xD4,0x5E,0xA5,0x8C,
+0x04,0x00,0x02,0x24,
+0x1E,0x00,0xA2,0x10,
+0x05,0x00,0xA2,0x2C,
+0x10,0x00,0x40,0x10,
+0x05,0x00,0x02,0x24,
+0x03,0x00,0x02,0x24,
+0x08,0x00,0xA2,0x10,
+0x00,0x19,0x04,0x00,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0xC0,0x10,0x02,0x00,
+0x23,0x10,0x44,0x00,
+0x00,0x11,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x40,0x19,0x02,0x00,
+0xFF,0xFF,0x63,0x24,
+0xFE,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0xA2,0x10,
+0x06,0x00,0x02,0x24,
+0xF2,0xFF,0xA2,0x14,
+0x80,0x10,0x04,0x00,
+0x40,0x11,0x04,0x00,
+0x23,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x00,0x19,0x02,0x00,
+0x23,0x18,0x62,0x00,
+0x3B,0x22,0x00,0x08,
+0x00,0x19,0x03,0x00,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0xC0,0x10,0x02,0x00,
+0x23,0x10,0x44,0x00,
+0x00,0x11,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x3B,0x22,0x00,0x08,
+0x00,0x19,0x02,0x00,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x50,0x89,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x05,0x3C,
+0xD4,0x5E,0xA3,0x8C,
+0x05,0x00,0x02,0x24,
+0x06,0x00,0x62,0x10,
+0x06,0x00,0x62,0x2C,
+0x0C,0x00,0x40,0x10,
+0x06,0x00,0x02,0x24,
+0x04,0x00,0x02,0x24,
+0x0E,0x00,0x62,0x10,
+0x80,0x10,0x04,0x00,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0xFF,0xFF,0x42,0x24,
+0xFE,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xF7,0xFF,0x62,0x14,
+0x00,0x11,0x04,0x00,
+0x23,0x10,0x44,0x00,
+0x66,0x22,0x00,0x08,
+0x40,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x66,0x22,0x00,0x08,
+0x40,0x10,0x02,0x00,
+0xFF,0xFF,0x85,0x30,
+0x21,0x30,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0x2A,0xB0,0x04,0x3C,
+0xB4,0x00,0x63,0x34,
+0x01,0x00,0xA2,0x24,
+0x31,0x00,0x84,0x34,
+0x00,0x00,0x65,0xA0,
+0x00,0x00,0x85,0xA0,
+0xFF,0xFF,0x45,0x30,
+0x12,0x00,0xA0,0x10,
+0x01,0x00,0x03,0x24,
+0x28,0xB0,0x07,0x3C,
+0x88,0x22,0x00,0x08,
+0xFF,0xFF,0x08,0x24,
+0x00,0x00,0x83,0xA0,
+0x01,0x00,0x63,0x24,
+0xFF,0xFF,0x63,0x30,
+0x2B,0x10,0xA3,0x00,
+0x09,0x00,0x40,0x14,
+0x08,0x00,0xC6,0x24,
+0xF9,0xFF,0x65,0x14,
+0x21,0x20,0xC7,0x00,
+0x01,0x00,0x63,0x24,
+0xFF,0xFF,0x63,0x30,
+0x2B,0x10,0xA3,0x00,
+0x00,0x00,0x88,0xA0,
+0xF9,0xFF,0x40,0x10,
+0x08,0x00,0xC6,0x24,
+0x00,0x01,0xA2,0x2C,
+0x13,0x00,0x40,0x10,
+0x21,0x18,0xA0,0x00,
+0xFF,0x00,0x08,0x24,
+0x28,0xB0,0x07,0x3C,
+0x9C,0x22,0x00,0x08,
+0xFF,0xFF,0x09,0x24,
+0xFF,0xFF,0x43,0x30,
+0x00,0x00,0xA2,0xA0,
+0x00,0x01,0x62,0x2C,
+0x0A,0x00,0x40,0x10,
+0x08,0x00,0xC6,0x24,
+0x01,0x00,0x62,0x24,
+0xF9,0xFF,0x68,0x14,
+0x21,0x28,0xC7,0x00,
+0x00,0x01,0x02,0x24,
+0xFF,0xFF,0x43,0x30,
+0x00,0x01,0x62,0x2C,
+0x00,0x00,0xA9,0xA0,
+0xF8,0xFF,0x40,0x14,
+0x08,0x00,0xC6,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD0,0xFF,0xBD,0x27,
+0x2C,0x00,0xBF,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x25,0xB0,0x10,0x3C,
+0x40,0x00,0x03,0x36,
+0x00,0x00,0x60,0xA4,
+0xA8,0x00,0x13,0x36,
+0xA0,0x00,0x12,0x36,
+0xA4,0x00,0x10,0x36,
+0x00,0x00,0x55,0x8E,
+0x00,0x00,0x16,0x8E,
+0x00,0x00,0x71,0x8E,
+0x00,0x80,0x14,0x3C,
+0xFC,0x37,0x02,0x24,
+0x00,0x00,0x40,0xAE,
+0xFD,0x00,0x04,0x24,
+0x00,0x00,0x00,0xAE,
+0x21,0x88,0x34,0x02,
+0x00,0x00,0x74,0xAE,
+0x00,0x00,0x62,0xA4,
+0x73,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x55,0xAE,
+0x00,0x00,0x16,0xAE,
+0x00,0x00,0x71,0xAE,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x2C,0x00,0xBF,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x25,0xB0,0x10,0x3C,
+0x40,0x00,0x05,0x36,
+0x00,0x00,0xA2,0x94,
+0x24,0xFA,0x03,0x24,
+0xA8,0x00,0x13,0x36,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0xA2,0xA4,
+0xA0,0x00,0x12,0x36,
+0xA4,0x00,0x10,0x36,
+0x00,0x00,0x55,0x8E,
+0x00,0x00,0x16,0x8E,
+0x00,0x00,0x71,0x8E,
+0x00,0x80,0x14,0x3C,
+0xFC,0x37,0x02,0x24,
+0x00,0x00,0x40,0xAE,
+0xFD,0x00,0x04,0x24,
+0x00,0x00,0x00,0xAE,
+0x21,0x88,0x34,0x02,
+0x00,0x00,0x74,0xAE,
+0x00,0x00,0xA2,0xA4,
+0x73,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x55,0xAE,
+0x00,0x00,0x16,0xAE,
+0x00,0x00,0x71,0xAE,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x2C,0x00,0xBF,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x25,0xB0,0x10,0x3C,
+0x40,0x00,0x05,0x36,
+0x00,0x00,0xA2,0x94,
+0xAF,0xFF,0x03,0x24,
+0xA8,0x00,0x13,0x36,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0xA2,0xA4,
+0xA0,0x00,0x12,0x36,
+0xA4,0x00,0x10,0x36,
+0x00,0x00,0x55,0x8E,
+0x00,0x00,0x16,0x8E,
+0x00,0x00,0x71,0x8E,
+0x00,0x80,0x14,0x3C,
+0xFC,0x37,0x02,0x24,
+0x00,0x00,0x40,0xAE,
+0xFD,0x00,0x04,0x24,
+0x00,0x00,0x00,0xAE,
+0x21,0x88,0x34,0x02,
+0x00,0x00,0x74,0xAE,
+0x00,0x00,0xA2,0xA4,
+0x73,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x55,0xAE,
+0x00,0x00,0x16,0xAE,
+0x00,0x00,0x71,0xAE,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x25,0xB0,0x04,0x3C,
+0x40,0x00,0x84,0x34,
+0x00,0x00,0x82,0x94,
+0xD8,0xFD,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0xFC,0x37,0x03,0x24,
+0x00,0x00,0x82,0xA4,
+0x00,0x00,0x83,0xA4,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x84,0x30,
+0xFF,0xFF,0xAC,0x30,
+0xC0,0x48,0x04,0x00,
+0x00,0x60,0x0E,0x40,
+0x01,0x00,0xC1,0x35,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x25,0xB0,0x02,0x3C,
+0x40,0x02,0x4D,0x34,
+0xF8,0xFF,0xE7,0x24,
+0x21,0x40,0x00,0x00,
+0x01,0x00,0x0F,0x24,
+0x44,0x02,0x4B,0x34,
+0x72,0x23,0x00,0x08,
+0x01,0x80,0x0A,0x3C,
+0x28,0x00,0x0F,0x11,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xE2,0x90,
+0x00,0x00,0xE4,0x90,
+0x02,0x00,0xE3,0x90,
+0x03,0x00,0xE5,0x90,
+0x00,0x12,0x02,0x00,
+0x25,0x20,0x82,0x00,
+0x00,0x1C,0x03,0x00,
+0x25,0x20,0x83,0x00,
+0x21,0x10,0x28,0x01,
+0x00,0x2E,0x05,0x00,
+0x01,0x00,0x08,0x25,
+0x25,0x20,0x85,0x00,
+0x25,0x10,0x4A,0x00,
+0x06,0x00,0x03,0x2D,
+0x00,0x00,0x64,0xAD,
+0x04,0x00,0xE7,0x24,
+0x00,0x00,0xA2,0xAD,
+0x12,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0xEA,0xFF,0x00,0x15,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0x90,
+0x01,0x00,0xC3,0x90,
+0x04,0x00,0xE7,0x24,
+0x00,0x14,0x02,0x00,
+0x25,0x10,0x82,0x01,
+0x00,0x1E,0x03,0x00,
+0x25,0x20,0x43,0x00,
+0x21,0x10,0x28,0x01,
+0x01,0x00,0x08,0x25,
+0x25,0x10,0x4A,0x00,
+0x06,0x00,0x03,0x2D,
+0x00,0x00,0x64,0xAD,
+0x00,0x00,0xA2,0xAD,
+0xF0,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x8E,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0xC2,0x90,
+0x02,0x00,0xC4,0x90,
+0x04,0x00,0xC3,0x90,
+0x05,0x00,0xC5,0x90,
+0x64,0x23,0x00,0x08,
+0x00,0x12,0x02,0x00,
+0xFF,0xFF,0x84,0x30,
+0x42,0xB0,0x08,0x3C,
+0x80,0x10,0x04,0x00,
+0x21,0x10,0x48,0x00,
+0x04,0x00,0x46,0xAC,
+0x00,0x00,0x07,0x91,
+0x40,0x18,0x04,0x00,
+0x03,0x00,0x06,0x24,
+0xFF,0x00,0xE7,0x30,
+0x04,0x30,0x66,0x00,
+0x01,0x00,0x02,0x24,
+0x04,0x10,0x62,0x00,
+0x25,0x30,0xC7,0x00,
+0xFF,0xFF,0xA5,0x30,
+0x25,0x10,0x47,0x00,
+0x02,0x00,0xA0,0x14,
+0xFF,0x00,0xC7,0x30,
+0xFF,0x00,0x47,0x30,
+0x42,0xB0,0x02,0x3C,
+0x00,0x00,0x47,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0x83,0x90,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x86,0xAC,
+0x18,0x00,0x85,0xAC,
+0x00,0x00,0x84,0xAC,
+0x03,0x00,0x62,0x10,
+0x04,0x00,0x84,0xAC,
+0x99,0x59,0x00,0x08,
+0x0C,0x00,0x80,0xAC,
+0x0C,0x00,0x82,0x8C,
+0x99,0x59,0x00,0x08,
+0x10,0x00,0x82,0xAC,
+0xC8,0xFF,0xBD,0x27,
+0x28,0x00,0xB6,0xAF,
+0x25,0xB0,0x02,0x3C,
+0x02,0x80,0x16,0x3C,
+0x2C,0x00,0xB7,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x18,0x03,0x55,0x34,
+0x01,0x80,0x17,0x3C,
+0x02,0x80,0x13,0x3C,
+0x02,0x80,0x14,0x3C,
+0x08,0xE4,0xD2,0x26,
+0xB8,0x8E,0xE2,0x26,
+0x00,0x00,0xA2,0xAE,
+0x08,0xE4,0xD0,0x8E,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x14,0x5E,0x71,0x8E,
+0x00,0x00,0x00,0x00,
+0x25,0x00,0x20,0x12,
+0x00,0x00,0x00,0x00,
+0x14,0x5E,0x60,0xAE,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x23,0x00,0x12,0x12,
+0x08,0x0C,0x84,0x26,
+0x14,0x00,0x03,0x92,
+0x01,0x00,0x02,0x24,
+0x2B,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x60,0x14,
+0x02,0x00,0x02,0x24,
+0x0C,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x23,0x02,
+0x1E,0x00,0x40,0x10,
+0x23,0x10,0x71,0x00,
+0x0C,0x00,0x02,0xAE,
+0x00,0x00,0x10,0x8E,
+0xCE,0x23,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x60,0x10,
+0x2B,0x10,0x23,0x02,
+0xF5,0xFF,0x40,0x14,
+0x23,0x10,0x71,0x00,
+0x08,0x00,0x02,0x8E,
+0x18,0x00,0x04,0x8E,
+0x09,0xF8,0x40,0x00,
+0x0C,0x00,0x00,0xAE,
+0x00,0x00,0x10,0x8E,
+0xCE,0x23,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x08,0x0C,0x84,0x26,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x91,0x3C,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0xC0,0x23,0x00,0x08,
+0xB8,0x8E,0xE2,0x26,
+0x08,0x00,0x02,0x8E,
+0x18,0x00,0x04,0x8E,
+0x09,0xF8,0x40,0x00,
+0x00,0x00,0x00,0x00,
+0xDC,0x23,0x00,0x08,
+0x0C,0x00,0x02,0xAE,
+0x0C,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x23,0x02,
+0xD9,0xFF,0x40,0x14,
+0x23,0x10,0x71,0x00,
+0x08,0x00,0x02,0x8E,
+0x18,0x00,0x04,0x8E,
+0x09,0xF8,0x40,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x03,0xAE,
+0x00,0x00,0x10,0x8E,
+0xCE,0x23,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x9C,0x57,0x42,0x24,
+0xC0,0x20,0x04,0x00,
+0x21,0x20,0x82,0x00,
+0x21,0x28,0x00,0x00,
+0x00,0x60,0x06,0x40,
+0x01,0x00,0xC1,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x44,0x10,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x43,0x8C,
+0x21,0x28,0x40,0x00,
+0x00,0x00,0x42,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x00,0x00,0xA5,0xAC,
+0x04,0x00,0xA5,0xAC,
+0x00,0x60,0x86,0x40,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x21,0x18,0x80,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x01,0x01,0x62,0x2C,
+0x10,0x00,0xBF,0xAF,
+0x01,0x00,0x04,0x24,
+0x01,0x02,0x65,0x2C,
+0x0A,0x00,0x40,0x14,
+0x21,0x30,0x00,0x00,
+0x02,0x00,0x04,0x24,
+0x07,0x00,0xA0,0x14,
+0x01,0x08,0x62,0x2C,
+0x05,0x00,0x40,0x14,
+0x03,0x00,0x04,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0xC0,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x0D,0x24,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x30,0x40,0x00,
+0x21,0x10,0xC0,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x00,0x60,0x06,0x40,
+0x01,0x00,0xC1,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x10,0x00,0x83,0x8C,
+0x02,0x80,0x02,0x3C,
+0x9C,0x57,0x42,0x24,
+0xC0,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x65,0x8C,
+0x02,0x80,0x07,0x3C,
+0x02,0x80,0x08,0x3C,
+0x00,0x00,0x85,0xAC,
+0x04,0x00,0xA4,0xAC,
+0x04,0x00,0x83,0xAC,
+0xD0,0x5E,0xE5,0x8C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0xA0,0x10,
+0x00,0x00,0x64,0xAC,
+0xBC,0x5E,0x02,0x8D,
+0xD0,0x5E,0xE0,0xAC,
+0x25,0x10,0x45,0x00,
+0xBC,0x5E,0x02,0xAD,
+0x00,0x60,0x86,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0xA5,0x30,
+0x25,0xB0,0x02,0x3C,
+0x21,0x28,0xA2,0x00,
+0xFF,0x00,0x84,0x30,
+0x60,0x01,0xA4,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x84,0x30,
+0x01,0x00,0x03,0x24,
+0x10,0x00,0x02,0x3C,
+0x04,0x18,0x83,0x00,
+0xF0,0x70,0x42,0x34,
+0x15,0x00,0x84,0x2C,
+0x06,0x00,0x80,0x10,
+0x24,0x28,0x62,0x00,
+0x0F,0x00,0x63,0x30,
+0x04,0x00,0xA0,0x14,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0x60,0x14,
+0x02,0x00,0x02,0x24,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0xA5,0x30,
+0x04,0x00,0xA2,0x2C,
+0x14,0x00,0x40,0x10,
+0xFF,0x00,0x84,0x30,
+0x02,0x80,0x03,0x3C,
+0xDE,0x5D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xEF,0xFF,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x02,0x00,0x42,0x2C,
+0x0E,0x00,0x40,0x10,
+0x02,0x00,0x03,0x24,
+0x24,0x00,0x83,0x10,
+0x0F,0x10,0x02,0x3C,
+0x03,0x00,0x82,0x28,
+0x14,0x00,0x40,0x10,
+0x03,0x00,0x02,0x24,
+0x01,0x00,0x02,0x24,
+0x2F,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0x1F,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0xFF,0xFF,0x42,0x34,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x35,0x00,0x83,0x10,
+0x0F,0x1F,0x02,0x3C,
+0x03,0x00,0x82,0x28,
+0x16,0x00,0x40,0x10,
+0x03,0x00,0x02,0x24,
+0x01,0x00,0x02,0x24,
+0xF4,0xFF,0x82,0x14,
+0x00,0x00,0x00,0x00,
+0x0F,0x1F,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x00,0x80,0x42,0x34,
+0xF0,0xFF,0x82,0x14,
+0xFF,0x1F,0x02,0x3C,
+0x01,0x00,0x02,0x24,
+0x29,0x00,0xA2,0x10,
+0x0F,0x10,0x02,0x3C,
+0x02,0x00,0xA2,0x28,
+0x1F,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x28,0x00,0xA3,0x10,
+0x00,0x00,0x00,0x00,
+0xE5,0xFF,0xA4,0x14,
+0x00,0x00,0x00,0x00,
+0x0F,0x10,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x00,0xF0,0x42,0x34,
+0xE1,0xFF,0x82,0x14,
+0xFF,0x1F,0x02,0x3C,
+0x01,0x00,0x02,0x24,
+0x1C,0x00,0xA2,0x10,
+0x0F,0x00,0x02,0x3C,
+0x02,0x00,0xA2,0x28,
+0x0B,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xA3,0x10,
+0x00,0x00,0x00,0x00,
+0xD6,0xFF,0xA4,0x14,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x00,0xF0,0x42,0x34,
+0x0F,0x10,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x00,0x80,0x42,0x34,
+0xCE,0xFF,0xA0,0x14,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x15,0xF0,0x42,0x34,
+0xC9,0xFF,0xA0,0x14,
+0x00,0x00,0x00,0x00,
+0x0F,0x10,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x15,0xF0,0x42,0x34,
+0x08,0x00,0xE0,0x03,
+0x00,0xF0,0x42,0x34,
+0x08,0x00,0xE0,0x03,
+0x10,0xF0,0x42,0x34,
+0x08,0x00,0xE0,0x03,
+0x10,0xF0,0x42,0x34,
+0x0F,0x10,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x05,0xF0,0x42,0x34,
+0x0F,0x00,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x05,0xF0,0x42,0x34,
+0xC0,0x40,0x04,0x00,
+0x21,0x18,0x04,0x01,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x64,0x00,
+0x02,0x80,0x02,0x3C,
+0x80,0x18,0x03,0x00,
+0x30,0x1F,0x42,0x24,
+0x21,0x18,0x62,0x00,
+0x18,0x24,0x66,0x8C,
+0x21,0x38,0x60,0x00,
+0x1E,0x24,0x60,0xA0,
+0x1F,0x24,0x60,0xA0,
+0x1C,0x00,0x05,0x24,
+0xDA,0x24,0x00,0x08,
+0x01,0x00,0x03,0x24,
+0x08,0x00,0xA0,0x04,
+0x21,0x10,0x04,0x01,
+0x04,0x10,0xA3,0x00,
+0x24,0x10,0xC2,0x00,
+0xFB,0xFF,0x40,0x10,
+0xFF,0xFF,0xA5,0x24,
+0x01,0x00,0xA5,0x24,
+0x1E,0x24,0xE5,0xA0,
+0x21,0x10,0x04,0x01,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x02,0x00,
+0x30,0x1F,0x63,0x24,
+0x21,0x18,0x43,0x00,
+0x18,0x24,0x66,0x8C,
+0x21,0x28,0x00,0x00,
+0xEE,0x24,0x00,0x08,
+0x01,0x00,0x07,0x24,
+0x1D,0x00,0xA2,0x28,
+0x08,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x04,0x10,0xA7,0x00,
+0x24,0x10,0xC2,0x00,
+0xFA,0xFF,0x40,0x10,
+0x01,0x00,0xA5,0x24,
+0xFF,0xFF,0xA5,0x24,
+0x08,0x00,0xE0,0x03,
+0x1F,0x24,0x65,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x88,0x00,0x00,
+0x30,0x1F,0x50,0x24,
+0xFF,0xF1,0x14,0x24,
+0x25,0xB0,0x13,0x3C,
+0x24,0x00,0xBF,0xAF,
+0x08,0x25,0x00,0x08,
+0x18,0x00,0xB2,0xAF,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0x22,0x2E,
+0x2A,0x00,0x40,0x10,
+0x94,0x00,0x10,0x26,
+0x1C,0x24,0x06,0x8E,
+0x01,0x00,0x03,0x24,
+0x02,0x13,0x06,0x00,
+0x01,0x00,0x45,0x30,
+0xF7,0xFF,0xA3,0x14,
+0x42,0x1A,0x06,0x00,
+0x0C,0x24,0x02,0x8E,
+0x07,0x00,0x64,0x30,
+0x02,0x11,0x02,0x00,
+0x7F,0x00,0x43,0x30,
+0x27,0x00,0x85,0x10,
+0x07,0x00,0xD2,0x30,
+0x02,0x00,0x82,0x28,
+0x31,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x28,0x00,0x82,0x10,
+0x03,0x00,0x02,0x24,
+0x31,0x00,0x82,0x10,
+0x1A,0x00,0x62,0x2C,
+0x1C,0x24,0x02,0x8E,
+0x04,0x00,0x43,0x2E,
+0x42,0x12,0x02,0x00,
+0x0A,0x00,0x60,0x10,
+0x07,0x00,0x44,0x30,
+0x6E,0x24,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x80,0x18,0x12,0x00,
+0x21,0x18,0x73,0x00,
+0x14,0x24,0x04,0x8E,
+0x84,0x01,0x65,0x8C,
+0x24,0x20,0x82,0x00,
+0x24,0x28,0xA4,0x00,
+0x18,0x24,0x05,0xAE,
+0xC9,0x24,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x21,0x10,0x33,0x02,
+0x01,0x00,0x31,0x26,
+0x60,0x01,0x43,0x90,
+0x20,0x00,0x22,0x2E,
+0xD8,0xFF,0x40,0x14,
+0x94,0x00,0x10,0x26,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x32,0x00,0x62,0x2C,
+0xDF,0xFF,0x40,0x10,
+0x24,0x10,0xD4,0x00,
+0x00,0x04,0x42,0x34,
+0x1B,0x25,0x00,0x08,
+0x1C,0x24,0x02,0xAE,
+0x38,0x00,0x62,0x2C,
+0x0D,0x00,0x40,0x14,
+0x14,0x00,0x62,0x2C,
+0x24,0x10,0xD4,0x00,
+0x00,0x02,0x42,0x34,
+0x1B,0x25,0x00,0x08,
+0x1C,0x24,0x02,0xAE,
+0xD3,0xFF,0x80,0x14,
+0x24,0x10,0xD4,0x00,
+0x1B,0x25,0x00,0x08,
+0x1C,0x24,0x02,0xAE,
+0xCF,0xFF,0x40,0x14,
+0x24,0x10,0xD4,0x00,
+0x3E,0x25,0x00,0x08,
+0x00,0x04,0x42,0x34,
+0xCB,0xFF,0x40,0x10,
+0x24,0x10,0xD4,0x00,
+0x00,0x06,0x42,0x34,
+0x1B,0x25,0x00,0x08,
+0x1C,0x24,0x02,0xAE,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0xC0,0x80,0x04,0x00,
+0x21,0x80,0x04,0x02,
+0x80,0x80,0x10,0x00,
+0x21,0x80,0x04,0x02,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x80,0x10,0x00,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x21,0x80,0x02,0x02,
+0x1C,0x24,0x03,0x8E,
+0x25,0xB0,0x02,0x3C,
+0x80,0x01,0x45,0x34,
+0x07,0x00,0x63,0x30,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0xA6,0x90,
+0x14,0x24,0x05,0x8E,
+0x84,0x01,0x62,0x8C,
+0x21,0x88,0x80,0x00,
+0x24,0x10,0x45,0x00,
+0xC9,0x24,0x00,0x0C,
+0x18,0x24,0x02,0xAE,
+0x1E,0x24,0x04,0x92,
+0xFF,0x00,0x25,0x32,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x57,0x24,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xFF,0xFF,0x84,0x30,
+0x00,0x02,0x82,0x30,
+0x07,0x00,0x03,0x24,
+0x0D,0x00,0x40,0x14,
+0x0B,0x00,0x84,0x30,
+0x0C,0x00,0x82,0x2C,
+0x0A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x04,0x00,
+0x74,0xED,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x06,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x05,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x04,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x03,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x02,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x01,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x21,0x18,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xA8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x50,0x00,0xBE,0xAF,
+0x4C,0x00,0xB7,0xAF,
+0x48,0x00,0xB6,0xAF,
+0x44,0x00,0xB5,0xAF,
+0x3C,0x00,0xB3,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x54,0x00,0xBF,0xAF,
+0x40,0x00,0xB4,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x30,0x00,0xB0,0xAF,
+0xA4,0xED,0x42,0x24,
+0x00,0x00,0x54,0x8C,
+0x21,0x98,0x00,0x00,
+0x21,0xA8,0x00,0x00,
+0x21,0xB0,0x00,0x00,
+0x10,0x00,0xA0,0xAF,
+0x21,0xB8,0x00,0x00,
+0x14,0x00,0xA0,0xAF,
+0x21,0xF0,0x00,0x00,
+0x18,0x00,0xA0,0xAF,
+0x1C,0x00,0xA0,0xAF,
+0x20,0x00,0xA0,0xAF,
+0x24,0x00,0xA0,0xAF,
+0x28,0x00,0xA0,0xAF,
+0x2C,0x00,0xA0,0xAF,
+0x21,0x90,0x80,0x02,
+0x1C,0x24,0x42,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x13,0x02,0x00,
+0x01,0x00,0x42,0x30,
+0x68,0x00,0x40,0x10,
+0x25,0xB0,0x02,0x3C,
+0x21,0x10,0x62,0x02,
+0x60,0x01,0x44,0x90,
+0x04,0x24,0x43,0x8E,
+0x00,0x24,0x46,0x8E,
+0xFF,0x00,0x8B,0x30,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x84,0x24,
+0x21,0x10,0x64,0x01,
+0xE7,0x04,0x44,0x90,
+0xCA,0x04,0x45,0x90,
+0xE8,0x23,0x47,0x8E,
+0x18,0x00,0x64,0x00,
+0x12,0x18,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xC5,0x00,
+0x12,0x30,0x00,0x00,
+0x21,0x30,0xC3,0x00,
+0x2B,0x10,0xE6,0x00,
+0x02,0x01,0x40,0x14,
+0x23,0x10,0xE6,0x00,
+0xE8,0x23,0x42,0xAE,
+0x04,0x24,0x44,0x8E,
+0x00,0x24,0x47,0x8E,
+0xEC,0x23,0x48,0x8E,
+0xF0,0x23,0x45,0x8E,
+0xF8,0x23,0x46,0x8E,
+0xFC,0x23,0x43,0x8E,
+0x21,0x38,0xE4,0x00,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x84,0x24,
+0x21,0x10,0x64,0x01,
+0x21,0x40,0x05,0x01,
+0x21,0x30,0xC3,0x00,
+0x3E,0x05,0x42,0x90,
+0xE8,0x23,0x4A,0x8E,
+0x0C,0x00,0xE0,0x10,
+0x21,0x48,0x00,0x00,
+0x2B,0x48,0x47,0x00,
+0x0B,0x00,0x20,0x15,
+0x02,0x80,0x02,0x3C,
+0x07,0x00,0x62,0x2D,
+0x4B,0x01,0x40,0x14,
+0xC0,0x10,0x07,0x00,
+0x0C,0x00,0x02,0x24,
+0x47,0x01,0x62,0x11,
+0x0D,0x00,0x02,0x24,
+0x46,0x01,0x62,0x11,
+0xC0,0x10,0x07,0x00,
+0x6C,0x00,0x20,0x11,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x0B,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x20,0x4B,0x02,
+0x5A,0x24,0x85,0x90,
+0x60,0x05,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x04,0x10,0xA2,0x00,
+0x2B,0x10,0x4A,0x00,
+0x61,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x78,0x24,0x42,0x8E,
+0x01,0x00,0x07,0x24,
+0x04,0x18,0x67,0x01,
+0x24,0x10,0x43,0x00,
+0xE1,0x00,0x40,0x10,
+0x1C,0x00,0x62,0x2D,
+0x21,0x28,0x4B,0x02,
+0x20,0x24,0xA6,0x90,
+0x5A,0x24,0xA2,0x90,
+0x0A,0x00,0x04,0x24,
+0xFF,0x00,0xC3,0x30,
+0x04,0x20,0x44,0x00,
+0x2A,0x18,0x64,0x00,
+0xD8,0x00,0x60,0x10,
+0x1C,0x00,0x62,0x2D,
+0x01,0x00,0xC2,0x24,
+0xFF,0x00,0x43,0x30,
+0x37,0x01,0x64,0x10,
+0x20,0x24,0xA2,0xA0,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x85,0x24,
+0x80,0x10,0x0B,0x00,
+0x21,0x10,0x45,0x00,
+0xD4,0x05,0x44,0x8C,
+0x60,0x05,0x43,0x8C,
+0x18,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x30,0x45,0x00,
+0x40,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0x21,0x18,0x62,0x00,
+0x82,0x50,0x03,0x00,
+0xE8,0x23,0xCA,0xAC,
+0x30,0x38,0xA3,0x8C,
+0xFF,0xFF,0x02,0x34,
+0x03,0x00,0x62,0x10,
+0x21,0x20,0x60,0x01,
+0x57,0x24,0x00,0x0C,
+0xFF,0x00,0x65,0x32,
+0x9E,0x00,0x60,0x12,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x82,0x24,
+0x21,0x10,0xA2,0x02,
+0xFC,0x23,0x40,0xAC,
+0x00,0x24,0x40,0xAC,
+0x04,0x24,0x40,0xAC,
+0xEC,0x23,0x40,0xAC,
+0xF0,0x23,0x40,0xAC,
+0xF4,0x23,0x40,0xAC,
+0xF8,0x23,0x40,0xAC,
+0x2C,0x00,0xA2,0x8F,
+0x28,0x00,0xA4,0x8F,
+0x01,0x00,0x73,0x26,
+0x94,0x00,0x42,0x24,
+0x94,0x00,0x84,0x24,
+0x2C,0x00,0xA2,0xAF,
+0x28,0x00,0xA4,0xAF,
+0x24,0x00,0xA2,0x8F,
+0x20,0x00,0xA4,0x8F,
+0x20,0x00,0x63,0x2A,
+0x94,0x00,0x42,0x24,
+0x94,0x00,0x84,0x24,
+0x24,0x00,0xA2,0xAF,
+0x20,0x00,0xA4,0xAF,
+0x1C,0x00,0xA2,0x8F,
+0x18,0x00,0xA4,0x8F,
+0x94,0x00,0x52,0x26,
+0x94,0x00,0x42,0x24,
+0x94,0x00,0x84,0x24,
+0x1C,0x00,0xA2,0xAF,
+0x18,0x00,0xA4,0xAF,
+0x14,0x00,0xA2,0x8F,
+0x10,0x00,0xA4,0x8F,
+0x94,0x00,0xDE,0x27,
+0x94,0x00,0x42,0x24,
+0x94,0x00,0x84,0x24,
+0x14,0x00,0xA2,0xAF,
+0x94,0x00,0xF7,0x26,
+0x10,0x00,0xA4,0xAF,
+0x94,0x00,0x94,0x26,
+0x94,0x00,0xD6,0x26,
+0x69,0xFF,0x60,0x14,
+0x94,0x00,0xB5,0x26,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0x79,0x00,0xE0,0x10,
+0x00,0x00,0x00,0x00,
+0x79,0x00,0x20,0x15,
+0x02,0x80,0x03,0x3C,
+0x40,0x10,0x07,0x00,
+0x21,0x10,0x47,0x00,
+0x82,0x10,0x02,0x00,
+0x2B,0x10,0x46,0x00,
+0xBE,0xFF,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x88,0x24,
+0x21,0x20,0xC8,0x03,
+0x21,0x30,0x8B,0x00,
+0x78,0x24,0x83,0x8C,
+0x01,0x00,0x05,0x24,
+0x04,0x10,0x65,0x01,
+0x3D,0x24,0xC7,0x90,
+0x27,0x10,0x02,0x00,
+0x24,0x18,0x62,0x00,
+0x78,0x24,0x83,0xAC,
+0x09,0x00,0xE5,0x10,
+0x20,0x24,0xC0,0xA0,
+0x14,0x00,0xA2,0x8F,
+0x21,0x38,0x00,0x00,
+0x21,0x20,0x48,0x00,
+0x21,0x18,0x87,0x00,
+0x01,0x00,0xE7,0x24,
+0x1D,0x00,0xE2,0x28,
+0xFC,0xFF,0x40,0x14,
+0x5A,0x24,0x60,0xA0,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x83,0x24,
+0x21,0x10,0xE3,0x02,
+0x21,0x10,0x4B,0x00,
+0x3D,0x24,0x40,0xA0,
+0x21,0x50,0x60,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x78,0xE8,0x49,0x24,
+0x04,0xE8,0x68,0x24,
+0x21,0x38,0x00,0x00,
+0x80,0x18,0x07,0x00,
+0x21,0x10,0x69,0x00,
+0x21,0x20,0x68,0x00,
+0x00,0x00,0x46,0x8C,
+0x00,0x00,0x85,0x8C,
+0x01,0x00,0xE7,0x24,
+0x21,0x18,0x6A,0x00,
+0x1D,0x00,0xE2,0x28,
+0x60,0x05,0x65,0xAC,
+0xF6,0xFF,0x40,0x14,
+0xD4,0x05,0x66,0xAC,
+0x15,0x00,0x60,0x11,
+0x02,0x80,0x04,0x3C,
+0x1F,0x24,0x82,0x92,
+0xFF,0xFF,0x67,0x25,
+0x2A,0x10,0xE2,0x00,
+0x10,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x10,0x00,0xA4,0x8F,
+0x30,0x1F,0x62,0x24,
+0x21,0x10,0x82,0x00,
+0x1F,0x24,0x45,0x90,
+0x18,0x24,0x44,0x8C,
+0x01,0x00,0x06,0x24,
+0x04,0x18,0xE6,0x00,
+0x24,0x10,0x83,0x00,
+0xB9,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0xE7,0x24,
+0x2A,0x10,0xE5,0x00,
+0xFA,0xFF,0x40,0x10,
+0x04,0x18,0xE6,0x00,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x83,0x24,
+0x80,0x10,0x0B,0x00,
+0x21,0x10,0x43,0x00,
+0xD4,0x05,0x45,0x8C,
+0x60,0x05,0x44,0x8C,
+0x02,0x80,0x03,0x3C,
+0x40,0x10,0x05,0x00,
+0xDE,0x5D,0x66,0x90,
+0x21,0x10,0x45,0x00,
+0x21,0x20,0x82,0x00,
+0x22,0x00,0x02,0x24,
+0x9D,0x00,0xC2,0x10,
+0x82,0x50,0x04,0x00,
+0x78,0x24,0x83,0x8E,
+0x01,0x00,0x02,0x24,
+0x04,0x10,0x62,0x01,
+0x25,0x18,0x62,0x00,
+0x78,0x24,0x83,0xAE,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x43,0x24,
+0x21,0x10,0xC3,0x02,
+0xE8,0x23,0x4A,0xAC,
+0x30,0x38,0x64,0x8C,
+0xFF,0xFF,0x02,0x34,
+0x62,0xFF,0x82,0x14,
+0x21,0x20,0x60,0x01,
+0x64,0xFF,0x60,0x16,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x70,0x24,
+0xF0,0x23,0x05,0x96,
+0xEC,0x23,0x02,0x96,
+0x25,0xB0,0x11,0x3C,
+0x00,0x2C,0x05,0x00,
+0x21,0x28,0x45,0x00,
+0xB5,0x59,0x00,0x0C,
+0x68,0x0C,0x24,0x36,
+0xFC,0x23,0x02,0x8E,
+0xF8,0x23,0x05,0x8E,
+0xF4,0x23,0x03,0x96,
+0x6C,0x0C,0x24,0x36,
+0x21,0x28,0xA2,0x00,
+0x00,0x2C,0x05,0x00,
+0xB5,0x59,0x00,0x0C,
+0x21,0x28,0x65,0x00,
+0x28,0x26,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0xD6,0x25,0x00,0x08,
+0xE8,0x23,0x40,0xAE,
+0x4C,0xFF,0x20,0x11,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x62,0x24,
+0x80,0x18,0x0B,0x00,
+0x21,0x18,0x62,0x00,
+0xD4,0x05,0x64,0x8C,
+0x00,0x00,0x00,0x00,
+0x2B,0x20,0x44,0x01,
+0x44,0xFF,0x80,0x10,
+0x02,0x80,0x04,0x3C,
+0x69,0x26,0x00,0x08,
+0x30,0x1F,0x88,0x24,
+0x2D,0xFF,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x21,0x20,0x4B,0x02,
+0x3D,0x24,0x83,0x90,
+0x01,0x00,0x02,0x24,
+0x53,0x00,0x62,0x10,
+0x02,0x80,0x02,0x3C,
+0x2C,0x00,0xA3,0x8F,
+0x30,0x1F,0x42,0x24,
+0x21,0x38,0x00,0x00,
+0x21,0x20,0x62,0x00,
+0x21,0x18,0x87,0x00,
+0x01,0x00,0xE7,0x24,
+0x1D,0x00,0xE2,0x28,
+0xFC,0xFF,0x40,0x14,
+0x5A,0x24,0x60,0xA0,
+0x28,0x00,0xA4,0x8F,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x65,0x24,
+0x21,0x30,0x85,0x00,
+0x78,0x24,0xC2,0x8C,
+0x01,0x00,0x03,0x24,
+0x04,0x18,0x63,0x01,
+0x27,0x18,0x03,0x00,
+0x21,0x20,0xCB,0x00,
+0x24,0x10,0x43,0x00,
+0x3D,0x24,0x80,0xA0,
+0x78,0x24,0xC2,0xAC,
+0x12,0x00,0x60,0x15,
+0x20,0x24,0x80,0xA0,
+0x1E,0x24,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x0E,0x00,0x40,0x10,
+0x01,0x00,0x07,0x24,
+0x24,0x00,0xA3,0x8F,
+0x01,0x00,0x06,0x24,
+0x21,0x10,0x65,0x00,
+0x1E,0x24,0x44,0x90,
+0x18,0x24,0x45,0x8C,
+0x04,0x18,0xE6,0x00,
+0x24,0x10,0xA3,0x00,
+0x4B,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xE7,0x24,
+0x2A,0x10,0x87,0x00,
+0xFA,0xFF,0x40,0x10,
+0x04,0x18,0xE6,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x44,0x24,
+0x20,0x00,0xA2,0x8F,
+0x01,0x00,0x67,0x25,
+0x21,0x18,0x44,0x00,
+0x1E,0x24,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x2A,0x10,0x47,0x00,
+0x0E,0x00,0x40,0x14,
+0x01,0x00,0x06,0x24,
+0x1C,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x64,0x00,
+0x1E,0x24,0x45,0x90,
+0x18,0x24,0x44,0x8C,
+0x04,0x18,0xE6,0x00,
+0x24,0x10,0x83,0x00,
+0x31,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xE7,0x24,
+0x2A,0x10,0xA7,0x00,
+0xFA,0xFF,0x40,0x10,
+0x04,0x18,0xE6,0x00,
+0x02,0x80,0x02,0x3C,
+0xDE,0x5D,0x44,0x90,
+0x22,0x00,0x03,0x24,
+0xE4,0xFE,0x83,0x14,
+0x02,0x80,0x04,0x3C,
+0xEE,0xFF,0x62,0x25,
+0xFF,0x00,0x42,0x30,
+0x02,0x00,0x42,0x2C,
+0x18,0x00,0x03,0x24,
+0x12,0x26,0x00,0x08,
+0x0B,0x58,0x62,0x00,
+0xC0,0x10,0x07,0x00,
+0x23,0x10,0x47,0x00,
+0xC2,0x10,0x02,0x00,
+0x2B,0x10,0x48,0x00,
+0xC4,0xFE,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xF1,0x25,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x62,0x2D,
+0x0A,0x00,0x40,0x14,
+0x05,0x00,0x62,0x2D,
+0x5A,0x24,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x62,0x2C,
+0xB0,0xFF,0x40,0x10,
+0x01,0x00,0x62,0x24,
+0xF4,0x26,0x00,0x08,
+0x5A,0x24,0x82,0xA0,
+0x11,0x26,0x00,0x08,
+0x3D,0x24,0xA7,0xA0,
+0x04,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x5A,0x24,0x83,0x90,
+0x43,0x27,0x00,0x08,
+0x03,0x00,0x62,0x2C,
+0x5A,0x24,0x83,0x90,
+0x43,0x27,0x00,0x08,
+0x04,0x00,0x62,0x2C,
+0x13,0x00,0x02,0x24,
+0x62,0xFF,0x62,0x15,
+0x02,0x80,0x02,0x3C,
+0xBC,0x26,0x00,0x08,
+0x30,0x1F,0x43,0x24,
+0xFF,0x00,0xEB,0x30,
+0x2B,0x27,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x13,0x27,0x00,0x08,
+0xFF,0x00,0xEB,0x30,
+0xA7,0x26,0x00,0x08,
+0xFF,0x00,0xEB,0x30,
+0xD8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x14,0x00,0xB1,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x45,0x24,
+0xA9,0x37,0xA4,0x90,
+0xA4,0x37,0xA3,0x8C,
+0xA0,0x37,0xA2,0x8C,
+0x21,0x88,0x64,0x00,
+0x2B,0x10,0x22,0x02,
+0x60,0x00,0x40,0x10,
+0x21,0x80,0xA0,0x00,
+0x02,0x80,0x14,0x3C,
+0x21,0x98,0xA0,0x00,
+0x76,0x27,0x00,0x08,
+0x21,0x90,0xA0,0x00,
+0xA0,0x37,0x42,0x8E,
+0x10,0x00,0x31,0x26,
+0x2B,0x10,0x22,0x02,
+0x57,0x00,0x40,0x10,
+0x21,0x80,0x40,0x02,
+0xA9,0x37,0x02,0x92,
+0xFF,0xFF,0x23,0x32,
+0x02,0x80,0x05,0x3C,
+0x10,0x00,0x42,0x24,
+0x25,0x28,0x65,0x00,
+0x98,0x55,0x84,0x26,
+0x10,0x00,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0xA9,0x37,0x02,0xA2,
+0x6C,0x36,0x06,0x8E,
+0x00,0x00,0x00,0x00,
+0x42,0x24,0x06,0x00,
+0x1F,0x00,0x84,0x30,
+0xC0,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x38,0x50,0x00,
+0x1C,0x24,0xE3,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x1B,0x03,0x00,
+0x01,0x00,0x63,0x30,
+0xE3,0xFF,0x60,0x10,
+0x25,0xB0,0x02,0x3C,
+0x68,0x36,0x05,0x8E,
+0x21,0x10,0x82,0x00,
+0x60,0x01,0x44,0x90,
+0x82,0x1D,0x05,0x00,
+0x3F,0x00,0x63,0x30,
+0x04,0x00,0x0A,0x24,
+0x05,0x00,0x62,0x28,
+0x21,0x40,0x40,0x01,
+0x0B,0x40,0x62,0x00,
+0x07,0x00,0xA0,0x04,
+0xFF,0x00,0x89,0x30,
+0x08,0x24,0xE2,0x8C,
+0x04,0x00,0x08,0x24,
+0x01,0x00,0x42,0x24,
+0x08,0x24,0xE2,0xAC,
+0x6C,0x36,0x66,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x13,0x06,0x00,
+0x1F,0x00,0x42,0x30,
+0x08,0x00,0x42,0x28,
+0xCD,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x68,0x36,0x62,0x8E,
+0x00,0x00,0x00,0x00,
+0x3F,0x00,0x42,0x30,
+0xC8,0xFF,0x49,0x14,
+0x00,0x00,0x00,0x00,
+0x29,0x00,0x00,0x11,
+0x01,0x00,0x02,0x24,
+0x2E,0x00,0x02,0x11,
+0x02,0x00,0x02,0x24,
+0x33,0x00,0x02,0x11,
+0x03,0x00,0x02,0x24,
+0x38,0x00,0x02,0x11,
+0x00,0x00,0x00,0x00,
+0x3B,0x00,0x0A,0x11,
+0x00,0x00,0x00,0x00,
+0x0C,0x24,0xE2,0x8C,
+0x21,0x18,0x33,0x01,
+0x04,0x05,0x64,0x90,
+0x02,0x11,0x02,0x00,
+0x2B,0x10,0x44,0x00,
+0x3E,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x24,0xE3,0x8C,
+0x80,0x10,0x09,0x00,
+0x21,0x10,0x49,0x00,
+0x01,0x00,0x63,0x24,
+0x21,0x10,0x53,0x00,
+0x00,0x24,0xE3,0xAC,
+0x21,0x10,0x48,0x00,
+0xA8,0x03,0x44,0x90,
+0xE8,0x23,0xE3,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x64,0x00,
+0xE8,0x23,0xE3,0xAC,
+0xA0,0x37,0x42,0x8E,
+0x10,0x00,0x31,0x26,
+0x2B,0x10,0x22,0x02,
+0xAB,0xFF,0x40,0x14,
+0x21,0x80,0x40,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xEC,0x23,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xEC,0x23,0xE2,0xAC,
+0x01,0x00,0x02,0x24,
+0xD4,0xFF,0x02,0x15,
+0x02,0x00,0x02,0x24,
+0xF0,0x23,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xF0,0x23,0xE2,0xAC,
+0x02,0x00,0x02,0x24,
+0xCF,0xFF,0x02,0x15,
+0x03,0x00,0x02,0x24,
+0xF4,0x23,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xF4,0x23,0xE2,0xAC,
+0x03,0x00,0x02,0x24,
+0xCA,0xFF,0x02,0x15,
+0x00,0x00,0x00,0x00,
+0xF8,0x23,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xC7,0xFF,0x0A,0x15,
+0xF8,0x23,0xE2,0xAC,
+0xFC,0x23,0xE2,0x8C,
+0x21,0x18,0x33,0x01,
+0x01,0x00,0x42,0x24,
+0xFC,0x23,0xE2,0xAC,
+0x0C,0x24,0xE2,0x8C,
+0x04,0x05,0x64,0x90,
+0x02,0x11,0x02,0x00,
+0x2B,0x10,0x44,0x00,
+0xC4,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x04,0x24,0xE3,0x8C,
+0x80,0x10,0x09,0x00,
+0x21,0x10,0x49,0x00,
+0x01,0x00,0x63,0x24,
+0x21,0x10,0x53,0x00,
+0x04,0x24,0xE3,0xAC,
+0x21,0x10,0x48,0x00,
+0x39,0x04,0x44,0x90,
+0xE8,0x23,0xE3,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x64,0x00,
+0xC7,0x27,0x00,0x08,
+0xE8,0x23,0xE3,0xAC,
+0x23,0x10,0xA4,0x00,
+0x2B,0x18,0xA4,0x00,
+0x23,0x20,0x85,0x00,
+0x08,0x00,0xE0,0x03,
+0x0B,0x10,0x83,0x00,
+0x20,0xFF,0xBD,0x27,
+0xCC,0x00,0xB5,0xAF,
+0xDC,0x00,0xBF,0xAF,
+0xD8,0x00,0xBE,0xAF,
+0xD4,0x00,0xB7,0xAF,
+0xD0,0x00,0xB6,0xAF,
+0xC8,0x00,0xB4,0xAF,
+0xC4,0x00,0xB3,0xAF,
+0xC0,0x00,0xB2,0xAF,
+0xBC,0x00,0xB1,0xAF,
+0xB8,0x00,0xB0,0xAF,
+0x21,0xA8,0x00,0x00,
+0x40,0x11,0x15,0x00,
+0x10,0x00,0xA3,0x27,
+0x21,0x10,0x43,0x00,
+0x07,0x00,0x16,0x24,
+0xFF,0xFF,0xD6,0x26,
+0x00,0x00,0x40,0xAC,
+0xFD,0xFF,0xC1,0x06,
+0x04,0x00,0x42,0x24,
+0x01,0x00,0xB5,0x26,
+0x03,0x00,0xA2,0x2E,
+0xF6,0xFF,0x40,0x14,
+0x40,0x11,0x15,0x00,
+0x25,0xB0,0x10,0x3C,
+0xC4,0x02,0x02,0x36,
+0x00,0x00,0x40,0xAC,
+0x04,0x00,0x03,0x36,
+0x00,0x00,0x62,0x8C,
+0x04,0x0C,0x03,0x36,
+0x00,0x00,0x63,0x8C,
+0x08,0x0C,0x04,0x36,
+0x0F,0x00,0x11,0x3C,
+0xAC,0x00,0xA3,0xAF,
+0x00,0x00,0x84,0x8C,
+0x24,0x10,0x51,0x00,
+0x02,0xF4,0x02,0x00,
+0xB0,0x00,0xA4,0xAF,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x21,0x20,0x00,0x00,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x25,0x36,
+0x70,0x00,0xA2,0xAF,
+0x00,0x60,0x92,0x40,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x21,0x20,0x00,0x00,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x25,0x36,
+0x74,0x00,0xA2,0xAF,
+0x00,0x60,0x92,0x40,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0xE0,0x0E,0x02,0x36,
+0x21,0x20,0x40,0x00,
+0x00,0x00,0x42,0x8C,
+0xDC,0x0E,0x12,0x36,
+0x70,0x0E,0x13,0x36,
+0x78,0x00,0xA2,0xAF,
+0x00,0x00,0x42,0x8E,
+0x74,0x0E,0x14,0x36,
+0x78,0x0E,0x15,0x36,
+0x7C,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8E,
+0x7C,0x0E,0x16,0x36,
+0x80,0x0E,0x17,0x36,
+0x80,0x00,0xA3,0xAF,
+0x00,0x00,0x82,0x8E,
+0xD4,0x0E,0x10,0x36,
+0xED,0x3F,0x11,0x3C,
+0x84,0x00,0xA2,0xAF,
+0x00,0x00,0xA3,0x8E,
+0xFB,0x92,0x25,0x36,
+0x88,0x00,0xA3,0xAF,
+0x00,0x00,0xC2,0x8E,
+0x00,0x00,0x00,0x00,
+0x8C,0x00,0xA2,0xAF,
+0x00,0x00,0xE3,0x8E,
+0x25,0xB0,0x02,0x3C,
+0x84,0x0E,0x42,0x34,
+0x90,0x00,0xA3,0xAF,
+0x00,0x00,0x42,0x8C,
+0x25,0xB0,0x03,0x3C,
+0x88,0x0E,0x63,0x34,
+0x94,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8C,
+0x25,0xB0,0x02,0x3C,
+0x8C,0x0E,0x42,0x34,
+0x98,0x00,0xA3,0xAF,
+0x00,0x00,0x42,0x8C,
+0x25,0xB0,0x03,0x3C,
+0xD0,0x0E,0x63,0x34,
+0x9C,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8C,
+0x00,0x00,0x00,0x00,
+0xA0,0x00,0xA3,0xAF,
+0x00,0x00,0x02,0x8E,
+0x25,0xB0,0x03,0x3C,
+0xD8,0x0E,0x63,0x34,
+0xA4,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8C,
+0x02,0x5C,0x00,0x0C,
+0xA8,0x00,0xA3,0xAF,
+0x21,0x20,0x40,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x21,0x20,0x60,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x21,0x20,0x80,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x21,0x20,0xA0,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x21,0x20,0xC0,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x21,0x20,0xE0,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x02,0x80,0x02,0x3C,
+0xA8,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x25,0xB0,0x13,0x3C,
+0x02,0x80,0x03,0x3C,
+0xAC,0xED,0x63,0x24,
+0x00,0x00,0x64,0x8C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x21,0xB0,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xB0,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0xFF,0x03,0x14,0x3C,
+0x02,0x80,0x03,0x3C,
+0xB4,0xED,0x63,0x24,
+0x00,0x00,0x64,0x8C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x10,0x00,0xB7,0x27,
+0x21,0x20,0x00,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x02,0x80,0x02,0x3C,
+0xB8,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0xE4,0x28,0x00,0x08,
+0x21,0xA8,0x00,0x00,
+0x6E,0x00,0xC2,0x13,
+0x02,0x80,0x02,0x3C,
+0xAC,0x0E,0x62,0x36,
+0x94,0x0E,0x63,0x36,
+0x00,0x00,0x48,0x8C,
+0x00,0x00,0x64,0x8C,
+0xB4,0x0E,0x62,0x36,
+0x9C,0x0E,0x63,0x36,
+0x00,0x00,0x45,0x8C,
+0x00,0x00,0x66,0x8C,
+0x25,0xB0,0x03,0x3C,
+0xBC,0x0E,0x63,0x34,
+0x00,0x00,0x67,0x8C,
+0x24,0x20,0x94,0x00,
+0x00,0xD8,0x02,0x3C,
+0x24,0x10,0x02,0x01,
+0x24,0x28,0xB4,0x00,
+0x24,0x30,0xD4,0x00,
+0x24,0x38,0xF4,0x00,
+0x02,0x24,0x04,0x00,
+0x20,0x01,0x03,0x24,
+0x01,0x00,0x42,0x2C,
+0x02,0x2C,0x05,0x00,
+0x02,0x34,0x06,0x00,
+0xE8,0x00,0x83,0x10,
+0x02,0x3C,0x07,0x00,
+0xE6,0x00,0xA3,0x10,
+0x20,0x00,0x03,0x24,
+0xE4,0x00,0xC3,0x10,
+0x00,0x00,0x00,0x00,
+0xE2,0x00,0xE3,0x10,
+0x01,0x00,0x08,0x24,
+0x80,0x00,0x03,0x24,
+0x08,0x00,0x83,0x10,
+0x21,0x20,0x00,0x00,
+0x06,0x00,0xA3,0x10,
+0x21,0x20,0x00,0x00,
+0xE0,0x03,0x03,0x24,
+0x03,0x00,0xC3,0x10,
+0x00,0x00,0x00,0x00,
+0xDB,0x00,0xE3,0x10,
+0x01,0x00,0x04,0x24,
+0x05,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x00,0x11,
+0x00,0x00,0x00,0x00,
+0xD7,0x00,0x80,0x14,
+0x94,0x0E,0x63,0x36,
+0x01,0x00,0xB5,0x26,
+0x0A,0x00,0xA2,0x2E,
+0x01,0x01,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xCB,0xFF,0xC0,0x17,
+0x01,0x00,0x02,0x24,
+0xA0,0x00,0x03,0x3C,
+0x30,0x54,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x04,0x0C,0x64,0x36,
+0x08,0x00,0x05,0x3C,
+0xE4,0x00,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x08,0x0C,0x64,0x36,
+0x28,0x0E,0x64,0x36,
+0x02,0x5C,0x00,0x0C,
+0x80,0x80,0x05,0x3C,
+0x14,0x02,0x02,0x3C,
+0x48,0x01,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x40,0x0E,0x64,0x36,
+0x16,0x68,0x05,0x3C,
+0xA2,0x04,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x44,0x0E,0x64,0x36,
+0x4C,0x0E,0x64,0x36,
+0x02,0x5C,0x00,0x0C,
+0xD1,0x28,0x05,0x24,
+0x14,0x02,0x03,0x3C,
+0x4D,0x01,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x60,0x0E,0x64,0x36,
+0x16,0x28,0x05,0x3C,
+0xBA,0x08,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x64,0x0E,0x64,0x36,
+0x6C,0x0E,0x64,0x36,
+0x02,0x5C,0x00,0x0C,
+0xD1,0x28,0x05,0x24,
+0x00,0xFB,0x05,0x3C,
+0x01,0x00,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0x64,0x36,
+0x00,0xF8,0x05,0x3C,
+0x01,0x00,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0x64,0x36,
+0x25,0x22,0x00,0x0C,
+0x03,0x00,0x04,0x24,
+0xA0,0x00,0x02,0x3C,
+0x33,0x54,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x04,0x0C,0x64,0x36,
+0x08,0x0C,0x64,0x36,
+0x02,0x5C,0x00,0x0C,
+0xE4,0x00,0x05,0x24,
+0x28,0x0E,0x64,0x36,
+0x02,0x5C,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x96,0xFF,0xC2,0x17,
+0xAC,0x0E,0x62,0x36,
+0x02,0x80,0x02,0x3C,
+0xBC,0xED,0x42,0x24,
+0x25,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0x8C,
+0x20,0x08,0x63,0x34,
+0x00,0x00,0x71,0x8C,
+0x00,0x01,0x03,0x3C,
+0x00,0x01,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x25,0xB0,0x12,0x3C,
+0x00,0x01,0x02,0x3C,
+0x00,0x01,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x28,0x08,0x44,0x36,
+0xA0,0x00,0x03,0x3C,
+0x30,0x54,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x04,0x0C,0x44,0x36,
+0x08,0x00,0x05,0x3C,
+0xE4,0x00,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x08,0x0C,0x44,0x36,
+0x28,0x0E,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0x80,0x80,0x05,0x3C,
+0x00,0x01,0x02,0x3C,
+0x00,0x7C,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x30,0x0E,0x44,0x36,
+0x00,0x01,0x03,0x3C,
+0x00,0x48,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x34,0x0E,0x44,0x36,
+0x00,0x10,0x02,0x3C,
+0x1F,0xDC,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x38,0x0E,0x44,0x36,
+0x00,0x10,0x03,0x3C,
+0x1F,0x8C,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x3C,0x0E,0x44,0x36,
+0x14,0x02,0x02,0x3C,
+0x02,0x01,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x40,0x0E,0x44,0x36,
+0x16,0x68,0x05,0x3C,
+0xC7,0x04,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x44,0x0E,0x44,0x36,
+0x4C,0x0E,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0xD1,0x28,0x05,0x24,
+0x6C,0x0E,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0xD1,0x28,0x05,0x24,
+0x00,0x01,0x03,0x3C,
+0x00,0x7C,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x50,0x0E,0x44,0x36,
+0x00,0x01,0x02,0x3C,
+0x00,0x48,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x54,0x0E,0x44,0x36,
+0x00,0x10,0x03,0x3C,
+0x23,0xDC,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x58,0x0E,0x44,0x36,
+0x00,0x10,0x02,0x3C,
+0x23,0x8C,0x45,0x34,
+0x02,0x5C,0x00,0x0C,
+0x5C,0x0E,0x44,0x36,
+0x14,0x02,0x03,0x3C,
+0x02,0x01,0x65,0x34,
+0x02,0x5C,0x00,0x0C,
+0x60,0x0E,0x44,0x36,
+0x16,0x28,0x05,0x3C,
+0x07,0x0D,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x64,0x0E,0x44,0x36,
+0x48,0x0E,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0xFB,0x05,0x3C,
+0x00,0xF8,0x05,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0x44,0x36,
+0x00,0x02,0x10,0x3C,
+0x25,0x22,0x00,0x0C,
+0x03,0x00,0x04,0x24,
+0x4C,0x0E,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0xD1,0x28,0x05,0x36,
+0xD1,0x28,0x05,0x36,
+0x02,0x5C,0x00,0x0C,
+0x6C,0x0E,0x44,0x36,
+0x48,0x0E,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0xFB,0x05,0x3C,
+0x00,0xF8,0x05,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0x44,0x36,
+0x25,0x22,0x00,0x0C,
+0x03,0x00,0x04,0x24,
+0xAC,0x00,0xA5,0x8F,
+0x04,0x0C,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x31,0x32,
+0xB0,0x00,0xA5,0x8F,
+0x08,0x0C,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0x2B,0x88,0x11,0x00,
+0x28,0x0E,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x23,0xFF,0x20,0x16,
+0xAC,0x0E,0x62,0x36,
+0x02,0x80,0x02,0x3C,
+0xBC,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x05,0x3C,
+0x28,0x08,0x44,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x05,0x3C,
+0xAC,0x0E,0x62,0x36,
+0x94,0x0E,0x63,0x36,
+0x00,0x00,0x48,0x8C,
+0x00,0x00,0x64,0x8C,
+0xB4,0x0E,0x62,0x36,
+0x9C,0x0E,0x63,0x36,
+0x00,0x00,0x45,0x8C,
+0x00,0x00,0x66,0x8C,
+0x25,0xB0,0x03,0x3C,
+0xBC,0x0E,0x63,0x34,
+0x00,0x00,0x67,0x8C,
+0x24,0x20,0x94,0x00,
+0x00,0xD8,0x02,0x3C,
+0x24,0x10,0x02,0x01,
+0x24,0x28,0xB4,0x00,
+0x24,0x30,0xD4,0x00,
+0x24,0x38,0xF4,0x00,
+0x02,0x24,0x04,0x00,
+0x20,0x01,0x03,0x24,
+0x01,0x00,0x42,0x2C,
+0x02,0x2C,0x05,0x00,
+0x02,0x34,0x06,0x00,
+0x1A,0xFF,0x83,0x14,
+0x02,0x3C,0x07,0x00,
+0x80,0x00,0x03,0x24,
+0x20,0xFF,0x83,0x14,
+0x21,0x40,0x00,0x00,
+0xDA,0x28,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x62,0x8C,
+0x9C,0x0E,0x65,0x36,
+0xA4,0x0E,0x66,0x36,
+0x24,0x10,0x54,0x00,
+0x02,0x14,0x02,0x00,
+0x00,0x00,0xE2,0xAE,
+0x00,0x00,0xA4,0x8C,
+0xAC,0x0E,0x67,0x36,
+0xB4,0x0E,0x65,0x36,
+0x24,0x20,0x94,0x00,
+0x02,0x24,0x04,0x00,
+0x04,0x00,0xE4,0xAE,
+0x00,0x00,0xC3,0x8C,
+0xC4,0x0E,0x64,0x36,
+0x24,0x18,0x74,0x00,
+0x02,0x1C,0x03,0x00,
+0x08,0x00,0xE3,0xAE,
+0x00,0x00,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x54,0x00,
+0x02,0x14,0x02,0x00,
+0x0C,0x00,0xE2,0xAE,
+0x00,0x00,0xA3,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x18,0x74,0x00,
+0x02,0x1C,0x03,0x00,
+0x10,0x00,0xE3,0xAE,
+0x25,0xB0,0x03,0x3C,
+0xBC,0x0E,0x63,0x34,
+0x00,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x54,0x00,
+0x02,0x14,0x02,0x00,
+0x14,0x00,0xE2,0xAE,
+0x00,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x18,0x74,0x00,
+0x02,0x1C,0x03,0x00,
+0x18,0x00,0xE3,0xAE,
+0x25,0xB0,0x03,0x3C,
+0xCC,0x0E,0x63,0x34,
+0x00,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x54,0x00,
+0x02,0x14,0x02,0x00,
+0x1C,0x00,0xE2,0xAE,
+0x01,0x00,0xD6,0x26,
+0x03,0x00,0xC2,0x2E,
+0xC7,0xFE,0x40,0x14,
+0x20,0x00,0xF7,0x26,
+0x10,0x00,0xB0,0x8F,
+0x00,0x00,0x00,0x00,
+0x49,0x01,0x00,0x16,
+0x00,0x00,0x00,0x00,
+0x30,0x00,0xB1,0x8F,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x20,0x16,
+0x21,0x20,0x00,0x02,
+0x50,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x29,0x00,0x40,0x10,
+0xFF,0x00,0x05,0x24,
+0x21,0x20,0x00,0x02,
+0x05,0x28,0x00,0x0C,
+0x21,0x28,0x20,0x02,
+0x03,0x00,0x42,0x2C,
+0x08,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0xA5,0x8F,
+0x14,0x00,0xA4,0x8F,
+0x05,0x28,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x2C,
+0x1C,0x00,0x40,0x14,
+0x21,0x28,0x00,0x00,
+0x50,0x00,0xB2,0x8F,
+0x21,0x20,0x00,0x02,
+0x05,0x28,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x03,0x00,0x42,0x2C,
+0x09,0x00,0x40,0x10,
+0x21,0x20,0x20,0x02,
+0x54,0x00,0xA5,0x8F,
+0x14,0x00,0xA4,0x8F,
+0x05,0x28,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x2C,
+0x0E,0x00,0x40,0x14,
+0x21,0x28,0x00,0x00,
+0x21,0x20,0x20,0x02,
+0x05,0x28,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x03,0x00,0x42,0x2C,
+0xE0,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x54,0x00,0xA5,0x8F,
+0x34,0x00,0xA4,0x8F,
+0x05,0x28,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x2C,
+0xD9,0x00,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x02,0x24,
+0xDB,0x00,0xA2,0x10,
+0x25,0xB0,0x03,0x3C,
+0x10,0x00,0xA2,0x27,
+0x40,0x29,0x05,0x00,
+0x02,0x80,0x0F,0x3C,
+0x21,0x28,0xA2,0x00,
+0x30,0x1F,0xEC,0x25,
+0x00,0x00,0xA6,0x8C,
+0x0C,0x00,0xA7,0x8C,
+0x0C,0x00,0x83,0x8D,
+0x10,0x00,0x84,0x8D,
+0x04,0x00,0xA8,0x8C,
+0x10,0x00,0xA9,0x8C,
+0x00,0xFC,0x02,0x24,
+0x08,0x00,0xAA,0x8C,
+0x14,0x00,0xAB,0x8C,
+0x24,0x20,0x82,0x00,
+0xFF,0x03,0xC6,0x30,
+0x24,0x18,0x62,0x00,
+0xFF,0x03,0xE7,0x30,
+0xF0,0xFF,0x02,0x3C,
+0xFF,0x03,0x42,0x34,
+0x25,0x18,0x66,0x00,
+0x25,0x20,0x87,0x00,
+0xFF,0x03,0x08,0x31,
+0xFF,0x03,0x29,0x31,
+0x24,0x20,0x82,0x00,
+0x24,0x18,0x62,0x00,
+0x80,0x42,0x08,0x00,
+0x80,0x4A,0x09,0x00,
+0x0F,0xC0,0x02,0x3C,
+0x1C,0x00,0xA6,0x8C,
+0x18,0x00,0xA7,0x8C,
+0xFF,0xFF,0x42,0x34,
+0x25,0x18,0x68,0x00,
+0x25,0x20,0x89,0x00,
+0xFF,0x03,0x4A,0x31,
+0xFF,0x03,0x6B,0x31,
+0x24,0x20,0x82,0x00,
+0x00,0x55,0x0A,0x00,
+0x24,0x18,0x62,0x00,
+0x00,0x5D,0x0B,0x00,
+0x25,0x18,0x6A,0x00,
+0x25,0x20,0x8B,0x00,
+0x16,0x00,0x86,0xA5,
+0x0C,0x00,0x83,0xAD,
+0x10,0x00,0x84,0xAD,
+0x14,0x00,0x87,0xA5,
+0x30,0x1F,0xF1,0x25,
+0x10,0x00,0x22,0x8E,
+0x01,0x00,0x03,0x24,
+0x82,0x17,0x02,0x00,
+0x4D,0x00,0x43,0x10,
+0x25,0xB0,0x12,0x3C,
+0x0C,0x00,0x23,0x8E,
+0x80,0x0C,0x44,0x36,
+0x00,0x00,0x88,0x8C,
+0x00,0x02,0x62,0x30,
+0xC0,0xFF,0x13,0x3C,
+0x82,0x6D,0x08,0x00,
+0x03,0x00,0x40,0x10,
+0xFF,0x03,0x65,0x30,
+0x00,0xFC,0x02,0x24,
+0x25,0x28,0xA2,0x00,
+0x18,0x00,0xAD,0x00,
+0x82,0x62,0x03,0x00,
+0xFF,0x03,0x8C,0x31,
+0x00,0x02,0x83,0x31,
+0x12,0x10,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x03,0x00,0x60,0x10,
+0xFF,0x03,0x46,0x30,
+0x00,0xFC,0x02,0x24,
+0x25,0x60,0x82,0x01,
+0x18,0x00,0x8D,0x01,
+0x00,0xFC,0x74,0x36,
+0x24,0x28,0x14,0x01,
+0x12,0x80,0x00,0x00,
+0x02,0x82,0x10,0x00,
+0x3F,0x00,0x02,0x32,
+0x00,0x14,0x02,0x00,
+0x25,0x28,0xA2,0x00,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0xA6,0x00,
+0x94,0x0C,0x44,0x36,
+0x00,0x00,0x85,0x8C,
+0xFF,0x0F,0x02,0x3C,
+0xFF,0xFF,0x55,0x34,
+0xC0,0x03,0x10,0x32,
+0x24,0x28,0xB5,0x00,
+0x80,0x85,0x10,0x00,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0xB0,0x00,
+0x10,0x00,0x2C,0x8E,
+0x88,0x0C,0x44,0x36,
+0x00,0x00,0x88,0x8C,
+0x82,0x2A,0x0C,0x00,
+0xFF,0x03,0xA5,0x30,
+0x24,0x10,0x13,0x01,
+0x00,0x02,0xA3,0x30,
+0x03,0x00,0x60,0x10,
+0x82,0x6D,0x02,0x00,
+0x00,0xFC,0x02,0x24,
+0x25,0x28,0xA2,0x00,
+0x18,0x00,0xAD,0x00,
+0x02,0x65,0x0C,0x00,
+0xFF,0x03,0x8C,0x31,
+0x00,0x02,0x83,0x31,
+0x12,0x10,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x03,0x00,0x60,0x10,
+0xFF,0x03,0x46,0x30,
+0x00,0xFC,0x02,0x24,
+0x25,0x60,0x82,0x01,
+0x18,0x00,0x8D,0x01,
+0x24,0x28,0x14,0x01,
+0x12,0x80,0x00,0x00,
+0x02,0x82,0x10,0x00,
+0x3F,0x00,0x02,0x32,
+0x00,0x14,0x02,0x00,
+0x25,0x28,0xA2,0x00,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0xA6,0x00,
+0x9C,0x0C,0x44,0x36,
+0x00,0x00,0x85,0x8C,
+0xC0,0x03,0x10,0x32,
+0x80,0x85,0x10,0x00,
+0x24,0x28,0xB5,0x00,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0xB0,0x00,
+0x78,0x00,0xA5,0x8F,
+0x25,0xB0,0x10,0x3C,
+0x02,0x5C,0x00,0x0C,
+0xE0,0x0E,0x04,0x36,
+0x7C,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0xDC,0x0E,0x04,0x36,
+0x80,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x70,0x0E,0x04,0x36,
+0x84,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x74,0x0E,0x04,0x36,
+0x88,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x78,0x0E,0x04,0x36,
+0x8C,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x7C,0x0E,0x04,0x36,
+0x90,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x80,0x0E,0x04,0x36,
+0x94,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x84,0x0E,0x04,0x36,
+0x98,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x88,0x0E,0x04,0x36,
+0x9C,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x8C,0x0E,0x04,0x36,
+0xA0,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0xD0,0x0E,0x04,0x36,
+0xA4,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0xD4,0x0E,0x04,0x36,
+0xA8,0x00,0xA5,0x8F,
+0x88,0x0E,0x04,0x36,
+0x02,0x5C,0x00,0x0C,
+0x0F,0x00,0x10,0x3C,
+0x70,0x00,0xA6,0x8F,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x74,0x00,0xA6,0x8F,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0xFF,0xFF,0x05,0x36,
+0x8A,0x47,0x00,0x0C,
+0x1E,0x00,0x04,0x24,
+0x21,0x88,0x40,0x00,
+0xFD,0xFF,0x06,0x24,
+0x01,0x00,0x42,0x34,
+0x24,0x30,0x46,0x00,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x1E,0x00,0x04,0x24,
+0x25,0x22,0x00,0x0C,
+0x03,0x00,0x04,0x24,
+0xFF,0xFF,0x05,0x36,
+0x03,0x00,0x26,0x36,
+0x5F,0x47,0x00,0x0C,
+0x1E,0x00,0x04,0x24,
+0xDC,0x00,0xBF,0x8F,
+0xD8,0x00,0xBE,0x8F,
+0xD4,0x00,0xB7,0x8F,
+0xD0,0x00,0xB6,0x8F,
+0xCC,0x00,0xB5,0x8F,
+0xC8,0x00,0xB4,0x8F,
+0xC4,0x00,0xB3,0x8F,
+0xC0,0x00,0xB2,0x8F,
+0xBC,0x00,0xB1,0x8F,
+0xB8,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0xE0,0x00,0xBD,0x27,
+0xFF,0x00,0x05,0x24,
+0xFF,0x00,0x02,0x24,
+0x29,0xFF,0xA2,0x14,
+0x10,0x00,0xA2,0x27,
+0x25,0xB0,0x03,0x3C,
+0x94,0x0E,0x62,0x34,
+0x9C,0x0E,0x64,0x34,
+0xA4,0x0E,0x65,0x34,
+0xAC,0x0E,0x66,0x34,
+0x02,0x80,0x0F,0x3C,
+0x00,0x00,0x49,0x8C,
+0x30,0x1F,0xED,0x25,
+0x00,0x00,0x8C,0x8C,
+0x00,0x00,0xAE,0x8C,
+0x00,0x00,0xC7,0x8C,
+0xB4,0x0E,0x62,0x34,
+0x0C,0x00,0xA4,0x8D,
+0x10,0x00,0xA5,0x8D,
+0x00,0x00,0x4A,0x8C,
+0xFF,0x03,0x06,0x3C,
+0x00,0xFC,0x08,0x24,
+0xBC,0x0E,0x62,0x34,
+0x24,0x48,0x26,0x01,
+0x24,0x38,0xE6,0x00,
+0x00,0x00,0x4B,0x8C,
+0x24,0x28,0xA8,0x00,
+0x24,0x20,0x88,0x00,
+0x02,0x3C,0x07,0x00,
+0xCC,0x0E,0x68,0x34,
+0x02,0x4C,0x09,0x00,
+0xC4,0x0E,0x63,0x34,
+0xF0,0xFF,0x02,0x3C,
+0xFF,0x03,0x42,0x34,
+0x25,0x28,0xA7,0x00,
+0x25,0x20,0x89,0x00,
+0x00,0x00,0x67,0x8C,
+0x24,0x60,0x86,0x01,
+0x00,0x00,0x03,0x8D,
+0x24,0x50,0x46,0x01,
+0x24,0x28,0xA2,0x00,
+0x24,0x20,0x82,0x00,
+0x82,0x61,0x0C,0x00,
+0x82,0x51,0x0A,0x00,
+0x0F,0xC0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x25,0x20,0x8C,0x00,
+0x25,0x28,0xAA,0x00,
+0x24,0x70,0xC6,0x01,
+0x24,0x58,0x66,0x01,
+0x24,0x28,0xA2,0x00,
+0x24,0x18,0x66,0x00,
+0x00,0x71,0x0E,0x00,
+0x24,0x20,0x82,0x00,
+0x00,0x59,0x0B,0x00,
+0x24,0x38,0xE6,0x00,
+0x25,0x20,0x8E,0x00,
+0x25,0x28,0xAB,0x00,
+0x02,0x3C,0x07,0x00,
+0x02,0x1C,0x03,0x00,
+0x16,0x00,0xA3,0xA5,
+0x0C,0x00,0xA4,0xAD,
+0x10,0x00,0xA5,0xAD,
+0x4D,0x2A,0x00,0x08,
+0x14,0x00,0xA7,0xA5,
+0x30,0x00,0xB1,0x8F,
+0xF5,0x29,0x00,0x08,
+0x21,0x20,0x00,0x02,
+0x25,0xB0,0x05,0x3C,
+0x4C,0x00,0xA2,0x34,
+0x02,0x80,0x07,0x3C,
+0x00,0x00,0x43,0x90,
+0x30,0x1F,0xE4,0x24,
+0xC1,0x1B,0x82,0x90,
+0x03,0x00,0x66,0x30,
+0x24,0x00,0x46,0x10,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xC0,0x14,
+0x25,0xB0,0x03,0x3C,
+0xE6,0x02,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x15,0x00,0x40,0x14,
+0x58,0x00,0x62,0x34,
+0x1C,0x00,0x02,0x24,
+0x50,0x0C,0xA3,0x34,
+0x00,0x00,0x62,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x25,0xB0,0x02,0x3C,
+0x58,0x0C,0x42,0x34,
+0x1C,0x00,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x25,0xB0,0x03,0x3C,
+0x58,0x00,0x62,0x34,
+0x00,0x00,0x45,0x8C,
+0x29,0xB0,0x04,0x3C,
+0x5C,0x00,0x63,0x34,
+0x00,0x00,0x85,0xAC,
+0x00,0x00,0x65,0x8C,
+0x30,0x1F,0xE2,0x24,
+0x04,0x00,0x84,0x34,
+0xC1,0x1B,0x46,0xA0,
+0x00,0x00,0x85,0xAC,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x2D,0x0A,0x46,0x34,
+0xA2,0x0D,0x43,0x34,
+0xA4,0x0D,0x44,0x34,
+0xA6,0x0D,0x45,0x34,
+0xA8,0x0D,0x42,0x34,
+0x00,0x00,0x67,0x94,
+0x00,0x00,0x88,0x94,
+0x00,0x00,0xA9,0x94,
+0x00,0x00,0x44,0x94,
+0x00,0x00,0xC3,0x90,
+0x02,0x80,0x0A,0x3C,
+0x30,0x1F,0x42,0x25,
+0x40,0x00,0x63,0x34,
+0xFF,0x00,0x63,0x30,
+0xDE,0x02,0x44,0xA4,
+0x00,0x00,0xC3,0xA0,
+0xD8,0x02,0x47,0xA4,
+0xDA,0x02,0x48,0xA4,
+0xDC,0x02,0x49,0xA4,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x25,0xB0,0x07,0x3C,
+0x5B,0x0A,0xE2,0x34,
+0x00,0x00,0x44,0x90,
+0x30,0x1F,0x46,0x25,
+0x5C,0x0A,0xE2,0x34,
+0x00,0x00,0x45,0x90,
+0xD8,0x02,0xC3,0x94,
+0xDA,0x02,0xC2,0x94,
+0xDC,0x02,0xC9,0x94,
+0xDE,0x02,0xC8,0x94,
+0xFF,0x00,0x84,0x30,
+0x21,0x18,0x62,0x00,
+0x00,0x22,0x04,0x00,
+0xFF,0x00,0xA5,0x30,
+0x21,0x20,0x85,0x00,
+0x21,0x18,0x69,0x00,
+0xFF,0xFF,0x82,0x30,
+0x21,0x18,0x68,0x00,
+0x21,0x18,0x62,0x00,
+0x64,0x0C,0xE7,0x34,
+0xFF,0xFF,0x42,0x30,
+0xE0,0x02,0xC3,0xAC,
+0x00,0x00,0xE2,0xA4,
+0xE4,0x02,0xC4,0xA4,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x42,0x8D,
+0x01,0x00,0x03,0x24,
+0x0F,0x00,0x44,0x30,
+0x07,0x00,0x83,0x10,
+0x30,0x1F,0x45,0x25,
+0xB6,0x5F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE4,0x02,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x17,0x02,0x00,
+0x03,0x00,0x42,0x30,
+0xF5,0xFF,0x40,0x14,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x63,0x30,
+0x3F,0x00,0x64,0x10,
+0x30,0x1F,0x44,0x25,
+0xE6,0x02,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x40,0x14,
+0x01,0x00,0x03,0x24,
+0x30,0x1F,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x0F,0x00,0x42,0x30,
+0x3C,0x00,0x43,0x10,
+0x25,0xB0,0x02,0x3C,
+0x30,0x1F,0x45,0x25,
+0xE6,0x02,0xA3,0x90,
+0xFF,0x00,0x02,0x24,
+0xE0,0xFF,0x62,0x14,
+0x25,0xB0,0x03,0x3C,
+0xC8,0x02,0xA2,0x94,
+0xE0,0x02,0xA6,0x8C,
+0x50,0x0C,0x63,0x34,
+0x00,0x00,0x64,0x90,
+0x2B,0x10,0xC2,0x00,
+0x85,0x00,0x40,0x10,
+0x7F,0x00,0x84,0x30,
+0xFF,0xFF,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x30,0x1F,0x45,0x25,
+0xD0,0x02,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x64,0x00,
+0x78,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x60,0x00,
+0x30,0x1F,0x43,0x25,
+0xE0,0x02,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x11,0x27,0x42,0x2C,
+0x6D,0x00,0x40,0x14,
+0x3A,0x00,0x82,0x2C,
+0x32,0x00,0x04,0x24,
+0x44,0x00,0x03,0x24,
+0x25,0xB0,0x02,0x3C,
+0x30,0x0C,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x25,0xB0,0x02,0x3C,
+0x50,0x0C,0x42,0x34,
+0x00,0x00,0x44,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x25,0xB0,0x02,0x3C,
+0x58,0x0C,0x42,0x34,
+0x00,0x00,0x44,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0xA4,0x2B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE6,0x02,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xBF,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x02,0x24,
+0xB6,0x2B,0x00,0x08,
+0xE6,0x02,0xA2,0xA0,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x63,0x30,
+0xA4,0xFF,0x60,0x10,
+0xFF,0xFF,0x02,0x34,
+0x80,0x36,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0xA0,0xFF,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0xE0,0x02,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x65,0x00,0x62,0x2C,
+0x59,0x00,0x40,0x14,
+0x28,0x00,0x62,0x2C,
+0xD2,0x02,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0xFE,0xFF,0x42,0x24,
+0xFC,0xFF,0x42,0x28,
+0x02,0x00,0x40,0x10,
+0xFE,0xFF,0x62,0x24,
+0xFC,0xFF,0x02,0x24,
+0xD2,0x02,0x82,0xA0,
+0x30,0x1F,0x45,0x25,
+0x80,0x36,0xA2,0x8C,
+0xD2,0x02,0xA3,0x90,
+0xCE,0x02,0xA6,0x90,
+0x02,0x11,0x02,0x00,
+0x7F,0x00,0x42,0x30,
+0x0A,0x00,0x44,0x24,
+0x23,0x18,0x83,0x00,
+0x00,0x26,0x03,0x00,
+0x03,0x26,0x04,0x00,
+0xFF,0x00,0xC2,0x30,
+0x2A,0x10,0x44,0x00,
+0x4D,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x26,0x06,0x00,
+0x03,0x26,0x04,0x00,
+0x30,0x1F,0x43,0x25,
+0xE0,0x02,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x11,0x27,0x42,0x2C,
+0x33,0x00,0x40,0x14,
+0x3A,0x00,0x82,0x28,
+0x32,0x00,0x82,0x28,
+0x30,0x00,0x40,0x10,
+0x3A,0x00,0x82,0x28,
+0x32,0x00,0x04,0x24,
+0x44,0x00,0x03,0x24,
+0x25,0xB0,0x02,0x3C,
+0x30,0x0C,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x25,0xB0,0x02,0x3C,
+0x50,0x0C,0x42,0x34,
+0xFF,0x00,0x84,0x30,
+0x00,0x00,0x44,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x25,0xB0,0x02,0x3C,
+0x58,0x0C,0x42,0x34,
+0x00,0x00,0x44,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0xA4,0x2B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x95,0xFF,0x40,0x10,
+0x48,0x00,0x03,0x24,
+0xDD,0x2B,0x00,0x08,
+0x44,0x00,0x03,0x24,
+0xD1,0x02,0xA3,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x83,0x00,
+0xD5,0x2B,0x00,0x08,
+0x0B,0x20,0x62,0x00,
+0xCA,0x02,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0xC2,0x00,
+0x7A,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xCC,0x02,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0xC2,0x00,
+0x07,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xCD,0x2B,0x00,0x08,
+0x01,0x00,0x82,0x24,
+0xD2,0xFF,0x40,0x10,
+0x48,0x00,0x03,0x24,
+0x2F,0x2C,0x00,0x08,
+0x44,0x00,0x03,0x24,
+0xCD,0x2B,0x00,0x08,
+0x02,0x00,0x82,0x24,
+0xB2,0xFF,0x40,0x10,
+0x30,0x1F,0x45,0x25,
+0xD2,0x02,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x02,0x00,0x42,0x24,
+0x0D,0x00,0x42,0x28,
+0x09,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x13,0x2C,0x00,0x08,
+0x0C,0x00,0x02,0x24,
+0xCF,0x02,0xA3,0x80,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x62,0x30,
+0x2A,0x10,0x82,0x00,
+0x24,0x2C,0x00,0x08,
+0x0B,0x20,0x62,0x00,
+0x13,0x2C,0x00,0x08,
+0x02,0x00,0x62,0x24,
+0xC0,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x25,0xB0,0x14,0x3C,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x34,0x00,0xB7,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x24,0x00,0xB3,0xAF,
+0xD8,0x00,0x86,0x36,
+0x00,0x00,0xC3,0x90,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x51,0x24,
+0x2A,0xB0,0x10,0x3C,
+0xA0,0xFF,0x02,0x24,
+0x25,0x18,0x62,0x00,
+0x34,0x00,0x05,0x36,
+0xFE,0xFF,0x02,0x24,
+0xBC,0x02,0x33,0x92,
+0x40,0x00,0x04,0x24,
+0x00,0x00,0xC3,0xA0,
+0x00,0x00,0xA2,0xA0,
+0x25,0x24,0x00,0x0C,
+0x00,0x9E,0x13,0x00,
+0x21,0x90,0x40,0x00,
+0x8A,0x00,0x40,0x12,
+0x00,0x40,0x02,0x3C,
+0x08,0x00,0x43,0x8E,
+0xB0,0x03,0x82,0x36,
+0x25,0xB0,0x1E,0x3C,
+0x21,0x20,0x40,0x02,
+0x00,0x00,0x43,0xAC,
+0x0C,0x4D,0x00,0x0C,
+0x21,0xB8,0x20,0x02,
+0x42,0x00,0xD5,0x37,
+0x03,0x0C,0xD1,0x37,
+0x17,0x0E,0xD6,0x37,
+0x04,0x00,0x14,0x24,
+0x2A,0xB0,0x03,0x3C,
+0x06,0x00,0x63,0x34,
+0x00,0x00,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0xFF,0x42,0x30,
+0x0A,0x00,0x40,0x18,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x8C,0xF0,0x84,0x24,
+0x00,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0xFF,0x42,0x30,
+0xFC,0xFF,0x40,0x1C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x45,0x8E,
+0x20,0x10,0x06,0x3C,
+0x01,0x00,0x04,0x24,
+0x00,0xFE,0xC6,0x34,
+0x40,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA4,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x90,0xF0,0x42,0x24,
+0x00,0x00,0x45,0x8C,
+0x01,0x00,0x03,0x24,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0xA3,0xA0,
+0xFF,0xFF,0x03,0x24,
+0x00,0x00,0xA3,0xA2,
+0x00,0x00,0x22,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x40,0x00,0x42,0x34,
+0x00,0x00,0x22,0xA2,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x02,0x00,0x02,0x24,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0xA2,0xA0,
+0x30,0x1F,0x83,0x24,
+0xC1,0x02,0x62,0x90,
+0x00,0x00,0xC4,0x92,
+0x21,0x28,0x00,0x00,
+0x00,0x00,0xC2,0xA2,
+0xFF,0x00,0x90,0x30,
+0x01,0x00,0xA2,0x24,
+0xFF,0x00,0x45,0x30,
+0x06,0x00,0xA3,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0xA2,0x24,
+0xEF,0xFF,0x02,0x24,
+0x64,0x00,0x04,0x24,
+0x00,0x00,0xA2,0xA2,
+0x54,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x22,0x92,
+0x21,0x20,0x00,0x00,
+0xBF,0x00,0x42,0x30,
+0x00,0x00,0x22,0xA2,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x54,0x22,0x00,0x0C,
+0x84,0x03,0x04,0x24,
+0xF4,0x08,0xC2,0x37,
+0x00,0x00,0x43,0x8C,
+0x00,0x80,0x04,0x3C,
+0xDF,0x07,0x84,0x34,
+0x00,0x00,0xD0,0xA2,
+0x21,0x10,0x00,0x00,
+0x24,0x28,0x64,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0xA0,0xA2,
+0x00,0x00,0x22,0x92,
+0x21,0x20,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x40,0x00,0x42,0x34,
+0x00,0x00,0x22,0xA2,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0xBE,0x02,0xE2,0x92,
+0x1F,0x00,0xA3,0x30,
+0x2B,0x10,0x62,0x00,
+0x0A,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xBF,0x02,0xE2,0x92,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0x05,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x02,0x3C,
+0x25,0x10,0x62,0x00,
+0x21,0x98,0x62,0x02,
+0x02,0x80,0x02,0x3C,
+0xDE,0x5D,0x43,0x90,
+0x22,0x00,0x02,0x24,
+0x19,0x00,0x62,0x10,
+0x92,0x00,0x02,0x24,
+0x18,0x00,0x62,0x10,
+0x02,0x80,0x03,0x3C,
+0xFF,0xFF,0x94,0x26,
+0x54,0x22,0x00,0x0C,
+0xF4,0x01,0x04,0x24,
+0x89,0xFF,0x81,0x06,
+0x2A,0xB0,0x03,0x3C,
+0x04,0x00,0x40,0x12,
+0x21,0x10,0x60,0x02,
+0x3D,0x24,0x00,0x0C,
+0x21,0x20,0x40,0x02,
+0x21,0x10,0x60,0x02,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x63,0x24,
+0xBE,0x02,0x62,0x90,
+0xC0,0x07,0xA3,0x30,
+0x82,0x19,0x03,0x00,
+0x2B,0x10,0x62,0x00,
+0xE3,0xFF,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x84,0x24,
+0xBF,0x02,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x43,0x00,
+0xDD,0xFF,0x40,0x10,
+0x00,0x12,0x03,0x00,
+0x10,0x00,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x13,0x2D,0x00,0x08,
+0x21,0x98,0x62,0x02,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0xF0,0xF8,0x06,0x34,
+0x15,0x00,0x04,0x24,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x5F,0x47,0x00,0x0C,
+0x14,0x00,0xB1,0xAF,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x02,0x80,0x12,0x3C,
+0xFF,0xFF,0x05,0x36,
+0x56,0x30,0x06,0x24,
+0x5F,0x47,0x00,0x0C,
+0x1A,0x00,0x04,0x24,
+0x30,0x1F,0x51,0x26,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x04,0x03,0x23,0x92,
+0x04,0x00,0x02,0x24,
+0x20,0x00,0x62,0x10,
+0x25,0xB0,0x02,0x3C,
+0x14,0x03,0x25,0x8E,
+0x25,0xB0,0x10,0x3C,
+0x43,0x60,0x00,0x0C,
+0x00,0x0E,0x04,0x36,
+0x14,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x04,0x0E,0x04,0x36,
+0x18,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x08,0x0E,0x04,0x36,
+0x14,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x10,0x0E,0x04,0x36,
+0x14,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x14,0x0E,0x04,0x36,
+0x14,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x18,0x0E,0x04,0x36,
+0x14,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x1C,0x0E,0x04,0x36,
+0x30,0x1F,0x43,0x26,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x04,0x00,0x02,0x24,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x04,0x03,0x62,0xA0,
+0x00,0x0E,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0x14,0x03,0x25,0x8E,
+0x00,0x00,0x00,0x00,
+0xDE,0xFF,0x65,0x14,
+0x25,0xB0,0x10,0x3C,
+0x6A,0x2D,0x00,0x08,
+0x30,0x1F,0x43,0x26,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0xF0,0xF8,0x06,0x34,
+0x15,0x00,0x04,0x24,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x5F,0x47,0x00,0x0C,
+0x14,0x00,0xB1,0xAF,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xFF,0xFF,0x05,0x36,
+0x56,0x30,0x06,0x24,
+0x5F,0x47,0x00,0x0C,
+0x1A,0x00,0x04,0x24,
+0x02,0x80,0x10,0x3C,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x30,0x1F,0x02,0x26,
+0x04,0x03,0x46,0x90,
+0x25,0xB0,0x11,0x3C,
+0x10,0x10,0x12,0x3C,
+0x01,0x00,0x03,0x24,
+0x00,0x0E,0x24,0x36,
+0x1E,0x00,0xC3,0x10,
+0x10,0x10,0x45,0x36,
+0x43,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x04,0x0E,0x24,0x36,
+0x43,0x60,0x00,0x0C,
+0x10,0x10,0x45,0x36,
+0x08,0x0E,0x24,0x36,
+0x43,0x60,0x00,0x0C,
+0x10,0x10,0x05,0x24,
+0x10,0x0E,0x24,0x36,
+0x43,0x60,0x00,0x0C,
+0x10,0x10,0x45,0x36,
+0x14,0x0E,0x24,0x36,
+0x43,0x60,0x00,0x0C,
+0x10,0x10,0x45,0x36,
+0x18,0x0E,0x24,0x36,
+0x43,0x60,0x00,0x0C,
+0x10,0x10,0x45,0x36,
+0x1C,0x0E,0x24,0x36,
+0x43,0x60,0x00,0x0C,
+0x10,0x10,0x45,0x36,
+0x30,0x1F,0x03,0x26,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x04,0x03,0x62,0xA0,
+0x00,0x00,0x86,0x8C,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xC5,0x14,
+0x30,0x1F,0x03,0x26,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x04,0x03,0x62,0xA0,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x02,0x80,0x13,0x3C,
+0x14,0x00,0xB1,0xAF,
+0x30,0x1F,0x71,0x26,
+0x0C,0x03,0x26,0x8E,
+0x10,0x00,0xB0,0xAF,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0x15,0x00,0x04,0x24,
+0x20,0x00,0xBF,0xAF,
+0x5F,0x47,0x00,0x0C,
+0x18,0x00,0xB2,0xAF,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x10,0x03,0x26,0x8E,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x1A,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x04,0x03,0x22,0x92,
+0x25,0xB0,0x12,0x3C,
+0x08,0x00,0x40,0x14,
+0x08,0x0E,0x44,0x36,
+0x25,0xB0,0x02,0x3C,
+0x00,0x0E,0x42,0x34,
+0x00,0x00,0x45,0x8C,
+0xEC,0x02,0x23,0x8E,
+0x00,0x00,0x00,0x00,
+0x17,0x00,0xA3,0x10,
+0x30,0x1F,0x62,0x26,
+0xE8,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEC,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x00,0x0E,0x44,0x36,
+0xF0,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x04,0x0E,0x44,0x36,
+0xF4,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x10,0x0E,0x44,0x36,
+0xF8,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x14,0x0E,0x44,0x36,
+0xFC,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x18,0x0E,0x44,0x36,
+0x00,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x1C,0x0E,0x44,0x36,
+0x30,0x1F,0x62,0x26,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x28,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x04,0x03,0x40,0xA0,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x02,0x80,0x12,0x3C,
+0x14,0x00,0xB1,0xAF,
+0x30,0x1F,0x51,0x26,
+0x0C,0x03,0x26,0x8E,
+0x10,0x00,0xB0,0xAF,
+0x0F,0x00,0x10,0x3C,
+0xFF,0xFF,0x05,0x36,
+0x1C,0x00,0xBF,0xAF,
+0x5F,0x47,0x00,0x0C,
+0x15,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x10,0x03,0x26,0x8E,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x1A,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x04,0x03,0x23,0x92,
+0x03,0x00,0x02,0x24,
+0x2C,0x00,0x62,0x10,
+0x25,0xB0,0x02,0x3C,
+0xEC,0x02,0x25,0x8E,
+0x25,0xB0,0x10,0x3C,
+0x43,0x60,0x00,0x0C,
+0x00,0x0E,0x04,0x36,
+0xF0,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x04,0x0E,0x04,0x36,
+0xF4,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x10,0x0E,0x04,0x36,
+0xF8,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x14,0x0E,0x04,0x36,
+0xFC,0x02,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x18,0x0E,0x04,0x36,
+0x00,0x03,0x25,0x8E,
+0x43,0x60,0x00,0x0C,
+0x1C,0x0E,0x04,0x36,
+0x08,0x03,0x24,0x8E,
+0xE8,0x02,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0x44,0x00,
+0x00,0xFF,0xA3,0x30,
+0xFF,0xFF,0x02,0x3C,
+0xFF,0x00,0x42,0x34,
+0x01,0x3F,0x63,0x2C,
+0x24,0x10,0xA2,0x00,
+0x0C,0x00,0x60,0x10,
+0x08,0x0E,0x04,0x36,
+0x43,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x43,0x26,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x03,0x00,0x02,0x24,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x04,0x03,0x62,0xA0,
+0x32,0x2E,0x00,0x08,
+0x00,0x3F,0x45,0x34,
+0x00,0x0E,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0xEC,0x02,0x25,0x8E,
+0x00,0x00,0x00,0x00,
+0xD2,0xFF,0x65,0x14,
+0x25,0xB0,0x10,0x3C,
+0x35,0x2E,0x00,0x08,
+0x30,0x1F,0x43,0x26,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x02,0x80,0x12,0x3C,
+0x20,0x00,0xB4,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x44,0x26,
+0x0C,0x24,0x82,0x8C,
+0x30,0x1F,0x43,0x8E,
+0x04,0x03,0x93,0x90,
+0x02,0x11,0x02,0x00,
+0x7F,0x00,0x54,0x30,
+0xF0,0xF0,0x63,0x30,
+0x00,0x10,0x02,0x24,
+0x6A,0x00,0x62,0x10,
+0x01,0x00,0x02,0x24,
+0x25,0xB0,0x08,0x3C,
+0x4C,0x00,0x03,0x35,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x42,0x30,
+0x08,0x00,0x40,0x10,
+0x30,0x1F,0x45,0x26,
+0x30,0x1F,0x42,0x8E,
+0x00,0x00,0x00,0x00,
+0x02,0x13,0x02,0x00,
+0x0F,0x00,0x42,0x30,
+0x2F,0x00,0x40,0x10,
+0x00,0x0E,0x05,0x35,
+0x30,0x1F,0x45,0x26,
+0x04,0x03,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x0F,0x00,0x40,0x14,
+0x30,0x1F,0x42,0x26,
+0x25,0xB0,0x02,0x3C,
+0x84,0x01,0x42,0x34,
+0x00,0x00,0x44,0x8C,
+0x0D,0x00,0x03,0x24,
+0x7C,0x00,0x83,0x10,
+0x3E,0x00,0x02,0x24,
+0x4A,0x00,0x03,0x24,
+0x1F,0x03,0xA2,0xA0,
+0x1C,0x03,0xA3,0xA0,
+0x45,0x00,0x02,0x24,
+0x43,0x00,0x03,0x24,
+0x1D,0x03,0xA2,0xA0,
+0x1E,0x03,0xA3,0xA0,
+0x30,0x1F,0x42,0x26,
+0x0C,0x24,0x43,0x8C,
+0x25,0xB0,0x02,0x3C,
+0x60,0x0C,0x42,0x34,
+0x02,0x19,0x03,0x00,
+0xFF,0x00,0x63,0x30,
+0x00,0x00,0x43,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x45,0x8E,
+0x10,0x10,0x02,0x24,
+0xF0,0xF0,0xA3,0x30,
+0x3F,0x00,0x62,0x10,
+0x30,0x1F,0x44,0x26,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x00,0x00,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x5F,0x00,0x40,0x10,
+0x10,0x0E,0x07,0x35,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x08,0x0E,0x02,0x35,
+0x04,0x0E,0x03,0x35,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0xA5,0x8C,
+0x00,0x00,0x66,0x8C,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x49,0x24,
+0xE8,0x02,0x24,0xAD,
+0xEC,0x02,0x25,0xAD,
+0xF0,0x02,0x26,0xAD,
+0x14,0x0E,0x04,0x35,
+0x02,0x80,0x02,0x3C,
+0x18,0x0E,0x05,0x35,
+0x00,0x00,0xE7,0x8C,
+0x1C,0x0E,0x06,0x35,
+0x00,0x00,0x83,0x8C,
+0xDE,0x5D,0x4A,0x90,
+0x00,0x00,0xA2,0x8C,
+0x00,0x00,0xC4,0x8C,
+0xF4,0x02,0x27,0xAD,
+0xFC,0x02,0x22,0xAD,
+0x22,0x00,0x02,0x24,
+0xF8,0x02,0x23,0xAD,
+0x5B,0x00,0x42,0x11,
+0x00,0x03,0x24,0xAD,
+0x92,0x00,0x02,0x24,
+0x59,0x00,0x42,0x11,
+0x0D,0x08,0x02,0x35,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x30,0x1F,0x43,0x8E,
+0xFF,0xFF,0x02,0x3C,
+0xFF,0x0F,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x10,0x63,0x34,
+0x66,0x2E,0x00,0x08,
+0x30,0x1F,0x43,0xAE,
+0x3A,0x00,0x62,0x12,
+0x04,0x00,0x02,0x24,
+0x38,0x00,0x62,0x12,
+0x30,0x1F,0x43,0x26,
+0xFF,0xFF,0x02,0x24,
+0x59,0x2E,0x00,0x08,
+0x04,0x03,0x62,0xA0,
+0x0C,0x24,0x83,0x8C,
+0xFF,0xFF,0x02,0x34,
+0xBF,0xFF,0x62,0x10,
+0x02,0x12,0x05,0x00,
+0x0F,0x00,0x45,0x30,
+0x01,0x00,0x03,0x24,
+0xBB,0xFF,0xA3,0x14,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x63,0x30,
+0xB5,0xFF,0x60,0x10,
+0x03,0x00,0x02,0x24,
+0x65,0x00,0x62,0x12,
+0x04,0x00,0x62,0x2A,
+0x47,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x6A,0x00,0x60,0x12,
+0x00,0x00,0x00,0x00,
+0xAD,0xFF,0x65,0x16,
+0x00,0x00,0x00,0x00,
+0x1C,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x82,0x02,
+0x56,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1F,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x54,0x00,
+0x48,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xBE,0x2D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x8B,0x2E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x3B,0x00,0x02,0x24,
+0x46,0x00,0x03,0x24,
+0x1F,0x03,0xA2,0xA0,
+0x1C,0x03,0xA3,0xA0,
+0x41,0x00,0x02,0x24,
+0x40,0x00,0x03,0x24,
+0x1D,0x03,0xA2,0xA0,
+0x79,0x2E,0x00,0x08,
+0x1E,0x03,0xA3,0xA0,
+0x00,0x00,0xE3,0x8C,
+0x3F,0x3F,0x02,0x3C,
+0x3F,0x3F,0x42,0x34,
+0x9E,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x67,0x2E,0x00,0x08,
+0x30,0x1F,0x45,0x26,
+0x0F,0x00,0x10,0x3C,
+0x01,0x00,0x11,0x3C,
+0xFF,0xFF,0x05,0x36,
+0xF4,0x98,0x26,0x36,
+0x5F,0x47,0x00,0x0C,
+0x15,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xFF,0xFF,0x05,0x36,
+0x56,0x30,0x26,0x36,
+0x5F,0x47,0x00,0x0C,
+0x1A,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x30,0x1F,0x43,0x26,
+0xFF,0xFF,0x02,0x24,
+0x59,0x2E,0x00,0x08,
+0x04,0x03,0x62,0xA0,
+0x0D,0x08,0x02,0x35,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x63,0x30,
+0x08,0x00,0x62,0x2C,
+0x0F,0x00,0x63,0x38,
+0xA2,0xFF,0x40,0x14,
+0x01,0x00,0x65,0x24,
+0x00,0x16,0x05,0x00,
+0x00,0x24,0x05,0x00,
+0x00,0x1A,0x05,0x00,
+0x25,0x10,0x44,0x00,
+0x25,0x10,0x43,0x00,
+0x25,0x10,0x45,0x00,
+0x25,0x18,0x65,0x00,
+0x18,0x03,0x23,0xAD,
+0xB8,0x2E,0x00,0x08,
+0x14,0x03,0x22,0xAD,
+0x04,0x00,0x02,0x24,
+0x11,0x00,0x62,0x12,
+0xFF,0x00,0x02,0x24,
+0x66,0xFF,0x62,0x16,
+0x00,0x00,0x00,0x00,
+0x1E,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x82,0x02,
+0x21,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x82,0x02,
+0x0A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x7A,0x2D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x8B,0x2E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x1D,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x54,0x00,
+0xF8,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x3B,0x2D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x8B,0x2E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x20,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x82,0x02,
+0xA8,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xFC,0x2D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x8B,0x2E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x1E,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x82,0x02,
+0xE6,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x03,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x54,0x00,
+0x9A,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xFC,0x2D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x8B,0x2E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x08,0x3C,
+0x30,0x1F,0x05,0x25,
+0x80,0x36,0xA4,0x8C,
+0xE6,0x02,0xA3,0x90,
+0x02,0x11,0x04,0x00,
+0x26,0x00,0x60,0x14,
+0x7F,0x00,0x46,0x30,
+0x25,0xB0,0x07,0x3C,
+0x4C,0x00,0xE2,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x02,0x34,
+0x1D,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0xE3,0x34,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x19,0x00,0x40,0x10,
+0x4B,0x00,0xC2,0x2C,
+0x3E,0x00,0x40,0x10,
+0x01,0x00,0x04,0x24,
+0xD8,0xFF,0xC2,0x24,
+0x1E,0x00,0x42,0x2C,
+0x49,0x00,0x40,0x10,
+0x23,0x00,0xC2,0x2C,
+0x30,0x1F,0x04,0x25,
+0xD3,0x02,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0x40,0x10,
+0x23,0x00,0xC2,0x2C,
+0x25,0xB0,0x02,0x3C,
+0x87,0x0C,0x42,0x34,
+0x20,0x00,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0xD3,0x02,0x80,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x17,0x00,0x40,0x10,
+0x01,0x00,0x04,0x24,
+0xD8,0xFF,0xC2,0x24,
+0x1E,0x00,0x42,0x2C,
+0x44,0x00,0x40,0x10,
+0x23,0x00,0xC2,0x2C,
+0x30,0x1F,0x04,0x25,
+0xD3,0x02,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x3F,0x00,0x40,0x10,
+0x23,0x00,0xC2,0x2C,
+0x25,0xB0,0x02,0x3C,
+0x30,0x0C,0x42,0x34,
+0x44,0x00,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0xD3,0x02,0x80,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xD3,0x02,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xE7,0xFF,0x44,0x10,
+0x43,0x00,0x02,0x24,
+0x30,0x0C,0xE3,0x34,
+0xD3,0x02,0xA4,0xA0,
+0x00,0x00,0x62,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xD3,0x02,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xC0,0xFF,0x44,0x10,
+0x10,0x00,0x02,0x24,
+0x87,0x0C,0xE3,0x34,
+0xD3,0x02,0xA4,0xA0,
+0x00,0x00,0x62,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xC7,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x04,0x25,
+0xD3,0x02,0x82,0x90,
+0x02,0x00,0x03,0x24,
+0xC2,0xFF,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x87,0x0C,0x42,0x34,
+0xD3,0x02,0x83,0xA0,
+0x00,0x00,0x40,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xB4,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x04,0x25,
+0xD3,0x02,0x82,0x90,
+0x02,0x00,0x03,0x24,
+0xAF,0xFF,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0xD3,0x02,0x83,0xA0,
+0x30,0x0C,0x42,0x34,
+0x42,0x00,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0x01,0x80,0x02,0x3C,
+0x18,0x03,0x64,0x34,
+0x7C,0xBF,0x42,0x24,
+0x00,0x00,0x82,0xAC,
+0x00,0x60,0x07,0x40,
+0x01,0x00,0xE1,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x20,0x80,0x02,0x3C,
+0x30,0x03,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x25,0xB0,0x06,0x3C,
+0x01,0x80,0x02,0x3C,
+0x7D,0xBF,0x45,0x24,
+0x33,0x03,0xC3,0x34,
+0x00,0x00,0x85,0xAC,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0xFB,0xFF,0x40,0x10,
+0x30,0x03,0xC2,0x34,
+0x00,0x00,0x45,0x8C,
+0x0F,0x00,0x03,0x3C,
+0xFF,0xFF,0x63,0x34,
+0x24,0x28,0xA3,0x00,
+0x40,0x11,0x05,0x00,
+0x23,0x10,0x45,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x45,0x00,
+0xAF,0x0F,0x04,0x3C,
+0xC0,0x10,0x02,0x00,
+0x00,0xA0,0x84,0x34,
+0x1B,0x00,0x82,0x00,
+0x02,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x63,0x24,
+0xC2,0x28,0x05,0x00,
+0xA0,0x3E,0x65,0xAC,
+0x12,0x20,0x00,0x00,
+0xA4,0x3E,0x64,0xAC,
+0x00,0x60,0x87,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x14,0x5F,0x43,0xA0,
+0xD0,0x07,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xE4,0x5E,0x44,0xAC,
+0x13,0x5F,0x60,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x04,0x3C,
+0x28,0x00,0x85,0x34,
+0x02,0x00,0x82,0x94,
+0x04,0x00,0x84,0x24,
+0x05,0x00,0x40,0x14,
+0x2B,0x18,0xA4,0x00,
+0xFB,0xFF,0x60,0x10,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0xBE,0x00,0x63,0x34,
+0x00,0x00,0x62,0x94,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x42,0x2C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x17,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x19,0x00,0x40,0x10,
+0x74,0x57,0x64,0x24,
+0x74,0x57,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x15,0x00,0x44,0x14,
+0x02,0x80,0x02,0x3C,
+0x14,0x5F,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0xFF,0x00,0x63,0x30,
+0x10,0x00,0x62,0x10,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x05,0x00,0x42,0x28,
+0x0A,0x00,0x40,0x10,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x9C,0x5A,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x60,0x14,
+0x21,0x10,0x80,0x00,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x10,0x00,0xBF,0x8F,
+0x21,0x20,0x00,0x00,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x17,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2C,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x74,0x57,0x43,0x8C,
+0x74,0x57,0x42,0x24,
+0x28,0x00,0x62,0x14,
+0x02,0x80,0x03,0x3C,
+0x0C,0x5F,0x62,0x90,
+0x01,0x00,0x04,0x24,
+0xFF,0x00,0x42,0x30,
+0x23,0x00,0x44,0x10,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x03,0x00,0x42,0x28,
+0x1D,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x0E,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x30,
+0x18,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x0E,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x42,0x30,
+0x13,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x14,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x0E,0x00,0x44,0x10,
+0x02,0x80,0x02,0x3C,
+0x15,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x60,0x14,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x6C,0x3B,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x60,0x14,
+0x21,0x18,0x00,0x00,
+0x40,0x39,0x42,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x40,0x14,
+0x01,0x00,0x03,0x24,
+0x21,0x18,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x23,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x0E,0x00,0x40,0x10,
+0x6C,0x57,0x65,0x24,
+0x6C,0x57,0x62,0x8C,
+0x02,0x80,0x04,0x3C,
+0x64,0x57,0x86,0x24,
+0x09,0x00,0x45,0x14,
+0x01,0x00,0x03,0x24,
+0x64,0x57,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x46,0x14,
+0x21,0x10,0x60,0x00,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x10,0x00,0xBF,0x8F,
+0x21,0x18,0x00,0x00,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xFF,0x00,0x84,0x30,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x0E,0x00,0x80,0x10,
+0x02,0x80,0x13,0x3C,
+0x44,0x5F,0x62,0x92,
+0x01,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x39,0x00,0x43,0x10,
+0x25,0xB0,0x03,0x3C,
+0x00,0x60,0x92,0x40,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x44,0x5F,0x62,0x92,
+0x02,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0xF4,0xFF,0x43,0x14,
+0x44,0x08,0x04,0x24,
+0x94,0x60,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0x04,0x0C,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0xFD,0x00,0x42,0x30,
+0x04,0x0C,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x25,0xB0,0x03,0x3C,
+0x04,0x0D,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0xFD,0x00,0x42,0x30,
+0x04,0x0D,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x25,0xB0,0x11,0x3C,
+0x70,0x0E,0x25,0x8E,
+0x7F,0xFE,0x10,0x3C,
+0xFF,0xFF,0x10,0x36,
+0x24,0x28,0xB0,0x00,
+0x94,0x60,0x00,0x0C,
+0x70,0x0E,0x04,0x24,
+0x8C,0x0E,0x25,0x8E,
+0x8C,0x0E,0x04,0x24,
+0x94,0x60,0x00,0x0C,
+0x24,0x28,0xB0,0x00,
+0x01,0x00,0x02,0x24,
+0x44,0x5F,0x62,0xA2,
+0x00,0x60,0x92,0x40,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x04,0x0C,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x02,0x00,0x42,0x34,
+0x04,0x0C,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x25,0xB0,0x03,0x3C,
+0x04,0x0D,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x02,0x00,0x42,0x34,
+0x04,0x0D,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x25,0xB0,0x10,0x3C,
+0x70,0x0E,0x05,0x8E,
+0x80,0x01,0x11,0x3C,
+0x70,0x0E,0x04,0x24,
+0x94,0x60,0x00,0x0C,
+0x25,0x28,0xB1,0x00,
+0x8C,0x0E,0x05,0x8E,
+0x8C,0x0E,0x04,0x24,
+0x94,0x60,0x00,0x0C,
+0x25,0x28,0xB1,0x00,
+0x03,0x00,0x05,0x3C,
+0x59,0x01,0xA5,0x34,
+0x94,0x60,0x00,0x0C,
+0x44,0x08,0x04,0x24,
+0x02,0x00,0x02,0x24,
+0x44,0x5F,0x62,0xA2,
+0xDD,0x30,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0xFC,0x37,0x02,0x24,
+0x40,0x00,0x64,0x34,
+0x00,0x00,0x82,0xA4,
+0x42,0x00,0x65,0x34,
+0x03,0x00,0x02,0x24,
+0x00,0x00,0xA0,0xA0,
+0x03,0x08,0x62,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x0B,0x00,0x60,0x10,
+0x25,0xB0,0x10,0x3C,
+0x02,0x80,0x03,0x3C,
+0xDE,0x5D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x32,0x00,0x40,0x14,
+0x00,0x02,0x05,0x3C,
+0x00,0x08,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x25,0xB0,0x10,0x3C,
+0x21,0x00,0x06,0x36,
+0x00,0x00,0xC2,0x90,
+0x18,0x00,0x03,0x36,
+0x42,0x00,0x05,0x36,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0xC2,0xA0,
+0x40,0x00,0x11,0x36,
+0x00,0x00,0x60,0xA0,
+0xFF,0xFF,0x02,0x24,
+0xFC,0x57,0x03,0x24,
+0x00,0x00,0xA2,0xA0,
+0x64,0x00,0x04,0x24,
+0x00,0x00,0x23,0xA6,
+0x54,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFC,0x77,0x02,0x24,
+0x00,0x00,0x22,0xA6,
+0x54,0x22,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0x03,0x08,0x00,0xA2,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x0A,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x25,0xB0,0x10,0x3C,
+0x40,0x00,0x10,0x36,
+0xFC,0x37,0x02,0x24,
+0x00,0x00,0x02,0xA6,
+0x54,0x22,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0xFC,0x77,0x02,0x24,
+0x00,0x00,0x02,0xA6,
+0x54,0x22,0x00,0x0C,
+0x0A,0x00,0x04,0x24,
+0xFC,0x57,0x02,0x24,
+0x00,0x00,0x02,0xA6,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x9B,0x30,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x2F,0x31,0x00,0x08,
+0x25,0xB0,0x10,0x3C,
+0xC0,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x38,0x00,0xBE,0xAF,
+0x34,0x00,0xB7,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0xFF,0x00,0x90,0x30,
+0xFF,0x00,0xB2,0x30,
+0x21,0xA0,0x00,0x00,
+0x00,0x60,0x16,0x40,
+0x01,0x00,0xC1,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x13,0x3C,
+0xF6,0x5E,0x62,0x92,
+0x0F,0x00,0x11,0x32,
+0x0F,0x00,0x42,0x30,
+0x12,0x00,0x51,0x10,
+0x04,0x00,0x02,0x32,
+0x40,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x62,0x92,
+0x0C,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0x8F,0x00,0x43,0x10,
+0x08,0x00,0x02,0x32,
+0xF6,0x5E,0x62,0x92,
+0x04,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0xD2,0x01,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x62,0x92,
+0x02,0x00,0x03,0x24,
+0x0F,0x00,0x42,0x30,
+0x9B,0x00,0x43,0x10,
+0x06,0x00,0x02,0x32,
+0x02,0x80,0x10,0x3C,
+0xF5,0x5E,0x03,0x92,
+0xF6,0x5E,0x62,0x92,
+0x0F,0x00,0x63,0x30,
+0x0F,0x00,0x42,0x30,
+0x2A,0x10,0x43,0x00,
+0x1C,0x00,0x40,0x14,
+0x02,0x80,0x12,0x3C,
+0xF5,0x5E,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0x17,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xDA,0x5D,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x43,0x30,
+0x52,0x00,0x60,0x14,
+0x04,0x00,0x42,0x30,
+0x10,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x43,0x92,
+0x02,0x80,0x06,0x3C,
+0x5C,0xE9,0xC5,0x90,
+0x0F,0x00,0x63,0x30,
+0x25,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0xDD,0x02,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0xF5,0x5E,0x04,0x92,
+0x80,0xFF,0x02,0x24,
+0xBF,0xFF,0x03,0x24,
+0x26,0x28,0xA2,0x00,
+0x24,0x20,0x83,0x00,
+0x5C,0xE9,0xC5,0xA0,
+0xF5,0x5E,0x04,0xA2,
+0x00,0x60,0x96,0x40,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0xF6,0x5E,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x30,
+0x4C,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x30,
+0x03,0x00,0x40,0x10,
+0x08,0x00,0x02,0x32,
+0x1B,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0xF6,0x5E,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x30,
+0x0C,0x00,0x40,0x14,
+0x08,0x00,0x02,0x32,
+0x0A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x40,0x12,
+0x02,0x80,0x03,0x3C,
+0xE0,0x3A,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x03,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xCD,0x4E,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0xF6,0x5E,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0xF6,0x5E,0x62,0xA2,
+0xF6,0x5E,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x23,0x02,
+0xF6,0x5E,0x63,0xA2,
+0x8E,0x31,0x00,0x08,
+0x02,0x80,0x10,0x3C,
+0xE0,0x3A,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0xF2,0xFF,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x14,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xA2,0xFF,0x60,0x14,
+0x01,0x00,0x04,0x24,
+0xCD,0x4E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xD9,0x31,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0x24,0x00,0x0C,
+0x24,0x00,0x04,0x24,
+0x76,0x01,0x40,0x10,
+0x21,0x88,0x40,0x00,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0x45,0x90,
+0xF6,0x5E,0x44,0x92,
+0xF5,0x5E,0x02,0x92,
+0xBF,0xFF,0x03,0x24,
+0x0F,0x00,0x84,0x30,
+0x24,0x10,0x43,0x00,
+0xF5,0x5E,0x02,0xA2,
+0x10,0x00,0xA5,0xA3,
+0x11,0x00,0xA4,0xA3,
+0x08,0x00,0x24,0x96,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xA5,0x27,
+0x25,0x20,0x82,0x00,
+0x20,0x00,0x84,0x24,
+0x5F,0x1E,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x04,0x00,0x03,0x24,
+0x17,0x00,0x02,0x24,
+0x0C,0x00,0x23,0xAE,
+0x14,0x00,0x22,0xAE,
+0x30,0x09,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0xB0,0x31,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x0C,0x31,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xC2,0x31,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x71,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x28,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x77,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0xF6,0x5E,0x62,0xA2,
+0x02,0x80,0x03,0x3C,
+0xF6,0x5E,0x62,0x92,
+0xE0,0x3A,0x64,0x94,
+0x04,0x00,0x42,0x34,
+0x00,0x01,0x84,0x30,
+0xF6,0x5E,0x62,0xA2,
+0x61,0xFF,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0xCD,0x4E,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x83,0x31,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x65,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x82,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x61,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x41,0xB0,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0xF6,0x5E,0x62,0xA2,
+0xF6,0x5E,0x63,0x92,
+0x08,0x00,0x85,0x34,
+0x82,0x00,0x02,0x24,
+0x01,0x00,0x63,0x34,
+0x02,0x80,0x1E,0x3C,
+0xF6,0x5E,0x63,0xA2,
+0x00,0x00,0x80,0xAC,
+0x00,0x00,0xA2,0xA4,
+0x42,0xB0,0x04,0x3C,
+0x30,0x1F,0xC2,0x27,
+0xB0,0x1B,0x45,0x94,
+0x00,0x00,0x83,0x90,
+0xBE,0xFF,0x02,0x24,
+0x03,0x00,0x86,0x34,
+0x24,0x18,0x62,0x00,
+0x00,0x01,0xA5,0x30,
+0x90,0xFF,0x02,0x24,
+0x00,0x00,0x83,0xA0,
+0x00,0x00,0xC2,0xA0,
+0x38,0x00,0xA0,0x10,
+0x25,0xB0,0x06,0x3C,
+0x25,0xB0,0x04,0x3C,
+0x84,0x00,0x82,0x34,
+0x00,0x00,0x46,0x8C,
+0x80,0x00,0x84,0x34,
+0x00,0x00,0x82,0x8C,
+0x02,0x80,0x0B,0x3C,
+0x1C,0x5F,0x64,0x8D,
+0x00,0x38,0x06,0x00,
+0x21,0x30,0x00,0x00,
+0x25,0xA0,0xC2,0x00,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x0A,0x3C,
+0x25,0xA8,0xE3,0x00,
+0x21,0x28,0x00,0x00,
+0x24,0x5F,0x42,0x8D,
+0x21,0x20,0x94,0x00,
+0x2B,0x18,0x94,0x00,
+0x21,0x28,0xB5,0x00,
+0x21,0x28,0xA3,0x00,
+0x2B,0x10,0xA2,0x00,
+0x24,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x24,0x5F,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x10,0x01,0x45,0x10,
+0x01,0x00,0x05,0x24,
+0x30,0x1F,0xC2,0x27,
+0xA4,0x3E,0x43,0x8C,
+0x42,0xB0,0x07,0x3C,
+0x00,0x00,0xE6,0x90,
+0x18,0x00,0x65,0x00,
+0xFB,0xFF,0x02,0x24,
+0x24,0x30,0xC2,0x00,
+0x00,0x00,0xE6,0xA0,
+0x67,0x46,0x06,0x3C,
+0xCF,0xAC,0xC6,0x34,
+0x01,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x12,0x18,0x00,0x00,
+0x82,0x1A,0x03,0x00,
+0x40,0x10,0x03,0x00,
+0x21,0x10,0x43,0x00,
+0xC0,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x10,0x02,0x00,
+0x19,0x00,0x46,0x00,
+0x10,0x30,0x00,0x00,
+0x23,0x10,0x46,0x00,
+0x42,0x10,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x02,0x33,0x06,0x00,
+0x01,0x00,0x02,0x24,
+0x8C,0x23,0x00,0x0C,
+0x0A,0x30,0x46,0x00,
+0x25,0xB0,0x06,0x3C,
+0xF2,0x02,0xC3,0x34,
+0x88,0xFF,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0x11,0x00,0xC7,0x34,
+0x00,0x00,0xE2,0x90,
+0x08,0x00,0xC5,0x34,
+0x30,0x1F,0xC4,0x27,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0xE2,0xA0,
+0x00,0x00,0xA3,0x94,
+0xB0,0x1B,0x82,0x94,
+0xFF,0xFF,0x64,0x30,
+0x10,0x00,0x84,0x34,
+0x00,0x00,0xA4,0xA4,
+0xFB,0xFF,0x84,0x30,
+0x00,0x00,0xA4,0xA4,
+0x00,0x01,0x42,0x30,
+0x02,0x00,0x84,0x34,
+0x00,0x00,0xA4,0xA4,
+0x04,0x00,0x40,0x10,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0xFF,0xF7,0x84,0x30,
+0x00,0x00,0xA4,0xA4,
+0x28,0x00,0xC4,0x34,
+0x00,0x00,0x83,0x94,
+0xEF,0xFE,0x02,0x24,
+0xFE,0xFF,0x08,0x24,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0x83,0xA4,
+0x00,0x00,0x82,0x94,
+0x26,0x00,0xC5,0x34,
+0x02,0x80,0x03,0x3C,
+0x24,0x10,0x48,0x00,
+0x00,0x00,0x82,0xA4,
+0xDA,0x5D,0x64,0x90,
+0x00,0x00,0xA2,0x94,
+0x04,0x00,0x84,0x30,
+0x00,0x24,0x42,0x34,
+0x00,0x00,0xA2,0xA4,
+0x09,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x48,0x00,
+0x00,0x00,0xA2,0xA4,
+0x00,0x00,0xE3,0x90,
+0xFD,0xFF,0x02,0x24,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0xE3,0xA0,
+0x00,0x68,0x02,0x40,
+0x00,0x08,0x42,0x30,
+0xFD,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x12,0x3C,
+0x11,0x00,0x43,0x36,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA0,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x26,0x00,0x44,0x36,
+0x00,0x00,0x82,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0x82,0xA4,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x83,0x94,
+0xFF,0xDB,0x02,0x24,
+0x28,0x00,0x45,0x36,
+0x24,0x18,0x62,0x00,
+0x00,0x00,0x83,0xA4,
+0x00,0x00,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0xA2,0xA4,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x94,
+0x00,0x00,0x00,0x00,
+0x10,0x01,0x42,0x34,
+0x00,0x00,0xA2,0xA4,
+0x08,0x00,0x51,0x36,
+0x00,0x00,0x23,0x96,
+0x30,0x1F,0xD7,0x27,
+0xB0,0x1B,0xE2,0x96,
+0xFF,0xFF,0x70,0x30,
+0x00,0x18,0x10,0x36,
+0x00,0x00,0x30,0xA6,
+0x00,0x01,0x42,0x30,
+0xFD,0xFF,0x10,0x32,
+0x00,0x00,0x30,0xA6,
+0x05,0x00,0x40,0x10,
+0x42,0xB0,0x02,0x3C,
+0x00,0x00,0x43,0x90,
+0xFB,0xFF,0x04,0x24,
+0x24,0x18,0x64,0x00,
+0x00,0x00,0x43,0xA0,
+0x04,0x00,0x10,0x36,
+0x54,0x22,0x00,0x0C,
+0x32,0x00,0x04,0x24,
+0x00,0x00,0x30,0xA6,
+0x22,0x00,0x02,0x24,
+0xF2,0x02,0x43,0x36,
+0xEF,0xFF,0x10,0x32,
+0x00,0x00,0x30,0xA6,
+0xC8,0x00,0x04,0x24,
+0x00,0x00,0x62,0xA0,
+0x54,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0xE2,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x41,0x00,0x40,0x10,
+0x42,0xB0,0x06,0x3C,
+0x84,0x00,0x42,0x36,
+0x00,0x00,0x44,0x8C,
+0x80,0x00,0x46,0x36,
+0x00,0x00,0xC2,0x8C,
+0x00,0x28,0x04,0x00,
+0x21,0x18,0x00,0x00,
+0x21,0x20,0x00,0x00,
+0x25,0x30,0x82,0x00,
+0x25,0x38,0xA3,0x00,
+0xA4,0x3E,0xE3,0x8E,
+0x23,0x28,0xD4,0x00,
+0x80,0x12,0x05,0x00,
+0x1B,0x00,0x43,0x00,
+0x02,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x02,0x80,0x0B,0x3C,
+0x1C,0x5F,0x63,0x8D,
+0x12,0x10,0x00,0x00,
+0x23,0x10,0x45,0x00,
+0x21,0x10,0x43,0x00,
+0x1C,0x5F,0x62,0xAD,
+0x1C,0x5F,0x63,0x8D,
+0x42,0xB0,0x02,0x3C,
+0x03,0x00,0x42,0x34,
+0xC4,0x09,0x63,0x24,
+0x1C,0x5F,0x63,0xAD,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x63,0x30,
+0x20,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x5F,0x62,0x8D,
+0x02,0x80,0x0A,0x3C,
+0x24,0x5F,0x44,0x8D,
+0x21,0x40,0x46,0x00,
+0x2B,0x28,0x06,0x01,
+0x21,0x48,0x67,0x00,
+0x21,0x48,0x25,0x01,
+0x2B,0x20,0x24,0x01,
+0x59,0x00,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x24,0x5F,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x47,0x00,0x49,0x10,
+0x01,0x00,0x05,0x24,
+0x42,0xB0,0x02,0x3C,
+0x00,0x00,0x43,0x90,
+0xFB,0xFF,0x04,0x24,
+0x01,0x00,0x06,0x24,
+0x24,0x18,0x64,0x00,
+0x00,0x00,0x43,0xA0,
+0x04,0x00,0xA0,0x10,
+0x01,0x00,0x04,0x24,
+0x80,0x10,0x05,0x00,
+0x21,0x10,0x45,0x00,
+0x80,0x30,0x02,0x00,
+0x8C,0x23,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x42,0xB0,0x06,0x3C,
+0x00,0x00,0xC2,0x90,
+0x30,0x1F,0xC5,0x27,
+0xD0,0x1B,0xA8,0x8C,
+0xDC,0x1B,0xA7,0x94,
+0x41,0xB0,0x03,0x3C,
+0x41,0x00,0x42,0x34,
+0x08,0x00,0x64,0x34,
+0x00,0x00,0xC2,0xA0,
+0x00,0x00,0x68,0xAC,
+0x00,0x00,0x87,0xA4,
+0xF6,0x5E,0x63,0x92,
+0xF0,0xFF,0x02,0x24,
+0xDC,0x1B,0xA7,0xA4,
+0x24,0x18,0x62,0x00,
+0xF6,0x5E,0x63,0xA2,
+0xF6,0x5E,0x62,0x92,
+0xD0,0x1B,0xA8,0xAC,
+0x02,0x00,0x42,0x34,
+0xF6,0x5E,0x62,0xA2,
+0x8E,0x31,0x00,0x08,
+0x02,0x80,0x10,0x3C,
+0x4C,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x31,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x1C,0x31,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF6,0x5E,0x62,0x92,
+0xF0,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0xF6,0x5E,0x62,0xA2,
+0xF6,0x5E,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x63,0x34,
+0xF6,0x5E,0x63,0xA2,
+0x88,0x31,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x99,0x99,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x97,0x99,0x63,0x34,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0xB0,0x31,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x20,0x5F,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x82,0x00,
+0x0C,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x20,0x5F,0x42,0x8D,
+0x61,0x32,0x00,0x08,
+0x01,0x00,0x05,0x24,
+0x20,0x5F,0x42,0x8D,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x02,0x01,
+0x0A,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x20,0x5F,0x42,0x8D,
+0x32,0x33,0x00,0x08,
+0x01,0x00,0x05,0x24,
+0x20,0x5F,0x42,0x8D,
+0x24,0x5F,0x43,0x8D,
+0x1C,0x5F,0x64,0x8D,
+0x23,0x10,0x54,0x00,
+0x61,0x32,0x00,0x08,
+0x23,0x28,0x44,0x00,
+0x20,0x5F,0x42,0x8D,
+0x24,0x5F,0x43,0x8D,
+0x1C,0x5F,0x64,0x8D,
+0x23,0x10,0x46,0x00,
+0x32,0x33,0x00,0x08,
+0x23,0x28,0x44,0x00,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0xF6,0x5E,0x43,0x90,
+0x04,0x00,0x04,0x24,
+0x0F,0x00,0x63,0x30,
+0x04,0x00,0x63,0x28,
+0x03,0x00,0x60,0x14,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x64,0x31,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x6C,0xCE,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x14,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x00,0x60,0x10,0x40,
+0x01,0x00,0x01,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x04,0x3C,
+0x13,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x0B,0x00,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0xD0,0x07,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0xE4,0x5E,0x43,0xAC,
+0x13,0x5F,0x80,0xA0,
+0x00,0x60,0x90,0x40,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x16,0x5F,0x44,0xA0,
+0x14,0x5F,0x60,0xA0,
+0x02,0x80,0x02,0x3C,
+0xF5,0x5E,0x44,0x90,
+0x64,0x31,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x00,0x60,0x90,0x40,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x42,0x11,0x05,0x00,
+0x0F,0x00,0x46,0x30,
+0xE8,0xFF,0xBD,0x27,
+0x09,0x00,0xC3,0x28,
+0x14,0x00,0xBF,0xAF,
+0x15,0x00,0x60,0x10,
+0x10,0x00,0xB0,0xAF,
+0x82,0x16,0x05,0x00,
+0x01,0x00,0x42,0x30,
+0x15,0x00,0x40,0x10,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0xA2,0x00,
+0x48,0x00,0x40,0x14,
+0xC2,0x15,0x04,0x00,
+0x01,0x00,0x42,0x30,
+0x55,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x50,0xE9,0x63,0x24,
+0x21,0x18,0xC3,0x00,
+0x02,0x80,0x04,0x3C,
+0x0F,0x5F,0x85,0x90,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x45,0x00,
+0x4B,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x24,0x10,0xA2,0x00,
+0x20,0x00,0x40,0x14,
+0xC2,0x15,0x04,0x00,
+0x01,0x00,0x42,0x30,
+0x0B,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x03,0x3C,
+0x50,0xE9,0x63,0x24,
+0x21,0x18,0xC3,0x00,
+0x02,0x80,0x04,0x3C,
+0x0F,0x5F,0x85,0x90,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x45,0x00,
+0x3C,0x00,0x40,0x14,
+0x02,0x80,0x04,0x3C,
+0x0E,0x5F,0x82,0x90,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x0E,0x5F,0x82,0xA0,
+0x0E,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x42,0x30,
+0xE4,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x0C,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x64,0x90,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0x64,0x31,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x0E,0x5F,0x82,0x90,
+0xFD,0xFF,0x03,0x24,
+0x14,0x00,0xBF,0x8F,
+0x24,0x10,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x0E,0x5F,0x82,0xA0,
+0x12,0x5F,0x60,0xA0,
+0x42,0xB0,0x04,0x3C,
+0x00,0x00,0x82,0x90,
+0x10,0x00,0xB0,0x8F,
+0xEF,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x03,0x00,0x85,0x34,
+0x40,0x00,0x03,0x24,
+0x18,0x00,0xBD,0x27,
+0x00,0x00,0x82,0xA0,
+0x00,0x00,0xA3,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x42,0xB0,0x07,0x3C,
+0x00,0x00,0xE3,0x90,
+0xEF,0xFF,0x02,0x24,
+0x03,0x00,0xF0,0x34,
+0x24,0x18,0x62,0x00,
+0x40,0x00,0x02,0x24,
+0x00,0x00,0xE3,0xA0,
+0x02,0x00,0x04,0x24,
+0x00,0x00,0x02,0xA2,
+0x21,0x28,0x00,0x00,
+0x8C,0x23,0x00,0x0C,
+0x00,0xF0,0x06,0x34,
+0x44,0x00,0x02,0x24,
+0x00,0x00,0x02,0xA2,
+0xE0,0x33,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x04,0x24,
+0xFE,0x4E,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x0E,0x5F,0x82,0x90,
+0xF6,0x33,0x00,0x08,
+0xFB,0xFF,0x03,0x24,
+0x82,0x16,0x05,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x01,0x00,0x42,0x30,
+0x14,0x00,0xBF,0xAF,
+0x0E,0x00,0x40,0x10,
+0x10,0x00,0xB0,0xAF,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0xA2,0x00,
+0x37,0x00,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x0D,0x5F,0x43,0x90,
+0x02,0x00,0x02,0x24,
+0xFF,0x00,0x63,0x30,
+0x44,0x00,0x62,0x10,
+0x01,0x00,0x04,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFE,0x4E,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x00,0xC0,0x02,0x3C,
+0x24,0x10,0xA2,0x00,
+0x0E,0x00,0x40,0x14,
+0x02,0x80,0x06,0x3C,
+0x0E,0x5F,0xC2,0x90,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x0E,0x5F,0xC2,0xA0,
+0x0E,0x5F,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x42,0x30,
+0x18,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x0E,0x5F,0xC2,0x90,
+0xFD,0xFF,0x03,0x24,
+0x42,0xB0,0x04,0x3C,
+0x24,0x10,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x0E,0x5F,0xC2,0xA0,
+0x12,0x5F,0x60,0xA0,
+0x00,0x00,0x82,0x90,
+0xEF,0xFF,0x03,0x24,
+0x03,0x00,0x85,0x34,
+0x24,0x10,0x43,0x00,
+0x40,0x00,0x03,0x24,
+0x00,0x00,0x82,0xA0,
+0x00,0x00,0xA3,0xA0,
+0x0E,0x5F,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x42,0x30,
+0xEA,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0x0C,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x64,0x90,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0x64,0x31,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x42,0xB0,0x07,0x3C,
+0x00,0x00,0xE3,0x90,
+0xEF,0xFF,0x02,0x24,
+0x03,0x00,0xF0,0x34,
+0x24,0x18,0x62,0x00,
+0x40,0x00,0x02,0x24,
+0x00,0x00,0xE3,0xA0,
+0x02,0x00,0x04,0x24,
+0x00,0x00,0x02,0xA2,
+0x21,0x28,0x00,0x00,
+0x8C,0x23,0x00,0x0C,
+0x00,0xF0,0x06,0x34,
+0x44,0x00,0x02,0x24,
+0x00,0x00,0x02,0xA2,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x0D,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x0C,0x00,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x64,0x31,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x30,0xD2,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x02,0x80,0x10,0x3C,
+0xF5,0x5E,0x02,0x92,
+0x14,0x00,0xBF,0xAF,
+0x0F,0x00,0x42,0x30,
+0x03,0x00,0x42,0x28,
+0x05,0x00,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0x4C,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x40,0x10,
+0x01,0x00,0x05,0x24,
+0xF5,0x5E,0x04,0x92,
+0x64,0x31,0x00,0x0C,
+0xFF,0x00,0x84,0x30,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x84,0x24,
+0xE0,0x1B,0x83,0x94,
+0xDC,0x1B,0x85,0x94,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x00,0x63,0x30,
+0x41,0xB0,0x02,0x3C,
+0x25,0x18,0x65,0x00,
+0x08,0x00,0x42,0x34,
+0x18,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA4,
+0x08,0x00,0xE0,0x03,
+0xDC,0x1B,0x83,0xA4,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x02,0x80,0x10,0x3C,
+0x08,0x14,0x04,0x26,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x91,0x3C,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0xB4,0x34,0x00,0x08,
+0x08,0x14,0x04,0x26,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0xCF,0x61,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xFF,0xFF,0x8D,0x30,
+0x00,0x60,0x0F,0x40,
+0x01,0x00,0xE1,0x35,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x06,0x3C,
+0x30,0x1F,0xCE,0x24,
+0x2A,0x1C,0xC2,0x91,
+0x00,0x00,0x00,0x00,
+0x1D,0x00,0x40,0x10,
+0x25,0xB0,0x03,0x3C,
+0x38,0x02,0x64,0x34,
+0x80,0xFF,0x02,0x24,
+0x00,0x00,0x82,0xA0,
+0x34,0x02,0x6A,0x34,
+0xD2,0x01,0x65,0x34,
+0xD6,0x01,0x66,0x34,
+0xDA,0x01,0x67,0x34,
+0xDE,0x01,0x63,0x34,
+0x00,0x00,0xA8,0x94,
+0x00,0x00,0xC9,0x94,
+0x00,0x00,0xEB,0x94,
+0x00,0x00,0x6C,0x94,
+0x00,0x00,0x44,0x95,
+0xB0,0xFE,0xA2,0x25,
+0xFF,0xFF,0x4D,0x30,
+0x28,0x1C,0xC4,0xA5,
+0x00,0x00,0xA0,0xA4,
+0x20,0x1C,0xC8,0xA5,
+0x00,0x00,0xC0,0xA4,
+0x22,0x1C,0xC9,0xA5,
+0x00,0x00,0xE0,0xA4,
+0x24,0x1C,0xCB,0xA5,
+0x00,0x00,0x60,0xA4,
+0x00,0x00,0x4D,0xA5,
+0x26,0x1C,0xCC,0xA5,
+0x00,0x60,0x8F,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x02,0x3C,
+0x0A,0x00,0x45,0x34,
+0x63,0x00,0x03,0x24,
+0xFF,0xFF,0x04,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x40,0x10,
+0x30,0x1F,0xC2,0x24,
+0x64,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x42,0x30,
+0xFE,0xFF,0x40,0x14,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x62,0x24,
+0xFF,0xFF,0x43,0x30,
+0xF4,0xFF,0x64,0x14,
+0x30,0x1F,0xC2,0x24,
+0x28,0x1C,0x48,0x94,
+0x26,0x1C,0x47,0x94,
+0x20,0x1C,0x49,0x94,
+0x22,0x1C,0x4A,0x94,
+0x24,0x1C,0x4B,0x94,
+0x25,0xB0,0x03,0x3C,
+0x38,0x02,0x6C,0x34,
+0x34,0x02,0x62,0x34,
+0xD2,0x01,0x64,0x34,
+0xD6,0x01,0x65,0x34,
+0xDA,0x01,0x66,0x34,
+0xDE,0x01,0x63,0x34,
+0x00,0x00,0x48,0xA4,
+0x00,0x00,0x89,0xA4,
+0x00,0x00,0xAA,0xA4,
+0x00,0x00,0xCB,0xA4,
+0x00,0x00,0x67,0xA4,
+0x00,0x00,0x80,0xA1,
+0x00,0x60,0x8F,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD0,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xFF,0xFF,0x14,0x24,
+0x02,0x80,0x13,0x3C,
+0x41,0xB0,0x02,0x3C,
+0x30,0x1F,0x63,0x26,
+0x04,0x00,0x42,0x34,
+0x00,0x00,0x45,0x8C,
+0xD4,0x1B,0x64,0x8C,
+0xD0,0x1B,0x66,0x8C,
+0x02,0x80,0x02,0x3C,
+0x08,0x5E,0x47,0x90,
+0x25,0xB0,0x08,0x3C,
+0xB0,0x03,0x02,0x35,
+0x25,0x90,0x85,0x00,
+0x00,0x00,0x52,0xAC,
+0x00,0x00,0x46,0xAC,
+0x01,0x00,0x02,0x24,
+0x8D,0x03,0xE2,0x10,
+0xD4,0x1B,0x72,0xAC,
+0x30,0x1F,0x64,0x26,
+0xD0,0x1B,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x52,0x00,
+0x01,0x00,0x42,0x30,
+0x0E,0x00,0x40,0x10,
+0x30,0x1F,0x67,0x26,
+0x25,0xB0,0x10,0x3C,
+0xB0,0x03,0x02,0x36,
+0x01,0x00,0x05,0x24,
+0x00,0x00,0x45,0xAC,
+0x04,0x00,0x0B,0x36,
+0xD4,0x1B,0x83,0x8C,
+0x00,0x00,0x69,0x8D,
+0x40,0x00,0x02,0x3C,
+0x01,0x00,0x63,0x38,
+0x24,0x10,0x22,0x01,
+0x2A,0x01,0x40,0x10,
+0xD4,0x1B,0x83,0xAC,
+0x30,0x1F,0x67,0x26,
+0xD0,0x1B,0xE8,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x12,0x01,
+0x04,0x00,0x42,0x30,
+0x18,0x00,0x40,0x10,
+0x30,0x1F,0x71,0x26,
+0x25,0xB0,0x03,0x3C,
+0xB0,0x03,0x64,0x34,
+0x04,0x00,0x02,0x24,
+0x00,0x00,0x82,0xAC,
+0xD4,0x1B,0xE2,0x8C,
+0xFC,0x00,0x63,0x34,
+0xAC,0x1B,0xE5,0x94,
+0xD0,0x37,0xE4,0x8C,
+0x00,0x00,0x66,0x8C,
+0x04,0x00,0x42,0x38,
+0x21,0x48,0x85,0x00,
+0x0A,0x00,0xC9,0x10,
+0xD4,0x1B,0xE2,0xAC,
+0x02,0x80,0x05,0x3C,
+0xBC,0x5E,0xA2,0x8C,
+0xFB,0xFF,0x04,0x24,
+0x24,0x20,0x04,0x01,
+0x00,0x10,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0xBC,0x5E,0xA2,0xAC,
+0x00,0x00,0x64,0xAC,
+0xD0,0x1B,0xE4,0xAC,
+0x30,0x1F,0x71,0x26,
+0xD0,0x1B,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x52,0x00,
+0x08,0x00,0x42,0x30,
+0x0A,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x22,0x96,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x30,
+0x5D,0x03,0x40,0x14,
+0x00,0x80,0x02,0x3C,
+0xD4,0x1B,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x38,
+0xD4,0x1B,0x22,0xAE,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x20,0x52,0x00,
+0x00,0x08,0x83,0x30,
+0x06,0x00,0x60,0x10,
+0x00,0x10,0x82,0x30,
+0xD4,0x1B,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x42,0x38,
+0xD4,0x1B,0x02,0xAE,
+0x00,0x10,0x82,0x30,
+0x05,0x03,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x72,0x00,
+0x00,0x20,0x42,0x30,
+0xF7,0x02,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x72,0x00,
+0x00,0x80,0x42,0x30,
+0xB9,0x01,0x40,0x14,
+0x01,0x00,0x03,0x3C,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0xF1,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xD0,0x1B,0x02,0x8E,
+0x02,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x28,0x02,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x04,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x62,0x02,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x08,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x9B,0x02,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x10,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x5A,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x20,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x18,0x01,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x40,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0xD6,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x65,0x26,
+0xD0,0x1B,0xA2,0x8C,
+0x00,0x04,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x3D,0x00,0x40,0x10,
+0x30,0x1F,0x66,0x26,
+0x2A,0xB0,0x02,0x3C,
+0x2C,0x00,0x43,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x02,0x24,
+0xFF,0x00,0x24,0x31,
+0x29,0x03,0x82,0x10,
+0x00,0x80,0x22,0x31,
+0xF9,0x02,0x40,0x14,
+0x00,0x80,0x02,0x3C,
+0x00,0xFF,0x02,0x3C,
+0x24,0x10,0x22,0x01,
+0x0B,0x00,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0xB8,0x36,0xA2,0x90,
+0x20,0xB0,0x03,0x3C,
+0x00,0x12,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x0C,0x00,0x49,0x8C,
+0x25,0xB0,0x03,0x3C,
+0xB0,0x03,0x63,0x34,
+0x00,0x00,0x69,0xAC,
+0xFF,0x00,0x24,0x31,
+0xFF,0x00,0x02,0x24,
+0x1B,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x88,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x1C,0x37,0x03,0xAE,
+0x0A,0x00,0x04,0x24,
+0xB8,0x36,0x09,0xA2,
+0x00,0x01,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xD0,0x1B,0x05,0x8E,
+0x02,0x80,0x06,0x3C,
+0xBC,0x5E,0xC4,0x8C,
+0x00,0x04,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x28,0xA2,0x00,
+0x25,0xB0,0x02,0x3C,
+0x00,0x40,0x84,0x34,
+0xB0,0x03,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0xAC,
+0x00,0x00,0x65,0xAC,
+0xBC,0x5E,0xC4,0xAC,
+0xD0,0x1B,0x05,0xAE,
+0x30,0x1F,0x65,0x26,
+0xD4,0x1B,0xA4,0x8C,
+0x00,0x04,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x26,0x20,0x83,0x00,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x44,0xAC,
+0xD4,0x1B,0xA4,0xAC,
+0x30,0x1F,0x66,0x26,
+0xD0,0x1B,0xC7,0x8C,
+0x00,0x08,0x04,0x3C,
+0x24,0x28,0xF2,0x00,
+0x24,0x10,0xA4,0x00,
+0x08,0x00,0x40,0x10,
+0x80,0x00,0x08,0x3C,
+0xD4,0x1B,0xC3,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0x26,0x18,0x64,0x00,
+0x00,0x00,0x44,0xAC,
+0xD4,0x1B,0xC3,0xAC,
+0x80,0x00,0x08,0x3C,
+0x24,0x10,0xA8,0x00,
+0x21,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xD4,0x1B,0xC3,0x8C,
+0x25,0xB0,0x09,0x3C,
+0xB0,0x03,0x2A,0x35,
+0x2A,0xB0,0x02,0x3C,
+0x00,0x00,0x43,0xAD,
+0x36,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x23,0xB0,0x04,0x3C,
+0xFF,0x1F,0x02,0x3C,
+0xC0,0x18,0x03,0x00,
+0xF0,0x07,0x63,0x30,
+0x00,0x38,0xC5,0x8C,
+0x21,0x18,0x64,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0xCE,0x02,0x65,0x10,
+0x04,0x38,0xC3,0xAC,
+0x02,0x80,0x05,0x3C,
+0xBC,0x5E,0xA3,0x8C,
+0x27,0x20,0x08,0x00,
+0x24,0x20,0xE4,0x00,
+0x00,0x08,0x63,0x34,
+0x41,0xB0,0x02,0x3C,
+0x00,0x00,0x43,0xAD,
+0x00,0x00,0x44,0xAC,
+0xBC,0x5E,0xA3,0xAC,
+0xD0,0x1B,0xC4,0xAC,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x80,0x00,0x04,0x3C,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0x30,0x1F,0x66,0x26,
+0xD0,0x1B,0xC3,0x8C,
+0x00,0x01,0x05,0x3C,
+0x24,0x20,0x72,0x00,
+0x24,0x10,0x85,0x00,
+0x06,0x00,0x40,0x10,
+0x25,0xB0,0x02,0x3C,
+0xD4,0x1B,0xC3,0x8C,
+0xB0,0x03,0x42,0x34,
+0x26,0x18,0x65,0x00,
+0x00,0x00,0x45,0xAC,
+0xD4,0x1B,0xC3,0xAC,
+0x00,0x02,0x05,0x3C,
+0x24,0x10,0x85,0x00,
+0x06,0x00,0x40,0x10,
+0x25,0xB0,0x02,0x3C,
+0xD4,0x1B,0xC3,0x8C,
+0xB0,0x03,0x42,0x34,
+0x26,0x18,0x65,0x00,
+0x00,0x00,0x45,0xAC,
+0xD4,0x1B,0xC3,0xAC,
+0x00,0x10,0x05,0x3C,
+0x24,0x10,0x85,0x00,
+0x0C,0x00,0x40,0x10,
+0x30,0x1F,0x63,0x26,
+0xB0,0x1B,0xC3,0x94,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x62,0x30,
+0x02,0x00,0x40,0x10,
+0x00,0x08,0x62,0x34,
+0xB0,0x1B,0xC2,0xA4,
+0xD4,0x1B,0xC2,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x45,0x00,
+0xD4,0x1B,0xC2,0xAC,
+0x30,0x1F,0x63,0x26,
+0xD0,0x1B,0x62,0x8C,
+0x00,0x20,0x05,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x45,0x00,
+0x0B,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x64,0x94,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x82,0x30,
+0x02,0x00,0x40,0x10,
+0xFF,0xF7,0x82,0x30,
+0xB0,0x1B,0x62,0xA4,
+0xD4,0x1B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x45,0x00,
+0xD4,0x1B,0x62,0xAC,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x20,0xBD,0x02,0x3C,
+0xEC,0x02,0x03,0x36,
+0x4D,0x00,0x07,0x36,
+0xF1,0x02,0x08,0x36,
+0x08,0x00,0x06,0x24,
+0x78,0x02,0x42,0x34,
+0x00,0x00,0x45,0xA4,
+0x00,0x00,0xE0,0xA0,
+0x00,0x00,0x06,0xA1,
+0x00,0x00,0x60,0xAC,
+0x00,0x00,0x62,0x8C,
+0xFF,0x00,0x04,0x3C,
+0x00,0x00,0xE0,0xA0,
+0xFF,0x00,0x49,0x30,
+0x25,0x48,0x24,0x01,
+0x00,0x00,0x06,0xA1,
+0xF2,0x02,0x05,0x36,
+0x00,0x00,0x64,0xAC,
+0x0A,0x00,0x0A,0x36,
+0x00,0x00,0x69,0xAC,
+0x80,0xFF,0x03,0x24,
+0x00,0x00,0xA0,0xA0,
+0x00,0x00,0x43,0xA1,
+0x00,0x00,0x62,0x8D,
+0x80,0x00,0x03,0x3C,
+0x24,0x10,0x43,0x00,
+0x02,0x00,0x40,0x10,
+0x84,0xFF,0x02,0x24,
+0x00,0x00,0x42,0xA1,
+0x25,0x22,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x02,0x00,0x02,0x36,
+0x00,0x00,0x43,0x94,
+0xFF,0xBF,0x04,0x24,
+0x24,0x18,0x64,0x00,
+0x00,0x00,0x43,0xA4,
+0x3C,0x35,0x00,0x08,
+0x30,0x1F,0x67,0x26,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x2A,0xB0,0x06,0x3C,
+0xB0,0x03,0x42,0x34,
+0x00,0x00,0x54,0xAC,
+0x28,0x00,0xC3,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x05,0x24,
+0xFF,0x00,0x24,0x31,
+0x6D,0x03,0x85,0x10,
+0x25,0xBD,0x02,0x3C,
+0x00,0x80,0x22,0x31,
+0x59,0x02,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x62,0xAC,
+0xFF,0x00,0x02,0x24,
+0x21,0x00,0x82,0x10,
+0xFF,0x00,0x23,0x31,
+0x30,0x1F,0x70,0x26,
+0x58,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xA4,0x36,0x09,0xA2,
+0xEC,0x36,0x03,0xAE,
+0x06,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x09,0x3C,
+0xCC,0x5E,0x27,0x91,
+0x02,0x80,0x08,0x3C,
+0xBC,0x5E,0x05,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x60,0x00,0x02,0x3C,
+0x02,0x00,0xE7,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x04,0xA5,0x34,
+0x00,0x26,0x07,0x00,
+0x25,0xB0,0x02,0x3C,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0xAC,
+0x00,0x00,0x66,0xAC,
+0xBC,0x5E,0x05,0xAD,
+0xCC,0x5E,0x27,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x40,0x00,0x04,0x3C,
+0x26,0x18,0x64,0x00,
+0xB5,0x35,0x00,0x08,
+0xD4,0x1B,0x43,0xAC,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x24,0x00,0xA3,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x24,0x31,
+0x48,0x03,0x86,0x10,
+0x25,0xB0,0x02,0x3C,
+0x00,0x80,0x22,0x31,
+0x64,0x02,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x62,0xAC,
+0xFF,0x00,0x02,0x24,
+0x25,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x58,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xA0,0x36,0x09,0xA2,
+0xEC,0x36,0x03,0xAE,
+0x06,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x0A,0x3C,
+0xCC,0x5E,0x47,0x91,
+0x02,0x80,0x09,0x3C,
+0xBC,0x5E,0x25,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x60,0x00,0x02,0x3C,
+0x04,0x00,0xE7,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x04,0xA5,0x34,
+0x25,0xB0,0x03,0x3C,
+0x40,0x00,0x02,0x3C,
+0x00,0x26,0x07,0x00,
+0x26,0xA0,0x82,0x02,
+0xB0,0x03,0x68,0x34,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x63,0x34,
+0x41,0xB0,0x02,0x3C,
+0x00,0x00,0x64,0xAC,
+0x00,0x00,0x46,0xAC,
+0xBC,0x5E,0x25,0xAD,
+0xCC,0x5E,0x47,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x00,0x00,0x14,0xAD,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x20,0x00,0x04,0x3C,
+0x26,0x18,0x64,0x00,
+0xAD,0x35,0x00,0x08,
+0xD4,0x1B,0x43,0xAC,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x05,0x3C,
+0xB0,0x03,0xA2,0x34,
+0x2A,0xB0,0x07,0x3C,
+0x00,0x00,0x54,0xAC,
+0x20,0x00,0xE3,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x24,0x31,
+0x07,0x03,0x86,0x10,
+0x90,0x03,0xA2,0x34,
+0x00,0x80,0x22,0x31,
+0x05,0x02,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x62,0xAC,
+0xFF,0x00,0x02,0x24,
+0x21,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x4C,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0xA8,0x36,0x09,0xA2,
+0xE0,0x36,0x03,0xAE,
+0x05,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x09,0x3C,
+0xCC,0x5E,0x27,0x91,
+0x02,0x80,0x08,0x3C,
+0xBC,0x5E,0x05,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x18,0x00,0x02,0x3C,
+0x01,0x00,0xE7,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x02,0xA5,0x34,
+0x00,0x26,0x07,0x00,
+0x25,0xB0,0x02,0x3C,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0xAC,
+0x00,0x00,0x66,0xAC,
+0xBC,0x5E,0x05,0xAD,
+0xCC,0x5E,0x27,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x10,0x00,0x04,0x3C,
+0x26,0x18,0x64,0x00,
+0xA6,0x35,0x00,0x08,
+0xD4,0x1B,0x43,0xAC,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x0C,0x00,0xA3,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x24,0x31,
+0xC6,0x02,0x86,0x10,
+0x00,0x80,0x22,0x31,
+0x54,0x02,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x62,0xAC,
+0xFF,0x00,0x02,0x24,
+0x24,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x34,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x8C,0x36,0x09,0xA2,
+0xC8,0x36,0x03,0xAE,
+0x03,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x0A,0x3C,
+0xCC,0x5E,0x47,0x91,
+0x02,0x80,0x09,0x3C,
+0xBC,0x5E,0x25,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x01,0x00,0x08,0x3C,
+0x80,0xFF,0x02,0x24,
+0x25,0x38,0xE2,0x00,
+0x00,0x80,0x03,0x35,
+0x80,0x00,0xA5,0x34,
+0x27,0x18,0x03,0x00,
+0x00,0x26,0x07,0x00,
+0x25,0xB0,0x02,0x3C,
+0x24,0x30,0xC3,0x00,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0xAC,
+0x27,0xA0,0x08,0x00,
+0x00,0x00,0x66,0xAC,
+0xBC,0x5E,0x25,0xAD,
+0xCC,0x5E,0x47,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x30,0x1F,0x63,0x26,
+0xD4,0x1B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x42,0x38,
+0xD4,0x1B,0x62,0xAC,
+0x30,0x1F,0x70,0x26,
+0xD0,0x1B,0x02,0x8E,
+0x01,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0x11,0xFE,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x10,0x00,0xA3,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x24,0x31,
+0x7C,0x02,0x86,0x10,
+0x25,0xB0,0x02,0x3C,
+0x00,0x80,0x22,0x31,
+0xD0,0x01,0x40,0x10,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x62,0xAC,
+0xFF,0x00,0x02,0x24,
+0x22,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x34,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x90,0x36,0x09,0xA2,
+0xC8,0x36,0x03,0xAE,
+0x03,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x09,0x3C,
+0xCC,0x5E,0x27,0x91,
+0x02,0x80,0x08,0x3C,
+0xBC,0x5E,0x05,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x01,0x00,0x02,0x3C,
+0x00,0x80,0x42,0x34,
+0x40,0x00,0xE7,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x30,0xC2,0x00,
+0x80,0x00,0xA5,0x34,
+0x00,0x26,0x07,0x00,
+0x25,0xB0,0x02,0x3C,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0xAC,
+0x00,0x00,0x66,0xAC,
+0xBC,0x5E,0x05,0xAD,
+0xCC,0x5E,0x27,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x01,0x00,0x04,0x3C,
+0x30,0x1F,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x02,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0xDB,0xFD,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x14,0x00,0xA3,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x24,0x31,
+0x64,0x02,0x86,0x10,
+0x25,0xB0,0x02,0x3C,
+0x00,0x80,0x22,0x31,
+0xFA,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x62,0xAC,
+0xFF,0x00,0x02,0x24,
+0x25,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x40,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x94,0x36,0x09,0xA2,
+0xD4,0x36,0x03,0xAE,
+0x04,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x0A,0x3C,
+0xCC,0x5E,0x47,0x91,
+0x02,0x80,0x09,0x3C,
+0xBC,0x5E,0x25,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x06,0x00,0x02,0x3C,
+0x20,0x00,0xE7,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x01,0xA5,0x34,
+0x25,0xB0,0x03,0x3C,
+0x04,0x00,0x02,0x3C,
+0x00,0x26,0x07,0x00,
+0x26,0xA0,0x82,0x02,
+0xB0,0x03,0x68,0x34,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x63,0x34,
+0x41,0xB0,0x02,0x3C,
+0x00,0x00,0x64,0xAC,
+0x00,0x00,0x46,0xAC,
+0xBC,0x5E,0x25,0xAD,
+0xCC,0x5E,0x47,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x00,0x00,0x14,0xAD,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x02,0x00,0x04,0x3C,
+0x30,0x1F,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x04,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x54,0x00,
+0x24,0x10,0x43,0x00,
+0xA1,0xFD,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0xB0,0x03,0x62,0x34,
+0x2A,0xB0,0x07,0x3C,
+0x00,0x00,0x54,0xAC,
+0x18,0x00,0xE5,0x34,
+0x00,0x00,0xA9,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x24,0x31,
+0x16,0x02,0x86,0x10,
+0x04,0x00,0x02,0x24,
+0x00,0x80,0x22,0x31,
+0xD6,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0xA2,0xAC,
+0xFF,0x00,0x02,0x24,
+0x21,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x40,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x98,0x36,0x09,0xA2,
+0xD4,0x36,0x03,0xAE,
+0x04,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x09,0x3C,
+0xCC,0x5E,0x27,0x91,
+0x02,0x80,0x08,0x3C,
+0xBC,0x5E,0x05,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x06,0x00,0x02,0x3C,
+0x10,0x00,0xE7,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x01,0xA5,0x34,
+0x00,0x26,0x07,0x00,
+0x25,0xB0,0x02,0x3C,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0xAC,
+0x00,0x00,0x66,0xAC,
+0xBC,0x5E,0x05,0xAD,
+0xCC,0x5E,0x27,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x04,0x00,0x04,0x3C,
+0x30,0x1F,0x70,0x26,
+0x26,0x18,0x64,0x00,
+0xD4,0x1B,0x43,0xAC,
+0xD0,0x1B,0x02,0x8E,
+0x08,0x00,0x03,0x3C,
+0x24,0x10,0x52,0x00,
+0x24,0x10,0x43,0x00,
+0x68,0xFD,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x05,0x3C,
+0x1C,0x00,0xA3,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x06,0x24,
+0xFF,0x00,0x24,0x31,
+0xDD,0x01,0x86,0x10,
+0x25,0xB0,0x02,0x3C,
+0x00,0x80,0x22,0x31,
+0x33,0x01,0x40,0x10,
+0x00,0xFF,0x02,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x00,0x62,0xAC,
+0xFF,0x00,0x02,0x24,
+0x25,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x4C,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x9C,0x36,0x09,0xA2,
+0xE0,0x36,0x03,0xAE,
+0x05,0x00,0x04,0x24,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0x02,0x80,0x0A,0x3C,
+0xCC,0x5E,0x47,0x91,
+0x02,0x80,0x09,0x3C,
+0xBC,0x5E,0x25,0x8D,
+0xD0,0x1B,0x06,0x8E,
+0x18,0x00,0x02,0x3C,
+0x08,0x00,0xE7,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x02,0xA5,0x34,
+0x25,0xB0,0x03,0x3C,
+0x10,0x00,0x02,0x3C,
+0x00,0x26,0x07,0x00,
+0x26,0xA0,0x82,0x02,
+0xB0,0x03,0x68,0x34,
+0x25,0x20,0x85,0x00,
+0x80,0x03,0x63,0x34,
+0x41,0xB0,0x02,0x3C,
+0x00,0x00,0x64,0xAC,
+0x00,0x00,0x46,0xAC,
+0xBC,0x5E,0x25,0xAD,
+0xCC,0x5E,0x47,0xA1,
+0xD0,0x1B,0x06,0xAE,
+0x00,0x00,0x14,0xAD,
+0x30,0x1F,0x62,0x26,
+0xD4,0x1B,0x43,0x8C,
+0x08,0x00,0x04,0x3C,
+0x26,0x18,0x64,0x00,
+0x9E,0x35,0x00,0x08,
+0xD4,0x1B,0x43,0xAC,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xD4,0x1B,0x02,0x8E,
+0xD0,0x1B,0x03,0x8E,
+0x00,0x20,0x42,0x38,
+0x7D,0x35,0x00,0x08,
+0xD4,0x1B,0x02,0xAE,
+0x8C,0x33,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x2A,0xB0,0x02,0x3C,
+0x08,0x00,0x43,0x34,
+0x00,0x00,0x69,0x8C,
+0xFF,0x00,0x02,0x24,
+0xFF,0x00,0x24,0x31,
+0x2C,0x00,0x82,0x10,
+0x00,0x80,0x22,0x31,
+0x34,0x01,0x40,0x14,
+0x00,0x80,0x02,0x3C,
+0x00,0xFF,0x02,0x3C,
+0x24,0x10,0x22,0x01,
+0x0B,0x00,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0xB4,0x36,0x02,0x92,
+0x20,0xB0,0x03,0x3C,
+0x00,0x12,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x0C,0x00,0x49,0x8C,
+0x25,0xB0,0x03,0x3C,
+0xB0,0x03,0x63,0x34,
+0x00,0x00,0x69,0xAC,
+0xFF,0x00,0x24,0x31,
+0xFF,0x00,0x02,0x24,
+0x1A,0x00,0x82,0x10,
+0x30,0x1F,0x70,0x26,
+0xFF,0x00,0x23,0x31,
+0x7C,0x37,0x05,0x8E,
+0x20,0x10,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x21,0x30,0x60,0x00,
+0x10,0x37,0x03,0xAE,
+0x01,0x00,0x04,0x24,
+0xB4,0x36,0x09,0xA2,
+0x80,0x00,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA0,0xAF,
+0xD0,0x1B,0x05,0x8E,
+0x02,0x80,0x06,0x3C,
+0xBC,0x5E,0xC4,0x8C,
+0xFF,0xC7,0x02,0x24,
+0x24,0x28,0xA2,0x00,
+0x25,0xB0,0x02,0x3C,
+0x10,0x00,0x84,0x34,
+0x80,0x03,0x42,0x34,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x44,0xAC,
+0x00,0x00,0x65,0xAC,
+0xBC,0x5E,0xC4,0xAC,
+0xD0,0x1B,0x05,0xAE,
+0x30,0x1F,0x63,0x26,
+0xD4,0x1B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x38,
+0x76,0x35,0x00,0x08,
+0xD4,0x1B,0x62,0xAC,
+0x56,0x01,0x02,0x35,
+0x00,0x00,0x43,0x94,
+0x00,0x00,0x00,0x00,
+0x70,0xFC,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x93,0x55,0x00,0x0C,
+0x07,0x00,0x04,0x24,
+0x29,0x35,0x00,0x08,
+0x30,0x1F,0x64,0x26,
+0x00,0x00,0x62,0xAC,
+0xD3,0x35,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0xF8,0x1D,0x24,0x96,
+0x64,0x37,0x25,0x8E,
+0xFF,0x0F,0x83,0x30,
+0x25,0x28,0xA2,0x00,
+0x00,0x19,0x03,0x00,
+0x20,0x00,0xA6,0x24,
+0x02,0x12,0x03,0x00,
+0x01,0x00,0x84,0x24,
+0xF8,0x1D,0x24,0xA6,
+0x17,0x00,0xC2,0xA0,
+0x16,0x00,0xC3,0xA0,
+0x0C,0x00,0xA4,0x8C,
+0x00,0xF0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xFF,0x0F,0x63,0x30,
+0x00,0x1C,0x03,0x00,
+0x24,0x20,0x82,0x00,
+0x25,0x20,0x83,0x00,
+0x0C,0x00,0xA4,0xAC,
+0x64,0x37,0x25,0x8E,
+0x01,0x00,0x10,0x24,
+0x01,0x00,0x04,0x24,
+0x31,0x10,0x06,0x3C,
+0x00,0x01,0x07,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x2A,0xB0,0x02,0x3C,
+0x01,0x00,0x42,0x34,
+0x02,0x00,0x03,0x24,
+0x00,0x00,0x50,0xA0,
+0x00,0x00,0x43,0xA0,
+0xD4,0x1B,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x42,0x38,
+0x68,0x35,0x00,0x08,
+0xD4,0x1B,0x22,0xAE,
+0xD0,0x03,0x23,0x35,
+0x80,0x00,0x02,0x24,
+0x00,0x00,0x62,0xAC,
+0x24,0x36,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0x25,0xB0,0x02,0x3C,
+0x01,0x00,0x03,0x24,
+0x90,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0xF0,0x35,0x00,0x08,
+0x30,0x1F,0x65,0x26,
+0x24,0x10,0x22,0x01,
+0xA9,0xFD,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x47,0x00,0xC6,0x34,
+0x00,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x85,0x10,
+0x30,0x1F,0x62,0x26,
+0xA4,0x36,0x04,0xA2,
+0x00,0x00,0xC2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x07,0x00,0x83,0x10,
+0x21,0x38,0x00,0x02,
+0x21,0x28,0xC0,0x00,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0xA4,0x36,0xE3,0xA0,
+0x30,0x1F,0x62,0x26,
+0xA4,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0x9C,0x36,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0xFD,0xFD,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x45,0x00,0xE5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x30,0x1F,0x62,0x26,
+0xA8,0x36,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x30,0x1F,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0xA8,0x36,0xC3,0xA0,
+0x30,0x1F,0x62,0x26,
+0xA8,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0x11,0x37,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0x9E,0xFD,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x46,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x30,0x1F,0x62,0x26,
+0xA0,0x36,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x30,0x1F,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0xA0,0x36,0xC3,0xA0,
+0x30,0x1F,0x62,0x26,
+0xA0,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0xD3,0x36,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x00,0xFF,0x02,0x3C,
+0x24,0x10,0x22,0x01,
+0x30,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x41,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x30,0x1F,0x62,0x26,
+0x90,0x36,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x30,0x1F,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x90,0x36,0xC3,0xA0,
+0x30,0x1F,0x62,0x26,
+0x90,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0x87,0x37,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0xCF,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x44,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x30,0x1F,0x62,0x26,
+0x9C,0x36,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x30,0x1F,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x9C,0x36,0xC3,0xA0,
+0x30,0x1F,0x62,0x26,
+0x9C,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0x47,0x38,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0xAE,0xFD,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x40,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x30,0x1F,0x62,0x26,
+0x8C,0x36,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x30,0x1F,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x8C,0x36,0xC3,0xA0,
+0x30,0x1F,0x62,0x26,
+0x8C,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0x47,0x37,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x00,0x00,0x62,0xAC,
+0x93,0x38,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0x08,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x42,0x00,0xA5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x30,0x1F,0x62,0x26,
+0x94,0x36,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x30,0x1F,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x94,0x36,0xC3,0xA0,
+0x30,0x1F,0x62,0x26,
+0x94,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0xC5,0x37,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x24,0x10,0x22,0x01,
+0x2C,0xFE,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x43,0x00,0xE5,0x34,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x0E,0x00,0x86,0x10,
+0x30,0x1F,0x62,0x26,
+0x98,0x36,0x04,0xA2,
+0x00,0x00,0xA2,0x90,
+0xFF,0x00,0x83,0x30,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0x83,0x10,
+0x30,0x1F,0x62,0x26,
+0x21,0x30,0x00,0x02,
+0x00,0x00,0xA2,0x90,
+0x21,0x18,0x80,0x00,
+0xFD,0xFF,0x62,0x14,
+0xFF,0x00,0x44,0x30,
+0x98,0x36,0xC3,0xA0,
+0x30,0x1F,0x62,0x26,
+0x98,0x36,0x43,0x90,
+0x20,0xB0,0x02,0x3C,
+0x00,0x1A,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x0C,0x00,0x69,0x8C,
+0x25,0xB0,0x02,0x3C,
+0xB0,0x03,0x42,0x34,
+0xFF,0x00,0x24,0x31,
+0x00,0x00,0x49,0xAC,
+0x0A,0x38,0x00,0x08,
+0xFF,0x00,0x02,0x24,
+0x06,0x00,0x03,0x24,
+0x90,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0xAB,0x37,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0x01,0x00,0x03,0x24,
+0x90,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0xBF,0x36,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0x25,0xB0,0x02,0x3C,
+0x07,0x00,0x03,0x24,
+0x90,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x30,0x1F,0x63,0x26,
+0xD4,0x1B,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x42,0x38,
+0x71,0x37,0x00,0x08,
+0xD4,0x1B,0x62,0xAC,
+0x00,0x00,0x40,0xAC,
+0x34,0x37,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0x02,0x00,0x03,0x24,
+0x90,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0xFA,0x36,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0x90,0x03,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x2D,0x38,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0x03,0x00,0x03,0x24,
+0x90,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x6E,0x38,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0x05,0x00,0x03,0x24,
+0x90,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0xEC,0x37,0x00,0x08,
+0x30,0x1F,0x62,0x26,
+0xE0,0xFF,0xBD,0x27,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x25,0xB0,0x0C,0x3C,
+0x01,0x80,0x02,0x3C,
+0x18,0x03,0x83,0x35,
+0x9C,0xE8,0x42,0x24,
+0x02,0x80,0x12,0x3C,
+0x41,0xB0,0x0B,0x3C,
+0x00,0x00,0x62,0xAC,
+0x30,0x1F,0x4A,0x26,
+0x0A,0x00,0x62,0x35,
+0x00,0x00,0x44,0x94,
+0xDE,0x1B,0x43,0x95,
+0xDC,0x1B,0x49,0x95,
+0x25,0x30,0x64,0x00,
+0xFF,0xFF,0xD0,0x30,
+0x24,0x10,0x09,0x02,
+0x02,0x00,0x42,0x30,
+0xC2,0x00,0x40,0x10,
+0xC0,0x03,0x83,0x35,
+0x02,0x00,0x02,0x24,
+0x00,0x00,0x62,0xAC,
+0x02,0x80,0x08,0x3C,
+0xBC,0x5E,0x04,0x8D,
+0xDC,0x02,0x82,0x35,
+0x00,0x00,0x47,0x90,
+0xFD,0xFF,0x03,0x24,
+0x00,0x80,0x02,0x3C,
+0x24,0x18,0x23,0x01,
+0x25,0x20,0x82,0x00,
+0x02,0x00,0xC6,0x38,
+0x08,0x00,0x65,0x35,
+0x02,0x80,0x02,0x3C,
+0xF5,0x5E,0x47,0xA0,
+0xBC,0x5E,0x04,0xAD,
+0xDE,0x1B,0x46,0xA5,
+0x21,0x48,0x60,0x00,
+0x00,0x00,0xA3,0xA4,
+0xDC,0x1B,0x43,0xA5,
+0x24,0x38,0x09,0x02,
+0x04,0x00,0xE2,0x30,
+0x0A,0x00,0x40,0x10,
+0x08,0x00,0xE2,0x30,
+0xDE,0x1B,0x43,0x95,
+0x0C,0x00,0x64,0x35,
+0xC0,0x03,0x85,0x35,
+0x04,0x00,0x63,0x38,
+0x04,0x00,0x02,0x24,
+0x00,0x00,0x86,0x8C,
+0x00,0x00,0xA2,0xAC,
+0xDE,0x1B,0x43,0xA5,
+0x08,0x00,0xE2,0x30,
+0x08,0x00,0x40,0x10,
+0x10,0x00,0xE2,0x30,
+0xDE,0x1B,0x42,0x95,
+0xC0,0x03,0x84,0x35,
+0x08,0x00,0x03,0x24,
+0x08,0x00,0x42,0x38,
+0x00,0x00,0x83,0xAC,
+0xDE,0x1B,0x42,0xA5,
+0x10,0x00,0xE2,0x30,
+0x08,0x00,0x40,0x10,
+0x20,0x00,0xE2,0x30,
+0xDE,0x1B,0x42,0x95,
+0xC0,0x03,0x84,0x35,
+0x10,0x00,0x03,0x24,
+0x10,0x00,0x42,0x38,
+0x00,0x00,0x83,0xAC,
+0xDE,0x1B,0x42,0xA5,
+0x20,0x00,0xE2,0x30,
+0x08,0x00,0x40,0x10,
+0x80,0x00,0xE2,0x30,
+0xDE,0x1B,0x42,0x95,
+0xC0,0x03,0x84,0x35,
+0x20,0x00,0x03,0x24,
+0x20,0x00,0x42,0x38,
+0x00,0x00,0x83,0xAC,
+0xDE,0x1B,0x42,0xA5,
+0x80,0x00,0xE2,0x30,
+0x74,0x00,0x40,0x10,
+0x30,0x1F,0x47,0x26,
+0xC0,0x03,0x83,0x35,
+0x80,0x00,0x02,0x24,
+0x42,0xB0,0x0B,0x3C,
+0x00,0x00,0x62,0xAC,
+0x03,0x00,0x71,0x35,
+0xDE,0x1B,0x42,0x95,
+0x00,0x00,0x23,0x92,
+0x80,0x00,0x42,0x38,
+0x20,0x00,0x63,0x30,
+0x59,0x00,0x60,0x10,
+0xDE,0x1B,0x42,0xA5,
+0x20,0x00,0x02,0x24,
+0x00,0x00,0x22,0xA2,
+0x02,0x80,0x03,0x3C,
+0x16,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x75,0x00,0x40,0x14,
+0x21,0x40,0x00,0x00,
+0xB0,0x1B,0x42,0x95,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x4E,0x00,0x40,0x10,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0xF4,0x5E,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x49,0x00,0x40,0x10,
+0x02,0x80,0x09,0x3C,
+0x02,0x80,0x04,0x3C,
+0x00,0x5F,0x82,0x8C,
+0x20,0x5F,0x24,0x8D,
+0x24,0x5F,0x25,0x8D,
+0x21,0x18,0x00,0x00,
+0x21,0x10,0x44,0x00,
+0x2B,0x30,0x44,0x00,
+0x21,0x18,0x65,0x00,
+0x21,0x18,0x66,0x00,
+0x20,0x5F,0x22,0xAD,
+0x24,0x5F,0x23,0xAD,
+0xF4,0x5E,0xE4,0x90,
+0x02,0x00,0x02,0x24,
+0xFF,0x00,0x84,0x30,
+0x07,0x00,0x82,0x10,
+0x02,0x80,0x04,0x3C,
+0xF4,0x5E,0xE2,0x90,
+0x03,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x5A,0x00,0x43,0x14,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x04,0x3C,
+0x11,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x42,0x24,
+0x11,0x5F,0x82,0xA0,
+0x11,0x5F,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0xFA,0x5E,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x5B,0x00,0x00,0x11,
+0x80,0x00,0x86,0x35,
+0x11,0x5F,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x14,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x10,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x11,0x5F,0x83,0xA0,
+0x02,0x80,0x05,0x3C,
+0x0E,0x5F,0xA2,0x90,
+0x02,0x80,0x03,0x3C,
+0x02,0x00,0x04,0x24,
+0x10,0x00,0x42,0x34,
+0x0E,0x5F,0xA2,0xA0,
+0xF9,0x5E,0x62,0x90,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x30,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x8C,0x23,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x42,0xB0,0x02,0x3C,
+0x44,0x00,0x04,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x44,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF6,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x05,0x00,0x40,0x10,
+0x02,0x80,0x06,0x3C,
+0x04,0x00,0x04,0x24,
+0x64,0x31,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x02,0x80,0x06,0x3C,
+0xBC,0x5E,0xC4,0x8C,
+0x30,0x1F,0x47,0x26,
+0xDC,0x1B,0xE5,0x94,
+0x08,0x00,0x02,0x3C,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x7F,0xFF,0xA5,0x30,
+0xB0,0x03,0x42,0x34,
+0x08,0x00,0x63,0x34,
+0x00,0x00,0x44,0xAC,
+0x00,0x00,0x65,0xA4,
+0xBC,0x5E,0xC4,0xAC,
+0xDC,0x1B,0xE5,0xA4,
+0x30,0x1F,0x47,0x26,
+0xDC,0x1B,0xE2,0x94,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x50,0x00,
+0x00,0x30,0x42,0x30,
+0x06,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xDE,0x1B,0xE2,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x38,
+0x00,0x20,0x42,0x34,
+0xDE,0x1B,0xE2,0xA4,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x51,0x3A,0x00,0x08,
+0xDE,0x1B,0x46,0xA5,
+0x01,0x00,0x08,0x24,
+0x16,0x5F,0x60,0xA0,
+0x8D,0x3A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x0E,0x5F,0xA2,0x90,
+0x02,0x80,0x03,0x3C,
+0x02,0x00,0x04,0x24,
+0x10,0x00,0x42,0x34,
+0x0E,0x5F,0xA2,0xA0,
+0xF9,0x5E,0x62,0x90,
+0x21,0x28,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x30,0x02,0x00,
+0x21,0x30,0xC2,0x00,
+0x8C,0x23,0x00,0x0C,
+0x00,0x33,0x06,0x00,
+0x44,0x00,0x02,0x24,
+0x00,0x00,0x22,0xA2,
+0xD5,0x3A,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0x84,0x00,0x84,0x35,
+0x00,0x00,0x82,0x8C,
+0x02,0x80,0x08,0x3C,
+0x00,0x00,0xC4,0x8C,
+0x1C,0x5F,0x06,0x8D,
+0x21,0x10,0x00,0x00,
+0x20,0x5F,0x28,0x8D,
+0x24,0x5F,0x29,0x8D,
+0x00,0x00,0x65,0x91,
+0x25,0x10,0x44,0x00,
+0x21,0x10,0x46,0x00,
+0xFB,0xFF,0x04,0x24,
+0x24,0x28,0xA4,0x00,
+0x23,0x40,0x02,0x01,
+0x00,0x00,0x65,0xA1,
+0x04,0x00,0x00,0x11,
+0x01,0x00,0x06,0x24,
+0x80,0x10,0x08,0x00,
+0x21,0x10,0x48,0x00,
+0x80,0x30,0x02,0x00,
+0x01,0x00,0x04,0x24,
+0x8C,0x23,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x42,0xB0,0x02,0x3C,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0xDF,0x3A,0x00,0x08,
+0x02,0x80,0x06,0x3C,
+0xF0,0xFF,0xBD,0x27,
+0x08,0x00,0xB2,0xAF,
+0x04,0x00,0xB1,0xAF,
+0x00,0x00,0xB0,0xAF,
+0x00,0x40,0x09,0x40,
+0x00,0x68,0x0A,0x40,
+0x00,0x70,0x02,0x40,
+0x00,0x60,0x0B,0x40,
+0x25,0xB0,0x05,0x3C,
+0x18,0x03,0xA7,0x34,
+0x00,0x00,0xE6,0x8C,
+0x01,0x80,0x02,0x3C,
+0x1C,0x03,0xA3,0x34,
+0xC8,0xEC,0x42,0x24,
+0x00,0x00,0x66,0xAC,
+0x00,0x00,0xE2,0xAC,
+0x80,0x00,0x83,0x8C,
+0x7C,0x02,0xA2,0x34,
+0x80,0x02,0xA6,0x34,
+0x84,0x02,0xA7,0x34,
+0x88,0x02,0xA8,0x34,
+0x00,0x00,0x43,0xAC,
+0x00,0x00,0xC9,0xAC,
+0x00,0x00,0xEA,0xAC,
+0x00,0x00,0x0B,0xAD,
+0x74,0x00,0x83,0x8C,
+0x8C,0x02,0xA2,0x34,
+0x90,0x02,0xA7,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0x86,0x8C,
+0x94,0x02,0xA8,0x34,
+0x98,0x02,0xA9,0x34,
+0x00,0x00,0xE6,0xAC,
+0x0C,0x00,0x82,0x8C,
+0x9C,0x02,0xA6,0x34,
+0xA0,0x02,0xA7,0x34,
+0x00,0x00,0x02,0xAD,
+0x10,0x00,0x83,0x8C,
+0xA4,0x02,0xA8,0x34,
+0xA8,0x02,0xAA,0x34,
+0x00,0x00,0x23,0xAD,
+0x14,0x00,0x82,0x8C,
+0xAC,0x02,0xA9,0x34,
+0xB0,0x02,0xAB,0x34,
+0x00,0x00,0xC2,0xAC,
+0x18,0x00,0x83,0x8C,
+0xB4,0x02,0xAC,0x34,
+0xB8,0x02,0xAD,0x34,
+0x00,0x00,0xE3,0xAC,
+0x1C,0x00,0x82,0x8C,
+0xBC,0x02,0xA7,0x34,
+0xC0,0x02,0xAE,0x34,
+0x00,0x00,0x02,0xAD,
+0x20,0x00,0x83,0x8C,
+0xC4,0x02,0xA8,0x34,
+0xC8,0x02,0xAF,0x34,
+0x00,0x00,0x43,0xAD,
+0x24,0x00,0x82,0x8C,
+0xCC,0x02,0xAA,0x34,
+0xD0,0x02,0xB0,0x34,
+0x00,0x00,0x22,0xAD,
+0x28,0x00,0x83,0x8C,
+0xD4,0x02,0xA9,0x34,
+0xD8,0x02,0xB1,0x34,
+0x00,0x00,0x63,0xAD,
+0x2C,0x00,0x86,0x8C,
+0x70,0x02,0xAB,0x34,
+0x74,0x02,0xB2,0x34,
+0x00,0x00,0x86,0xAD,
+0x30,0x00,0x82,0x8C,
+0x78,0x02,0xA6,0x34,
+0x6C,0x03,0xAC,0x34,
+0x00,0x00,0xA2,0xAD,
+0x34,0x00,0x83,0x8C,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0xE3,0xAC,
+0x38,0x00,0x85,0x8C,
+0x28,0xC7,0x47,0x8C,
+0x00,0x00,0xC5,0xAD,
+0x3C,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x02,0xAD,
+0x40,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE3,0xAD,
+0x44,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x42,0xAD,
+0x48,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x03,0xAE,
+0x4C,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x22,0xAD,
+0x50,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x23,0xAE,
+0x54,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x62,0xAD,
+0x58,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0xAE,
+0x5C,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0xAC,
+0x21,0x10,0xE0,0x00,
+0x00,0x00,0x82,0xAD,
+0x01,0x00,0xE7,0x24,
+0x21,0x10,0xE0,0x00,
+0x01,0x00,0xE7,0x24,
+0x00,0x00,0x82,0xAD,
+0x9D,0x3B,0x00,0x08,
+0x21,0x10,0xE0,0x00,
+0x01,0x80,0x1B,0x3C,
+0x90,0xEE,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x21,0xD8,0xA0,0x03,
+0x82,0xDA,0x1B,0x00,
+0x80,0xDA,0x1B,0x00,
+0x08,0x00,0x7B,0x27,
+0x04,0x00,0x61,0xAF,
+0x08,0x00,0x62,0xAF,
+0x0C,0x00,0x63,0xAF,
+0x10,0x00,0x64,0xAF,
+0x14,0x00,0x65,0xAF,
+0x18,0x00,0x66,0xAF,
+0x1C,0x00,0x67,0xAF,
+0x20,0x00,0x68,0xAF,
+0x24,0x00,0x69,0xAF,
+0x28,0x00,0x6A,0xAF,
+0x2C,0x00,0x6B,0xAF,
+0x30,0x00,0x6C,0xAF,
+0x34,0x00,0x6D,0xAF,
+0x38,0x00,0x6E,0xAF,
+0x3C,0x00,0x6F,0xAF,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x70,0x0A,0x40,
+0x40,0x00,0x70,0xAF,
+0x44,0x00,0x71,0xAF,
+0x48,0x00,0x72,0xAF,
+0x4C,0x00,0x73,0xAF,
+0x50,0x00,0x74,0xAF,
+0x54,0x00,0x75,0xAF,
+0x58,0x00,0x76,0xAF,
+0x5C,0x00,0x77,0xAF,
+0x60,0x00,0x78,0xAF,
+0x64,0x00,0x79,0xAF,
+0x68,0x00,0x7C,0xAF,
+0x6C,0x00,0x7D,0xAF,
+0x70,0x00,0x7E,0xAF,
+0x74,0x00,0x7F,0xAF,
+0x78,0x00,0x68,0xAF,
+0x7C,0x00,0x69,0xAF,
+0x80,0x00,0x6A,0xAF,
+0x00,0x68,0x1A,0x40,
+0x25,0xB0,0x1B,0x3C,
+0x1C,0x03,0x7B,0x37,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x7A,0xAF,
+0x7F,0x00,0x5B,0x33,
+0x30,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x1B,0x3C,
+0x30,0x03,0x7B,0x37,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x7A,0xAF,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0xA0,0x03,
+0x82,0xDA,0x1B,0x00,
+0x80,0xDA,0x1B,0x00,
+0x08,0x00,0x7B,0x27,
+0x04,0x00,0x61,0xAF,
+0x08,0x00,0x62,0xAF,
+0x0C,0x00,0x63,0xAF,
+0x10,0x00,0x64,0xAF,
+0x14,0x00,0x65,0xAF,
+0x18,0x00,0x66,0xAF,
+0x1C,0x00,0x67,0xAF,
+0x20,0x00,0x68,0xAF,
+0x24,0x00,0x69,0xAF,
+0x28,0x00,0x6A,0xAF,
+0x2C,0x00,0x6B,0xAF,
+0x30,0x00,0x6C,0xAF,
+0x34,0x00,0x6D,0xAF,
+0x38,0x00,0x6E,0xAF,
+0x3C,0x00,0x6F,0xAF,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x70,0x0A,0x40,
+0x40,0x00,0x70,0xAF,
+0x44,0x00,0x71,0xAF,
+0x48,0x00,0x72,0xAF,
+0x4C,0x00,0x73,0xAF,
+0x50,0x00,0x74,0xAF,
+0x54,0x00,0x75,0xAF,
+0x58,0x00,0x76,0xAF,
+0x5C,0x00,0x77,0xAF,
+0x60,0x00,0x78,0xAF,
+0x64,0x00,0x79,0xAF,
+0x68,0x00,0x7C,0xAF,
+0x6C,0x00,0x7D,0xAF,
+0x70,0x00,0x7E,0xAF,
+0x74,0x00,0x7F,0xAF,
+0x78,0x00,0x68,0xAF,
+0x7C,0x00,0x69,0xAF,
+0x80,0x00,0x6A,0xAF,
+0x32,0x3B,0x00,0x08,
+0x21,0x20,0x60,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x08,0x3C,
+0x20,0x03,0x08,0x35,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x1A,0xAD,
+0x00,0x04,0x5B,0x33,
+0x0A,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x08,0x3C,
+0x3C,0xD4,0x08,0x25,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x1B,0x3C,
+0x24,0x03,0x7B,0x37,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x68,0xAF,
+0x09,0xF8,0x00,0x01,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x5B,0x33,
+0x25,0xB0,0x08,0x3C,
+0x28,0x03,0x08,0x35,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x1B,0xAD,
+0x06,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x08,0x3C,
+0x9C,0xE8,0x08,0x25,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x00,0x01,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x1A,0x3C,
+0xBC,0x5E,0x5A,0x27,
+0x04,0x00,0x5B,0x97,
+0x25,0xB0,0x08,0x3C,
+0x30,0x03,0x08,0x35,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x1B,0xAD,
+0x18,0x00,0x60,0x13,
+0x00,0x00,0x00,0x00,
+0x08,0xE4,0x9B,0x27,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x61,0x8F,
+0xFC,0x03,0x70,0x7B,
+0x7C,0x00,0x62,0x7B,
+0xBC,0x00,0x64,0x7B,
+0xFC,0x00,0x66,0x7B,
+0x3C,0x01,0x68,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x6A,0x7B,
+0xBC,0x01,0x6C,0x7B,
+0xFC,0x01,0x6E,0x7B,
+0x3C,0x02,0x70,0x7B,
+0x7C,0x02,0x72,0x7B,
+0xBC,0x02,0x74,0x7B,
+0xFC,0x02,0x76,0x7B,
+0x3C,0x03,0x78,0x7B,
+0x7C,0x03,0x7C,0x7B,
+0xBC,0x03,0x7E,0x7B,
+0x80,0x00,0x7B,0x8F,
+0x8F,0x3C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0xA0,0x03,
+0x82,0xDA,0x1B,0x00,
+0x80,0xDA,0x1B,0x00,
+0x08,0x00,0x7B,0x27,
+0x08,0x00,0x5B,0xAF,
+0xFC,0xE7,0x9D,0x27,
+0x00,0x00,0x4A,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x00,0x40,0x11,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x08,0x3C,
+0x1C,0x5E,0x08,0x25,
+0x21,0x48,0x00,0x00,
+0x21,0x58,0x00,0x00,
+0x01,0x00,0x6B,0x25,
+0x1A,0x00,0x40,0x11,
+0x24,0x70,0x4B,0x01,
+0x14,0x00,0xC0,0x11,
+0x01,0x00,0x04,0x24,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x44,0xA3,
+0x26,0x50,0x4B,0x01,
+0x00,0x00,0x4A,0xAF,
+0x80,0x80,0x09,0x00,
+0x21,0x80,0x08,0x02,
+0x00,0x00,0x10,0x8E,
+0x00,0x00,0x00,0x00,
+0x09,0xF8,0x00,0x02,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x1B,0x3C,
+0x68,0xF1,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x02,0x80,0x1A,0x3C,
+0xBC,0x5E,0x5A,0x27,
+0xE1,0xFF,0x00,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x29,0x25,
+0x40,0x58,0x0B,0x00,
+0x52,0x3C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x1B,0x3C,
+0xBC,0x5E,0x7B,0x27,
+0x21,0x60,0x00,0x00,
+0x04,0x00,0x6C,0xA7,
+0x08,0x00,0x7A,0x8F,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x5A,0x27,
+0x00,0x00,0x5A,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x5A,0x27,
+0x84,0x00,0x44,0x8F,
+0x00,0x00,0x00,0x00,
+0xF9,0xFF,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x41,0x8F,
+0xFC,0x03,0x50,0x7B,
+0x7C,0x00,0x42,0x7B,
+0xBC,0x00,0x44,0x7B,
+0xFC,0x00,0x46,0x7B,
+0x3C,0x01,0x48,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x4A,0x7B,
+0xBC,0x01,0x4C,0x7B,
+0xFC,0x01,0x4E,0x7B,
+0x3C,0x02,0x50,0x7B,
+0x7C,0x02,0x52,0x7B,
+0xBC,0x02,0x54,0x7B,
+0xFC,0x02,0x56,0x7B,
+0x3C,0x03,0x58,0x7B,
+0x7C,0x03,0x5C,0x7B,
+0xBC,0x03,0x5E,0x7B,
+0x80,0x00,0x5B,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x60,0x03,
+0x10,0x00,0x00,0x42,
+0x00,0x60,0x05,0x40,
+0x42,0x28,0x05,0x00,
+0x40,0x28,0x05,0x00,
+0x00,0x60,0x85,0x40,
+0x04,0x00,0x81,0xAC,
+0x08,0x00,0x82,0xAC,
+0x0C,0x00,0x83,0xAC,
+0x20,0x00,0x88,0xAC,
+0x24,0x00,0x89,0xAC,
+0x28,0x00,0x8A,0xAC,
+0x2C,0x00,0x8B,0xAC,
+0x30,0x00,0x8C,0xAC,
+0x34,0x00,0x8D,0xAC,
+0x38,0x00,0x8E,0xAC,
+0x3C,0x00,0x8F,0xAC,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x40,0x00,0x90,0xAC,
+0x44,0x00,0x91,0xAC,
+0x48,0x00,0x92,0xAC,
+0x4C,0x00,0x93,0xAC,
+0x50,0x00,0x94,0xAC,
+0x54,0x00,0x95,0xAC,
+0x58,0x00,0x96,0xAC,
+0x5C,0x00,0x97,0xAC,
+0x60,0x00,0x98,0xAC,
+0x64,0x00,0x99,0xAC,
+0x68,0x00,0x9C,0xAC,
+0x6C,0x00,0x9D,0xAC,
+0x70,0x00,0x9E,0xAC,
+0x74,0x00,0x9F,0xAC,
+0x78,0x00,0x88,0xAC,
+0x7C,0x00,0x89,0xAC,
+0x80,0x00,0x9F,0xAC,
+0xF8,0xFF,0x84,0x24,
+0x00,0x00,0x84,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x84,0x24,
+0x84,0x00,0x86,0x8C,
+0x00,0x00,0x00,0x00,
+0xF9,0xFF,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0x80,0x00,
+0x01,0x00,0xBA,0x34,
+0x04,0x00,0x61,0x8F,
+0xFC,0x03,0x70,0x7B,
+0x7C,0x00,0x62,0x7B,
+0xBC,0x00,0x64,0x7B,
+0xFC,0x00,0x66,0x7B,
+0x3C,0x01,0x68,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x6A,0x7B,
+0xBC,0x01,0x6C,0x7B,
+0xFC,0x01,0x6E,0x7B,
+0x3C,0x02,0x70,0x7B,
+0x7C,0x02,0x72,0x7B,
+0xBC,0x02,0x74,0x7B,
+0xFC,0x02,0x76,0x7B,
+0x3C,0x03,0x78,0x7B,
+0x7C,0x03,0x7C,0x7B,
+0xBC,0x03,0x7E,0x7B,
+0x80,0x00,0x7B,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x60,0x03,
+0x00,0x60,0x9A,0x40,
+0x00,0x60,0x05,0x40,
+0x42,0x28,0x05,0x00,
+0x40,0x28,0x05,0x00,
+0x00,0x60,0x85,0x40,
+0x04,0x00,0x81,0xAC,
+0x08,0x00,0x82,0xAC,
+0x0C,0x00,0x83,0xAC,
+0x20,0x00,0x88,0xAC,
+0x24,0x00,0x89,0xAC,
+0x28,0x00,0x8A,0xAC,
+0x2C,0x00,0x8B,0xAC,
+0x30,0x00,0x8C,0xAC,
+0x34,0x00,0x8D,0xAC,
+0x38,0x00,0x8E,0xAC,
+0x3C,0x00,0x8F,0xAC,
+0x12,0x40,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x40,0x00,0x90,0xAC,
+0x44,0x00,0x91,0xAC,
+0x48,0x00,0x92,0xAC,
+0x4C,0x00,0x93,0xAC,
+0x50,0x00,0x94,0xAC,
+0x54,0x00,0x94,0xAC,
+0x58,0x00,0x96,0xAC,
+0x5C,0x00,0x96,0xAC,
+0x60,0x00,0x98,0xAC,
+0x64,0x00,0x99,0xAC,
+0x68,0x00,0x9C,0xAC,
+0x6C,0x00,0x9D,0xAC,
+0x70,0x00,0x9E,0xAC,
+0x78,0x00,0x88,0xAC,
+0x7C,0x00,0x89,0xAC,
+0x80,0x00,0x9F,0xAC,
+0x84,0x00,0x80,0xAC,
+0xF8,0xFF,0x84,0x24,
+0x00,0x00,0x84,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x84,0x24,
+0x84,0x00,0x86,0x8C,
+0xFA,0xFF,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0xD8,0x80,0x00,
+0x01,0x00,0xBA,0x24,
+0x04,0x00,0x61,0x8F,
+0xFC,0x03,0x70,0x7B,
+0x7C,0x00,0x62,0x7B,
+0xBC,0x00,0x64,0x7B,
+0xFC,0x00,0x66,0x7B,
+0x3C,0x01,0x68,0x7B,
+0x13,0x00,0x00,0x02,
+0x11,0x00,0x20,0x02,
+0x7C,0x01,0x6A,0x7B,
+0xBC,0x01,0x6C,0x7B,
+0xFC,0x01,0x6E,0x7B,
+0x3C,0x02,0x70,0x7B,
+0x7C,0x02,0x72,0x7B,
+0xBC,0x02,0x74,0x7B,
+0xFC,0x02,0x76,0x7B,
+0x3C,0x03,0x78,0x7B,
+0x7C,0x03,0x7C,0x7B,
+0xBC,0x03,0x7E,0x7B,
+0x80,0x00,0x7B,0x8F,
+0x08,0x00,0x60,0x03,
+0x00,0x60,0x9A,0x40,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x83,0x4E,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x1B,0x3C,
+0x00,0x00,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x00,0x00,0x05,0x24,
+0x03,0x00,0xA4,0x24,
+0x00,0xA0,0x80,0x40,
+0x00,0xA0,0x84,0x40,
+0x01,0x80,0x04,0x3C,
+0x40,0x00,0x84,0x24,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x1B,0x3C,
+0x40,0x00,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x02,0x80,0x1A,0x3C,
+0x00,0x00,0x5A,0x27,
+0xFC,0x03,0x5D,0x27,
+0x02,0x80,0x1C,0x3C,
+0x00,0x1C,0x9C,0x27,
+0x00,0xF0,0x08,0x3C,
+0x00,0x0C,0x08,0x35,
+0x00,0x60,0x88,0x40,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x84,0x24,
+0xFF,0x7F,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x24,0x20,0x85,0x00,
+0x00,0x20,0x84,0x4C,
+0xFF,0xFF,0x05,0x34,
+0x21,0x28,0xA4,0x00,
+0x00,0x28,0x85,0x4C,
+0x02,0x80,0x08,0x3C,
+0x00,0x00,0x08,0x25,
+0x00,0x00,0x00,0xAD,
+0x03,0x80,0x09,0x3C,
+0xFC,0xCC,0x29,0x25,
+0x04,0x00,0x08,0x25,
+0xFE,0xFF,0x09,0x15,
+0x00,0x00,0x00,0xAD,
+0x00,0x80,0x04,0x3C,
+0x00,0x00,0x84,0x24,
+0xFF,0x7F,0x05,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x24,0x20,0x85,0x00,
+0x00,0x00,0x84,0x4C,
+0xFF,0xFF,0x06,0x34,
+0x21,0x30,0xC4,0x00,
+0x24,0x30,0xC5,0x00,
+0x00,0x08,0x86,0x4C,
+0x00,0xA0,0x04,0x40,
+0x10,0x00,0x84,0x34,
+0x00,0xA0,0x84,0x40,
+0x01,0x80,0x1B,0x3C,
+0xEC,0x00,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x44,0x00,0x84,0x34,
+0x00,0x00,0x85,0x84,
+0x20,0x00,0x06,0x24,
+0x25,0x28,0xA6,0x00,
+0x00,0x00,0x85,0xA4,
+0x01,0x80,0x1B,0x3C,
+0x1C,0x01,0x7B,0x27,
+0x25,0xB0,0x1A,0x3C,
+0x18,0x03,0x5A,0x27,
+0x00,0x00,0x5B,0xAF,
+0x25,0xB0,0x04,0x3C,
+0x44,0x00,0x84,0x34,
+0x00,0x00,0x85,0x8C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xA5,0x30,
+0xFC,0xFF,0xA0,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0x1F,0x07,0x3C,
+0xFF,0xFF,0xE7,0x34,
+0x02,0x80,0x05,0x3C,
+0xD8,0x5D,0xA5,0x24,
+0xFF,0xFF,0xA5,0x30,
+0x40,0xB0,0x04,0x3C,
+0x25,0x28,0xA4,0x00,
+0x24,0x28,0xA7,0x00,
+0x21,0x30,0x00,0x00,
+0x43,0xB0,0x02,0x3C,
+0x00,0x80,0x04,0x3C,
+0x40,0x00,0x84,0x34,
+0x00,0x00,0x45,0xAC,
+0x04,0x00,0x46,0xAC,
+0x08,0x00,0x44,0xAC,
+0xEA,0x65,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x41,0x04,
+0xFF,0xFF,0x42,0x24,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x42,0x24,
+0x00,0x60,0x02,0x40,
+0x01,0x00,0x41,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x82,0xAC,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x40,0x00,
+0x00,0x60,0x83,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x82,0xAC,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x00,0x60,0x81,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x0C,0x02,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x04,0x00,0x85,0x8C,
+0x00,0xA0,0x03,0x3C,
+0x01,0x00,0x02,0x24,
+0x25,0x28,0xA3,0x00,
+0x00,0x00,0xA4,0x8C,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x3C,0x02,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x04,0x00,0x82,0x8C,
+0x02,0x00,0x83,0x94,
+0x00,0xA0,0x07,0x3C,
+0x25,0x28,0x47,0x00,
+0x00,0x00,0xA2,0x8C,
+0x10,0x00,0x02,0x24,
+0x13,0x00,0x62,0x10,
+0x11,0x00,0x66,0x28,
+0x06,0x00,0xC0,0x10,
+0x20,0x00,0x02,0x24,
+0x08,0x00,0x02,0x24,
+0x17,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0xFD,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA3,0xAC,
+0x04,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x25,0x10,0x47,0x00,
+0x00,0x00,0x42,0x8C,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xA4,
+0x04,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x67,0x00,
+0x00,0x00,0x62,0x94,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xA0,
+0x04,0x00,0x83,0x8C,
+0x00,0x00,0x00,0x00,
+0x25,0x18,0x67,0x00,
+0x00,0x00,0x62,0x90,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x47,0x24,
+0x30,0x37,0xE3,0x90,
+0xFF,0xFF,0xA5,0x30,
+0x09,0x00,0xA3,0x10,
+0x21,0x20,0xC0,0x00,
+0xA0,0x37,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xC2,0xAC,
+0xAA,0x37,0xE3,0x94,
+0x0E,0x00,0x02,0x24,
+0x14,0x00,0xC2,0xAC,
+0x30,0x09,0x00,0x08,
+0x0C,0x00,0xC3,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x31,0x26,
+0x88,0x37,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x01,0x80,0x03,0x3C,
+0x25,0x80,0x02,0x02,
+0x25,0xB0,0x02,0x3C,
+0x40,0x03,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x60,0x00,0x04,0x26,
+0x80,0x00,0x05,0x26,
+0x00,0x00,0x43,0xAC,
+0x5F,0x1E,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x00,0x00,
+0x08,0x52,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x88,0x37,0x22,0x8E,
+0x0C,0x00,0x03,0x24,
+0x0C,0x00,0x43,0xAE,
+0x08,0x00,0x42,0xAE,
+0x12,0x00,0x02,0x24,
+0x14,0x00,0x42,0xAE,
+0x21,0x20,0x40,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x30,0x09,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x30,0x80,0x00,
+0x21,0x90,0x00,0x00,
+0x00,0x60,0x11,0x40,
+0x01,0x00,0x21,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x0D,0x00,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x60,0x14,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x03,0x24,
+0xF8,0x5E,0x43,0xA0,
+0x0C,0x00,0xC2,0x90,
+0x02,0x80,0x05,0x3C,
+0x0D,0x5F,0xA2,0xA0,
+0x00,0x00,0xC4,0x90,
+0x05,0x00,0x02,0x24,
+0xFF,0x00,0x83,0x30,
+0x41,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x02,0x24,
+0x31,0x00,0x62,0x10,
+0xFF,0x00,0x84,0x30,
+0x09,0x00,0x82,0x2C,
+0x25,0x00,0x40,0x10,
+0x02,0x80,0x10,0x3C,
+0xF4,0x5E,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x21,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0xB6,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF4,0x5E,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x34,0x00,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0xE0,0x3A,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x51,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x15,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x11,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x15,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x15,0x5F,0x62,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF6,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x04,0x00,0x42,0x28,
+0x06,0x00,0x40,0x10,
+0x04,0x00,0x04,0x24,
+0x64,0x31,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x40,0x41,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x12,0x24,
+0x00,0x60,0x91,0x40,
+0x21,0x10,0x40,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x0B,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x40,0x14,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x02,0x24,
+0x10,0x5F,0x62,0xA0,
+0x10,0x5F,0x63,0x90,
+0x02,0x80,0x02,0x3C,
+0x11,0x5F,0x43,0xA0,
+0x00,0x00,0xC4,0x90,
+0x18,0x41,0x00,0x08,
+0xFF,0x00,0x84,0x30,
+0x0D,0x5F,0xA0,0xA0,
+0x00,0x00,0xC4,0x90,
+0x15,0x41,0x00,0x08,
+0xFF,0x00,0x83,0x30,
+0x42,0xB0,0x06,0x3C,
+0x00,0x00,0xC3,0x90,
+0xEF,0xFF,0x02,0x24,
+0x03,0x00,0xC7,0x34,
+0x24,0x18,0x62,0x00,
+0x40,0x00,0x02,0x24,
+0x00,0x00,0xC3,0xA0,
+0x0C,0x00,0x04,0x24,
+0x00,0x00,0xE2,0xA0,
+0x64,0x31,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x02,0x80,0x03,0x3C,
+0xDE,0x5D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x15,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x2A,0x1C,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xCD,0xFF,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x50,0x39,0x44,0x94,
+0x2A,0x1C,0x40,0xA0,
+0x00,0xC0,0x84,0x24,
+0xC2,0x34,0x00,0x0C,
+0xFF,0xFF,0x84,0x30,
+0x40,0x41,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x15,0x5F,0x40,0xA0,
+0x40,0x41,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x9B,0x30,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x6B,0x41,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x30,0x26,
+0xB0,0x1B,0x07,0x96,
+0x18,0x00,0xBF,0xAF,
+0xFF,0xFF,0xE3,0x30,
+0x00,0x01,0x62,0x30,
+0x0E,0x00,0x40,0x10,
+0x01,0x00,0x66,0x30,
+0x02,0x80,0x04,0x3C,
+0x88,0x58,0x84,0x24,
+0x03,0x00,0x05,0x24,
+0x17,0x00,0xC0,0x14,
+0x04,0x00,0x62,0x30,
+0x02,0x00,0x40,0x10,
+0xFB,0xF6,0xE3,0x30,
+0xB0,0x1B,0x03,0xA6,
+0xA3,0x51,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x40,0xA0,
+0x21,0x20,0x00,0x00,
+0x12,0x0D,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x30,0x1F,0x23,0x26,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x20,0x00,0xBD,0x27,
+0x10,0x3E,0x60,0xAC,
+0xEC,0x38,0x60,0xAC,
+0x08,0x39,0x60,0xAC,
+0x08,0x00,0xE0,0x03,
+0x50,0x3E,0x60,0xAC,
+0x6C,0x4C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0xFE,0xFE,0x42,0x30,
+0xA3,0x51,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x40,0xA0,
+0x9D,0x41,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x01,0x00,0x83,0x90,
+0x02,0x80,0x02,0x3C,
+0x21,0x38,0x80,0x00,
+0xB0,0x5C,0x43,0xAC,
+0x01,0x00,0x84,0x90,
+0x00,0x00,0xE2,0x90,
+0x02,0x80,0x06,0x3C,
+0xFF,0x00,0x85,0x30,
+0x80,0x10,0x02,0x00,
+0x25,0x28,0xA2,0x00,
+0xE8,0xDD,0xC6,0x24,
+0xFF,0x00,0x84,0x30,
+0x00,0x80,0xA5,0x34,
+0x4E,0x23,0x00,0x0C,
+0x03,0x00,0xE7,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x03,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0xE0,0x3A,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x43,0x30,
+0x00,0x01,0x42,0x30,
+0x04,0x00,0x40,0x10,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x06,0x00,0x60,0x14,
+0xE0,0xD7,0x84,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x07,0x92,
+0x07,0x00,0x02,0x26,
+0x21,0x20,0x00,0x02,
+0x80,0x38,0x07,0x00,
+0x00,0x80,0xE7,0x34,
+0x05,0x00,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0x1E,0x51,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x30,0x1F,0x45,0x24,
+0x50,0x3E,0xA3,0x8C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x60,0x14,
+0x21,0x80,0x80,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x4C,0x3E,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x45,0x00,
+0x44,0x3E,0x40,0xA0,
+0x00,0x00,0x84,0x8C,
+0x6D,0x1D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x06,0x8E,
+0x03,0x00,0x04,0x24,
+0x90,0x14,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x00,0x00,0x84,0x90,
+0x4F,0x0C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x86,0x90,
+0x21,0x80,0x80,0x00,
+0x00,0x7F,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x08,0x0E,0x04,0x24,
+0x00,0x00,0x05,0x92,
+0x7F,0x7F,0x11,0x3C,
+0x00,0x0E,0x04,0x24,
+0x00,0x14,0x05,0x00,
+0x00,0x86,0x05,0x00,
+0x00,0x1A,0x05,0x00,
+0x25,0x80,0x02,0x02,
+0x25,0x80,0x03,0x02,
+0x25,0x80,0x05,0x02,
+0x21,0x30,0x00,0x02,
+0xA9,0x45,0x00,0x0C,
+0x7F,0x7F,0x25,0x36,
+0x7F,0x7F,0x25,0x36,
+0x21,0x30,0x00,0x02,
+0xA9,0x45,0x00,0x0C,
+0x04,0x0E,0x04,0x24,
+0x7F,0x7F,0x25,0x36,
+0x21,0x30,0x00,0x02,
+0xA9,0x45,0x00,0x0C,
+0x10,0x0E,0x04,0x24,
+0x7F,0x7F,0x25,0x36,
+0x21,0x30,0x00,0x02,
+0xA9,0x45,0x00,0x0C,
+0x14,0x0E,0x04,0x24,
+0x7F,0x7F,0x25,0x36,
+0x21,0x30,0x00,0x02,
+0xA9,0x45,0x00,0x0C,
+0x18,0x0E,0x04,0x24,
+0x7F,0x7F,0x25,0x36,
+0x21,0x30,0x00,0x02,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x1C,0x0E,0x04,0x24,
+0xA9,0x45,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x00,0x00,0x85,0x94,
+0x02,0x00,0x02,0x24,
+0x21,0x98,0x80,0x00,
+0x10,0x00,0xA0,0xA3,
+0x21,0x80,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x21,0x88,0x00,0x00,
+0x66,0x00,0xA2,0x10,
+0x10,0x00,0xB2,0x27,
+0x03,0x00,0xA2,0x28,
+0x26,0x00,0x40,0x14,
+0x01,0x00,0x02,0x24,
+0x03,0x00,0x02,0x24,
+0x75,0x00,0xA2,0x10,
+0x24,0x08,0x04,0x24,
+0x0C,0x09,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x04,0x08,0x04,0x24,
+0x21,0x30,0x00,0x02,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x05,0x24,
+0x02,0x00,0x64,0x96,
+0x02,0x00,0x02,0x24,
+0x35,0x00,0x82,0x10,
+0x03,0x00,0x82,0x28,
+0x4B,0x00,0x40,0x10,
+0x03,0x00,0x02,0x24,
+0x01,0x00,0x02,0x24,
+0x60,0x00,0x82,0x10,
+0x21,0x30,0x20,0x02,
+0x04,0x0C,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x05,0x24,
+0x21,0x30,0x20,0x02,
+0x04,0x0D,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x05,0x24,
+0x10,0x00,0xA6,0x93,
+0x04,0x0A,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x00,0xFF,0x05,0x3C,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xDE,0xFF,0xA2,0x14,
+0x0C,0x09,0x04,0x24,
+0x24,0x08,0x04,0x24,
+0x0E,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x2C,0x08,0x04,0x24,
+0x01,0x00,0x06,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0E,0x00,0x05,0x24,
+0x10,0x00,0xA2,0x93,
+0x80,0xFF,0x03,0x24,
+0x11,0x11,0x04,0x3C,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x11,0x11,0x86,0x34,
+0x03,0x00,0x10,0x24,
+0x10,0x00,0xA2,0xA3,
+0x0C,0x09,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x04,0x08,0x04,0x24,
+0x21,0x30,0x00,0x02,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x05,0x24,
+0x02,0x00,0x64,0x96,
+0x02,0x00,0x02,0x24,
+0xCD,0xFF,0x82,0x14,
+0x03,0x00,0x82,0x28,
+0x00,0x00,0x42,0x92,
+0x02,0x00,0x11,0x24,
+0xF5,0x00,0x42,0x30,
+0x05,0x00,0x42,0x34,
+0x00,0x00,0x42,0xA2,
+0x21,0x30,0x20,0x02,
+0x04,0x0C,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x05,0x24,
+0x21,0x30,0x20,0x02,
+0x04,0x0D,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x05,0x24,
+0x10,0x00,0xA6,0x93,
+0x04,0x0A,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x00,0xFF,0x05,0x3C,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xB8,0xFF,0x82,0x14,
+0x21,0x30,0x20,0x02,
+0x00,0x00,0x42,0x92,
+0x03,0x00,0x11,0x24,
+0xF0,0x00,0x42,0x30,
+0x01,0x00,0x42,0x34,
+0xD4,0x42,0x00,0x08,
+0x00,0x00,0x42,0xA2,
+0x24,0x08,0x04,0x24,
+0x0E,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x02,0x00,0x06,0x24,
+0x2C,0x08,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0E,0x00,0x05,0x24,
+0x10,0x00,0xA2,0x93,
+0x22,0x22,0x03,0x3C,
+0x22,0x22,0x66,0x34,
+0x0F,0x00,0x42,0x30,
+0x40,0x00,0x42,0x34,
+0x03,0x00,0x10,0x24,
+0xC4,0x42,0x00,0x08,
+0x10,0x00,0xA2,0xA3,
+0x00,0x00,0x42,0x92,
+0x01,0x00,0x11,0x24,
+0xF0,0x00,0x42,0x30,
+0xD4,0x42,0x00,0x08,
+0x00,0x00,0x42,0xA2,
+0x0E,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x02,0x00,0x06,0x24,
+0x2C,0x08,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0E,0x00,0x05,0x24,
+0x10,0x00,0xA2,0x93,
+0xC0,0xFF,0x03,0x24,
+0x03,0x00,0x10,0x24,
+0x0F,0x00,0x42,0x30,
+0x25,0x10,0x43,0x00,
+0x32,0x03,0x03,0x3C,
+0x33,0x13,0x66,0x34,
+0x90,0x42,0x00,0x08,
+0x10,0x00,0xA2,0xA3,
+0x00,0x00,0x86,0x8C,
+0x00,0x0F,0x05,0x3C,
+0xA9,0x45,0x00,0x08,
+0x80,0x08,0x04,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x2F,0x55,0x00,0x0C,
+0xF0,0xD7,0x84,0x24,
+0x00,0x00,0x02,0x92,
+0x00,0x0D,0x04,0x24,
+0x00,0x10,0x05,0x3C,
+0x21,0x00,0x40,0x10,
+0x21,0x30,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0xCB,0x45,0x00,0x0C,
+0x00,0x02,0x05,0x3C,
+0x00,0x08,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0x32,0x00,0x40,0x10,
+0x01,0x00,0x06,0x24,
+0x00,0x0A,0x04,0x24,
+0x03,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x08,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x10,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x20,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x40,0x05,0x3C,
+0x21,0x30,0x00,0x00,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x20,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x40,0x05,0x3C,
+0x21,0x30,0x00,0x00,
+0xA9,0x45,0x00,0x0C,
+0x00,0x0D,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x10,0x27,0x04,0x24,
+0x00,0x0F,0x04,0x24,
+0x00,0x01,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0F,0x04,0x24,
+0x00,0x01,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x03,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x08,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x10,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x20,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x40,0x05,0x3C,
+0x3E,0x43,0x00,0x08,
+0x21,0x30,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x2F,0x55,0x00,0x0C,
+0x08,0xD8,0x84,0x24,
+0x00,0x00,0x02,0x92,
+0x0F,0x00,0x12,0x3C,
+0x0F,0x00,0x11,0x3C,
+0x00,0x08,0x04,0x24,
+0x00,0x01,0x05,0x3C,
+0x20,0x00,0x40,0x10,
+0x21,0x30,0x00,0x00,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x02,0x05,0x3C,
+0x21,0x30,0x00,0x00,
+0xA9,0x45,0x00,0x0C,
+0x00,0x08,0x04,0x24,
+0x01,0x00,0x04,0x92,
+0xE6,0x44,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x06,0x3C,
+0xFF,0xFF,0x45,0x36,
+0x00,0x40,0xC6,0x34,
+0x5F,0x47,0x00,0x0C,
+0x21,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x02,0x00,0x06,0x3C,
+0xFF,0xFF,0x45,0x36,
+0x1F,0x00,0xC6,0x34,
+0x5F,0x47,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x02,0x05,0x3C,
+0x01,0x00,0x06,0x24,
+0xA9,0x45,0x00,0x0C,
+0x00,0x08,0x04,0x24,
+0x01,0x00,0x04,0x92,
+0xE6,0x44,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x06,0x3C,
+0xFF,0xFF,0x25,0x36,
+0x00,0x40,0xC6,0x34,
+0x5F,0x47,0x00,0x0C,
+0x21,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xFF,0xFF,0x25,0x36,
+0x21,0x20,0x00,0x00,
+0x5F,0x47,0x00,0x0C,
+0x03,0x00,0x06,0x3C,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x2F,0x55,0x00,0x0C,
+0x20,0xD8,0x84,0x24,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x40,0x10,
+0x00,0x0A,0x04,0x24,
+0x04,0x00,0x02,0x8E,
+0x00,0x08,0x04,0x24,
+0x04,0x00,0x42,0x2C,
+0x1C,0x00,0x40,0x14,
+0x00,0x01,0x05,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x04,0x00,0x02,0x8E,
+0x03,0x00,0x05,0x24,
+0x04,0x00,0x42,0x2C,
+0xF8,0xFF,0x40,0x10,
+0x21,0x30,0x00,0x00,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x08,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0F,0x04,0x24,
+0x00,0x01,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0F,0x04,0x24,
+0x00,0x01,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xCB,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0x00,0x01,0x05,0x3C,
+0x1B,0x00,0x40,0x10,
+0x01,0x00,0x06,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x10,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x20,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x40,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x03,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x00,0x0A,0x04,0x24,
+0x08,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x00,0x30,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0xE4,0x43,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xEF,0x43,0x00,0x08,
+0x00,0x0D,0x04,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x04,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x2F,0x55,0x00,0x0C,
+0x40,0xD8,0x84,0x24,
+0x04,0x00,0x03,0x8E,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x62,0x2C,
+0x2C,0x00,0x40,0x14,
+0xFC,0xFF,0x62,0x24,
+0x18,0x00,0x42,0x2C,
+0x05,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x6C,0xD8,0x84,0x24,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x54,0x00,0x40,0x10,
+0x00,0x0D,0x04,0x24,
+0x00,0x08,0x04,0x24,
+0xCB,0x45,0x00,0x0C,
+0x00,0x02,0x05,0x3C,
+0x63,0x00,0x40,0x10,
+0x00,0x08,0x04,0x24,
+0x00,0x0A,0x04,0x24,
+0x03,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x08,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x10,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x20,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x40,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x58,0xD8,0x84,0x24,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x21,0x00,0x40,0x10,
+0x00,0x0A,0x04,0x24,
+0x00,0x08,0x04,0x24,
+0xCB,0x45,0x00,0x0C,
+0x00,0x01,0x05,0x3C,
+0x3A,0x00,0x40,0x10,
+0x00,0x08,0x04,0x24,
+0x00,0x0D,0x04,0x24,
+0x00,0x10,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x20,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x40,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x04,0x00,0x06,0x8E,
+0x00,0x0A,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0x00,0x30,0x05,0x24,
+0x00,0x0A,0x04,0x24,
+0x03,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x00,0x0A,0x04,0x24,
+0x08,0x00,0x05,0x24,
+0x01,0x00,0x06,0x24,
+0xA9,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x3F,0x44,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0A,0x04,0x24,
+0x08,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0F,0x04,0x24,
+0x00,0x01,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0F,0x04,0x24,
+0x00,0x01,0x05,0x24,
+0x66,0x44,0x00,0x08,
+0x01,0x00,0x06,0x24,
+0x00,0x10,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x20,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x40,0x05,0x3C,
+0x21,0x30,0x00,0x00,
+0xA9,0x45,0x00,0x0C,
+0x00,0x0D,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x10,0x27,0x04,0x24,
+0x72,0x44,0x00,0x08,
+0x00,0x0F,0x04,0x24,
+0x00,0x01,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x50,0x44,0x00,0x08,
+0x00,0x0D,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x2C,0x44,0x00,0x08,
+0x00,0x0A,0x04,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x03,0x02,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x90,0x90,
+0x25,0xB0,0x02,0x3C,
+0xFF,0x00,0x63,0x30,
+0xFB,0x00,0x65,0x30,
+0x00,0x00,0x04,0x3A,
+0x04,0x00,0x63,0x34,
+0x0B,0x18,0xA4,0x00,
+0x03,0x02,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0x12,0x00,0x00,0x12,
+0x01,0x00,0x02,0x24,
+0x22,0x00,0x02,0x12,
+0x00,0x08,0x04,0x24,
+0x1A,0x00,0x00,0x12,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0x02,0x16,
+0x00,0x00,0x00,0x00,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x18,0x00,0x04,0x24,
+0x00,0x0C,0x05,0x24,
+0x21,0x30,0x00,0x00,
+0x5F,0x47,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x00,0x08,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x09,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x84,0x08,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x58,0x00,0x06,0x24,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x18,0x00,0x04,0x24,
+0x00,0x0C,0x05,0x24,
+0xAE,0x44,0x00,0x08,
+0x01,0x00,0x06,0x24,
+0x01,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x09,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x0A,0x04,0x24,
+0x10,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x0D,0x04,0x24,
+0x00,0x0C,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x84,0x08,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x18,0x00,0x06,0x24,
+0xA5,0x44,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x85,0xAC,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x05,0x3C,
+0x01,0x80,0x03,0x3C,
+0x21,0x38,0x80,0x00,
+0x18,0x03,0xA2,0x34,
+0x98,0x13,0x63,0x24,
+0x01,0x00,0x04,0x24,
+0x00,0x00,0x43,0xAC,
+0x35,0x00,0xE4,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x10,
+0x20,0x08,0xA2,0x34,
+0x02,0x00,0x02,0x24,
+0x83,0x00,0xE2,0x10,
+0x03,0x00,0x02,0x24,
+0x5A,0x00,0xE2,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x00,0x00,0x44,0x8C,
+0x30,0x1F,0x66,0x24,
+0x70,0x08,0x02,0x24,
+0xE0,0x08,0x03,0x24,
+0x34,0x1C,0xC2,0xAC,
+0x40,0x08,0x02,0x24,
+0x38,0x1C,0xC3,0xAC,
+0x44,0x1C,0xC2,0xAC,
+0x78,0x08,0x03,0x24,
+0x0C,0x08,0x02,0x24,
+0x48,0x1C,0xC3,0xAC,
+0x4C,0x1C,0xC2,0xAC,
+0x10,0x08,0x03,0x24,
+0x20,0x08,0x02,0x24,
+0x50,0x1C,0xC3,0xAC,
+0x54,0x1C,0xC2,0xAC,
+0x24,0x08,0x03,0x24,
+0x58,0x08,0x02,0x24,
+0x58,0x1C,0xC3,0xAC,
+0x5C,0x1C,0xC2,0xAC,
+0x50,0x0C,0x03,0x24,
+0x54,0x0C,0x02,0x24,
+0x60,0x1C,0xC3,0xAC,
+0x64,0x1C,0xC2,0xAC,
+0x14,0x0C,0x03,0x24,
+0x10,0x0C,0x02,0x24,
+0x60,0x08,0x05,0x24,
+0x68,0x1C,0xC3,0xAC,
+0x6C,0x1C,0xC2,0xAC,
+0x80,0x0C,0x03,0x24,
+0x84,0x0C,0x02,0x24,
+0x00,0x01,0x84,0x30,
+0x74,0x1C,0xC2,0xAC,
+0x40,0x1C,0xC5,0xAC,
+0x70,0x1C,0xC3,0xAC,
+0x31,0x1C,0xC0,0xA0,
+0x3C,0x1C,0xC5,0xAC,
+0x02,0x00,0x80,0x10,
+0xA0,0x08,0x02,0x24,
+0xB8,0x08,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x78,0x1C,0xC2,0xAC,
+0x28,0x08,0xA2,0x34,
+0x02,0x80,0x03,0x3C,
+0x00,0x00,0x44,0x8C,
+0x30,0x1F,0x66,0x24,
+0x70,0x08,0x02,0x24,
+0xE0,0x08,0x03,0x24,
+0x34,0x1C,0xC2,0xAC,
+0x44,0x08,0x02,0x24,
+0x38,0x1C,0xC3,0xAC,
+0x44,0x1C,0xC2,0xAC,
+0x78,0x08,0x03,0x24,
+0x0C,0x08,0x02,0x24,
+0x48,0x1C,0xC3,0xAC,
+0x4C,0x1C,0xC2,0xAC,
+0x14,0x08,0x03,0x24,
+0x28,0x08,0x02,0x24,
+0x50,0x1C,0xC3,0xAC,
+0x54,0x1C,0xC2,0xAC,
+0x2C,0x08,0x03,0x24,
+0x58,0x08,0x02,0x24,
+0x58,0x1C,0xC3,0xAC,
+0x5C,0x1C,0xC2,0xAC,
+0x58,0x0C,0x03,0x24,
+0x5C,0x0C,0x02,0x24,
+0x60,0x1C,0xC3,0xAC,
+0x64,0x1C,0xC2,0xAC,
+0x1C,0x0C,0x03,0x24,
+0x18,0x0C,0x02,0x24,
+0x64,0x08,0x05,0x24,
+0x68,0x1C,0xC3,0xAC,
+0x6C,0x1C,0xC2,0xAC,
+0x88,0x0C,0x03,0x24,
+0x8C,0x0C,0x02,0x24,
+0x00,0x01,0x84,0x30,
+0x74,0x1C,0xC2,0xAC,
+0x31,0x1C,0xC7,0xA0,
+0x40,0x1C,0xC5,0xAC,
+0x70,0x1C,0xC3,0xAC,
+0x3C,0x1C,0xC5,0xAC,
+0xD6,0xFF,0x80,0x10,
+0xA4,0x08,0x02,0x24,
+0xBC,0x08,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x78,0x1C,0xC2,0xAC,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0xAC,0x08,0x03,0x24,
+0x78,0x1C,0x43,0xAC,
+0x74,0x08,0x03,0x24,
+0xE4,0x08,0x04,0x24,
+0x34,0x1C,0x43,0xAC,
+0x4C,0x08,0x03,0x24,
+0x38,0x1C,0x44,0xAC,
+0x44,0x1C,0x43,0xAC,
+0x7C,0x08,0x04,0x24,
+0x0C,0x08,0x03,0x24,
+0x48,0x1C,0x44,0xAC,
+0x4C,0x1C,0x43,0xAC,
+0x1C,0x08,0x04,0x24,
+0x38,0x08,0x03,0x24,
+0x50,0x1C,0x44,0xAC,
+0x54,0x1C,0x43,0xAC,
+0x3C,0x08,0x04,0x24,
+0x5C,0x08,0x03,0x24,
+0x58,0x1C,0x44,0xAC,
+0x5C,0x1C,0x43,0xAC,
+0x68,0x0C,0x04,0x24,
+0x6C,0x0C,0x03,0x24,
+0x60,0x1C,0x44,0xAC,
+0x64,0x1C,0x43,0xAC,
+0x2C,0x0C,0x04,0x24,
+0x28,0x0C,0x03,0x24,
+0x6C,0x08,0x05,0x24,
+0x68,0x1C,0x44,0xAC,
+0x6C,0x1C,0x43,0xAC,
+0x98,0x0C,0x04,0x24,
+0x9C,0x0C,0x03,0x24,
+0x31,0x1C,0x47,0xA0,
+0x40,0x1C,0x45,0xAC,
+0x70,0x1C,0x44,0xAC,
+0x74,0x1C,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x3C,0x1C,0x45,0xAC,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0xA8,0x08,0x03,0x24,
+0x78,0x1C,0x43,0xAC,
+0x74,0x08,0x03,0x24,
+0xE4,0x08,0x04,0x24,
+0x34,0x1C,0x43,0xAC,
+0x48,0x08,0x03,0x24,
+0x38,0x1C,0x44,0xAC,
+0x44,0x1C,0x43,0xAC,
+0x7C,0x08,0x04,0x24,
+0x0C,0x08,0x03,0x24,
+0x48,0x1C,0x44,0xAC,
+0x4C,0x1C,0x43,0xAC,
+0x18,0x08,0x04,0x24,
+0x30,0x08,0x03,0x24,
+0x50,0x1C,0x44,0xAC,
+0x54,0x1C,0x43,0xAC,
+0x34,0x08,0x04,0x24,
+0x5C,0x08,0x03,0x24,
+0x58,0x1C,0x44,0xAC,
+0x5C,0x1C,0x43,0xAC,
+0x60,0x0C,0x04,0x24,
+0x64,0x0C,0x03,0x24,
+0x60,0x1C,0x44,0xAC,
+0x64,0x1C,0x43,0xAC,
+0x24,0x0C,0x04,0x24,
+0x20,0x0C,0x03,0x24,
+0x68,0x08,0x05,0x24,
+0x68,0x1C,0x44,0xAC,
+0x6C,0x1C,0x43,0xAC,
+0x90,0x0C,0x04,0x24,
+0x94,0x0C,0x03,0x24,
+0x31,0x1C,0x47,0xA0,
+0x40,0x1C,0x45,0xAC,
+0x70,0x1C,0x44,0xAC,
+0x74,0x1C,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x3C,0x1C,0x45,0xAC,
+0xA2,0x45,0x00,0x08,
+0x21,0x18,0x00,0x00,
+0x20,0x00,0x62,0x2C,
+0x06,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x06,0x10,0x64,0x00,
+0x01,0x00,0x42,0x30,
+0xFA,0xFF,0x40,0x10,
+0x01,0x00,0x63,0x24,
+0xFF,0xFF,0x63,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x25,0xB0,0x02,0x3C,
+0x21,0x88,0xA0,0x00,
+0xFF,0xFF,0x03,0x24,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x21,0x98,0xC0,0x00,
+0x21,0x28,0xC0,0x00,
+0x21,0x90,0x80,0x00,
+0x09,0x00,0x23,0x12,
+0x21,0x80,0x82,0x00,
+0x00,0x00,0x10,0x8E,
+0x9D,0x45,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x27,0x28,0x11,0x00,
+0x24,0x28,0xB0,0x00,
+0x04,0x10,0x53,0x00,
+0x25,0x28,0xA2,0x00,
+0x21,0x20,0x40,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xDB,0x44,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x21,0x30,0x80,0x00,
+0x74,0x3B,0x44,0x8C,
+0xA9,0x45,0x00,0x08,
+0xFF,0xFF,0x05,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x90,0x8C,
+0x21,0x88,0xA0,0x00,
+0x9D,0x45,0x00,0x0C,
+0x21,0x20,0xA0,0x00,
+0x24,0x80,0x11,0x02,
+0x06,0x10,0x50,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x20,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x31,0x26,
+0x58,0x1C,0x23,0x8E,
+0x25,0xB0,0x02,0x3C,
+0x24,0x08,0x53,0x8C,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x70,0x8C,
+0x7F,0x80,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xFF,0x7F,0x05,0x3C,
+0x24,0x80,0x02,0x02,
+0xC0,0x25,0x04,0x00,
+0xFF,0xFF,0xA5,0x34,
+0x24,0x28,0x65,0x02,
+0x25,0x80,0x04,0x02,
+0xDB,0x44,0x00,0x0C,
+0x24,0x08,0x04,0x24,
+0x25,0x22,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x00,0x80,0x12,0x3C,
+0x58,0x1C,0x24,0x8E,
+0x25,0x80,0x12,0x02,
+0xDB,0x44,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0x25,0x22,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x25,0x28,0x72,0x02,
+0xDB,0x44,0x00,0x0C,
+0x24,0x08,0x04,0x24,
+0x25,0x22,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x78,0x1C,0x24,0x8E,
+0x0F,0x00,0x05,0x3C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFF,0xFF,0xA5,0x34,
+0xCB,0x45,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x30,0x1F,0x27,0x26,
+0x33,0x1C,0xE5,0x90,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x2C,0x18,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x02,0x00,0x06,0x24,
+0x00,0x00,0x43,0xAC,
+0x34,0x00,0xA6,0x10,
+0x21,0x80,0x80,0x00,
+0x03,0x00,0x03,0x24,
+0x3A,0x00,0xA3,0x10,
+0x2E,0x00,0x02,0x2E,
+0x10,0x00,0x02,0x2E,
+0x07,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x04,0x32,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xDC,0x45,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xFA,0xFF,0xA6,0x14,
+0xFF,0x00,0x04,0x32,
+0x31,0x1C,0xE4,0x90,
+0x01,0x00,0x02,0x24,
+0x33,0x00,0x82,0x10,
+0x02,0x00,0x82,0x28,
+0x38,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x38,0x00,0x85,0x10,
+0x30,0x1F,0x22,0x26,
+0x2E,0x00,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0xCB,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0xFF,0xFC,0x06,0x3C,
+0xFF,0xFF,0xC6,0x34,
+0x24,0x30,0x46,0x00,
+0x00,0x08,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x30,0x1F,0x22,0x26,
+0x31,0x1C,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x07,0x00,0x83,0x10,
+0x02,0x00,0x82,0x28,
+0x2C,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x2C,0x00,0x82,0x10,
+0x03,0x00,0x02,0x24,
+0xDB,0xFF,0x82,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x21,0x46,0x00,0x08,
+0xFF,0x00,0x04,0x32,
+0x25,0x00,0x82,0x2C,
+0xCC,0xFF,0x40,0x14,
+0x03,0x00,0x03,0x24,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC7,0xFF,0x40,0x14,
+0x10,0x00,0x02,0x2E,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0x33,0x46,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xCC,0xFF,0x80,0x14,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0x33,0x46,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xB2,0xFF,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x21,0x46,0x00,0x08,
+0xFF,0x00,0x04,0x32,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x02,0x80,0x11,0x3C,
+0x30,0x1F,0x28,0x26,
+0x33,0x1C,0x06,0x91,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xD8,0x19,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x02,0x00,0x07,0x24,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x00,0x00,0x43,0xAC,
+0x21,0x90,0xA0,0x00,
+0x39,0x00,0xC7,0x10,
+0xFF,0x00,0x90,0x30,
+0x03,0x00,0x03,0x24,
+0x3F,0x00,0xC3,0x10,
+0x2E,0x00,0x02,0x2E,
+0x10,0x00,0x02,0x2E,
+0x0C,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x04,0x3C,
+0xFF,0xFF,0x84,0x34,
+0x24,0x20,0x44,0x02,
+0x00,0x15,0x10,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x25,0x20,0x44,0x00,
+0xC6,0x45,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0xF5,0xFF,0xC7,0x14,
+0x0F,0x00,0x04,0x3C,
+0x31,0x1C,0x04,0x91,
+0x01,0x00,0x02,0x24,
+0x33,0x00,0x82,0x10,
+0x02,0x00,0x82,0x28,
+0x38,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x38,0x00,0x86,0x10,
+0x30,0x1F,0x22,0x26,
+0x2E,0x00,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0xCB,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0xFF,0xFC,0x06,0x3C,
+0xFF,0xFF,0xC6,0x34,
+0x24,0x30,0x46,0x00,
+0x00,0x08,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x30,0x1F,0x22,0x26,
+0x31,0x1C,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x07,0x00,0x83,0x10,
+0x02,0x00,0x82,0x28,
+0x2C,0x00,0x40,0x14,
+0x02,0x00,0x02,0x24,
+0x2C,0x00,0x82,0x10,
+0x03,0x00,0x02,0x24,
+0xD6,0xFF,0x82,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x8E,0x46,0x00,0x08,
+0x0F,0x00,0x04,0x3C,
+0x25,0x00,0x02,0x2E,
+0xC7,0xFF,0x40,0x14,
+0x03,0x00,0x03,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC1,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0xA5,0x46,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xCC,0xFF,0x80,0x14,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x0F,0x00,0x06,0x24,
+0xA5,0x46,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0xAD,0xFF,0x80,0x14,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x22,0x26,
+0x34,0x1C,0x44,0x8C,
+0x0F,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x8E,0x46,0x00,0x08,
+0x0F,0x00,0x04,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x14,0x00,0xBF,0xAF,
+0xDC,0x45,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x40,0x01,0x44,0x34,
+0x21,0x18,0x40,0x00,
+0x1F,0x00,0x02,0x2E,
+0x00,0x23,0x04,0x00,
+0x10,0x00,0x40,0x10,
+0x10,0x00,0x05,0x2E,
+0x00,0x01,0x64,0x34,
+0x06,0x00,0xA0,0x10,
+0x00,0x23,0x04,0x00,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xC6,0x45,0x00,0x0C,
+0xF1,0xFF,0x10,0x26,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xC6,0x45,0x00,0x0C,
+0xE2,0xFF,0x10,0x26,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x90,0x8C,
+0x21,0x88,0xA0,0x00,
+0x9D,0x45,0x00,0x0C,
+0x21,0x20,0xA0,0x00,
+0x24,0x80,0x11,0x02,
+0x06,0x10,0x50,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x18,0x00,0xB2,0xAF,
+0x21,0x90,0x82,0x00,
+0xFF,0xFF,0x02,0x24,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x88,0xA0,0x00,
+0x21,0x20,0xA0,0x00,
+0x21,0x18,0x40,0x02,
+0x10,0x00,0xA2,0x10,
+0x21,0x98,0xC0,0x00,
+0x00,0x00,0x50,0x8E,
+0x9D,0x45,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x27,0x18,0x11,0x00,
+0x24,0x18,0x70,0x00,
+0x04,0x10,0x53,0x00,
+0x25,0x18,0x62,0x00,
+0x00,0x00,0x43,0xAE,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x28,0x00,0xBD,0x27,
+0x00,0x00,0x66,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x38,0x82,0x00,
+0xFF,0xFF,0x02,0x24,
+0x27,0x40,0x05,0x00,
+0x08,0x00,0xA2,0x10,
+0x24,0x18,0xC5,0x00,
+0x00,0x00,0xE2,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x02,0x01,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0xE2,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE6,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x38,0xA0,0x00,
+0x25,0xB0,0x02,0x3C,
+0xFF,0xFF,0x03,0x24,
+0x27,0x48,0x05,0x00,
+0x24,0x40,0xC7,0x00,
+0x21,0x28,0xC0,0x00,
+0x05,0x00,0xE3,0x10,
+0x21,0x30,0x82,0x00,
+0x00,0x00,0xC5,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x28,0x25,0x01,
+0x25,0x28,0xA8,0x00,
+0xDB,0x44,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xD8,0xFF,0xBD,0x27,
+0x7C,0x1D,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x62,0xAC,
+0x21,0x88,0xA0,0x00,
+0x21,0x98,0xC0,0x00,
+0x21,0xA0,0x80,0x00,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x0F,0x00,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x0A,0x00,0x22,0x12,
+0x21,0x28,0xC0,0x00,
+0x0B,0x46,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x20,0x02,
+0x9D,0x45,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x27,0x28,0x11,0x00,
+0x24,0x28,0xB0,0x00,
+0x04,0x10,0x53,0x00,
+0x25,0x28,0xA2,0x00,
+0x76,0x46,0x00,0x0C,
+0xFF,0x00,0x84,0x32,
+0x00,0x60,0x92,0x40,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x01,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x28,0x1E,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0xE0,0xFF,0xBD,0x27,
+0x00,0x00,0x43,0xAC,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x0B,0x46,0x00,0x0C,
+0x21,0x88,0xA0,0x00,
+0x21,0x80,0x40,0x00,
+0x9D,0x45,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x24,0x80,0x11,0x02,
+0x06,0x10,0x50,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x24,0x00,0xB5,0xAF,
+0xFF,0x00,0x84,0x30,
+0x21,0xA8,0xC0,0x00,
+0x28,0x00,0xB6,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0xB0,0xA0,0x00,
+0xE6,0x44,0x00,0x0C,
+0x21,0x98,0x00,0x00,
+0x21,0x00,0xA0,0x16,
+0x80,0x10,0x13,0x00,
+0xDD,0x47,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xFD,0x00,0x02,0x24,
+0x23,0x00,0x02,0x12,
+0x05,0x00,0x04,0x24,
+0xFC,0x00,0x02,0x24,
+0x37,0x00,0x02,0x12,
+0x00,0x00,0x00,0x00,
+0xFB,0x00,0x02,0x24,
+0x30,0x00,0x02,0x12,
+0x32,0x00,0x04,0x24,
+0xFA,0x00,0x02,0x24,
+0x2D,0x00,0x02,0x12,
+0x05,0x00,0x04,0x24,
+0xF9,0x00,0x02,0x24,
+0x29,0x00,0x02,0x12,
+0x0F,0x00,0x05,0x3C,
+0x04,0x00,0xD1,0x8C,
+0xFF,0xFF,0xA5,0x34,
+0x21,0x20,0x00,0x02,
+0x5F,0x47,0x00,0x0C,
+0x21,0x30,0x20,0x02,
+0x25,0x22,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x19,0x00,0x02,0x24,
+0x28,0x00,0x02,0x12,
+0x21,0x90,0x00,0x00,
+0x02,0x00,0x62,0x26,
+0xFF,0x00,0x53,0x30,
+0x2B,0x18,0x75,0x02,
+0x0F,0x00,0x60,0x10,
+0x80,0x10,0x13,0x00,
+0x21,0x30,0x56,0x00,
+0x00,0x00,0xD0,0x8C,
+0xFF,0x00,0x02,0x24,
+0x0A,0x00,0x02,0x12,
+0xFE,0x00,0x02,0x24,
+0xDC,0xFF,0x02,0x16,
+0x32,0x00,0x04,0x24,
+0x25,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x62,0x26,
+0xFF,0x00,0x53,0x30,
+0x2B,0x18,0x75,0x02,
+0xF3,0xFF,0x60,0x14,
+0x80,0x10,0x13,0x00,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x01,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xCB,0x47,0x00,0x08,
+0x02,0x00,0x62,0x26,
+0x25,0x22,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xD9,0x47,0x00,0x08,
+0x02,0x00,0x62,0x26,
+0x0F,0x00,0x14,0x3C,
+0x21,0x20,0x00,0x02,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x85,0x36,
+0x21,0x20,0x00,0x02,
+0xFF,0xFF,0x85,0x36,
+0xD2,0xFF,0x51,0x10,
+0x21,0x30,0x20,0x02,
+0x5F,0x47,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x25,0x22,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x01,0x00,0x42,0x26,
+0xFF,0x00,0x52,0x30,
+0x0A,0x00,0x43,0x2E,
+0xF2,0xFF,0x60,0x14,
+0x21,0x20,0x00,0x02,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xB8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x30,0x1F,0x57,0x24,
+0x64,0x37,0xE3,0x96,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x05,0x3C,
+0x25,0xA0,0x62,0x00,
+0xF0,0xDD,0xA5,0x24,
+0x24,0x00,0x84,0x26,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x02,0x3C,
+0x20,0x00,0x80,0xA6,
+0x10,0x52,0x00,0x0C,
+0x84,0x58,0x56,0x24,
+0x02,0x80,0x05,0x3C,
+0x18,0x3B,0xA5,0x24,
+0x2A,0x00,0x84,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x88,0x58,0xA5,0x24,
+0x06,0x00,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0x30,0x00,0x84,0x26,
+0x20,0x00,0x83,0x96,
+0x74,0x00,0xD0,0x26,
+0x21,0x20,0x00,0x02,
+0x03,0xFF,0x63,0x30,
+0x80,0x00,0x63,0x34,
+0x20,0x00,0x83,0xA6,
+0x20,0x00,0x1E,0x24,
+0x40,0x00,0x93,0x26,
+0x17,0x4F,0x00,0x0C,
+0x1C,0x00,0xBE,0xAF,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0x60,0x02,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x1C,0x00,0xA2,0x8F,
+0x21,0x20,0x00,0x02,
+0x42,0x00,0x93,0x26,
+0x02,0x00,0x42,0x24,
+0x32,0x4F,0x00,0x0C,
+0x1C,0x00,0xA2,0xAF,
+0x21,0x28,0x40,0x00,
+0x21,0x20,0x60,0x02,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x1C,0x00,0xA2,0x8F,
+0x0C,0x00,0xC6,0x8E,
+0x1C,0x00,0xB0,0x27,
+0x21,0x28,0x00,0x00,
+0x10,0x00,0xC7,0x26,
+0x02,0x00,0x42,0x24,
+0x44,0x00,0x84,0x26,
+0x60,0x00,0xD1,0x26,
+0x1C,0x00,0xA2,0xAF,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x20,0x02,
+0x37,0x50,0x00,0x0C,
+0x21,0x98,0x40,0x00,
+0x09,0x00,0x52,0x2C,
+0x08,0x00,0x06,0x24,
+0x21,0x20,0x60,0x02,
+0x0B,0x30,0x52,0x00,
+0x21,0x38,0x20,0x02,
+0x01,0x00,0x05,0x24,
+0x21,0xA8,0x40,0x00,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x40,0x00,
+0x03,0x00,0x05,0x24,
+0x01,0x00,0x06,0x24,
+0x48,0x00,0xC7,0x26,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x21,0x20,0x40,0x00,
+0x06,0x00,0x05,0x24,
+0x02,0x00,0x06,0x24,
+0x18,0x00,0xA7,0x27,
+0x18,0x00,0xA0,0xA7,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xA5,0x97,
+0x02,0x80,0x04,0x3C,
+0x68,0xDF,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x21,0x98,0x40,0x00,
+0x13,0x00,0x40,0x12,
+0x21,0x20,0x60,0x02,
+0x1C,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x24,
+0x01,0x01,0x42,0x2C,
+0x18,0x00,0x40,0x14,
+0x21,0x20,0x80,0x02,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xF8,0xFF,0xA6,0x26,
+0x68,0x00,0xC7,0x26,
+0x32,0x00,0x05,0x24,
+0x41,0x4F,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x24,
+0x01,0x01,0x42,0x2C,
+0xEA,0xFF,0x40,0x10,
+0x21,0x20,0x80,0x02,
+0x21,0x28,0x00,0x00,
+0x08,0x52,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0x08,0x00,0x84,0x8E,
+0x04,0x00,0x85,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0x10,0x00,0x86,0x8E,
+0x14,0x00,0x87,0x8E,
+0xFF,0xFF,0x42,0x34,
+0x1C,0x00,0xA8,0x8F,
+0x24,0x20,0x82,0x00,
+0x00,0x40,0x03,0x3C,
+0xFF,0xE0,0x02,0x24,
+0x24,0x28,0xA2,0x00,
+0x25,0x20,0x83,0x00,
+0x00,0x80,0x02,0x3C,
+0xFF,0x81,0x03,0x24,
+0x24,0x38,0xE3,0x00,
+0x25,0x30,0xC2,0x00,
+0x00,0x10,0xA5,0x34,
+0x80,0x00,0x84,0x34,
+0x08,0x00,0x84,0xAE,
+0x00,0x00,0x88,0xA6,
+0x02,0x00,0x9E,0xA2,
+0x14,0x00,0x87,0xAE,
+0x04,0x00,0x85,0xAE,
+0x10,0x00,0x86,0xAE,
+0xF8,0x36,0xE6,0x8E,
+0x64,0x37,0xE5,0x8E,
+0x01,0x00,0x04,0x24,
+0x00,0x01,0x07,0x24,
+0x01,0x00,0x02,0x24,
+0x73,0x01,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0xB0,0x01,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x25,0x24,0x00,0x0C,
+0x24,0x00,0x04,0x24,
+0x21,0x30,0x40,0x00,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x50,0x24,
+0x21,0x20,0xC0,0x00,
+0x13,0x00,0xC0,0x10,
+0x48,0xEA,0xA5,0x24,
+0x04,0x00,0x02,0x24,
+0x09,0x00,0x03,0x24,
+0x0C,0x00,0xC2,0xAC,
+0x14,0x00,0xC3,0xAC,
+0x08,0x00,0xC5,0x94,
+0xA4,0x3B,0x03,0x8E,
+0x02,0x80,0x02,0x3C,
+0x25,0x28,0xA2,0x00,
+0x30,0x09,0x00,0x0C,
+0x20,0x00,0xA3,0xAC,
+0xA8,0x3B,0x06,0x8E,
+0xA4,0x3B,0x05,0x8E,
+0x02,0x80,0x04,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x80,0xDF,0x84,0x24,
+0x2F,0x55,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x74,0xDF,0x84,0x24,
+0x2F,0x55,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x12,0x3C,
+0x30,0x1F,0x51,0x26,
+0xB0,0x1B,0x25,0x96,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x80,0x44,0x00,
+0x00,0x01,0xA3,0x30,
+0x04,0x00,0x60,0x10,
+0x18,0x00,0x04,0x26,
+0x00,0x10,0xA2,0x30,
+0x0B,0x00,0x40,0x10,
+0x04,0x00,0xA2,0x30,
+0x21,0x18,0x00,0x00,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xF5,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x55,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x18,0x3B,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xED,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x88,0x58,0x53,0x24,
+0x22,0x00,0x14,0x26,
+0x21,0x20,0x80,0x02,
+0x21,0x28,0x60,0x02,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xE4,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x28,0x00,0x04,0x26,
+0x21,0x28,0x60,0x02,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xDE,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0xE8,0xDF,0x84,0x24,
+0xB0,0x1B,0x24,0x96,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x83,0x30,
+0x01,0x00,0x62,0x30,
+0x08,0x00,0x40,0x10,
+0x00,0x20,0x62,0x30,
+0x15,0x00,0x40,0x10,
+0xFF,0xDE,0x82,0x30,
+0xFE,0xFF,0x04,0x24,
+0xB0,0x1B,0x22,0xA6,
+0xD0,0x38,0x20,0xAE,
+0x48,0x0E,0x00,0x0C,
+0xB4,0x38,0x20,0xAE,
+0x25,0xB0,0x02,0x3C,
+0x30,0x1F,0x50,0x26,
+0x4C,0x00,0x42,0x34,
+0x00,0x00,0x40,0xA0,
+0x21,0x20,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x12,0x0D,0x00,0x0C,
+0xA1,0x3B,0x00,0xA2,
+0x10,0x3E,0x00,0xAE,
+0xEC,0x38,0x00,0xAE,
+0x08,0x39,0x00,0xAE,
+0xA3,0x51,0x00,0x0C,
+0x50,0x3E,0x00,0xAE,
+0xFA,0x48,0x00,0x08,
+0x21,0x18,0x00,0x00,
+0x76,0x0E,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0xBB,0xFF,0x40,0x14,
+0xFF,0xFF,0x03,0x24,
+0xB0,0x1B,0x22,0x96,
+0x00,0x00,0x00,0x00,
+0xFF,0xFE,0x42,0x30,
+0x2D,0x49,0x00,0x08,
+0xB0,0x1B,0x22,0xA6,
+0xD0,0xFF,0xBD,0x27,
+0x20,0x00,0xB4,0xAF,
+0x02,0x80,0x14,0x3C,
+0x14,0x00,0xB1,0xAF,
+0x28,0x00,0xBF,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x91,0x26,
+0xB0,0x1B,0x23,0x96,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x62,0x30,
+0x3A,0x00,0x40,0x14,
+0x00,0x01,0x62,0x30,
+0x2E,0x00,0x40,0x10,
+0x00,0x10,0x62,0x30,
+0x29,0x00,0x40,0x14,
+0x01,0x00,0x62,0x30,
+0x1D,0x00,0x40,0x14,
+0x04,0x00,0x62,0x30,
+0x25,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x21,0x90,0x20,0x02,
+0x2B,0x3D,0x55,0x24,
+0x01,0x00,0x13,0x24,
+0xF0,0x00,0x10,0x24,
+0x65,0x49,0x00,0x08,
+0x19,0x00,0x11,0x24,
+0xFF,0xFF,0x31,0x26,
+0x1C,0x00,0x20,0x06,
+0x28,0x00,0x10,0x26,
+0x21,0x18,0x12,0x02,
+0xFA,0x1D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xF9,0xFF,0x53,0x14,
+0x00,0x00,0x00,0x00,
+0x0C,0x1E,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x33,0x00,0x40,0x10,
+0x21,0x20,0x15,0x02,
+0x00,0x60,0x02,0x40,
+0x01,0x00,0x41,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x0C,0x1E,0x60,0xAC,
+0x00,0x60,0x82,0x40,
+0x63,0x49,0x00,0x08,
+0xFF,0xFF,0x31,0x26,
+0xD4,0x1E,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x2F,0x00,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x00,0x60,0x02,0x40,
+0x01,0x00,0x41,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0xD4,0x1E,0x20,0xAE,
+0x00,0x60,0x82,0x40,
+0x53,0x1E,0x00,0x0C,
+0x30,0x1F,0x90,0x26,
+0xEC,0x38,0x02,0xAE,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0xF8,0xDF,0x84,0x24,
+0xB0,0x1B,0x22,0x96,
+0xEC,0x38,0x20,0xAE,
+0xFD,0xFF,0x04,0x24,
+0xEF,0xDF,0x42,0x30,
+0x48,0x0E,0x00,0x0C,
+0xB0,0x1B,0x22,0xA6,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x8E,0x3E,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x42,0x24,
+0x8E,0x3E,0x42,0xA2,
+0x76,0x0E,0x00,0x0C,
+0xFA,0x1D,0x60,0xA0,
+0x63,0x49,0x00,0x08,
+0xFF,0xFF,0x31,0x26,
+0x2F,0x55,0x00,0x0C,
+0x18,0xE0,0x84,0x24,
+0xB0,0x1B,0x23,0x96,
+0x25,0xB0,0x02,0x3C,
+0x4C,0x00,0x42,0x34,
+0xFE,0xFE,0x63,0x30,
+0xB0,0x1B,0x23,0xA6,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x40,0xA0,
+0x21,0x28,0x00,0x00,
+0xA1,0x3B,0x20,0xA2,
+0x12,0x0D,0x00,0x0C,
+0xC2,0x1E,0x20,0xA2,
+0x02,0x80,0x04,0x3C,
+0x76,0x0E,0x00,0x0C,
+0x88,0x58,0x84,0x24,
+0x83,0x49,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xA8,0xFF,0xBD,0x27,
+0x48,0x00,0xB6,0xAF,
+0x3C,0x00,0xB3,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x30,0x00,0xB0,0xAF,
+0x54,0x00,0xBF,0xAF,
+0x50,0x00,0xBE,0xAF,
+0x4C,0x00,0xB7,0xAF,
+0x44,0x00,0xB5,0xAF,
+0x40,0x00,0xB4,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x02,0x00,0x82,0x90,
+0x00,0x00,0x83,0x8C,
+0x21,0xB0,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x80,0x44,0x00,
+0x18,0x00,0x12,0x26,
+0x21,0x20,0x40,0x02,
+0x55,0x50,0x00,0x0C,
+0xFF,0x3F,0x73,0x30,
+0x02,0x80,0x04,0x3C,
+0x18,0x3B,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x0B,0x00,0x40,0x14,
+0x02,0x80,0x15,0x3C,
+0x30,0x1F,0xB1,0x26,
+0xB0,0x1B,0x23,0x96,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x62,0x30,
+0x05,0x00,0x40,0x10,
+0x00,0x10,0x62,0x30,
+0x03,0x00,0x40,0x14,
+0x00,0x01,0x62,0x30,
+0x0E,0x00,0x40,0x10,
+0x20,0x00,0xB4,0x27,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0x32,0x00,0x05,0x26,
+0x21,0x20,0x80,0x02,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x20,0x00,0xA5,0x97,
+0x00,0x00,0x00,0x00,
+0xC2,0x00,0xA0,0x14,
+0x02,0x80,0x04,0x3C,
+0x21,0x20,0x80,0x02,
+0x34,0x00,0x05,0x26,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x20,0x00,0xA2,0x97,
+0x21,0x20,0x80,0x02,
+0x30,0x00,0x05,0x26,
+0xFF,0x3F,0x42,0x30,
+0x02,0x00,0x06,0x24,
+0x50,0x39,0x22,0xA6,
+0x10,0x52,0x00,0x0C,
+0x28,0x00,0xA2,0xAF,
+0x20,0x00,0xA3,0x97,
+0x21,0x40,0x20,0x02,
+0x00,0x04,0x63,0x30,
+0x02,0x00,0x60,0x14,
+0x09,0x00,0x02,0x24,
+0x14,0x00,0x02,0x24,
+0x1E,0x00,0x5E,0x26,
+0xE2,0xFF,0x74,0x26,
+0x21,0x20,0xC0,0x03,
+0x01,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x21,0x38,0x80,0x02,
+0x55,0x1D,0x00,0x0C,
+0x0C,0x3E,0x02,0xA1,
+0xA8,0x00,0x40,0x10,
+0x02,0x00,0x45,0x24,
+0x24,0x00,0xA6,0x8F,
+0x10,0x52,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x21,0x20,0xC0,0x03,
+0x32,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x24,0x00,0xB7,0x8F,
+0x55,0x1D,0x00,0x0C,
+0x21,0x38,0x80,0x02,
+0x08,0x00,0x40,0x10,
+0x10,0x00,0xA4,0x27,
+0x24,0x00,0xA6,0x8F,
+0x21,0x20,0x97,0x00,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0x24,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0xB8,0xE3,0x02,
+0x02,0x80,0x02,0x3C,
+0xEA,0x5D,0x44,0x90,
+0x02,0x00,0x03,0x24,
+0xE5,0x00,0x83,0x10,
+0x21,0x20,0xC0,0x03,
+0x30,0x1F,0xA4,0x26,
+0x10,0x3E,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x22,0x00,0x40,0x10,
+0x30,0x1F,0xB1,0x26,
+0x02,0x80,0x02,0x3C,
+0xE6,0x5D,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x1D,0x00,0x60,0x14,
+0x23,0x10,0xD2,0x03,
+0x2B,0x10,0x53,0x00,
+0x1A,0x00,0x40,0x10,
+0x21,0x80,0xC0,0x03,
+0x02,0x80,0x11,0x3C,
+0x21,0x20,0x00,0x02,
+0xDD,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x55,0x1D,0x00,0x0C,
+0x21,0x38,0x80,0x02,
+0x21,0x80,0x40,0x00,
+0x02,0x00,0x44,0x24,
+0xC8,0xDD,0x25,0x26,
+0x0E,0x01,0x40,0x10,
+0x06,0x00,0x06,0x24,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x01,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x24,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x02,0x02,
+0x02,0x00,0x70,0x24,
+0x23,0x20,0x12,0x02,
+0x03,0x01,0x40,0x10,
+0x2B,0x20,0x93,0x00,
+0xEB,0xFF,0x80,0x14,
+0x21,0x20,0x00,0x02,
+0x30,0x1F,0xB1,0x26,
+0x50,0x3E,0x22,0x8E,
+0x00,0x00,0x00,0x00,
+0x6A,0x00,0x40,0x14,
+0x24,0x00,0xA6,0x27,
+0x53,0x1E,0x00,0x0C,
+0x30,0x1F,0xB2,0x26,
+0x25,0xB0,0x14,0x3C,
+0xB0,0x1B,0x45,0x96,
+0x02,0x00,0x03,0x24,
+0x4C,0x00,0x84,0x36,
+0x00,0x00,0x83,0xA0,
+0xEC,0x38,0x42,0xAE,
+0x02,0x00,0x02,0x3C,
+0x00,0x01,0xA5,0x34,
+0x20,0xBF,0x42,0x34,
+0x08,0x39,0x42,0xAE,
+0x21,0x0E,0x00,0x0C,
+0xB0,0x1B,0x45,0xA6,
+0x10,0x00,0xA4,0x27,
+0x7D,0x50,0x00,0x0C,
+0x21,0x28,0xE0,0x02,
+0x0F,0x00,0x50,0x30,
+0x10,0x00,0xA4,0x27,
+0x96,0x50,0x00,0x0C,
+0x21,0x28,0xE0,0x02,
+0x40,0x02,0x13,0x36,
+0x02,0x80,0x04,0x3C,
+0x21,0x88,0x40,0x00,
+0x21,0x30,0x40,0x00,
+0x21,0x28,0x60,0x02,
+0x2F,0x55,0x00,0x0C,
+0x6C,0xE0,0x84,0x24,
+0x21,0x20,0x60,0x02,
+0xC1,0x5B,0x00,0x0C,
+0x21,0x28,0x20,0x02,
+0x21,0x28,0xE0,0x02,
+0xC2,0x50,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x21,0x88,0x40,0x00,
+0x50,0x3E,0x42,0x8E,
+0x00,0x00,0x00,0x00,
+0x16,0x00,0x40,0x10,
+0x50,0x00,0x13,0x36,
+0x5B,0x3E,0x42,0x92,
+0x5C,0x3E,0x43,0x92,
+0x0A,0x3E,0x44,0x92,
+0x00,0x13,0x02,0x00,
+0x00,0x1D,0x03,0x00,
+0x25,0x10,0x43,0x00,
+0x04,0x00,0x03,0x24,
+0xA0,0x00,0x83,0x10,
+0x25,0x88,0x22,0x02,
+0x54,0x3E,0x43,0x8E,
+0x00,0x00,0x00,0x00,
+0x07,0x00,0x60,0x14,
+0x01,0x00,0x02,0x24,
+0x58,0x3E,0x42,0x96,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0x42,0x30,
+0xA1,0x00,0x40,0x14,
+0x00,0x10,0x02,0x3C,
+0x01,0x00,0x02,0x24,
+0x98,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x80,0xE0,0x84,0x24,
+0x21,0x28,0x60,0x02,
+0x21,0x38,0xC0,0x02,
+0x2F,0x55,0x00,0x0C,
+0x21,0x30,0x20,0x02,
+0x21,0x20,0x60,0x02,
+0xC1,0x5B,0x00,0x0C,
+0x21,0x28,0x20,0x02,
+0x30,0x1F,0xA2,0x26,
+0xB0,0x1B,0x43,0x94,
+0x0A,0x3E,0x44,0x90,
+0xB4,0x38,0x40,0xAC,
+0xFF,0xDF,0x63,0x30,
+0xB0,0x1B,0x43,0xA4,
+0x04,0x00,0x03,0x24,
+0xD0,0x38,0x40,0xAC,
+0x94,0x3E,0x40,0xAC,
+0x06,0x00,0x83,0x10,
+0x98,0x3E,0x40,0xAC,
+0x28,0x00,0xA4,0x8F,
+0x48,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE2,0x49,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x06,0x3C,
+0x64,0x03,0xC6,0x34,
+0x30,0x1F,0xA4,0x8E,
+0x00,0x00,0xC5,0x90,
+0x0F,0xFF,0x02,0x24,
+0xFD,0xFF,0x03,0x24,
+0x24,0x20,0x82,0x00,
+0x24,0x28,0xA3,0x00,
+0x30,0x1F,0xA4,0xAE,
+0x00,0x00,0xC5,0xA0,
+0x28,0x00,0xA4,0x8F,
+0x48,0x0E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE2,0x49,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x2F,0x55,0x00,0x0C,
+0x50,0xE0,0x84,0x24,
+0xFF,0xFF,0x02,0x24,
+0x99,0x4A,0x00,0x08,
+0x28,0x00,0xA2,0xAF,
+0x21,0x20,0xC0,0x03,
+0x2D,0x00,0x05,0x24,
+0x55,0x1D,0x00,0x0C,
+0x21,0x38,0x80,0x02,
+0x91,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x24,0x00,0xAB,0x8F,
+0x00,0x00,0x00,0x00,
+0x1F,0x00,0x60,0x19,
+0x21,0x40,0x00,0x00,
+0x02,0x00,0x49,0x24,
+0x21,0x50,0x20,0x02,
+0x02,0x00,0x0C,0x24,
+0xD5,0x4A,0x00,0x08,
+0x21,0x68,0x20,0x01,
+0x58,0x3E,0x82,0x90,
+0x00,0x00,0x23,0x91,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x43,0x00,
+0x58,0x3E,0x82,0xA0,
+0x01,0x00,0x08,0x25,
+0x2A,0x10,0x0B,0x01,
+0x11,0x00,0x40,0x10,
+0x01,0x00,0x29,0x25,
+0xF6,0xFF,0x0C,0x15,
+0x21,0x20,0x0A,0x01,
+0x5A,0x3E,0x43,0x91,
+0x00,0x00,0x25,0x91,
+0x02,0x00,0xA2,0x91,
+0x1C,0x00,0x64,0x30,
+0x1C,0x00,0xA5,0x30,
+0x03,0x00,0x42,0x30,
+0x03,0x00,0x63,0x30,
+0x2A,0x30,0x43,0x00,
+0x2A,0x38,0xA4,0x00,
+0x0A,0x10,0x66,0x00,
+0x0A,0x20,0xA7,0x00,
+0x25,0x10,0x44,0x00,
+0xD1,0x4A,0x00,0x08,
+0x5A,0x3E,0x42,0xA1,
+0x02,0x80,0x02,0x3C,
+0xDE,0x5D,0x43,0x90,
+0x02,0x80,0x02,0x3C,
+0x3C,0xE3,0x47,0x24,
+0x10,0x00,0x65,0x30,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x4C,0xE3,0x66,0x24,
+0x30,0x1F,0x44,0x24,
+0xF8,0x4A,0x00,0x08,
+0x21,0x40,0x00,0x00,
+0x00,0x00,0x43,0x90,
+0x5B,0x3E,0x82,0x90,
+0x01,0x00,0x08,0x25,
+0x24,0x10,0x43,0x00,
+0x5B,0x3E,0x82,0xA0,
+0x10,0x00,0x02,0x29,
+0x07,0x00,0x40,0x10,
+0x01,0x00,0x84,0x24,
+0x21,0x10,0x07,0x01,
+0xF6,0xFF,0xA0,0x14,
+0x21,0x18,0x06,0x01,
+0x00,0x00,0x63,0x90,
+0xF1,0x4A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0xC0,0x03,
+0x21,0x38,0x80,0x02,
+0x3D,0x00,0x05,0x24,
+0x55,0x1D,0x00,0x0C,
+0x24,0x00,0xA6,0x27,
+0x48,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x24,0x00,0xA6,0x8F,
+0x02,0x80,0x04,0x3C,
+0xA8,0x5D,0x84,0x24,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0x90,0x0D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x54,0x4A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x2A,0x00,0x05,0x24,
+0x24,0x00,0xA6,0x27,
+0x55,0x1D,0x00,0x0C,
+0x21,0x38,0x80,0x02,
+0x30,0x00,0x40,0x10,
+0x30,0x1F,0xA5,0x26,
+0x02,0x00,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x2B,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0xEB,0x5D,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x3E,0x00,0x83,0x10,
+0x30,0x1F,0xA2,0x26,
+0x10,0x23,0x43,0x8C,
+0xFF,0xEF,0x04,0x24,
+0x00,0x08,0x63,0x34,
+0x24,0x18,0x64,0x00,
+0x2A,0x4A,0x00,0x08,
+0x10,0x23,0x43,0xAC,
+0xF6,0x01,0x82,0x36,
+0x00,0x00,0x40,0xA4,
+0x91,0x4A,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0x58,0x3E,0x42,0x96,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x30,
+0x66,0xFF,0x40,0x10,
+0x02,0x80,0x04,0x3C,
+0x00,0x10,0x02,0x3C,
+0x25,0x88,0x22,0x02,
+0x0F,0x00,0x08,0x24,
+0x01,0x00,0x03,0x24,
+0x0C,0x00,0x02,0x25,
+0x04,0x10,0x43,0x00,
+0x24,0x10,0x51,0x00,
+0x16,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x08,0x25,
+0xFA,0xFF,0x01,0x05,
+0x0C,0x00,0x02,0x25,
+0x00,0x12,0x16,0x00,
+0x00,0x1B,0x16,0x00,
+0x25,0x18,0x62,0x00,
+0x00,0x21,0x16,0x00,
+0x25,0x18,0x64,0x00,
+0x25,0xB0,0x02,0x3C,
+0x25,0x18,0x76,0x00,
+0xF6,0x01,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x91,0x4A,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0x10,0x23,0xA2,0x8C,
+0xFF,0xF7,0x03,0x24,
+0xFF,0xEF,0x04,0x24,
+0x24,0x10,0x43,0x00,
+0x24,0x10,0x44,0x00,
+0x2A,0x4A,0x00,0x08,
+0x10,0x23,0xA2,0xAC,
+0x38,0x4B,0x00,0x08,
+0xFF,0x00,0x16,0x31,
+0x30,0x1F,0xA2,0x26,
+0x54,0x4A,0x00,0x08,
+0x50,0x3E,0x40,0xAC,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x4F,0x4A,0x00,0x08,
+0x10,0x3E,0x40,0xAC,
+0x54,0x4A,0x00,0x08,
+0x50,0x3E,0x20,0xAE,
+0x21,0x20,0x00,0x02,
+0x78,0x0F,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x50,0x4A,0x00,0x08,
+0x30,0x1F,0xB1,0x26,
+0x10,0x23,0x43,0x8C,
+0xFF,0xF7,0x04,0x24,
+0x24,0x18,0x64,0x00,
+0x00,0x10,0x63,0x34,
+0x2A,0x4A,0x00,0x08,
+0x10,0x23,0x43,0xAC,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x03,0x3C,
+0xE0,0x3A,0x65,0x94,
+0x0F,0x00,0x42,0x30,
+0x00,0x00,0x83,0x8C,
+0xC0,0x10,0x02,0x00,
+0x21,0x20,0x44,0x00,
+0x00,0x10,0xA8,0x30,
+0x02,0x80,0x02,0x3C,
+0x00,0x08,0xA5,0x30,
+0x84,0x58,0x51,0x24,
+0xFF,0x3F,0x63,0x30,
+0x06,0x00,0xA0,0x10,
+0x18,0x00,0x90,0x24,
+0xE8,0xFF,0x67,0x24,
+0x30,0x00,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0x07,0x00,0x00,0x11,
+0x10,0x00,0xA6,0x27,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x55,0x1D,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF7,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x44,0x24,
+0x10,0x00,0xA2,0x8F,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x10,
+0x10,0x00,0x25,0x26,
+0x0C,0x00,0x26,0x8E,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xED,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x42,0x50,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x01,0x10,0x00,0x0C,
+0x21,0x20,0x40,0x00,
+0x77,0x4B,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0xE5,0x48,0x00,0x0C,
+0xFE,0xFF,0x05,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0xE5,0x48,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x10,0x00,0xBF,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x01,0x80,0x02,0x3C,
+0xB0,0x03,0x65,0x34,
+0x8C,0x2E,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0xA4,0xAC,
+0x00,0x00,0x83,0x8C,
+0x21,0x10,0x00,0x00,
+0xFF,0x3F,0x63,0x30,
+0x00,0x00,0xA3,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x30,0x1F,0x50,0x24,
+0x70,0x3D,0x03,0x8E,
+0xFE,0xFF,0x04,0x24,
+0x01,0x00,0x63,0x24,
+0x05,0x00,0x62,0x2C,
+0x12,0x00,0x40,0x10,
+0x70,0x3D,0x03,0xAE,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x30,
+0x05,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xA5,0x12,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xC8,0x00,0x03,0x24,
+0xD0,0x38,0x03,0xAE,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0xFF,0xDF,0x42,0x30,
+0x48,0x0E,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x02,0x00,0x82,0x90,
+0x02,0x80,0x14,0x3C,
+0x30,0x1F,0x92,0x26,
+0xB0,0x1B,0x43,0x96,
+0x00,0x00,0x85,0x8C,
+0x0F,0x00,0x42,0x30,
+0xC0,0x10,0x02,0x00,
+0x21,0x80,0x44,0x00,
+0x01,0x00,0x63,0x30,
+0xFF,0x3F,0xB3,0x30,
+0x18,0x00,0x11,0x26,
+0x0A,0x00,0x60,0x14,
+0x21,0x20,0x00,0x00,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x55,0x50,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x02,0x80,0x04,0x3C,
+0x18,0x3B,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x39,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xEF,0xFF,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0xB0,0x1B,0x42,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x10,0x42,0x30,
+0xEA,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x03,0x96,
+0x04,0x00,0x04,0x24,
+0x21,0x10,0x80,0x00,
+0x00,0x40,0x63,0x30,
+0x0A,0x10,0x03,0x00,
+0x21,0x10,0x22,0x02,
+0x1C,0x00,0x43,0x94,
+0x1A,0x00,0x45,0x94,
+0x2F,0x00,0x60,0x14,
+0x02,0x00,0x02,0x24,
+0x14,0x00,0xA2,0x10,
+0x01,0x00,0x02,0x24,
+0x0E,0x00,0xA4,0x14,
+0x02,0x80,0x04,0x3C,
+0x78,0x3D,0x43,0x8E,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x62,0x10,
+0x30,0x1F,0x83,0x26,
+0xB0,0x1B,0x62,0x94,
+0xFF,0xFF,0x04,0x24,
+0xFF,0xDF,0x42,0x30,
+0xE9,0x4B,0x00,0x08,
+0xB0,0x1B,0x62,0xA4,
+0x84,0x14,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE9,0x4B,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x2F,0x55,0x00,0x0C,
+0xEC,0xE1,0x84,0x24,
+0x12,0x4C,0x00,0x08,
+0x30,0x1F,0x83,0x26,
+0x78,0x3D,0x43,0x8E,
+0x00,0x00,0x00,0x00,
+0xF5,0xFF,0x62,0x14,
+0xE2,0xFF,0x67,0x26,
+0x36,0x00,0x04,0x26,
+0x10,0x00,0x05,0x24,
+0x55,0x1D,0x00,0x0C,
+0x10,0x00,0xA6,0x27,
+0x16,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xA6,0x8F,
+0x02,0x80,0x04,0x3C,
+0xB8,0x5C,0x84,0x24,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x45,0x24,
+0xB0,0x1B,0x43,0x96,
+0x21,0x20,0x00,0x00,
+0x03,0x00,0x02,0x24,
+0xDF,0xFF,0x63,0x30,
+0x40,0x00,0x63,0x34,
+0xB0,0x1B,0x43,0xA6,
+0xBC,0x15,0x00,0x0C,
+0x74,0x3D,0x42,0xAE,
+0xE9,0x4B,0x00,0x08,
+0x21,0x20,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0xBC,0xE1,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x21,0x28,0x60,0x00,
+0x12,0x4C,0x00,0x08,
+0x30,0x1F,0x83,0x26,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0xD8,0xE1,0x84,0x24,
+0x12,0x4C,0x00,0x08,
+0x30,0x1F,0x83,0x26,
+0xE8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x30,0x1F,0x50,0x24,
+0x6C,0x3D,0x03,0x8E,
+0xFF,0xFF,0x04,0x24,
+0x01,0x00,0x63,0x24,
+0x05,0x00,0x62,0x2C,
+0x16,0x00,0x40,0x10,
+0x6C,0x3D,0x03,0xAE,
+0xB0,0x1B,0x03,0x96,
+0xBF,0xFF,0x02,0x24,
+0x21,0x20,0x00,0x00,
+0x24,0x10,0x62,0x00,
+0x80,0x00,0x63,0x30,
+0x05,0x00,0x60,0x10,
+0x20,0x00,0x45,0x34,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x01,0x00,0x02,0x24,
+0x74,0x3D,0x02,0xAE,
+0xBC,0x15,0x00,0x0C,
+0xB0,0x1B,0x05,0xA6,
+0xC8,0x00,0x03,0x24,
+0xB4,0x38,0x03,0xAE,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xB0,0x1B,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0xFF,0xDF,0x42,0x30,
+0x48,0x0E,0x00,0x0C,
+0xB0,0x1B,0x02,0xA6,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x21,0x90,0x80,0x00,
+0x00,0x01,0x04,0x24,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x21,0x98,0xA0,0x00,
+0x28,0x00,0xBF,0xAF,
+0x25,0x24,0x00,0x0C,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x21,0x88,0x40,0x00,
+0x20,0xE2,0x84,0x24,
+0x37,0x00,0x40,0x10,
+0x04,0xEB,0xA5,0x24,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x40,0x02,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0x20,0x00,0x00,0xA6,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x30,0x00,0x04,0x26,
+0x88,0x58,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x05,0x3C,
+0x03,0xFF,0x63,0x30,
+0xC0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x30,0x1F,0xA5,0x24,
+0x0C,0x00,0x22,0xAE,
+0xF8,0x1D,0xA3,0x94,
+0x20,0x00,0x07,0x26,
+0x38,0x00,0x04,0x26,
+0xFF,0x0F,0x62,0x30,
+0x00,0x11,0x02,0x00,
+0x02,0x32,0x02,0x00,
+0x01,0x00,0x63,0x24,
+0xF8,0x1D,0xA3,0xA4,
+0x17,0x00,0xE6,0xA0,
+0x16,0x00,0xE2,0xA0,
+0x10,0x00,0xA6,0x27,
+0x0C,0x00,0x27,0x26,
+0x02,0x00,0x05,0x24,
+0x68,0x4F,0x00,0x0C,
+0x10,0x00,0xB3,0xA7,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x00,0x00,
+0xB9,0x0C,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x14,0xE2,0x84,0x24,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x21,0x90,0x80,0x00,
+0x00,0x01,0x04,0x24,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x21,0x98,0xA0,0x00,
+0x28,0x00,0xBF,0xAF,
+0x25,0x24,0x00,0x0C,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x21,0x88,0x40,0x00,
+0x3C,0xE2,0x84,0x24,
+0x37,0x00,0x40,0x10,
+0x14,0xEB,0xA5,0x24,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x40,0x02,
+0x25,0x80,0x02,0x02,
+0x24,0x00,0x04,0x26,
+0x20,0x00,0x00,0xA6,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x04,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x30,0x00,0x04,0x26,
+0x88,0x58,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x03,0x96,
+0x18,0x00,0x02,0x24,
+0x02,0x80,0x05,0x3C,
+0x03,0xFF,0x63,0x30,
+0xA0,0x00,0x63,0x34,
+0x20,0x00,0x03,0xA6,
+0x30,0x1F,0xA5,0x24,
+0x0C,0x00,0x22,0xAE,
+0xF8,0x1D,0xA3,0x94,
+0x20,0x00,0x07,0x26,
+0x38,0x00,0x04,0x26,
+0xFF,0x0F,0x62,0x30,
+0x00,0x11,0x02,0x00,
+0x02,0x32,0x02,0x00,
+0x01,0x00,0x63,0x24,
+0xF8,0x1D,0xA3,0xA4,
+0x17,0x00,0xE6,0xA0,
+0x16,0x00,0xE2,0xA0,
+0x10,0x00,0xA6,0x27,
+0x0C,0x00,0x27,0x26,
+0x02,0x00,0x05,0x24,
+0x68,0x4F,0x00,0x0C,
+0x10,0x00,0xB3,0xA7,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x00,0x00,
+0xB9,0x0C,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x30,0xE2,0x84,0x24,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x2C,0x00,0xB1,0xAF,
+0xFF,0xFF,0x05,0x24,
+0x21,0x88,0x80,0x00,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA4,0x27,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x08,0x52,0x00,0x0C,
+0x28,0x00,0xB0,0xAF,
+0x08,0x00,0x30,0x96,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x00,0x00,
+0x25,0x80,0x02,0x02,
+0x21,0x20,0x00,0x02,
+0x08,0x52,0x00,0x0C,
+0x10,0x00,0x06,0x24,
+0x20,0x00,0x02,0x96,
+0x24,0x00,0x04,0x26,
+0x10,0x00,0xA5,0x27,
+0x03,0xFF,0x42,0x30,
+0xC8,0x00,0x42,0x34,
+0x20,0x00,0x02,0xA6,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x25,0xB0,0x03,0x3C,
+0x50,0x00,0x62,0x34,
+0x00,0x00,0x44,0x8C,
+0x54,0x00,0x65,0x34,
+0x58,0x00,0x66,0x34,
+0x18,0x00,0xA4,0xAF,
+0x00,0x00,0xA2,0x8C,
+0x5C,0x00,0x63,0x34,
+0x2A,0x00,0x04,0x26,
+0x1C,0x00,0xA2,0xAF,
+0x00,0x00,0xC7,0x8C,
+0x18,0x00,0xA5,0x27,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0xA7,0xAF,
+0x00,0x00,0x62,0x8C,
+0x1A,0x00,0x12,0x24,
+0x10,0x52,0x00,0x0C,
+0x24,0x00,0xA2,0xAF,
+0x30,0x00,0x04,0x26,
+0x20,0x00,0xA5,0x27,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x13,0x00,0x03,0x24,
+0x14,0x00,0x23,0xAE,
+0x0C,0x00,0x32,0xAE,
+0x08,0x00,0x05,0x8E,
+0x04,0x00,0x04,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0x14,0x00,0x06,0x8E,
+0xFF,0xFF,0x42,0x34,
+0x10,0x00,0x07,0x8E,
+0xFF,0xE0,0x03,0x24,
+0x24,0x28,0xA2,0x00,
+0x00,0x40,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0x25,0x28,0xA2,0x00,
+0xFF,0x81,0x03,0x24,
+0xFE,0xFF,0x02,0x3C,
+0x24,0x30,0xC3,0x00,
+0xFF,0xFF,0x42,0x34,
+0x00,0x12,0x84,0x34,
+0x00,0x80,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0x25,0x38,0xE3,0x00,
+0x00,0x26,0xC6,0x34,
+0x80,0x00,0xA5,0x34,
+0x20,0x00,0x02,0x24,
+0x00,0x00,0x12,0xA6,
+0x10,0x00,0x07,0xAE,
+0x02,0x00,0x02,0xA2,
+0x14,0x00,0x06,0xAE,
+0x04,0x00,0x04,0xAE,
+0x08,0x00,0x05,0xAE,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB1,0xAF,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x11,0x3C,
+0x18,0x03,0x23,0x36,
+0x80,0x35,0x42,0x24,
+0x28,0x00,0xB4,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x21,0xA0,0x80,0x00,
+0x48,0x00,0xB2,0x93,
+0xFF,0x00,0xE4,0x30,
+0x00,0x00,0x62,0xAC,
+0x24,0x00,0xB3,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0xFF,0x00,0xB3,0x30,
+0x0D,0x24,0x00,0x0C,
+0xFF,0x00,0xD0,0x30,
+0x66,0x00,0x40,0x10,
+0x10,0x00,0xA2,0xAF,
+0x08,0x00,0x44,0x8C,
+0xB0,0x03,0x22,0x36,
+0x00,0x00,0x44,0xAC,
+0x10,0x00,0xA3,0x8F,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0x64,0x94,
+0x00,0x00,0x00,0x00,
+0x25,0x88,0x82,0x00,
+0x41,0x00,0x40,0x16,
+0x20,0x00,0x24,0x26,
+0x48,0x00,0x02,0x24,
+0x43,0x00,0x02,0x12,
+0x20,0x00,0x30,0xA6,
+0x04,0x00,0x02,0x24,
+0x47,0x00,0x62,0x16,
+0x21,0x28,0x80,0x02,
+0xA4,0x00,0x02,0x24,
+0x61,0x00,0x02,0x12,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xA2,0x8F,
+0x25,0xB0,0x10,0x3C,
+0xB0,0x03,0x10,0x36,
+0x0C,0x00,0x55,0xAC,
+0x10,0x00,0xA2,0x8F,
+0x12,0x00,0x03,0x24,
+0x21,0x28,0x00,0x00,
+0x14,0x00,0x43,0xAC,
+0x00,0x00,0x15,0xAE,
+0x10,0x00,0xA2,0x8F,
+0x08,0x00,0x06,0x24,
+0x08,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x03,0xAE,
+0x10,0x00,0xA2,0x8F,
+0x02,0x80,0x03,0x3C,
+0x08,0x00,0x44,0x94,
+0x00,0x00,0x00,0x00,
+0x25,0x88,0x83,0x00,
+0x08,0x52,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x14,0x00,0x25,0x8E,
+0x08,0x00,0x24,0x8E,
+0xFF,0xDF,0x02,0x3C,
+0xFF,0x81,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x24,0x28,0xA3,0x00,
+0x24,0x20,0x82,0x00,
+0x00,0x40,0x03,0x3C,
+0x25,0x20,0x83,0x00,
+0x20,0x00,0x02,0x24,
+0x00,0x24,0xA5,0x34,
+0x00,0x00,0x35,0xA6,
+0x02,0x00,0x22,0xA2,
+0x08,0x00,0x24,0xAE,
+0x14,0x00,0x25,0xAE,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xA3,0x8F,
+0x74,0x57,0x42,0x24,
+0x04,0x00,0x44,0x8C,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x10,0x00,0xA2,0x27,
+0x00,0x00,0x83,0xAC,
+0x04,0x00,0x64,0xAC,
+0x30,0x00,0xBF,0x8F,
+0x00,0x00,0x02,0xAE,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x00,0x10,0x02,0x36,
+0x20,0x00,0x22,0xA6,
+0x48,0x00,0x02,0x24,
+0xC0,0xFF,0x02,0x16,
+0x04,0x00,0x02,0x24,
+0x20,0x00,0x22,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x42,0x34,
+0x20,0x00,0x22,0xA6,
+0x04,0x00,0x02,0x24,
+0xBB,0xFF,0x62,0x12,
+0x21,0x28,0x80,0x02,
+0x24,0x00,0x24,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x18,0x3B,0xA5,0x24,
+0x2A,0x00,0x24,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x30,0x00,0x24,0x26,
+0x88,0x58,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x88,0x4D,0x00,0x08,
+0x18,0x00,0x15,0x24,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x4C,0xE2,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x24,0xEB,0xA5,0x24,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x80,0x58,0x43,0x94,
+0x02,0x80,0x05,0x3C,
+0x88,0x58,0xA5,0x24,
+0x00,0xC0,0x63,0x24,
+0xFF,0xFF,0x63,0x30,
+0x02,0x12,0x03,0x00,
+0x02,0x00,0x83,0xA0,
+0x03,0x00,0x82,0xA0,
+0x06,0x00,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0x24,0x00,0x24,0x26,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x24,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x88,0x4D,0x00,0x08,
+0x18,0x00,0x15,0x24,
+0xB0,0xFF,0xBD,0x27,
+0x3C,0x00,0xB5,0xAF,
+0x38,0x00,0xB4,0xAF,
+0xFF,0xFF,0xF5,0x30,
+0x25,0xB0,0x14,0x3C,
+0x01,0x80,0x02,0x3C,
+0x2C,0x00,0xB1,0xAF,
+0x18,0x03,0x83,0x36,
+0xE8,0x37,0x42,0x24,
+0x20,0x00,0xB1,0x26,
+0x44,0x00,0xB7,0xAF,
+0x34,0x00,0xB3,0xAF,
+0x21,0xB8,0x80,0x00,
+0x60,0x00,0xB3,0x93,
+0x21,0x20,0x20,0x02,
+0x00,0x00,0x62,0xAC,
+0x40,0x00,0xB6,0xAF,
+0x30,0x00,0xB2,0xAF,
+0x48,0x00,0xBF,0xAF,
+0x28,0x00,0xB0,0xAF,
+0xFF,0x00,0xB6,0x30,
+0x25,0x24,0x00,0x0C,
+0xFF,0x00,0xD2,0x30,
+0x11,0x00,0x40,0x14,
+0x20,0x00,0xA2,0xAF,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x58,0xE2,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x30,0xEB,0xA5,0x24,
+0x48,0x00,0xBF,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0x08,0x00,0x43,0x8C,
+0xB0,0x03,0x82,0x36,
+0x02,0x80,0x10,0x3C,
+0x00,0x00,0x43,0xAC,
+0x20,0x00,0xA2,0x8F,
+0x21,0x30,0x20,0x02,
+0x21,0x28,0x00,0x00,
+0x08,0x00,0x44,0x94,
+0xFF,0x51,0x00,0x0C,
+0x25,0x20,0x90,0x00,
+0x20,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x25,0x88,0x50,0x00,
+0x51,0x00,0x60,0x16,
+0x20,0x00,0x30,0x26,
+0x20,0x00,0x32,0xA6,
+0x48,0x00,0x02,0x24,
+0x6C,0x00,0x42,0x12,
+0x50,0x00,0x82,0x36,
+0x04,0x00,0x02,0x24,
+0x4D,0x00,0xC2,0x16,
+0x21,0x28,0xE0,0x02,
+0xA4,0x00,0x02,0x24,
+0x7E,0x00,0x42,0x12,
+0x02,0x80,0x02,0x3C,
+0x20,0x00,0xA2,0x8F,
+0x25,0xB0,0x10,0x3C,
+0xB0,0x03,0x10,0x36,
+0x0C,0x00,0x55,0xAC,
+0x20,0x00,0xA2,0x8F,
+0x12,0x00,0x03,0x24,
+0x21,0x28,0x00,0x00,
+0x14,0x00,0x43,0xAC,
+0x00,0x00,0x15,0xAE,
+0x20,0x00,0xA2,0x8F,
+0x08,0x00,0x06,0x24,
+0x08,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x03,0xAE,
+0x20,0x00,0xA2,0x8F,
+0x02,0x80,0x03,0x3C,
+0x08,0x00,0x44,0x94,
+0x00,0x00,0x00,0x00,
+0x25,0x88,0x83,0x00,
+0x08,0x52,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x04,0x00,0x25,0x8E,
+0x08,0x00,0x26,0x8E,
+0x14,0x00,0x27,0x8E,
+0x10,0x00,0x24,0x8E,
+0xFF,0xE0,0x03,0x24,
+0xFF,0xDF,0x02,0x3C,
+0x24,0x28,0xA3,0x00,
+0xFF,0xFF,0x42,0x34,
+0xFF,0x81,0x03,0x24,
+0x24,0x38,0xE3,0x00,
+0x24,0x30,0xC2,0x00,
+0x00,0x80,0x03,0x3C,
+0x00,0x40,0x02,0x3C,
+0x25,0x30,0xC2,0x00,
+0x25,0x20,0x83,0x00,
+0x00,0x12,0xA5,0x34,
+0x20,0x00,0x02,0x24,
+0x10,0x00,0x24,0xAE,
+0x00,0x00,0x35,0xA6,
+0x02,0x00,0x22,0xA2,
+0x04,0x00,0x25,0xAE,
+0x14,0x00,0x27,0xAE,
+0x08,0x00,0x26,0xAE,
+0x00,0x60,0x05,0x40,
+0x01,0x00,0xA1,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x02,0x3C,
+0x20,0x00,0xA3,0x8F,
+0x74,0x57,0x42,0x24,
+0x04,0x00,0x44,0x8C,
+0x00,0x00,0x62,0xAC,
+0x04,0x00,0x43,0xAC,
+0x20,0x00,0xA2,0x27,
+0x00,0x00,0x83,0xAC,
+0x04,0x00,0x64,0xAC,
+0x00,0x00,0x02,0xAE,
+0x00,0x60,0x85,0x40,
+0x48,0x00,0xBF,0x8F,
+0x44,0x00,0xB7,0x8F,
+0x40,0x00,0xB6,0x8F,
+0x3C,0x00,0xB5,0x8F,
+0x38,0x00,0xB4,0x8F,
+0x34,0x00,0xB3,0x8F,
+0x30,0x00,0xB2,0x8F,
+0x2C,0x00,0xB1,0x8F,
+0x28,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x50,0x00,0xBD,0x27,
+0x00,0x10,0x42,0x36,
+0x35,0x4E,0x00,0x08,
+0x20,0x00,0x22,0xA6,
+0x24,0x00,0x24,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x18,0x3B,0xA5,0x24,
+0x2A,0x00,0x24,0x26,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x30,0x00,0x24,0x26,
+0x88,0x58,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x30,0x1F,0xA5,0x24,
+0xF8,0x1D,0xA6,0x94,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xC2,0x24,
+0x00,0x21,0x06,0x00,
+0xFF,0xFF,0x46,0x30,
+0xFF,0xFF,0x84,0x30,
+0x00,0x10,0xC2,0x2C,
+0x0A,0x30,0x02,0x00,
+0x02,0x1A,0x04,0x00,
+0x17,0x00,0x03,0xA2,
+0x16,0x00,0x04,0xA2,
+0x3E,0x4E,0x00,0x08,
+0xF8,0x1D,0xA6,0xA4,
+0x00,0x00,0x43,0x8C,
+0x54,0x00,0x84,0x36,
+0x58,0x00,0x85,0x36,
+0x10,0x00,0xA3,0xAF,
+0x00,0x00,0x82,0x8C,
+0x5C,0x00,0x87,0x36,
+0x2A,0x00,0x24,0x26,
+0x14,0x00,0xA2,0xAF,
+0x00,0x00,0xA3,0x8C,
+0x06,0x00,0x06,0x24,
+0x10,0x00,0xA5,0x27,
+0x18,0x00,0xA3,0xAF,
+0x00,0x00,0xE2,0x8C,
+0x10,0x52,0x00,0x0C,
+0x1C,0x00,0xA2,0xAF,
+0x30,0x00,0x24,0x26,
+0x18,0x00,0xA5,0x27,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x20,0x00,0x23,0x96,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x63,0x34,
+0x38,0x4E,0x00,0x08,
+0x20,0x00,0x23,0xA6,
+0x80,0x58,0x43,0x94,
+0x02,0x80,0x05,0x3C,
+0x24,0x00,0x24,0x26,
+0x00,0xC0,0x63,0x24,
+0xFF,0xFF,0x63,0x30,
+0x02,0x12,0x03,0x00,
+0x88,0x58,0xA5,0x24,
+0x03,0x00,0x02,0xA2,
+0x02,0x00,0x03,0xA2,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x02,0x80,0x05,0x3C,
+0x2A,0x00,0x24,0x26,
+0x18,0x3B,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x3E,0x4E,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0xFF,0x00,0x90,0x30,
+0x02,0x80,0x04,0x3C,
+0x21,0x28,0x00,0x02,
+0x1C,0x00,0xBF,0xAF,
+0x2F,0x55,0x00,0x0C,
+0x64,0xE2,0x84,0x24,
+0x02,0x80,0x04,0x3C,
+0x88,0x58,0x84,0x24,
+0x08,0x00,0x05,0x24,
+0x48,0x00,0x06,0x24,
+0x18,0x00,0x07,0x24,
+0xFA,0x4D,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x01,0x00,0x02,0x24,
+0x21,0x28,0x00,0x00,
+0x90,0x00,0x06,0x24,
+0x21,0x38,0x00,0x00,
+0x18,0x00,0xBF,0xAF,
+0x60,0x4D,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xB0,0xAF,
+0xFF,0xFF,0x05,0x24,
+0xFF,0x00,0x90,0x30,
+0x02,0x00,0x06,0x24,
+0x24,0x00,0xBF,0xAF,
+0x08,0x52,0x00,0x0C,
+0x18,0x00,0xA4,0x27,
+0x18,0x00,0xA4,0x27,
+0x08,0x00,0x05,0x24,
+0xC8,0x00,0x06,0x24,
+0x21,0x38,0x00,0x00,
+0x60,0x4D,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x05,0x3C,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x30,0x1F,0xA5,0x24,
+0x50,0x39,0xA2,0x94,
+0x01,0x00,0x03,0x24,
+0xFF,0x00,0x90,0x30,
+0x00,0xC0,0x42,0x24,
+0xFF,0xFF,0x44,0x30,
+0xC2,0x34,0x00,0x0C,
+0x2A,0x1C,0xA3,0xA0,
+0x02,0x80,0x04,0x3C,
+0x88,0x58,0x84,0x24,
+0x04,0x00,0x05,0x24,
+0xA4,0x00,0x06,0x24,
+0x10,0x00,0x07,0x24,
+0xFA,0x4D,0x00,0x0C,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x08,0x00,0x82,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x17,0x4F,0x00,0x0C,
+0x74,0x00,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x10,0x00,0xA4,0x27,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA2,0x97,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x17,0x4F,0x00,0x0C,
+0x10,0x00,0xA5,0xA7,
+0x21,0x20,0x40,0x00,
+0x10,0x00,0xA5,0x27,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x0A,0x00,0x82,0x24,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x32,0x4F,0x00,0x0C,
+0x74,0x00,0x84,0x24,
+0x21,0x28,0x40,0x00,
+0x10,0x00,0xA4,0x27,
+0x10,0x52,0x00,0x0C,
+0x02,0x00,0x06,0x24,
+0x10,0x00,0xA2,0x97,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0x80,0x00,
+0x00,0x00,0x05,0xA2,
+0x01,0x00,0x06,0xA2,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x21,0x88,0xC0,0x00,
+0x02,0x00,0x84,0x24,
+0x30,0x00,0xB2,0x8F,
+0x0D,0x00,0xC0,0x14,
+0x21,0x28,0xE0,0x00,
+0x00,0x00,0x43,0x8E,
+0x21,0x10,0x11,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x21,0x18,0x71,0x00,
+0x02,0x00,0x63,0x24,
+0x00,0x00,0x43,0xAE,
+0x14,0x00,0xB1,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x00,0x42,0x24,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x10,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x43,0x8E,
+0x21,0x10,0x11,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x21,0x18,0x71,0x00,
+0x02,0x00,0x63,0x24,
+0x00,0x00,0x43,0xAE,
+0x14,0x00,0xB1,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x00,0x42,0x24,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0xA0,0x00,
+0x18,0x00,0xB2,0xAF,
+0x21,0x28,0xC0,0x00,
+0x21,0x90,0xE0,0x00,
+0x21,0x30,0x00,0x02,
+0x1C,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x52,0x00,0x0C,
+0x21,0x88,0x80,0x00,
+0x00,0x00,0x43,0x8E,
+0x21,0x10,0x30,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x21,0x18,0x70,0x00,
+0x00,0x00,0x43,0xAE,
+0x14,0x00,0xB1,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x7F,0x00,0x84,0x30,
+0x6D,0x00,0x82,0x2C,
+0x0A,0x00,0x40,0x10,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x04,0x00,
+0x58,0xEB,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x0B,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x0A,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x09,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x07,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x06,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x03,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x05,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x04,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x02,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x01,0x00,0x05,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x7F,0x00,0x84,0x30,
+0x0C,0x00,0x82,0x2C,
+0x0A,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x04,0x00,
+0x0C,0xED,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x6C,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x60,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x48,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x30,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x24,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x18,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x12,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x0C,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x16,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x0B,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x04,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x02,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xC8,0xFF,0xBD,0x27,
+0x24,0x00,0xB5,0xAF,
+0x02,0x80,0x15,0x3C,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x30,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0xB8,0x80,0x00,
+0x21,0xA0,0x00,0x00,
+0x21,0x98,0x00,0x00,
+0x30,0x1F,0xB6,0x26,
+0x30,0x1F,0xA2,0x26,
+0x21,0x10,0x62,0x02,
+0xFB,0x1B,0x51,0x90,
+0xFE,0x00,0x03,0x24,
+0x1E,0x00,0x23,0x12,
+0xFF,0x00,0x02,0x24,
+0x21,0x00,0x22,0x12,
+0x21,0x10,0x80,0x02,
+0xAD,0x4F,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x21,0x88,0x40,0x00,
+0x21,0x80,0x00,0x00,
+0x21,0x90,0xC0,0x02,
+0x21,0x10,0x12,0x02,
+0xEE,0x1B,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x82,0x24,
+0xFF,0x00,0x42,0x30,
+0x02,0x00,0x42,0x2C,
+0x05,0x00,0x40,0x14,
+0x01,0x00,0x10,0x26,
+0xAD,0x4F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x51,0x10,
+0x01,0x00,0x03,0x24,
+0x0D,0x00,0x02,0x2A,
+0xF3,0xFF,0x40,0x14,
+0x21,0x10,0x12,0x02,
+0x21,0x18,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x14,0x00,0x62,0x10,
+0xFF,0x00,0x22,0x32,
+0x21,0x10,0xF4,0x02,
+0x00,0x00,0x51,0xA0,
+0x01,0x00,0x94,0x26,
+0x01,0x00,0x73,0x26,
+0x0D,0x00,0x62,0x2A,
+0xDB,0xFF,0x40,0x14,
+0x30,0x1F,0xA2,0x26,
+0x21,0x10,0x80,0x02,
+0x30,0x00,0xBF,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x0C,0x50,0x00,0x08,
+0x80,0x00,0x51,0x34,
+0xD0,0xFF,0xBD,0x27,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x21,0x88,0x80,0x00,
+0x21,0x80,0xA0,0x00,
+0x0D,0x00,0x06,0x24,
+0x21,0x28,0x00,0x00,
+0x28,0x00,0xBF,0xAF,
+0xFF,0x51,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0xDD,0x4F,0x00,0x0C,
+0x10,0x00,0xA4,0x27,
+0x00,0x00,0x02,0xAE,
+0x21,0x20,0x20,0x02,
+0x10,0x00,0xA5,0x27,
+0x10,0x52,0x00,0x0C,
+0x21,0x30,0x40,0x00,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x21,0x28,0x00,0x00,
+0x21,0x10,0x85,0x00,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x60,0x10,
+0x0D,0x00,0xA2,0x2C,
+0xFA,0xFF,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xFF,0xFF,0xA5,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x00,0x00,0x82,0x94,
+0x21,0x30,0x80,0x00,
+0x10,0x00,0x85,0x24,
+0x42,0x1A,0x02,0x00,
+0xC2,0x11,0x02,0x00,
+0x02,0x00,0x42,0x30,
+0x01,0x00,0x63,0x30,
+0x25,0x18,0x43,0x00,
+0x01,0x00,0x04,0x24,
+0x07,0x00,0x64,0x10,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x60,0x10,
+0x0A,0x00,0xC5,0x24,
+0x02,0x00,0x02,0x24,
+0x02,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xC5,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x00,0x00,0x82,0x94,
+0x21,0x30,0x80,0x00,
+0x04,0x00,0x85,0x24,
+0x42,0x1A,0x02,0x00,
+0xC2,0x11,0x02,0x00,
+0x02,0x00,0x42,0x30,
+0x01,0x00,0x63,0x30,
+0x25,0x18,0x43,0x00,
+0x01,0x00,0x04,0x24,
+0x04,0x00,0x64,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xC5,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xA0,0x00,
+0x13,0x00,0xA0,0x18,
+0x21,0x30,0x00,0x00,
+0x02,0x00,0x07,0x24,
+0x04,0x00,0x08,0x24,
+0x0B,0x00,0x09,0x24,
+0x16,0x00,0x0A,0x24,
+0x21,0x10,0x86,0x00,
+0x00,0x00,0x43,0x90,
+0x01,0x00,0xC6,0x24,
+0x7F,0x00,0x63,0x30,
+0x07,0x00,0x67,0x10,
+0x2A,0x10,0xC5,0x00,
+0x05,0x00,0x68,0x10,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x69,0x10,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x6A,0x14,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x02,0x80,0x02,0x3C,
+0x80,0x5D,0x43,0x8C,
+0x08,0x00,0x10,0x24,
+0x06,0x00,0xA0,0x14,
+0x0A,0x80,0x03,0x00,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x65,0x50,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x36,
+0x01,0x00,0x42,0x38,
+0x03,0x00,0x04,0x36,
+0x21,0x80,0x60,0x00,
+0x0B,0x80,0x82,0x00,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x0E,0x00,0xA3,0x2C,
+0x21,0x88,0xA0,0x00,
+0x0D,0x00,0x02,0x24,
+0x0A,0x88,0x43,0x00,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x21,0x98,0x80,0x00,
+0x21,0x90,0x00,0x00,
+0x15,0x00,0x20,0x12,
+0x21,0x80,0x00,0x00,
+0xAA,0x50,0x00,0x08,
+0x01,0x00,0x14,0x24,
+0x2B,0x10,0x11,0x02,
+0x11,0x00,0x40,0x10,
+0x21,0x10,0x40,0x02,
+0x21,0x18,0x70,0x02,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x44,0x30,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0xF6,0xFF,0x41,0x04,
+0x01,0x00,0x10,0x26,
+0x7D,0x4F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x04,0x10,0x54,0x00,
+0x25,0x90,0x42,0x02,
+0x2B,0x10,0x11,0x02,
+0xF3,0xFF,0x40,0x14,
+0x21,0x18,0x70,0x02,
+0x21,0x10,0x40,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x0E,0x00,0xA3,0x2C,
+0x21,0x88,0xA0,0x00,
+0x0D,0x00,0x02,0x24,
+0x0A,0x88,0x43,0x00,
+0x20,0x00,0xB4,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x21,0xA0,0x80,0x00,
+0x21,0x90,0x00,0x00,
+0x0A,0x00,0x20,0x12,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x13,0x24,
+0x21,0x10,0x90,0x02,
+0x00,0x00,0x44,0x90,
+0x7D,0x4F,0x00,0x0C,
+0x01,0x00,0x10,0x26,
+0x04,0x10,0x53,0x00,
+0x2B,0x18,0x11,0x02,
+0xF9,0xFF,0x60,0x14,
+0x25,0x90,0x42,0x02,
+0x21,0x10,0x40,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE8,0xFF,0xBD,0x27,
+0xFF,0xFF,0x02,0x24,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x21,0x30,0xA0,0x00,
+0x1B,0x00,0x82,0x10,
+0x20,0x00,0x10,0x24,
+0x20,0x00,0x82,0x28,
+0x06,0x00,0x40,0x14,
+0x80,0x18,0x04,0x00,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x21,0x18,0x64,0x00,
+0x21,0x80,0x80,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x04,0x3C,
+0xC0,0x18,0x03,0x00,
+0x30,0x1F,0x42,0x24,
+0x2B,0x3D,0x84,0x24,
+0x21,0x20,0x64,0x00,
+0x21,0x18,0x62,0x00,
+0x01,0x00,0x02,0x24,
+0x06,0x00,0x06,0x24,
+0x10,0x52,0x00,0x0C,
+0xFA,0x1D,0x62,0xA0,
+0x21,0x10,0x00,0x02,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0xC8,0x00,0x47,0x24,
+0x05,0x00,0x10,0x24,
+0xC2,0x1E,0x43,0x24,
+0x10,0x51,0x00,0x08,
+0xC8,0x00,0x05,0x24,
+0x01,0x00,0x10,0x26,
+0x20,0x00,0x02,0x2E,
+0x28,0x00,0xA5,0x24,
+0xDE,0xFF,0x40,0x10,
+0x28,0x00,0xE7,0x24,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0xF8,0xFF,0x40,0x14,
+0x28,0x00,0x63,0x24,
+0x02,0x80,0x04,0x3C,
+0x2B,0x3D,0x84,0x24,
+0x01,0x00,0x02,0x24,
+0x21,0x20,0xA4,0x00,
+0xFA,0x1D,0xE2,0xA0,
+0x21,0x28,0xC0,0x00,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x00,0x51,0x00,0x08,
+0x21,0x10,0x00,0x02,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x30,0x00,0xB2,0x8F,
+0x21,0x88,0x80,0x00,
+0x21,0x20,0xA0,0x00,
+0x21,0x28,0x20,0x02,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0xE3,0x50,0x00,0x0C,
+0xFF,0xFF,0xF0,0x30,
+0x20,0x00,0x03,0x24,
+0x21,0x20,0x40,0x00,
+0x21,0x28,0x00,0x02,
+0x21,0x30,0x20,0x02,
+0x07,0x00,0x43,0x10,
+0x21,0x38,0x40,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x4E,0x23,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0xA8,0x80,0x00,
+0x30,0x1F,0x54,0x24,
+0x2B,0x3D,0x73,0x24,
+0x05,0x00,0x11,0x24,
+0x01,0x00,0x12,0x24,
+0xC8,0x00,0x10,0x24,
+0x50,0x51,0x00,0x08,
+0x28,0x00,0xBF,0xAF,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0x22,0x2A,
+0x0E,0x00,0x40,0x10,
+0x21,0x10,0x20,0x02,
+0x21,0x10,0x14,0x02,
+0xFA,0x1D,0x43,0x90,
+0x21,0x20,0x13,0x02,
+0x21,0x28,0xA0,0x02,
+0x06,0x00,0x06,0x24,
+0xF6,0xFF,0x72,0x14,
+0x28,0x00,0x10,0x26,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x14,
+0x01,0x00,0x31,0x26,
+0xFF,0xFF,0x31,0x26,
+0x21,0x10,0x20,0x02,
+0x28,0x00,0xBF,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x98,0x80,0x00,
+0x30,0x1F,0x56,0x24,
+0x2B,0x3D,0x75,0x24,
+0x21,0x88,0x00,0x00,
+0x01,0x00,0x14,0x24,
+0x21,0x80,0x00,0x00,
+0x2C,0x00,0xBF,0xAF,
+0x7C,0x51,0x00,0x08,
+0x18,0x00,0xB2,0xAF,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0x22,0x2A,
+0x1E,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x90,0x16,0x02,
+0xFA,0x1D,0x42,0x92,
+0x21,0x20,0x15,0x02,
+0x21,0x28,0x60,0x02,
+0x06,0x00,0x06,0x24,
+0xF6,0xFF,0x54,0x14,
+0x28,0x00,0x10,0x26,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x40,0x14,
+0x01,0x00,0x31,0x26,
+0xFF,0xFF,0x31,0x26,
+0x02,0x80,0x06,0x3C,
+0x02,0x80,0x07,0x3C,
+0x21,0x20,0x20,0x02,
+0xFA,0x1D,0x40,0xA2,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xE8,0xDD,0xC6,0x24,
+0xD8,0xDD,0xE7,0x24,
+0x21,0x28,0x00,0x00,
+0x4E,0x23,0x00,0x08,
+0x30,0x00,0xBD,0x27,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x18,0x00,0xB2,0xAF,
+0x30,0x1F,0x52,0x24,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x21,0x80,0x00,0x00,
+0x02,0x80,0x1E,0x3C,
+0x02,0x80,0x17,0x3C,
+0x02,0x80,0x16,0x3C,
+0x01,0x00,0x13,0x24,
+0xFF,0xF7,0x15,0x24,
+0xFF,0xEF,0x14,0x24,
+0x21,0x88,0x40,0x02,
+0xFA,0x1D,0x22,0x92,
+0xC0,0x48,0x10,0x00,
+0xEA,0x5D,0xC7,0x93,
+0x41,0x00,0x53,0x10,
+0x21,0x30,0x32,0x01,
+0xE8,0x22,0xC2,0x8C,
+0xBF,0xFF,0x03,0x24,
+0x24,0x28,0x43,0x00,
+0x80,0x07,0xA3,0x34,
+0x24,0x10,0x75,0x00,
+0x31,0x00,0xF3,0x10,
+0x24,0x10,0x54,0x00,
+0xE8,0x22,0xC2,0xAC,
+0x21,0x48,0x32,0x01,
+0xE8,0x22,0x23,0x8D,
+0xFD,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0xFB,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0xE7,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0xFF,0xFD,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xEC,0x22,0x28,0x8D,
+0x24,0x18,0x62,0x00,
+0xFF,0xFB,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0xFF,0xE7,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x1F,0x00,0x06,0x3C,
+0x00,0x80,0x08,0x35,
+0x24,0x18,0x62,0x00,
+0x25,0x40,0x06,0x01,
+0x21,0x20,0x00,0x02,
+0xE8,0x22,0x23,0xAD,
+0x01,0x00,0x10,0x26,
+0x21,0x28,0x00,0x00,
+0xE8,0xDD,0xE6,0x26,
+0xD8,0xDD,0xC7,0x26,
+0x4E,0x23,0x00,0x0C,
+0xEC,0x22,0x28,0xAD,
+0x20,0x00,0x03,0x2A,
+0xD1,0xFF,0x60,0x14,
+0x28,0x00,0x31,0x26,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0xEB,0x5D,0x44,0x90,
+0x24,0x18,0x75,0x00,
+0x80,0x0F,0xA2,0x34,
+0x00,0x10,0x63,0x34,
+0xCA,0xFF,0x87,0x14,
+0x24,0x10,0x54,0x00,
+0xC5,0x51,0x00,0x08,
+0xE8,0x22,0xC3,0xAC,
+0xBD,0x51,0x00,0x08,
+0xFA,0x1D,0x20,0xA2,
+0x04,0x52,0x00,0x08,
+0xFF,0x00,0xA5,0x30,
+0x00,0x00,0x85,0xA0,
+0xFF,0xFF,0xC6,0x24,
+0x01,0x00,0x84,0x24,
+0xFC,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x85,0xAC,
+0xFF,0xFF,0xC6,0x24,
+0xFD,0xFF,0xC0,0x14,
+0x04,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x38,0x80,0x00,
+0x08,0x00,0xC0,0x10,
+0xFF,0xFF,0xC3,0x24,
+0xFF,0xFF,0x06,0x24,
+0x00,0x00,0xA2,0x90,
+0xFF,0xFF,0x63,0x24,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0xE2,0xA0,
+0xFB,0xFF,0x66,0x14,
+0x01,0x00,0xE7,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x2B,0x10,0xA4,0x00,
+0x0D,0x00,0x40,0x14,
+0xFF,0xFF,0x02,0x24,
+0xFF,0xFF,0xC6,0x24,
+0x08,0x00,0xC2,0x10,
+0x21,0x18,0x80,0x00,
+0xFF,0xFF,0x07,0x24,
+0x00,0x00,0xA2,0x90,
+0xFF,0xFF,0xC6,0x24,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x62,0xA0,
+0xFB,0xFF,0xC7,0x14,
+0x01,0x00,0x63,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x21,0x28,0xA6,0x00,
+0x21,0x18,0x86,0x00,
+0xFF,0xFF,0xC6,0x24,
+0xFA,0xFF,0xC2,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x07,0x24,
+0xFF,0xFF,0xA5,0x24,
+0x00,0x00,0xA2,0x90,
+0xFF,0xFF,0x63,0x24,
+0xFF,0xFF,0xC6,0x24,
+0xFB,0xFF,0xC7,0x14,
+0x00,0x00,0x62,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x0C,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0xA3,0x90,
+0x01,0x00,0x84,0x24,
+0x23,0x10,0x43,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x04,0x00,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xFF,0xFF,0xC6,0x24,
+0xF6,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xC0,0x00,
+0x4F,0x52,0x00,0x08,
+0x21,0x18,0x86,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x45,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x84,0x24,
+0xFA,0xFF,0x83,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0x09,0x00,0xC0,0x10,
+0xFF,0xFF,0xC3,0x24,
+0xFF,0x00,0xA5,0x30,
+0xFF,0xFF,0x06,0x24,
+0x00,0x00,0x82,0x90,
+0xFF,0xFF,0x63,0x24,
+0x05,0x00,0x45,0x10,
+0x01,0x00,0x84,0x24,
+0xFB,0xFF,0x66,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0xFF,0xFF,0x82,0x24,
+0x21,0x38,0x00,0x00,
+0x1F,0x00,0xC0,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x40,0xF2,0x4B,0x24,
+0x00,0x00,0x87,0x90,
+0x00,0x00,0xA3,0x90,
+0xFF,0xFF,0xC6,0x24,
+0x01,0x00,0x84,0x24,
+0x21,0x10,0xEB,0x00,
+0x16,0x00,0xE0,0x10,
+0x01,0x00,0xA5,0x24,
+0x14,0x00,0x60,0x10,
+0x21,0x48,0x6B,0x00,
+0x10,0x00,0xE3,0x10,
+0x20,0x00,0xE8,0x24,
+0x00,0x00,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x02,0x00,0x40,0x10,
+0x20,0x00,0x6A,0x24,
+0xFF,0x00,0x07,0x31,
+0x00,0x00,0x22,0x91,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x02,0x00,0x40,0x10,
+0xFF,0x00,0xE7,0x30,
+0xFF,0x00,0x43,0x31,
+0xFF,0x00,0x63,0x30,
+0x03,0x00,0xE3,0x14,
+0x00,0x00,0x00,0x00,
+0xE5,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0xE3,0x00,
+0x21,0x18,0x80,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x21,0x38,0x80,0x00,
+0xFF,0xFF,0x03,0x24,
+0xFF,0xFF,0xC6,0x24,
+0x06,0x00,0xC3,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0xF9,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xE0,0x00,
+0x00,0x00,0x82,0x80,
+0x9E,0x52,0x00,0x08,
+0x21,0x18,0x80,0x00,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x82,0x80,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x12,0x00,0xC0,0x10,
+0x21,0x18,0x80,0x00,
+0x00,0x00,0x82,0x80,
+0xAF,0x52,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x82,0x80,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0xA5,0x24,
+0x00,0x00,0x82,0xA0,
+0x05,0x00,0x40,0x10,
+0x01,0x00,0x84,0x24,
+0xFF,0xFF,0xC6,0x24,
+0xF9,0xFF,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x80,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x00,0x00,0x83,0x90,
+0x00,0x00,0xA2,0x90,
+0x01,0x00,0x84,0x24,
+0x23,0x10,0x62,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x00,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xF7,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x00,0x00,
+0x0B,0x00,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0x90,
+0x00,0x00,0x83,0x90,
+0xFF,0xFF,0xC6,0x24,
+0x23,0x10,0x62,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x00,0x40,0x14,
+0x01,0x00,0xA5,0x24,
+0xF5,0xFF,0x60,0x14,
+0x01,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x83,0x80,
+0x00,0x2E,0x05,0x00,
+0x21,0x10,0x80,0x00,
+0xE0,0x52,0x00,0x08,
+0x03,0x2E,0x05,0x00,
+0x07,0x00,0x60,0x10,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0x43,0x80,
+0x00,0x00,0x00,0x00,
+0xFB,0xFF,0x65,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x00,0x00,0x82,0x80,
+0xEC,0x52,0x00,0x08,
+0x21,0x18,0x80,0x00,
+0x01,0x00,0x63,0x24,
+0x00,0x00,0x62,0x80,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x23,0x10,0x64,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x21,0x80,0xA0,0x00,
+0x14,0x00,0xB1,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x21,0x88,0x80,0x00,
+0xE6,0x52,0x00,0x0C,
+0x00,0x86,0x10,0x00,
+0x21,0x18,0x51,0x00,
+0x03,0x86,0x10,0x00,
+0x00,0x00,0x62,0x80,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x50,0x10,
+0x21,0x10,0x60,0x00,
+0xFF,0xFF,0x63,0x24,
+0x2B,0x10,0x71,0x00,
+0xF9,0xFF,0x40,0x10,
+0x21,0x10,0x00,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x21,0x30,0x80,0x00,
+0x0D,0x00,0xA0,0x10,
+0xFF,0xFF,0xA3,0x24,
+0x00,0x00,0x82,0x80,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x05,0x24,
+0xFF,0xFF,0x63,0x24,
+0x05,0x00,0x65,0x10,
+0x01,0x00,0xC6,0x24,
+0x00,0x00,0xC2,0x80,
+0x00,0x00,0x00,0x00,
+0xFA,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0xC4,0x00,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x19,0x00,0x40,0x10,
+0x21,0x40,0x00,0x00,
+0x00,0x00,0xA9,0x80,
+0x00,0x00,0x00,0x00,
+0x17,0x00,0x20,0x11,
+0x21,0x30,0xA0,0x00,
+0x00,0x3E,0x02,0x00,
+0x03,0x3E,0x07,0x00,
+0x21,0x18,0x20,0x01,
+0x15,0x00,0xE3,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0xC6,0x24,
+0x00,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x1E,0x02,0x00,
+0x03,0x1E,0x03,0x00,
+0xF8,0xFF,0x60,0x14,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x06,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xEB,0xFF,0x40,0x14,
+0x01,0x00,0x08,0x25,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x01,
+0x00,0x00,0xA2,0x90,
+0x31,0x53,0x00,0x08,
+0x00,0x16,0x02,0x00,
+0x00,0x00,0xC2,0x90,
+0x31,0x53,0x00,0x08,
+0x00,0x16,0x02,0x00,
+0x00,0x00,0x87,0x90,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xE0,0x10,
+0x21,0x10,0x80,0x00,
+0x00,0x00,0xA4,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x1E,0x04,0x00,
+0x03,0x1E,0x03,0x00,
+0x09,0x00,0x60,0x10,
+0x21,0x30,0xA0,0x00,
+0x00,0x3E,0x07,0x00,
+0x03,0x3E,0x07,0x00,
+0x0B,0x00,0xE3,0x10,
+0x01,0x00,0xC6,0x24,
+0x00,0x00,0xC3,0x80,
+0x00,0x00,0x00,0x00,
+0xFB,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0x00,0x00,0x47,0x90,
+0x00,0x00,0x00,0x00,
+0xF0,0xFF,0xE0,0x14,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x1D,0x00,0x80,0x10,
+0x21,0x88,0xA0,0x00,
+0x1D,0x53,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x21,0x80,0x02,0x02,
+0x00,0x00,0x02,0x82,
+0x21,0x28,0x20,0x02,
+0x21,0x20,0x00,0x02,
+0x22,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x41,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x40,0x10,
+0x21,0x18,0x40,0x00,
+0x00,0x00,0x42,0x80,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x5C,0xF3,0x43,0xAC,
+0x21,0x18,0x00,0x02,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x60,0xA0,
+0x72,0x53,0x00,0x08,
+0x01,0x00,0x63,0x24,
+0x02,0x80,0x02,0x3C,
+0x5C,0xF3,0x50,0x8C,
+0x00,0x00,0x00,0x00,
+0xF3,0xFF,0x00,0x12,
+0x21,0x18,0x00,0x00,
+0x1D,0x53,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x21,0x80,0x02,0x02,
+0x00,0x00,0x02,0x82,
+0x21,0x28,0x20,0x02,
+0x21,0x20,0x00,0x02,
+0xE0,0xFF,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x02,0x80,0x02,0x3C,
+0x5C,0xF3,0x40,0xAC,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x90,0x8C,
+0x21,0x90,0x80,0x00,
+0x21,0x88,0xA0,0x00,
+0x21,0x18,0x00,0x00,
+0x0F,0x00,0x00,0x12,
+0x21,0x20,0x00,0x02,
+0x1D,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x80,0x02,0x02,
+0x00,0x00,0x02,0x82,
+0x21,0x28,0x20,0x02,
+0x21,0x20,0x00,0x02,
+0x07,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x41,0x53,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x40,0x00,
+0x09,0x00,0x40,0x14,
+0x00,0x00,0x42,0xAE,
+0x21,0x18,0x00,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x42,0x80,
+0x00,0x00,0x00,0x00,
+0xF5,0xFF,0x40,0x10,
+0x01,0x00,0x64,0x24,
+0x00,0x00,0x60,0xA0,
+0xAB,0x53,0x00,0x08,
+0x00,0x00,0x44,0xAE,
+0xD8,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x21,0x88,0x80,0x00,
+0x21,0x20,0xA0,0x00,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0xE6,0x52,0x00,0x0C,
+0x21,0x98,0xA0,0x00,
+0x21,0x90,0x40,0x00,
+0x08,0x00,0x40,0x16,
+0x21,0x10,0x20,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE6,0x52,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x21,0x80,0x40,0x00,
+0x2A,0x10,0x52,0x00,
+0x0A,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x60,0x02,
+0x21,0x30,0x40,0x02,
+0x39,0x52,0x00,0x0C,
+0xFF,0xFF,0x10,0x26,
+0x0B,0x00,0x40,0x10,
+0x2A,0x18,0x12,0x02,
+0xF8,0xFF,0x60,0x10,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xC7,0x53,0x00,0x08,
+0x21,0x10,0x20,0x02,
+0x00,0x00,0x87,0x90,
+0x00,0x00,0x00,0x00,
+0x27,0x00,0xE0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA6,0x90,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0xC0,0x10,
+0xDF,0xFF,0x02,0x24,
+0x24,0x18,0xC2,0x00,
+0x24,0x10,0xE2,0x00,
+0x00,0x16,0x02,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x1E,0x03,0x00,
+0x0A,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0xDF,0xFF,0x02,0x24,
+0x24,0x18,0xC2,0x00,
+0x24,0x10,0xE2,0x00,
+0x00,0x16,0x02,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0x43,0x00,
+0x0A,0x54,0x00,0x08,
+0xDF,0xFF,0x08,0x24,
+0x00,0x00,0xA6,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x06,0x01,
+0x00,0x16,0x02,0x00,
+0xF0,0xFF,0xC0,0x10,
+0x03,0x16,0x02,0x00,
+0xEF,0xFF,0x62,0x14,
+0xDF,0xFF,0x02,0x24,
+0x01,0x00,0x84,0x24,
+0x00,0x00,0x87,0x90,
+0x01,0x00,0xA5,0x24,
+0x24,0x10,0x07,0x01,
+0x00,0x1E,0x02,0x00,
+0xF2,0xFF,0xE0,0x14,
+0x03,0x1E,0x03,0x00,
+0x00,0x00,0xA6,0x90,
+0xDF,0xFF,0x02,0x24,
+0x24,0x18,0xC2,0x00,
+0x24,0x10,0xE2,0x00,
+0x00,0x16,0x02,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x08,0x00,0xE0,0x03,
+0x23,0x10,0x43,0x00,
+0xA8,0xFF,0xBD,0x27,
+0x44,0x00,0xB5,0xAF,
+0x40,0x00,0xB4,0xAF,
+0x38,0x00,0xB2,0xAF,
+0x34,0x00,0xB1,0xAF,
+0x54,0x00,0xBF,0xAF,
+0x50,0x00,0xBE,0xAF,
+0x4C,0x00,0xB7,0xAF,
+0x48,0x00,0xB6,0xAF,
+0x3C,0x00,0xB3,0xAF,
+0x30,0x00,0xB0,0xAF,
+0x21,0x90,0xA0,0x00,
+0x00,0x00,0xA5,0x90,
+0x21,0xA0,0x80,0x00,
+0x21,0xA8,0xC0,0x00,
+0x00,0x26,0x05,0x00,
+0x03,0x26,0x04,0x00,
+0x11,0x00,0x80,0x10,
+0x21,0x88,0x80,0x02,
+0x25,0x00,0x02,0x24,
+0x29,0x00,0x82,0x10,
+0x0A,0x00,0x02,0x24,
+0x1B,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x1E,0x00,0x80,0x12,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x25,0xA2,
+0x01,0x00,0x31,0x26,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x26,0x05,0x00,
+0x03,0x26,0x04,0x00,
+0xF2,0xFF,0x80,0x14,
+0x25,0x00,0x02,0x24,
+0x02,0x00,0x80,0x12,
+0x23,0x10,0x34,0x02,
+0x00,0x00,0x20,0xA2,
+0x54,0x00,0xBF,0x8F,
+0x50,0x00,0xBE,0x8F,
+0x4C,0x00,0xB7,0x8F,
+0x48,0x00,0xB6,0x8F,
+0x44,0x00,0xB5,0x8F,
+0x40,0x00,0xB4,0x8F,
+0x3C,0x00,0xB3,0x8F,
+0x38,0x00,0xB2,0x8F,
+0x34,0x00,0xB1,0x8F,
+0x30,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x58,0x00,0xBD,0x27,
+0xE7,0xFF,0x80,0x16,
+0x00,0x00,0x00,0x00,
+0x77,0x55,0x00,0x0C,
+0x0D,0x00,0x04,0x24,
+0x0A,0x00,0x04,0x24,
+0x77,0x55,0x00,0x0C,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x26,0x05,0x00,
+0x3C,0x54,0x00,0x08,
+0x03,0x26,0x04,0x00,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x73,0x00,0x02,0x24,
+0x00,0x1E,0x05,0x00,
+0x03,0x1E,0x03,0x00,
+0x2C,0x00,0x62,0x10,
+0x10,0x00,0xB3,0x27,
+0x23,0x00,0x02,0x24,
+0x21,0xF0,0x60,0x02,
+0x21,0x38,0x00,0x00,
+0x34,0x00,0x62,0x10,
+0x1C,0x00,0x04,0x24,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0x68,0x00,0x03,0x24,
+0x36,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0x39,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0x20,0x00,0xA2,0x34,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x78,0x00,0x03,0x24,
+0x3C,0x00,0x43,0x10,
+0x20,0x00,0xA6,0x30,
+0x00,0x1E,0x05,0x00,
+0x03,0x1E,0x03,0x00,
+0x64,0x00,0x02,0x24,
+0x49,0x00,0x62,0x10,
+0x40,0x00,0x02,0x24,
+0x81,0x00,0x62,0x10,
+0x21,0x00,0x02,0x24,
+0x92,0x00,0x62,0x10,
+0x63,0x00,0x02,0x24,
+0xA2,0x00,0x62,0x10,
+0x11,0x00,0xB3,0x27,
+0x10,0x00,0xA5,0xA3,
+0x21,0x80,0xC0,0x03,
+0x2B,0x10,0x13,0x02,
+0xB4,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x6C,0x00,0x80,0x12,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x02,0x92,
+0x01,0x00,0x10,0x26,
+0x00,0x00,0x22,0xA2,
+0x81,0x54,0x00,0x08,
+0x01,0x00,0x31,0x26,
+0x00,0x00,0xA2,0x8E,
+0x04,0x00,0xB5,0x26,
+0x21,0x80,0x40,0x00,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0xA6,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x63,0x00,0x80,0x12,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x22,0xA2,
+0x01,0x00,0x10,0x26,
+0x8E,0x54,0x00,0x08,
+0x01,0x00,0x31,0x26,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x68,0x00,0x03,0x24,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0xCC,0xFF,0x43,0x14,
+0x01,0x00,0x07,0x24,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x05,0x00,
+0x03,0x16,0x02,0x00,
+0xC9,0xFF,0x43,0x14,
+0x0C,0x00,0x04,0x24,
+0x01,0x00,0x52,0x26,
+0x00,0x00,0x45,0x92,
+0x78,0x00,0x03,0x24,
+0x20,0x00,0xA2,0x34,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0xC7,0xFF,0x43,0x14,
+0x04,0x00,0x04,0x24,
+0x20,0x00,0xA6,0x30,
+0x00,0x00,0xA5,0x8E,
+0x35,0x00,0xE0,0x14,
+0x04,0x00,0xB5,0x26,
+0xCD,0xFF,0x80,0x04,
+0x02,0x80,0x02,0x3C,
+0x48,0xED,0x42,0x24,
+0x00,0x00,0x47,0x8C,
+0x07,0x10,0x85,0x00,
+0x0F,0x00,0x42,0x30,
+0x21,0x10,0x47,0x00,
+0x00,0x00,0x43,0x90,
+0xFC,0xFF,0x84,0x24,
+0x25,0x18,0xC3,0x00,
+0x00,0x00,0x63,0xA2,
+0xF8,0xFF,0x81,0x04,
+0x01,0x00,0x73,0x26,
+0x81,0x54,0x00,0x08,
+0x21,0x80,0xC0,0x03,
+0x00,0x00,0xA2,0x8E,
+0x04,0x00,0xB5,0x26,
+0x28,0x00,0x40,0x04,
+0x21,0x28,0x40,0x00,
+0x21,0x80,0x60,0x02,
+0x02,0x80,0x02,0x3C,
+0x4C,0xED,0x42,0x24,
+0x00,0x00,0x46,0x8C,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xA6,0x00,
+0xC3,0x27,0x05,0x00,
+0x10,0x10,0x00,0x00,
+0x83,0x10,0x02,0x00,
+0x23,0x10,0x44,0x00,
+0x80,0x18,0x02,0x00,
+0x21,0x18,0x62,0x00,
+0x40,0x18,0x03,0x00,
+0x23,0x18,0xA3,0x00,
+0x30,0x00,0x63,0x24,
+0x00,0x00,0x63,0xA2,
+0x21,0x28,0x40,0x00,
+0xF3,0xFF,0x40,0x14,
+0x01,0x00,0x73,0x26,
+0xE1,0x54,0x00,0x08,
+0xFF,0xFF,0x63,0x26,
+0x00,0x00,0x65,0x80,
+0x00,0x00,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x62,0xA0,
+0x00,0x00,0x05,0xA2,
+0xFF,0xFF,0x63,0x24,
+0x01,0x00,0x10,0x26,
+0x2B,0x10,0x03,0x02,
+0xF7,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x81,0x54,0x00,0x08,
+0x21,0x80,0xC0,0x03,
+0x58,0x00,0xC3,0x34,
+0x30,0x00,0x02,0x24,
+0x12,0x00,0xB3,0x27,
+0x10,0x00,0xA2,0xA3,
+0xB2,0x54,0x00,0x08,
+0x11,0x00,0xA3,0xA3,
+0x2D,0x00,0x02,0x24,
+0x23,0x28,0x05,0x00,
+0x11,0x00,0xB3,0x27,
+0xC5,0x54,0x00,0x08,
+0x10,0x00,0xA2,0xA3,
+0x00,0x00,0x04,0x82,
+0x77,0x55,0x00,0x0C,
+0x01,0x00,0x10,0x26,
+0x82,0x54,0x00,0x08,
+0x2B,0x10,0x13,0x02,
+0x00,0x00,0x04,0x82,
+0x77,0x55,0x00,0x0C,
+0x01,0x00,0x10,0x26,
+0x8E,0x54,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA3,0x8E,
+0x28,0x00,0xB0,0x27,
+0x2C,0x00,0xA4,0x27,
+0x2B,0x10,0x04,0x02,
+0x28,0x00,0xA3,0xAF,
+0x0B,0x00,0x40,0x10,
+0x04,0x00,0xB5,0x26,
+0x21,0xB8,0x80,0x00,
+0x02,0x80,0x16,0x3C,
+0x00,0x00,0x06,0x92,
+0x21,0x20,0x60,0x02,
+0x01,0x00,0x10,0x26,
+0x24,0x55,0x00,0x0C,
+0xD0,0xE3,0xC5,0x26,
+0x2B,0x18,0x17,0x02,
+0xF9,0xFF,0x60,0x14,
+0x21,0x98,0x62,0x02,
+0x80,0x54,0x00,0x08,
+0xFF,0xFF,0x73,0x26,
+0x00,0x00,0xA2,0x8E,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x56,0x24,
+0x21,0x80,0x40,0x00,
+0x2B,0x10,0x56,0x00,
+0xF8,0xFF,0x40,0x10,
+0x04,0x00,0xB5,0x26,
+0x02,0x80,0x17,0x3C,
+0x00,0x00,0x06,0x82,
+0x21,0x20,0x60,0x02,
+0x01,0x00,0x10,0x26,
+0x24,0x55,0x00,0x0C,
+0xD4,0xE3,0xE5,0x26,
+0x2B,0x18,0x16,0x02,
+0xF9,0xFF,0x60,0x14,
+0x21,0x98,0x62,0x02,
+0x80,0x54,0x00,0x08,
+0xFF,0xFF,0x73,0x26,
+0x00,0x00,0xA2,0x8E,
+0x04,0x00,0xB5,0x26,
+0x80,0x54,0x00,0x08,
+0x10,0x00,0xA2,0xA3,
+0xE8,0xFF,0xBD,0x27,
+0x20,0x00,0xA6,0xAF,
+0x20,0x00,0xA6,0x27,
+0x10,0x00,0xBF,0xAF,
+0x24,0x00,0xA7,0xAF,
+0x1B,0x54,0x00,0x0C,
+0x1C,0x00,0xA5,0xAF,
+0x10,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x24,0x00,0xA5,0xAF,
+0x28,0x00,0xA6,0xAF,
+0x2C,0x00,0xA7,0xAF,
+0x20,0x00,0xA4,0xAF,
+0x00,0x60,0x11,0x40,
+0x01,0x00,0x21,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x25,0x24,0x00,0x0C,
+0xA0,0x00,0x04,0x24,
+0x19,0x00,0x40,0x10,
+0x21,0x80,0x40,0x00,
+0x08,0x00,0x44,0x94,
+0x20,0x00,0xA5,0x8F,
+0x02,0x80,0x02,0x3C,
+0x25,0x20,0x82,0x00,
+0x20,0x00,0x84,0x24,
+0x1B,0x54,0x00,0x0C,
+0x24,0x00,0xA6,0x27,
+0x01,0x00,0x42,0x24,
+0x13,0x00,0x03,0x24,
+0x81,0x00,0x44,0x2C,
+0x14,0x00,0x03,0xAE,
+0x17,0x00,0x80,0x14,
+0x0C,0x00,0x02,0xAE,
+0x00,0x60,0x01,0x40,
+0x01,0x00,0x21,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x88,0x88,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x88,0x88,0x63,0x34,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x55,0x55,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x91,0x40,
+0x99,0x99,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x99,0x99,0x63,0x34,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x30,0x09,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0x00,0x60,0x91,0x40,
+0x5D,0x55,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x02,0x80,0x06,0x3C,
+0x60,0xF3,0xC5,0x8C,
+0x02,0x80,0x02,0x3C,
+0x40,0xF3,0x42,0x24,
+0x03,0x00,0xA3,0x30,
+0x21,0x18,0x62,0x00,
+0x00,0x00,0x64,0x80,
+0x01,0x00,0xA5,0x24,
+0x77,0x55,0x00,0x0C,
+0x60,0xF3,0xC5,0xAC,
+0x10,0x00,0xBF,0x8F,
+0x08,0x00,0x04,0x24,
+0x77,0x55,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x00,0x26,0x04,0x00,
+0x03,0x26,0x04,0x00,
+0x00,0x00,0x84,0x48,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x26,0x04,0x00,
+0x03,0x26,0x04,0x00,
+0xF7,0xFF,0x82,0x24,
+0x05,0x00,0x42,0x2C,
+0x06,0x00,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x20,0x00,0x02,0x24,
+0x03,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x01,0x00,0x03,0x24,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0x00,0x60,0x02,0x40,
+0x01,0x00,0x41,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x03,0x3C,
+0xD4,0x5E,0x64,0xAC,
+0x00,0x60,0x82,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x05,0x3C,
+0x01,0x00,0x06,0x24,
+0x01,0x80,0x02,0x3C,
+0x04,0x30,0x86,0x00,
+0xF1,0x02,0xA7,0x34,
+0xED,0x02,0xA4,0x34,
+0x4C,0x56,0x42,0x24,
+0x18,0x03,0xA5,0x34,
+0x08,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xAC,
+0x00,0x00,0xE3,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0x86,0xA0,
+0x00,0x00,0x80,0xA0,
+0x00,0x00,0xE0,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x82,0x8C,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0xC6,0x30,
+0x10,0x00,0x02,0x24,
+0x0C,0x00,0xC2,0x10,
+0x11,0x00,0xC3,0x28,
+0x06,0x00,0x60,0x10,
+0x20,0x00,0x02,0x24,
+0x08,0x00,0x02,0x24,
+0x0D,0x00,0xC2,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0xC2,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x85,0xA4,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x85,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x85,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x0A,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0xFF,0xFF,0xA5,0x24,
+0x00,0x2C,0x05,0x00,
+0xFD,0x00,0x63,0x30,
+0x03,0x2C,0x05,0x00,
+0xFF,0xFF,0x87,0x30,
+0x00,0x00,0x43,0xA0,
+0x1A,0x00,0xA0,0x04,
+0x00,0x00,0x00,0x00,
+0x21,0x30,0x40,0x00,
+0x07,0x10,0xA7,0x00,
+0x01,0x00,0x42,0x30,
+0xFD,0x00,0x64,0x30,
+0x00,0x00,0x42,0x38,
+0x02,0x00,0x63,0x34,
+0x0A,0x18,0x82,0x00,
+0x00,0x00,0xC3,0xA0,
+0x04,0x00,0x63,0x34,
+0x00,0x00,0xC3,0xA0,
+0x09,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x41,0x04,
+0xFF,0xFF,0x42,0x24,
+0xFB,0x00,0x63,0x30,
+0x00,0x00,0xC3,0xA0,
+0x04,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x41,0x04,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0xA2,0x24,
+0x00,0x2C,0x02,0x00,
+0x03,0x2C,0x05,0x00,
+0xEA,0xFF,0xA1,0x04,
+0x07,0x10,0xA7,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x0A,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0xFF,0xFF,0x84,0x24,
+0x00,0x24,0x04,0x00,
+0x03,0x24,0x04,0x00,
+0xFF,0x00,0x65,0x30,
+0x1D,0x00,0x80,0x04,
+0x21,0x38,0x00,0x00,
+0x21,0x30,0x40,0x00,
+0x01,0x00,0x08,0x24,
+0x04,0x00,0xA5,0x34,
+0x00,0x00,0xC5,0xA0,
+0x00,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x45,0x30,
+0x01,0x00,0xA3,0x30,
+0x05,0x00,0x60,0x10,
+0x04,0x00,0x02,0x24,
+0x04,0x10,0x88,0x00,
+0x25,0x10,0x47,0x00,
+0xFF,0xFF,0x47,0x30,
+0x04,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x41,0x04,
+0xFF,0xFF,0x42,0x24,
+0xFB,0x00,0xA5,0x30,
+0x00,0x00,0xC5,0xA0,
+0x09,0x00,0x02,0x24,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x41,0x04,
+0xFF,0xFF,0x42,0x24,
+0xFF,0xFF,0x82,0x24,
+0x00,0x24,0x02,0x00,
+0x03,0x24,0x04,0x00,
+0xE7,0xFF,0x81,0x04,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xE0,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x25,0xB0,0x10,0x3C,
+0x0A,0x00,0x10,0x36,
+0x18,0x00,0xBF,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x00,0x00,0x02,0x92,
+0xFF,0xFF,0x91,0x30,
+0x03,0x00,0x05,0x24,
+0xC0,0x00,0x42,0x30,
+0x80,0x00,0x43,0x34,
+0x00,0x00,0x03,0xA2,
+0x04,0x00,0x63,0x34,
+0x00,0x00,0x03,0xA2,
+0xFB,0x00,0x63,0x30,
+0x00,0x00,0x03,0xA2,
+0x08,0x00,0x63,0x34,
+0x00,0x00,0x03,0xA2,
+0x04,0x00,0x63,0x34,
+0x00,0x00,0x03,0xA2,
+0xFB,0x00,0x63,0x30,
+0x00,0x00,0x03,0xA2,
+0xC9,0x55,0x00,0x0C,
+0x06,0x00,0x04,0x24,
+0x42,0x20,0x11,0x00,
+0xC9,0x55,0x00,0x0C,
+0x06,0x00,0x05,0x24,
+0xEF,0x55,0x00,0x0C,
+0x10,0x00,0x04,0x24,
+0x00,0x00,0x03,0x92,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0xC0,0x00,0x63,0x30,
+0x00,0x00,0x03,0xA2,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0xFF,0xFF,0xB1,0x30,
+0x18,0x00,0xB2,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x21,0x90,0xC0,0x00,
+0x0A,0x00,0x20,0x12,
+0xFF,0xFF,0x90,0x30,
+0x16,0x56,0x00,0x0C,
+0x21,0x20,0x00,0x02,
+0xFE,0xFF,0x23,0x26,
+0x02,0x00,0x04,0x26,
+0x00,0x00,0x42,0xA6,
+0xFF,0xFF,0x71,0x30,
+0xFF,0xFF,0x90,0x30,
+0xF8,0xFF,0x20,0x16,
+0x02,0x00,0x52,0x26,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x0A,0x00,0x67,0x34,
+0x00,0x00,0xE2,0x90,
+0xFF,0xFF,0xB2,0x30,
+0x21,0x98,0xC0,0x00,
+0xFF,0x00,0x91,0x30,
+0x20,0x00,0x40,0x12,
+0xFF,0x00,0x50,0x30,
+0x21,0xA0,0xE0,0x00,
+0x0C,0x00,0x77,0x34,
+0x0B,0x00,0x76,0x34,
+0x21,0xF0,0xE0,0x00,
+0xC0,0xFF,0x15,0x24,
+0x25,0x10,0x15,0x02,
+0xFF,0x00,0x50,0x30,
+0x00,0x00,0xD1,0xA2,
+0x00,0x00,0x90,0xA2,
+0x00,0x00,0x82,0x92,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x50,0x30,
+0xC0,0x00,0x03,0x32,
+0x07,0x00,0x60,0x10,
+0x21,0x20,0xC0,0x03,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x50,0x30,
+0xC0,0x00,0x03,0x32,
+0xFB,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE2,0x8E,
+0x04,0x00,0x23,0x26,
+0x64,0x00,0x04,0x24,
+0x00,0x00,0x62,0xAE,
+0x25,0x22,0x00,0x0C,
+0xFF,0x00,0x71,0x30,
+0xFC,0xFF,0x42,0x26,
+0xFF,0xFF,0x52,0x30,
+0xE7,0xFF,0x40,0x16,
+0x04,0x00,0x73,0x26,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x25,0xB0,0x06,0x3C,
+0x31,0x00,0xC2,0x34,
+0xFF,0xFF,0x84,0x30,
+0x00,0x00,0x44,0xA0,
+0x32,0x00,0xC7,0x34,
+0x00,0x00,0xE3,0x90,
+0xFC,0xFF,0x02,0x24,
+0x02,0x22,0x04,0x00,
+0x24,0x18,0x62,0x00,
+0x03,0x00,0x84,0x30,
+0x25,0x20,0x83,0x00,
+0x33,0x00,0xC6,0x34,
+0x72,0x00,0x02,0x24,
+0x00,0x00,0xE4,0xA0,
+0x00,0x00,0xC2,0xA0,
+0x00,0x00,0xC3,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0x05,0x00,0x61,0x04,
+0x21,0x10,0x00,0x00,
+0xB5,0x56,0x00,0x08,
+0x25,0xB0,0x02,0x3C,
+0x11,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC3,0x90,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0xF8,0xFF,0x61,0x04,
+0x64,0x00,0x44,0x2C,
+0x64,0x00,0x44,0x2C,
+0x07,0x00,0x80,0x10,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x30,0x00,0x42,0x34,
+0x00,0x00,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0xA3,0xA0,
+0xFF,0xFF,0x02,0x24,
+0x00,0x00,0xA2,0xA0,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x25,0xB0,0x06,0x3C,
+0x31,0x00,0xC2,0x34,
+0xFF,0xFF,0x84,0x30,
+0x00,0x00,0x44,0xA0,
+0x32,0x00,0xC3,0x34,
+0x00,0x00,0x62,0x90,
+0x02,0x22,0x04,0x00,
+0x03,0x00,0x84,0x30,
+0x25,0x20,0x82,0x00,
+0x00,0x00,0x64,0xA0,
+0x33,0x00,0xC7,0x34,
+0xFF,0x00,0xA5,0x30,
+0x30,0x00,0xC6,0x34,
+0xF2,0xFF,0x03,0x24,
+0x00,0x00,0xC5,0xA0,
+0x00,0x00,0xE3,0xA0,
+0x00,0x00,0xE2,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x16,0x02,0x00,
+0x03,0x16,0x02,0x00,
+0x03,0x00,0x40,0x04,
+0x21,0x20,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x01,0x00,0x02,0x24,
+0xDA,0x56,0x00,0x08,
+0x21,0x30,0xE0,0x00,
+0x0B,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC3,0x90,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x00,0x1E,0x03,0x00,
+0x03,0x1E,0x03,0x00,
+0xF8,0xFF,0x60,0x04,
+0x64,0x00,0x82,0x2C,
+0x64,0x00,0x82,0x2C,
+0xF1,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x25,0xB0,0x02,0x3C,
+0x18,0x00,0xB0,0xAF,
+0xF8,0x02,0x45,0x34,
+0x25,0xB0,0x10,0x3C,
+0xFF,0x00,0x83,0x30,
+0x01,0x00,0x02,0x24,
+0x1C,0x00,0xBF,0xAF,
+0x03,0x00,0x06,0x36,
+0x0A,0x00,0x62,0x10,
+0x0A,0x00,0x04,0x24,
+0x00,0x00,0xA2,0x90,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0xA2,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x20,0x00,0x43,0x34,
+0x20,0x00,0x42,0x30,
+0x02,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC3,0xA0,
+0x25,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x04,0x36,
+0x00,0x00,0x82,0x90,
+0xFE,0xFF,0x03,0x24,
+0xF8,0x02,0x06,0x36,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA0,
+0x00,0x00,0xC3,0x90,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0x00,0x00,
+0x03,0x00,0x63,0x34,
+0x00,0x00,0xC3,0xA0,
+0x91,0x56,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xFF,0x00,0x84,0x30,
+0x21,0x38,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0xA3,0x24,
+0x07,0x10,0xA4,0x00,
+0x01,0x00,0x42,0x30,
+0xFF,0x00,0x65,0x30,
+0x01,0x00,0xE6,0x24,
+0x02,0x00,0x40,0x14,
+0x04,0x00,0xA3,0x2C,
+0xFF,0x00,0xC7,0x30,
+0xF7,0xFF,0x60,0x14,
+0x21,0x10,0xE0,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x8C,0x30,
+0x21,0x48,0x00,0x00,
+0x21,0x38,0x00,0x00,
+0x40,0x10,0x07,0x00,
+0xFF,0x00,0x42,0x30,
+0x21,0x50,0x46,0x00,
+0x01,0x00,0xE3,0x24,
+0x07,0x10,0xEC,0x00,
+0x01,0x00,0x42,0x30,
+0xFF,0x00,0x67,0x30,
+0x21,0x58,0x25,0x01,
+0x01,0x00,0x24,0x25,
+0x09,0x00,0x40,0x14,
+0x04,0x00,0xE8,0x2C,
+0x00,0x00,0x63,0x91,
+0xFF,0x00,0x89,0x30,
+0x21,0x20,0x25,0x01,
+0x00,0x00,0x43,0xA1,
+0x00,0x00,0x83,0x90,
+0x01,0x00,0x22,0x25,
+0xFF,0x00,0x49,0x30,
+0x01,0x00,0x43,0xA1,
+0xED,0xFF,0x00,0x15,
+0x40,0x10,0x07,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x24,0x00,0xBF,0xAF,
+0x01,0x00,0x12,0x24,
+0x21,0x80,0x00,0x00,
+0x57,0x57,0x00,0x08,
+0xFF,0x00,0x11,0x24,
+0x91,0x56,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x40,0x10,
+0x00,0x02,0x03,0x2E,
+0x0F,0x00,0x60,0x10,
+0x21,0x10,0x00,0x02,
+0x10,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x51,0x10,
+0x0F,0x00,0x44,0x30,
+0x15,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x40,0x10,0x02,0x00,
+0x21,0x10,0x50,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x50,0x30,
+0x21,0x20,0x00,0x02,
+0xEE,0xFF,0x40,0x16,
+0x10,0x00,0xA5,0x27,
+0x21,0x10,0x00,0x02,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xB8,0xFF,0xBD,0x27,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x24,0x00,0xB1,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x21,0x98,0xA0,0x00,
+0xFF,0x00,0x96,0x30,
+0x01,0x00,0x10,0x24,
+0x01,0x00,0x17,0x24,
+0x21,0xA0,0x00,0x00,
+0x21,0x88,0x00,0x00,
+0x21,0xA8,0x00,0x00,
+0x04,0x00,0xA0,0x10,
+0x21,0x18,0x00,0x00,
+0x10,0x00,0xC2,0x2E,
+0x0E,0x00,0x40,0x14,
+0x21,0x20,0xA0,0x00,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x08,0x00,0x06,0x24,
+0xFF,0x51,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x18,0x00,0xA4,0x27,
+0xFF,0x00,0x05,0x24,
+0xFF,0x51,0x00,0x0C,
+0x08,0x00,0x06,0x24,
+0xE6,0x56,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x96,0x57,0x00,0x08,
+0x10,0x00,0xBE,0x27,
+0x1C,0x00,0x40,0x14,
+0x21,0x20,0xA0,0x02,
+0x37,0x00,0xE0,0x12,
+0x00,0x02,0x22,0x2E,
+0x35,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x32,
+0xF8,0xFF,0x40,0x10,
+0x20,0x00,0x02,0x32,
+0x21,0x20,0x20,0x02,
+0x91,0x56,0x00,0x0C,
+0x10,0x00,0xA5,0x27,
+0x2D,0x00,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x10,0x00,0xB0,0x93,
+0x00,0x00,0x00,0x00,
+0x29,0x00,0x02,0x12,
+0x0F,0x00,0x15,0x32,
+0x15,0x57,0x00,0x0C,
+0x21,0x20,0xA0,0x02,
+0x02,0x81,0x10,0x00,
+0x10,0x00,0x16,0x12,
+0x21,0xA0,0x40,0x00,
+0x40,0x10,0x14,0x00,
+0x21,0x10,0x51,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x51,0x30,
+0x92,0x57,0x00,0x08,
+0x01,0x00,0x10,0x24,
+0x18,0x00,0xA5,0x27,
+0x24,0x57,0x00,0x0C,
+0x21,0x30,0x60,0x02,
+0x40,0x10,0x14,0x00,
+0x21,0x10,0x51,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x51,0x30,
+0x92,0x57,0x00,0x08,
+0x01,0x00,0x10,0x24,
+0x40,0x90,0x02,0x00,
+0x10,0x00,0x40,0x1A,
+0x21,0x80,0x00,0x00,
+0x21,0x20,0x30,0x02,
+0x01,0x00,0x84,0x24,
+0xFF,0xFF,0x84,0x30,
+0x91,0x56,0x00,0x0C,
+0x10,0x00,0xA5,0x27,
+0x01,0x00,0x03,0x26,
+0x21,0x20,0xD0,0x03,
+0xFF,0x00,0x70,0x30,
+0x04,0x00,0x40,0x10,
+0x2A,0x18,0x12,0x02,
+0x10,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x82,0xA0,
+0xF3,0xFF,0x60,0x14,
+0x21,0x20,0x30,0x02,
+0x92,0x57,0x00,0x08,
+0x20,0x00,0x10,0x24,
+0xE6,0x56,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x63,0x92,
+0xFF,0x00,0x02,0x24,
+0x0F,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0x01,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0xF0,0xFF,0x43,0x14,
+0x01,0x00,0x03,0x24,
+0x02,0x00,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0xEB,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0x43,0x14,
+0x01,0x00,0x03,0x24,
+0x04,0x00,0x63,0x92,
+0x00,0x00,0x00,0x00,
+0xE3,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x05,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0xDF,0xFF,0x43,0x14,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x67,0x92,
+0x00,0x00,0x00,0x00,
+0xDC,0xFF,0xE2,0x14,
+0x01,0x00,0x03,0x24,
+0x07,0x00,0x62,0x92,
+0x00,0x00,0x00,0x00,
+0x7F,0xFF,0x47,0x10,
+0x21,0x18,0x00,0x00,
+0xD1,0x57,0x00,0x08,
+0x01,0x00,0x03,0x24,
+0xC0,0xFF,0xBD,0x27,
+0x38,0x00,0xBE,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x21,0xF0,0xC0,0x00,
+0xFF,0x00,0xB6,0x30,
+0xFF,0xFF,0x95,0x30,
+0xFF,0x00,0x05,0x24,
+0x10,0x00,0xA4,0x27,
+0x08,0x00,0x06,0x24,
+0x34,0x00,0xB7,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x3C,0x00,0xBF,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0xFF,0x51,0x00,0x0C,
+0x0F,0x00,0x17,0x24,
+0x21,0x98,0x00,0x00,
+0x40,0x10,0x13,0x00,
+0xFF,0x00,0x52,0x30,
+0x07,0x10,0x76,0x02,
+0x01,0x00,0x42,0x30,
+0x21,0xA0,0x5E,0x02,
+0x21,0x88,0xA0,0x02,
+0x21,0x20,0xA0,0x02,
+0x13,0x00,0x40,0x10,
+0x01,0x00,0xA3,0x26,
+0x01,0x00,0x62,0x26,
+0xFF,0x00,0x53,0x30,
+0x04,0x00,0x63,0x2E,
+0xF4,0xFF,0x60,0x14,
+0x40,0x10,0x13,0x00,
+0x21,0x10,0xE0,0x02,
+0x3C,0x00,0xBF,0x8F,
+0x38,0x00,0xBE,0x8F,
+0x34,0x00,0xB7,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x40,0x00,0xBD,0x27,
+0x00,0x00,0x85,0x92,
+0xFF,0xFF,0x75,0x30,
+0xBE,0x56,0x00,0x0C,
+0x21,0x80,0xA0,0x02,
+0x01,0x00,0x85,0x92,
+0x21,0x20,0xA0,0x02,
+0x01,0x00,0xA2,0x26,
+0xBE,0x56,0x00,0x0C,
+0xFF,0xFF,0x55,0x30,
+0x10,0x00,0xA3,0x27,
+0x21,0x90,0x72,0x00,
+0x21,0x20,0x20,0x02,
+0x91,0x56,0x00,0x0C,
+0x21,0x28,0x40,0x02,
+0x21,0x20,0x00,0x02,
+0x91,0x56,0x00,0x0C,
+0x01,0x00,0x45,0x26,
+0x00,0x00,0x84,0x92,
+0x00,0x00,0x42,0x92,
+0x01,0x00,0x03,0x24,
+0x04,0x18,0x63,0x02,
+0x03,0x00,0x82,0x10,
+0x27,0x30,0x03,0x00,
+0x19,0x58,0x00,0x08,
+0x24,0xB8,0xD7,0x00,
+0x01,0x00,0x83,0x92,
+0x01,0x00,0x42,0x92,
+0x00,0x00,0x00,0x00,
+0xD2,0xFF,0x62,0x10,
+0x01,0x00,0x62,0x26,
+0x1A,0x58,0x00,0x08,
+0x24,0xB8,0xD7,0x00,
+0x98,0xFF,0xBD,0x27,
+0x50,0x00,0xB4,0xAF,
+0xFF,0x00,0x94,0x30,
+0x01,0x00,0x04,0x24,
+0x64,0x00,0xBF,0xAF,
+0x60,0x00,0xBE,0xAF,
+0x5C,0x00,0xB7,0xAF,
+0x58,0x00,0xB6,0xAF,
+0x4C,0x00,0xB3,0xAF,
+0x48,0x00,0xB2,0xAF,
+0x44,0x00,0xB1,0xAF,
+0x21,0x98,0xC0,0x00,
+0xFF,0x00,0xB1,0x30,
+0x54,0x00,0xB5,0xAF,
+0xE6,0x56,0x00,0x0C,
+0x40,0x00,0xB0,0xAF,
+0x3E,0x57,0x00,0x0C,
+0x01,0x00,0x16,0x24,
+0x21,0x18,0x40,0x00,
+0xFF,0x01,0x42,0x2C,
+0x01,0x00,0x17,0x24,
+0x01,0x00,0x1E,0x24,
+0x21,0x90,0x00,0x00,
+0x0E,0x00,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x64,0x00,0xBF,0x8F,
+0x60,0x00,0xBE,0x8F,
+0x5C,0x00,0xB7,0x8F,
+0x58,0x00,0xB6,0x8F,
+0x54,0x00,0xB5,0x8F,
+0x50,0x00,0xB4,0x8F,
+0x4C,0x00,0xB3,0x8F,
+0x48,0x00,0xB2,0x8F,
+0x44,0x00,0xB1,0x8F,
+0x40,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x68,0x00,0xBD,0x27,
+0xFF,0x01,0x02,0x24,
+0x23,0x10,0x43,0x00,
+0x1A,0x00,0xA4,0x27,
+0xFF,0x00,0x05,0x24,
+0x08,0x00,0x06,0x24,
+0xFF,0xFF,0x50,0x30,
+0x18,0x00,0xB4,0xA3,
+0xFF,0x51,0x00,0x0C,
+0x19,0x00,0xB1,0xA3,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x60,0x02,
+0x24,0x57,0x00,0x0C,
+0x1A,0x00,0xA6,0x27,
+0x19,0x00,0xA4,0x93,
+0x15,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0xA8,0x40,0x00,
+0xFF,0xFF,0x42,0x30,
+0x2B,0x10,0x02,0x02,
+0xDF,0xFF,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x09,0x00,0xC2,0x12,
+0x20,0x00,0x02,0x24,
+0x22,0x00,0xC2,0x12,
+0x00,0x00,0x00,0x00,
+0x3B,0x00,0xE0,0x12,
+0x00,0x02,0x42,0x2E,
+0x39,0x00,0x40,0x10,
+0x01,0x00,0x02,0x24,
+0xF9,0xFF,0xC2,0x16,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x40,0x02,
+0x10,0x00,0xA5,0x27,
+0x91,0x56,0x00,0x0C,
+0x01,0x00,0x13,0x24,
+0x41,0x00,0x40,0x10,
+0xFF,0x00,0x02,0x24,
+0x10,0x00,0xA5,0x93,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0xA4,0x30,
+0x3C,0x00,0x82,0x10,
+0x0F,0x00,0xA3,0x30,
+0x02,0x11,0x04,0x00,
+0x21,0x20,0x60,0x00,
+0x29,0x00,0xA3,0xA3,
+0x28,0x00,0xA2,0xA3,
+0x15,0x57,0x00,0x0C,
+0x11,0x00,0xA5,0xA3,
+0x21,0x80,0x40,0x00,
+0x28,0x00,0xA3,0x93,
+0x18,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x5F,0x00,0x62,0x10,
+0x40,0x10,0x10,0x00,
+0x21,0x10,0x52,0x00,
+0x01,0x00,0x42,0x24,
+0x8B,0x58,0x00,0x08,
+0xFF,0xFF,0x52,0x30,
+0x19,0x00,0xA5,0x93,
+0x01,0x00,0x44,0x26,
+0xFF,0xFF,0x84,0x30,
+0xFC,0x57,0x00,0x0C,
+0x1A,0x00,0xA6,0x27,
+0x21,0x28,0x40,0x00,
+0x0F,0x00,0x43,0x30,
+0x0F,0x00,0x02,0x24,
+0x12,0x00,0x62,0x10,
+0x40,0x10,0x15,0x00,
+0x21,0x10,0x52,0x00,
+0x01,0x00,0x42,0x24,
+0x21,0x20,0xA0,0x00,
+0xFF,0xFF,0x52,0x30,
+0x18,0x00,0xB4,0xA3,
+0x15,0x57,0x00,0x0C,
+0x19,0x00,0xA5,0xA3,
+0x21,0xA8,0x40,0x00,
+0x02,0x80,0x03,0x3C,
+0x04,0xE4,0x62,0x8C,
+0x02,0x80,0x04,0x3C,
+0x01,0x00,0x16,0x24,
+0x01,0x00,0x42,0x24,
+0x04,0x00,0x43,0x28,
+0xC6,0xFF,0x60,0x14,
+0x04,0xE4,0x82,0xAC,
+0x21,0xF0,0x00,0x00,
+0xE6,0x56,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x21,0x20,0xC0,0x03,
+0x64,0x00,0xBF,0x8F,
+0x60,0x00,0xBE,0x8F,
+0x5C,0x00,0xB7,0x8F,
+0x58,0x00,0xB6,0x8F,
+0x54,0x00,0xB5,0x8F,
+0x50,0x00,0xB4,0x8F,
+0x4C,0x00,0xB3,0x8F,
+0x48,0x00,0xB2,0x8F,
+0x44,0x00,0xB1,0x8F,
+0x40,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x08,0x00,0xE0,0x03,
+0x68,0x00,0xBD,0x27,
+0x3E,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFF,0x01,0x03,0x24,
+0x23,0x18,0x62,0x00,
+0xFF,0xFF,0x70,0x30,
+0xFF,0xFF,0xA2,0x32,
+0x2B,0x10,0x02,0x02,
+0xE7,0xFF,0x40,0x14,
+0x21,0x20,0x40,0x02,
+0x18,0x00,0xB0,0x93,
+0x19,0x00,0xA2,0x93,
+0x00,0x81,0x10,0x00,
+0x25,0x80,0x02,0x02,
+0xFF,0x00,0x10,0x32,
+0xBE,0x56,0x00,0x0C,
+0x21,0x28,0x00,0x02,
+0x21,0x20,0x40,0x02,
+0x91,0x56,0x00,0x0C,
+0x11,0x00,0xA5,0x27,
+0x11,0x00,0xA3,0x93,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x64,0x30,
+0x9D,0xFF,0x90,0x10,
+0x20,0x00,0x16,0x24,
+0xFF,0x00,0x02,0x24,
+0xCD,0xFF,0x82,0x10,
+0x0F,0x00,0x63,0x30,
+0x02,0x11,0x04,0x00,
+0x21,0x20,0x60,0x00,
+0x29,0x00,0xA3,0xA3,
+0x15,0x57,0x00,0x0C,
+0x28,0x00,0xA2,0xA3,
+0x38,0x00,0xA4,0x27,
+0xFF,0x00,0x05,0x24,
+0x08,0x00,0x06,0x24,
+0xFF,0x51,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x28,0x00,0xA4,0x93,
+0x61,0x57,0x00,0x0C,
+0x38,0x00,0xA5,0x27,
+0x1F,0x00,0x40,0x14,
+0x01,0x00,0x44,0x26,
+0x40,0x10,0x10,0x00,
+0x21,0x10,0x52,0x00,
+0x01,0x00,0x42,0x24,
+0xBE,0x58,0x00,0x08,
+0xFF,0xFF,0x52,0x30,
+0x40,0x88,0x10,0x00,
+0x27,0x00,0x20,0x1A,
+0x21,0x80,0x00,0x00,
+0xFF,0x00,0x16,0x24,
+0x21,0x20,0x50,0x02,
+0x01,0x00,0x84,0x24,
+0xFF,0xFF,0x84,0x30,
+0x91,0x56,0x00,0x0C,
+0x10,0x00,0xA5,0x27,
+0x01,0x00,0x03,0x26,
+0xFF,0x00,0x70,0x30,
+0x05,0x00,0x40,0x10,
+0x2A,0x18,0x11,0x02,
+0x10,0x00,0xA2,0x93,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x56,0x00,
+0x0B,0x98,0x02,0x00,
+0xF3,0xFF,0x60,0x14,
+0x21,0x20,0x50,0x02,
+0x15,0x00,0x60,0x16,
+0x21,0x10,0x32,0x02,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x52,0x30,
+0x8B,0x58,0x00,0x08,
+0x01,0x00,0x16,0x24,
+0x29,0x00,0xA5,0x93,
+0xFF,0xFF,0x84,0x30,
+0xFC,0x57,0x00,0x0C,
+0x38,0x00,0xA6,0x27,
+0x21,0x28,0x40,0x00,
+0x0F,0x00,0x43,0x30,
+0x0F,0x00,0x02,0x24,
+0xDB,0xFF,0x62,0x10,
+0x40,0x10,0x10,0x00,
+0x28,0x00,0xA4,0x93,
+0x4B,0x58,0x00,0x0C,
+0x38,0x00,0xA6,0x27,
+0x3E,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xBE,0x58,0x00,0x08,
+0x21,0x90,0x40,0x00,
+0x19,0x00,0xA3,0x93,
+0x29,0x00,0xA6,0x93,
+0x0F,0x00,0x13,0x24,
+0x0E,0x00,0x10,0x24,
+0x25,0x18,0x66,0x00,
+0x01,0x00,0x62,0x30,
+0x0A,0x98,0x02,0x02,
+0x02,0x00,0x64,0x30,
+0xFD,0x00,0x62,0x32,
+0x0A,0x98,0x44,0x00,
+0x04,0x00,0x65,0x30,
+0xFB,0x00,0x62,0x32,
+0x0A,0x98,0x45,0x00,
+0x08,0x00,0x63,0x30,
+0xF7,0x00,0x62,0x32,
+0x0A,0x98,0x43,0x00,
+0x0F,0x00,0x64,0x32,
+0x0F,0x00,0x16,0x24,
+0x25,0x00,0x96,0x10,
+0x21,0x28,0xC0,0x00,
+0x01,0x00,0x44,0x26,
+0xFF,0xFF,0x84,0x30,
+0xFC,0x57,0x00,0x0C,
+0x1A,0x00,0xA6,0x27,
+0x21,0x28,0x40,0x00,
+0x0F,0x00,0x42,0x30,
+0x03,0x00,0x56,0x10,
+0x21,0x20,0x80,0x02,
+0x4B,0x58,0x00,0x0C,
+0x38,0x00,0xA6,0x27,
+0x19,0x00,0xA5,0x93,
+0x00,0x00,0x00,0x00,
+0x26,0x10,0x65,0x02,
+0x01,0x00,0x42,0x30,
+0x0A,0x80,0xC2,0x02,
+0x26,0x18,0x65,0x02,
+0x02,0x00,0x63,0x30,
+0xFD,0x00,0x04,0x32,
+0x0B,0x80,0x83,0x00,
+0x26,0x10,0x65,0x02,
+0x04,0x00,0x42,0x30,
+0xFB,0x00,0x03,0x32,
+0x0B,0x80,0x62,0x00,
+0x26,0x28,0x65,0x02,
+0x08,0x00,0xA5,0x30,
+0xF7,0x00,0x02,0x32,
+0x0B,0x80,0x45,0x00,
+0x0F,0x00,0x03,0x32,
+0x0D,0x00,0x76,0x10,
+0x00,0x00,0x00,0x00,
+0x3E,0x57,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x90,0x40,0x00,
+0x19,0x00,0xB0,0xA3,
+0xBE,0x58,0x00,0x08,
+0x18,0x00,0xB4,0xA3,
+0x21,0x10,0x32,0x02,
+0x01,0x00,0x42,0x24,
+0xFF,0xFF,0x52,0x30,
+0x01,0x00,0x16,0x24,
+0x8B,0x58,0x00,0x08,
+0x18,0x00,0xB4,0xA3,
+0xBE,0x58,0x00,0x08,
+0x21,0xB8,0x00,0x00,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xBC,0x65,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0x83,0x90,
+0x30,0x00,0x02,0x24,
+0x05,0x00,0x62,0x10,
+0x21,0x20,0x00,0x00,
+0x31,0x00,0x02,0x24,
+0x02,0x00,0x62,0x10,
+0x01,0x00,0x04,0x24,
+0x07,0x00,0x04,0x24,
+0x93,0x55,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x02,0x3C,
+0x25,0xB0,0x03,0x3C,
+0xF8,0x65,0x42,0x24,
+0x18,0x03,0x63,0x34,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x62,0xAC,
+0x08,0x00,0xE0,0x03,
+0x14,0x5E,0x80,0xAC,
+0x42,0xB0,0x02,0x3C,
+0x03,0x00,0x47,0x34,
+0x00,0x00,0xE3,0x90,
+0xFF,0x00,0x84,0x30,
+0x04,0x00,0x84,0x24,
+0xFF,0x00,0x65,0x30,
+0x01,0x00,0x02,0x24,
+0x04,0x30,0x82,0x00,
+0x07,0x18,0x85,0x00,
+0x25,0xB0,0x02,0x3C,
+0xE8,0x03,0x42,0x34,
+0x01,0x00,0x63,0x30,
+0x21,0x20,0xC0,0x00,
+0x00,0x00,0x45,0xA0,
+0x02,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE6,0xA0,
+0x08,0x00,0xE0,0x03,
+0x24,0x10,0x85,0x00,
+0x00,0x60,0x03,0x40,
+0x01,0x00,0x61,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x02,0x80,0x02,0x3C,
+0x08,0xE4,0x42,0x24,
+0x04,0x00,0x45,0x8C,
+0x00,0x00,0x82,0xAC,
+0x04,0x00,0x44,0xAC,
+0x00,0x00,0xA4,0xAC,
+0x04,0x00,0x85,0xAC,
+0x00,0x60,0x83,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x03,0x40,
+0x01,0x00,0x61,0x34,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x04,0x00,0x85,0x8C,
+0x00,0x00,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA2,0xAC,
+0x04,0x00,0x45,0xAC,
+0x00,0x00,0x84,0xAC,
+0x04,0x00,0x84,0xAC,
+0x00,0x60,0x83,0x40,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x85,0xAC,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x24,0x04,0x00,
+0xFF,0x00,0x84,0x30,
+0xC0,0x18,0x04,0x00,
+0x21,0x18,0x64,0x00,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x64,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x1C,0x24,0x64,0x8C,
+0xFF,0xF1,0x02,0x24,
+0x24,0x20,0x82,0x00,
+0x08,0x00,0xE0,0x03,
+0x1C,0x24,0x64,0xAC,
+0x02,0x24,0x04,0x00,
+0xFF,0x00,0x84,0x30,
+0xC0,0x18,0x04,0x00,
+0x21,0x18,0x64,0x00,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x64,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x62,0x00,
+0x1C,0x24,0x64,0x8C,
+0xFF,0xF1,0x02,0x24,
+0x24,0x20,0x82,0x00,
+0x00,0x02,0x84,0x34,
+0x08,0x00,0xE0,0x03,
+0x1C,0x24,0x64,0xAC,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0xC0,0x80,0x04,0x00,
+0x21,0x80,0x04,0x02,
+0x80,0x80,0x10,0x00,
+0x21,0x80,0x04,0x02,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x80,0x10,0x00,
+0x21,0x80,0x02,0x02,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x24,0x05,0x8E,
+0xFF,0x1F,0x02,0x3C,
+0x25,0xB0,0x12,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x14,0x24,0x02,0xAE,
+0x84,0x01,0x43,0x36,
+0xF8,0xFF,0x02,0x24,
+0x00,0x00,0x66,0x8C,
+0x24,0x28,0xA2,0x00,
+0xFF,0xFE,0x02,0x24,
+0x24,0x28,0xA2,0x00,
+0xFF,0xEF,0x03,0x24,
+0x24,0x28,0xA3,0x00,
+0x18,0x24,0x06,0xAE,
+0x1C,0x24,0x05,0xAE,
+0xC9,0x24,0x00,0x0C,
+0x21,0x88,0x80,0x00,
+0x1E,0x24,0x02,0x92,
+0x21,0x88,0x32,0x02,
+0x1C,0x00,0xBF,0x8F,
+0x60,0x01,0x22,0xA2,
+0x18,0x00,0xB2,0x8F,
+0x08,0x24,0x00,0xAE,
+0xEC,0x23,0x00,0xAE,
+0xF0,0x23,0x00,0xAE,
+0xF4,0x23,0x00,0xAE,
+0xF8,0x23,0x00,0xAE,
+0xFC,0x23,0x00,0xAE,
+0x00,0x24,0x00,0xAE,
+0x04,0x24,0x00,0xAE,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xFF,0x00,0xA5,0x30,
+0xC0,0x10,0x05,0x00,
+0x21,0x10,0x45,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x45,0x00,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x63,0x24,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x1C,0x24,0x43,0x8C,
+0x25,0xB0,0x05,0x3C,
+0xFF,0x00,0xC6,0x30,
+0x21,0x30,0xC5,0x00,
+0xAF,0x01,0xC2,0x90,
+0x07,0x00,0x63,0x30,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x65,0x00,
+0xFF,0x00,0x88,0x30,
+0xFF,0x00,0x49,0x30,
+0x84,0x01,0x66,0x8C,
+0x21,0x50,0x00,0x00,
+0x21,0x58,0x00,0x00,
+0x2B,0x00,0x20,0x11,
+0x21,0x20,0x00,0x01,
+0x2B,0x00,0xC0,0x10,
+0x2B,0x10,0x09,0x01,
+0x21,0x28,0x00,0x00,
+0x2D,0x5A,0x00,0x08,
+0x01,0x00,0x07,0x24,
+0xFF,0x00,0x65,0x30,
+0x1D,0x00,0xA2,0x2C,
+0x07,0x00,0x40,0x10,
+0xFF,0xFF,0x02,0x25,
+0x04,0x10,0xA7,0x00,
+0x24,0x10,0x46,0x00,
+0xF9,0xFF,0x40,0x10,
+0x01,0x00,0xA3,0x24,
+0x21,0x58,0xA0,0x00,
+0xFF,0xFF,0x02,0x25,
+0xFF,0x00,0x45,0x30,
+0x2B,0x18,0xAB,0x00,
+0x0F,0x00,0x60,0x14,
+0x2B,0x10,0x49,0x01,
+0x01,0x00,0x04,0x24,
+0x04,0x10,0xA4,0x00,
+0x24,0x10,0x46,0x00,
+0xFF,0xFF,0xA7,0x24,
+0x04,0x00,0x40,0x10,
+0x01,0x00,0x43,0x25,
+0x17,0x00,0x49,0x11,
+0xFF,0x00,0x6A,0x30,
+0x21,0x40,0xA0,0x00,
+0xFF,0x00,0xE5,0x30,
+0x2B,0x10,0xAB,0x00,
+0xF6,0xFF,0x40,0x10,
+0x04,0x10,0xA4,0x00,
+0x2B,0x10,0x49,0x01,
+0x08,0x00,0x40,0x10,
+0x21,0x20,0x00,0x01,
+0x23,0x10,0x2A,0x01,
+0x2A,0x10,0x62,0x01,
+0x04,0x00,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x23,0x10,0x69,0x01,
+0x21,0x10,0x4A,0x00,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0xFD,0xFF,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x23,0x10,0x09,0x01,
+0x4E,0x5A,0x00,0x08,
+0xFF,0x00,0x44,0x30,
+0x21,0x20,0x00,0x01,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0xFF,0x00,0x84,0x30,
+0xC0,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x63,0x24,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x25,0xB0,0x06,0x3C,
+0x1C,0x24,0x43,0x8C,
+0xFF,0x00,0xA5,0x30,
+0x21,0x20,0x86,0x00,
+0x21,0x28,0xA6,0x00,
+0x60,0x01,0x82,0x90,
+0xAF,0x01,0xA4,0x90,
+0x07,0x00,0x63,0x30,
+0x80,0x18,0x03,0x00,
+0x21,0x18,0x66,0x00,
+0xFF,0x00,0x48,0x30,
+0xFF,0x00,0x89,0x30,
+0x84,0x01,0x66,0x8C,
+0x21,0x50,0x00,0x00,
+0x21,0x58,0x00,0x00,
+0x2B,0x00,0x20,0x11,
+0x21,0x20,0x00,0x01,
+0x2B,0x00,0xC0,0x10,
+0x2B,0x10,0x09,0x01,
+0x21,0x28,0x00,0x00,
+0x7B,0x5A,0x00,0x08,
+0x01,0x00,0x07,0x24,
+0xFF,0x00,0x65,0x30,
+0x1D,0x00,0xA2,0x2C,
+0x07,0x00,0x40,0x10,
+0xFF,0xFF,0x02,0x25,
+0x04,0x10,0xA7,0x00,
+0x24,0x10,0x46,0x00,
+0xF9,0xFF,0x40,0x10,
+0x01,0x00,0xA3,0x24,
+0x21,0x58,0xA0,0x00,
+0xFF,0xFF,0x02,0x25,
+0xFF,0x00,0x45,0x30,
+0x2B,0x18,0xAB,0x00,
+0x0F,0x00,0x60,0x14,
+0x2B,0x10,0x49,0x01,
+0x01,0x00,0x04,0x24,
+0x04,0x10,0xA4,0x00,
+0x24,0x10,0x46,0x00,
+0xFF,0xFF,0xA7,0x24,
+0x04,0x00,0x40,0x10,
+0x01,0x00,0x43,0x25,
+0x17,0x00,0x49,0x11,
+0xFF,0x00,0x6A,0x30,
+0x21,0x40,0xA0,0x00,
+0xFF,0x00,0xE5,0x30,
+0x2B,0x10,0xAB,0x00,
+0xF6,0xFF,0x40,0x10,
+0x04,0x10,0xA4,0x00,
+0x2B,0x10,0x49,0x01,
+0x08,0x00,0x40,0x10,
+0x21,0x20,0x00,0x01,
+0x23,0x10,0x2A,0x01,
+0x2A,0x10,0x62,0x01,
+0x04,0x00,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x23,0x10,0x69,0x01,
+0x21,0x10,0x4A,0x00,
+0xFF,0x00,0x44,0x30,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0xFD,0xFF,0x40,0x14,
+0x21,0x20,0x00,0x00,
+0x23,0x10,0x09,0x01,
+0x9C,0x5A,0x00,0x08,
+0xFF,0x00,0x44,0x30,
+0x21,0x20,0x00,0x01,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x80,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x10,0x00,0xB0,0xAF,
+0x30,0x1F,0x50,0x24,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x21,0x88,0x00,0x00,
+0x21,0x90,0x00,0x02,
+0xDD,0x59,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x1E,0x24,0x02,0x92,
+0x21,0x28,0x00,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x52,0x00,
+0x60,0x05,0x44,0x8C,
+0xD4,0x05,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x21,0x18,0x64,0x00,
+0x42,0x18,0x03,0x00,
+0xE8,0x23,0x03,0xAE,
+0x21,0x10,0x05,0x02,
+0x01,0x00,0xA5,0x24,
+0x1D,0x00,0xA3,0x28,
+0x5A,0x24,0x40,0xA0,
+0x20,0x24,0x40,0xA0,
+0xFA,0xFF,0x60,0x14,
+0x3D,0x24,0x40,0xA0,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0x22,0x2A,
+0x78,0x24,0x00,0xAE,
+0xE9,0xFF,0x40,0x14,
+0x94,0x00,0x10,0x26,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x28,0x00,0xB6,0xAF,
+0x02,0x80,0x16,0x3C,
+0x24,0x00,0xB5,0xAF,
+0x30,0x1F,0xC6,0x26,
+0x2C,0x00,0xBF,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x30,0x38,0xC2,0x8C,
+0xFF,0x00,0x8D,0x30,
+0xFF,0x00,0x03,0x24,
+0xFF,0xFF,0x42,0x38,
+0x21,0xA8,0x00,0x00,
+0xFF,0xFF,0x04,0x34,
+0x0A,0xA8,0x62,0x00,
+0xA4,0x00,0xA0,0x11,
+0x30,0x38,0xC4,0xAC,
+0x02,0x80,0x02,0x3C,
+0xE4,0xE7,0x45,0x24,
+0x04,0x05,0xC4,0x24,
+0xEB,0x5A,0x00,0x08,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x10,0x26,
+0x00,0x00,0x82,0xA0,
+0x1D,0x00,0x02,0x2A,
+0x0B,0x00,0x40,0x10,
+0x01,0x00,0x84,0x24,
+0x21,0x10,0x05,0x02,
+0x00,0x00,0x42,0x90,
+0x00,0x00,0x00,0x00,
+0xF7,0xFF,0x40,0x10,
+0xFD,0xFF,0x43,0x24,
+0x01,0x00,0x10,0x26,
+0x1D,0x00,0x02,0x2A,
+0x00,0x00,0x83,0xA0,
+0xF7,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x4A,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x7C,0xE5,0x6C,0x24,
+0x04,0xE5,0x4B,0x24,
+0x21,0x80,0x00,0x00,
+0x21,0x48,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x21,0x40,0x2A,0x01,
+0x21,0x38,0x2C,0x01,
+0x21,0x10,0xE6,0x00,
+0x91,0x00,0x44,0x90,
+0x00,0x00,0x45,0x90,
+0x21,0x18,0x06,0x01,
+0x01,0x00,0xC6,0x24,
+0x05,0x00,0xC2,0x28,
+0x39,0x04,0x64,0xA0,
+0xF8,0xFF,0x40,0x14,
+0xA8,0x03,0x65,0xA0,
+0x21,0x10,0x0B,0x02,
+0x1D,0x00,0x44,0x90,
+0x00,0x00,0x45,0x90,
+0x21,0x18,0x0A,0x02,
+0x01,0x00,0x10,0x26,
+0x1D,0x00,0x02,0x2A,
+0xE7,0x04,0x64,0xA0,
+0xCA,0x04,0x65,0xA0,
+0xEB,0xFF,0x40,0x14,
+0x05,0x00,0x29,0x25,
+0x9A,0x00,0xA0,0x11,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x48,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x78,0xE8,0x69,0x24,
+0x04,0xE8,0x47,0x24,
+0x21,0x80,0x00,0x00,
+0x80,0x18,0x10,0x00,
+0x21,0x10,0x69,0x00,
+0x21,0x20,0x67,0x00,
+0x00,0x00,0x46,0x8C,
+0x00,0x00,0x85,0x8C,
+0x01,0x00,0x10,0x26,
+0x21,0x18,0x68,0x00,
+0x04,0x00,0x02,0x2A,
+0x60,0x05,0x65,0xAC,
+0xF6,0xFF,0x40,0x14,
+0xD4,0x05,0x66,0xAC,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x49,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x78,0xE8,0x68,0x24,
+0x04,0xE8,0x47,0x24,
+0x04,0x00,0x10,0x24,
+0x80,0x20,0x10,0x00,
+0x21,0x10,0x88,0x00,
+0x21,0x30,0x87,0x00,
+0x00,0x00,0x45,0x8C,
+0x00,0x00,0xC3,0x8C,
+0x01,0x00,0x10,0x26,
+0x21,0x20,0x89,0x00,
+0x82,0x28,0x05,0x00,
+0x82,0x18,0x03,0x00,
+0x1D,0x00,0x02,0x2A,
+0x60,0x05,0x83,0xAC,
+0xF4,0xFF,0x40,0x14,
+0xD4,0x05,0x85,0xAC,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x53,0x24,
+0x21,0x80,0x00,0x00,
+0x21,0xA0,0x60,0x02,
+0x21,0x90,0x00,0x00,
+0x46,0x5B,0x00,0x08,
+0x21,0x88,0x60,0x02,
+0x01,0x00,0x10,0x26,
+0x20,0x00,0x02,0x2A,
+0x94,0x00,0x31,0x26,
+0x32,0x00,0x40,0x10,
+0x94,0x00,0x52,0x26,
+0x1C,0x24,0x24,0x8E,
+0x01,0x00,0x03,0x24,
+0x02,0x13,0x04,0x00,
+0x01,0x00,0x42,0x30,
+0xF6,0xFF,0x43,0x14,
+0x07,0x00,0x82,0x30,
+0x25,0xB0,0x03,0x3C,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x43,0x00,
+0x84,0x01,0x45,0x8C,
+0x14,0x24,0x23,0x8E,
+0x21,0x20,0x00,0x02,
+0x24,0x28,0xA3,0x00,
+0xC9,0x24,0x00,0x0C,
+0x18,0x24,0x25,0xAE,
+0x1E,0x24,0x24,0x92,
+0x57,0x24,0x00,0x0C,
+0xFF,0x00,0x05,0x32,
+0x1E,0x24,0x23,0x92,
+0xEC,0x23,0x20,0xAE,
+0xF0,0x23,0x20,0xAE,
+0x80,0x18,0x03,0x00,
+0xF4,0x23,0x20,0xAE,
+0xF8,0x23,0x20,0xAE,
+0xFC,0x23,0x20,0xAE,
+0x00,0x24,0x20,0xAE,
+0x04,0x24,0x20,0xAE,
+0x08,0x24,0x20,0xAE,
+0x21,0x18,0x74,0x00,
+0x60,0x05,0x64,0x8C,
+0xD4,0x05,0x62,0x8C,
+0x21,0x30,0x00,0x00,
+0x21,0x28,0x53,0x02,
+0x21,0x10,0x44,0x00,
+0x42,0x10,0x02,0x00,
+0xE8,0x23,0x22,0xAE,
+0x21,0x10,0xA6,0x00,
+0x01,0x00,0xC6,0x24,
+0x1D,0x00,0xC3,0x28,
+0x5A,0x24,0x40,0xA0,
+0x20,0x24,0x40,0xA0,
+0xFA,0xFF,0x60,0x14,
+0x3D,0x24,0x40,0xA0,
+0x01,0x00,0x10,0x26,
+0x20,0x00,0x02,0x2A,
+0x78,0x24,0xA0,0xAC,
+0x94,0x00,0x31,0x26,
+0xD0,0xFF,0x40,0x14,
+0x94,0x00,0x52,0x26,
+0x02,0x00,0xA0,0x16,
+0x30,0x1F,0xC2,0x26,
+0x30,0x38,0x40,0xAC,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0xE4,0xE7,0x45,0x24,
+0x04,0x05,0xC4,0x24,
+0x21,0x80,0x00,0x00,
+0x21,0x10,0x05,0x02,
+0x00,0x00,0x43,0x90,
+0x01,0x00,0x10,0x26,
+0x1D,0x00,0x02,0x2A,
+0x00,0x00,0x83,0xA0,
+0xFA,0xFF,0x40,0x14,
+0x01,0x00,0x84,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x4A,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xA0,0xE6,0x6C,0x24,
+0x40,0xE5,0x4B,0x24,
+0x21,0x80,0x00,0x00,
+0x21,0x48,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x21,0x40,0x2A,0x01,
+0x21,0x38,0x2C,0x01,
+0x21,0x10,0xE6,0x00,
+0x91,0x00,0x44,0x90,
+0x00,0x00,0x45,0x90,
+0x21,0x18,0x06,0x01,
+0x01,0x00,0xC6,0x24,
+0x05,0x00,0xC2,0x28,
+0x39,0x04,0x64,0xA0,
+0xF8,0xFF,0x40,0x14,
+0xA8,0x03,0x65,0xA0,
+0x21,0x10,0x0B,0x02,
+0x1D,0x00,0x44,0x90,
+0x00,0x00,0x45,0x90,
+0x21,0x18,0x0A,0x02,
+0x01,0x00,0x10,0x26,
+0x1D,0x00,0x02,0x2A,
+0xE7,0x04,0x64,0xA0,
+0xCA,0x04,0x65,0xA0,
+0xEB,0xFF,0x40,0x14,
+0x05,0x00,0x29,0x25,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x49,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x78,0xE8,0x68,0x24,
+0x04,0xE8,0x47,0x24,
+0x21,0x80,0x00,0x00,
+0x80,0x18,0x10,0x00,
+0x21,0x10,0x68,0x00,
+0x21,0x20,0x67,0x00,
+0x00,0x00,0x46,0x8C,
+0x00,0x00,0x85,0x8C,
+0x01,0x00,0x10,0x26,
+0x21,0x18,0x69,0x00,
+0x1D,0x00,0x02,0x2A,
+0x60,0x05,0x65,0xAC,
+0xF6,0xFF,0x40,0x14,
+0xD4,0x05,0x66,0xAC,
+0x3B,0x5B,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0xD8,0xFF,0xBD,0x27,
+0xFF,0xFF,0x84,0x30,
+0x18,0x00,0xB2,0xAF,
+0xF0,0x01,0x92,0x30,
+0x02,0x91,0x12,0x00,
+0x14,0x00,0xB1,0xAF,
+0xC0,0x88,0x12,0x00,
+0x21,0x88,0x32,0x02,
+0x80,0x88,0x11,0x00,
+0x21,0x88,0x32,0x02,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x88,0x11,0x00,
+0x21,0x88,0x22,0x02,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x1C,0x24,0x30,0x8E,
+0x00,0x02,0x82,0x30,
+0xFF,0xFE,0x03,0x24,
+0x2B,0x10,0x02,0x00,
+0x00,0x10,0x10,0x36,
+0x24,0x80,0x03,0x02,
+0x00,0x12,0x02,0x00,
+0x25,0x80,0x02,0x02,
+0x14,0x24,0x25,0xAE,
+0x1C,0x24,0x30,0xAE,
+0x76,0x25,0x00,0x0C,
+0x21,0x98,0xA0,0x00,
+0xF8,0xFF,0x03,0x24,
+0x24,0x80,0x03,0x02,
+0x07,0x00,0x42,0x30,
+0x25,0x80,0x02,0x02,
+0x07,0x00,0x03,0x32,
+0x25,0xB0,0x02,0x3C,
+0x80,0x18,0x03,0x00,
+0x1C,0x24,0x30,0xAE,
+0x21,0x18,0x62,0x00,
+0x84,0x01,0x62,0x8C,
+0x21,0x20,0x40,0x02,
+0x24,0x10,0x53,0x00,
+0xC9,0x24,0x00,0x0C,
+0x18,0x24,0x22,0xAE,
+0x1E,0x24,0x24,0x92,
+0x21,0x28,0x40,0x02,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x57,0x24,0x00,0x08,
+0x28,0x00,0xBD,0x27,
+0xDD,0x59,0x00,0x08,
+0xFF,0x00,0x84,0x30,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x43,0x24,
+0x1F,0x00,0x04,0x24,
+0x1C,0x24,0x62,0x8C,
+0xFF,0xFF,0x84,0x24,
+0x00,0x10,0x42,0x34,
+0x1C,0x24,0x62,0xAC,
+0xFB,0xFF,0x81,0x04,
+0x94,0x00,0x63,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x85,0xAC,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x44,0x00,0x02,0x24,
+0x10,0x00,0xA2,0xA3,
+0x49,0x00,0x03,0x24,
+0x47,0x00,0x02,0x24,
+0x02,0x80,0x07,0x3C,
+0xD4,0xF3,0xE7,0x24,
+0x11,0x00,0xA3,0xA3,
+0x12,0x00,0xA2,0xA3,
+0x10,0x27,0x03,0x24,
+0x01,0x00,0x02,0x24,
+0x01,0x80,0x06,0x3C,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0xE0,0x00,
+0x20,0x73,0xC6,0x24,
+0x0C,0x00,0xE3,0xAC,
+0x14,0x00,0xE2,0xA0,
+0x18,0x00,0xBF,0xAF,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD0,0xFF,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x03,0x0D,0x64,0x34,
+0x00,0x00,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x54,0x30,
+0x70,0x00,0x93,0x32,
+0x5D,0x00,0x60,0x12,
+0x42,0x00,0x63,0x34,
+0x8F,0x00,0x82,0x32,
+0x00,0x00,0x82,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x55,0x00,0x60,0x12,
+0x00,0x00,0x00,0x00,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x0F,0x00,0x11,0x3C,
+0x21,0x20,0x00,0x00,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x25,0x36,
+0x21,0xA8,0x40,0x00,
+0x00,0x60,0x92,0x40,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x21,0x20,0x00,0x00,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x25,0x36,
+0x21,0xB0,0x40,0x00,
+0x00,0x60,0x92,0x40,
+0x64,0x00,0x04,0x24,
+0x54,0x22,0x00,0x0C,
+0x08,0x00,0x10,0x3C,
+0xFF,0xFF,0x10,0x36,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x12,0x3C,
+0x24,0x30,0xB0,0x02,
+0x25,0x30,0xD2,0x00,
+0xFF,0xFF,0x25,0x36,
+0x5F,0x47,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x24,0x80,0xD0,0x02,
+0xE6,0x44,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x25,0x30,0x12,0x02,
+0xFF,0xFF,0x25,0x36,
+0x5F,0x47,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x0F,0x00,0x10,0x3C,
+0x18,0x00,0x04,0x24,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x05,0x36,
+0x21,0x88,0x40,0x00,
+0x00,0x60,0x92,0x40,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x18,0x00,0x04,0x24,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x00,0x80,0x26,0x36,
+0x25,0x22,0x00,0x0C,
+0x03,0x00,0x04,0x24,
+0x25,0x00,0x60,0x16,
+0x25,0xB0,0x02,0x3C,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x25,0xB0,0x02,0x3C,
+0x42,0x00,0x42,0x34,
+0x30,0x00,0xBD,0x27,
+0x00,0x00,0x40,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0x00,0x60,0x12,0x40,
+0x01,0x00,0x41,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x0F,0x00,0x10,0x3C,
+0x18,0x00,0x04,0x24,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x05,0x36,
+0x21,0x88,0x40,0x00,
+0x00,0x60,0x92,0x40,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x18,0x00,0x04,0x24,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x00,0x80,0x26,0x36,
+0x25,0x22,0x00,0x0C,
+0x03,0x00,0x04,0x24,
+0xDD,0xFF,0x60,0x12,
+0x25,0xB0,0x02,0x3C,
+0x03,0x0D,0x42,0x34,
+0x00,0x00,0x54,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x0F,0x00,0x10,0x3C,
+0x21,0x30,0xA0,0x02,
+0xFF,0xFF,0x05,0x36,
+0x5F,0x47,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xFF,0xFF,0x05,0x36,
+0x21,0x30,0xC0,0x02,
+0x5F,0x47,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x20,0x00,0x00,
+0xE6,0x44,0x00,0x08,
+0x30,0x00,0xBD,0x27,
+0xC8,0xFF,0xBD,0x27,
+0x28,0x00,0xB4,0xAF,
+0x02,0x80,0x14,0x3C,
+0x30,0x00,0xB6,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x30,0x1F,0x85,0x26,
+0x0C,0x00,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x82,0x17,0x02,0x00,
+0x01,0x00,0x42,0x30,
+0x08,0x00,0x40,0x14,
+0x06,0x00,0x16,0x24,
+0x08,0x00,0xA2,0x8C,
+0x01,0x00,0x03,0x24,
+0x42,0x17,0x02,0x00,
+0x03,0x00,0x42,0x30,
+0x57,0x00,0x43,0x10,
+0x25,0xB0,0x02,0x3C,
+0x30,0x1F,0x85,0x26,
+0x0C,0x00,0xA2,0x8C,
+0x01,0x00,0x03,0x24,
+0x82,0x17,0x02,0x00,
+0x01,0x00,0x44,0x30,
+0x0B,0x00,0x83,0x10,
+0x21,0x10,0x00,0x00,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x08,0x00,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x42,0x17,0x02,0x00,
+0x03,0x00,0x43,0x30,
+0xF1,0xFF,0x64,0x14,
+0x21,0x10,0x00,0x00,
+0x10,0x00,0xA2,0x8C,
+0x00,0x00,0x00,0x00,
+0x82,0x17,0x02,0x00,
+0x50,0x02,0x43,0x10,
+0x25,0xB0,0x02,0x3C,
+0xC7,0x02,0xB3,0x90,
+0x62,0x0C,0x42,0x34,
+0xFF,0x00,0x63,0x32,
+0x00,0x00,0x43,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x90,0x26,
+0xC6,0x02,0x02,0x92,
+0x00,0x00,0x00,0x00,
+0x83,0x00,0x40,0x10,
+0x01,0x00,0x02,0x24,
+0x25,0xB0,0x11,0x3C,
+0x03,0x0D,0x23,0x36,
+0x00,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x70,0x00,0x42,0x30,
+0xA9,0x00,0x40,0x14,
+0xCC,0x00,0x02,0x24,
+0xC4,0x02,0x02,0x96,
+0x00,0x00,0x00,0x00,
+0x23,0x20,0x53,0x00,
+0x2B,0x18,0x53,0x00,
+0x23,0x10,0x62,0x02,
+0x0A,0x10,0x83,0x00,
+0x03,0x00,0x42,0x2C,
+0x76,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xC4,0x02,0x03,0x92,
+0x63,0x0C,0x22,0x36,
+0x21,0x20,0x00,0x00,
+0x00,0x00,0x43,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x30,0x1F,0x83,0x26,
+0xC3,0x02,0x62,0x90,
+0x08,0x00,0x66,0x8C,
+0xC2,0x02,0x73,0xA0,
+0x23,0x20,0x53,0x00,
+0x02,0x2C,0x06,0x00,
+0x2B,0x40,0x62,0x02,
+0x23,0x90,0x62,0x02,
+0x0B,0x90,0x88,0x00,
+0x3F,0x00,0xA7,0x30,
+0x3F,0x00,0xC6,0x30,
+0x24,0x00,0x02,0x24,
+0x20,0x00,0x03,0x24,
+0x23,0x10,0x46,0x00,
+0x91,0x00,0x40,0x16,
+0x23,0x20,0x67,0x00,
+0xE6,0x5C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x80,0x0C,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0x21,0x30,0xA0,0x00,
+0xC0,0xFF,0x02,0x3C,
+0x24,0x20,0x62,0x00,
+0x21,0x88,0x00,0x00,
+0xC0,0xFF,0x05,0x3C,
+0x42,0x5D,0x00,0x08,
+0x18,0x00,0xC3,0x24,
+0x01,0x00,0x31,0x26,
+0x25,0x00,0x22,0x2E,
+0x0D,0x00,0x40,0x10,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x45,0x00,
+0xF8,0xFF,0x44,0x14,
+0x04,0x00,0x63,0x24,
+0x08,0x00,0xC2,0x8C,
+0xC0,0xFF,0x03,0x24,
+0x3F,0x00,0x24,0x32,
+0x24,0x10,0x43,0x00,
+0x25,0x10,0x44,0x00,
+0x08,0x00,0xC2,0xAC,
+0x02,0x80,0x02,0x3C,
+0xDE,0x5D,0x44,0x90,
+0x22,0x00,0x03,0x24,
+0x42,0x00,0x83,0x10,
+0x92,0x00,0x02,0x24,
+0x41,0x00,0x82,0x10,
+0x25,0xB0,0x02,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x24,0x0A,0x42,0x34,
+0x00,0x00,0x44,0x8C,
+0x3F,0x3F,0x03,0x3C,
+0x3F,0x3F,0x63,0x34,
+0x24,0x20,0x83,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xDE,0x1F,0x53,0x24,
+0xE6,0x20,0x72,0x24,
+0x21,0x88,0x00,0x00,
+0x69,0x5D,0x00,0x08,
+0x10,0x00,0xA4,0xAF,
+0x39,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x4B,0x00,0x40,0x10,
+0x30,0x1F,0x85,0x26,
+0x01,0x00,0x31,0x26,
+0x21,0x00,0x22,0x2E,
+0x17,0x00,0x40,0x10,
+0x30,0x1F,0x82,0x26,
+0xC0,0x80,0x11,0x00,
+0x10,0x00,0xA4,0x27,
+0x21,0x28,0x13,0x02,
+0x39,0x52,0x00,0x0C,
+0x04,0x00,0x06,0x24,
+0x21,0x28,0x12,0x02,
+0x10,0x00,0xA4,0x27,
+0xF0,0xFF,0x40,0x14,
+0x04,0x00,0x06,0x24,
+0x30,0x1F,0x85,0x26,
+0x08,0x00,0xA3,0x8C,
+0xC0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x3F,0x00,0x24,0x32,
+0x24,0x18,0x62,0x00,
+0x00,0x24,0x04,0x00,
+0xFF,0x7F,0x02,0x3C,
+0x25,0x18,0x64,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x08,0x00,0xA3,0xAC,
+0x30,0x1F,0x82,0x26,
+0x0C,0x00,0x43,0x8C,
+0x00,0x40,0x04,0x3C,
+0x30,0x1F,0x85,0x26,
+0x25,0x18,0x64,0x00,
+0x0C,0x00,0x43,0xAC,
+0x0C,0x00,0xA2,0x8C,
+0x01,0x00,0x03,0x24,
+0x82,0x17,0x02,0x00,
+0x01,0x00,0x44,0x30,
+0x5D,0xFF,0x83,0x14,
+0x21,0x10,0x00,0x00,
+0xF0,0x5C,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xC6,0x02,0x02,0xA2,
+0x0A,0x5D,0x00,0x08,
+0xC4,0x02,0x13,0xA6,
+0x23,0x5C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1A,0x5D,0x00,0x08,
+0xC4,0x02,0x13,0xA6,
+0x25,0xB0,0x02,0x3C,
+0x88,0x0C,0x42,0x34,
+0x00,0x00,0x44,0x8C,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x66,0x24,
+0xC0,0xFF,0x02,0x3C,
+0x24,0x20,0x82,0x00,
+0x21,0x88,0x00,0x00,
+0xC0,0xFF,0x05,0x3C,
+0xA2,0x5D,0x00,0x08,
+0x18,0x00,0xC3,0x24,
+0x01,0x00,0x31,0x26,
+0x25,0x00,0x22,0x2E,
+0xB4,0xFF,0x40,0x10,
+0x25,0xB0,0x02,0x3C,
+0x00,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x45,0x00,
+0xF8,0xFF,0x44,0x14,
+0x04,0x00,0x63,0x24,
+0x08,0x00,0xC2,0x8C,
+0x3F,0x00,0x23,0x32,
+0xFF,0xC0,0x04,0x24,
+0x24,0x10,0x44,0x00,
+0x00,0x1A,0x03,0x00,
+0x25,0x10,0x43,0x00,
+0x54,0x5D,0x00,0x08,
+0x08,0x00,0xC2,0xAC,
+0x08,0x00,0xA3,0x8C,
+0xC0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x3F,0x00,0x24,0x32,
+0x24,0x18,0x62,0x00,
+0x00,0x24,0x04,0x00,
+0x25,0x18,0x64,0x00,
+0x00,0x80,0x02,0x3C,
+0x7D,0x5D,0x00,0x08,
+0x25,0x18,0x62,0x00,
+0x63,0x0C,0x23,0x36,
+0x00,0x00,0x62,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x24,0x5D,0x00,0x08,
+0x30,0x1F,0x83,0x26,
+0x71,0x01,0x00,0x11,
+0x23,0x28,0xF2,0x00,
+0x2B,0x10,0x42,0x02,
+0x21,0x18,0xD2,0x00,
+0x00,0x00,0x42,0x38,
+0x24,0x00,0x08,0x24,
+0x2B,0x20,0x44,0x02,
+0x0B,0x40,0x62,0x00,
+0x06,0x00,0x80,0x10,
+0x20,0x00,0x15,0x24,
+0x30,0x1F,0x83,0x26,
+0x0A,0x00,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x3F,0x00,0x42,0x30,
+0x21,0xA8,0x52,0x00,
+0x2B,0x28,0xC8,0x02,
+0x5E,0x01,0xA0,0x10,
+0x30,0x1F,0x82,0x26,
+0x80,0x10,0x08,0x00,
+0x30,0x1F,0x83,0x26,
+0x21,0x10,0x43,0x00,
+0x18,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x82,0x25,0x04,0x00,
+0x30,0x1F,0x86,0x26,
+0x0C,0x00,0xC3,0x8C,
+0x00,0x00,0x00,0x00,
+0xFF,0x03,0x67,0x30,
+0x47,0x01,0xE0,0x10,
+0x00,0x02,0x62,0x30,
+0x04,0x00,0x40,0x10,
+0x18,0x00,0xE4,0x00,
+0x00,0xFC,0x02,0x24,
+0x25,0x38,0xE2,0x00,
+0x18,0x00,0xE4,0x00,
+0x82,0x82,0x03,0x00,
+0xFF,0x03,0x10,0x32,
+0x00,0x02,0x03,0x32,
+0x12,0x10,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x03,0x00,0x60,0x10,
+0xFF,0x03,0x45,0x30,
+0x00,0xFC,0x02,0x24,
+0x25,0x80,0x02,0x02,
+0x18,0x00,0x04,0x02,
+0x80,0x1D,0x04,0x00,
+0x25,0xB0,0x11,0x3C,
+0x80,0x0C,0x24,0x36,
+0x94,0x0C,0x31,0x36,
+0x12,0x80,0x00,0x00,
+0x02,0x82,0x10,0x00,
+0x3F,0x00,0x02,0x32,
+0x00,0x14,0x02,0x00,
+0x25,0x18,0x62,0x00,
+0x25,0x18,0x65,0x00,
+0x21,0x28,0x60,0x00,
+0x02,0x5C,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x00,0x00,0x23,0x8E,
+0xFF,0x0F,0x02,0x3C,
+0xC0,0x03,0x10,0x32,
+0xFF,0xFF,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0x80,0x85,0x10,0x00,
+0x25,0x18,0x70,0x00,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x60,0x00,
+0x10,0x00,0xA3,0xAF,
+0x02,0x5C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x83,0x26,
+0x08,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0xB9,0x00,0x40,0x04,
+0xC0,0x28,0x15,0x00,
+0x21,0x10,0xA3,0x00,
+0xAC,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x22,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xAD,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x23,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xAE,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x24,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xAF,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x25,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB0,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x26,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB1,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x27,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB2,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x28,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB3,0x00,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x29,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x02,0x80,0x02,0x3C,
+0xDE,0x5D,0x44,0x90,
+0x22,0x00,0x03,0x24,
+0x03,0x00,0x83,0x10,
+0x92,0x00,0x02,0x24,
+0x73,0xFE,0x82,0x14,
+0x21,0x10,0x00,0x00,
+0x30,0x1F,0x82,0x26,
+0x08,0x00,0x43,0x8C,
+0x01,0x00,0x44,0x3A,
+0x24,0x00,0x02,0x24,
+0x02,0x1A,0x03,0x00,
+0x3F,0x00,0x63,0x30,
+0x01,0x00,0x84,0x30,
+0xF3,0x00,0x80,0x10,
+0x23,0x28,0x43,0x00,
+0x42,0x18,0x12,0x00,
+0x40,0x10,0x03,0x00,
+0x21,0x90,0x43,0x00,
+0x30,0x1F,0x83,0x26,
+0xC3,0x02,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x62,0x02,
+0xB8,0x00,0x40,0x10,
+0x2B,0x10,0x45,0x02,
+0x06,0x00,0x40,0x10,
+0x24,0x00,0x06,0x24,
+0x08,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x3F,0x00,0x42,0x30,
+0x21,0x30,0x52,0x00,
+0x2B,0x28,0xC6,0x02,
+0xB8,0x00,0xA0,0x10,
+0x30,0x1F,0x82,0x26,
+0x80,0x10,0x06,0x00,
+0x30,0x1F,0x83,0x26,
+0x21,0x10,0x43,0x00,
+0x18,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x82,0x25,0x04,0x00,
+0x30,0x1F,0x83,0x26,
+0x10,0x00,0x70,0x8C,
+0x00,0x00,0x00,0x00,
+0x82,0x3A,0x10,0x00,
+0xFF,0x03,0xE7,0x30,
+0xC5,0x00,0xE0,0x10,
+0x00,0x02,0xE2,0x30,
+0x04,0x00,0x40,0x10,
+0x18,0x00,0xE4,0x00,
+0x00,0xFC,0x02,0x24,
+0x25,0x38,0xE2,0x00,
+0x18,0x00,0xE4,0x00,
+0x02,0x85,0x10,0x00,
+0xFF,0x03,0x10,0x32,
+0x00,0x02,0x03,0x32,
+0x12,0x10,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x03,0x00,0x60,0x10,
+0xFF,0x03,0x45,0x30,
+0x00,0xFC,0x02,0x24,
+0x25,0x80,0x02,0x02,
+0x18,0x00,0x04,0x02,
+0x80,0x1D,0x04,0x00,
+0x25,0xB0,0x11,0x3C,
+0x88,0x0C,0x24,0x36,
+0x9C,0x0C,0x31,0x36,
+0x12,0x80,0x00,0x00,
+0x02,0x82,0x10,0x00,
+0x3F,0x00,0x02,0x32,
+0x00,0x14,0x02,0x00,
+0x25,0x18,0x62,0x00,
+0x25,0x18,0x65,0x00,
+0x21,0x28,0x60,0x00,
+0x02,0x5C,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0x00,0x00,0x23,0x8E,
+0xFF,0x0F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xC0,0x03,0x10,0x32,
+0x24,0x18,0x62,0x00,
+0x80,0x85,0x10,0x00,
+0x25,0x18,0x70,0x00,
+0x21,0x20,0x20,0x02,
+0x21,0x28,0x60,0x00,
+0x02,0x5C,0x00,0x0C,
+0x10,0x00,0xA3,0xAF,
+0xE6,0x5C,0x00,0x08,
+0x21,0x10,0x00,0x00,
+0x21,0x10,0xA3,0x00,
+0xB4,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x22,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB5,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x23,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB6,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x24,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB7,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x25,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB8,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x26,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xB9,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x27,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xBA,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x28,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x42,0x24,
+0x30,0x1F,0x82,0x26,
+0x21,0x10,0xA2,0x00,
+0xBB,0x01,0x44,0x90,
+0x25,0xB0,0x03,0x3C,
+0x29,0x0A,0x63,0x34,
+0x00,0x00,0x64,0xA0,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x6E,0x5E,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x36,0x00,0xA0,0x10,
+0x80,0x10,0x08,0x00,
+0x21,0x10,0x46,0x00,
+0x18,0x00,0x45,0x8C,
+0x25,0xB0,0x04,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x80,0x0C,0x84,0x34,
+0x25,0xB0,0x04,0x3C,
+0x94,0x0C,0x84,0x34,
+0x07,0x5E,0x00,0x08,
+0x21,0x28,0x00,0x00,
+0x30,0x00,0x43,0x8C,
+0xDB,0x5D,0x00,0x08,
+0x82,0x25,0x03,0x00,
+0x23,0x20,0xD2,0x00,
+0x2B,0x10,0x46,0x02,
+0x2B,0x18,0x47,0x02,
+0x21,0x40,0x00,0x00,
+0x21,0xA8,0x00,0x00,
+0x0B,0x40,0x82,0x00,
+0xD2,0x5D,0x00,0x08,
+0x0B,0xA8,0xA3,0x00,
+0x08,0x00,0x62,0x8C,
+0x00,0x00,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0x3F,0x00,0x42,0x30,
+0x2B,0x18,0x42,0x02,
+0x4A,0xFF,0x60,0x14,
+0x23,0x30,0x52,0x00,
+0x21,0x30,0x00,0x00,
+0x21,0x28,0x00,0x00,
+0x30,0x1F,0x82,0x26,
+0x30,0x00,0x43,0x8C,
+0x96,0x5E,0x00,0x08,
+0x82,0x25,0x03,0x00,
+0x0F,0x00,0x11,0x3C,
+0xFF,0xFF,0x25,0x36,
+0x60,0x00,0x06,0x24,
+0x5F,0x47,0x00,0x0C,
+0x24,0x00,0x04,0x24,
+0x25,0x22,0x00,0x0C,
+0xE8,0x03,0x04,0x24,
+0x00,0x60,0x10,0x40,
+0x01,0x00,0x01,0x36,
+0x01,0x00,0x21,0x38,
+0x00,0x60,0x81,0x40,
+0x24,0x00,0x04,0x24,
+0x8A,0x47,0x00,0x0C,
+0xFF,0xFF,0x25,0x36,
+0x1F,0x00,0x53,0x30,
+0x00,0x60,0x90,0x40,
+0x54,0x22,0x00,0x0C,
+0x64,0x00,0x04,0x24,
+0x06,0x5D,0x00,0x08,
+0x30,0x1F,0x90,0x26,
+0x30,0x00,0xC5,0x8C,
+0x2C,0x5F,0x00,0x08,
+0x25,0xB0,0x04,0x3C,
+0x13,0x00,0xA0,0x10,
+0x00,0x00,0x00,0x00,
+0x80,0x10,0x06,0x00,
+0x21,0x10,0x43,0x00,
+0x18,0x00,0x45,0x8C,
+0x25,0xB0,0x04,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x88,0x0C,0x84,0x34,
+0x25,0xB0,0x04,0x3C,
+0x9C,0x0C,0x84,0x34,
+0x02,0x5C,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0xE6,0x5C,0x00,0x08,
+0x21,0x10,0x00,0x00,
+0xFF,0xFF,0x43,0x26,
+0x42,0x18,0x03,0x00,
+0x40,0x10,0x03,0x00,
+0x21,0x10,0x43,0x00,
+0x80,0x5E,0x00,0x08,
+0x01,0x00,0x52,0x24,
+0x30,0x00,0x65,0x8C,
+0x67,0x5F,0x00,0x08,
+0x25,0xB0,0x04,0x3C,
+0x00,0xFF,0x84,0x30,
+0x02,0x22,0x04,0x00,
+0x08,0x00,0x80,0x10,
+0x02,0x80,0x02,0x3C,
+0xFF,0x00,0x02,0x24,
+0x04,0x00,0x82,0x10,
+0xCC,0xFF,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x16,0x22,0x43,0xA0,
+0x02,0x80,0x02,0x3C,
+0x08,0x00,0xE0,0x03,
+0x16,0x22,0x44,0xA0,
+0x02,0x24,0x04,0x00,
+0xFF,0x00,0x84,0x30,
+0xC0,0x10,0x04,0x00,
+0x21,0x10,0x44,0x00,
+0x80,0x10,0x02,0x00,
+0x21,0x10,0x44,0x00,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x02,0x00,
+0x30,0x1F,0x63,0x24,
+0x20,0x00,0x84,0x2C,
+0x09,0x00,0x80,0x10,
+0x21,0x10,0x43,0x00,
+0x0C,0x24,0x43,0x8C,
+0x25,0xB0,0x02,0x3C,
+0x74,0x03,0x42,0x34,
+0x02,0x19,0x03,0x00,
+0x7F,0x00,0x63,0x30,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xB0,0x55,0x43,0x8C,
+0x25,0xB0,0x02,0x3C,
+0x74,0x03,0x42,0x34,
+0x02,0x19,0x03,0x00,
+0x7F,0x00,0x63,0x30,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x85,0x30,
+0xD2,0xFF,0xA3,0x24,
+0xFE,0xFF,0xA2,0x24,
+0xDA,0xFF,0xA4,0x24,
+0x04,0x00,0x63,0x2C,
+0x08,0x00,0x84,0x2C,
+0x06,0x00,0x60,0x14,
+0xFF,0x00,0x42,0x30,
+0xF0,0xFF,0xA2,0x24,
+0xFC,0xFF,0xA3,0x24,
+0x16,0x00,0x46,0x2C,
+0x03,0x00,0x80,0x10,
+0xFF,0x00,0x62,0x30,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xFA,0xFF,0xA3,0x24,
+0xFC,0xFF,0xC0,0x10,
+0x21,0x10,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0xFF,0x00,0x62,0x30,
+0x25,0xB0,0x03,0x3C,
+0x03,0x0D,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x08,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x25,0xB0,0x03,0x3C,
+0x03,0x0D,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0xF7,0x00,0x42,0x30,
+0x00,0x00,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x25,0xB0,0x03,0x3C,
+0x2D,0x0A,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0x3F,0x00,0x42,0x30,
+0x00,0x00,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x82,0x24,
+0x25,0xB0,0x03,0x3C,
+0x2D,0x0A,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x21,0x20,0x00,0x00,
+0xFF,0x00,0x42,0x30,
+0x80,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA0,
+0x01,0x00,0x82,0x24,
+0xFF,0x00,0x44,0x30,
+0x06,0x00,0x83,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0xFF,0x00,0x03,0x3C,
+0x82,0x01,0x49,0x34,
+0x81,0x01,0x48,0x34,
+0x24,0x10,0x83,0x00,
+0x02,0x3C,0x02,0x00,
+0x00,0xFF,0x63,0x34,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x45,0x24,
+0x02,0x32,0x04,0x00,
+0x01,0x00,0x02,0x24,
+0x24,0x20,0x83,0x00,
+0xE6,0x1D,0xA2,0xA0,
+0xD4,0x1D,0xA0,0xAC,
+0xD8,0x1D,0xA0,0xAC,
+0xDC,0x1D,0xA0,0xAC,
+0x06,0x00,0x80,0x14,
+0xE0,0x1D,0xA0,0xAC,
+0x00,0x00,0x02,0x91,
+0x00,0x00,0x23,0x91,
+0xE4,0x1D,0xA2,0xA0,
+0x08,0x00,0xE0,0x03,
+0xE5,0x1D,0xA3,0xA0,
+0xE5,0x1D,0xA7,0xA0,
+0x08,0x00,0xE0,0x03,
+0xE4,0x1D,0xA6,0xA0,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x63,0x24,
+0xE5,0x1D,0x66,0x90,
+0xE4,0x1D,0x65,0x90,
+0x25,0xB0,0x02,0x3C,
+0x82,0x01,0x44,0x34,
+0x81,0x01,0x42,0x34,
+0x00,0x00,0x45,0xA0,
+0x00,0x00,0x86,0xA0,
+0x08,0x00,0xE0,0x03,
+0xE6,0x1D,0x60,0xA0,
+0x02,0x80,0x08,0x3C,
+0x30,0x1F,0x04,0x25,
+0xE6,0x1D,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x15,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0xD8,0x1D,0x82,0x8C,
+0xD4,0x1D,0x85,0x8C,
+0x25,0xB0,0x03,0x3C,
+0x40,0x11,0x02,0x00,
+0x2B,0x10,0xA2,0x00,
+0x82,0x01,0x67,0x34,
+0x0F,0x00,0x40,0x10,
+0x81,0x01,0x66,0x34,
+0xE5,0x1D,0x83,0x90,
+0xE4,0x1D,0x82,0x90,
+0xF0,0x00,0x63,0x30,
+0x1F,0x00,0x42,0x30,
+0x00,0x00,0xC2,0xA0,
+0x00,0x00,0xE3,0xA0,
+0x30,0x1F,0x02,0x25,
+0x01,0x00,0x03,0x24,
+0xE0,0x1D,0x40,0xAC,
+0xD4,0x1D,0x40,0xAC,
+0xD8,0x1D,0x40,0xAC,
+0xDC,0x1D,0x40,0xAC,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x60,0x00,
+0xDC,0x1D,0x82,0x8C,
+0x25,0xB0,0x03,0x3C,
+0x82,0x01,0x69,0x34,
+0x40,0x11,0x02,0x00,
+0x2B,0x10,0xA2,0x00,
+0x0E,0x00,0x40,0x14,
+0x81,0x01,0x66,0x34,
+0xE0,0x1D,0x82,0x8C,
+0x00,0x00,0x00,0x00,
+0x40,0x11,0x02,0x00,
+0x2B,0x10,0xA2,0x00,
+0x08,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0xE5,0x1D,0x83,0x90,
+0xE4,0x1D,0x82,0x90,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xC2,0xA0,
+0x00,0x00,0x23,0xA1,
+0x20,0x60,0x00,0x08,
+0x30,0x1F,0x02,0x25,
+0xE5,0x1D,0x83,0x90,
+0xE4,0x1D,0x82,0x90,
+0xF0,0x00,0x63,0x30,
+0x7F,0x00,0x42,0x30,
+0x00,0x00,0xC2,0xA0,
+0x00,0x00,0x23,0xA1,
+0x20,0x60,0x00,0x08,
+0x30,0x1F,0x02,0x25,
+0x00,0x00,0x85,0xAC,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x03,0x3C,
+0x33,0x02,0x65,0x34,
+0x00,0x11,0x04,0x00,
+0x00,0x00,0xA2,0xA0,
+0x30,0x02,0x63,0x34,
+0x00,0x00,0x65,0x8C,
+0x0F,0x00,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x28,0xA2,0x00,
+0x01,0x00,0x03,0x24,
+0x04,0x18,0x83,0x00,
+0x02,0x00,0xA0,0x10,
+0x21,0x10,0x00,0x00,
+0xFF,0xFF,0x62,0x30,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x25,0xB0,0x11,0x3C,
+0x18,0x00,0xB2,0xAF,
+0x4C,0x00,0x22,0x36,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0x44,0x90,
+0x02,0x80,0x03,0x3C,
+0x02,0x00,0x02,0x24,
+0xFF,0x00,0x84,0x30,
+0x07,0x00,0x82,0x10,
+0x30,0x1F,0x72,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x8A,0x36,0x43,0x96,
+0x01,0x00,0x02,0x24,
+0xF7,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0xF2,0xFF,0x60,0x14,
+0x21,0x20,0x00,0x00,
+0x4C,0x60,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x04,0x24,
+0x4C,0x60,0x00,0x0C,
+0x21,0x80,0x40,0x00,
+0x25,0x80,0x02,0x02,
+0x02,0x80,0x04,0x3C,
+0x33,0x02,0x23,0x36,
+0x08,0x00,0x02,0x24,
+0xFF,0xFF,0x10,0x32,
+0x40,0x00,0x27,0x36,
+0xEC,0xE8,0x84,0x24,
+0x00,0x00,0x62,0xA0,
+0xE3,0xFF,0x00,0x16,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xE2,0x94,
+0x88,0x36,0x43,0x96,
+0xFF,0xDF,0x42,0x30,
+0x01,0x00,0x63,0x24,
+0x00,0x20,0x46,0x34,
+0x88,0x36,0x43,0xA6,
+0xFF,0xFF,0x65,0x30,
+0x00,0x00,0xE2,0xA4,
+0x00,0x00,0xE6,0xA4,
+0x2F,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x69,0x60,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0x21,0x20,0x82,0x00,
+0x00,0x00,0x85,0xAC,
+0x21,0x10,0x00,0x00,
+0x01,0x00,0x42,0x24,
+0xFF,0x00,0x42,0x30,
+0x06,0x00,0x43,0x2C,
+0xFC,0xFF,0x60,0x14,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0xDF,0x2F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x02,0x80,0x02,0x3C,
+0xE8,0x03,0x03,0x24,
+0x34,0x5F,0x43,0xAC,
+0x18,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xFA,0x5E,0x40,0xA0,
+0xFF,0x00,0x85,0x30,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x0C,0x5F,0x60,0xA0,
+0x08,0x00,0xA4,0x2C,
+0x0E,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x16,0x5F,0x60,0xA0,
+0xF4,0x5E,0x45,0xA0,
+0x2C,0x00,0x80,0x10,
+0x02,0x80,0x03,0x3C,
+0x80,0x10,0x05,0x00,
+0x94,0xF0,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x30,0x1F,0xA5,0x24,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x70,0x02,0x3C,
+0x02,0x00,0x42,0x34,
+0x25,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0x02,0x80,0x05,0x3C,
+0x30,0x1F,0xA5,0x24,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x70,0x02,0x3C,
+0x02,0x00,0x42,0x34,
+0x27,0x10,0x02,0x00,
+0x24,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0x02,0x80,0x05,0x3C,
+0x30,0x1F,0xA5,0x24,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x70,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x20,0x82,0x00,
+0x02,0x80,0x07,0x3C,
+0x41,0xB0,0x02,0x3C,
+0x01,0x00,0x03,0x24,
+0x00,0x00,0x44,0xAC,
+0x10,0x5F,0xE3,0xA0,
+0x10,0x5F,0xE6,0x90,
+0x02,0x80,0x02,0x3C,
+0xD0,0x1B,0xA4,0xAC,
+0x11,0x5F,0x46,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x30,0x1F,0xA5,0x24,
+0xD0,0x1B,0xA4,0x8C,
+0x00,0x70,0x02,0x3C,
+0x27,0x10,0x02,0x00,
+0x24,0x20,0x82,0x00,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x64,0xAC,
+0x08,0x00,0xE0,0x03,
+0xD0,0x1B,0xA4,0xAC,
+0xE0,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x10,0x3C,
+0xF4,0x5E,0x02,0x92,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x21,0x90,0x80,0x00,
+0x1C,0x00,0x40,0x10,
+0xFF,0x00,0xB1,0x30,
+0x02,0x80,0x03,0x3C,
+0xDE,0x5D,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x42,0x30,
+0x1C,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x00,0x08,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x02,0x80,0x03,0x3C,
+0xF6,0x5E,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x42,0x30,
+0x0C,0x00,0x42,0x28,
+0x06,0x00,0x40,0x10,
+0x08,0x00,0x02,0x24,
+0x00,0x00,0x44,0x96,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x83,0x30,
+0x1B,0x00,0x62,0x10,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0x02,0x92,
+0x05,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x0B,0x00,0x43,0x10,
+0x02,0x80,0x03,0x3C,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x9B,0x30,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x0C,0x61,0x00,0x08,
+0x00,0x08,0x04,0x24,
+0x0F,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x24,0x10,0x22,0x02,
+0xF2,0xFF,0x40,0x10,
+0x02,0x80,0x03,0x3C,
+0x0E,0x5F,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x04,0x00,0x42,0x34,
+0x0E,0x5F,0x62,0xA0,
+0x20,0x61,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x0D,0x5F,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x60,0x14,
+0x00,0x10,0x82,0x34,
+0x1B,0x61,0x00,0x08,
+0x00,0x00,0x42,0xA6,
+0x0C,0x00,0x04,0x24,
+0x64,0x31,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x1B,0x61,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0xFF,0x00,0xA5,0x30,
+0x10,0x00,0xB0,0xAF,
+0x14,0x00,0xBF,0xAF,
+0x18,0x00,0xA0,0x14,
+0xFF,0x00,0x90,0x30,
+0x2C,0x00,0x00,0x12,
+0x01,0x00,0x05,0x24,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x07,0x24,
+0x0C,0x5F,0x67,0xA0,
+0x02,0x80,0x08,0x3C,
+0x0E,0x5F,0x02,0x91,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x02,0x00,0x42,0x34,
+0x00,0xF0,0x06,0x34,
+0x0E,0x5F,0x02,0xA1,
+0x8C,0x23,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x42,0xB0,0x02,0x3C,
+0x44,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x18,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x0C,0x5F,0x43,0xA0,
+0x02,0x80,0x02,0x3C,
+0x0F,0x5F,0x43,0x90,
+0x0F,0x00,0x02,0x24,
+0x02,0x80,0x05,0x3C,
+0x0F,0x00,0x63,0x30,
+0x07,0x00,0x62,0x10,
+0x01,0x00,0x04,0x24,
+0x0E,0x5F,0xA2,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x34,
+0x0E,0x5F,0xA2,0xA0,
+0xFE,0x4E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xDB,0xFF,0x00,0x16,
+0x02,0x80,0x03,0x3C,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x0C,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x64,0x90,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFF,0x00,0x84,0x30,
+0x64,0x31,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0xFF,0x00,0xA5,0x30,
+0x14,0x00,0xB1,0xAF,
+0x18,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x03,0x00,0xA0,0x14,
+0xFF,0x00,0x91,0x30,
+0x3A,0x00,0x20,0x12,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x10,0x3C,
+0x0E,0x5F,0x02,0x92,
+0xFB,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x0E,0x5F,0x02,0xA2,
+0x10,0x00,0xA0,0x14,
+0x02,0x80,0x03,0x3C,
+0x0E,0x5F,0x02,0x92,
+0xFE,0xFF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0x0E,0x5F,0x02,0xA2,
+0x19,0x00,0x20,0x16,
+0x02,0x80,0x02,0x3C,
+0x0E,0x5F,0x02,0x92,
+0xFD,0xFF,0x03,0x24,
+0x18,0x00,0xBF,0x8F,
+0x24,0x10,0x43,0x00,
+0x0E,0x5F,0x02,0xA2,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x01,0x00,0x04,0x24,
+0x0C,0x5F,0x64,0xA0,
+0x0E,0x5F,0x02,0x92,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x42,0x34,
+0x0E,0x5F,0x02,0xA2,
+0x0D,0x5F,0x62,0x90,
+0x02,0x00,0x03,0x24,
+0xFF,0x00,0x42,0x30,
+0x23,0x00,0x43,0x10,
+0x00,0x00,0x00,0x00,
+0xFE,0x4E,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0xE9,0xFF,0x20,0x12,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x04,0x24,
+0x0C,0x5F,0x44,0xA0,
+0x0E,0x5F,0x03,0x92,
+0x02,0x00,0x04,0x24,
+0x21,0x28,0x00,0x00,
+0x02,0x00,0x63,0x34,
+0x00,0xF0,0x06,0x34,
+0x0E,0x5F,0x03,0xA2,
+0x8C,0x23,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x42,0xB0,0x02,0x3C,
+0x44,0x00,0x03,0x24,
+0x03,0x00,0x42,0x34,
+0x20,0x00,0xBD,0x27,
+0x00,0x00,0x43,0xA0,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x0C,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0xF5,0x5E,0x64,0x90,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x05,0x24,
+0xFF,0x00,0x84,0x30,
+0x64,0x31,0x00,0x08,
+0x20,0x00,0xBD,0x27,
+0x0D,0x30,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x0C,0x00,0x04,0x24,
+0x64,0x31,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x90,0x61,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB2,0xAF,
+0x0C,0x00,0xB1,0xAF,
+0x08,0x00,0xB0,0xAF,
+0x21,0x40,0xE0,0x00,
+0x21,0x90,0xA0,0x03,
+0x21,0x60,0xC0,0x00,
+0x21,0x78,0x80,0x00,
+0x45,0x00,0xE0,0x14,
+0x21,0x50,0xA0,0x00,
+0x2B,0x10,0xA6,0x00,
+0x78,0x00,0x40,0x10,
+0xFF,0xFF,0x02,0x34,
+0x2B,0x10,0x46,0x00,
+0x8F,0x01,0x40,0x10,
+0x21,0x28,0xC0,0x00,
+0xFF,0x00,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x10,0x00,0x03,0x24,
+0x2B,0x10,0x46,0x00,
+0x18,0x00,0x04,0x24,
+0x21,0x30,0x60,0x00,
+0x0B,0x30,0x82,0x00,
+0x02,0x80,0x03,0x3C,
+0x06,0x10,0xC5,0x00,
+0xB4,0xF0,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x86,0x00,
+0x23,0x30,0x44,0x00,
+0x08,0x00,0xC0,0x10,
+0x02,0x4C,0x0C,0x00,
+0x23,0x10,0x46,0x00,
+0x06,0x10,0x4F,0x00,
+0x04,0x18,0xCA,0x00,
+0x25,0x50,0x62,0x00,
+0x04,0x60,0xCC,0x00,
+0x04,0x78,0xCF,0x00,
+0x02,0x4C,0x0C,0x00,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x87,0x31,
+0x02,0x24,0x0F,0x00,
+0x12,0x18,0x00,0x00,
+0x10,0x28,0x00,0x00,
+0x00,0x14,0x05,0x00,
+0x25,0x28,0x44,0x00,
+0x18,0x00,0x67,0x00,
+0x12,0x58,0x00,0x00,
+0x2B,0x18,0xAB,0x00,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x08,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0xAC,0x00,
+0x2B,0x10,0xAC,0x00,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0xAB,0x00,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0xAC,0x00,
+0x0B,0x28,0x62,0x00,
+0x23,0x28,0xAB,0x00,
+0x1B,0x00,0xA9,0x00,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0xE4,0x31,
+0x12,0x18,0x00,0x00,
+0x10,0x40,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x8F,0x62,0x00,0x08,
+0x18,0x00,0x67,0x00,
+0x2B,0x10,0xA7,0x00,
+0x0A,0x00,0x40,0x10,
+0xFF,0xFF,0x02,0x34,
+0x10,0x00,0xB2,0x8F,
+0x0C,0x00,0xB1,0x8F,
+0x08,0x00,0xB0,0x8F,
+0x21,0x10,0x80,0x00,
+0x21,0x18,0xA0,0x00,
+0x00,0x00,0xA4,0xAF,
+0x04,0x00,0xA5,0xAF,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x2B,0x10,0x47,0x00,
+0xD2,0x00,0x40,0x10,
+0x00,0x01,0xE3,0x2C,
+0xFF,0x00,0x02,0x3C,
+0x10,0x00,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x2B,0x10,0x47,0x00,
+0x18,0x00,0x04,0x24,
+0x21,0x28,0x60,0x00,
+0x0B,0x28,0x82,0x00,
+0x06,0x10,0xA8,0x00,
+0x02,0x80,0x03,0x3C,
+0xB4,0xF0,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0xCE,0x00,0xC0,0x14,
+0x23,0x38,0x46,0x00,
+0x2B,0x10,0x0A,0x01,
+0x04,0x00,0x40,0x14,
+0x23,0x20,0xEC,0x01,
+0x2B,0x10,0xEC,0x01,
+0x05,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0xE4,0x01,
+0x23,0x18,0x48,0x01,
+0x23,0x50,0x62,0x00,
+0x21,0x78,0x80,0x00,
+0x04,0x00,0x40,0x12,
+0x21,0xC0,0xE0,0x01,
+0x21,0xC8,0x40,0x01,
+0x00,0x00,0x58,0xAE,
+0x04,0x00,0x59,0xAE,
+0x00,0x00,0xA2,0x8F,
+0x04,0x00,0xA3,0x8F,
+0x10,0x00,0xB2,0x8F,
+0x0C,0x00,0xB1,0x8F,
+0x08,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x53,0x00,0xC0,0x10,
+0x01,0x00,0x02,0x24,
+0xFF,0xFF,0x02,0x34,
+0x2B,0x10,0x4C,0x00,
+0x59,0x00,0x40,0x14,
+0xFF,0x00,0x02,0x3C,
+0x00,0x01,0x83,0x2D,
+0x08,0x00,0x02,0x24,
+0x21,0x28,0x00,0x00,
+0x0A,0x28,0x43,0x00,
+0x06,0x10,0xAC,0x00,
+0x02,0x80,0x03,0x3C,
+0xB4,0xF0,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0x5B,0x00,0xC0,0x14,
+0x00,0x00,0x00,0x00,
+0x23,0x50,0x4C,0x01,
+0x02,0x4C,0x0C,0x00,
+0xFF,0xFF,0x8D,0x31,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x02,0x24,0x0F,0x00,
+0x12,0x18,0x00,0x00,
+0x10,0x28,0x00,0x00,
+0x00,0x14,0x05,0x00,
+0x25,0x28,0x44,0x00,
+0x18,0x00,0x6D,0x00,
+0x12,0x58,0x00,0x00,
+0x2B,0x18,0xAB,0x00,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x49,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x08,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x28,0xAC,0x00,
+0x2B,0x10,0xAC,0x00,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0xAB,0x00,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0xAC,0x00,
+0x0B,0x28,0x62,0x00,
+0x23,0x28,0xAB,0x00,
+0x1B,0x00,0xA9,0x00,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0xE4,0x31,
+0x12,0x18,0x00,0x00,
+0x10,0x40,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x6D,0x00,
+0x00,0x14,0x08,0x00,
+0x12,0x58,0x00,0x00,
+0x25,0x40,0x44,0x00,
+0x2B,0x18,0x0B,0x01,
+0x1B,0x00,0xA9,0x00,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x08,0x00,0x60,0x10,
+0x00,0x00,0x00,0x00,
+0x21,0x40,0x0C,0x01,
+0x2B,0x10,0x0C,0x01,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0x0B,0x01,
+0x21,0x18,0x0C,0x01,
+0x00,0x00,0x42,0x38,
+0x0B,0x40,0x62,0x00,
+0xAB,0xFF,0x40,0x12,
+0x23,0x78,0x0B,0x01,
+0x06,0xC0,0xCF,0x00,
+0x21,0xC8,0x00,0x00,
+0x00,0x00,0x58,0xAE,
+0x4C,0x62,0x00,0x08,
+0x04,0x00,0x59,0xAE,
+0x1B,0x00,0x47,0x00,
+0x02,0x00,0xE0,0x14,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x02,0x34,
+0x12,0x60,0x00,0x00,
+0x2B,0x10,0x4C,0x00,
+0xAB,0xFF,0x40,0x10,
+0x00,0x01,0x83,0x2D,
+0xFF,0x00,0x02,0x3C,
+0x10,0x00,0x03,0x24,
+0xFF,0xFF,0x42,0x34,
+0x2B,0x10,0x4C,0x00,
+0x18,0x00,0x04,0x24,
+0x21,0x28,0x60,0x00,
+0x0B,0x28,0x82,0x00,
+0x02,0x80,0x03,0x3C,
+0x06,0x10,0xAC,0x00,
+0xB4,0xF0,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0xA7,0xFF,0xC0,0x10,
+0x00,0x00,0x00,0x00,
+0x23,0x38,0x46,0x00,
+0x04,0x60,0xCC,0x00,
+0x06,0x58,0xEA,0x00,
+0x02,0x4C,0x0C,0x00,
+0x1B,0x00,0x69,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x8D,0x31,
+0x06,0x18,0xEF,0x00,
+0x04,0x10,0xCA,0x00,
+0x25,0x50,0x43,0x00,
+0x02,0x24,0x0A,0x00,
+0x12,0x28,0x00,0x00,
+0x10,0x40,0x00,0x00,
+0x00,0x14,0x08,0x00,
+0x25,0x40,0x44,0x00,
+0x18,0x00,0xAD,0x00,
+0x12,0x28,0x00,0x00,
+0x2B,0x18,0x05,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x69,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x05,0x00,0x60,0x10,
+0x04,0x78,0xCF,0x00,
+0x21,0x40,0x0C,0x01,
+0x2B,0x10,0x0C,0x01,
+0x93,0x00,0x40,0x10,
+0x2B,0x10,0x05,0x01,
+0x23,0x40,0x05,0x01,
+0x1B,0x00,0x09,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x44,0x31,
+0x12,0x18,0x00,0x00,
+0x10,0x58,0x00,0x00,
+0x00,0x14,0x0B,0x00,
+0x25,0x58,0x44,0x00,
+0x18,0x00,0x6D,0x00,
+0x12,0x28,0x00,0x00,
+0x2B,0x18,0x65,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x09,0x01,
+0x02,0x00,0x20,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x77,0xFF,0x60,0x10,
+0x23,0x50,0x65,0x01,
+0x21,0x58,0x6C,0x01,
+0x2B,0x10,0x6C,0x01,
+0x04,0x00,0x40,0x14,
+0x2B,0x10,0x65,0x01,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0x6C,0x01,
+0x0B,0x58,0x62,0x00,
+0x6A,0x62,0x00,0x08,
+0x23,0x50,0x65,0x01,
+0x08,0x00,0x02,0x24,
+0x21,0x28,0x00,0x00,
+0x0A,0x28,0x43,0x00,
+0x02,0x80,0x03,0x3C,
+0x06,0x10,0xA8,0x00,
+0xB4,0xF0,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x20,0x00,0x02,0x24,
+0x21,0x20,0x85,0x00,
+0x23,0x30,0x44,0x00,
+0x34,0xFF,0xC0,0x10,
+0x23,0x38,0x46,0x00,
+0x06,0x10,0xEC,0x00,
+0x04,0x18,0xC8,0x00,
+0x25,0x40,0x62,0x00,
+0x06,0x58,0xEA,0x00,
+0x02,0x6C,0x08,0x00,
+0x1B,0x00,0x6D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x11,0x31,
+0x06,0x10,0xEF,0x00,
+0x04,0x18,0xCA,0x00,
+0x25,0x50,0x62,0x00,
+0x02,0x24,0x0A,0x00,
+0x04,0x60,0xCC,0x00,
+0x12,0x80,0x00,0x00,
+0x10,0x48,0x00,0x00,
+0x00,0x14,0x09,0x00,
+0x25,0x48,0x44,0x00,
+0x12,0x28,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x18,0x00,0x11,0x02,
+0x12,0x70,0x00,0x00,
+0x2B,0x18,0x2E,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x6D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x0A,0x00,0x60,0x10,
+0x04,0x78,0xCF,0x00,
+0x21,0x48,0x28,0x01,
+0x2B,0x10,0x28,0x01,
+0x06,0x00,0x40,0x14,
+0xFF,0xFF,0xB0,0x24,
+0x2B,0x10,0x2E,0x01,
+0x03,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x10,0x26,
+0x21,0x48,0x28,0x01,
+0x23,0x48,0x2E,0x01,
+0x1B,0x00,0x2D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0xFF,0xFF,0x44,0x31,
+0x12,0x28,0x00,0x00,
+0x10,0x58,0x00,0x00,
+0x00,0x14,0x0B,0x00,
+0x25,0x58,0x44,0x00,
+0x18,0x00,0xB1,0x00,
+0x12,0x70,0x00,0x00,
+0x2B,0x18,0x6E,0x01,
+0x00,0x00,0x00,0x00,
+0x1B,0x00,0x2D,0x01,
+0x02,0x00,0xA0,0x15,
+0x00,0x00,0x00,0x00,
+0x0D,0x00,0x07,0x00,
+0x0B,0x00,0x60,0x10,
+0x00,0x14,0x10,0x00,
+0x21,0x58,0x68,0x01,
+0x2B,0x10,0x68,0x01,
+0x06,0x00,0x40,0x14,
+0xFF,0xFF,0xA5,0x24,
+0x2B,0x10,0x6E,0x01,
+0x04,0x00,0x40,0x10,
+0x00,0x14,0x10,0x00,
+0xFF,0xFF,0xA5,0x24,
+0x21,0x58,0x68,0x01,
+0x00,0x14,0x10,0x00,
+0x25,0x10,0x45,0x00,
+0x23,0x58,0x6E,0x01,
+0x19,0x00,0x4C,0x00,
+0x10,0x28,0x00,0x00,
+0x2B,0x18,0x65,0x01,
+0x12,0x48,0x00,0x00,
+0x05,0x00,0x60,0x14,
+0x23,0x20,0x2C,0x01,
+0x07,0x00,0xAB,0x14,
+0x2B,0x10,0xE9,0x01,
+0x05,0x00,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x2B,0x10,0x24,0x01,
+0x23,0x18,0xA8,0x00,
+0x23,0x28,0x62,0x00,
+0x21,0x48,0x80,0x00,
+0xEA,0xFE,0x40,0x12,
+0x23,0x18,0xE9,0x01,
+0x23,0x20,0x65,0x01,
+0x2B,0x10,0xE3,0x01,
+0x23,0x50,0x82,0x00,
+0x04,0x28,0xEA,0x00,
+0x06,0x18,0xC3,0x00,
+0x25,0xC0,0xA3,0x00,
+0x06,0xC8,0xCA,0x00,
+0x00,0x00,0x58,0xAE,
+0x4C,0x62,0x00,0x08,
+0x04,0x00,0x59,0xAE,
+0x00,0x01,0xC3,0x2C,
+0x08,0x00,0x02,0x24,
+0x21,0x30,0x00,0x00,
+0xE6,0x61,0x00,0x08,
+0x0A,0x30,0x43,0x00,
+0x00,0x00,0x42,0x38,
+0x21,0x18,0x0C,0x01,
+0xE0,0x62,0x00,0x08,
+0x0B,0x40,0x62,0x00,
+0x25,0xB0,0x02,0x3C,
+0xFF,0x00,0x03,0x3C,
+0xEC,0x02,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xF0,0x8D,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x7F,0x00,0x02,0x3C,
+0x0D,0xB8,0x44,0x34,
+0x80,0x04,0x03,0x3C,
+0x25,0x20,0x83,0x00,
+0x00,0x08,0x02,0x3C,
+0x25,0x20,0x82,0x00,
+0x00,0x30,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x25,0x20,0x83,0x00,
+0x41,0xB0,0x03,0x3C,
+0x00,0x00,0x64,0xAC,
+0xD8,0x1B,0x44,0xAC,
+0xD0,0x1B,0x44,0xAC,
+0x08,0x00,0x63,0x34,
+0x86,0x00,0x04,0x24,
+0x00,0x00,0x64,0xA4,
+0xDC,0x1B,0x44,0xA4,
+0xD4,0x1B,0x40,0xAC,
+0xDE,0x1B,0x40,0xA4,
+0x08,0x00,0xE0,0x03,
+0xE0,0x1B,0x44,0xA4,
+0x99,0x63,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x42,0xB0,0x03,0x3C,
+0x01,0x00,0x63,0x34,
+0x02,0x00,0x02,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x00,0x00,0x62,0xA0,
+0x10,0x00,0xBF,0xAF,
+0xDF,0x2F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x00,
+0x01,0x00,0x05,0x24,
+0x8C,0x23,0x00,0x0C,
+0x00,0x50,0x06,0x24,
+0x1F,0x00,0x06,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x00,0x40,0xC6,0x34,
+0x03,0x00,0x04,0x24,
+0x01,0x00,0x05,0x24,
+0x8C,0x23,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xC8,0xFF,0xBD,0x27,
+0x18,0x03,0x64,0x34,
+0xB8,0x8E,0x42,0x24,
+0x00,0x00,0x82,0xAC,
+0x30,0x00,0xBE,0xAF,
+0x2C,0x00,0xB7,0xAF,
+0x28,0x00,0xB6,0xAF,
+0x24,0x00,0xB5,0xAF,
+0x20,0x00,0xB4,0xAF,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0xB6,0x00,0x63,0x34,
+0x00,0x00,0x62,0x90,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x70,0x24,
+0xAB,0x1B,0x02,0xA2,
+0x28,0x6B,0x00,0x0C,
+0x7A,0x36,0x00,0xA2,
+0x48,0x01,0x03,0x24,
+0x84,0x36,0x03,0xAE,
+0x80,0x36,0x03,0xAE,
+0xFD,0xFF,0x02,0x3C,
+0xFB,0xFF,0x03,0x3C,
+0x21,0x98,0x00,0x02,
+0x21,0xA0,0x00,0x02,
+0xFF,0xFF,0x55,0x34,
+0xFF,0xFF,0x76,0x34,
+0x21,0x88,0x00,0x00,
+0x02,0x80,0x1E,0x3C,
+0x02,0x80,0x17,0x3C,
+0x21,0x90,0x00,0x02,
+0x80,0x10,0x11,0x00,
+0x21,0x10,0x51,0x00,
+0xC0,0x10,0x02,0x00,
+0x21,0x10,0x53,0x00,
+0xE8,0x1D,0x42,0x24,
+0x07,0x00,0x03,0x24,
+0xFF,0xFF,0x63,0x24,
+0x00,0x00,0x40,0xA4,
+0xFD,0xFF,0x61,0x04,
+0x02,0x00,0x42,0x24,
+0xC0,0x80,0x11,0x00,
+0x18,0x42,0xC4,0x27,
+0x21,0x20,0x04,0x02,
+0x21,0x28,0x00,0x00,
+0x02,0x00,0x06,0x24,
+0xF8,0x1D,0x40,0xA6,
+0x08,0x52,0x00,0x0C,
+0xFA,0x1D,0x40,0xA2,
+0x21,0x20,0x13,0x02,
+0xE8,0x22,0x83,0x8C,
+0xEA,0x5D,0xE7,0x92,
+0xBF,0xFF,0x02,0x24,
+0x24,0x28,0x62,0x00,
+0x01,0x00,0x02,0x24,
+0x63,0x00,0xE2,0x10,
+0x80,0x07,0xA6,0x34,
+0xFF,0xF7,0x03,0x24,
+0x24,0x10,0xC3,0x00,
+0xFF,0xEF,0x03,0x24,
+0x24,0x10,0x43,0x00,
+0xE8,0x22,0x82,0xAC,
+0x21,0x30,0x14,0x02,
+0xE8,0x22,0xC4,0x8C,
+0xE7,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x95,0x00,
+0x24,0x20,0x96,0x00,
+0xFF,0xFD,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0xFF,0xFF,0x63,0x34,
+0xFF,0xFB,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0xEC,0x22,0xC5,0x8C,
+0xFF,0xFF,0x42,0x34,
+0xFF,0xE7,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0xFF,0xFF,0x63,0x34,
+0xFF,0xFF,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0xFF,0x7F,0x42,0x34,
+0xC0,0xFF,0x03,0x24,
+0x24,0x28,0xA2,0x00,
+0x24,0x20,0x83,0x00,
+0x1F,0x00,0x02,0x3C,
+0x01,0x00,0x31,0x26,
+0x25,0x28,0xA2,0x00,
+0x08,0x00,0x84,0x34,
+0x20,0x00,0x22,0x2A,
+0xE8,0x22,0xC4,0xAC,
+0xEC,0x22,0xC5,0xAC,
+0xC3,0xFF,0x40,0x14,
+0x28,0x00,0x52,0x26,
+0x25,0xB0,0x02,0x3C,
+0x10,0x00,0x03,0x24,
+0xB0,0x03,0x42,0x34,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x43,0xAC,
+0x58,0x22,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0x08,0x52,0x00,0x0C,
+0x20,0x00,0x06,0x24,
+0x02,0x80,0x02,0x3C,
+0xE9,0x5D,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x3A,0x00,0x60,0x10,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x50,0x24,
+0x24,0x03,0x00,0xA2,
+0x38,0x70,0x00,0x0C,
+0x25,0x03,0x00,0xA2,
+0x02,0x80,0x09,0x3C,
+0x64,0x57,0x22,0x25,
+0x02,0x80,0x0A,0x3C,
+0x02,0x80,0x0B,0x3C,
+0x02,0x80,0x0C,0x3C,
+0x02,0x80,0x0D,0x3C,
+0x02,0x80,0x0E,0x3C,
+0x02,0x80,0x0F,0x3C,
+0x04,0x00,0x42,0xAC,
+0x64,0x57,0x22,0xAD,
+0x6C,0x57,0x43,0x25,
+0x74,0x57,0x64,0x25,
+0x7C,0x57,0x85,0x25,
+0x84,0x57,0xA6,0x25,
+0x8C,0x57,0xC7,0x25,
+0x94,0x57,0xE8,0x25,
+0x09,0x00,0x02,0x24,
+0x04,0x00,0x63,0xAC,
+0x6C,0x57,0x43,0xAD,
+0x04,0x00,0x84,0xAC,
+0x74,0x57,0x64,0xAD,
+0x04,0x00,0xA5,0xAC,
+0x7C,0x57,0x85,0xAD,
+0x04,0x00,0xC6,0xAC,
+0x84,0x57,0xA6,0xAD,
+0x04,0x00,0xE7,0xAC,
+0x8C,0x57,0xC7,0xAD,
+0x94,0x57,0xE8,0xAD,
+0x04,0x00,0x08,0xAD,
+0x34,0x00,0xBF,0x8F,
+0x0C,0x3E,0x02,0xA2,
+0x32,0x3B,0x00,0xA6,
+0x8E,0x3E,0x00,0xA2,
+0x30,0x00,0xBE,0x8F,
+0x2C,0x00,0xB7,0x8F,
+0x28,0x00,0xB6,0x8F,
+0x24,0x00,0xB5,0x8F,
+0x20,0x00,0xB4,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0xEB,0x5D,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x9C,0xFF,0x67,0x14,
+0x80,0x0F,0xA2,0x34,
+0xFF,0xF7,0x03,0x24,
+0x24,0x10,0xC3,0x00,
+0xF0,0x63,0x00,0x08,
+0x00,0x10,0x42,0x34,
+0xFA,0x6B,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x50,0x6E,0x00,0x0C,
+0x30,0x38,0x80,0xAE,
+0x6E,0x6F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x03,0x3C,
+0xDE,0x5D,0x64,0x90,
+0x92,0x00,0x02,0x24,
+0x03,0x00,0x82,0x10,
+0x00,0x00,0x00,0x00,
+0xCA,0x6F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xB0,0x6F,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x6A,0x6E,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x24,
+0x8A,0x36,0x83,0xA6,
+0x1E,0x70,0x00,0x0C,
+0x88,0x36,0x80,0xA6,
+0x1E,0x64,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xC8,0xFF,0xBD,0x27,
+0xB8,0x91,0x63,0x24,
+0x18,0x03,0x42,0x34,
+0x18,0x00,0xB0,0xAF,
+0x34,0x00,0xBF,0xAF,
+0x30,0x00,0xB6,0xAF,
+0x2C,0x00,0xB5,0xAF,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x20,0x00,0xB2,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x00,0x00,0x43,0xAC,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x02,0x26,
+0xFF,0xFF,0x50,0x30,
+0x64,0x00,0x03,0x2E,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0x02,0x26,
+0x02,0x80,0x03,0x3C,
+0xDB,0x5D,0x68,0x90,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xD8,0x5D,0x4B,0x94,
+0xF3,0x5D,0x6A,0x90,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x14,0x3C,
+0xFA,0x5D,0x67,0x90,
+0xE8,0x5D,0x49,0x90,
+0xDA,0x5D,0x83,0x92,
+0x02,0x80,0x0C,0x3C,
+0x02,0x80,0x02,0x3C,
+0xF5,0x5D,0x46,0x90,
+0xF8,0x5D,0x85,0x91,
+0x25,0xB0,0x04,0x3C,
+0xB0,0x03,0x82,0x34,
+0x00,0x00,0x4B,0xAC,
+0x00,0x00,0x48,0xAC,
+0x00,0x00,0x49,0xAC,
+0x00,0x00,0x43,0xAC,
+0x02,0x80,0x03,0x3C,
+0x00,0x00,0x4A,0xAC,
+0x0A,0x00,0x88,0x34,
+0x00,0x00,0x46,0xAC,
+0x00,0x00,0x45,0xAC,
+0x00,0x00,0x47,0xAC,
+0x1A,0x5E,0x60,0xA4,
+0x00,0x00,0x06,0x91,
+0x02,0x80,0x02,0x3C,
+0x0B,0x00,0x04,0x24,
+0x02,0x80,0x16,0x3C,
+0xE5,0x5D,0x44,0xA0,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0xC5,0x26,
+0x00,0x78,0x03,0x24,
+0x08,0x5E,0x40,0xA0,
+0xF0,0xFF,0x02,0x24,
+0x01,0x00,0x07,0x24,
+0x02,0x80,0x15,0x3C,
+0xAC,0x1B,0xA3,0xA4,
+0xAA,0x1B,0xA2,0xA0,
+0xFF,0x07,0x03,0x24,
+0xFF,0xFF,0x02,0x24,
+0x20,0x00,0xC6,0x30,
+0xF8,0x5D,0x87,0xA1,
+0xA8,0x1B,0xA7,0xA0,
+0xAE,0x1B,0xA3,0xA4,
+0x48,0xF3,0xA2,0xA2,
+0xB1,0x00,0xC0,0x10,
+0xB0,0x1B,0xA0,0xA4,
+0x00,0x00,0x02,0x91,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x42,0x30,
+0xFB,0x00,0x40,0x14,
+0x02,0x80,0x13,0x3C,
+0x21,0x80,0x00,0x00,
+0x21,0x88,0x00,0x00,
+0xB8,0xF1,0x72,0x26,
+0xFF,0x00,0x24,0x32,
+0x61,0x57,0x00,0x0C,
+0x21,0x28,0x12,0x02,
+0x08,0x00,0x03,0x26,
+0xFF,0xFF,0x70,0x30,
+0x01,0x00,0x22,0x26,
+0x80,0x00,0x03,0x2E,
+0xF8,0xFF,0x60,0x14,
+0xFF,0xFF,0x51,0x30,
+0xDA,0x5D,0x83,0x92,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0x62,0x30,
+0xC1,0x00,0x40,0x14,
+0x04,0x00,0x62,0x30,
+0x9A,0x00,0x40,0x10,
+0x25,0xB0,0x03,0x3C,
+0x25,0xB0,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x06,0x00,0x06,0x24,
+0x50,0x00,0x84,0x34,
+0x10,0x52,0x00,0x0C,
+0x07,0xF2,0xA5,0x24,
+0xB8,0xF1,0x63,0x26,
+0x7B,0x00,0x66,0x90,
+0x00,0x00,0x00,0x00,
+0x02,0x00,0xC2,0x2C,
+0x04,0x00,0x40,0x14,
+0x02,0x00,0x0B,0x24,
+0x79,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x03,0x00,0x4B,0x30,
+0x04,0x00,0xC2,0x2C,
+0xDC,0x00,0x40,0x10,
+0xB8,0xF1,0x62,0x26,
+0x02,0x80,0x02,0x3C,
+0x4A,0xF3,0x40,0xA0,
+0x02,0x80,0x02,0x3C,
+0xE7,0x5D,0x43,0x90,
+0x01,0x00,0x02,0x24,
+0x02,0x00,0x62,0x10,
+0xFC,0xFF,0x08,0x24,
+0x21,0x40,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xB8,0xF1,0x4A,0x24,
+0x30,0x1F,0x69,0x24,
+0x21,0x60,0x00,0x00,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x02,0x26,
+0x21,0x30,0x30,0x01,
+0x03,0x00,0x03,0x2E,
+0x08,0x00,0x04,0x2E,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x07,0x2E,
+0x04,0x00,0x60,0x14,
+0x21,0x88,0x00,0x00,
+0x01,0x00,0x11,0x24,
+0x02,0x00,0x02,0x24,
+0x0A,0x88,0x44,0x00,
+0x21,0x10,0x51,0x01,
+0x61,0x00,0x43,0x90,
+0x55,0x00,0x44,0x90,
+0x5B,0x00,0x45,0x90,
+0x21,0x18,0x03,0x01,
+0x21,0x20,0x04,0x01,
+0x21,0x28,0x05,0x01,
+0x9C,0x1D,0xC3,0xA0,
+0x64,0x1D,0xC4,0xA0,
+0xEB,0xFF,0xE0,0x14,
+0x80,0x1D,0xC5,0xA0,
+0x01,0x00,0x8C,0x25,
+0x02,0x00,0x82,0x2D,
+0x0E,0x00,0x29,0x25,
+0xE5,0xFF,0x40,0x14,
+0x03,0x00,0x4A,0x25,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x47,0x24,
+0xB8,0xF1,0x66,0x24,
+0x21,0x80,0x00,0x00,
+0x03,0x00,0x02,0x2E,
+0x21,0x20,0x07,0x02,
+0xB9,0x00,0x40,0x10,
+0x08,0x00,0x03,0x2E,
+0x71,0x00,0xC3,0x90,
+0x6E,0x00,0xC2,0x90,
+0x00,0x00,0x00,0x00,
+0xC6,0x1D,0x82,0xA0,
+0xB8,0x1D,0x83,0xA0,
+0x01,0x00,0x02,0x26,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x03,0x2E,
+0xF4,0xFF,0x60,0x14,
+0x03,0x00,0x02,0x2E,
+0x03,0x00,0x02,0x24,
+0x2A,0x00,0x62,0x15,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xB8,0xF1,0x4E,0x24,
+0x34,0xD9,0x6F,0x24,
+0x21,0x60,0x00,0x00,
+0x21,0x68,0x00,0x00,
+0x21,0x10,0xAE,0x01,
+0x74,0x00,0x43,0x90,
+0x21,0x80,0x00,0x00,
+0x0F,0x00,0x6A,0x30,
+0x02,0x49,0x03,0x00,
+0x21,0x10,0xB0,0x01,
+0x00,0x11,0x02,0x00,
+0x21,0x58,0x4F,0x00,
+0x21,0x38,0x00,0x00,
+0x21,0x40,0x67,0x01,
+0x00,0x00,0x03,0x91,
+0x00,0x31,0x09,0x00,
+0x01,0x00,0xE7,0x24,
+0x02,0x11,0x03,0x00,
+0x00,0x21,0x02,0x00,
+0x0F,0x00,0x63,0x30,
+0x2B,0x10,0x49,0x00,
+0x0A,0x20,0xC2,0x00,
+0x2B,0x28,0x6A,0x00,
+0x00,0x00,0xA5,0x38,
+0x25,0x18,0x83,0x00,
+0xFF,0xFF,0xE7,0x30,
+0x25,0x20,0x8A,0x00,
+0x0A,0x18,0x85,0x00,
+0x10,0x00,0xE2,0x2C,
+0xEF,0xFF,0x40,0x14,
+0x00,0x00,0x03,0xA1,
+0x01,0x00,0x02,0x26,
+0xFF,0xFF,0x50,0x30,
+0x03,0x00,0x03,0x2E,
+0xE7,0xFF,0x60,0x14,
+0x21,0x10,0xB0,0x01,
+0x01,0x00,0x8C,0x25,
+0x02,0x00,0x82,0x2D,
+0xDD,0xFF,0x40,0x14,
+0x03,0x00,0xAD,0x25,
+0xE6,0x56,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x48,0xF3,0xA5,0x26,
+0x91,0x56,0x00,0x0C,
+0xFA,0x01,0x04,0x24,
+0xE6,0x56,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x25,0xB0,0x05,0x3C,
+0x18,0x3B,0x84,0x24,
+0x50,0x00,0xA5,0x34,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0x30,0x1F,0xC5,0x26,
+0x01,0x00,0x02,0x24,
+0x06,0x00,0x03,0x24,
+0x05,0x00,0x04,0x24,
+0x33,0x1C,0xA2,0xA0,
+0x8A,0x55,0x00,0x0C,
+0x30,0x3B,0xA3,0xA0,
+0x34,0x00,0xBF,0x8F,
+0x30,0x00,0xB6,0x8F,
+0x2C,0x00,0xB5,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x38,0x00,0xBD,0x27,
+0x25,0xB0,0x03,0x3C,
+0x4C,0x87,0x02,0x3C,
+0x54,0x00,0x65,0x34,
+0x00,0xE0,0x42,0x34,
+0x50,0x00,0x63,0x34,
+0x00,0x00,0x62,0xAC,
+0x12,0x01,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0xA4,0xAC,
+0x30,0x1F,0x46,0x24,
+0x21,0x60,0x00,0x00,
+0x10,0x00,0x05,0x24,
+0x21,0x80,0x00,0x00,
+0x01,0x00,0x02,0x26,
+0x21,0x18,0xD0,0x00,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x04,0x2E,
+0x80,0x1D,0x65,0xA0,
+0x64,0x1D,0x65,0xA0,
+0xF9,0xFF,0x80,0x14,
+0x9C,0x1D,0x65,0xA0,
+0x01,0x00,0x8C,0x25,
+0x02,0x00,0x82,0x2D,
+0xF4,0xFF,0x40,0x14,
+0x0E,0x00,0xC6,0x24,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x46,0x24,
+0x21,0x80,0x00,0x00,
+0x04,0x00,0x05,0x24,
+0x01,0x00,0x02,0x26,
+0x21,0x18,0x06,0x02,
+0xFF,0xFF,0x50,0x30,
+0x0E,0x00,0x04,0x2E,
+0xC6,0x1D,0x60,0xA0,
+0xFA,0xFF,0x80,0x14,
+0xB8,0x1D,0x65,0xA0,
+0x48,0x65,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x50,0x00,0x84,0x34,
+0xCA,0xF1,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x06,0x00,0x06,0x24,
+0xB8,0xF1,0x62,0x92,
+0xB8,0xF1,0x64,0x26,
+0x01,0x00,0x85,0x90,
+0x21,0x18,0x40,0x00,
+0x10,0x00,0xA2,0xA3,
+0x29,0x00,0x02,0x24,
+0x11,0x00,0xA5,0xA3,
+0x50,0x00,0x86,0x90,
+0x3B,0x00,0x62,0x10,
+0xFF,0x00,0xA3,0x30,
+0xB8,0xF1,0x65,0x26,
+0x68,0x00,0xA2,0x90,
+0x02,0x80,0x03,0x3C,
+0x04,0x00,0xC4,0x2C,
+0x1F,0x00,0x42,0x30,
+0x24,0x00,0x80,0x14,
+0x49,0xF3,0x62,0xA0,
+0x7A,0x00,0xA2,0x90,
+0x79,0x00,0xA4,0x90,
+0x02,0x80,0x03,0x3C,
+0x04,0x00,0x42,0x30,
+0x83,0x10,0x02,0x00,
+0x03,0x00,0x8B,0x30,
+0x4A,0xF3,0x62,0xA0,
+0x06,0x00,0xC2,0x2C,
+0x37,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0xB8,0xF1,0x63,0x26,
+0x69,0x00,0x62,0x90,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x42,0x30,
+0x31,0xFF,0x40,0x14,
+0x02,0x80,0x02,0x3C,
+0xE8,0x64,0x00,0x08,
+0x21,0x40,0x00,0x00,
+0x21,0x20,0x00,0x00,
+0x80,0x00,0x05,0x24,
+0x53,0x56,0x00,0x0C,
+0xB8,0xF1,0x66,0x26,
+0xC7,0x64,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x7D,0x00,0x43,0x90,
+0x69,0x00,0x44,0x90,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x63,0x30,
+0x01,0x00,0x84,0x30,
+0x83,0x18,0x03,0x00,
+0x01,0x00,0x84,0x2C,
+0x1F,0xFF,0x80,0x10,
+0x4A,0xF3,0x43,0xA0,
+0xE8,0x64,0x00,0x08,
+0x21,0x40,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x02,0x00,0x0B,0x24,
+0xAA,0x65,0x00,0x08,
+0x4A,0xF3,0x40,0xA0,
+0x21,0x28,0x07,0x02,
+0x06,0x00,0x60,0x10,
+0x21,0x20,0xA0,0x00,
+0x67,0x00,0xC3,0x90,
+0x6F,0x00,0xC2,0x90,
+0xB8,0x1D,0xA3,0xA0,
+0x17,0x65,0x00,0x08,
+0xC6,0x1D,0xA2,0xA0,
+0x72,0x00,0xC3,0x90,
+0x70,0x00,0xC2,0x90,
+0x16,0x65,0x00,0x08,
+0xC6,0x1D,0x82,0xA0,
+0x81,0x00,0x02,0x24,
+0xC4,0xFF,0x62,0x14,
+0x01,0x00,0x02,0x24,
+0x54,0x00,0x83,0x90,
+0x00,0x00,0x00,0x00,
+0x0A,0x00,0x62,0x10,
+0x02,0x00,0x02,0x24,
+0x04,0x00,0x62,0x10,
+0x11,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x9C,0x65,0x00,0x08,
+0xDE,0x5D,0x43,0xA0,
+0x22,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x9C,0x65,0x00,0x08,
+0xDE,0x5D,0x43,0xA0,
+0x12,0x00,0x03,0x24,
+0x02,0x80,0x02,0x3C,
+0x9C,0x65,0x00,0x08,
+0xDE,0x5D,0x43,0xA0,
+0xD8,0xFF,0xBD,0x27,
+0x18,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0x25,0xB0,0x10,0x3C,
+0x18,0x03,0x03,0x36,
+0xA8,0x97,0x42,0x24,
+0x00,0x00,0x62,0xAC,
+0x20,0x00,0xB2,0xAF,
+0x02,0x80,0x12,0x3C,
+0x24,0x00,0xBF,0xAF,
+0x6E,0x64,0x00,0x0C,
+0x1C,0x00,0xB1,0xAF,
+0x9C,0x66,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x36,0x69,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x1A,0x6A,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x7C,0x6C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x82,0x69,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x30,0x1F,0x43,0x26,
+0x30,0x3B,0x64,0x90,
+0x0D,0x0C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x76,0x63,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x64,0x40,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0x03,0x36,
+0x00,0x00,0x62,0x94,
+0x00,0x00,0x00,0x00,
+0x40,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA4,
+0xAE,0x63,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x7C,0x63,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x9B,0x63,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xE6,0x69,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xA3,0x69,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x00,0x80,0x04,0x3C,
+0x74,0x6A,0x84,0x24,
+0x03,0x6A,0x00,0x0C,
+0x01,0x00,0x05,0x24,
+0x00,0x80,0x04,0x3C,
+0x6C,0x72,0x84,0x24,
+0x03,0x6A,0x00,0x0C,
+0x02,0x00,0x05,0x24,
+0x00,0x80,0x04,0x3C,
+0x48,0x7B,0x84,0x24,
+0x03,0x6A,0x00,0x0C,
+0x04,0x00,0x05,0x24,
+0x7E,0x59,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x01,0x80,0x04,0x3C,
+0xB8,0x8E,0x84,0x24,
+0x03,0x6A,0x00,0x0C,
+0x03,0x00,0x05,0x24,
+0x02,0x80,0x03,0x3C,
+0xE8,0x5D,0x63,0x90,
+0x00,0x00,0x00,0x00,
+0x60,0x00,0x60,0x10,
+0x43,0x00,0x02,0x36,
+0x07,0x00,0x02,0x24,
+0x0C,0x00,0x62,0x10,
+0x03,0x00,0x02,0x24,
+0x25,0xB0,0x04,0x3C,
+0x43,0x00,0x85,0x34,
+0x10,0x02,0x86,0x34,
+0x10,0x00,0x03,0x24,
+0x00,0x00,0xA2,0xA0,
+0xD8,0x00,0x84,0x34,
+0x00,0x00,0xC3,0xA0,
+0x00,0x00,0x82,0x90,
+0x80,0xFF,0x03,0x24,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0x82,0xA0,
+0xE0,0x6A,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x42,0xB0,0x03,0x3C,
+0x00,0x00,0x62,0x90,
+0x25,0xB0,0x10,0x3C,
+0x02,0x80,0x11,0x3C,
+0x01,0x00,0x42,0x34,
+0x00,0x00,0x62,0xA0,
+0x83,0x63,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0x05,0x36,
+0x00,0x00,0xA2,0x94,
+0x02,0x80,0x03,0x3C,
+0x8C,0xC6,0x64,0x8C,
+0xC0,0x00,0x42,0x34,
+0x00,0x00,0xA2,0xA4,
+0x2F,0x55,0x00,0x0C,
+0x80,0x0C,0x10,0x36,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xDA,0x5D,0x45,0x90,
+0xDF,0x5D,0x66,0x90,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x90,0xC6,0x84,0x24,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xDE,0x5D,0x45,0x90,
+0x48,0xF3,0x66,0x90,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xE7,0x5D,0x47,0x90,
+0x4A,0xF3,0x62,0x90,
+0x02,0x80,0x04,0x3C,
+0xA4,0xC6,0x84,0x24,
+0x2F,0x55,0x00,0x0C,
+0x10,0x00,0xA2,0xAF,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0x07,0x8E,
+0xE6,0x5D,0x46,0x90,
+0xE9,0x5D,0x25,0x92,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0xC0,0xC6,0x84,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xEB,0x5D,0x66,0x90,
+0xEA,0x5D,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x30,0x1F,0x50,0x26,
+0x2F,0x55,0x00,0x0C,
+0xDC,0xC6,0x84,0x24,
+0xA0,0x3E,0x06,0x8E,
+0xA4,0x3E,0x05,0x8E,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0xF0,0xC6,0x84,0x24,
+0x02,0x80,0x02,0x3C,
+0x49,0xF3,0x45,0x90,
+0x02,0x80,0x04,0x3C,
+0x2F,0x55,0x00,0x0C,
+0x10,0xC7,0x84,0x24,
+0xE9,0x5D,0x23,0x92,
+0x10,0x27,0x02,0x24,
+0x02,0x80,0x04,0x3C,
+0x0B,0x10,0x03,0x00,
+0x40,0x39,0x02,0xAE,
+0x08,0x00,0x84,0x24,
+0x21,0x28,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x91,0x3C,0x00,0x0C,
+0x21,0x38,0x00,0x00,
+0x99,0x63,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x24,0x00,0xBF,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xD8,0x00,0x04,0x36,
+0x00,0x00,0x40,0xA0,
+0x38,0x66,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x20,0x00,0x00,
+0x20,0xB0,0x06,0x3C,
+0xFF,0xFF,0x05,0x34,
+0x21,0x18,0x86,0x00,
+0x04,0x00,0x84,0x24,
+0x2A,0x10,0xA4,0x00,
+0x00,0x00,0x60,0xAC,
+0xFB,0xFF,0x40,0x10,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xB8,0xFF,0xBD,0x27,
+0x24,0x00,0xB1,0xAF,
+0x44,0x00,0xBF,0xAF,
+0x40,0x00,0xBE,0xAF,
+0x3C,0x00,0xB7,0xAF,
+0x38,0x00,0xB6,0xAF,
+0x34,0x00,0xB5,0xAF,
+0x30,0x00,0xB4,0xAF,
+0x2C,0x00,0xB3,0xAF,
+0x28,0x00,0xB2,0xAF,
+0x20,0x00,0xB0,0xAF,
+0x02,0x80,0x02,0x3C,
+0xDA,0x5D,0x42,0x90,
+0x25,0xB0,0x11,0x3C,
+0x58,0x00,0x25,0x36,
+0x10,0x00,0xA2,0xAF,
+0x4C,0x81,0x02,0x3C,
+0x00,0xE0,0x42,0x34,
+0x00,0x00,0xA2,0xAC,
+0xFF,0xFF,0x04,0x24,
+0x96,0x01,0x03,0x24,
+0x28,0x28,0x02,0x24,
+0x5C,0x00,0x26,0x36,
+0x60,0x00,0x27,0x36,
+0x64,0x00,0x28,0x36,
+0x8A,0x00,0x29,0x36,
+0x00,0x00,0xC3,0xAC,
+0x00,0x00,0xE4,0xAC,
+0x00,0x00,0x04,0xAD,
+0x00,0x00,0x22,0xA5,
+0x0E,0x0E,0x02,0x3C,
+0x09,0x00,0x03,0x24,
+0x0A,0x0A,0x42,0x34,
+0x89,0x00,0x2A,0x36,
+0x8C,0x00,0x2B,0x36,
+0x00,0x00,0x43,0xA1,
+0x90,0x00,0x2C,0x36,
+0x00,0x00,0x62,0xAD,
+0x13,0x00,0x03,0x24,
+0x30,0x00,0x02,0x24,
+0x91,0x00,0x2D,0x36,
+0x00,0x00,0x83,0xA1,
+0x92,0x00,0x2E,0x36,
+0x00,0x00,0xA2,0xA1,
+0x3A,0x01,0x03,0x24,
+0x21,0x00,0x02,0x24,
+0xB5,0x00,0x2F,0x36,
+0x00,0x00,0xC3,0xA5,
+0x00,0x00,0xE2,0xA1,
+0x10,0x00,0xA2,0x8F,
+0x12,0x00,0x03,0x24,
+0x89,0x01,0x43,0x10,
+0x07,0x07,0x02,0x3C,
+0x07,0x07,0x42,0x34,
+0xA0,0x00,0x24,0x36,
+0x00,0x00,0x82,0xAC,
+0xA4,0x00,0x25,0x36,
+0x00,0x07,0x03,0x24,
+0x00,0xC0,0x02,0x3C,
+0xA8,0x00,0x26,0x36,
+0x00,0x00,0xA3,0xAC,
+0x00,0xC4,0x42,0x34,
+0x00,0x00,0xC2,0xAC,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x62,0x24,
+0xAC,0x1B,0x45,0x94,
+0xAE,0x1B,0x46,0x94,
+0xAA,0x1B,0x42,0x90,
+0x02,0x80,0x03,0x3C,
+0x21,0xB0,0x07,0x3C,
+0x14,0x00,0xA2,0xA3,
+0xE9,0x5D,0x63,0x90,
+0x20,0xB0,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x18,0x00,0xA3,0xAF,
+0x23,0xB0,0x03,0x3C,
+0xFF,0xFF,0x63,0x34,
+0x24,0xB0,0x08,0x3C,
+0xFF,0x1F,0x04,0x3C,
+0x25,0xB0,0x1E,0x3C,
+0xFF,0xFF,0x84,0x34,
+0x21,0x38,0xA7,0x00,
+0x21,0x40,0xC8,0x00,
+0x21,0x28,0xA2,0x00,
+0x21,0x30,0xC3,0x00,
+0x24,0x40,0x04,0x01,
+0x24,0x28,0xA4,0x00,
+0x24,0x38,0xE4,0x00,
+0x24,0x30,0xC4,0x00,
+0x35,0x00,0x02,0x24,
+0x20,0x00,0xC4,0x37,
+0x00,0x00,0x82,0xA0,
+0x22,0x00,0x03,0x24,
+0x09,0x00,0x02,0x24,
+0x03,0x05,0xC9,0x37,
+0x60,0x05,0xCA,0x37,
+0xAC,0x00,0xCB,0x37,
+0xF8,0x00,0xCC,0x37,
+0xB0,0x00,0xCD,0x37,
+0x08,0x01,0xCE,0x37,
+0xD8,0x00,0xCF,0x37,
+0x00,0x00,0x23,0xA1,
+0x00,0x00,0x42,0xA1,
+0x00,0x00,0x65,0xAD,
+0x00,0x00,0x87,0xAD,
+0x00,0x00,0xA6,0xAD,
+0x00,0x00,0xC8,0xAD,
+0x00,0x00,0xE0,0xA1,
+0x14,0x00,0xA3,0x93,
+0x25,0xB0,0x02,0x3C,
+0xB4,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA0,
+0xB6,0x00,0xD1,0x37,
+0x04,0x00,0x02,0x24,
+0x25,0xB0,0x03,0x3C,
+0x00,0x00,0x22,0xA2,
+0xB9,0x00,0x63,0x34,
+0xFF,0xFF,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0x25,0xB0,0x03,0x3C,
+0x0F,0x00,0x02,0x24,
+0xBA,0x00,0x63,0x34,
+0x00,0x00,0x62,0xA4,
+0x16,0x01,0xD4,0x37,
+0x3F,0x3F,0x03,0x24,
+0x2F,0x00,0x02,0x3C,
+0x00,0x00,0x83,0xA6,
+0x17,0x32,0x42,0x34,
+0xFF,0xCF,0x03,0x24,
+0x18,0x01,0xD5,0x37,
+0x1A,0x01,0xD6,0x37,
+0xDC,0x00,0xD7,0x37,
+0xD0,0x01,0xD8,0x37,
+0x00,0x00,0xA0,0xA6,
+0x00,0x00,0xC0,0xA6,
+0x00,0x00,0xE3,0xAE,
+0x00,0x00,0x02,0xAF,
+0x5E,0x00,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x17,0x43,0x63,0x34,
+0xD4,0x01,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x10,0x00,0x02,0x3C,
+0x20,0x53,0x42,0x34,
+0xD8,0x01,0xDF,0x37,
+0x00,0x00,0xE2,0xAF,
+0x25,0xB0,0x02,0x3C,
+0x44,0xA4,0x03,0x34,
+0xDC,0x01,0x42,0x34,
+0x00,0x00,0x43,0xAC,
+0x25,0xB0,0x03,0x3C,
+0x1A,0x06,0x02,0x24,
+0xE0,0x01,0x63,0x34,
+0x00,0x00,0x62,0xA4,
+0xC2,0x00,0x02,0x3C,
+0x30,0x30,0x03,0x24,
+0x51,0x10,0x42,0x34,
+0xF4,0x01,0xD0,0x37,
+0xF8,0x01,0xD3,0x37,
+0x00,0x00,0x03,0xA6,
+0x00,0x02,0xD2,0x37,
+0x00,0x00,0x62,0xAE,
+0x26,0x00,0x03,0x24,
+0x03,0x02,0xD9,0x37,
+0x04,0x00,0x02,0x24,
+0x00,0x00,0x43,0xA6,
+0x00,0x00,0x22,0xA3,
+0x18,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0xE5,0x00,0x60,0x14,
+0x36,0x02,0xC2,0x37,
+0x04,0x00,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0x02,0x80,0x0B,0x3C,
+0xDE,0x5D,0x66,0x91,
+0x25,0xB0,0x09,0x3C,
+0x80,0x00,0x02,0x24,
+0x34,0x02,0x24,0x35,
+0x00,0x00,0x82,0xA4,
+0x37,0x02,0x25,0x35,
+0x53,0x00,0x03,0x24,
+0x22,0x00,0x02,0x24,
+0x00,0x00,0xA3,0xA0,
+0xE6,0x00,0xC2,0x10,
+0x1B,0x1B,0x02,0x3C,
+0x13,0x13,0x02,0x3C,
+0x13,0x13,0x42,0x34,
+0x60,0x01,0x23,0x35,
+0x64,0x01,0x24,0x35,
+0x68,0x01,0x25,0x35,
+0x7C,0x01,0x2A,0x35,
+0x6C,0x01,0x26,0x35,
+0x70,0x01,0x27,0x35,
+0x74,0x01,0x28,0x35,
+0x78,0x01,0x29,0x35,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0x82,0xAC,
+0x00,0x00,0xA2,0xAC,
+0x00,0x00,0xC2,0xAC,
+0x00,0x00,0xE2,0xAC,
+0x00,0x00,0x02,0xAD,
+0x00,0x00,0x22,0xAD,
+0x00,0x00,0x42,0xAD,
+0xDE,0x5D,0x65,0x91,
+0x25,0xB0,0x0C,0x3C,
+0x01,0x00,0x03,0x3C,
+0x80,0x01,0x82,0x35,
+0x08,0x5F,0x63,0x34,
+0x22,0x00,0x04,0x24,
+0x00,0x00,0x43,0xAC,
+0xE5,0x00,0xA4,0x10,
+0x0F,0x1F,0x02,0x3C,
+0x92,0x00,0x02,0x24,
+0xE2,0x00,0xA2,0x10,
+0x0F,0x1F,0x02,0x3C,
+0x0F,0x10,0x02,0x3C,
+0x00,0xF0,0x4F,0x34,
+0xF7,0x01,0x91,0x35,
+0x15,0xF0,0x4D,0x34,
+0x77,0x00,0x0E,0x24,
+0x84,0x01,0x87,0x35,
+0x88,0x01,0x88,0x35,
+0x10,0xF0,0x44,0x34,
+0x8C,0x01,0x85,0x35,
+0x05,0xF0,0x42,0x34,
+0x00,0x00,0xED,0xAC,
+0x90,0x01,0x83,0x35,
+0x00,0x00,0x04,0xAD,
+0x94,0x01,0x86,0x35,
+0x00,0x00,0xA2,0xAC,
+0xF5,0x0F,0x02,0x24,
+0x00,0x00,0x6F,0xAC,
+0x98,0x01,0x89,0x35,
+0x00,0x00,0xC2,0xAC,
+0x9C,0x01,0x8A,0x35,
+0xA0,0x01,0x8B,0x35,
+0xF0,0x0F,0x03,0x24,
+0xF6,0x01,0x8C,0x35,
+0x0D,0x00,0x02,0x24,
+0x00,0x00,0x23,0xAD,
+0x00,0x00,0x42,0xAD,
+0x00,0x00,0x6D,0xAD,
+0x02,0x80,0x02,0x3C,
+0x00,0x00,0x8E,0xA1,
+0x00,0x00,0x2E,0xA2,
+0xFB,0x5D,0x42,0x90,
+0x25,0xB0,0x1F,0x3C,
+0xA7,0x01,0xE7,0x37,
+0x1C,0x00,0xA2,0xAF,
+0xFF,0xFF,0x02,0x24,
+0x00,0x00,0xE2,0xA0,
+0x05,0x06,0x03,0x3C,
+0x25,0xB0,0x02,0x3C,
+0x03,0x04,0x63,0x34,
+0x0C,0x00,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0x01,0x02,0x06,0x3C,
+0xC2,0x01,0x42,0x34,
+0xA8,0x01,0xE8,0x37,
+0xAC,0x01,0xE9,0x37,
+0xB0,0x01,0xEA,0x37,
+0xB4,0x01,0xEB,0x37,
+0xB8,0x01,0xEC,0x37,
+0xBC,0x01,0xED,0x37,
+0xC0,0x01,0xEE,0x37,
+0xC1,0x01,0xEF,0x37,
+0x00,0x00,0x05,0xAD,
+0x00,0x00,0x25,0xAD,
+0x00,0x00,0x46,0xAD,
+0x00,0x00,0x63,0xAD,
+0x00,0x00,0x86,0xAD,
+0x00,0x00,0xA3,0xAD,
+0x00,0x00,0xC4,0xA1,
+0x25,0xB0,0x03,0x3C,
+0x00,0x00,0xE4,0xA1,
+0x00,0x00,0x44,0xA0,
+0x25,0xB0,0x02,0x3C,
+0x0D,0x00,0x17,0x24,
+0x0E,0x00,0x18,0x24,
+0xC4,0x01,0x63,0x34,
+0xC5,0x01,0x42,0x34,
+0xC3,0x01,0xF1,0x37,
+0x00,0x00,0x37,0xA2,
+0xC6,0x01,0xF4,0x37,
+0x00,0x00,0x77,0xA0,
+0xC7,0x01,0xF5,0x37,
+0x00,0x00,0x58,0xA0,
+0x0F,0x00,0x02,0x24,
+0x00,0x00,0x98,0xA2,
+0x00,0x00,0xA2,0xA2,
+0xD3,0x01,0x02,0x3C,
+0x46,0x00,0xF6,0x37,
+0x48,0x00,0xFE,0x37,
+0x0E,0xF0,0x42,0x34,
+0x00,0x00,0xC0,0xA6,
+0x00,0x00,0xC2,0xAF,
+0x1C,0x00,0xA3,0x8F,
+0x00,0x00,0x00,0x00,
+0x09,0x00,0x60,0x10,
+0x44,0x00,0xF7,0x37,
+0x00,0x00,0xE2,0x8E,
+0x00,0x02,0x03,0x3C,
+0x25,0x10,0x43,0x00,
+0x00,0x00,0xE2,0xAE,
+0x00,0x00,0xC3,0x8F,
+0x00,0x04,0x02,0x3C,
+0x25,0x18,0x62,0x00,
+0x00,0x00,0xC3,0xAF,
+0x4C,0x00,0xE2,0x37,
+0x00,0x00,0x40,0xA0,
+0x4D,0x00,0xE3,0x37,
+0xF1,0x02,0xE4,0x37,
+0x08,0x00,0x02,0x24,
+0x00,0x00,0x60,0xA0,
+0x40,0x00,0xE6,0x37,
+0x00,0x00,0x82,0xA0,
+0x64,0x03,0xE5,0x37,
+0xBC,0x00,0x03,0x24,
+0xFC,0x37,0x02,0x24,
+0x00,0x00,0xC3,0xA4,
+0x00,0x00,0xA0,0xA0,
+0x00,0x00,0xC2,0xA4,
+0x02,0x80,0x02,0x3C,
+0xD8,0x00,0xE9,0x37,
+0x30,0x1F,0x43,0x24,
+0x00,0x00,0x26,0x91,
+0xAA,0x1B,0x64,0x90,
+0x2A,0xB0,0x05,0x3C,
+0xA0,0xFF,0x02,0x24,
+0x26,0xB0,0x07,0x3C,
+0x25,0x30,0xC2,0x00,
+0x30,0x00,0xAD,0x34,
+0x34,0x00,0xA8,0x34,
+0x01,0x00,0x83,0x24,
+0x38,0x00,0xA5,0x34,
+0x20,0x20,0x02,0x24,
+0x00,0x00,0x26,0xA1,
+0x79,0x00,0xEA,0x34,
+0x00,0x00,0x03,0xA1,
+0x00,0x00,0xA2,0xA4,
+0x40,0x00,0x03,0x24,
+0x16,0x00,0x02,0x24,
+0x00,0x00,0xA3,0xA1,
+0x94,0x00,0xEB,0x37,
+0x00,0x00,0x42,0xA1,
+0x98,0x00,0xEC,0x37,
+0x64,0x00,0x03,0x24,
+0x22,0x00,0x02,0x24,
+0x00,0x00,0x63,0xA5,
+0x7C,0x00,0xF4,0x34,
+0x00,0x00,0x82,0xA5,
+0x7A,0x00,0xE7,0x34,
+0x04,0x00,0x03,0x24,
+0x20,0x0C,0x02,0x24,
+0x00,0x00,0xE3,0xA0,
+0x9C,0x00,0xEE,0x37,
+0x00,0x00,0x82,0xA6,
+0x9A,0x00,0xEF,0x37,
+0x0A,0x00,0x03,0x24,
+0xFF,0x03,0x02,0x24,
+0x00,0x00,0xC3,0xA1,
+0x00,0x00,0xE2,0xA5,
+0x25,0xB0,0x02,0x3C,
+0x02,0x00,0x03,0x24,
+0x96,0x00,0x42,0x34,
+0x00,0x00,0x43,0xA4,
+0x89,0x00,0xF5,0x37,
+0xB7,0x00,0xF1,0x37,
+0x20,0x00,0x02,0x24,
+0x09,0x00,0x03,0x24,
+0x00,0x00,0x22,0xA2,
+0x00,0x00,0xA3,0xA2,
+0x00,0x00,0xE2,0x96,
+0xFF,0xFD,0x03,0x24,
+0x04,0x02,0x05,0x24,
+0x24,0x10,0x43,0x00,
+0x00,0x00,0xE2,0xA6,
+0x00,0x00,0xE3,0x96,
+0x29,0xB0,0x02,0x3C,
+0x40,0x00,0x42,0x34,
+0x00,0x02,0x63,0x34,
+0x00,0x00,0xE3,0xA6,
+0xFF,0x00,0x84,0x30,
+0x00,0x00,0x45,0xA4,
+0x73,0x22,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0xBF,0x8F,
+0x40,0x00,0xBE,0x8F,
+0x3C,0x00,0xB7,0x8F,
+0x38,0x00,0xB6,0x8F,
+0x34,0x00,0xB5,0x8F,
+0x30,0x00,0xB4,0x8F,
+0x2C,0x00,0xB3,0x8F,
+0x28,0x00,0xB2,0x8F,
+0x24,0x00,0xB1,0x8F,
+0x20,0x00,0xB0,0x8F,
+0x01,0x00,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x48,0x00,0xBD,0x27,
+0xFF,0xFF,0x03,0x24,
+0x00,0x00,0x43,0xA0,
+0x02,0x80,0x0B,0x3C,
+0xDE,0x5D,0x66,0x91,
+0x25,0xB0,0x09,0x3C,
+0x80,0x00,0x02,0x24,
+0x34,0x02,0x24,0x35,
+0x00,0x00,0x82,0xA4,
+0x37,0x02,0x25,0x35,
+0x53,0x00,0x03,0x24,
+0x22,0x00,0x02,0x24,
+0x00,0x00,0xA3,0xA0,
+0x1E,0xFF,0xC2,0x14,
+0x13,0x13,0x02,0x3C,
+0x1B,0x1B,0x02,0x3C,
+0x1B,0x1B,0x42,0x34,
+0x60,0x01,0x23,0x35,
+0x64,0x01,0x24,0x35,
+0x68,0x01,0x25,0x35,
+0x7C,0x01,0x2A,0x35,
+0x6C,0x01,0x26,0x35,
+0x70,0x01,0x27,0x35,
+0x74,0x01,0x28,0x35,
+0x78,0x01,0x29,0x35,
+0x00,0x00,0x62,0xAC,
+0x00,0x00,0x82,0xAC,
+0x00,0x00,0xA2,0xAC,
+0x00,0x00,0xC2,0xAC,
+0x00,0x00,0xE2,0xAC,
+0x00,0x00,0x02,0xAD,
+0x00,0x00,0x22,0xAD,
+0x00,0x00,0x42,0xAD,
+0xDE,0x5D,0x65,0x91,
+0x25,0xB0,0x0C,0x3C,
+0x01,0x00,0x03,0x3C,
+0x80,0x01,0x82,0x35,
+0x08,0x5F,0x63,0x34,
+0x22,0x00,0x04,0x24,
+0x00,0x00,0x43,0xAC,
+0x1D,0xFF,0xA4,0x14,
+0x0F,0x1F,0x02,0x3C,
+0x00,0xF0,0x4F,0x34,
+0xF7,0x01,0x91,0x35,
+0x15,0xF0,0x4D,0x34,
+0x78,0x67,0x00,0x08,
+0xFF,0xFF,0x0E,0x24,
+0x02,0x80,0x02,0x3C,
+0xDF,0x5D,0x44,0x90,
+0x06,0x00,0x03,0x24,
+0x0C,0x00,0x83,0x10,
+0x00,0x1C,0x02,0x3C,
+0x00,0x1C,0x42,0x34,
+0xA0,0x00,0x24,0x36,
+0x00,0x00,0x82,0xAC,
+0x00,0xE0,0x02,0x3C,
+0xA4,0x00,0x25,0x36,
+0x00,0x04,0x03,0x24,
+0xA8,0x00,0x26,0x36,
+0x00,0xB0,0x42,0x34,
+0x00,0x00,0xA3,0xAC,
+0xDA,0x66,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x16,0x16,0x02,0x3C,
+0x07,0x07,0x42,0x34,
+0xA0,0x00,0x23,0x36,
+0x00,0x00,0x62,0xAC,
+0x00,0xC0,0x02,0x3C,
+0xA8,0x00,0x25,0x36,
+0xA4,0x00,0x24,0x36,
+0x00,0xB4,0x42,0x34,
+0x00,0x00,0x80,0xAC,
+0x00,0x00,0xA2,0xAC,
+0xDC,0x66,0x00,0x08,
+0x02,0x80,0x03,0x3C,
+0xE8,0xFF,0xBD,0x27,
+0x01,0x00,0x06,0x24,
+0xE8,0x0E,0x04,0x24,
+0x10,0x00,0xBF,0xAF,
+0xA9,0x45,0x00,0x0C,
+0x00,0x10,0x05,0x3C,
+0x60,0x08,0x04,0x24,
+0xCB,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x20,0x04,0x06,0x3C,
+0x20,0x04,0xC6,0x34,
+0x25,0x30,0x46,0x00,
+0x60,0x08,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x70,0x08,0x04,0x24,
+0x00,0x04,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x00,0x20,0x06,0x3C,
+0x80,0x00,0xC6,0x34,
+0x80,0x0C,0x04,0x24,
+0xA9,0x45,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0x00,0x40,0x06,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x00,0x01,0xC6,0x34,
+0x88,0x0C,0x04,0x24,
+0xFF,0xFF,0x05,0x24,
+0xA9,0x45,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x10,0x00,0xA0,0x10,
+0x21,0x38,0x00,0x00,
+0x25,0xB0,0x08,0x3C,
+0x00,0x00,0x82,0x8C,
+0x04,0x00,0x83,0x8C,
+0x21,0x30,0x00,0x00,
+0x21,0x10,0x48,0x00,
+0x00,0x00,0x43,0xAC,
+0x01,0x00,0xC2,0x24,
+0xFF,0x00,0x46,0x30,
+0x06,0x00,0xC3,0x2C,
+0xFD,0xFF,0x60,0x14,
+0x01,0x00,0xC2,0x24,
+0x02,0x00,0xE7,0x24,
+0x2B,0x10,0xE5,0x00,
+0xF3,0xFF,0x40,0x14,
+0x08,0x00,0x84,0x24,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x1C,0x00,0xBF,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x21,0x90,0xA0,0x00,
+0x0B,0x00,0xA0,0x10,
+0x21,0x88,0x00,0x00,
+0x21,0x80,0x80,0x00,
+0x00,0x00,0x04,0x8E,
+0x04,0x00,0x05,0x8E,
+0x08,0x00,0x06,0x8E,
+0x03,0x00,0x31,0x26,
+0xA9,0x45,0x00,0x0C,
+0x0C,0x00,0x10,0x26,
+0x2B,0x10,0x32,0x02,
+0xF8,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x21,0x40,0x80,0x00,
+0x21,0x48,0x00,0x00,
+0x1E,0x00,0xA0,0x10,
+0x21,0x38,0x00,0x00,
+0x80,0x30,0x07,0x00,
+0x21,0x10,0xC8,0x00,
+0x00,0x00,0x43,0x8C,
+0x00,0x00,0x00,0x00,
+0x00,0xF2,0x63,0x24,
+0x1D,0x00,0x62,0x2C,
+0x12,0x00,0x40,0x10,
+0x80,0x10,0x03,0x00,
+0x02,0x80,0x03,0x3C,
+0x64,0xE9,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x8C,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0x80,0x00,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x23,0x18,0x69,0x00,
+0x08,0x00,0x44,0x8C,
+0x02,0x80,0x02,0x3C,
+0x80,0x18,0x03,0x00,
+0x30,0x1F,0x42,0x24,
+0x21,0x18,0x62,0x00,
+0x04,0x1D,0x64,0xAC,
+0x01,0x00,0x29,0x25,
+0x03,0x00,0xE7,0x24,
+0x2B,0x10,0xE5,0x00,
+0xE5,0xFF,0x40,0x14,
+0x80,0x30,0x07,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xD6,0xFF,0x40,0x14,
+0x00,0x1D,0x64,0xAC,
+0xE0,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xC8,0xFF,0x40,0x14,
+0xFC,0x1C,0x64,0xAC,
+0xE0,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xBA,0xFF,0x40,0x14,
+0xF8,0x1C,0x64,0xAC,
+0xE0,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0xAC,0xFF,0x40,0x14,
+0x08,0x1D,0x64,0xAC,
+0xE0,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0x9E,0xFF,0x40,0x14,
+0xF4,0x1C,0x64,0xAC,
+0xE0,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x21,0x10,0xC8,0x00,
+0xC0,0x18,0x09,0x00,
+0x08,0x00,0x44,0x8C,
+0x23,0x18,0x69,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x80,0x18,0x03,0x00,
+0x03,0x00,0xE7,0x24,
+0x21,0x18,0x62,0x00,
+0x2B,0x10,0xE5,0x00,
+0x90,0xFF,0x40,0x14,
+0xF0,0x1C,0x64,0xAC,
+0xE0,0x68,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x25,0xB0,0x02,0x3C,
+0xFC,0x37,0x03,0x24,
+0x40,0x00,0x42,0x34,
+0x02,0x80,0x04,0x3C,
+0x00,0x00,0x43,0xA4,
+0xE8,0xFF,0xBD,0x27,
+0xA4,0xCF,0x84,0x24,
+0x10,0x00,0xBF,0xAF,
+0x94,0x68,0x00,0x0C,
+0x74,0x01,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0xDE,0x5D,0x44,0x90,
+0x12,0x00,0x03,0x24,
+0x34,0x00,0x83,0x10,
+0x13,0x00,0x82,0x28,
+0x17,0x00,0x40,0x14,
+0x11,0x00,0x02,0x24,
+0x22,0x00,0x02,0x24,
+0x36,0x00,0x82,0x10,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x04,0x3C,
+0x2C,0xCC,0x84,0x24,
+0xBF,0x68,0x00,0x0C,
+0x54,0x00,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x4A,0xF3,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0x1A,0x00,0x83,0x10,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x2C,0xC7,0x84,0x24,
+0x94,0x68,0x00,0x0C,
+0x40,0x01,0x05,0x24,
+0x10,0x00,0xBF,0x8F,
+0x84,0x08,0x04,0x24,
+0xFF,0x00,0x05,0x24,
+0x58,0x00,0x06,0x24,
+0x1B,0x47,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xED,0xFF,0x82,0x14,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x04,0x3C,
+0xE4,0xCE,0x84,0x24,
+0xA7,0x68,0x00,0x0C,
+0x30,0x00,0x05,0x24,
+0x02,0x80,0x04,0x3C,
+0x2C,0xCC,0x84,0x24,
+0xBF,0x68,0x00,0x0C,
+0x54,0x00,0x05,0x24,
+0x02,0x80,0x02,0x3C,
+0x4A,0xF3,0x44,0x90,
+0x01,0x00,0x03,0x24,
+0xE8,0xFF,0x83,0x14,
+0x00,0x00,0x00,0x00,
+0x75,0x68,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x2C,0xC7,0x84,0x24,
+0x94,0x68,0x00,0x0C,
+0x40,0x01,0x05,0x24,
+0x10,0x00,0xBF,0x8F,
+0x84,0x08,0x04,0x24,
+0xFF,0x00,0x05,0x24,
+0x58,0x00,0x06,0x24,
+0x1B,0x47,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x04,0x3C,
+0x30,0xCE,0x84,0x24,
+0x2D,0x00,0x05,0x24,
+0xA7,0x68,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x64,0x69,0x00,0x08,
+0x02,0x80,0x04,0x3C,
+0x7C,0xCD,0x84,0x24,
+0x7B,0x69,0x00,0x08,
+0x2D,0x00,0x05,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xB0,0xAF,
+0x50,0x0C,0x04,0x24,
+0xFF,0x00,0x05,0x24,
+0x02,0x80,0x10,0x3C,
+0x14,0x00,0xBF,0xAF,
+0x0A,0x47,0x00,0x0C,
+0x30,0x1F,0x10,0x26,
+0x60,0x1D,0x02,0xA2,
+0x58,0x0C,0x04,0x24,
+0x0A,0x47,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x61,0x1D,0x02,0xA2,
+0x60,0x0C,0x04,0x24,
+0x0A,0x47,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x62,0x1D,0x02,0xA2,
+0x68,0x0C,0x04,0x24,
+0x0A,0x47,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0x63,0x1D,0x02,0xA2,
+0x38,0x0C,0x04,0x24,
+0x0A,0x47,0x00,0x0C,
+0xFF,0x00,0x05,0x24,
+0xE8,0x1C,0x02,0xA2,
+0x34,0x0C,0x04,0x24,
+0x0A,0x47,0x00,0x0C,
+0xFF,0xFF,0x05,0x24,
+0xEC,0x1C,0x02,0xAE,
+0x14,0x00,0xBF,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x03,0x3C,
+0x84,0xA7,0x42,0x24,
+0xBC,0x5E,0x60,0xAC,
+0x1C,0x5E,0xA2,0xAC,
+0x02,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0xC0,0x5E,0x60,0xA4,
+0x1C,0x5E,0xA4,0x24,
+0x88,0x0D,0x42,0x24,
+0x02,0x80,0x03,0x3C,
+0xC2,0x5E,0x60,0xA4,
+0x08,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x02,0x80,0x06,0x3C,
+0x88,0x10,0x42,0x24,
+0xA4,0x0D,0x63,0x24,
+0xC4,0x5E,0xC7,0x24,
+0x14,0x00,0x82,0xAC,
+0x10,0x00,0x83,0xAC,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xC4,0x5E,0xC0,0xAC,
+0x04,0x00,0xE0,0xAC,
+0xCC,0x5E,0x40,0xA0,
+0xD0,0x5E,0x60,0xAC,
+0x01,0x80,0x02,0x3C,
+0x30,0xD2,0x42,0x24,
+0x7C,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0xA4,0x10,0x63,0x24,
+0x64,0x13,0x42,0x24,
+0x1C,0x00,0x83,0xAC,
+0x20,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x2C,0x16,0x63,0x24,
+0xF0,0x18,0x42,0x24,
+0x24,0x00,0x83,0xAC,
+0x28,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x01,0x80,0x02,0x3C,
+0xC8,0x2A,0x63,0x24,
+0x98,0x01,0x42,0x24,
+0x2C,0x00,0x83,0xAC,
+0x50,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x10,0x1C,0x63,0x24,
+0xFC,0x1D,0x42,0x24,
+0x30,0x00,0x83,0xAC,
+0x38,0x00,0x82,0xAC,
+0x00,0x80,0x03,0x3C,
+0x00,0x80,0x02,0x3C,
+0x00,0x03,0x63,0x24,
+0xB4,0x1B,0x42,0x24,
+0x4C,0x00,0x83,0xAC,
+0x08,0x00,0xE0,0x03,
+0x3C,0x00,0x82,0xAC,
+0x25,0xB0,0x02,0x3C,
+0x08,0x00,0x42,0x34,
+0x00,0x00,0x43,0x8C,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x0E,0x3C,
+0x02,0x80,0x08,0x3C,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0xF8,0x03,0x4D,0x24,
+0x00,0x1C,0x6C,0x24,
+0x01,0x00,0x07,0x24,
+0x00,0x00,0xCB,0x25,
+0xFF,0xFF,0x0A,0x24,
+0x00,0x04,0x09,0x25,
+0x80,0x1A,0x07,0x00,
+0x21,0x10,0x6B,0x00,
+0x00,0x00,0x42,0xAC,
+0x90,0x00,0x4A,0xAC,
+0x00,0x04,0x04,0x8D,
+0x01,0x00,0xE7,0x24,
+0x08,0x00,0x45,0x24,
+0x21,0x18,0x6D,0x00,
+0x07,0x00,0xE6,0x28,
+0x04,0x00,0x82,0xAC,
+0x00,0x00,0x44,0xAC,
+0x04,0x00,0x49,0xAC,
+0x00,0x04,0x02,0xAD,
+0x8C,0x00,0x40,0xAC,
+0x6C,0x00,0xA3,0xAC,
+0xF0,0xFF,0xC0,0x14,
+0x68,0x00,0xAC,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0xC9,0xAD,
+0x07,0x00,0xA2,0x2C,
+0x13,0x00,0x40,0x10,
+0xFF,0xFF,0x07,0x24,
+0x02,0x80,0x02,0x3C,
+0x80,0x1A,0x05,0x00,
+0x00,0x00,0x42,0x24,
+0x0E,0x00,0xA0,0x10,
+0x21,0x30,0x62,0x00,
+0x90,0x00,0xC3,0x8C,
+0xFF,0xFF,0x02,0x24,
+0x0A,0x00,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x8C,0x00,0xC2,0x8C,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x02,0x24,
+0x88,0x00,0xC4,0xAC,
+0x8C,0x00,0xC2,0xAC,
+0x90,0x00,0xC5,0xAC,
+0x21,0x38,0xA0,0x00,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0xE0,0x00,
+0x25,0xB0,0x06,0x3C,
+0x02,0x80,0x02,0x3C,
+0xE0,0xFF,0xBD,0x27,
+0x68,0xA8,0x42,0x24,
+0xDB,0xFF,0x03,0x24,
+0x18,0x03,0xC4,0x34,
+0x27,0x00,0xC5,0x34,
+0x00,0x00,0x82,0xAC,
+0x1C,0x00,0xBF,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x00,0x00,0xA3,0xA0,
+0x06,0x00,0xC2,0x34,
+0x00,0x00,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x0F,0x00,0x63,0x30,
+0x5A,0x00,0x60,0x14,
+0x01,0x00,0x02,0x24,
+0x1B,0x00,0xC3,0x34,
+0x07,0x00,0x02,0x24,
+0x00,0x00,0x62,0xA0,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x50,0x24,
+0x34,0x1C,0x04,0x8E,
+0xCB,0x45,0x00,0x0C,
+0x10,0x00,0x05,0x24,
+0x40,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x3C,
+0x01,0x00,0x06,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x3C,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x58,0x1C,0x04,0x8E,
+0x00,0x04,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x58,0x1C,0x04,0x8E,
+0x00,0x08,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0xEC,0xD9,0xA5,0x24,
+0x21,0x20,0x00,0x00,
+0x9F,0x47,0x00,0x0C,
+0xCA,0x00,0x06,0x24,
+0x31,0x00,0x40,0x10,
+0x21,0x18,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0xE7,0x5D,0x43,0x90,
+0x01,0x00,0x11,0x24,
+0x57,0x00,0x71,0x10,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x02,0x3C,
+0x4A,0xF3,0x43,0x90,
+0x00,0x00,0x00,0x00,
+0x58,0x00,0x71,0x10,
+0x02,0x80,0x05,0x3C,
+0x34,0x1C,0x04,0x8E,
+0x21,0x30,0x40,0x02,
+0x10,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x02,0x80,0x11,0x3C,
+0xDE,0x5D,0x23,0x92,
+0x11,0x00,0x02,0x24,
+0x2E,0x00,0x62,0x10,
+0x00,0x08,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x01,0x00,0x04,0x24,
+0x34,0x1C,0x04,0x8E,
+0xCB,0x45,0x00,0x0C,
+0x10,0x00,0x05,0x3C,
+0x40,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x3C,
+0x01,0x00,0x06,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x90,0x40,0x00,
+0x3C,0x1C,0x04,0x8E,
+0x10,0x00,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x58,0x1C,0x04,0x8E,
+0x00,0x04,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x58,0x1C,0x04,0x8E,
+0x00,0x08,0x05,0x24,
+0xA9,0x45,0x00,0x0C,
+0x21,0x30,0x00,0x00,
+0x02,0x80,0x05,0x3C,
+0x94,0xD9,0xA5,0x24,
+0x01,0x00,0x04,0x24,
+0x9F,0x47,0x00,0x0C,
+0x16,0x00,0x06,0x24,
+0x0C,0x00,0x40,0x14,
+0x21,0x18,0x00,0x00,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xA9,0xFF,0x62,0x14,
+0x1F,0x00,0xC3,0x34,
+0x2F,0x6A,0x00,0x08,
+0x07,0x00,0x02,0x24,
+0x34,0x1C,0x04,0x8E,
+0x21,0x30,0x40,0x02,
+0xA9,0x45,0x00,0x0C,
+0x10,0x00,0x05,0x3C,
+0x00,0x08,0x04,0x24,
+0x00,0x01,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0x00,0x08,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x01,0x00,0x06,0x24,
+0xDE,0x5D,0x23,0x92,
+0x11,0x00,0x02,0x24,
+0x1D,0x00,0x62,0x10,
+0x00,0x08,0x04,0x24,
+0xE6,0x44,0x00,0x0C,
+0x21,0x20,0x00,0x00,
+0x0F,0x00,0x05,0x3C,
+0x0C,0x00,0x06,0x3C,
+0xFF,0xFF,0xA5,0x34,
+0x00,0xB4,0xC6,0x34,
+0x5F,0x47,0x00,0x0C,
+0x08,0x00,0x04,0x24,
+0x1C,0x00,0xBF,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x01,0x00,0x03,0x24,
+0x21,0x10,0x60,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x84,0xD8,0xA5,0x24,
+0x21,0x20,0x00,0x00,
+0x9F,0x47,0x00,0x0C,
+0x16,0x00,0x06,0x24,
+0x55,0x6A,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0xDC,0xD8,0xA5,0x24,
+0x21,0x20,0x00,0x00,
+0x9F,0x47,0x00,0x0C,
+0x16,0x00,0x06,0x24,
+0x59,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0xFF,0x05,0x3C,
+0xA9,0x45,0x00,0x0C,
+0x03,0x00,0x06,0x24,
+0x9A,0x6A,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x02,0x80,0x02,0x3C,
+0x61,0x5A,0x47,0x90,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x03,0x00,0x03,0x24,
+0x1E,0x3B,0x84,0x24,
+0xAC,0xE3,0xA5,0x24,
+0x0F,0x00,0xE3,0x10,
+0x0D,0x00,0x06,0x24,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x1E,0x3B,0x84,0x24,
+0x5C,0xE3,0xA5,0x24,
+0x10,0x52,0x00,0x0C,
+0x0D,0x00,0x06,0x24,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x2B,0x3B,0x84,0x24,
+0x6C,0xE3,0xA5,0x24,
+0x0D,0x00,0x06,0x24,
+0x10,0x52,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x10,0x52,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0x10,0x00,0xBF,0x8F,
+0x2B,0x3B,0x84,0x24,
+0x9C,0xE3,0xA5,0x24,
+0x0D,0x00,0x06,0x24,
+0x10,0x52,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x02,0x80,0x11,0x3C,
+0x02,0x80,0x05,0x3C,
+0x02,0x80,0x10,0x3C,
+0x30,0x1F,0x10,0x26,
+0x64,0x5A,0x24,0x26,
+0x14,0xDD,0xA5,0x24,
+0x34,0x00,0x06,0x24,
+0x18,0x00,0xBF,0xAF,
+0x10,0x52,0x00,0x0C,
+0x64,0x5A,0x31,0x26,
+0xBD,0x6A,0x00,0x0C,
+0x68,0x3B,0x11,0xAE,
+0x02,0x00,0x11,0x24,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0xA0,0x38,0x11,0xA2,
+0xBC,0x57,0x84,0x24,
+0xFC,0x64,0xC6,0x24,
+0x21,0x28,0x00,0x00,
+0xA2,0x23,0x00,0x0C,
+0x98,0x38,0x00,0xAE,
+0x02,0x80,0x04,0x3C,
+0x01,0x80,0x06,0x3C,
+0xBC,0x38,0x11,0xA2,
+0xD8,0x57,0x84,0x24,
+0x0C,0x31,0xC6,0x24,
+0x21,0x28,0x00,0x00,
+0xA2,0x23,0x00,0x0C,
+0xB4,0x38,0x00,0xAE,
+0x02,0x80,0x04,0x3C,
+0x01,0x80,0x06,0x3C,
+0xD8,0x38,0x11,0xA2,
+0xF4,0x57,0x84,0x24,
+0xC0,0x2E,0xC6,0x24,
+0x21,0x28,0x00,0x00,
+0xA2,0x23,0x00,0x0C,
+0xD0,0x38,0x00,0xAE,
+0x02,0x80,0x04,0x3C,
+0x01,0x80,0x06,0x3C,
+0xF4,0x38,0x11,0xA2,
+0x10,0x58,0x84,0x24,
+0x14,0x25,0xC6,0x24,
+0x21,0x28,0x00,0x00,
+0xA2,0x23,0x00,0x0C,
+0xEC,0x38,0x00,0xAE,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0x10,0x39,0x11,0xA2,
+0x2C,0x58,0x84,0x24,
+0x58,0x64,0xC6,0x24,
+0x21,0x28,0x00,0x00,
+0xA2,0x23,0x00,0x0C,
+0x08,0x39,0x00,0xAE,
+0x02,0x80,0x04,0x3C,
+0x00,0x80,0x06,0x3C,
+0x48,0x39,0x11,0xA2,
+0x40,0x39,0x00,0xAE,
+0x64,0x58,0x84,0x24,
+0x38,0x3B,0xC6,0x24,
+0xA2,0x23,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x02,0x80,0x02,0x3C,
+0x49,0xF3,0x43,0x90,
+0x18,0x00,0xBF,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x9C,0x3E,0x03,0xA2,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x03,0x80,0x05,0x3C,
+0x00,0x80,0xA5,0x24,
+0x40,0x10,0x0D,0x3C,
+0xFF,0xFF,0xA5,0x30,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x42,0x24,
+0x25,0xC8,0xAD,0x00,
+0x38,0x37,0x59,0xAC,
+0x00,0x01,0x39,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x44,0x37,0x59,0xAC,
+0x00,0x01,0x39,0x27,
+0x1C,0x00,0xB7,0xAF,
+0x18,0x00,0xB6,0xAF,
+0x14,0x00,0xB5,0xAF,
+0x10,0x00,0xB4,0xAF,
+0x0C,0x00,0xB3,0xAF,
+0x08,0x00,0xB2,0xAF,
+0x04,0x00,0xB1,0xAF,
+0x00,0x00,0xB0,0xAF,
+0x50,0x37,0x59,0xAC,
+0x00,0x01,0x39,0x27,
+0x5C,0x37,0x59,0xAC,
+0xAA,0x1B,0x44,0x90,
+0x00,0x01,0x39,0x27,
+0x68,0x37,0x59,0xAC,
+0x00,0x01,0x39,0x27,
+0x74,0x37,0x59,0xAC,
+0x20,0xB0,0x06,0x3C,
+0x44,0x37,0x48,0x8C,
+0x50,0x37,0x49,0x8C,
+0x5C,0x37,0x4A,0x8C,
+0x68,0x37,0x4B,0x8C,
+0x74,0x37,0x4C,0x8C,
+0x00,0x22,0x04,0x00,
+0x00,0x01,0xC7,0x34,
+0xFF,0x1F,0x03,0x3C,
+0x00,0x01,0x39,0x27,
+0xFF,0xFF,0x63,0x34,
+0x21,0x38,0x87,0x00,
+0x21,0x20,0x86,0x00,
+0x24,0x38,0xE3,0x00,
+0x20,0x10,0x06,0x3C,
+0x24,0x20,0x83,0x00,
+0x80,0x37,0x59,0xAC,
+0x21,0x78,0x20,0x03,
+0x25,0x28,0xAD,0x00,
+0x25,0xB0,0x0E,0x3C,
+0x00,0x01,0x39,0x27,
+0x34,0x37,0x45,0xAC,
+0x40,0x37,0x48,0xAC,
+0x4C,0x37,0x49,0xAC,
+0x58,0x37,0x4A,0xAC,
+0xF8,0x36,0x44,0xAC,
+0x64,0x37,0x4B,0xAC,
+0x04,0x37,0x47,0xAC,
+0x70,0x37,0x4C,0xAC,
+0xAC,0x00,0xC3,0x35,
+0xCC,0x36,0x46,0xAC,
+0xC8,0x36,0x46,0xAC,
+0xD8,0x36,0x46,0xAC,
+0xD4,0x36,0x46,0xAC,
+0xE4,0x36,0x46,0xAC,
+0x8C,0x37,0x59,0xAC,
+0xFC,0x36,0x44,0xAC,
+0x08,0x37,0x47,0xAC,
+0x7C,0x37,0x4F,0xAC,
+0xE0,0x36,0x46,0xAC,
+0xF0,0x36,0x46,0xAC,
+0xEC,0x36,0x46,0xAC,
+0x14,0x37,0x46,0xAC,
+0x10,0x37,0x46,0xAC,
+0x00,0x02,0x39,0x27,
+0x00,0x00,0x68,0x8C,
+0xAC,0x1B,0x47,0x94,
+0xA4,0x37,0x59,0xAC,
+0xB0,0x00,0xC3,0x35,
+0x00,0x00,0x75,0x8C,
+0x21,0x10,0x05,0x3C,
+0x8C,0x37,0x52,0x8C,
+0x23,0x10,0x0B,0x3C,
+0x22,0x10,0x0F,0x3C,
+0x02,0x80,0x14,0x3C,
+0x02,0x80,0x16,0x3C,
+0x02,0x80,0x17,0x3C,
+0x02,0x80,0x18,0x3C,
+0x00,0x80,0xA4,0x34,
+0x21,0x98,0x20,0x03,
+0x23,0x20,0x87,0x00,
+0x00,0x04,0x39,0x27,
+0x24,0x10,0x07,0x3C,
+0x9C,0x57,0x8A,0x26,
+0xA4,0x57,0xC9,0x26,
+0xAC,0x57,0xEC,0x26,
+0xB4,0x57,0x0D,0x27,
+0x00,0x04,0x70,0x35,
+0x01,0x00,0x08,0x25,
+0x00,0x40,0xF1,0x35,
+0x00,0x01,0xCE,0x35,
+0x01,0x00,0x03,0x24,
+0x88,0x37,0x52,0xAC,
+0x91,0x37,0x43,0xA0,
+0xA0,0x37,0x53,0xAC,
+0x08,0x38,0x50,0xAC,
+0xCC,0x37,0x48,0xAC,
+0xD8,0x37,0x44,0xAC,
+0xFC,0x37,0x51,0xAC,
+0xF0,0x37,0x55,0xAC,
+0x00,0x00,0xC7,0xAD,
+0xEC,0x37,0x47,0xAC,
+0x0C,0x38,0x46,0xAC,
+0x20,0x37,0x46,0xAC,
+0x1C,0x37,0x46,0xAC,
+0xAA,0x37,0x40,0xA4,
+0xA9,0x37,0x40,0xA0,
+0xA8,0x37,0x40,0xA0,
+0x00,0x38,0x4B,0xAC,
+0x04,0x38,0x4B,0xAC,
+0xC4,0x37,0x45,0xAC,
+0xC8,0x37,0x45,0xAC,
+0xD0,0x37,0x45,0xAC,
+0xD4,0x37,0x45,0xAC,
+0xF4,0x37,0x4F,0xAC,
+0xF8,0x37,0x4F,0xAC,
+0xE8,0x37,0x47,0xAC,
+0x10,0x38,0x46,0xAC,
+0x1C,0x38,0x59,0xAC,
+0x18,0x38,0x59,0xAC,
+0x04,0x00,0x4A,0xAD,
+0x9C,0x57,0x8A,0xAE,
+0x04,0x00,0x8C,0xAD,
+0xA4,0x57,0xC9,0xAE,
+0x04,0x00,0xAD,0xAD,
+0xAC,0x57,0xEC,0xAE,
+0xB4,0x57,0x0D,0xAF,
+0x04,0x00,0x29,0xAD,
+0x02,0x80,0x02,0x3C,
+0x00,0x1C,0x43,0x24,
+0x01,0x00,0x05,0x24,
+0x21,0x20,0x20,0x01,
+0x0F,0x00,0x06,0x24,
+0x21,0x10,0x80,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x08,0x00,0x79,0xAC,
+0x00,0x00,0x63,0xAC,
+0x10,0x00,0x65,0xAC,
+0x00,0x00,0x69,0xAC,
+0x21,0x20,0x60,0x00,
+0x04,0x00,0x62,0xAC,
+0x00,0x00,0x43,0xAC,
+0x00,0x01,0x39,0x27,
+0xF5,0xFF,0xC1,0x04,
+0x18,0x00,0x63,0x24,
+0x02,0x80,0x02,0x3C,
+0xAC,0x57,0x48,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x07,0x8D,
+0x80,0x1D,0x4B,0x24,
+0x04,0x00,0x24,0xAD,
+0x00,0x1C,0x6A,0x24,
+0x02,0x00,0x09,0x24,
+0x21,0x28,0x00,0x00,
+0x0F,0x00,0x06,0x24,
+0x21,0x20,0xAB,0x00,
+0x21,0x10,0xAA,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x88,0x01,0x59,0xAC,
+0x90,0x01,0x49,0xAC,
+0x18,0x00,0xA5,0x24,
+0x00,0x00,0x88,0xAC,
+0x04,0x00,0x87,0xAC,
+0x00,0x00,0xE4,0xAC,
+0x00,0x02,0x39,0x27,
+0xF5,0xFF,0xC1,0x04,
+0x21,0x38,0x80,0x00,
+0x02,0x80,0x02,0x3C,
+0xB4,0x57,0x49,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x27,0x8D,
+0x00,0x1F,0x4B,0x24,
+0x04,0x00,0x04,0xAD,
+0x00,0x1C,0x6A,0x24,
+0x03,0x00,0x08,0x24,
+0x21,0x28,0x00,0x00,
+0x01,0x00,0x06,0x24,
+0x21,0x20,0xAB,0x00,
+0x21,0x10,0xAA,0x00,
+0xFF,0xFF,0xC6,0x24,
+0x08,0x03,0x59,0xAC,
+0x10,0x03,0x48,0xAC,
+0x18,0x00,0xA5,0x24,
+0x00,0x00,0x89,0xAC,
+0x04,0x00,0x87,0xAC,
+0x00,0x00,0xE4,0xAC,
+0x00,0x08,0x39,0x27,
+0xF5,0xFF,0xC1,0x04,
+0x21,0x38,0x80,0x00,
+0x1C,0x00,0xB7,0x8F,
+0x18,0x00,0xB6,0x8F,
+0x14,0x00,0xB5,0x8F,
+0x10,0x00,0xB4,0x8F,
+0x0C,0x00,0xB3,0x8F,
+0x08,0x00,0xB2,0x8F,
+0x04,0x00,0xB1,0x8F,
+0x00,0x00,0xB0,0x8F,
+0x20,0x00,0xBD,0x27,
+0x08,0x00,0xE0,0x03,
+0x04,0x00,0x24,0xAD,
+0xD0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x20,0x00,0xB2,0xAF,
+0x02,0x80,0x03,0x3C,
+0x78,0xE8,0x52,0x24,
+0x02,0x80,0x02,0x3C,
+0x28,0x00,0xB4,0xAF,
+0x24,0x00,0xB3,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x2C,0x00,0xBF,0xAF,
+0x04,0xE8,0x73,0x24,
+0x30,0x1F,0x50,0x24,
+0x21,0x88,0x00,0x00,
+0x02,0x80,0x14,0x3C,
+0xDD,0x59,0x00,0x0C,
+0x21,0x20,0x20,0x02,
+0x1C,0x24,0x05,0x8E,
+0x6C,0x00,0x66,0x8E,
+0xE4,0xE7,0x82,0x26,
+0x6C,0x00,0x43,0x8E,
+0x1B,0x00,0x44,0x90,
+0xFF,0xF1,0x02,0x24,
+0x21,0x18,0x66,0x00,
+0x24,0x28,0xA2,0x00,
+0x00,0x21,0x04,0x00,
+0x42,0x18,0x03,0x00,
+0x00,0x02,0xA5,0x34,
+0xE8,0x23,0x03,0xAE,
+0x0C,0x24,0x04,0xAE,
+0x1C,0x24,0x05,0xAE,
+0x10,0x24,0x04,0xAE,
+0x21,0x30,0x00,0x00,
+0x21,0x10,0x06,0x02,
+0x01,0x00,0xC6,0x24,
+0x1D,0x00,0xC3,0x28,
+0x3D,0x24,0x40,0xA0,
+0x20,0x24,0x40,0xA0,
+0xFA,0xFF,0x60,0x14,
+0x5A,0x24,0x40,0xA0,
+0x01,0x00,0x31,0x26,
+0x20,0x00,0x22,0x2A,
+0x78,0x24,0x00,0xAE,
+0xE3,0xFF,0x40,0x14,
+0x94,0x00,0x10,0x26,
+0x02,0x80,0x02,0x3C,
+0x02,0x80,0x03,0x3C,
+0x30,0x1F,0x4B,0x24,
+0x02,0x80,0x02,0x3C,
+0x78,0xE8,0x6F,0x24,
+0x04,0xE8,0x4D,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xE4,0xE7,0x6E,0x24,
+0xC4,0xE7,0x4C,0x24,
+0x21,0x88,0x00,0x00,
+0x80,0x18,0x11,0x00,
+0x21,0x20,0x6D,0x00,
+0x21,0x10,0x6F,0x00,
+0x21,0x28,0x2E,0x02,
+0x21,0x30,0x2C,0x02,
+0x00,0x00,0x88,0x8C,
+0x00,0x00,0xA9,0x90,
+0x00,0x00,0xC7,0x90,
+0x00,0x00,0x4A,0x8C,
+0x21,0x10,0x2B,0x02,
+0x01,0x00,0x31,0x26,
+0x21,0x18,0x6B,0x00,
+0x1D,0x00,0x24,0x2A,
+0x60,0x05,0x68,0xAC,
+0x3E,0x05,0x47,0xA0,
+0xD4,0x05,0x6A,0xAC,
+0xEF,0xFF,0x80,0x14,
+0x04,0x05,0x49,0xA0,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x4A,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xA0,0xE6,0x6B,0x24,
+0x40,0xE5,0x4C,0x24,
+0x21,0x88,0x00,0x00,
+0x21,0x48,0x00,0x00,
+0x21,0x30,0x00,0x00,
+0x21,0x40,0x2A,0x01,
+0x21,0x38,0x2B,0x01,
+0x21,0x10,0xE6,0x00,
+0x91,0x00,0x44,0x90,
+0x00,0x00,0x45,0x90,
+0x21,0x18,0x06,0x01,
+0x01,0x00,0xC6,0x24,
+0x05,0x00,0xC2,0x28,
+0x39,0x04,0x64,0xA0,
+0xF8,0xFF,0x40,0x14,
+0xA8,0x03,0x65,0xA0,
+0x21,0x10,0x2C,0x02,
+0x1D,0x00,0x44,0x90,
+0x00,0x00,0x45,0x90,
+0x21,0x18,0x2A,0x02,
+0x01,0x00,0x31,0x26,
+0x1D,0x00,0x22,0x2A,
+0xE7,0x04,0x64,0xA0,
+0xCA,0x04,0x65,0xA0,
+0xEB,0xFF,0x40,0x14,
+0x05,0x00,0x29,0x25,
+0x52,0x00,0x02,0x24,
+0x10,0x00,0xA2,0xA3,
+0x41,0x00,0x03,0x24,
+0x4D,0x00,0x02,0x24,
+0x02,0x80,0x07,0x3C,
+0x64,0xF3,0xE7,0x24,
+0x11,0x00,0xA3,0xA3,
+0x12,0x00,0xA2,0xA3,
+0xE8,0x03,0x03,0x24,
+0x01,0x00,0x02,0x24,
+0x01,0x80,0x06,0x3C,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0xE0,0x00,
+0xDC,0x93,0xC6,0x24,
+0x0C,0x00,0xE3,0xAC,
+0x14,0x00,0xE2,0xA0,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x2C,0x00,0xBF,0x8F,
+0x28,0x00,0xB4,0x8F,
+0x24,0x00,0xB3,0x8F,
+0x20,0x00,0xB2,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x30,0x00,0xBD,0x27,
+0x90,0xFF,0xBD,0x27,
+0x48,0x00,0xB0,0xAF,
+0x25,0xB0,0x10,0x3C,
+0x6C,0x00,0xBF,0xAF,
+0x68,0x00,0xBE,0xAF,
+0x64,0x00,0xB7,0xAF,
+0x58,0x00,0xB4,0xAF,
+0x54,0x00,0xB3,0xAF,
+0x50,0x00,0xB2,0xAF,
+0x4C,0x00,0xB1,0xAF,
+0x60,0x00,0xB6,0xAF,
+0x5C,0x00,0xB5,0xAF,
+0xE0,0x0E,0x02,0x36,
+0x21,0x20,0x40,0x00,
+0x00,0x00,0x42,0x8C,
+0xDC,0x0E,0x12,0x36,
+0x70,0x0E,0x13,0x36,
+0x10,0x00,0xA2,0xAF,
+0x00,0x00,0x42,0x8E,
+0x78,0x0E,0x1E,0x36,
+0x7C,0x0E,0x14,0x36,
+0x14,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8E,
+0x25,0xB0,0x02,0x3C,
+0x74,0x0E,0x42,0x34,
+0x18,0x00,0xA3,0xAF,
+0x00,0x00,0x42,0x8C,
+0xD4,0x0E,0x10,0x36,
+0xED,0x3F,0x11,0x3C,
+0x1C,0x00,0xA2,0xAF,
+0x00,0x00,0xC3,0x8F,
+0xFB,0x92,0x25,0x36,
+0x25,0xB0,0x17,0x3C,
+0x20,0x00,0xA3,0xAF,
+0x00,0x00,0x82,0x8E,
+0x25,0xB0,0x03,0x3C,
+0x80,0x0E,0x63,0x34,
+0x24,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8C,
+0x25,0xB0,0x02,0x3C,
+0x84,0x0E,0x42,0x34,
+0x28,0x00,0xA3,0xAF,
+0x00,0x00,0x42,0x8C,
+0x25,0xB0,0x03,0x3C,
+0x88,0x0E,0x63,0x34,
+0x2C,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8C,
+0x25,0xB0,0x02,0x3C,
+0x8C,0x0E,0x42,0x34,
+0x30,0x00,0xA3,0xAF,
+0x00,0x00,0x42,0x8C,
+0x25,0xB0,0x03,0x3C,
+0xD0,0x0E,0x63,0x34,
+0x34,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8C,
+0x00,0x00,0x00,0x00,
+0x38,0x00,0xA3,0xAF,
+0x00,0x00,0x02,0x8E,
+0x25,0xB0,0x03,0x3C,
+0xD8,0x0E,0x63,0x34,
+0x3C,0x00,0xA2,0xAF,
+0x00,0x00,0x63,0x8C,
+0x02,0x5C,0x00,0x0C,
+0x40,0x00,0xA3,0xAF,
+0x21,0x20,0x40,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x21,0x20,0x60,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x02,0x80,0x05,0x3C,
+0xC0,0xED,0xA5,0x24,
+0x00,0x00,0xA4,0x8C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x13,0x3C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x21,0x20,0xC0,0x03,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x21,0x20,0x80,0x02,
+0x02,0x80,0x02,0x3C,
+0xC4,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0xA0,0x00,0x12,0x3C,
+0x02,0x80,0x03,0x3C,
+0xC8,0xED,0x63,0x24,
+0x00,0x00,0x64,0x8C,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x02,0x80,0x05,0x3C,
+0xCC,0xED,0xA5,0x24,
+0x00,0x00,0xA4,0x8C,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x02,0x80,0x02,0x3C,
+0xD0,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x02,0x80,0x03,0x3C,
+0xD4,0xED,0x63,0x24,
+0x00,0x00,0x64,0x8C,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x21,0x20,0x00,0x02,
+0x02,0x5C,0x00,0x0C,
+0xFB,0x92,0x25,0x36,
+0x02,0x80,0x05,0x3C,
+0xD8,0xED,0xA5,0x24,
+0x00,0x00,0xA4,0x8C,
+0xFB,0x92,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x21,0x80,0x00,0x00,
+0x14,0x02,0x11,0x3C,
+0x20,0x08,0xE4,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x65,0x36,
+0x28,0x08,0xE4,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x65,0x36,
+0x30,0x54,0x45,0x36,
+0x02,0x5C,0x00,0x0C,
+0x04,0x0C,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x08,0x00,0x05,0x3C,
+0xE4,0x00,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x08,0x0C,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x80,0x80,0x05,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x28,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x02,0x01,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x40,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x16,0x68,0x05,0x3C,
+0xC2,0x04,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x44,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0xD1,0x28,0x05,0x24,
+0x02,0x5C,0x00,0x0C,
+0x4C,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x02,0x01,0x25,0x36,
+0x02,0x5C,0x00,0x0C,
+0x60,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x16,0x28,0x05,0x3C,
+0x05,0x0D,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x64,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x00,0xFB,0x05,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x00,0xF8,0x05,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x25,0x22,0x00,0x0C,
+0x02,0x00,0x04,0x24,
+0x00,0x02,0x05,0x3C,
+0xD1,0x28,0xA5,0x34,
+0x02,0x5C,0x00,0x0C,
+0x6C,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x00,0xFB,0x05,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x00,0xF8,0x05,0x3C,
+0x02,0x5C,0x00,0x0C,
+0x48,0x0E,0xE4,0x36,
+0x25,0x22,0x00,0x0C,
+0x02,0x00,0x04,0x24,
+0x33,0x54,0x45,0x36,
+0x02,0x5C,0x00,0x0C,
+0x04,0x0C,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0xE4,0x00,0x05,0x24,
+0x02,0x5C,0x00,0x0C,
+0x08,0x0C,0xE4,0x36,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x28,0x0E,0xE4,0x36,
+0x02,0x5C,0x00,0x0C,
+0x21,0x28,0x00,0x00,
+0x20,0x08,0xE4,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x05,0x3C,
+0x28,0x08,0xE4,0x36,
+0x02,0x5C,0x00,0x0C,
+0x00,0x01,0x05,0x3C,
+0x25,0xB0,0x02,0x3C,
+0xAC,0x0E,0x42,0x34,
+0x00,0x00,0x5E,0x8C,
+0x00,0xD8,0x02,0x3C,
+0x24,0x10,0xC2,0x03,
+0x37,0x00,0x40,0x10,
+0x01,0x00,0x10,0x26,
+0x0A,0x00,0x02,0x2E,
+0x97,0xFF,0x40,0x14,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xA5,0x8F,
+0x25,0xB0,0x10,0x3C,
+0x02,0x5C,0x00,0x0C,
+0xE0,0x0E,0x04,0x36,
+0x14,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0xDC,0x0E,0x04,0x36,
+0x18,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x70,0x0E,0x04,0x36,
+0x1C,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x74,0x0E,0x04,0x36,
+0x20,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x78,0x0E,0x04,0x36,
+0x24,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x7C,0x0E,0x04,0x36,
+0x28,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x80,0x0E,0x04,0x36,
+0x2C,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x84,0x0E,0x04,0x36,
+0x30,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x88,0x0E,0x04,0x36,
+0x34,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0x8C,0x0E,0x04,0x36,
+0x38,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0xD0,0x0E,0x04,0x36,
+0x3C,0x00,0xA5,0x8F,
+0x02,0x5C,0x00,0x0C,
+0xD4,0x0E,0x04,0x36,
+0x40,0x00,0xA5,0x8F,
+0x88,0x0E,0x04,0x36,
+0x6C,0x00,0xBF,0x8F,
+0x68,0x00,0xBE,0x8F,
+0x64,0x00,0xB7,0x8F,
+0x60,0x00,0xB6,0x8F,
+0x5C,0x00,0xB5,0x8F,
+0x58,0x00,0xB4,0x8F,
+0x54,0x00,0xB3,0x8F,
+0x50,0x00,0xB2,0x8F,
+0x4C,0x00,0xB1,0x8F,
+0x48,0x00,0xB0,0x8F,
+0x02,0x5C,0x00,0x08,
+0x70,0x00,0xBD,0x27,
+0x80,0x0C,0xF1,0x36,
+0x94,0x0E,0xE3,0x36,
+0x00,0x00,0x24,0x8E,
+0x00,0x00,0x62,0x8C,
+0xFF,0x03,0x03,0x3C,
+0xFF,0x03,0x95,0x30,
+0x24,0x10,0x43,0x00,
+0x02,0x14,0x02,0x00,
+0x18,0x00,0x55,0x00,
+0x02,0x80,0x10,0x3C,
+0x30,0x1F,0x10,0x26,
+0x0C,0x00,0x02,0x8E,
+0x00,0xFC,0x12,0x24,
+0x00,0x00,0x3E,0x8E,
+0x24,0x10,0x52,0x00,
+0x21,0x20,0x20,0x02,
+0x24,0x30,0xD2,0x03,
+0xFF,0xFF,0x13,0x3C,
+0xFF,0x03,0x73,0x36,
+0x12,0x18,0x00,0x00,
+0x02,0x1A,0x03,0x00,
+0xFF,0x03,0x63,0x30,
+0x25,0x10,0x43,0x00,
+0xFF,0x03,0x45,0x30,
+0x25,0x28,0xC5,0x00,
+0x02,0x5C,0x00,0x0C,
+0x0C,0x00,0x02,0xAE,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x9C,0x0E,0xE3,0x36,
+0x00,0x00,0x62,0x8C,
+0xFF,0x03,0x03,0x3C,
+0x0C,0x00,0x06,0x8E,
+0x24,0x10,0x43,0x00,
+0x02,0xB4,0x02,0x00,
+0x18,0x00,0xD5,0x02,
+0xF0,0xFF,0x02,0x3C,
+0xFF,0x03,0x42,0x34,
+0x24,0x30,0xC2,0x00,
+0x00,0x00,0x3E,0x8E,
+0xC0,0xFF,0x04,0x3C,
+0xFF,0xFF,0x84,0x34,
+0x24,0x10,0xC4,0x03,
+0x21,0x20,0x20,0x02,
+0xFF,0x0F,0x11,0x3C,
+0xFF,0xFF,0x31,0x36,
+0x12,0x18,0x00,0x00,
+0x02,0x1A,0x03,0x00,
+0xFF,0x03,0x63,0x30,
+0x80,0x1A,0x03,0x00,
+0x25,0x30,0xC3,0x00,
+0x82,0x2A,0x06,0x00,
+0x3F,0x00,0xA5,0x30,
+0x00,0x2C,0x05,0x00,
+0x0C,0x00,0x06,0xAE,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0x45,0x00,
+0x94,0x0C,0xE4,0x36,
+0x00,0x00,0x9E,0x8C,
+0x82,0x29,0x16,0x00,
+0x00,0x2F,0x05,0x00,
+0x24,0x10,0xD1,0x03,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0x45,0x00,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x25,0xB0,0x05,0x3C,
+0xA4,0x0E,0xE3,0x36,
+0x14,0x0C,0xA5,0x34,
+0x00,0x00,0xBE,0x8C,
+0x00,0x00,0x62,0x8C,
+0xFF,0x03,0x05,0x3C,
+0x02,0x80,0x03,0x3C,
+0xDC,0xED,0x63,0x24,
+0x24,0x10,0x45,0x00,
+0x00,0x00,0x64,0x8C,
+0x02,0x14,0x02,0x00,
+0x24,0x18,0xD2,0x03,
+0x25,0xF0,0x62,0x00,
+0x02,0x5C,0x00,0x0C,
+0x21,0x28,0xC0,0x03,
+0x25,0xB0,0x02,0x3C,
+0xAC,0x0E,0x42,0x34,
+0x00,0x00,0x45,0x8C,
+0x3F,0x00,0x03,0x3C,
+0x24,0x10,0xD3,0x03,
+0x24,0x28,0xA3,0x00,
+0x82,0x29,0x05,0x00,
+0x25,0x28,0x45,0x00,
+0x02,0x80,0x02,0x3C,
+0xDC,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0x02,0x5C,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x25,0xB0,0x05,0x3C,
+0xB4,0x0E,0xE3,0x36,
+0x88,0x0C,0xA5,0x34,
+0x00,0x00,0xA4,0x8C,
+0x00,0x00,0x62,0x8C,
+0xFF,0x03,0x03,0x3C,
+0xFF,0x03,0x95,0x30,
+0x24,0x10,0x43,0x00,
+0x02,0x14,0x02,0x00,
+0x18,0x00,0x55,0x00,
+0x0C,0x00,0x06,0x8E,
+0x00,0x00,0xBE,0x8C,
+0x02,0x80,0x02,0x3C,
+0x24,0x30,0xD2,0x00,
+0xE0,0xED,0x42,0x24,
+0x00,0x00,0x44,0x8C,
+0x24,0x10,0xD2,0x03,
+0x12,0x18,0x00,0x00,
+0x02,0x1A,0x03,0x00,
+0xFF,0x03,0x63,0x30,
+0x25,0x30,0xC3,0x00,
+0xFF,0x03,0xC5,0x30,
+0x25,0x28,0x45,0x00,
+0x02,0x5C,0x00,0x0C,
+0x0C,0x00,0x06,0xAE,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0xBC,0x0E,0xE2,0x36,
+0x00,0x00,0x43,0x8C,
+0xFF,0x03,0x05,0x3C,
+0x0C,0x00,0x06,0x8E,
+0x24,0x18,0x65,0x00,
+0x02,0xB4,0x03,0x00,
+0x18,0x00,0xD5,0x02,
+0x25,0xB0,0x04,0x3C,
+0x88,0x0C,0x84,0x34,
+0xF0,0xFF,0x03,0x3C,
+0x00,0x00,0x9E,0x8C,
+0xFF,0x03,0x63,0x34,
+0x24,0x30,0xC3,0x00,
+0xC0,0xFF,0x04,0x3C,
+0x02,0x80,0x05,0x3C,
+0xFF,0xFF,0x84,0x34,
+0xE0,0xED,0xA5,0x24,
+0x24,0xF0,0xC4,0x03,
+0x00,0x00,0xA4,0x8C,
+0x44,0x00,0xBE,0xAF,
+0x12,0x10,0x00,0x00,
+0x02,0x12,0x02,0x00,
+0xFF,0x03,0x42,0x30,
+0x80,0x12,0x02,0x00,
+0x25,0x30,0xC2,0x00,
+0x82,0x2A,0x06,0x00,
+0x3F,0x00,0xA5,0x30,
+0x00,0x2C,0x05,0x00,
+0x0C,0x00,0x06,0xAE,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0xC5,0x03,
+0x9C,0x0C,0xE4,0x36,
+0x00,0x00,0x9E,0x8C,
+0x82,0x29,0x16,0x00,
+0x00,0x2F,0x05,0x00,
+0x24,0x88,0xD1,0x03,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0x25,0x02,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x25,0xB0,0x02,0x3C,
+0xC4,0x0E,0xE3,0x36,
+0x1C,0x0C,0x42,0x34,
+0x00,0x00,0x5E,0x8C,
+0x00,0x00,0x62,0x8C,
+0xFF,0x03,0x05,0x3C,
+0x02,0x80,0x03,0x3C,
+0xE4,0xED,0x63,0x24,
+0x24,0x10,0x45,0x00,
+0x00,0x00,0x64,0x8C,
+0x02,0x14,0x02,0x00,
+0x24,0x90,0xD2,0x03,
+0x25,0xF0,0x42,0x02,
+0x02,0x5C,0x00,0x0C,
+0x21,0x28,0xC0,0x03,
+0xCC,0x0E,0xE2,0x36,
+0x00,0x00,0x45,0x8C,
+0x02,0x80,0x02,0x3C,
+0xE4,0xED,0x42,0x24,
+0x3F,0x00,0x03,0x3C,
+0x00,0x00,0x44,0x8C,
+0x24,0x28,0xA3,0x00,
+0x24,0x98,0xD3,0x03,
+0x82,0x29,0x05,0x00,
+0x02,0x5C,0x00,0x0C,
+0x25,0x28,0x65,0x02,
+0x54,0x22,0x00,0x0C,
+0x05,0x00,0x04,0x24,
+0x5C,0x6D,0x00,0x08,
+0x00,0x00,0x00,0x00,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x42,0x00,0x03,0x24,
+0x10,0x00,0xA3,0xA3,
+0xF1,0x3A,0x40,0xA0,
+0x4E,0x00,0x03,0x24,
+0x43,0x00,0x02,0x24,
+0x02,0x80,0x07,0x3C,
+0x9C,0xF3,0xE7,0x24,
+0x11,0x00,0xA2,0xA3,
+0x12,0x00,0xA3,0xA3,
+0xD0,0x07,0x02,0x24,
+0x01,0x00,0x03,0x24,
+0x01,0x80,0x06,0x3C,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0xE0,0x00,
+0xDC,0xAC,0xC6,0x24,
+0x0C,0x00,0xE2,0xAC,
+0x14,0x00,0xE3,0xA0,
+0x18,0x00,0xBF,0xAF,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x48,0xFD,0xBD,0x27,
+0xE8,0xED,0x46,0x24,
+0x02,0x80,0x03,0x3C,
+0xB0,0x02,0xB2,0xAF,
+0xAC,0x02,0xB1,0xAF,
+0xA8,0x02,0xB0,0xAF,
+0x33,0x1F,0x60,0xA0,
+0x21,0x38,0xA0,0x03,
+0x90,0x00,0xC8,0x24,
+0x00,0x00,0xC2,0x8C,
+0x04,0x00,0xC3,0x8C,
+0x08,0x00,0xC4,0x8C,
+0x0C,0x00,0xC5,0x8C,
+0x10,0x00,0xC6,0x24,
+0x00,0x00,0xE2,0xAC,
+0x04,0x00,0xE3,0xAC,
+0x08,0x00,0xE4,0xAC,
+0x0C,0x00,0xE5,0xAC,
+0xF6,0xFF,0xC8,0x14,
+0x10,0x00,0xE7,0x24,
+0x00,0x00,0xC3,0x8C,
+0x02,0x80,0x02,0x3C,
+0x7C,0xEE,0x58,0x24,
+0x00,0x00,0xE3,0xAC,
+0x98,0x00,0xB9,0x27,
+0x00,0x01,0x12,0x27,
+0x01,0x00,0x02,0x93,
+0x05,0x00,0x03,0x93,
+0x09,0x00,0x04,0x93,
+0x0D,0x00,0x05,0x93,
+0x00,0x00,0x11,0x93,
+0x02,0x00,0x0D,0x93,
+0x04,0x00,0x10,0x93,
+0x06,0x00,0x0C,0x93,
+0x08,0x00,0x0F,0x93,
+0x0A,0x00,0x07,0x93,
+0x0C,0x00,0x0E,0x93,
+0x0E,0x00,0x06,0x93,
+0x03,0x00,0x08,0x93,
+0x07,0x00,0x09,0x93,
+0x0B,0x00,0x0A,0x93,
+0x0F,0x00,0x0B,0x93,
+0x00,0x12,0x02,0x00,
+0x00,0x1A,0x03,0x00,
+0x00,0x22,0x04,0x00,
+0x00,0x2A,0x05,0x00,
+0x25,0x10,0x51,0x00,
+0x25,0x18,0x70,0x00,
+0x25,0x20,0x8F,0x00,
+0x25,0x28,0xAE,0x00,
+0x00,0x6C,0x0D,0x00,
+0x00,0x64,0x0C,0x00,
+0x00,0x3C,0x07,0x00,
+0x00,0x34,0x06,0x00,
+0x25,0x68,0xA2,0x01,
+0x25,0x60,0x83,0x01,
+0x25,0x38,0xE4,0x00,
+0x25,0x30,0xC5,0x00,
+0x00,0x46,0x08,0x00,
+0x00,0x4E,0x09,0x00,
+0x00,0x56,0x0A,0x00,
+0x00,0x5E,0x0B,0x00,
+0x25,0x40,0x0D,0x01,
+0x25,0x48,0x2C,0x01,
+0x25,0x50,0x47,0x01,
+0x25,0x58,0x66,0x01,
+0x10,0x00,0x18,0x27,
+0x00,0x00,0x28,0xAF,
+0x04,0x00,0x29,0xAF,
+0x08,0x00,0x2A,0xAF,
+0x0C,0x00,0x2B,0xAF,
+0xD2,0xFF,0x12,0x17,
+0x10,0x00,0x39,0x27,
+0x01,0x00,0x02,0x93,
+0x05,0x00,0x03,0x93,
+0x00,0x00,0x09,0x93,
+0x02,0x00,0x04,0x93,
+0x04,0x00,0x08,0x93,
+0x06,0x00,0x05,0x93,
+0x07,0x00,0x06,0x93,
+0x03,0x00,0x07,0x93,
+0x00,0x12,0x02,0x00,
+0x00,0x1A,0x03,0x00,
+0x25,0x10,0x49,0x00,
+0x25,0x18,0x68,0x00,
+0x00,0x24,0x04,0x00,
+0x00,0x2C,0x05,0x00,
+0x25,0x20,0x82,0x00,
+0x25,0x28,0xA3,0x00,
+0x00,0x3E,0x07,0x00,
+0x00,0x36,0x06,0x00,
+0x02,0x80,0x02,0x3C,
+0x25,0x38,0xE4,0x00,
+0x25,0x30,0xC5,0x00,
+0x84,0xEF,0x58,0x24,
+0x04,0x00,0x26,0xAF,
+0x00,0x00,0x27,0xAF,
+0x00,0x01,0x12,0x27,
+0xA0,0x01,0xB9,0x27,
+0x01,0x00,0x02,0x93,
+0x05,0x00,0x03,0x93,
+0x09,0x00,0x04,0x93,
+0x0D,0x00,0x05,0x93,
+0x00,0x00,0x11,0x93,
+0x02,0x00,0x0D,0x93,
+0x04,0x00,0x10,0x93,
+0x06,0x00,0x0C,0x93,
+0x08,0x00,0x0F,0x93,
+0x0A,0x00,0x07,0x93,
+0x0C,0x00,0x0E,0x93,
+0x0E,0x00,0x06,0x93,
+0x03,0x00,0x08,0x93,
+0x07,0x00,0x09,0x93,
+0x0B,0x00,0x0A,0x93,
+0x0F,0x00,0x0B,0x93,
+0x00,0x12,0x02,0x00,
+0x00,0x1A,0x03,0x00,
+0x00,0x22,0x04,0x00,
+0x00,0x2A,0x05,0x00,
+0x25,0x10,0x51,0x00,
+0x25,0x18,0x70,0x00,
+0x25,0x20,0x8F,0x00,
+0x25,0x28,0xAE,0x00,
+0x00,0x6C,0x0D,0x00,
+0x00,0x64,0x0C,0x00,
+0x00,0x3C,0x07,0x00,
+0x00,0x34,0x06,0x00,
+0x25,0x68,0xA2,0x01,
+0x25,0x60,0x83,0x01,
+0x25,0x38,0xE4,0x00,
+0x25,0x30,0xC5,0x00,
+0x00,0x46,0x08,0x00,
+0x00,0x4E,0x09,0x00,
+0x00,0x56,0x0A,0x00,
+0x00,0x5E,0x0B,0x00,
+0x25,0x40,0x0D,0x01,
+0x25,0x48,0x2C,0x01,
+0x25,0x50,0x47,0x01,
+0x25,0x58,0x66,0x01,
+0x10,0x00,0x18,0x27,
+0x00,0x00,0x28,0xAF,
+0x04,0x00,0x29,0xAF,
+0x08,0x00,0x2A,0xAF,
+0x0C,0x00,0x2B,0xAF,
+0xD2,0xFF,0x12,0x17,
+0x10,0x00,0x39,0x27,
+0x01,0x00,0x02,0x93,
+0x05,0x00,0x03,0x93,
+0x00,0x00,0x09,0x93,
+0x02,0x00,0x04,0x93,
+0x04,0x00,0x08,0x93,
+0x06,0x00,0x05,0x93,
+0x07,0x00,0x06,0x93,
+0x03,0x00,0x07,0x93,
+0x00,0x12,0x02,0x00,
+0x00,0x1A,0x03,0x00,
+0x25,0x10,0x49,0x00,
+0x25,0x18,0x68,0x00,
+0x00,0x24,0x04,0x00,
+0x00,0x2C,0x05,0x00,
+0x25,0x20,0x82,0x00,
+0x25,0x28,0xA3,0x00,
+0x00,0x3E,0x07,0x00,
+0x00,0x36,0x06,0x00,
+0x25,0x30,0xC5,0x00,
+0x25,0x38,0xE4,0x00,
+0x02,0x80,0x02,0x3C,
+0x04,0x00,0x26,0xAF,
+0x00,0x00,0x27,0xAF,
+0x30,0x1F,0x46,0x24,
+0x21,0x50,0x00,0x00,
+0x80,0x20,0x0A,0x00,
+0x21,0x10,0x9D,0x00,
+0x00,0x00,0x45,0x8C,
+0x01,0x00,0x43,0x25,
+0xFF,0x00,0x6A,0x30,
+0x21,0x20,0x86,0x00,
+0x25,0x00,0x42,0x2D,
+0xF8,0xFF,0x40,0x14,
+0x18,0x00,0x85,0xAC,
+0x02,0x80,0x02,0x3C,
+0x30,0x1F,0x4B,0x24,
+0x21,0x50,0x00,0x00,
+0xC0,0x10,0x0A,0x00,
+0x21,0x48,0x5D,0x00,
+0x21,0x38,0x00,0x00,
+0x21,0x40,0x4B,0x00,
+0x21,0x10,0x27,0x01,
+0xA0,0x01,0x46,0x90,
+0x98,0x00,0x45,0x90,
+0x01,0x00,0xE4,0x24,
+0x21,0x18,0x07,0x01,
+0xFF,0x00,0x87,0x30,
+0x08,0x00,0xE2,0x2C,
+0xB4,0x01,0x66,0xA0,
+0xF7,0xFF,0x40,0x14,
+0xAC,0x00,0x65,0xA0,
+0x01,0x00,0x42,0x25,
+0xFF,0x00,0x4A,0x30,
+0x21,0x00,0x43,0x2D,
+0xEF,0xFF,0x60,0x14,
+0xC0,0x10,0x0A,0x00,
+0x08,0x00,0x64,0x8D,
+0xFF,0x7F,0x07,0x3C,
+0xFF,0xFF,0xE7,0x34,
+0xC0,0xFF,0x02,0x24,
+0x24,0x20,0x87,0x00,
+0x24,0x20,0x82,0x00,
+0x0C,0x00,0x84,0x34,
+0xFF,0xC0,0x02,0x24,
+0x24,0x20,0x82,0x00,
+0xC0,0xFF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x00,0x18,0x84,0x34,
+0xBF,0xFF,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0xFF,0xFF,0x63,0x34,
+0x7F,0xFF,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0xFF,0xFF,0x42,0x34,
+0x24,0x20,0x82,0x00,
+0x0C,0x00,0x65,0x8D,
+0x7F,0xFF,0x03,0x24,
+0x40,0x40,0x84,0x34,
+0xFF,0xFF,0x02,0x3C,
+0x24,0x20,0x83,0x00,
+0xFF,0x7F,0x42,0x34,
+0xFF,0xBF,0x03,0x3C,
+0x10,0x00,0x66,0x8D,
+0x24,0x20,0x82,0x00,
+0xFF,0xFF,0x63,0x34,
+0xFF,0x9F,0x02,0x3C,
+0x24,0x28,0xA3,0x00,
+0xFF,0xFF,0x42,0x34,
+0xFF,0x3F,0x03,0x3C,
+0x24,0x20,0x82,0x00,
+0xFF,0xFF,0x63,0x34,
+0x12,0x00,0x02,0x24,
+0xB0,0x02,0xB2,0x8F,
+0xAC,0x02,0xB1,0x8F,
+0xA8,0x02,0xB0,0x8F,
+0x24,0x30,0xC3,0x00,
+0xC7,0x02,0x62,0xA1,
+0x1F,0x00,0x03,0x24,
+0x01,0x00,0x02,0x24,
+0x24,0x28,0xA7,0x00,
+0xBE,0x02,0x63,0xA1,
+0xC0,0x02,0x62,0xA1,
+0xFF,0x00,0x03,0x24,
+0xFF,0xFF,0x02,0x24,
+0xB8,0x02,0xBD,0x27,
+0x08,0x00,0x64,0xAD,
+0x10,0x00,0x66,0xAD,
+0x0C,0x00,0x65,0xAD,
+0xC2,0x02,0x62,0xA1,
+0xC4,0x02,0x63,0xA5,
+0xBF,0x02,0x60,0xA1,
+0x08,0x00,0xE0,0x03,
+0xC6,0x02,0x60,0xA1,
+0x02,0x80,0x0B,0x3C,
+0x30,0x1F,0x67,0x25,
+0xE0,0xFF,0xBD,0x27,
+0xE6,0x02,0xE0,0xA0,
+0x18,0x00,0xBF,0xAF,
+0xE4,0x02,0xE8,0x8C,
+0xFF,0xCF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x30,0x1F,0x69,0x8D,
+0x24,0x40,0x02,0x01,
+0xFF,0xBF,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0xF0,0xFF,0x03,0x24,
+0x24,0x40,0x02,0x01,
+0xFF,0x7F,0x02,0x3C,
+0x24,0x48,0x23,0x01,
+0xFF,0xFF,0x42,0x34,
+0xFF,0xF0,0x03,0x24,
+0x24,0x48,0x23,0x01,
+0x24,0x40,0x02,0x01,
+0x20,0x00,0x03,0x24,
+0x0A,0x00,0x02,0x24,
+0x30,0x1F,0x69,0xAD,
+0xD2,0x02,0xE2,0xA0,
+0xD7,0x02,0xE3,0xA0,
+0x20,0x00,0x02,0x24,
+0x00,0x01,0x03,0x24,
+0xC8,0x02,0xE2,0xA4,
+0xCA,0x02,0xE3,0xA4,
+0x00,0x02,0x02,0x24,
+0x49,0x00,0x03,0x24,
+0x02,0x80,0x0A,0x3C,
+0xE4,0x02,0xE8,0xAC,
+0x80,0xF3,0x4A,0x25,
+0xFF,0xFF,0x0D,0x34,
+0x3E,0x00,0x0E,0x24,
+0x1C,0x00,0x0F,0x24,
+0x01,0x00,0x0C,0x24,
+0x11,0x00,0xA3,0xA3,
+0xCC,0x02,0xE2,0xA4,
+0xD0,0x07,0x03,0x24,
+0x44,0x00,0x02,0x24,
+0x01,0x80,0x06,0x3C,
+0x10,0x00,0xA2,0xA3,
+0x10,0x00,0xA5,0x27,
+0x47,0x00,0x02,0x24,
+0x21,0x20,0x40,0x01,
+0x94,0xAD,0xC6,0x24,
+0x04,0x00,0xED,0xAC,
+0xD0,0x02,0xEE,0xA0,
+0xD1,0x02,0xEF,0xA0,
+0x02,0x00,0xEC,0xA0,
+0x0C,0x00,0x43,0xAD,
+0x14,0x00,0x4C,0xA1,
+0x80,0x36,0xED,0xAC,
+0xCE,0x02,0xEE,0xA0,
+0xCF,0x02,0xEF,0xA0,
+0xD6,0x02,0xE0,0xA0,
+0xD4,0x02,0xE0,0xA0,
+0x12,0x00,0xA2,0xA3,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x50,0x00,0x03,0x24,
+0x10,0x00,0xA3,0xA3,
+0x16,0x3D,0x40,0xA0,
+0x41,0x00,0x03,0x24,
+0x52,0x00,0x02,0x24,
+0x02,0x80,0x07,0x3C,
+0x0C,0xF4,0xE7,0x24,
+0x11,0x00,0xA2,0xA3,
+0x12,0x00,0xA3,0xA3,
+0xD0,0x07,0x02,0x24,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x06,0x3C,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0xE0,0x00,
+0x2C,0x80,0xC6,0x24,
+0x0C,0x00,0xE2,0xAC,
+0x14,0x00,0xE3,0xA0,
+0x18,0x00,0xBF,0xAF,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0x02,0x80,0x09,0x3C,
+0x30,0x1F,0x23,0x8D,
+0xFF,0xFF,0x02,0x24,
+0xFF,0x00,0x4B,0x30,
+0x0F,0xFF,0x02,0x24,
+0x24,0x18,0x62,0x00,
+0xFF,0xFF,0x02,0x3C,
+0xFF,0x0F,0x42,0x34,
+0x24,0x18,0x62,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x30,0x1F,0x23,0xAD,
+0x47,0x00,0x02,0x24,
+0x3B,0x00,0x03,0x24,
+0x02,0x80,0x08,0x3C,
+0x28,0xF4,0x08,0x25,
+0x18,0x00,0xB0,0xAF,
+0x10,0x00,0xA2,0xA3,
+0x30,0x1F,0x30,0x25,
+0x11,0x00,0xA3,0xA3,
+0xD0,0x07,0x02,0x24,
+0x01,0x00,0x03,0x24,
+0x01,0x00,0x07,0x3C,
+0x01,0x80,0x06,0x3C,
+0x04,0x03,0x0B,0xAE,
+0x1C,0x00,0xB1,0xAF,
+0x56,0x30,0xEA,0x34,
+0x43,0x00,0x11,0x24,
+0xF4,0x98,0xE7,0x34,
+0x10,0x00,0xA5,0x27,
+0x0C,0x00,0x02,0xAD,
+0x14,0x00,0x03,0xA1,
+0x21,0x20,0x00,0x01,
+0x1C,0xB9,0xC6,0x24,
+0x20,0x00,0xBF,0xAF,
+0x12,0x00,0xB1,0xA3,
+0x0C,0x03,0x07,0xAE,
+0x10,0x03,0x0A,0xAE,
+0x13,0x00,0xA0,0xA3,
+0x08,0x03,0x00,0xAE,
+0x14,0x03,0x00,0xAE,
+0xA2,0x23,0x00,0x0C,
+0x18,0x03,0x00,0xAE,
+0x1E,0x00,0x02,0x24,
+0x21,0x03,0x02,0xA2,
+0x4A,0x00,0x03,0x24,
+0x45,0x00,0x02,0x24,
+0x1C,0x03,0x03,0xA2,
+0x1D,0x03,0x02,0xA2,
+0x23,0x00,0x03,0x24,
+0x3E,0x00,0x02,0x24,
+0x1E,0x03,0x11,0xA2,
+0x1F,0x03,0x02,0xA2,
+0x20,0x03,0x03,0xA2,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x3B,0x00,0x02,0x24,
+0x43,0x00,0x03,0x24,
+0x10,0x00,0xA2,0xA3,
+0x11,0x00,0xA3,0xA3,
+0x36,0x00,0x02,0x24,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x07,0x3C,
+0x44,0xF4,0xE7,0x24,
+0x12,0x00,0xA2,0xA3,
+0x03,0x22,0x60,0xA0,
+0xD0,0x07,0x02,0x24,
+0x01,0x00,0x03,0x24,
+0x01,0x80,0x06,0x3C,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0xE0,0x00,
+0x50,0xBD,0xC6,0x24,
+0x0C,0x00,0xE2,0xAC,
+0x14,0x00,0xE3,0xA0,
+0x18,0x00,0xBF,0xAF,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xE0,0xFF,0xBD,0x27,
+0x02,0x80,0x02,0x3C,
+0x52,0x00,0x03,0x24,
+0x10,0x00,0xA3,0xA3,
+0xB8,0x55,0x40,0xA4,
+0x54,0x00,0x03,0x24,
+0x53,0x00,0x02,0x24,
+0x02,0x80,0x07,0x3C,
+0x7C,0xF4,0xE7,0x24,
+0x11,0x00,0xA2,0xA3,
+0x12,0x00,0xA3,0xA3,
+0xF4,0x01,0x02,0x24,
+0x01,0x00,0x03,0x24,
+0x02,0x80,0x06,0x3C,
+0x10,0x00,0xA5,0x27,
+0x21,0x20,0xE0,0x00,
+0x70,0x81,0xC6,0x24,
+0x0C,0x00,0xE2,0xAC,
+0x14,0x00,0xE3,0xA0,
+0x18,0x00,0xBF,0xAF,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x18,0x00,0xBF,0x8F,
+0x00,0x00,0x00,0x00,
+0x08,0x00,0xE0,0x03,
+0x20,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x02,0x80,0x03,0x3C,
+0x20,0x00,0xBF,0xAF,
+0x1C,0x00,0xB1,0xAF,
+0x18,0x00,0xB0,0xAF,
+0x58,0xE9,0x62,0x24,
+0x58,0xE9,0x67,0x94,
+0x02,0x00,0x48,0x90,
+0x02,0x80,0x02,0x3C,
+0xD8,0x5E,0x42,0x24,
+0x02,0x00,0x11,0x24,
+0x01,0x80,0x06,0x3C,
+0x21,0x20,0x40,0x00,
+0x14,0x00,0x51,0xA0,
+0x10,0x00,0xA5,0x27,
+0x6C,0xCE,0xC6,0x24,
+0x02,0x80,0x10,0x3C,
+0x10,0x00,0xA7,0xA7,
+0x28,0x5F,0x10,0x26,
+0x12,0x00,0xA8,0xA3,
+0xA2,0x23,0x00,0x0C,
+0x13,0x00,0xA0,0xA3,
+0x02,0x80,0x06,0x3C,
+0x21,0x20,0x00,0x02,
+0x10,0x00,0xA5,0x27,
+0x14,0x00,0x11,0xA2,
+0xA2,0x23,0x00,0x0C,
+0x7C,0x82,0xC6,0x24,
+0x02,0x80,0x03,0x3C,
+0xDE,0x5D,0x62,0x90,
+0x02,0x00,0x07,0x24,
+0x0C,0x00,0x04,0x24,
+0x02,0x00,0x42,0x30,
+0x01,0x00,0x42,0x2C,
+0x23,0x38,0xE2,0x00,
+0xE8,0x03,0x02,0x24,
+0x0C,0x00,0x02,0xAE,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xF4,0x5E,0x60,0xA0,
+0xF5,0x5E,0x44,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xF6,0x5E,0x64,0xA0,
+0x0D,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x13,0x5F,0x60,0xA0,
+0x01,0x00,0x06,0x24,
+0x14,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xF8,0x5E,0x66,0xA0,
+0x0F,0x00,0x04,0x24,
+0x15,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0xF7,0x5E,0x66,0xA0,
+0xF9,0x5E,0x44,0xA0,
+0x02,0x80,0x03,0x3C,
+0x08,0x00,0x04,0x24,
+0x02,0x80,0x02,0x3C,
+0xFA,0x5E,0x60,0xA0,
+0x64,0x00,0x05,0x24,
+0x04,0x5F,0x44,0xA4,
+0x02,0x80,0x03,0x3C,
+0x01,0x00,0x02,0x3C,
+0xFC,0x5E,0x65,0xA4,
+0x00,0x90,0x42,0x34,
+0x02,0x80,0x03,0x3C,
+0x00,0x5F,0x62,0xAC,
+0x02,0x80,0x04,0x3C,
+0x02,0x80,0x02,0x3C,
+0x08,0x5F,0x80,0xAC,
+0x02,0x80,0x03,0x3C,
+0x0C,0x5F,0x40,0xA0,
+0x02,0x80,0x02,0x3C,
+0x0E,0x5F,0x60,0xA0,
+0x16,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x44,0x5F,0x67,0xA0,
+0x20,0x00,0xBF,0x8F,
+0x0F,0x5F,0x40,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x1C,0x00,0xB1,0x8F,
+0x18,0x00,0xB0,0x8F,
+0x10,0x5F,0x66,0xA0,
+0x11,0x5F,0x46,0xA0,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x12,0x5F,0x60,0xA0,
+0x21,0x20,0x00,0x00,
+0x18,0x5F,0x40,0xAC,
+0x02,0x80,0x03,0x3C,
+0x02,0x80,0x02,0x3C,
+0x21,0x28,0x00,0x00,
+0x28,0x00,0xBD,0x27,
+0x1C,0x5F,0x60,0xAC,
+0x20,0x5F,0x44,0xAC,
+0x24,0x5F,0x45,0xAC,
+0x08,0x00,0xE0,0x03,
+0x00,0x00,0x00,0x00,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x21,0x98,0xA0,0x00,
+0x21,0x88,0xC0,0x00,
+0x21,0x90,0x00,0x00,
+0x00,0x00,0x04,0x82,
+0x7C,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x10,0x26,
+0xFF,0xFF,0x10,0x26,
+0x00,0x00,0x04,0x92,
+0x2B,0x00,0x02,0x24,
+0x00,0x1E,0x04,0x00,
+0x03,0x1E,0x03,0x00,
+0x41,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0x02,0x24,
+0x30,0x00,0x22,0x12,
+0x00,0x1E,0x04,0x00,
+0x07,0x00,0x20,0x16,
+0x21,0x18,0x80,0x00,
+0x00,0x1E,0x04,0x00,
+0x03,0x1E,0x03,0x00,
+0x30,0x00,0x02,0x24,
+0x3B,0x00,0x62,0x10,
+0x0A,0x00,0x11,0x24,
+0x21,0x18,0x80,0x00,
+0x00,0x16,0x03,0x00,
+0x03,0x16,0x02,0x00,
+0x1A,0x00,0x40,0x10,
+0xFF,0x00,0x64,0x30,
+0xA9,0xFF,0x82,0x24,
+0x61,0x00,0x83,0x2C,
+0xFF,0x00,0x45,0x30,
+0x09,0x00,0x60,0x10,
+0x41,0x00,0x86,0x2C,
+0xC9,0xFF,0x82,0x24,
+0xFF,0x00,0x45,0x30,
+0x05,0x00,0xC0,0x10,
+0x3A,0x00,0x87,0x2C,
+0xD0,0xFF,0x82,0x24,
+0x02,0x00,0xE0,0x10,
+0xFF,0x00,0x05,0x24,
+0xFF,0x00,0x45,0x30,
+0x2A,0x10,0xB1,0x00,
+0x0A,0x00,0x40,0x10,
+0x18,0x00,0x51,0x02,
+0x01,0x00,0x10,0x26,
+0x12,0x10,0x00,0x00,
+0x2B,0x18,0x52,0x00,
+0x23,0x00,0x60,0x14,
+0x21,0x90,0xA2,0x00,
+0x00,0x00,0x03,0x92,
+0x00,0x00,0x00,0x00,
+0xE8,0xFF,0x60,0x14,
+0xFF,0x00,0x64,0x30,
+0x02,0x00,0x60,0x12,
+0x21,0x10,0x40,0x02,
+0x00,0x00,0x70,0xAE,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x03,0x1E,0x03,0x00,
+0x30,0x00,0x02,0x24,
+0xCE,0xFF,0x62,0x14,
+0x00,0x00,0x00,0x00,
+0x01,0x00,0x03,0x82,
+0x78,0x00,0x02,0x24,
+0x03,0x00,0x62,0x10,
+0x58,0x00,0x02,0x24,
+0xD0,0xFF,0x62,0x14,
+0x21,0x18,0x80,0x00,
+0x02,0x00,0x10,0x26,
+0x00,0x00,0x04,0x92,
+0xC0,0x70,0x00,0x08,
+0x10,0x00,0x11,0x24,
+0x01,0x00,0x10,0x26,
+0x00,0x00,0x04,0x92,
+0xB7,0x70,0x00,0x08,
+0x10,0x00,0x02,0x24,
+0xEC,0x70,0x00,0x08,
+0x08,0x00,0x11,0x24,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFF,0xFF,0x02,0x24,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x21,0x48,0x80,0x00,
+0x31,0x00,0xC0,0x14,
+0x21,0x50,0x00,0x00,
+0x00,0x00,0x87,0x90,
+0x30,0x00,0x02,0x24,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0x2E,0x00,0x62,0x10,
+0x0A,0x00,0x06,0x24,
+0x02,0x80,0x02,0x3C,
+0x40,0xF2,0x4B,0x24,
+0xFF,0x00,0xE8,0x30,
+0x21,0x10,0x0B,0x01,
+0x00,0x00,0x44,0x90,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0x44,0x00,0x82,0x30,
+0x02,0x00,0x87,0x30,
+0xD0,0xFF,0x63,0x24,
+0x1A,0x00,0x40,0x10,
+0x04,0x00,0x84,0x30,
+0x07,0x00,0x80,0x14,
+0x2B,0x10,0x66,0x00,
+0x21,0x10,0x00,0x01,
+0x02,0x00,0xE0,0x10,
+0xE0,0xFF,0x03,0x25,
+0xFF,0x00,0x62,0x30,
+0xC9,0xFF,0x43,0x24,
+0x2B,0x10,0x66,0x00,
+0x10,0x00,0x40,0x10,
+0x18,0x00,0x46,0x01,
+0x01,0x00,0x29,0x25,
+0x00,0x00,0x27,0x91,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0xE8,0x30,
+0x12,0x10,0x00,0x00,
+0x21,0x50,0x43,0x00,
+0x21,0x10,0x0B,0x01,
+0x00,0x00,0x44,0x90,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0x44,0x00,0x82,0x30,
+0x02,0x00,0x87,0x30,
+0xD0,0xFF,0x63,0x24,
+0xE8,0xFF,0x40,0x14,
+0x04,0x00,0x84,0x30,
+0x02,0x00,0xA0,0x10,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0xA9,0xAC,
+0x08,0x00,0xE0,0x03,
+0x21,0x10,0x40,0x01,
+0x00,0x00,0x87,0x90,
+0x0E,0x71,0x00,0x08,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x89,0x24,
+0x00,0x00,0x27,0x91,
+0x78,0x00,0x02,0x24,
+0x00,0x1E,0x07,0x00,
+0x03,0x1E,0x03,0x00,
+0xCD,0xFF,0x62,0x14,
+0x08,0x00,0x06,0x24,
+0x01,0x00,0x22,0x91,
+0x02,0x80,0x03,0x3C,
+0x40,0xF2,0x63,0x24,
+0x21,0x10,0x43,0x00,
+0x00,0x00,0x44,0x90,
+0x00,0x00,0x00,0x00,
+0x44,0x00,0x84,0x30,
+0xC5,0xFF,0x80,0x10,
+0x02,0x80,0x02,0x3C,
+0x01,0x00,0x29,0x25,
+0x00,0x00,0x27,0x91,
+0x0E,0x71,0x00,0x08,
+0x10,0x00,0x06,0x24,
+0xE8,0xFF,0xBD,0x27,
+0x10,0x00,0xBF,0xAF,
+0x00,0x00,0x83,0x80,
+0x2D,0x00,0x02,0x24,
+0x04,0x00,0x62,0x10,
+0x00,0x00,0x00,0x00,
+0x10,0x00,0xBF,0x8F,
+0x04,0x71,0x00,0x08,
+0x18,0x00,0xBD,0x27,
+0x04,0x71,0x00,0x0C,
+0x01,0x00,0x84,0x24,
+0x10,0x00,0xBF,0x8F,
+0x23,0x10,0x02,0x00,
+0x08,0x00,0xE0,0x03,
+0x18,0x00,0xBD,0x27,
+0xD8,0xFF,0xBD,0x27,
+0x1C,0x00,0xB3,0xAF,
+0x18,0x00,0xB2,0xAF,
+0x14,0x00,0xB1,0xAF,
+0x10,0x00,0xB0,0xAF,
+0x20,0x00,0xBF,0xAF,
+0x21,0x80,0x80,0x00,
+0x21,0x90,0xA0,0x00,
+0x21,0x98,0xC0,0x00,
+0x21,0x88,0x00,0x00,
+0x00,0x00,0x04,0x82,
+0x7C,0x55,0x00,0x0C,
+0x00,0x00,0x00,0x00,
+0xFC,0xFF,0x40,0x14,
+0x01,0x00,0x10,0x26,
+0xFF,0xFF,0x10,0x26,
+0x00,0x00,0x03,0x82,
+0x2D,0x00,0x02,0x24,
+0x0F,0x00,0x62,0x10,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x40,0x02,
+0xA0,0x70,0x00,0x0C,
+0x21,0x30,0x60,0x02,
+0x12,0x00,0x40,0x04,
+0x21,0x18,0x40,0x00,
+0x23,0x10,0x02,0x00,
+0x0A,0x10,0x71,0x00,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x01,0x00,0x10,0x26,
+0x21,0x20,0x00,0x02,
+0x21,0x28,0x40,0x02,
+0xA0,0x70,0x00,0x0C,
+0x21,0x30,0x60,0x02,
+0xFF,0xFF,0x11,0x24,
+0xF0,0xFF,0x41,0x04,
+0x21,0x18,0x40,0x00,
+0xF0,0xFF,0x20,0x16,
+0x00,0x80,0x02,0x3C,
+0x20,0x00,0xBF,0x8F,
+0x1C,0x00,0xB3,0x8F,
+0x18,0x00,0xB2,0x8F,
+0x14,0x00,0xB1,0x8F,
+0x10,0x00,0xB0,0x8F,
+0xFF,0x7F,0x02,0x3C,
+0xFF,0xFF,0x42,0x34,
+0x08,0x00,0xE0,0x03,
+0x28,0x00,0xBD,0x27,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x52,0x54,0x4C,0x38,
+0x37,0x31,0x32,0x20,
+0x46,0x57,0x20,0x76,
+0x65,0x72,0x73,0x69,
+0x6F,0x6E,0x20,0x30,
+0x2E,0x30,0x2E,0x31,
+0x23,0x20,0xE4,0xB8,
+0x89,0x20,0x31,0x30,
+0xE6,0x9C,0x88,0x20,
+0x32,0x38,0x20,0x31,
+0x37,0x3A,0x34,0x31,
+0x3A,0x34,0x37,0x20,
+0x43,0x53,0x54,0x20,
+0x32,0x30,0x30,0x39,
+0x0A,0x00,0x00,0x00,
+0x50,0xC6,0x01,0x80,
+0x48,0x43,0x49,0x20,
+0x74,0x79,0x70,0x65,
+0x3A,0x20,0x25,0x78,
+0x28,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x72,0x66,0x5F,0x63,
+0x6F,0x66,0x69,0x67,
+0x3A,0x20,0x25,0x78,
+0x28,0x25,0x78,0x2C,
+0x20,0x25,0x78,0x2C,
+0x20,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x6D,0x70,0x5F,0x6D,
+0x6F,0x64,0x65,0x3A,
+0x20,0x25,0x78,0x28,
+0x25,0x78,0x29,0x2C,
+0x20,0x49,0x51,0x4B,
+0x3A,0x20,0x25,0x78,
+0x0A,0x00,0x00,0x00,
+0x76,0x63,0x73,0x20,
+0x74,0x79,0x70,0x65,
+0x3A,0x20,0x25,0x78,
+0x28,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x33,0x32,0x6B,0x20,
+0x63,0x61,0x6C,0x69,
+0x62,0x72,0x61,0x3A,
+0x20,0x25,0x64,0x2C,
+0x20,0x33,0x32,0x4B,
+0x20,0x54,0x53,0x46,
+0x3A,0x20,0x25,0x78,
+0x00,0x00,0x00,0x00,
+0x74,0x61,0x72,0x67,
+0x65,0x74,0x20,0x74,
+0x68,0x65,0x72,0x6D,
+0x61,0x6C,0x3A,0x20,
+0x25,0x78,0x0A,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x00,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x01,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x02,0x7E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x03,0x7D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x04,0x7C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x05,0x7B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x06,0x7A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x07,0x79,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x08,0x78,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x09,0x77,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0A,0x76,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0B,0x75,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0C,0x74,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0D,0x73,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0E,0x72,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x0F,0x71,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x10,0x70,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x11,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x12,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x13,0x6E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x14,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x15,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x16,0x6C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x17,0x6B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x18,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x19,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1A,0x69,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1B,0x68,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1C,0x67,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1D,0x66,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1E,0x65,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x1F,0x64,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x20,0x63,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x21,0x4C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x22,0x4B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x23,0x4A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x24,0x49,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x25,0x48,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x26,0x47,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x27,0x46,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x28,0x45,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x29,0x44,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2A,0x2C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2B,0x2B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2C,0x2A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2D,0x29,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2E,0x28,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x2F,0x27,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x30,0x26,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x31,0x25,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x32,0x24,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x33,0x23,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x34,0x22,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x35,0x09,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x36,0x08,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x37,0x07,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x38,0x06,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x39,0x05,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3A,0x04,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3B,0x03,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3C,0x02,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3D,0x01,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3E,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x3F,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x40,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x41,0x7F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x42,0x7E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x43,0x7D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x44,0x7C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x45,0x7B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x46,0x7A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x47,0x79,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x48,0x78,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x49,0x77,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4A,0x76,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4B,0x75,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4C,0x74,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4D,0x73,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4E,0x72,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x4F,0x71,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x50,0x70,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x51,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x52,0x6F,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x53,0x6E,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x54,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x55,0x6D,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x56,0x6C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x57,0x6B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x58,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x59,0x6A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5A,0x69,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5B,0x68,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5C,0x67,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5D,0x66,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5E,0x65,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x5F,0x64,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x60,0x63,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x61,0x4C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x62,0x4B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x63,0x4A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x64,0x49,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x65,0x48,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x66,0x47,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x67,0x46,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x68,0x45,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x69,0x44,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6A,0x2C,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6B,0x2B,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6C,0x2A,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6D,0x29,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6E,0x28,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x6F,0x27,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x70,0x26,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x71,0x25,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x72,0x24,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x73,0x23,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x74,0x22,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x75,0x09,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x76,0x08,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x77,0x07,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x78,0x06,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x79,0x05,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7A,0x04,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7B,0x03,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7C,0x02,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7D,0x01,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7E,0x00,
+0x78,0x0C,0x00,0x00,
+0x01,0x00,0x7F,0x00,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x00,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x01,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x02,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x03,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x04,0x30,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x05,0x34,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x06,0x38,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x07,0x3E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x08,0x3E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x09,0x44,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0A,0x46,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0B,0x48,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0C,0x48,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0D,0x4E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0E,0x56,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x0F,0x5A,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x10,0x5E,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x11,0x62,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x12,0x6C,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x13,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x14,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x15,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x16,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x17,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x18,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x19,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1A,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1B,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1C,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1D,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1E,0x72,
+0x78,0x0C,0x00,0x00,
+0x1E,0x00,0x1F,0x72,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x06,0x06,0x06,0x04,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x04,0x02,0x02,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x0A,0x08,0x08,0x04,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x04,0x02,0x02,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x0A,0x08,0x08,0x04,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x04,0x02,0x02,0x00,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x00,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x08,0x0E,0x00,0x00,
+0x00,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x14,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x18,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x1C,0x0E,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x00,
+0x04,0x08,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x24,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x2C,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x70,0x08,0x00,0x00,
+0x00,0x00,0x00,0x04,
+0x01,0x00,0x00,0x00,
+0x64,0x08,0x00,0x00,
+0x00,0x04,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x78,0x08,0x00,0x00,
+0x0F,0x00,0x0F,0x00,
+0x02,0x00,0x02,0x00,
+0x74,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x78,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x7C,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x80,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x06,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x04,0x0C,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0xF4,0x01,0x00,0x00,
+0x00,0x00,0xFF,0xFF,
+0xFF,0xFF,0x00,0x00,
+0x34,0x02,0x00,0x00,
+0x00,0x00,0x00,0xF8,
+0x13,0x00,0x00,0x00,
+0x04,0x08,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x24,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x2C,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x02,0x00,0x30,0x00,
+0x70,0x08,0x00,0x00,
+0x00,0x00,0x00,0x04,
+0x01,0x00,0x00,0x00,
+0x64,0x08,0x00,0x00,
+0x00,0x04,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x78,0x08,0x00,0x00,
+0x0F,0x00,0x0F,0x00,
+0x02,0x00,0x00,0x00,
+0x74,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x78,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x7C,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x80,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x11,0x00,0x00,0x00,
+0x04,0x0C,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0xF4,0x01,0x00,0x00,
+0x00,0x00,0xFF,0xFF,
+0x77,0x77,0x00,0x00,
+0x34,0x02,0x00,0x00,
+0x00,0x00,0x00,0xF8,
+0x0A,0x00,0x00,0x00,
+0x44,0x08,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x01,0x00,
+0x04,0x08,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x24,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x04,0x00,0x30,0x00,
+0x2C,0x08,0x00,0x00,
+0x0F,0x00,0xF0,0x00,
+0x02,0x00,0x10,0x00,
+0x70,0x08,0x00,0x00,
+0x00,0x00,0x00,0x04,
+0x01,0x00,0x00,0x00,
+0x64,0x08,0x00,0x00,
+0x00,0x04,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x78,0x08,0x00,0x00,
+0x0F,0x00,0x0F,0x00,
+0x02,0x00,0x00,0x00,
+0x74,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x78,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x7C,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x80,0x0E,0x00,0x00,
+0x00,0x00,0x00,0x0F,
+0x02,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x11,0x00,0x00,0x00,
+0x04,0x0C,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x11,0x00,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x0F,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0xF4,0x01,0x00,0x00,
+0x00,0x00,0xFF,0xFF,
+0x77,0x77,0x00,0x00,
+0x34,0x02,0x00,0x00,
+0x00,0x00,0x00,0xF8,
+0x0A,0x00,0x00,0x00,
+0x1C,0x00,0x00,0x00,
+0x00,0x00,0x00,0x07,
+0x00,0x08,0x00,0x00,
+0x00,0x00,0x04,0x00,
+0x04,0x08,0x00,0x00,
+0x03,0x80,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x00,0xFC,0x00,0x00,
+0x0C,0x08,0x00,0x00,
+0x0A,0x00,0x00,0x00,
+0x10,0x08,0x00,0x00,
+0x88,0x50,0x00,0x10,
+0x14,0x08,0x00,0x00,
+0x10,0x3D,0x0C,0x02,
+0x18,0x08,0x00,0x00,
+0x85,0x01,0x20,0x00,
+0x1C,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x20,0x08,0x00,0x00,
+0x00,0x00,0x00,0x01,
+0x24,0x08,0x00,0x00,
+0x04,0x00,0x39,0x00,
+0x28,0x08,0x00,0x00,
+0x00,0x00,0x00,0x01,
+0x2C,0x08,0x00,0x00,
+0x04,0x00,0x39,0x00,
+0x30,0x08,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x34,0x08,0x00,0x00,
+0x00,0x02,0x69,0x00,
+0x38,0x08,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x3C,0x08,0x00,0x00,
+0x00,0x02,0x69,0x00,
+0x40,0x08,0x00,0x00,
+0x00,0x00,0x01,0x00,
+0x44,0x08,0x00,0x00,
+0x00,0x00,0x01,0x00,
+0x48,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x4C,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x50,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x54,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x58,0x08,0x00,0x00,
+0x48,0x48,0x48,0x48,
+0x5C,0x08,0x00,0x00,
+0xA9,0x65,0xA9,0x65,
+0x60,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x64,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x68,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x6C,0x08,0x00,0x00,
+0x30,0x01,0x7F,0x0F,
+0x70,0x08,0x00,0x00,
+0x00,0x07,0x00,0x03,
+0x74,0x08,0x00,0x00,
+0x00,0x03,0x00,0x03,
+0x78,0x08,0x00,0x00,
+0x02,0x00,0x02,0x00,
+0x7C,0x08,0x00,0x00,
+0x01,0x02,0x4F,0x00,
+0x80,0x08,0x00,0x00,
+0xC1,0x0A,0x30,0xA8,
+0x84,0x08,0x00,0x00,
+0x58,0x00,0x00,0x00,
+0x88,0x08,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x8C,0x08,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x90,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x94,0x08,0x00,0x00,
+0xFE,0xFF,0xFF,0xFF,
+0x98,0x08,0x00,0x00,
+0x10,0x20,0x30,0x40,
+0x9C,0x08,0x00,0x00,
+0x50,0x60,0x70,0x00,
+0xB0,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xE0,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xE4,0x08,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x0E,0x00,0x00,
+0x33,0x33,0x33,0x30,
+0x04,0x0E,0x00,0x00,
+0x2F,0x2E,0x2D,0x2A,
+0x08,0x0E,0x00,0x00,
+0x32,0x32,0x00,0x00,
+0x10,0x0E,0x00,0x00,
+0x33,0x33,0x33,0x30,
+0x14,0x0E,0x00,0x00,
+0x2F,0x2E,0x2D,0x2A,
+0x18,0x0E,0x00,0x00,
+0x33,0x33,0x33,0x30,
+0x1C,0x0E,0x00,0x00,
+0x2F,0x2E,0x2D,0x2A,
+0x30,0x0E,0x00,0x00,
+0x00,0x7C,0x00,0x01,
+0x34,0x0E,0x00,0x00,
+0x00,0x48,0x00,0x01,
+0x38,0x0E,0x00,0x00,
+0x1F,0xDC,0x00,0x10,
+0x3C,0x0E,0x00,0x00,
+0x1F,0x8C,0x00,0x10,
+0x40,0x0E,0x00,0x00,
+0xA0,0x00,0x14,0x02,
+0x44,0x0E,0x00,0x00,
+0xA0,0x00,0x16,0x28,
+0x48,0x0E,0x00,0x00,
+0x01,0x00,0x00,0xF8,
+0x4C,0x0E,0x00,0x00,
+0x10,0x29,0x00,0x00,
+0x50,0x0E,0x00,0x00,
+0x00,0x7C,0x00,0x01,
+0x54,0x0E,0x00,0x00,
+0x00,0x48,0x00,0x01,
+0x58,0x0E,0x00,0x00,
+0x1F,0xDC,0x00,0x10,
+0x5C,0x0E,0x00,0x00,
+0x1F,0x8C,0x00,0x10,
+0x60,0x0E,0x00,0x00,
+0xA0,0x00,0x14,0x02,
+0x64,0x0E,0x00,0x00,
+0xA0,0x00,0x16,0x28,
+0x6C,0x0E,0x00,0x00,
+0x10,0x29,0x00,0x00,
+0x70,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0x74,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x78,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x7C,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x80,0x0E,0x00,0x00,
+0xFB,0x36,0x15,0x36,
+0x84,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0x88,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0x8C,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0xD0,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0xD4,0x0E,0x00,0x00,
+0xFB,0x92,0xED,0x31,
+0xD8,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0xDC,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0xE0,0x0E,0x00,0x00,
+0xFB,0x92,0x0D,0x00,
+0xE4,0x0E,0x00,0x00,
+0x48,0x54,0x5E,0x01,
+0xE8,0x0E,0x00,0x00,
+0x48,0x54,0x55,0x21,
+0x00,0x09,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x04,0x09,0x00,0x00,
+0x23,0x00,0x00,0x00,
+0x08,0x09,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x0C,0x09,0x00,0x00,
+0x13,0x13,0x12,0x01,
+0x00,0x0A,0x00,0x00,
+0xC8,0x47,0xD0,0x00,
+0x04,0x0A,0x00,0x00,
+0x08,0x00,0xFF,0x80,
+0x08,0x0A,0x00,0x00,
+0x00,0x83,0xCD,0x88,
+0x0C,0x0A,0x00,0x00,
+0x0F,0x12,0x62,0x2E,
+0x10,0x0A,0x00,0x00,
+0x78,0xBB,0x00,0x95,
+0x14,0x0A,0x00,0x00,
+0x28,0x40,0x14,0x11,
+0x18,0x0A,0x00,0x00,
+0x17,0x11,0x88,0x00,
+0x1C,0x0A,0x00,0x00,
+0x00,0x0F,0x14,0x89,
+0x20,0x0A,0x00,0x00,
+0x00,0x00,0x1B,0x1A,
+0x24,0x0A,0x00,0x00,
+0x17,0x13,0x0E,0x09,
+0x28,0x0A,0x00,0x00,
+0x04,0x02,0x00,0x00,
+0x2C,0x0A,0x00,0x00,
+0x00,0x00,0xD3,0x10,
+0x00,0x0C,0x00,0x00,
+0x40,0x1D,0x07,0x40,
+0x04,0x0C,0x00,0x00,
+0x33,0x56,0xA0,0x00,
+0x08,0x0C,0x00,0x00,
+0xE4,0x00,0x00,0x00,
+0x0C,0x0C,0x00,0x00,
+0x6C,0x6C,0x6C,0x6C,
+0x10,0x0C,0x00,0x00,
+0x00,0x00,0x80,0x08,
+0x14,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x18,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x08,
+0x1C,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x20,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x08,
+0x24,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x28,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x08,
+0x2C,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x30,0x0C,0x00,0x00,
+0x44,0xAC,0xE9,0x6D,
+0x34,0x0C,0x00,0x00,
+0xCF,0x52,0x96,0x46,
+0x38,0x0C,0x00,0x00,
+0x94,0x59,0x79,0x49,
+0x3C,0x0C,0x00,0x00,
+0x64,0x97,0x97,0x0A,
+0x40,0x0C,0x00,0x00,
+0x3F,0x40,0x7C,0x1F,
+0x44,0x0C,0x00,0x00,
+0xB7,0x00,0x01,0x00,
+0x48,0x0C,0x00,0x00,
+0x00,0x00,0x02,0xEC,
+0x4C,0x0C,0x00,0x00,
+0x7F,0x03,0x7F,0x00,
+0x50,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x54,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x58,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x5C,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x60,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x64,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x68,0x0C,0x00,0x00,
+0x20,0x34,0x54,0x69,
+0x6C,0x0C,0x00,0x00,
+0x94,0x00,0x3C,0x43,
+0x70,0x0C,0x00,0x00,
+0x0D,0x00,0x7F,0x2C,
+0x74,0x0C,0x00,0x00,
+0x5B,0x17,0x86,0x01,
+0x78,0x0C,0x00,0x00,
+0x1F,0x00,0x00,0x00,
+0x7C,0x0C,0x00,0x00,
+0x12,0x16,0xB9,0x00,
+0x80,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x84,0x0C,0x00,0x00,
+0x00,0x00,0xF6,0x20,
+0x88,0x0C,0x00,0x00,
+0x80,0x00,0x00,0x20,
+0x8C,0x0C,0x00,0x00,
+0x00,0x00,0x20,0x20,
+0x90,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x94,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x98,0x0C,0x00,0x00,
+0x00,0x01,0x00,0x40,
+0x9C,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xA0,0x0C,0x00,0x00,
+0x92,0x24,0x49,0x00,
+0xA4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xA8,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xAC,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB0,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xB8,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xBC,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x28,
+0xC0,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xC4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xC8,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xCC,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xD0,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xD4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xD8,0x0C,0x00,0x00,
+0x27,0x24,0xB2,0x64,
+0xDC,0x0C,0x00,0x00,
+0x32,0x69,0x76,0x00,
+0xE0,0x0C,0x00,0x00,
+0x22,0x22,0x22,0x00,
+0xE4,0x0C,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xE8,0x0C,0x00,0x00,
+0x02,0x43,0x64,0x37,
+0xEC,0x0C,0x00,0x00,
+0x0C,0xD4,0x97,0x2F,
+0x00,0x0D,0x00,0x00,
+0x50,0x07,0x00,0x00,
+0x04,0x0D,0x00,0x00,
+0x03,0x04,0x00,0x00,
+0x08,0x0D,0x00,0x00,
+0x7F,0x90,0x00,0x00,
+0x0C,0x0D,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x10,0x0D,0x00,0x00,
+0x33,0x33,0x63,0xA0,
+0x14,0x0D,0x00,0x00,
+0x63,0x3C,0x33,0x33,
+0x18,0x0D,0x00,0x00,
+0x6B,0x5B,0x8F,0x6A,
+0x1C,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x20,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x24,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x28,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x2C,0x0D,0x00,0x00,
+0x75,0x99,0x97,0xCC,
+0x30,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x34,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x38,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x3C,0x0D,0x00,0x00,
+0x93,0x72,0x02,0x00,
+0x40,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x44,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x48,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x50,0x0D,0x00,0x00,
+0x0A,0x14,0x37,0x64,
+0x54,0x0D,0x00,0x00,
+0x02,0xBD,0x4D,0x02,
+0x58,0x0D,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x5C,0x0D,0x00,0x00,
+0x64,0x20,0x03,0x30,
+0x60,0x0D,0x00,0x00,
+0x68,0xDE,0x53,0x46,
+0x64,0x0D,0x00,0x00,
+0x3C,0x8A,0x51,0x00,
+0x68,0x0D,0x00,0x00,
+0x01,0x21,0x00,0x00,
+0x14,0x0F,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x4C,0x0F,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x0F,0x00,0x00,
+0x00,0x03,0x00,0x00,
+0x40,0x01,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x10,0x00,0x00,0x00,
+0x0C,0x02,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x3C,0x02,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x2C,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x34,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x3C,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x44,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x1C,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x24,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x7C,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x84,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0xE0,0x03,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0xD8,0x03,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x8C,0x08,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x94,0x08,0x01,0x80,
+0xDC,0x01,0x00,0x00,
+0x54,0x25,0x00,0x80,
+0x04,0x00,0x00,0x00,
+0x10,0x06,0x01,0x80,
+0xDC,0x01,0x00,0x00,
+0x54,0x25,0x00,0x80,
+0x04,0x00,0x00,0x00,
+0xD0,0x27,0x00,0x80,
+0x30,0x00,0x00,0x00,
+0xD8,0x27,0x00,0x80,
+0x04,0x00,0x00,0x00,
+0x64,0x2A,0x00,0x80,
+0x13,0x00,0x00,0x00,
+0xE8,0x06,0x01,0x80,
+0x17,0x00,0x00,0x00,
+0x3C,0x07,0x01,0x80,
+0x06,0x00,0x00,0x00,
+0xC4,0x07,0x01,0x80,
+0x06,0x00,0x00,0x00,
+0xCC,0x07,0x01,0x80,
+0x08,0x00,0x00,0x00,
+0xD4,0x07,0x01,0x80,
+0x0C,0x00,0x00,0x00,
+0xDC,0x07,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xE4,0x07,0x01,0x80,
+0x0E,0x00,0x00,0x00,
+0xEC,0x07,0x01,0x80,
+0x01,0x00,0x00,0x00,
+0xF4,0x07,0x01,0x80,
+0x38,0x00,0x00,0x00,
+0xFC,0x07,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x04,0x08,0x01,0x80,
+0x02,0x00,0x00,0x00,
+0x0C,0x08,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x14,0x08,0x01,0x80,
+0x01,0x00,0x00,0x00,
+0x54,0x08,0x01,0x80,
+0x01,0x00,0x00,0x00,
+0x5C,0x08,0x01,0x80,
+0x0C,0x00,0x00,0x00,
+0xE8,0x03,0x01,0x80,
+0x0E,0x00,0x00,0x00,
+0xF0,0x03,0x01,0x80,
+0x0C,0x00,0x00,0x00,
+0x08,0x06,0x01,0x80,
+0x34,0x00,0x00,0x00,
+0x64,0x08,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x6C,0x08,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x9C,0x08,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xA4,0x08,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xAC,0x08,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x74,0x08,0x01,0x80,
+0x08,0x00,0x00,0x00,
+0x40,0x03,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xB4,0x08,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x2C,0x09,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x38,0x09,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xEC,0x09,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x50,0x0C,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x60,0x0C,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xC8,0x0D,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0xF4,0x0E,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x30,0x10,0x01,0x80,
+0x04,0x00,0x00,0x00,
+0x48,0x12,0x01,0x80,
+0x51,0x73,0x65,0x6C,
+0x20,0x45,0x72,0x72,
+0x6F,0x72,0x2C,0x20,
+0x25,0x78,0x00,0x00,
+0x72,0x65,0x70,0x65,
+0x61,0x74,0x65,0x64,
+0x20,0x65,0x6C,0x65,
+0x6D,0x65,0x6E,0x74,
+0x20,0x49,0x44,0x3A,
+0x20,0x25,0x78,0x2C,
+0x20,0x63,0x6D,0x64,
+0x20,0x73,0x65,0x71,
+0x3D,0x25,0x78,0x2C,
+0x20,0x68,0x32,0x64,
+0x73,0x65,0x71,0x3D,
+0x25,0x78,0x0A,0x00,
+0x69,0x6E,0x76,0x61,
+0x6C,0x69,0x64,0x20,
+0x63,0x6D,0x64,0x20,
+0x69,0x64,0x3A,0x20,
+0x25,0x78,0x0A,0x00,
+0x48,0x32,0x43,0x3A,
+0x20,0x25,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x67,0x65,0x74,0x20,
+0x6A,0x6F,0x69,0x6E,
+0x20,0x63,0x6D,0x64,
+0x0A,0x00,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x67,0x65,0x74,0x20,
+0x73,0x75,0x72,0x76,
+0x65,0x79,0x20,0x63,
+0x6D,0x64,0x0A,0x00,
+0x53,0x53,0x49,0x44,
+0x3A,0x20,0x25,0x73,
+0x0A,0x00,0x00,0x00,
+0x73,0x65,0x74,0x41,
+0x75,0x74,0x68,0x3A,
+0x20,0x25,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x72,0x63,0x76,0x20,
+0x73,0x65,0x74,0x5F,
+0x73,0x74,0x61,0x6B,
+0x65,0x79,0x0A,0x00,
+0x53,0x65,0x74,0x53,
+0x69,0x6E,0x67,0x6C,
+0x65,0x43,0x61,0x72,
+0x72,0x69,0x65,0x72,
+0x54,0x78,0x5F,0x68,
+0x64,0x6C,0x0A,0x00,
+0x53,0x65,0x74,0x53,
+0x69,0x6E,0x67,0x6C,
+0x65,0x54,0x6F,0x6E,
+0x65,0x54,0x78,0x5F,
+0x68,0x64,0x6C,0x0A,
+0x00,0x00,0x00,0x00,
+0x53,0x65,0x74,0x43,
+0x61,0x72,0x72,0x69,
+0x65,0x72,0x53,0x75,
+0x70,0x70,0x72,0x65,
+0x73,0x73,0x69,0x6F,
+0x6E,0x54,0x78,0x5F,
+0x68,0x64,0x6C,0x0A,
+0x00,0x00,0x00,0x00,
+0x53,0x65,0x74,0x43,
+0x6F,0x6E,0x74,0x69,
+0x6E,0x75,0x6F,0x75,
+0x73,0x54,0x78,0x5F,
+0x68,0x64,0x6C,0x0A,
+0x00,0x00,0x00,0x00,
+0x53,0x65,0x74,0x43,
+0x43,0x4B,0x43,0x6F,
+0x6E,0x74,0x69,0x6E,
+0x75,0x6F,0x75,0x73,
+0x54,0x78,0x0A,0x00,
+0x53,0x65,0x74,0x4F,
+0x46,0x44,0x4D,0x43,
+0x6F,0x6E,0x74,0x69,
+0x6E,0x75,0x6F,0x75,
+0x73,0x54,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xF8,0x9E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xC8,0x5E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xF8,0x0E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xC8,0xCE,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xD4,0x8E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xA4,0x4E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xD0,0x0E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0xCE,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xD0,0x86,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0x46,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0x06,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xA4,0x9E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0x74,0x5E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xA4,0x0E,0x02,0x00,
+0x13,0x00,0x00,0x00,
+0xD0,0xCE,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x40,0x9F,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0x4E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0x06,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0xC6,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0xA0,0x82,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x70,0x42,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x40,0x02,0x00,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0xAA,0x88,0x88,0x44,
+0x44,0x22,0x22,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x03,0x00,
+0x01,0x00,0x00,0x00,
+0x41,0x10,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x00,0x10,0x01,0x00,
+0x05,0x00,0x00,0x00,
+0xC0,0x0F,0x08,0x00,
+0x07,0x00,0x00,0x00,
+0x03,0xC8,0x0F,0x00,
+0x13,0x00,0x00,0x00,
+0xB0,0x7C,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0xC0,0x1C,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x60,0xDC,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x60,0x8C,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x50,0x44,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x20,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x03,0x00,
+0x01,0x00,0x00,0x00,
+0x50,0x02,0x03,0x00,
+0x02,0x00,0x00,0x00,
+0x00,0x00,0x01,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x08,0x00,
+0x11,0x00,0x00,0x00,
+0xFC,0x31,0x02,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x0C,0x00,
+0x11,0x00,0x00,0x00,
+0xF8,0xF9,0x03,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x02,0x00,
+0x11,0x00,0x00,0x00,
+0x01,0x01,0x02,0x00,
+0x14,0x00,0x00,0x00,
+0x3E,0x09,0x01,0x00,
+0x14,0x00,0x00,0x00,
+0x3E,0x09,0x09,0x00,
+0x15,0x00,0x00,0x00,
+0xF4,0x98,0x01,0x00,
+0x17,0x00,0x00,0x00,
+0x00,0x65,0x0F,0x00,
+0x1A,0x00,0x00,0x00,
+0x56,0x30,0x01,0x00,
+0x1B,0x00,0x00,0x00,
+0x00,0x00,0x06,0x00,
+0x1C,0x00,0x00,0x00,
+0x00,0x03,0x00,0x00,
+0x1E,0x00,0x00,0x00,
+0x59,0x10,0x03,0x00,
+0x21,0x00,0x00,0x00,
+0x00,0x40,0x05,0x00,
+0x22,0x00,0x00,0x00,
+0x3C,0x08,0x00,0x00,
+0x23,0x00,0x00,0x00,
+0x58,0x15,0x00,0x00,
+0x24,0x00,0x00,0x00,
+0x60,0x00,0x00,0x00,
+0x25,0x00,0x00,0x00,
+0x83,0x25,0x02,0x00,
+0x26,0x00,0x00,0x00,
+0x00,0xF2,0x00,0x00,
+0x27,0x00,0x00,0x00,
+0xF1,0xAC,0x0E,0x00,
+0x28,0x00,0x00,0x00,
+0x54,0xBD,0x09,0x00,
+0x29,0x00,0x00,0x00,
+0x82,0x45,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x34,0x13,0x02,0x00,
+0x2A,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0C,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x03,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x08,0x08,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x05,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x06,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x07,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x09,0x07,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x09,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0A,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0B,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0C,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0A,0x06,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0xB3,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0B,0x05,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x33,0x33,0x05,0x00,
+0x2C,0x00,0x00,0x00,
+0x0D,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x0E,0x00,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x0B,0x05,0x00,0x00,
+0x2B,0x00,0x00,0x00,
+0x23,0x66,0x06,0x00,
+0x2C,0x00,0x00,0x00,
+0x1A,0x00,0x00,0x00,
+0x2A,0x00,0x00,0x00,
+0x00,0x40,0x0E,0x00,
+0x30,0x00,0x00,0x00,
+0x00,0x00,0x02,0x00,
+0x31,0x00,0x00,0x00,
+0x31,0x96,0x0B,0x00,
+0x32,0x00,0x00,0x00,
+0x0D,0x13,0x00,0x00,
+0x33,0x00,0x00,0x00,
+0x87,0x01,0x00,0x00,
+0x13,0x00,0x00,0x00,
+0x6C,0x9E,0x01,0x00,
+0x13,0x00,0x00,0x00,
+0x94,0x5E,0x01,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x01,0x00,
+0x18,0x00,0x00,0x00,
+0x01,0xF4,0x00,0x00,
+0xFE,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x1E,0x00,0x00,0x00,
+0x5B,0x10,0x03,0x00,
+0xFE,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x59,0x01,0x03,0x00,
+0x10,0x00,0x00,0x00,
+0x0F,0x00,0x04,0x00,
+0x11,0x00,0x00,0x00,
+0xF9,0x03,0x02,0x00,
+0x6C,0x09,0x00,0x00,
+0x01,0x02,0x03,0x04,
+0x05,0x06,0x07,0x08,
+0x09,0x0A,0x0B,0x00,
+0x00,0x00,0x00,0x12,
+0x12,0x12,0x12,0x12,
+0x12,0x12,0x12,0x12,
+0x12,0x12,0x00,0x00,
+0x00,0x00,0x0F,0x0F,
+0x0F,0x0F,0x0F,0x0F,
+0x0F,0x0F,0x0F,0x0F,
+0x0F,0x00,0x00,0x00,
+0x00,0x17,0x05,0x03,
+0x22,0x43,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x00,0x00,
+0x22,0x43,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x22,0x43,0x5E,0x00,
+0x4F,0xA4,0x3E,0x00,
+0x30,0xA6,0x00,0x00,
+0x4F,0xA4,0x3E,0x00,
+0x2B,0xA4,0x5E,0x00,
+0x2B,0xA4,0x00,0x00,
+0x2B,0xA4,0x5E,0x00,
+0x22,0xA4,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x4F,0xA4,0x00,0x00,
+0x4F,0xA4,0x5E,0x00,
+0x00,0xE0,0x4C,0x02,
+0x01,0x20,0x00,0x00,
+0x00,0xE0,0x4C,0x00,
+0x00,0x0C,0x43,0x00,
+0x00,0x50,0x43,0x00,
+0x00,0x40,0x96,0x00,
+0x00,0x05,0xB5,0x00,
+0x00,0x0A,0xF7,0x00,
+0x00,0x10,0x18,0x00,
+0x00,0x13,0x74,0x00,
+0x00,0x03,0x7F,0x00,
+0x00,0x50,0xF2,0x02,
+0x01,0x01,0x00,0x00,
+0x00,0x50,0xF2,0x02,
+0x00,0x01,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0xFF,0xFF,
+0xFF,0xFF,0x00,0x00,
+0x4F,0x6E,0x41,0x73,
+0x73,0x6F,0x63,0x52,
+0x65,0x71,0x00,0x00,
+0x4F,0x6E,0x41,0x73,
+0x73,0x6F,0x63,0x52,
+0x73,0x70,0x00,0x00,
+0x4F,0x6E,0x52,0x65,
+0x41,0x73,0x73,0x6F,
+0x63,0x52,0x65,0x71,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x52,0x65,
+0x41,0x73,0x73,0x6F,
+0x63,0x52,0x73,0x70,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x50,0x72,
+0x6F,0x62,0x65,0x52,
+0x65,0x71,0x00,0x00,
+0x4F,0x6E,0x50,0x72,
+0x6F,0x62,0x65,0x52,
+0x73,0x70,0x00,0x00,
+0x4F,0x6E,0x42,0x65,
+0x61,0x63,0x6F,0x6E,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x41,0x54,
+0x49,0x4D,0x00,0x00,
+0x4F,0x6E,0x44,0x69,
+0x73,0x61,0x73,0x73,
+0x6F,0x63,0x00,0x00,
+0x4F,0x6E,0x41,0x75,
+0x74,0x68,0x00,0x00,
+0x4F,0x6E,0x44,0x65,
+0x41,0x75,0x74,0x68,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x41,0x63,
+0x74,0x69,0x6F,0x6E,
+0x00,0x00,0x00,0x00,
+0x4F,0x6E,0x45,0x78,
+0x63,0x65,0x70,0x74,
+0x69,0x6F,0x6E,0x00,
+0x00,0x00,0x00,0x00,
+0xF8,0xDD,0x01,0x80,
+0xE8,0x26,0x01,0x80,
+0x10,0x00,0x00,0x00,
+0x04,0xDE,0x01,0x80,
+0xF0,0x26,0x01,0x80,
+0x20,0x00,0x00,0x00,
+0x10,0xDE,0x01,0x80,
+0xE8,0x26,0x01,0x80,
+0x30,0x00,0x00,0x00,
+0x20,0xDE,0x01,0x80,
+0xF0,0x26,0x01,0x80,
+0x40,0x00,0x00,0x00,
+0x30,0xDE,0x01,0x80,
+0x80,0x2D,0x01,0x80,
+0x50,0x00,0x00,0x00,
+0x3C,0xDE,0x01,0x80,
+0x28,0x4A,0x00,0x80,
+0x80,0x00,0x00,0x00,
+0x48,0xDE,0x01,0x80,
+0x90,0x59,0x00,0x80,
+0x90,0x00,0x00,0x00,
+0x54,0xDE,0x01,0x80,
+0x44,0x2E,0x01,0x80,
+0xA0,0x00,0x00,0x00,
+0x5C,0xDE,0x01,0x80,
+0x4C,0x2E,0x01,0x80,
+0xB0,0x00,0x00,0x00,
+0x68,0xDE,0x01,0x80,
+0x54,0x2F,0x01,0x80,
+0xC0,0x00,0x00,0x00,
+0x70,0xDE,0x01,0x80,
+0x6C,0x2E,0x01,0x80,
+0xD0,0x00,0x00,0x00,
+0x7C,0xDE,0x01,0x80,
+0xF0,0x54,0x00,0x80,
+0x0C,0x00,0x00,0x00,
+0x88,0xDE,0x01,0x80,
+0x8C,0x2E,0x01,0x80,
+0x73,0x77,0x69,0x74,
+0x63,0x68,0x20,0x74,
+0x6F,0x20,0x34,0x30,
+0x4D,0x20,0x48,0x7A,
+0x20,0x6D,0x6F,0x64,
+0x65,0x28,0x25,0x78,
+0x2C,0x20,0x25,0x78,
+0x29,0x0A,0x00,0x00,
+0x73,0x77,0x69,0x74,
+0x63,0x68,0x20,0x74,
+0x6F,0x20,0x32,0x30,
+0x4D,0x20,0x48,0x7A,
+0x20,0x6D,0x6F,0x64,
+0x65,0x0A,0x00,0x00,
+0x41,0x54,0x49,0x4D,
+0x3A,0x20,0x25,0x78,
+0x0A,0x00,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x73,0x75,0x72,0x76,
+0x65,0x79,0x20,0x64,
+0x6F,0x6E,0x65,0x28,
+0x25,0x78,0x2C,0x20,
+0x25,0x78,0x29,0x0A,
+0x00,0x00,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x6A,0x6F,0x69,0x6E,
+0x20,0x72,0x65,0x73,
+0x28,0x25,0x78,0x29,
+0x0A,0x00,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x64,0x65,0x6C,0x20,
+0x73,0x74,0x61,0x0A,
+0x00,0x00,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x61,0x64,0x64,0x20,
+0x73,0x74,0x61,0x3A,
+0x25,0x78,0x2C,0x20,
+0x25,0x78,0x0A,0x00,
+0x72,0x63,0x76,0x20,
+0x64,0x69,0x73,0x63,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x0A,0x00,
+0x64,0x69,0x73,0x63,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x20,0x74,
+0x69,0x6D,0x65,0x72,
+0x3A,0x20,0x6E,0x6F,
+0x20,0x62,0x65,0x61,
+0x63,0x6F,0x6E,0x0A,
+0x00,0x00,0x00,0x00,
+0x64,0x69,0x73,0x63,
+0x6F,0x6E,0x6E,0x65,
+0x63,0x74,0x20,0x74,
+0x69,0x6D,0x65,0x72,
+0x0A,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x40,
+0x25,0x73,0x0A,0x00,
+0x57,0x4D,0x4D,0x28,
+0x25,0x78,0x29,0x3A,
+0x20,0x25,0x78,0x2C,
+0x20,0x25,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x61,0x73,0x73,0x6F,
+0x63,0x20,0x72,0x65,
+0x6A,0x65,0x63,0x74,
+0x2C,0x20,0x73,0x74,
+0x61,0x74,0x75,0x73,
+0x3A,0x20,0x25,0x64,
+0x0A,0x00,0x00,0x00,
+0x6D,0x61,0x63,0x20,
+0x69,0x64,0x20,0x23,
+0x34,0x3A,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x6D,0x61,0x63,0x20,
+0x69,0x64,0x20,0x23,
+0x35,0x3A,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x40,
+0x25,0x73,0x0A,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x63,0x75,0x72,0x20,
+0x63,0x68,0x61,0x6E,
+0x6E,0x65,0x6C,0x3A,
+0x20,0x25,0x78,0x2C,
+0x20,0x62,0x63,0x6E,
+0x20,0x69,0x6E,0x74,
+0x65,0x72,0x76,0x61,
+0x6C,0x3A,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x49,0x42,0x53,0x53,
+0x20,0x6D,0x6F,0x64,
+0x65,0x2C,0x20,0x63,
+0x75,0x72,0x20,0x63,
+0x68,0x61,0x6E,0x6E,
+0x65,0x6C,0x3A,0x20,
+0x25,0x78,0x2C,0x20,
+0x62,0x63,0x6E,0x20,
+0x69,0x6E,0x74,0x65,
+0x72,0x76,0x61,0x6C,
+0x3A,0x20,0x25,0x78,
+0x0A,0x00,0x00,0x00,
+0x6D,0x61,0x63,0x20,
+0x69,0x64,0x20,0x23,
+0x34,0x3A,0x20,0x25,
+0x78,0x2C,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x69,0x6E,0x76,0x61,
+0x6C,0x69,0x64,0x20,
+0x63,0x61,0x70,0x3A,
+0x25,0x78,0x0A,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x61,0x73,
+0x73,0x6F,0x63,0x72,
+0x65,0x71,0x28,0x25,
+0x78,0x29,0x0A,0x00,
+0x5B,0x57,0x41,0x50,
+0x49,0x5D,0x20,0x67,
+0x65,0x74,0x20,0x77,
+0x61,0x70,0x69,0x20,
+0x49,0x45,0x0A,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x61,0x63,
+0x74,0x69,0x6F,0x6E,
+0x3A,0x20,0x25,0x78,
+0x2C,0x20,0x25,0x78,
+0x2C,0x20,0x25,0x78,
+0x20,0x0A,0x00,0x00,
+0x41,0x44,0x44,0x42,
+0x41,0x20,0x52,0x53,
+0x50,0x3A,0x20,0x25,
+0x78,0x0A,0x00,0x00,
+0x44,0x45,0x4C,0x42,
+0x41,0x3A,0x20,0x25,
+0x78,0x28,0x25,0x78,
+0x29,0x0A,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x61,0x75,
+0x74,0x68,0x0A,0x00,
+0x63,0x6C,0x6E,0x74,
+0x20,0x61,0x75,0x74,
+0x68,0x20,0x66,0x61,
+0x69,0x6C,0x2C,0x20,
+0x73,0x74,0x61,0x74,
+0x75,0x73,0x3A,0x20,
+0x25,0x64,0x0A,0x00,
+0x6E,0x6F,0x20,0x63,
+0x68,0x61,0x6C,0x6C,
+0x65,0x6E,0x67,0x65,
+0x20,0x74,0x65,0x78,
+0x74,0x3F,0x0A,0x00,
+0x63,0x6C,0x6E,0x74,
+0x20,0x61,0x75,0x74,
+0x68,0x20,0x66,0x61,
+0x69,0x6C,0x65,0x64,
+0x20,0x64,0x75,0x65,
+0x20,0x74,0x6F,0x20,
+0x69,0x6C,0x6C,0x65,
+0x67,0x61,0x6C,0x20,
+0x73,0x65,0x71,0x3D,
+0x25,0x78,0x0A,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x64,0x65,
+0x61,0x75,0x74,0x68,
+0x0A,0x00,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x64,0x69,
+0x73,0x61,0x73,0x73,
+0x6F,0x63,0x0A,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x4E,0x6F,0x20,0x69,
+0x72,0x70,0x20,0x25,
+0x73,0x0A,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x20,0x6E,0x75,
+0x6C,0x6C,0x20,0x64,
+0x61,0x74,0x61,0x28,
+0x25,0x64,0x29,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x41,0x72,0x74,0x68,
+0x65,0x72,0x6F,0x73,
+0x20,0x41,0x50,0x0A,
+0x00,0x00,0x00,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x42,0x72,0x6F,0x61,
+0x64,0x63,0x6F,0x6D,
+0x20,0x41,0x50,0x0A,
+0x00,0x00,0x00,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x4D,0x61,0x72,0x76,
+0x65,0x6C,0x6C,0x20,
+0x41,0x50,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x52,0x61,0x6C,0x69,
+0x6E,0x6B,0x20,0x41,
+0x50,0x0A,0x00,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x43,0x69,0x73,0x63,
+0x6F,0x20,0x41,0x50,
+0x0A,0x00,0x00,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x52,0x65,0x61,0x6C,
+0x74,0x65,0x6B,0x20,
+0x39,0x36,0x42,0x20,
+0x41,0x50,0x0A,0x00,
+0x6C,0x69,0x6E,0x6B,
+0x20,0x74,0x6F,0x20,
+0x75,0x6E,0x6B,0x6E,
+0x6F,0x77,0x6E,0x20,
+0x41,0x50,0x0A,0x00,
+0x6D,0x61,0x63,0x20,
+0x69,0x64,0x20,0x23,
+0x25,0x78,0x3A,0x20,
+0x25,0x78,0x2C,0x20,
+0x25,0x78,0x0A,0x00,
+0x64,0x72,0x6F,0x70,
+0x20,0x64,0x75,0x65,
+0x20,0x74,0x6F,0x20,
+0x64,0x65,0x63,0x61,
+0x63,0x68,0x65,0x0A,
+0x00,0x00,0x00,0x00,
+0xFF,0x00,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xFF,0xFF,0x00,0x00,
+0x01,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x02,0x03,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x02,0x03,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0xFF,0x00,0x00,0x00,
+0x04,0x05,0x06,0x07,
+0x08,0x09,0x0A,0x0B,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x04,0x05,0x06,0x07,
+0x08,0xFF,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x02,0x03,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x01,0x01,0x03,
+0xFF,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x30,0x31,0x32,0x33,
+0x34,0x35,0x36,0x37,
+0x38,0x39,0x41,0x42,
+0x43,0x44,0x45,0x46,
+0x00,0x00,0x00,0x00,
+0x25,0x64,0x2E,0x00,
+0x25,0x68,0x68,0x58,
+0x3A,0x00,0x00,0x00,
+0x74,0x61,0x72,0x67,
+0x65,0x74,0x20,0x74,
+0x68,0x65,0x72,0x6D,
+0x61,0x6C,0x3A,0x20,
+0x25,0x78,0x2C,0x20,
+0x63,0x75,0x72,0x20,
+0x74,0x68,0x65,0x72,
+0x6D,0x61,0x6C,0x3A,
+0x20,0x25,0x78,0x0A,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x08,0xE4,0x01,0x80,
+0x08,0xE4,0x01,0x80,
+0x31,0x10,0x10,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x20,0x10,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x28,0x10,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x2C,0x10,0x10,
+0x00,0x30,0x00,0x00,
+0x31,0x2F,0x10,0x10,
+0x00,0x30,0x00,0x00,
+0x31,0x30,0x18,0x00,
+0x00,0x30,0x00,0x00,
+0x31,0x30,0x20,0x10,
+0x00,0x30,0x00,0x00,
+0x22,0x20,0x18,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x14,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x1C,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x20,0x08,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x20,0x10,
+0x00,0x20,0x00,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x20,0x00,0x00,
+0x1A,0x19,0x18,0x10,
+0x00,0x18,0x00,0x00,
+0x12,0x11,0x10,0x08,
+0x00,0x10,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x02,
+0x00,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x06,
+0x00,0x08,0x00,0x00,
+0x08,0x07,0x06,0x04,
+0x00,0x06,0x00,0x00,
+0x06,0x05,0x04,0x02,
+0x00,0x04,0x00,0x00,
+0x06,0x05,0x04,0x03,
+0x00,0x04,0x00,0x00,
+0x05,0x04,0x03,0x02,
+0x00,0x03,0x00,0x00,
+0x09,0x08,0x07,0x06,
+0x07,0x06,0x06,0x05,
+0x05,0x04,0x04,0x03,
+0x06,0x05,0x05,0x04,
+0x04,0x03,0x03,0x03,
+0x05,0x04,0x04,0x03,
+0x03,0x02,0x02,0x02,
+0x00,0x09,0x08,0x07,
+0x06,0x07,0x06,0x06,
+0x05,0x05,0x04,0x04,
+0x03,0x05,0x04,0x04,
+0x03,0x03,0x02,0x02,
+0x02,0x04,0x03,0x03,
+0x02,0x02,0x01,0x01,
+0x01,0x00,0x00,0x00,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x10,0x10,0x20,
+0x08,0x08,0x08,0x08,
+0x20,0x20,0x20,0x20,
+0x08,0x08,0x08,0x08,
+0x08,0x20,0x20,0x20,
+0x30,0x08,0x08,0x08,
+0x08,0x18,0x18,0x18,
+0x18,0x18,0x20,0x30,
+0x30,0x10,0x20,0x20,
+0x20,0x20,0x20,0x30,
+0x30,0x08,0x10,0x20,
+0x30,0x30,0x30,0x30,
+0x30,0x30,0x00,0x00,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x10,0x10,0x20,
+0x08,0x08,0x08,0x08,
+0x08,0x20,0x20,0x20,
+0x08,0x08,0x08,0x08,
+0x08,0x20,0x20,0x20,
+0x20,0x08,0x08,0x08,
+0x08,0x18,0x18,0x18,
+0x18,0x18,0x20,0x30,
+0x30,0x10,0x20,0x20,
+0x20,0x20,0x20,0x30,
+0x30,0x08,0x10,0x20,
+0x30,0x30,0x30,0x30,
+0x30,0x30,0x00,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x0A,0x09,
+0x08,0x00,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x0A,0x09,
+0x08,0x00,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x22,0x21,0x20,
+0x18,0x00,0x22,0x21,
+0x1C,0x08,0x00,0x22,
+0x20,0x18,0x08,0x00,
+0x0A,0x09,0x08,0x02,
+0x00,0x0A,0x09,0x08,
+0x02,0x00,0x0A,0x09,
+0x08,0x02,0x00,0x0A,
+0x09,0x08,0x02,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x22,0x21,0x20,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x22,
+0x21,0x1C,0x08,0x00,
+0x31,0x30,0x18,0x00,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x1A,0x19,
+0x18,0x10,0x00,0x1A,
+0x19,0x18,0x10,0x00,
+0x1A,0x19,0x18,0x10,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x31,
+0x2C,0x10,0x10,0x00,
+0x31,0x28,0x10,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x22,0x21,
+0x20,0x18,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x08,
+0x00,0x22,0x21,0x14,
+0x08,0x00,0x22,0x20,
+0x18,0x08,0x00,0x31,
+0x30,0x20,0x10,0x00,
+0x31,0x2C,0x10,0x10,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x31,0x30,0x20,
+0x10,0x00,0x31,0x2F,
+0x10,0x10,0x00,0x31,
+0x2F,0x10,0x10,0x00,
+0x31,0x10,0x10,0x00,
+0x00,0x31,0x2C,0x10,
+0x10,0x00,0x00,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x0A,0x09,
+0x08,0x00,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x02,0x00,0x0A,
+0x09,0x08,0x00,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x22,0x21,0x20,
+0x18,0x00,0x22,0x21,
+0x1C,0x08,0x00,0x22,
+0x21,0x14,0x08,0x00,
+0x0A,0x09,0x08,0x02,
+0x00,0x0A,0x09,0x08,
+0x02,0x00,0x0A,0x09,
+0x08,0x02,0x00,0x0A,
+0x09,0x08,0x02,0x00,
+0x0A,0x09,0x08,0x00,
+0x00,0x22,0x21,0x20,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x22,
+0x21,0x14,0x08,0x00,
+0x22,0x21,0x14,0x08,
+0x00,0x0A,0x09,0x08,
+0x04,0x00,0x0A,0x09,
+0x08,0x04,0x00,0x0A,
+0x09,0x08,0x04,0x00,
+0x0A,0x09,0x08,0x04,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x1A,0x19,
+0x18,0x10,0x00,0x1A,
+0x19,0x18,0x10,0x00,
+0x1A,0x19,0x18,0x10,
+0x00,0x1A,0x19,0x18,
+0x10,0x00,0x22,0x21,
+0x20,0x08,0x00,0x31,
+0x2C,0x10,0x10,0x00,
+0x31,0x28,0x10,0x00,
+0x00,0x12,0x11,0x10,
+0x08,0x00,0x22,0x21,
+0x20,0x18,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x08,
+0x00,0x22,0x21,0x14,
+0x08,0x00,0x22,0x20,
+0x18,0x08,0x00,0x31,
+0x30,0x20,0x10,0x00,
+0x31,0x2C,0x10,0x10,
+0x00,0x0A,0x09,0x08,
+0x00,0x00,0x12,0x11,
+0x10,0x08,0x00,0x22,
+0x21,0x20,0x18,0x00,
+0x22,0x21,0x20,0x18,
+0x00,0x31,0x30,0x20,
+0x10,0x00,0x31,0x2F,
+0x10,0x10,0x00,0x31,
+0x2F,0x10,0x10,0x00,
+0x31,0x10,0x10,0x00,
+0x00,0x31,0x2C,0x10,
+0x10,0x00,0x00,0x00,
+0x01,0x02,0x04,0x08,
+0x02,0x04,0x08,0x0C,
+0x10,0x18,0x20,0x30,
+0x02,0x04,0x08,0x0C,
+0x10,0x18,0x20,0x30,
+0x06,0x0C,0x10,0x18,
+0x24,0x30,0x3C,0x48,
+0x48,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x25,0x27,0x2C,
+0x19,0x1B,0x1E,0x20,
+0x23,0x29,0x2A,0x2B,
+0x00,0x00,0x00,0x00,
+0x25,0x29,0x2B,0x2E,
+0x2E,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x10,0x00,0x00,0x00,
+0x18,0x00,0x00,0x00,
+0x24,0x00,0x00,0x00,
+0x30,0x00,0x00,0x00,
+0x48,0x00,0x00,0x00,
+0x60,0x00,0x00,0x00,
+0x90,0x00,0x00,0x00,
+0xC0,0x00,0x00,0x00,
+0xD8,0x00,0x00,0x00,
+0x50,0x00,0x00,0x00,
+0x78,0x00,0x00,0x00,
+0xA0,0x00,0x00,0x00,
+0xC8,0x00,0x00,0x00,
+0x40,0x01,0x00,0x00,
+0x90,0x01,0x00,0x00,
+0xE0,0x01,0x00,0x00,
+0x30,0x02,0x00,0x00,
+0x2C,0x01,0x00,0x00,
+0x40,0x01,0x00,0x00,
+0xE0,0x01,0x00,0x00,
+0xD0,0x02,0x00,0x00,
+0x80,0x0C,0x00,0x00,
+0x80,0x0C,0x00,0x00,
+0x80,0x0C,0x00,0x00,
+0xA0,0x0F,0x00,0x00,
+0xA0,0x0F,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x02,0x00,0x00,0x00,
+0x04,0x00,0x00,0x00,
+0x08,0x00,0x00,0x00,
+0x0C,0x00,0x00,0x00,
+0x12,0x00,0x00,0x00,
+0x18,0x00,0x00,0x00,
+0x24,0x00,0x00,0x00,
+0x30,0x00,0x00,0x00,
+0x48,0x00,0x00,0x00,
+0x60,0x00,0x00,0x00,
+0x6C,0x00,0x00,0x00,
+0x28,0x00,0x00,0x00,
+0x3C,0x00,0x00,0x00,
+0x50,0x00,0x00,0x00,
+0x64,0x00,0x00,0x00,
+0xA0,0x00,0x00,0x00,
+0xC8,0x00,0x00,0x00,
+0xF0,0x00,0x00,0x00,
+0x18,0x01,0x00,0x00,
+0x64,0x00,0x00,0x00,
+0xA0,0x00,0x00,0x00,
+0xF0,0x00,0x00,0x00,
+0x68,0x01,0x00,0x00,
+0x40,0x06,0x00,0x00,
+0x40,0x06,0x00,0x00,
+0x40,0x06,0x00,0x00,
+0xD0,0x07,0x00,0x00,
+0xD0,0x07,0x00,0x00,
+0x72,0x65,0x73,0x65,
+0x74,0x28,0x25,0x78,
+0x29,0x0A,0x00,0x00,
+0xC8,0x82,0x01,0x80,
+0xC8,0xD0,0x00,0x80,
+0xC8,0xD0,0x00,0x80,
+0xC8,0xD0,0x00,0x80,
+0xC8,0xD0,0x00,0x80,
+0x14,0xCF,0x00,0x80,
+0xD0,0x82,0x01,0x80,
+0xC8,0x82,0x01,0x80,
+0xC8,0x82,0x01,0x80,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xF0,0x85,0x01,0x80,
+0xF0,0x85,0x01,0x80,
+0xF0,0x85,0x01,0x80,
+0xF0,0x85,0x01,0x80,
+0xA8,0x82,0x01,0x80,
+0x00,0x85,0x01,0x80,
+0xB0,0x82,0x01,0x80,
+0xB8,0x82,0x01,0x80,
+0xC0,0x82,0x01,0x80,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x08,0x04,0x04,0x08,
+0x02,0x02,0x01,0x01,
+0x50,0x53,0x00,0x00,
+0x80,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xA0,0xA4,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x68,0xA4,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x30,0xA4,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0xF8,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0xC0,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x88,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x70,0xA3,0x01,0x80,
+0x48,0xA3,0x01,0x80,
+0xB8,0x06,0x00,0x80,
+0xAC,0x06,0x00,0x80,
+0xA0,0x06,0x00,0x80,
+0x94,0x06,0x00,0x80,
+0x88,0x06,0x00,0x80,
+0x7C,0x06,0x00,0x80,
+0x70,0x06,0x00,0x80,
+0x64,0x06,0x00,0x80,
+0x58,0x06,0x00,0x80,
+0x4C,0x06,0x00,0x80,
+0x04,0x06,0x00,0x80,
+0x30,0x1F,0x02,0x80,
+0xB0,0x03,0x25,0xB0,
+0x30,0x1F,0x02,0x80,
+0x30,0x1F,0x02,0x80,
+0x30,0x1F,0x02,0x80,
+0x30,0x1F,0x02,0x80,
+0x6A,0x6F,0x69,0x6E,
+0x62,0x73,0x73,0x5F,
+0x68,0x64,0x6C,0x00,
+0x00,0x0E,0x04,0x0E,
+0x10,0x0E,0x14,0x0E,
+0x18,0x0E,0x1C,0x0E,
+0x02,0x04,0x04,0x07,
+0x07,0x0D,0x0D,0x0D,
+0x02,0x07,0x07,0x0D,
+0x0D,0x0F,0x0F,0x0F,
+0x0F,0x00,0x00,0x00,
+0x72,0x65,0x70,0x6F,
+0x72,0x74,0x5F,0x73,
+0x75,0x72,0x76,0x65,
+0x79,0x5F,0x64,0x6F,
+0x6E,0x65,0x00,0x00,
+0x72,0x65,0x70,0x6F,
+0x72,0x74,0x5F,0x6A,
+0x6F,0x69,0x6E,0x5F,
+0x72,0x65,0x73,0x00,
+0x72,0x65,0x70,0x6F,
+0x72,0x74,0x5F,0x64,
+0x65,0x6C,0x5F,0x73,
+0x74,0x61,0x5F,0x65,
+0x76,0x65,0x6E,0x74,
+0x00,0x00,0x00,0x00,
+0x72,0x65,0x70,0x6F,
+0x72,0x74,0x5F,0x61,
+0x64,0x64,0x5F,0x73,
+0x74,0x61,0x5F,0x65,
+0x76,0x65,0x6E,0x74,
+0x00,0x00,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x70,0x72,
+0x6F,0x62,0x65,0x72,
+0x65,0x71,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x70,0x72,
+0x6F,0x62,0x65,0x72,
+0x73,0x70,0x00,0x00,
+0x72,0x65,0x70,0x6F,
+0x72,0x74,0x5F,0x42,
+0x53,0x53,0x49,0x44,
+0x5F,0x69,0x6E,0x66,
+0x6F,0x00,0x00,0x00,
+0x00,0x50,0xF2,0x01,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x61,0x73,
+0x73,0x6F,0x63,0x72,
+0x65,0x71,0x00,0x00,
+0x00,0x50,0xF2,0x04,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x61,0x63,
+0x74,0x69,0x6F,0x6E,
+0x00,0x00,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x61,0x75,
+0x74,0x68,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x64,0x65,
+0x61,0x75,0x74,0x68,
+0x00,0x00,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x64,0x69,
+0x73,0x61,0x73,0x73,
+0x6F,0x63,0x00,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x66,0x72,
+0x61,0x6D,0x65,0x00,
+0x69,0x73,0x73,0x75,
+0x65,0x5F,0x66,0x72,
+0x61,0x6D,0x65,0x5F,
+0x6C,0x65,0x6E,0x00,
+0x30,0x1F,0x02,0x80,
+0xB0,0x03,0x25,0xB0,
+0xF8,0x00,0x25,0xB0,
+0x18,0x03,0x25,0xB0,
+0x44,0x44,0x33,0x33,
+0x06,0x00,0x2A,0xB0,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x24,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0xA8,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x9C,0x3E,0x01,0x80,
+0x90,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x84,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x78,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x6C,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x60,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x54,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x48,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x3C,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x28,0x3E,0x01,0x80,
+0x30,0x3E,0x01,0x80,
+0x68,0x3F,0x01,0x80,
+0x5C,0x3F,0x01,0x80,
+0x50,0x3F,0x01,0x80,
+0x44,0x3F,0x01,0x80,
+0x38,0x3F,0x01,0x80,
+0x2C,0x3F,0x01,0x80,
+0x20,0x3F,0x01,0x80,
+0x14,0x3F,0x01,0x80,
+0x08,0x3F,0x01,0x80,
+0xFC,0x3E,0x01,0x80,
+0xF0,0x3E,0x01,0x80,
+0xE4,0x3E,0x01,0x80,
+0x00,0x50,0xF2,0x01,
+0x00,0x50,0xF2,0x02,
+0x00,0x0F,0xAC,0x02,
+0xBC,0xE3,0x01,0x80,
+0x67,0x66,0x66,0x66,
+0x7C,0x88,0x00,0x80,
+0x64,0x88,0x00,0x80,
+0x4C,0x88,0x00,0x80,
+0x34,0x88,0x00,0x80,
+0x1C,0x88,0x00,0x80,
+0x04,0x88,0x00,0x80,
+0xE0,0x87,0x00,0x80,
+0x00,0x02,0x00,0x00,
+0x08,0x09,0x00,0x00,
+0x18,0x96,0x00,0x80,
+0x24,0x96,0x00,0x80,
+0x30,0x96,0x00,0x80,
+0x3C,0x96,0x00,0x80,
+0x18,0x96,0x00,0x80,
+0x18,0x96,0x00,0x80,
+0x18,0x96,0x00,0x80,
+0x18,0x96,0x00,0x80,
+0x48,0x96,0x00,0x80,
+0x54,0x96,0x00,0x80,
+0x60,0x96,0x00,0x80,
+0x6C,0x96,0x00,0x80,
+0x30,0x1F,0x02,0x80,
+0x84,0x0E,0x25,0xB0,
+0x88,0x0E,0x25,0xB0,
+0x8C,0x0E,0x25,0xB0,
+0xD0,0x0E,0x25,0xB0,
+0xD8,0x0E,0x25,0xB0,
+0x20,0x08,0x25,0xB0,
+0x74,0x0E,0x25,0xB0,
+0x80,0x0E,0x25,0xB0,
+0x84,0x0E,0x25,0xB0,
+0x88,0x0E,0x25,0xB0,
+0x8C,0x0E,0x25,0xB0,
+0xD0,0x0E,0x25,0xB0,
+0xD8,0x0E,0x25,0xB0,
+0x14,0x0C,0x25,0xB0,
+0x88,0x0C,0x25,0xB0,
+0x1C,0x0C,0x25,0xB0,
+0xFE,0x01,0x80,0x7F,
+0xE2,0x01,0x80,0x78,
+0xC7,0x01,0xC0,0x71,
+0xAE,0x01,0x80,0x6B,
+0x95,0x01,0x40,0x65,
+0x7F,0x01,0xC0,0x5F,
+0x69,0x01,0x40,0x5A,
+0x55,0x01,0x40,0x55,
+0x42,0x01,0x80,0x50,
+0x30,0x01,0x00,0x4C,
+0x1F,0x01,0xC0,0x47,
+0x0F,0x01,0xC0,0x43,
+0x00,0x01,0x00,0x40,
+0xF2,0x00,0x80,0x3C,
+0xE4,0x00,0x00,0x39,
+0xD7,0x00,0xC0,0x35,
+0xCB,0x00,0xC0,0x32,
+0xC0,0x00,0x00,0x30,
+0xB5,0x00,0x40,0x2D,
+0xAB,0x00,0xC0,0x2A,
+0xA2,0x00,0x80,0x28,
+0x98,0x00,0x00,0x26,
+0x90,0x00,0x00,0x24,
+0x88,0x00,0x00,0x22,
+0x80,0x00,0x00,0x20,
+0x79,0x00,0x40,0x1E,
+0x72,0x00,0x80,0x1C,
+0x6C,0x00,0x00,0x1B,
+0x66,0x00,0x80,0x19,
+0x60,0x00,0x00,0x18,
+0x5B,0x00,0xC0,0x16,
+0x56,0x00,0x80,0x15,
+0x51,0x00,0x40,0x14,
+0x4C,0x00,0x00,0x13,
+0x48,0x00,0x00,0x12,
+0x44,0x00,0x00,0x11,
+0x40,0x00,0x00,0x10,
+0x36,0x35,0x2E,0x25,
+0x1C,0x12,0x09,0x04,
+0x33,0x32,0x2B,0x23,
+0x1A,0x11,0x08,0x04,
+0x30,0x2F,0x29,0x21,
+0x19,0x10,0x08,0x03,
+0x2D,0x2D,0x27,0x1F,
+0x18,0x0F,0x08,0x03,
+0x2B,0x2A,0x25,0x1E,
+0x16,0x0E,0x07,0x03,
+0x28,0x28,0x22,0x1C,
+0x15,0x0D,0x07,0x03,
+0x26,0x25,0x21,0x1B,
+0x14,0x0D,0x06,0x03,
+0x24,0x23,0x1F,0x19,
+0x13,0x0C,0x06,0x03,
+0x22,0x21,0x1D,0x18,
+0x11,0x0B,0x06,0x02,
+0x20,0x20,0x1B,0x16,
+0x11,0x08,0x05,0x02,
+0x1F,0x1E,0x1A,0x15,
+0x10,0x0A,0x05,0x02,
+0x1D,0x1C,0x18,0x14,
+0x0F,0x0A,0x05,0x02,
+0x1B,0x1A,0x17,0x13,
+0x0E,0x09,0x04,0x02,
+0x1A,0x19,0x16,0x12,
+0x0D,0x09,0x04,0x02,
+0x18,0x17,0x15,0x11,
+0x0C,0x08,0x04,0x02,
+0x17,0x16,0x13,0x10,
+0x0C,0x08,0x04,0x02,
+0x16,0x15,0x12,0x0F,
+0x0B,0x07,0x04,0x01,
+0x14,0x14,0x11,0x0E,
+0x0B,0x07,0x03,0x02,
+0x13,0x13,0x10,0x0D,
+0x0A,0x06,0x03,0x01,
+0x12,0x12,0x0F,0x0C,
+0x09,0x06,0x03,0x01,
+0x11,0x11,0x0F,0x0C,
+0x09,0x06,0x03,0x01,
+0x10,0x10,0x0E,0x0B,
+0x08,0x05,0x03,0x01,
+0x0F,0x0F,0x0D,0x0B,
+0x08,0x05,0x03,0x01,
+0x0E,0x0E,0x0C,0x0A,
+0x08,0x05,0x02,0x01,
+0x0D,0x0D,0x0C,0x0A,
+0x07,0x05,0x02,0x01,
+0x0D,0x0C,0x0B,0x09,
+0x07,0x04,0x02,0x01,
+0x0C,0x0C,0x0A,0x09,
+0x06,0x04,0x02,0x01,
+0x0B,0x0B,0x0A,0x08,
+0x06,0x04,0x02,0x01,
+0x0B,0x0A,0x09,0x08,
+0x06,0x04,0x02,0x01,
+0x0A,0x0A,0x09,0x07,
+0x05,0x03,0x02,0x01,
+0x0A,0x09,0x08,0x07,
+0x05,0x03,0x02,0x01,
+0x09,0x09,0x08,0x06,
+0x05,0x03,0x01,0x01,
+0x09,0x08,0x07,0x06,
+0x04,0x03,0x01,0x01,
+0x36,0x35,0x2E,0x1B,
+0x00,0x00,0x00,0x00,
+0x33,0x32,0x2B,0x19,
+0x00,0x00,0x00,0x00,
+0x30,0x2F,0x29,0x18,
+0x00,0x00,0x00,0x00,
+0x2D,0x2D,0x17,0x17,
+0x00,0x00,0x00,0x00,
+0x2B,0x2A,0x25,0x15,
+0x00,0x00,0x00,0x00,
+0x28,0x28,0x24,0x14,
+0x00,0x00,0x00,0x00,
+0x26,0x25,0x21,0x13,
+0x00,0x00,0x00,0x00,
+0x24,0x23,0x1F,0x12,
+0x00,0x00,0x00,0x00,
+0x22,0x21,0x1D,0x11,
+0x00,0x00,0x00,0x00,
+0x20,0x20,0x1B,0x10,
+0x00,0x00,0x00,0x00,
+0x1F,0x1E,0x1A,0x0F,
+0x00,0x00,0x00,0x00,
+0x1D,0x1C,0x18,0x0E,
+0x00,0x00,0x00,0x00,
+0x1B,0x1A,0x17,0x0E,
+0x00,0x00,0x00,0x00,
+0x1A,0x19,0x16,0x0D,
+0x00,0x00,0x00,0x00,
+0x18,0x17,0x15,0x0C,
+0x00,0x00,0x00,0x00,
+0x17,0x16,0x13,0x0B,
+0x00,0x00,0x00,0x00,
+0x16,0x15,0x12,0x0B,
+0x00,0x00,0x00,0x00,
+0x14,0x14,0x11,0x0A,
+0x00,0x00,0x00,0x00,
+0x13,0x13,0x10,0x0A,
+0x00,0x00,0x00,0x00,
+0x12,0x12,0x0F,0x09,
+0x00,0x00,0x00,0x00,
+0x11,0x11,0x0F,0x09,
+0x00,0x00,0x00,0x00,
+0x10,0x10,0x0E,0x08,
+0x00,0x00,0x00,0x00,
+0x0F,0x0F,0x0D,0x08,
+0x00,0x00,0x00,0x00,
+0x0E,0x0E,0x0C,0x07,
+0x00,0x00,0x00,0x00,
+0x0D,0x0D,0x0C,0x07,
+0x00,0x00,0x00,0x00,
+0x0D,0x0C,0x0B,0x06,
+0x00,0x00,0x00,0x00,
+0x0C,0x0C,0x0A,0x06,
+0x00,0x00,0x00,0x00,
+0x0B,0x0B,0x0A,0x06,
+0x00,0x00,0x00,0x00,
+0x0B,0x0A,0x09,0x05,
+0x00,0x00,0x00,0x00,
+0x0A,0x0A,0x09,0x05,
+0x00,0x00,0x00,0x00,
+0x0A,0x09,0x08,0x05,
+0x00,0x00,0x00,0x00,
+0x09,0x09,0x08,0x05,
+0x00,0x00,0x00,0x00,
+0x09,0x08,0x07,0x04,
+0x00,0x00,0x00,0x00,
+0x06,0x00,0x2A,0xB0,
+0x05,0x00,0x2A,0xB0,
+0x54,0x83,0x01,0x80,
+0xC4,0x83,0x01,0x80,
+0x80,0x83,0x01,0x80,
+0xC4,0x83,0x01,0x80,
+0xC4,0x83,0x01,0x80,
+0xC4,0x83,0x01,0x80,
+0xC4,0x83,0x01,0x80,
+0x2C,0x83,0x01,0x80,
+0x00,0x01,0x02,0x02,
+0x03,0x03,0x03,0x03,
+0x04,0x04,0x04,0x04,
+0x04,0x04,0x04,0x04,
+0x05,0x05,0x05,0x05,
+0x05,0x05,0x05,0x05,
+0x05,0x05,0x05,0x05,
+0x05,0x05,0x05,0x05,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x06,0x06,0x06,0x06,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x07,0x07,0x07,0x07,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x28,0x28,0x28,
+0x28,0x28,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0x08,0x08,0x08,0x08,
+0xA0,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x04,0x04,0x04,0x04,
+0x04,0x04,0x04,0x04,
+0x04,0x04,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x41,0x41,0x41,
+0x41,0x41,0x41,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x42,0x42,0x42,
+0x42,0x42,0x42,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x10,
+0x10,0x10,0x10,0x08,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0xA0,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x10,0x10,0x10,0x10,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x10,
+0x01,0x01,0x01,0x01,
+0x01,0x01,0x01,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x10,
+0x02,0x02,0x02,0x02,
+0x02,0x02,0x02,0x00,
+0x2D,0x5C,0x7C,0x2F,
+0x00,0x00,0x00,0x00,
+0xFD,0xFA,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x45,0xC4,0xF0,
+0x00,0x45,0xC4,0xF0,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x00,0x45,0xB5,0x60,
+0xFF,0xFF,0xFF,0xFF,
+0x00,0x00,0x00,0x02,
+0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,
+0x08,0xFB,0x90,0xB8,
+0xFF,0xFF,0xFF,0xFF,
+};
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/h2clbk.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/h2clbk.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/h2clbk.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/h2clbk.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _H2CLBK_H_
+
+
+#include <rtl8711_spec.h>
+#include <TypeDef.h>
+
+
+void _lbk_cmd(PADAPTER Adapter);
+
+void _lbk_rsp(PADAPTER Adapter);
+
+void _lbk_evt(IN PADAPTER Adapter);
+
+void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyCfg.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyCfg.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyCfg.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyCfg.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,457 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*****************************************************************************
+ *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
+ *
+ * Module:	__INC_HAL8192SPHYCFG_H
+ *
+ *
+ * Note:	
+ *			
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:	
+ *
+ * History:
+ *		Data		Who		Remark 
+ *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
+ *							2. Reorganize code architecture.
+ * 
+ *****************************************************************************/
+ /* Check to see if the file has been included already.  */
+#ifndef __INC_HAL8192SPHYCFG_H
+#define __INC_HAL8192SPHYCFG_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+
+#define PHY_SetMacReg			PHY_SetBBReg
+
+
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+#define	SET_RTL8192SE_RF_SLEEP(_pAdapter)							\
+{																	\
+	u1Byte		u1bTmp;												\
+	u1bTmp = PlatformEFIORead1Byte(_pAdapter, REG_LDOV12D_CTRL);		\
+	u1bTmp |= BIT0;													\
+	PlatformEFIOWrite1Byte(_pAdapter, REG_LDOV12D_CTRL, u1bTmp);		\
+	PlatformEFIOWrite1Byte(_pAdapter, REG_SPS_OCP_CFG, 0x0);				\
+	PlatformEFIOWrite1Byte(_pAdapter, TXPAUSE, 0xFF);				\
+	PlatformEFIOWrite2Byte(_pAdapter, CMDR, 0x57FC);				\
+	delay_us(100);													\
+	PlatformEFIOWrite2Byte(_pAdapter, CMDR, 0x77FC);				\
+	PlatformEFIOWrite1Byte(_pAdapter, PHY_CCA, 0x0);				\
+	delay_us(10);													\
+	PlatformEFIOWrite2Byte(_pAdapter, CMDR, 0x37FC);				\
+	delay_us(10);													\
+	PlatformEFIOWrite2Byte(_pAdapter, CMDR, 0x77FC);				\
+	delay_us(10);													\
+	PlatformEFIOWrite2Byte(_pAdapter, CMDR, 0x57FC);				\
+}
+#endif
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/ 
+typedef enum _SwChnlCmdID{
+	CmdID_End,
+	CmdID_SetTxPowerLevel,
+	CmdID_BBRegWrite10,
+	CmdID_WritePortUlong,
+	CmdID_WritePortUshort,
+	CmdID_WritePortUchar,
+	CmdID_RF_WriteReg,
+}SwChnlCmdID;
+
+
+/* 1. Switch channel related */
+typedef struct _SwChnlCmd{
+	SwChnlCmdID	CmdID;
+	u32			Para1;
+	u32			Para2;
+	u32			msDelay;
+}SwChnlCmd;
+
+typedef enum _HW90_BLOCK{
+	HW90_BLOCK_MAC = 0,
+	HW90_BLOCK_PHY0 = 1,
+	HW90_BLOCK_PHY1 = 2,
+	HW90_BLOCK_RF = 3,
+	HW90_BLOCK_MAXIMUM = 4, // Never use this
+}HW90_BLOCK_E, *PHW90_BLOCK_E;
+
+typedef enum _RF90_RADIO_PATH{
+	RF90_PATH_A = 0,			//Radio Path A
+	RF90_PATH_B = 1,			//Radio Path B
+	RF90_PATH_C = 2,			//Radio Path C
+	RF90_PATH_D = 3,			//Radio Path D
+	//RF90_PATH_MAX				//Max RF number 90 support 
+}RF90_RADIO_PATH_E, *PRF90_RADIO_PATH_E;
+
+#define	RF90_PATH_MAX			2
+
+typedef enum _WIRELESS_MODE {
+	WIRELESS_MODE_UNKNOWN = 0x00,
+	WIRELESS_MODE_A = 0x01,
+	WIRELESS_MODE_B = 0x02,
+	WIRELESS_MODE_G = 0x04,
+	WIRELESS_MODE_AUTO = 0x08,
+	WIRELESS_MODE_N_24G = 0x10,
+	WIRELESS_MODE_N_5G = 0x20
+} WIRELESS_MODE;
+
+
+#define CHANNEL_MAX_NUMBER		14	// 14 is the max channel number
+#define CHANNEL_GROUP_MAX		3	// ch1~3, ch4~9, ch10~14 total three groups
+
+
+typedef enum _BaseBand_Config_Type{
+	BaseBand_Config_PHY_REG = 0,			//Radio Path A
+	BaseBand_Config_AGC_TAB = 1,			//Radio Path B
+}BaseBand_Config_Type, *PBaseBand_Config_Type;
+
+
+typedef enum _PHY_Rate_Tx_Power_Offset_Area{
+	RA_OFFSET_LEGACY_OFDM1,
+	RA_OFFSET_LEGACY_OFDM2,
+	RA_OFFSET_HT_OFDM1,
+	RA_OFFSET_HT_OFDM2,
+	RA_OFFSET_HT_OFDM3,
+	RA_OFFSET_HT_OFDM4,
+	RA_OFFSET_HT_CCK,
+}RA_OFFSET_AREA,*PRA_OFFSET_AREA;
+
+
+/* BB/RF related */
+typedef	enum _RF_TYPE_8190P{
+	RF_TYPE_MIN,	// 0
+	RF_8225=1,			// 1 11b/g RF for verification only
+	RF_8256=2,			// 2 11b/g/n 
+	RF_8258=3,			// 3 11a/b/g/n RF
+	RF_6052=4,		// 4 11b/g/n RF
+	//RF_6052=5,		// 4 11b/g/n RF
+	// TODO: We sholud remove this psudo PHY RF after we get new RF.
+	RF_PSEUDO_11N=5,	// 5, It is a temporality RF. 
+}RF_TYPE_8190P_E,*PRF_TYPE_8190P_E;
+
+
+typedef enum _RATR_TABLE_MODE_8192C{
+	RATR_INX_WIRELESS_NGB = 0,
+	RATR_INX_WIRELESS_NG = 1,
+	RATR_INX_WIRELESS_NB = 2,
+	RATR_INX_WIRELESS_N = 3,
+	RATR_INX_WIRELESS_GB = 4,
+	RATR_INX_WIRELESS_G = 5,
+	RATR_INX_WIRELESS_B = 6,
+	RATR_INX_WIRELESS_MC = 7,
+	RATR_INX_WIRELESS_A = 8,
+}RATR_TABLE_MODE_8192C, *PRATR_TABLE_MODE_8192C;
+
+typedef struct _BB_REGISTER_DEFINITION{
+	u32 rfintfs;			// set software control: 
+							//		0x870~0x877[8 bytes]
+							
+	u32 rfintfi;			// readback data: 
+							//		0x8e0~0x8e7[8 bytes]
+							
+	u32 rfintfo; 		// output data: 
+							//		0x860~0x86f [16 bytes]
+							
+	u32 rfintfe; 		// output enable: 
+							//		0x860~0x86f [16 bytes]
+							
+	u32 rf3wireOffset;	// LSSI data:
+							//		0x840~0x84f [16 bytes]
+							
+	u32 rfLSSI_Select;	// BB Band Select: 
+							//		0x878~0x87f [8 bytes]
+							
+	u32 rfTxGainStage;	// Tx gain stage: 
+							//		0x80c~0x80f [4 bytes]
+							
+	u32 rfHSSIPara1; 	// wire parameter control1 : 
+							//		0x820~0x823,0x828~0x82b, 0x830~0x833, 0x838~0x83b [16 bytes]
+							
+	u32 rfHSSIPara2; 	// wire parameter control2 : 
+							//		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes]
+								
+	u32 rfSwitchControl; //Tx Rx antenna control : 
+							//		0x858~0x85f [16 bytes]
+								
+	u32 rfAGCControl1; 	//AGC parameter control1 : 
+							//		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes] 
+								
+	u32 rfAGCControl2; 	//AGC parameter control2 : 
+							//		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes] 
+							
+	u32 rfRxIQImbalance; //OFDM Rx IQ imbalance matrix : 
+							//		0xc14~0xc17,0xc1c~0xc1f, 0xc24~0xc27, 0xc2c~0xc2f [16 bytes]
+							
+	u32 rfRxAFE;  		//Rx IQ DC ofset and Rx digital filter, Rx DC notch filter : 
+							//		0xc10~0xc13,0xc18~0xc1b, 0xc20~0xc23, 0xc28~0xc2b [16 bytes]
+							
+	u32 rfTxIQImbalance; //OFDM Tx IQ imbalance matrix
+							//		0xc80~0xc83,0xc88~0xc8b, 0xc90~0xc93, 0xc98~0xc9b [16 bytes]
+							
+	u32 rfTxAFE; 		//Tx IQ DC Offset and Tx DFIR type
+							//		0xc84~0xc87,0xc8c~0xc8f, 0xc94~0xc97, 0xc9c~0xc9f [16 bytes]
+								
+	u32 rfLSSIReadBack; 	//LSSI RF readback data SI mode
+								//		0x8a0~0x8af [16 bytes]
+
+	u32 rfLSSIReadBackPi; 	//LSSI RF readback data PI mode 0x8b8-8bc for Path A and B
+
+}BB_REGISTER_DEFINITION_T, *PBB_REGISTER_DEFINITION_T;
+
+typedef enum _ANTENNA_PATH{
+        ANTENNA_NONE 	= 0x00,
+		ANTENNA_D		,
+		ANTENNA_C		,
+		ANTENNA_CD		,
+		ANTENNA_B		,
+		ANTENNA_BD		,
+		ANTENNA_BC		,
+		ANTENNA_BCD		,
+		ANTENNA_A		,
+		ANTENNA_AD		,
+		ANTENNA_AC		,
+		ANTENNA_ACD		,
+		ANTENNA_AB		,
+		ANTENNA_ABD		,
+		ANTENNA_ABC		,
+		ANTENNA_ABCD	
+} ANTENNA_PATH;
+
+typedef struct _R_ANTENNA_SELECT_OFDM{	
+	u32			r_tx_antenna:4;	
+	u32			r_ant_l:4;
+	u32			r_ant_non_ht:4;	
+	u32			r_ant_ht1:4;
+	u32			r_ant_ht2:4;
+	u32			r_ant_ht_s1:4;
+	u32			r_ant_non_ht_s1:4;
+	u32			OFDM_TXSC:2;
+	u32			Reserved:2;
+}R_ANTENNA_SELECT_OFDM;
+
+typedef struct _R_ANTENNA_SELECT_CCK{
+	u8			r_cckrx_enable_2:2;	
+	u8			r_cckrx_enable:2;
+	u8			r_ccktx_enable:4;
+}R_ANTENNA_SELECT_CCK;
+
+/*------------------------------Define structure----------------------------*/ 
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+//
+// BB and RF register read/write
+//
+extern	u32	PHY_QueryBBReg(	IN	PADAPTER	Adapter,
+								IN	u32		RegAddr,
+								IN	u32		BitMask	);
+extern	void	PHY_SetBBReg(	IN	PADAPTER	Adapter,
+								IN	u32		RegAddr,
+								IN	u32		BitMask,
+								IN	u32		Data	);
+extern	u32	PHY_QueryRFReg(	IN	PADAPTER			Adapter,
+								IN	RF90_RADIO_PATH_E	eRFPath,
+								IN	u32				RegAddr,
+								IN	u32				BitMask	);
+extern	void	PHY_SetRFReg(	IN	PADAPTER			Adapter,
+								IN	RF90_RADIO_PATH_E	eRFPath,
+								IN	u32				RegAddr,
+								IN	u32				BitMask,
+								IN	u32				Data	);
+
+//
+// Initialization related function
+//
+/* MAC/BB/RF HAL config */
+extern	int	PHY_MACConfig8192C(	IN	PADAPTER	Adapter	);
+extern	int	PHY_BBConfig8192C(	IN	PADAPTER	Adapter	);
+extern	int	PHY_RFConfig8192C(	IN	PADAPTER	Adapter	);
+
+#ifdef RTL8192C_RECONFIG_TO_1T1R
+extern void	PHY_Reconfig_To_1T1R(_adapter *padapter);
+#endif
+/* RF config */
+extern	int	PHY_ConfigRFWithParaFile(	IN	PADAPTER	Adapter,
+												IN	u8* 	pFileName,
+												IN	RF90_RADIO_PATH_E	eRFPath);
+extern	int	PHY_ConfigRFWithHeaderFile(	IN	PADAPTER			Adapter,
+												IN	RF90_RADIO_PATH_E	eRFPath);
+
+/* BB/RF readback check for making sure init OK */
+extern	int	PHY_CheckBBAndRFOK(	IN	PADAPTER			Adapter,
+										IN	HW90_BLOCK_E		CheckBlock,
+										IN	RF90_RADIO_PATH_E	eRFPath	  );
+/* Read initi reg value for tx power setting. */
+extern	void	PHY_GetHWRegOriginalValue(	IN	PADAPTER		Adapter	);
+
+//
+// RF Power setting
+//
+//extern	BOOLEAN	PHY_SetRFPowerState(IN	PADAPTER			Adapter, 
+//									IN	RT_RF_POWER_STATE	eRFPowerState);
+extern	void	
+PHY_SetRtl8192seRfHalt(		IN	PADAPTER	pAdapter);
+
+//
+// BB TX Power R/W
+//
+extern	void	PHY_GetTxPowerLevel8192C(	IN	PADAPTER		Adapter,
+											OUT u32*    		powerlevel	);
+extern	void	PHY_SetTxPowerLevel8192C(	IN	PADAPTER		Adapter,
+											IN	u8			channel	);
+extern	BOOLEAN	PHY_UpdateTxPowerDbm8192C(	IN	PADAPTER	Adapter,
+											IN	int		powerInDbm	);
+
+//
+extern	VOID 
+PHY_ScanOperationBackup8192C(IN	PADAPTER	Adapter,
+										IN	u8		Operation	);
+
+//
+// Switch bandwidth for 8192S
+//
+//extern	void	PHY_SetBWModeCallback8192C(	IN	PRT_TIMER		pTimer	);
+extern	void	PHY_SetBWMode8192C(	IN	PADAPTER			pAdapter,
+									IN	HT_CHANNEL_WIDTH	ChnlWidth,
+									IN	unsigned char	Offset	);
+
+//
+// Set FW CMD IO for 8192S.
+//
+//extern	BOOLEAN HalSetIO8192C(	IN	PADAPTER			Adapter,
+//									IN	IO_TYPE				IOType);
+
+//
+// Set A2 entry to fw for 8192S
+//
+extern	void FillA2Entry8192C(		IN	PADAPTER			Adapter,
+										IN	u8				index,
+										IN	u8*				val);
+
+
+//
+// channel switch related funciton
+//
+//extern	void	PHY_SwChnlCallback8192C(	IN	PRT_TIMER		pTimer	);
+extern	void	PHY_SwChnl8192C(	IN	PADAPTER		pAdapter,
+									IN	u8			channel	);
+				// Call after initialization
+extern	void	PHY_SwChnlPhy8192C(	IN	PADAPTER		pAdapter,
+									IN	u8			channel	);
+
+extern void ChkFwCmdIoDone(	IN	PADAPTER	Adapter);
+
+#ifdef USE_WORKITEM	
+//extern 	void SetIOWorkItemCallback( IN PVOID            pContext );
+#else
+//extern	void SetIOTimerCallback( IN PRT_TIMER		pTimer);
+#endif	
+				
+//
+// BB/MAC/RF other monitor API
+//
+extern	void	PHY_FalseAlarmCounterStatistics8192S(IN	PADAPTER	Adapter	);
+
+extern	void	PHY_SetMonitorMode8192C(IN	PADAPTER	pAdapter,
+										IN	BOOLEAN		bEnableMonitorMode	);
+
+extern	BOOLEAN	PHY_CheckIsLegalRfPath8192C(IN	PADAPTER	pAdapter,
+											IN	u32		eRFPath	);
+
+//
+// IQ calibrate
+//
+void	PHY_IQCalibrate(	IN	PADAPTER	pAdapter, IN BOOLEAN bReCovery);
+
+
+//
+// LC calibrate
+//
+void	PHY_LCCalibrate(IN	PADAPTER	pAdapter);
+
+//
+// AP calibrate
+//
+void	PHY_APCalibrate(IN	PADAPTER	pAdapter, IN 	char		delta);
+
+
+//
+// Modify the value of the hw register when beacon interval be changed.
+//
+extern void	
+PHY_SetBeaconHwReg(	IN	PADAPTER		Adapter,
+					IN	u16			BeaconInterval	);
+
+
+extern	VOID
+PHY_SwitchEphyParameter(
+	IN	PADAPTER			Adapter
+	);
+
+extern	VOID
+PHY_EnableHostClkReq(
+	IN	PADAPTER			Adapter
+	);
+
+int
+phy_TxPwrIdxToDbm(
+	IN	PADAPTER		Adapter,
+	IN	WIRELESS_MODE	WirelessMode,
+	IN	u8			TxPwrIdx	
+	);
+
+BOOLEAN
+SetAntennaConfig92C(
+	IN	PADAPTER	Adapter,
+	IN	u8		DefaultAnt	
+	);
+
+
+u8 PHY_QueryRFPath(IN PADAPTER	pAdapter);
+void PHY_SetRFPath(IN	PADAPTER	pAdapter,u8 antenna);
+
+/*--------------------------Exported Function prototype---------------------*/
+
+
+#endif	// __INC_HAL8192SPHYCFG_H
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyReg.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyReg.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyReg.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/Hal8192CPhyReg.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1055 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*****************************************************************************
+ *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
+ *
+ * Module:	__INC_HAL8192SPHYREG_H
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *			
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:	
+ *
+ * History:
+ *		Data		Who		Remark 
+ *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
+ *							2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ * 
+ *****************************************************************************/
+#ifndef __INC_HAL8192SPHYREG_H
+#define __INC_HAL8192SPHYREG_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//============================================================
+//       8192S Regsiter offset definition
+//============================================================
+
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming2			0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		TransceiverA_HSPI_Readback	0x8b8	// Transceiver A HSPI Readback
+#define		TransceiverB_HSPI_Readback	0x8bc	// Transceiver B HSPI Readback
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync. 
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+#define		rOFDM0_RxIQExtAnta				0xca0
+
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00			0xe10
+#define		rTxAGC_A_Mcs07_Mcs04			0xe14
+#define		rTxAGC_A_Mcs11_Mcs08			0xe18
+#define		rTxAGC_A_Mcs15_Mcs12			0xe1c
+
+#define		rTxAGC_B_Rate18_06			0x830
+#define		rTxAGC_B_Rate54_24			0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	// RF channel switch
+
+//#endif
+#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl						0	// Useless now
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+//RTL8258
+#define		rRTL8258_TxLPF					0x11	// Useless now
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	// 
+
+#define		RF_IQADJ_G1				0x01	// 
+#define		RF_IQADJ_G2				0x02	// 
+#define		RF_POW_TRSW				0x05	// 
+
+#define		RF_GAIN_RX					0x06	// 
+#define		RF_GAIN_TX					0x07	// 
+
+#define		RF_TXM_IDAC				0x08	// 
+#define		RF_BS_IQGEN				0x0F	// 
+
+#define		RF_MODE1					0x10	// 
+#define		RF_MODE2					0x11	// 
+
+#define		RF_RX_AGC_HP				0x12	// 
+#define		RF_TX_AGC					0x13	// 
+#define		RF_BIAS						0x14	// 
+#define		RF_IPA						0x15	// 
+#define		RF_POW_ABILITY			0x17	// 
+#define		RF_MODE_AG				0x18	// 
+#define		rRfChannel					0x18	// RF channel and BW switch
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	// 
+
+#define		RF_RX_G1					0x1A	// 
+#define		RF_RX_G2					0x1B	// 
+
+#define		RF_RX_BB2					0x1C	// 
+#define		RF_RX_BB1					0x1D	// 
+
+#define		RF_RCK1					0x1E	// 
+#define		RF_RCK2					0x1F	// 
+
+#define		RF_TX_G1					0x20	// 
+#define		RF_TX_G2					0x21	// 
+#define		RF_TX_G3					0x22	// 
+
+#define		RF_TX_BB1					0x23	// 
+
+#define		RF_T_METER					0x24	// 
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB						0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+// 2. Page8(0x800)
+#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  			0x3f
+
+#define		bAntennaSelect                 		0x0300
+
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+       		
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800 
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz       		
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      		0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        		0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          		0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               			0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          		0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          		0x100
+#define		bDA10PSAtRx               		0x1000       		
+#define		bCCKRxAGCFormat           		0x200       		
+#define		bPSDFFTSamplepPoint       		0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                			0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	      			0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode                		0x3	// Useless
+#define		bCCKTxPowerSaving         		0x80
+#define		bCCKRxPowerSaving         		0x40
+
+#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble              		0x8	// Useless
+#define		bCCKAntDiversity    		      	0x8000
+#define		bCCKCarrierRecovery   	    	0x4000
+#define		bCCKTxRate           		     	0x3000
+#define		bCCKDCCancel             	 	0x0800
+#define		bCCKISICancel             		0x0400
+#define		bCCKMatchFilter           		0x0200
+#define		bCCKEqualizer             		0x0100
+#define		bCCKPreambleDetect       	 	0x800000
+#define		bCCKFastFalseCCA          		0x400000
+#define		bCCKChEstStart            		0x300000
+#define		bCCKCCACount              		0x080000
+#define		bCCKcs_lim                			0x070000
+#define		bCCKBistMode              		0x80000000
+#define		bCCKCCAMask             	  	0x40000000
+#define		bCCKTxDACPhase         	   	0x4
+#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0         	   	0x0100
+#define		bCCKTxDCOffset           	 	0xf0
+#define		bCCKRxDCOffset           	 	0xf
+#define		bCCKCCAMode              	 	0xc000
+#define		bCCKFalseCS_lim           		0x3f00
+#define		bCCKCS_ratio              		0xc00000
+#define		bCCKCorgBit_sel           		0x300000
+#define		bCCKPD_lim                			0x0f0000
+#define		bCCKNewCCA                		0x80000000
+#define		bCCKRxHPofIG              		0x8000
+#define		bCCKRxIG                  			0x7f00
+#define		bCCKLNAPolarity           		0x800000
+#define		bCCKRx1stGain             		0x7f0000
+#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel        	 	0x1f000000
+#define		bCCKRxAGCSatCount       	  	0xe0
+#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity      	 	0x2000
+#define		bCCKTxFilterType          		0x0c00
+#define		bCCKRxAGCReportType   	   	0x0300
+#define		bCCKRxDAGCEn              		0x80000000
+#define		bCCKRxDAGCPeriod        	  	0x20000000
+#define		bCCKRxDAGCSatLevel     	   	0x1f000000
+#define		bCCKTimingRecovery       	 	0x800000
+#define		bCCKTxC0                  			0x3f0000
+#define		bCCKTxC1                  			0x3f000000
+#define		bCCKTxC2                  			0x3f
+#define		bCCKTxC3                  			0x3f00
+#define		bCCKTxC4                  			0x3f0000
+#define		bCCKTxC5                  			0x3f000000
+#define		bCCKTxC6                  			0x3f
+#define		bCCKTxC7                  			0x3f00
+#define		bCCKDebugPort             		0xff0000
+#define		bCCKDACDebug              		0x0f000000
+#define		bCCKFalseAlarmEnable      		0x8000
+#define		bCCKFalseAlarmRead        		0x4000
+#define		bCCKTRSSI                 			0x7f
+#define		bCCKRxAGCReport           		0xfe
+#define		bCCKRxReport_AntSel       		0x80000000
+#define		bCCKRxReport_MFOff        		0x40000000
+#define		bCCKRxRxReport_SQLoss     	0x20000000
+#define		bCCKRxReport_Pktloss      		0x10000000
+#define		bCCKRxReport_Lockedbit    	0x08000000
+#define		bCCKRxReport_RateError    	0x04000000
+#define		bCCKRxReport_RxRate       		0x03000000
+#define		bCCKRxFACounterLower      	0xff
+#define		bCCKRxFACounterUpper      	0xff000000
+#define		bCCKRxHPAGCStart          		0xe000
+#define		bCCKRxHPAGCFinal          		0x1c00       		
+#define		bCCKRxFalseAlarmEnable    	0x8000
+#define		bCCKFACounterFreeze       		0x4000       		
+#define		bCCKTxPathSel             		0x10000000
+#define		bCCKDefaultRxPath         		0xc000000
+#define		bCCKOptionRxPath          		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF                			0x3	// Useless
+#define		bShift_L                 			0xc0
+#define		bGI_TH                   			0xc
+#define		bRxPathA                 			0x1
+#define		bRxPathB                 			0x2
+#define		bRxPathC                 			0x4
+#define		bRxPathD                 			0x8
+#define		bTxPathA                 			0x1
+#define		bTxPathB                 			0x2
+#define		bTxPathC                 			0x4
+#define		bTxPathD                 			0x8
+#define		bTRSSIFreq               			0x200
+#define		bADCBackoff              			0x3000
+#define		bDFIRBackoff             			0xc000
+#define		bTRSSILatchPhase         		0x10000
+#define		bRxIDCOffset             			0xff
+#define		bRxQDCOffset             			0xff00
+#define		bRxDFIRMode              		0x1800000
+#define		bRxDCNFType              		0xe000000
+#define		bRXIQImb_A               			0x3ff
+#define		bRXIQImb_B               			0xfc00
+#define		bRXIQImb_C               			0x3f0000
+#define		bRXIQImb_D               			0xffc00000
+#define		bDC_dc_Notch             		0x60000
+#define		bRxNBINotch              			0x1f000000
+#define		bPD_TH                   			0xf
+#define		bPD_TH_Opt2              		0xc000
+#define		bPWED_TH                 			0x700
+#define		bIfMF_Win_L              			0x800
+#define		bPD_Option               			0x1000
+#define		bMF_Win_L                			0xe000
+#define		bBW_Search_L             		0x30000
+#define		bwin_enh_L               			0xc0000
+#define		bBW_TH                   			0x700000
+#define		bED_TH2                  			0x3800000
+#define		bBW_option               			0x4000000
+#define		bRatio_TH                			0x18000000
+#define		bWindow_L                			0xe0000000
+#define		bSBD_Option              			0x1
+#define		bFrame_TH                			0x1c
+#define		bFS_Option               			0x60
+#define		bDC_Slope_check          		0x80
+#define		bFGuard_Counter_DC_L     		0xe00
+#define		bFrame_Weight_Short      		0x7000
+#define		bSub_Tune                			0xe00000
+#define		bFrame_DC_Length         		0xe000000
+#define		bSBD_start_offset        		0x30000000
+#define		bFrame_TH_2              		0x7
+#define		bFrame_GI2_TH            		0x38
+#define		bGI2_Sync_en             		0x40
+#define		bSarch_Short_Early       		0x300
+#define		bSarch_Short_Late        		0xc00
+#define		bSarch_GI2_Late          		0x70000
+#define		bCFOAntSum               		0x1
+#define		bCFOAcc                  			0x2
+#define		bCFOStartOffset          		0xc
+#define		bCFOLookBack             		0x70
+#define		bCFOSumWeight            		0x80
+#define		bDAGCEnable              			0x10000
+#define		bTXIQImb_A               			0x3ff
+#define		bTXIQImb_B               			0xfc00
+#define		bTXIQImb_C               			0x3f0000
+#define		bTXIQImb_D               			0xffc00000
+#define		bTxIDCOffset             			0xff
+#define		bTxQDCOffset             			0xff00
+#define		bTxDFIRMode              		0x10000
+#define		bTxPesudoNoiseOn         		0x4000000
+#define		bTxPesudoNoise_A         		0xff
+#define		bTxPesudoNoise_B         		0xff00
+#define		bTxPesudoNoise_C         		0xff0000
+#define		bTxPesudoNoise_D         		0xff000000
+#define		bCCADropOption           		0x20000
+#define		bCCADropThres            		0xfff00000
+#define		bEDCCA_H                 			0xf
+#define		bEDCCA_L                 			0xf0
+#define		bLambda_ED               0x300
+#define		bRxInitialGain           0x7f
+#define		bRxAntDivEn              0x80
+#define		bRxAGCAddressForLNA      0x7f00
+#define		bRxHighPowerFlow         0x8000
+#define		bRxAGCFreezeThres        0xc0000
+#define		bRxFreezeStep_AGC1       0x300000
+#define		bRxFreezeStep_AGC2       0xc00000
+#define		bRxFreezeStep_AGC3       0x3000000
+#define		bRxFreezeStep_AGC0       0xc000000
+#define		bRxRssi_Cmp_En           0x10000000
+#define		bRxQuickAGCEn            0x20000000
+#define		bRxAGCFreezeThresMode    0x40000000
+#define		bRxOverFlowCheckType     0x80000000
+#define		bRxAGCShift              0x7f
+#define		bTRSW_Tri_Only           0x80
+#define		bPowerThres              0x300
+#define		bRxAGCEn                 0x1
+#define		bRxAGCTogetherEn         0x2
+#define		bRxAGCMin                0x4
+#define		bRxHP_Ini                0x7
+#define		bRxHP_TRLNA              0x70
+#define		bRxHP_RSSI               0x700
+#define		bRxHP_BBP1               0x7000
+#define		bRxHP_BBP2               0x70000
+#define		bRxHP_BBP3               0x700000
+#define		bRSSI_H                  0x7f0000     //the threshold for high power
+#define		bRSSI_Gen                0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW           0x7
+#define		bRxSettle_LNA            0x38
+#define		bRxSettle_RSSI           0x1c0
+#define		bRxSettle_BBP            0xe00
+#define		bRxSettle_RxHP           0x7000
+#define		bRxSettle_AntSW_RSSI     0x38000
+#define		bRxSettle_AntSW          0xc0000
+#define		bRxProcessTime_DAGC      0x300000
+#define		bRxSettle_HSSI           0x400000
+#define		bRxProcessTime_BBPPW     0x800000
+#define		bRxAntennaPowerShift     0x3000000
+#define		bRSSITableSelect         0xc000000
+#define		bRxHP_Final              0x7000000
+#define		bRxHTSettle_BBP          0x7
+#define		bRxHTSettle_HSSI         0x8
+#define		bRxHTSettle_RxHP         0x70
+#define		bRxHTSettle_BBPPW        0x80
+#define		bRxHTSettle_Idle         0x300
+#define		bRxHTSettle_Reserved     0x1c00
+#define		bRxHTRxHPEn              0x8000
+#define		bRxHTAGCFreezeThres      0x30000
+#define		bRxHTAGCTogetherEn       0x40000
+#define		bRxHTAGCMin              0x80000
+#define		bRxHTAGCEn               0x100000
+#define		bRxHTDAGCEn              0x200000
+#define		bRxHTRxHP_BBP            0x1c00000
+#define		bRxHTRxHP_Final          0xe0000000
+#define		bRxPWRatioTH             0x3
+#define		bRxPWRatioEn             0x4
+#define		bRxMFHold                0x3800
+#define		bRxPD_Delay_TH1          0x38
+#define		bRxPD_Delay_TH2          0x1c0
+#define		bRxPD_DC_COUNT_MAX       0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH           0x8000
+#define		bRxProcess_Delay         0xf0000
+#define		bRxSearchrange_GI2_Early 0x700000
+#define		bRxFrame_Guard_Counter_L 0x3800000
+#define		bRxSGI_Guard_L           0xc000000
+#define		bRxSGI_Search_L          0x30000000
+#define		bRxSGI_TH                0xc0000000
+#define		bDFSCnt0                 0xff
+#define		bDFSCnt1                 0xff00
+#define		bDFSFlag                 0xf0000       		
+#define		bMFWeightSum             0x300000
+#define		bMinIdxTH                0x7f000000       		
+#define		bDAFormat                0x40000       		
+#define		bTxChEmuEnable           0x01000000       		
+#define		bTRSWIsolation_A         0x7f
+#define		bTRSWIsolation_B         0x7f00
+#define		bTRSWIsolation_C         0x7f0000
+#define		bTRSWIsolation_D         0x7f000000       		
+#define		bExtLNAGain              0x7c00          
+
+// 6. PageE(0xE00)
+#define		bSTBCEn                  0x4	// Useless
+#define		bAntennaMapping          0x10
+#define		bNss                     0x20
+#define		bCFOAntSumD              0x200
+#define		bPHYCounterReset         0x8000000
+#define		bCFOReportGet            0x4000000
+#define		bOFDMContinueTx          0x10000000
+#define		bOFDMSingleCarrier       0x20000000
+#define		bOFDMSingleTone          0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect                0x100
+#define		bCFOEn                   0x10000
+#define		bCFOValue                0xfff00000
+#define		bSigTone_Re              0x3f
+#define		bSigTone_Im              0x7f00
+#define		bCounter_CCA             0xffff
+#define		bCounter_ParityFail      0xffff0000
+#define		bCounter_RateIllegal     0xffff
+#define		bCounter_CRC8Fail        0xffff0000
+#define		bCounter_MCSNoSupport    0xffff
+#define		bCounter_FastSync        0xffff
+#define		bShortCFO                0xfff
+#define		bShortCFOTLength         12   //total
+#define		bShortCFOFLength         11   //fraction
+#define		bLongCFO                 0x7ff
+#define		bLongCFOTLength          11
+#define		bLongCFOFLength          11
+#define		bTailCFO                 0x1fff
+#define		bTailCFOTLength          13
+#define		bTailCFOFLength          12       		
+#define		bmax_en_pwdB             0xffff
+#define		bCC_power_dB             0xffff0000
+#define		bnoise_pwdB              0xffff
+#define		bPowerMeasTLength        10
+#define		bPowerMeasFLength        3
+#define		bRx_HT_BW                0x1
+#define		bRxSC                    0x6
+#define		bRx_HT                   0x8       		
+#define		bNB_intf_det_on          0x1
+#define		bIntf_win_len_cfg        0x30
+#define		bNB_Intf_TH_cfg          0x1c0       		
+#define		bRFGain                  0x3f
+#define		bTableSel                0x40
+#define		bTRSW                    0x80       		
+#define		bRxSNR_A                 0xff
+#define		bRxSNR_B                 0xff00
+#define		bRxSNR_C                 0xff0000
+#define		bRxSNR_D                 0xff000000
+#define		bSNREVMTLength           8
+#define		bSNREVMFLength           1       		
+#define		bCSI1st                  0xff
+#define		bCSI2nd                  0xff00
+#define		bRxEVM1st                0xff0000
+#define		bRxEVM2nd                0xff000000       		
+#define		bSIGEVM                  0xff
+#define		bPWDB                    0xff00
+#define		bSGIEN                   0x10000
+       		
+#define		bSFactorQAM1             0xf	// Useless
+#define		bSFactorQAM2             0xf0
+#define		bSFactorQAM3             0xf00
+#define		bSFactorQAM4             0xf000
+#define		bSFactorQAM5             0xf0000
+#define		bSFactorQAM6             0xf0000
+#define		bSFactorQAM7             0xf00000
+#define		bSFactorQAM8             0xf000000
+#define		bSFactorQAM9             0xf0000000
+#define		bCSIScheme               0x100000
+       		
+#define		bNoiseLvlTopSet          0x3	// Useless
+#define		bChSmooth                0x4
+#define		bChSmoothCfg1            0x38
+#define		bChSmoothCfg2            0x1c0
+#define		bChSmoothCfg3            0xe00
+#define		bChSmoothCfg4            0x7000
+#define		bMRCMode                 0x800000
+#define		bTHEVMCfg                0x7000000
+       		
+#define		bLoopFitType             0x1	// Useless
+#define		bUpdCFO                  0x40
+#define		bUpdCFOOffData           0x80
+#define		bAdvUpdCFO               0x100
+#define		bAdvTimeCtrl             0x800
+#define		bUpdClko                 0x1000
+#define		bFC                      0x6000
+#define		bTrackingMode            0x8000
+#define		bPhCmpEnable             0x10000
+#define		bUpdClkoLTF              0x20000
+#define		bComChCFO                0x40000
+#define		bCSIEstiMode             0x80000
+#define		bAdvUpdEqz               0x100000
+#define		bUChCfg                  0x7000000
+#define		bUpdEqz                  0x8000000
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn         0x20000000	// Useless
+#define		bRxPesudoNoise_A         0xff
+#define		bRxPesudoNoise_B         0xff00
+#define		bRxPesudoNoise_C         0xff0000
+#define		bRxPesudoNoise_D         0xff000000
+#define		bPesudoNoiseState_A      0xffff
+#define		bPesudoNoiseState_B      0xffff0000
+#define		bPesudoNoiseState_C      0xffff
+#define		bPesudoNoiseState_D      0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable        0x8		// Useless
+#define		bZebra1_TRxControl        0xc00
+#define		bZebra1_TRxGainSetting    0x07f
+#define		bZebra1_RxCorner          0xc00
+#define		bZebra1_TxChargePump      0x38
+#define		bZebra1_RxChargePump      0x7
+#define		bZebra1_ChannelNum        0xf80
+#define		bZebra1_TxLPFBW           0x400
+#define		bZebra1_RxLPFBW           0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1      0x100	// Useless
+#define		bRTL8256RegModeCtrl0      0x40
+#define		bRTL8256_TxLPFBW          0x18
+#define		bRTL8256_RxLPFBW          0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW          0xc	// Useless
+#define		bRTL8258_RxLPFBW          0xc00
+#define		bRTL8258_RSSILPFBW        0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0                    0x1	// Useless
+#define		bByte1                    0x2
+#define		bByte2                    0x4
+#define		bByte3                    0x8
+#define		bWord0                    0x3
+#define		bWord1                    0xc
+#define		bDWord                    0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0                0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1                0xff00
+#define		bMaskByte2                0xff0000
+#define		bMaskByte3                0xff000000
+#define		bMaskHWord                0xffff0000
+#define		bMaskLWord                0x0000ffff
+#define		bMaskDWord                0xffffffff
+#define		bMaskH4Bits		  0xf0000000	
+#define 		bMaskOFDM_D	  0xffc00000
+#define		bMaskCCK		  0x3f3f3f3f
+#define		bMask12Bits			0xfff	
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+//#define		bMask12Bits               0xfffff	// RF Reg mask bits
+//#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask	0xfffff		
+  		
+#define		bEnable                   0x1	// Useless
+#define		bDisable                  0x0
+       		
+#define		LeftAntenna               0x0	// Useless
+#define		RightAntenna              0x1
+       		
+#define		tCheckTxStatus            500   //500ms // Useless
+#define		tUpdateRxCounter          100   //100ms
+       		
+#define		rateCCK     0	// Useless
+#define		rateOFDM    1
+#define		rateHT      2
+
+//define Register-End
+#define		bPMAC_End                 0x1ff	// Useless
+#define		bFPGAPHY0_End             0x8ff
+#define		bFPGAPHY1_End             0x9ff
+#define		bCCKPHY0_End              0xaff
+#define		bOFDMPHY0_End             0xcff
+#define		bOFDMPHY1_End             0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl              0x0		// Useless
+#define		bWMACControl              0x1
+#define		bWNICControl              0x2
+       		
+#define		PathA                     0x0	// Useless
+#define		PathB                     0x1
+#define		PathC                     0x2
+#define		PathD                     0x3
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	//__INC_HAL8192SPHYREG_H
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/Hal8192CUHWImg.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/Hal8192CUHWImg.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/Hal8192CUHWImg.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/Hal8192CUHWImg.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8192CU_FW_IMG_H
+#define __INC_HAL8192CU_FW_IMG_H
+
+/*Created on  2010/ 5/25,  2:21*/
+
+//#define TSMCImgArrayLength 16226 //v66 2011-02-10
+#define TSMCImgArrayLength 16352 //v68.1 2011-02-24
+extern u8 Rtl8192CUFwTSMCImgArray[TSMCImgArrayLength];
+
+//#define UMCImgArrayLength 16226 //V66 2011-02-10
+#define UMCACutImgArrayLength 16352 //v68.1 2011-02-24
+extern u8 Rtl8192CUFwUMCACutImgArray[UMCACutImgArrayLength];
+
+#define UMCBCutImgArrayLength 16334 //v68.1 2011-02-24
+extern u8 Rtl8192CUFwUMCBCutImgArray[UMCBCutImgArrayLength] ; 
+	
+//#define UMCBCutImgArrayLength 16206
+//extern u1Byte Rtl8192CUFwUMCBCutImgArray[UMCBCutImgArrayLength];
+
+#define UMC8723ImgArrayLength 16288
+extern u8 Rtl8192CUFwUMC8723ImgArray[UMC8723ImgArrayLength];
+#define PHY_REG_2TArrayLength 374
+extern u32  Rtl8192CUPHY_REG_2TArray[PHY_REG_2TArrayLength];
+#define PHY_REG_1TArrayLength 374
+extern u32 Rtl8192CUPHY_REG_1TArray[PHY_REG_1TArrayLength];
+#define PHY_ChangeTo_1T1RArrayLength 1
+extern u32 Rtl8192CUPHY_ChangeTo_1T1RArray[PHY_ChangeTo_1T1RArrayLength];
+#define PHY_ChangeTo_1T2RArrayLength 1
+extern u32 Rtl8192CUPHY_ChangeTo_1T2RArray[PHY_ChangeTo_1T2RArrayLength];
+#define PHY_ChangeTo_2T2RArrayLength 1
+extern u32 Rtl8192CUPHY_ChangeTo_2T2RArray[PHY_ChangeTo_2T2RArrayLength];
+#define PHY_REG_Array_PGLength 336
+extern u32 Rtl8192CUPHY_REG_Array_PG[PHY_REG_Array_PGLength];
+#define PHY_REG_Array_PG_mCardLength 336
+extern u32 Rtl8192CUPHY_REG_Array_PG_mCard[PHY_REG_Array_PG_mCardLength];
+#define PHY_REG_Array_MPLength 4
+extern u32 Rtl8192CUPHY_REG_Array_MP[PHY_REG_Array_MPLength];
+#define PHY_REG_1T_HPArrayLength 378
+extern u32 Rtl8192CUPHY_REG_1T_HPArray[PHY_REG_1T_HPArrayLength];
+#define PHY_REG_1T_mCardArrayLength 374
+extern u32 Rtl8192CUPHY_REG_1T_mCardArray[PHY_REG_1T_mCardArrayLength];
+#define PHY_REG_2T_mCardArrayLength 374
+extern u32 Rtl8192CUPHY_REG_2T_mCardArray[PHY_REG_2T_mCardArrayLength];
+#define PHY_REG_Array_PG_HPLength 336
+extern u32 Rtl8192CUPHY_REG_Array_PG_HP[PHY_REG_Array_PG_HPLength];
+#define RadioA_2TArrayLength 282
+extern u32 Rtl8192CURadioA_2TArray[RadioA_2TArrayLength];
+#define RadioB_2TArrayLength 78
+extern u32 Rtl8192CURadioB_2TArray[RadioB_2TArrayLength];
+#define RadioA_1TArrayLength 282
+extern u32 Rtl8192CURadioA_1TArray[RadioA_1TArrayLength];
+#define RadioB_1TArrayLength 1
+extern u32 Rtl8192CURadioB_1TArray[RadioB_1TArrayLength];
+#define RadioA_1T_mCardArrayLength 282
+extern u32 Rtl8192CURadioA_1T_mCardArray[RadioA_1T_mCardArrayLength];
+#define RadioB_1T_mCardArrayLength 1
+extern u32 Rtl8192CURadioB_1T_mCardArray[RadioB_1T_mCardArrayLength];
+#define RadioA_1T_HPArrayLength 282
+extern u32 Rtl8192CURadioA_1T_HPArray[RadioA_1T_HPArrayLength];
+#define RadioB_GM_ArrayLength 1
+extern u32 Rtl8192CURadioB_GM_Array[RadioB_GM_ArrayLength];
+#define MAC_2T_ArrayLength 172
+extern u32 Rtl8192CUMAC_2T_Array[MAC_2T_ArrayLength];
+#define MACPHY_Array_PGLength 1
+extern u32 Rtl8192CUMACPHY_Array_PG[MACPHY_Array_PGLength];
+#define AGCTAB_2TArrayLength 320
+extern u32 Rtl8192CUAGCTAB_2TArray[AGCTAB_2TArrayLength];
+#define AGCTAB_1TArrayLength 320
+extern u32 Rtl8192CUAGCTAB_1TArray[AGCTAB_1TArrayLength];
+#define AGCTAB_1T_HPArrayLength 320
+extern u32 Rtl8192CUAGCTAB_1T_HPArray[AGCTAB_1T_HPArrayLength];
+
+#endif //__INC_HAL8192CU_FW_IMG_H
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/hal_init.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/hal_init.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/hal_init.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/hal_init.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_INIT_H__
+#define __HAL_INIT_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+
+enum _CHIP_TYPE {
+
+	NULL_CHIP_TYPE,
+	RTL8712_8188S_8191S_8192S,
+	RTL8188C_8192C,
+	RTL8192D,
+	MAX_CHIP_TYPE
+};
+
+uint rtw_hal_init(_adapter *padapter);
+uint rtw_hal_deinit(_adapter *padapter);
+void rtw_hal_stop(_adapter *padapter);
+
+#ifdef CONFIG_RTL8711
+#include "rtl8711_hal.h"
+#endif
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_hal.h"
+#endif
+
+#ifdef CONFIG_RTL8192C
+#include "rtl8192c_hal.h"
+#endif
+
+#endif //__HAL_INIT_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/HalRf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/HalRf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/HalRf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/HalRf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,169 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ * 
+ *     (c) Copyright  2008, RealTEK Technologies Inc. All Rights Reserved.
+ * 
+ * Module:	HalRf.h	( Header File)
+ * 
+ * Note:	Collect every HAL RF type exter API or constant.	 
+ *
+ * Function:	
+ * 		 
+ * Export:	
+ * 
+ * Abbrev:	
+ * 
+ * History:
+ * Data			Who		Remark
+ * 
+ * 09/25/2008	MHC		Create initial version.
+ * 
+ * 
+******************************************************************************/
+#ifndef _HAL_RF_H_
+#define _HAL_RF_H_
+/* Check to see if the file has been included already.  */
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//
+// For RF 6052 Series
+//
+#define		RF6052_MAX_TX_PWR			0x3F
+#define		RF6052_MAX_REG				0x3F
+#define		RF6052_MAX_PATH				2
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/ 
+
+/*------------------------------Define structure----------------------------*/ 
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+/*------------------------Export Marco Definition---------------------------*/
+
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+//======================================================
+// Function prototypes for HalPhy8225.c
+//1======================================================
+
+extern	void	PHY_SetRF8225OfdmTxPower(	IN	PADAPTER		Adapter,
+												IN	u8			powerlevel);
+extern	void	PHY_SetRF8225CckTxPower(	IN	PADAPTER		Adapter,
+											IN	u8			powerlevel	);
+extern	void	PHY_SetRF8225Bandwidth(	IN	PADAPTER		Adapter,
+											IN	HT_CHANNEL_WIDTH	Bandwidth);	
+extern	int	PHY_RF8225_Config(	IN	PADAPTER		Adapter	);
+
+
+//1======================================================
+// Function prototypes for HalPhy8256.c
+//1======================================================
+extern	void	PHY_SetRF8256OFDMTxPower(	IN	PADAPTER	Adapter,
+											IN	u8			powerlevel	);
+extern	void	PHY_SetRF8256CCKTxPower(	IN	PADAPTER	Adapter,
+											IN	u8			powerlevel	);
+extern	void	PHY_SetRF8256Bandwidth(	IN	PADAPTER		Adapter,
+										IN	HT_CHANNEL_WIDTH	Bandwidth);	
+extern	int	PHY_RF8256_Config(	IN	PADAPTER		Adapter	);
+
+
+//
+// RF RL6052 Series API
+//
+extern	void		RF_ChangeTxPath(	IN	PADAPTER	Adapter, 
+										IN	u16		DataRate);
+extern	void		PHY_RF6052SetBandwidth(	
+										IN	PADAPTER				Adapter,
+										IN	HT_CHANNEL_WIDTH		Bandwidth);	
+extern	VOID	PHY_RF6052SetCckTxPower(
+										IN	PADAPTER	Adapter,
+										IN	u8*		pPowerlevel);
+extern	VOID	PHY_RF6052SetOFDMTxPower(
+										IN	PADAPTER	Adapter,
+										IN	u8*		pPowerLevel,
+										IN	u8		Channel);
+extern	int	PHY_RF6052_Config(	IN	PADAPTER		Adapter	);
+
+//
+// RF Shadow operation relative API
+//
+extern	u32
+PHY_RFShadowRead(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset);
+extern	VOID
+PHY_RFShadowWrite(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u32				Data);
+extern	BOOLEAN
+PHY_RFShadowCompare(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset);
+extern	VOID
+PHY_RFShadowRecorver(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset);
+extern	VOID
+PHY_RFShadowCompareAll(
+	IN	PADAPTER			Adapter);
+extern	VOID
+PHY_RFShadowRecorverAll(
+	IN	PADAPTER			Adapter);
+extern	VOID
+PHY_RFShadowCompareFlagSet(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u8				Type);
+extern	VOID
+PHY_RFShadowRecorverFlagSet(
+	IN	PADAPTER			Adapter,
+	IN	RF90_RADIO_PATH_E	eRFPath,
+	IN	u32				Offset,
+	IN	u8				Type);
+extern	VOID
+PHY_RFShadowCompareFlagSetAll(
+	IN	PADAPTER			Adapter);
+extern	VOID
+PHY_RFShadowRecorverFlagSetAll(
+	IN	PADAPTER			Adapter);
+extern	VOID
+PHY_RFShadowRefresh(
+	IN	PADAPTER			Adapter);
+/*--------------------------Exported Function prototype---------------------*/
+
+
+#endif/* End of HalRf.h */
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ieee80211_ext.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ieee80211_ext.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ieee80211_ext.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ieee80211_ext.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,477 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_EXT_H
+#define __IEEE80211_EXT_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define WMM_OUI_TYPE 2
+#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WMM_VERSION 1
+
+#define WPA_PROTO_WPA BIT(0)
+#define WPA_PROTO_RSN BIT(1)
+
+#define WPA_KEY_MGMT_IEEE8021X BIT(0)
+#define WPA_KEY_MGMT_PSK BIT(1)
+#define WPA_KEY_MGMT_NONE BIT(2)
+#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
+#define WPA_KEY_MGMT_WPA_NONE BIT(4)
+
+
+#define WPA_CAPABILITY_PREAUTH BIT(0)
+#define WPA_CAPABILITY_MGMT_FRAME_PROTECTION BIT(6)
+#define WPA_CAPABILITY_PEERKEY_ENABLED BIT(9)
+
+
+#define PMKID_LEN 16
+
+
+#ifdef PLATFORM_LINUX
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct wme_ac_parameter {
+#if defined(CONFIG_LITTLE_ENDIAN)
+	/* byte 1 */
+	u8 	aifsn:4,
+		acm:1,
+	 	aci:2,
+	 	reserved:1;
+
+	/* byte 2 */
+	u8 	eCWmin:4,
+	 	eCWmax:4;
+#elif defined(CONFIG_BIG_ENDIAN)
+	/* byte 1 */
+	u8 	reserved:1,
+	 	aci:2,
+	 	acm:1,
+	 	aifsn:4;
+
+	/* byte 2 */
+	u8 	eCWmax:4,
+	 	eCWmin:4;
+#else
+#error	"Please fix <endian.h>"
+#endif
+
+	/* bytes 3 & 4 */
+	u16 txopLimit;
+} __attribute__ ((packed));
+
+struct wme_parameter_element {
+	/* required fields for WME version 1 */
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	u8 acInfo;
+	u8 reserved;
+	struct wme_ac_parameter ac[4];
+
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+};
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+};
+
+#pragma pack()
+
+#endif
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RSN_SELECTOR_PUT(a, val) WPA_PUT_BE32((u8 *) (a), (val))
+//#define RSN_SELECTOR_PUT(a, val) WPA_PUT_LE32((u8 *) (a), (val))
+
+
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_WMM = 17,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum ieee80211_ht_actioncode {
+	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       WLAN_ACTION_SM_PS = 1,
+       WLAN_ACTION_PSPM = 2,
+       WLAN_ACTION_PCO_PHASE = 3,
+       WLAN_ACTION_MIMO_CSI_MX = 4,
+       WLAN_ACTION_MIMO_NONCP_BF = 5,
+       WLAN_ACTION_MIMP_CP_BF = 6,
+       WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+	WLAN_BACK_TIMER = 2,
+};
+
+#ifdef PLATFORM_LINUX
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  __attribute__ ((packed)) auth;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) reassoc_req;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) disassoc;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  __attribute__ ((packed)) beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_req;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) wme_action;
+#if 0
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_channel_sw_ie sw_elem;
+				}  __attribute__ ((packed)) chan_switch;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_msrment_ie msr_elem;
+				}  __attribute__ ((packed)) measurement;
+#endif
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  __attribute__ ((packed)) addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  __attribute__ ((packed)) addba_resp;
+				struct{
+					u8 action_code;
+					u16 params;
+					u16 reason_code;
+				}  __attribute__ ((packed)) delba;
+				struct{
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  __attribute__ ((packed)) plink_action;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) mesh_action;
+			} __attribute__ ((packed)) u;
+		}  __attribute__ ((packed)) action;
+	} __attribute__ ((packed)) u;
+}__attribute__ ((packed));
+
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  auth;
+		struct {
+			u16 reason_code;
+		}  deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  reassoc_req;
+		struct {
+			u16 reason_code;
+		}  disassoc;
+#if 0		
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  probe_req;
+		
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  probe_resp;
+#endif	
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  wme_action;
+/*				
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_channel_sw_ie sw_elem;
+				}  chan_switch;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u8 element_id;
+					u8 length;
+					struct ieee80211_msrment_ie msr_elem;
+				}  measurement;
+*/				
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  addba_resp;
+				struct{
+					u8 action_code;
+					u16 params;
+					u16 reason_code;
+				}  delba;
+				struct{
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  plink_action;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				}  mesh_action;
+			} u;
+		}  action;
+	} u;
+} ;
+
+#pragma pack()
+
+#endif
+
+/* mgmt header + 1 byte category code */
+#define IEEE80211_MIN_ACTION_SIZE FIELD_OFFSET(struct ieee80211_mgmt, u.action.u)
+
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ieee80211.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ieee80211.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ieee80211.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ieee80211.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1239 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+
+#ifndef CONFIG_RTL8711FW
+
+	#include <drv_conf.h>
+	#include <osdep_service.h>
+	#include <drv_types.h>
+	#include "wifi.h"
+
+	#if defined PLATFORM_OS_XP
+	#include <ntstrsafe.h>
+	#endif
+	#if defined PLATFORM_LINUX
+	#include <linux/wireless.h>
+	#endif
+#else
+	
+	#include <list.h>
+
+#endif
+
+#define MGMT_QUEUE_NUM 5
+
+#define ETH_ALEN	6
+
+#ifdef CONFIG_AP_MODE
+
+#define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 14)
+
+/* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	RTL871X_HOSTAPD_FLUSH = 1,
+	RTL871X_HOSTAPD_ADD_STA = 2,
+	RTL871X_HOSTAPD_REMOVE_STA = 3,
+	RTL871X_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	RTL871X_SET_ENCRYPTION = 6,
+	RTL871X_GET_ENCRYPTION = 7,
+	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
+	RTL871X_HOSTAPD_GET_RID = 9,
+	RTL871X_HOSTAPD_SET_RID = 10,
+	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
+	RTL871X_HOSTAPD_MLME = 13,
+	RTL871X_HOSTAPD_SCAN_REQ = 14,
+	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
+	RTL871X_HOSTAPD_SET_BEACON=16,
+};
+
+/* STA flags */
+#define WLAN_STA_AUTH BIT(0)
+#define WLAN_STA_ASSOC BIT(1)
+#define WLAN_STA_PS BIT(2)
+#define WLAN_STA_TIM BIT(3)
+#define WLAN_STA_PERM BIT(4)
+#define WLAN_STA_AUTHORIZED BIT(5)
+#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
+#define WLAN_STA_SHORT_PREAMBLE BIT(7)
+#define WLAN_STA_PREAUTH BIT(8)
+#define WLAN_STA_WME BIT(9)
+#define WLAN_STA_MFP BIT(10)
+#define WLAN_STA_HT BIT(11)
+#define WLAN_STA_WPS BIT(12)
+#define WLAN_STA_MAYBE_WPS BIT(13)
+#define WLAN_STA_NONERP BIT(31)
+
+#endif
+
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE				2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME						4
+
+#define IEEE_PARAM_WPA_ENABLED				1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED			3
+#define IEEE_PARAM_PRIVACY_INVOKED			4
+#define IEEE_PARAM_AUTH_ALGS					5
+#define IEEE_PARAM_IEEE_802_1X				6
+#define IEEE_PARAM_WPAX_SELECT				7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH				1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE 	BIT(0)
+#define WPA_CIPHER_WEP40 	BIT(1)
+#define WPA_CIPHER_WEP104 BIT(2)
+#define WPA_CIPHER_TKIP 	BIT(3)
+#define WPA_CIPHER_CCMP 	BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN 4
+static u8 WPA_OUI_TYPE[] = { 0x00, 0x50, 0xf2, 1 };
+static u16 WPA_VERSION = 1;
+static u8 WPA_AUTH_KEY_MGMT_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+static u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x50, 0xf2, 1 };
+static u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x50, 0xf2, 2 };
+static u8 WPA_CIPHER_SUITE_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+static u8 WPA_CIPHER_SUITE_WEP40[] = { 0x00, 0x50, 0xf2, 1 };
+static u8 WPA_CIPHER_SUITE_TKIP[] = { 0x00, 0x50, 0xf2, 2 };
+//static u8 WPA_CIPHER_SUITE_WRAP[] = { 0x00, 0x50, 0xf2, 3 };
+static u8 WPA_CIPHER_SUITE_CCMP[] = { 0x00, 0x50, 0xf2, 4 };
+static u8 WPA_CIPHER_SUITE_WEP104[] = { 0x00, 0x50, 0xf2, 5 };
+
+
+#define RSN_HEADER_LEN 4
+#define RSN_SELECTOR_LEN 4
+static u16 RSN_VERSION = 1;
+static u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x0f, 0xac, 1 };
+static u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x0f, 0xac, 2 };
+static u8 RSN_CIPHER_SUITE_NONE[] = { 0x00, 0x0f, 0xac, 0 };
+static u8 RSN_CIPHER_SUITE_WEP40[] = { 0x00, 0x0f, 0xac, 1 };
+static u8 RSN_CIPHER_SUITE_TKIP[] = { 0x00, 0x0f, 0xac, 2 };
+//static u8 RSN_CIPHER_SUITE_WRAP[] = { 0x00, 0x0f, 0xac, 3 };
+static u8 RSN_CIPHER_SUITE_CCMP[] = { 0x00, 0x0f, 0xac, 4 };
+static u8 RSN_CIPHER_SUITE_WEP104[] = { 0x00, 0x0f, 0xac, 5 };
+
+
+
+enum NETWORK_TYPE
+{
+	WIRELESS_INVALID	= 0,
+	WIRELESS_11B = 1,
+	WIRELESS_11G = 2,
+	WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G),
+	WIRELESS_11A = 4,
+	WIRELESS_11N = 8,
+	WIRELESS_11GN = (WIRELESS_11G|WIRELESS_11N),
+	WIRELESS_11BGN = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11N),
+};
+
+
+typedef struct ieee_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+        union {
+		struct {
+			u8 name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			u8 reserved[32];
+			u8 data[0];
+		} wpa_ie;
+	        struct{
+			int command;
+    			int reason_code;
+		} mlme;
+		struct {
+			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
+			u8 set_tx;
+			u32 err;
+			u8 idx;
+			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			u8 key[0];
+		} crypt;
+#ifdef CONFIG_AP_MODE
+		struct {
+			u16 aid;
+			u16 capability;
+			int flags;
+			u8 tx_supp_rates[16];		
+			struct ieee80211_ht_cap ht_cap;
+		} add_sta;
+		struct {
+			u8	reserved[2];
+			u8	buf[0];
+		} bcn_ie;
+#endif
+
+	} u;	   
+}ieee_param;
+
+
+#if WIRELESS_EXT < 17
+#define IW_QUAL_QUAL_INVALID   0x10
+#define IW_QUAL_LEVEL_INVALID  0x20
+#define IW_QUAL_NOISE_INVALID  0x40
+#define IW_QUAL_QUAL_UPDATED   0x1
+#define IW_QUAL_LEVEL_UPDATED  0x2
+#define IW_QUAL_NOISE_UPDATED  0x4
+#endif
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	u8 mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	_list	list;
+};
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} __attribute__ ((packed));
+
+struct ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+} __attribute__ ((packed));
+
+
+struct	ieee80211_hdr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+	u16	qc;
+}  __attribute__ ((packed));
+
+struct  ieee80211_hdr_3addr_qos {
+        u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+       u16     qc;
+}  __attribute__ ((packed));
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} __attribute__ ((packed));
+
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+};
+
+struct ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+};
+
+
+struct	ieee80211_hdr_qos {
+	struct	ieee80211_hdr wlan_hdr;
+	u16	qc;
+};
+
+struct  ieee80211_hdr_3addr_qos {
+        struct  ieee80211_hdr_3addr wlan_hdr;
+        u16     qc;
+};
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+};
+#pragma pack()
+
+#endif
+
+
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define IEEE80211_FCTL_VERS		0x0002
+#define IEEE80211_FCTL_FTYPE		0x000c
+#define IEEE80211_FCTL_STYPE		0x00f0
+#define IEEE80211_FCTL_TODS		0x0100
+#define IEEE80211_FCTL_FROMDS		0x0200
+#define IEEE80211_FCTL_MOREFRAGS	0x0400
+#define IEEE80211_FCTL_RETRY		0x0800
+#define IEEE80211_FCTL_PM		0x1000
+#define IEEE80211_FCTL_MOREDATA	0x2000
+#define IEEE80211_FCTL_WEP		0x4000
+#define IEEE80211_FCTL_ORDER		0x8000
+
+#define IEEE80211_FTYPE_MGMT		0x0000
+#define IEEE80211_FTYPE_CTL		0x0004
+#define IEEE80211_FTYPE_DATA		0x0008
+
+/* management */
+#define IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define IEEE80211_STYPE_ASSOC_RESP 	0x0010
+#define IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define IEEE80211_STYPE_PROBE_REQ	0x0040
+#define IEEE80211_STYPE_PROBE_RESP	0x0050
+#define IEEE80211_STYPE_BEACON		0x0080
+#define IEEE80211_STYPE_ATIM		0x0090
+#define IEEE80211_STYPE_DISASSOC	0x00A0
+#define IEEE80211_STYPE_AUTH		0x00B0
+#define IEEE80211_STYPE_DEAUTH		0x00C0
+
+/* control */
+#define IEEE80211_STYPE_PSPOLL		0x00A0
+#define IEEE80211_STYPE_RTS		0x00B0
+#define IEEE80211_STYPE_CTS		0x00C0
+#define IEEE80211_STYPE_ACK		0x00D0
+#define IEEE80211_STYPE_CFEND		0x00E0
+#define IEEE80211_STYPE_CFENDACK	0x00F0
+
+/* data */
+#define IEEE80211_STYPE_DATA		0x0000
+#define IEEE80211_STYPE_DATA_CFACK	0x0010
+#define IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define IEEE80211_STYPE_NULLFUNC	0x0040
+#define IEEE80211_STYPE_CFACK		0x0050
+#define IEEE80211_STYPE_CFPOLL		0x0060
+#define IEEE80211_STYPE_CFACKPOLL	0x0070
+#define IEEE80211_QOS_DATAGRP		0x0080
+#define IEEE80211_QoS_DATAGRP		IEEE80211_QOS_DATAGRP	
+
+#define IEEE80211_SCTL_FRAG		0x000F
+#define IEEE80211_SCTL_SEQ		0xFFF0
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_snap_hdr {
+
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_snap_hdr {
+
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+};
+#pragma pack()
+
+#endif
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+#define WLAN_EID_RSN 48
+#define WLAN_EID_GENERIC 221
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN  		4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN 		8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
+	IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
+        IEEE80211_CCK_RATE_5MB_MASK | \
+        IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+	IEEE80211_OFDM_RATE_12MB_MASK | \
+	IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
+	IEEE80211_OFDM_RATE_9MB_MASK  | \
+	IEEE80211_OFDM_RATE_18MB_MASK | \
+	IEEE80211_OFDM_RATE_36MB_MASK | \
+	IEEE80211_OFDM_RATE_48MB_MASK | \
+	IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+                                IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	//u32 mac_time[2];
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 received_channel;
+	u16 rate; /* in 100 kbps */
+	//u8 control;
+	u8 mask;
+	u8 freq;
+	u16 len;
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	u32 first_frag_time;
+	uint seq;
+	uint last_frag;
+	uint qos;   //jackson
+	uint tid;	//jackson
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	uint tx_unicast_frames;
+	uint tx_multicast_frames;
+	uint tx_fragments;
+	uint tx_unicast_octets;
+	uint tx_multicast_octets;
+	uint tx_deferred_transmissions;
+	uint tx_single_retry_frames;
+	uint tx_multiple_retry_frames;
+	uint tx_retry_limit_exceeded;
+	uint tx_discards;
+	uint rx_unicast_frames;
+	uint rx_multicast_frames;
+	uint rx_fragments;
+	uint rx_unicast_octets;
+	uint rx_multicast_octets;
+	uint rx_fcs_errors;
+	uint rx_discards_no_buffer;
+	uint tx_discards_wrong_sa;
+	uint rx_discards_undecryptable;
+	uint rx_message_in_msg_fragments;
+	uint rx_message_in_bad_msg_fragments;
+};
+
+struct ieee80211_softmac_stats{
+	uint rx_ass_ok;
+	uint rx_ass_err;
+	uint rx_probe_rq;
+	uint tx_probe_rs;
+	uint tx_beacons;
+	uint rx_auth_rq;
+	uint rx_auth_rs_ok;
+	uint rx_auth_rs_err;
+	uint tx_auth_rq;
+	uint no_auth_rs;
+	uint no_ass_rs;
+	uint tx_ass_rq;
+	uint rx_ass_rq;
+	uint tx_probe_rq;
+	uint reassoc;
+	uint swtxstop;
+	uint swtxawake;
+};
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} __attribute__ ((packed));
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} ;
+#pragma pack()
+
+#endif
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} __attribute__ ((packed));
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} __attribute__ ((packed));
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} ;
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} ;
+#pragma pack()
+
+#endif
+
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)
+
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	//struct ieee80211_info_element_hdr info_element;
+} __attribute__ ((packed));
+
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+	/*struct ieee80211_info_element info_element;*/
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_request_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	//u8 current_ap[ETH_ALEN];
+	struct ieee80211_info_element_hdr info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_response_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+//	struct ieee80211_info_element info_element; /* supported rates */
+} __attribute__ ((packed));
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	//struct ieee80211_info_element_hdr info_element;
+} ;
+
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} ;
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+	/*struct ieee80211_info_element info_element;*/
+} ;
+
+struct ieee80211_assoc_request_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	//u8 current_ap[ETH_ALEN];
+	struct ieee80211_info_element_hdr info_element;
+} ;
+
+struct ieee80211_assoc_response_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+//	struct ieee80211_info_element info_element; /* supported rates */
+};
+
+#pragma pack()
+
+#endif
+
+
+
+
+struct ieee80211_txb {
+	u8 nr_frags;
+	u8 encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+//(HZ / 2)
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN 128
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+#if 0
+struct ieee80211_network {
+	/* These entries are used to identify a unique network */
+	u8 bssid[ETH_ALEN];
+	u8 channel;
+	/* Ensure null-terminated for any debug msgs */
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
+	u8	rssi;	//relative signal strength
+	u8	sq;		//signal quality
+
+	/* These are network statistics */
+	//struct ieee80211_rx_stats stats;
+	u16 capability;
+	u16	aid;
+	u8 rates[MAX_RATES_LENGTH];
+	u8 rates_len;
+	u8 rates_ex[MAX_RATES_EX_LENGTH];
+	u8 rates_ex_len;
+	
+	u8 edca_parmsets[18];
+		
+	u8 mode;
+	u8 flags;
+	u8 time_stamp[8];
+	u16 beacon_interval;
+	u16 listen_interval;
+	u16 atim_window;
+	u8 wpa_ie[MAX_WPA_IE_LEN];
+	size_t wpa_ie_len;
+	u8 rsn_ie[MAX_WPA_IE_LEN];
+	size_t rsn_ie_len;
+	u8 country[6];
+	u8 dtim_period;
+	u8 dtim_data;
+	u8 power_constraint;
+	u8 qosinfo;
+	u8 qbssload[5];
+	u8 network_type;
+	int join_res;
+	unsigned long	last_scanned;	
+};
+#endif
+/*
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+*/
+
+enum ieee80211_state {
+
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+	
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+	
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+	
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+	
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+	
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+	
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+	
+};
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5]
+
+#ifdef PLATFORM_OS_XP
+extern __inline int is_multicast_ether_addr(const u8 *addr)
+{
+        return ((addr[0] != 0xff) && (0x01 & addr[0]));
+}
+
+extern __inline int is_broadcast_ether_addr(const u8 *addr)
+{
+	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
+		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
+}
+#endif
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+typedef struct tx_pending_t{
+	int frag;
+	struct ieee80211_txb *txb;
+}tx_pending_t;
+
+
+
+#define MAXTID	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
+
+extern __inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+{
+	/* Single white space is for Linksys APs */
+	if (essid_len == 1 && essid[0] == ' ')
+		return 1;
+
+	/* Otherwise, if the entire essid is 0, we assume it is hidden */
+	while (essid_len) {
+		essid_len--;
+		if (essid[essid_len] != '\0')
+			return 0;
+	}
+
+	return 1;
+}
+
+extern __inline int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case IEEE80211_FTYPE_DATA:
+		if (fc & IEEE80211_QOS_DATAGRP)
+			hdrlen += 2;
+		if ((fc & IEEE80211_FCTL_FROMDS) && (fc & IEEE80211_FCTL_TODS))
+			hdrlen += 6; /* Addr4 */
+		break;
+	case IEEE80211_FTYPE_CTL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case IEEE80211_STYPE_CTS:
+		case IEEE80211_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+
+	return hdrlen;
+}
+
+#if 0
+/* Action frame categories (IEEE 802.11-2007, 7.3.1.11, Table 7-24) */
+#define WLAN_ACTION_SPECTRUM_MGMT 0
+#define WLAN_ACTION_QOS 1
+#define WLAN_ACTION_DLS 2
+#define WLAN_ACTION_BLOCK_ACK 3
+#define WLAN_ACTION_RADIO_MEASUREMENT 5
+#define WLAN_ACTION_FT 6
+#define WLAN_ACTION_SA_QUERY 8
+#define WLAN_ACTION_WMM 17
+#endif
+
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_PUBLIC = 4, //P2P public action frames
+	WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
+	WLAN_CATEGORY_FT = 6,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_SA_QUERY = 8,
+	WLAN_CATEGORY_WMM = 17,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+enum _PUBLIC_ACTION{
+	ACT_PUBLIC_BSSCOEXIST = 0, // 20/40 BSS Coexistence
+	ACT_PUBLiC_MP = 7, // Measurement Pilot
+};
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum ieee80211_ht_actioncode {
+	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       WLAN_ACTION_SM_PS = 1,
+       WLAN_ACTION_PSPM = 2,
+       WLAN_ACTION_PCO_PHASE = 3,
+       WLAN_ACTION_MIMO_CSI_MX = 4,
+       WLAN_ACTION_MIMO_NONCP_BF = 5,
+       WLAN_ACTION_MIMP_CP_BF = 6,
+       WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+	WLAN_BACK_TIMER = 2,
+};
+
+
+u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
+u8 *rtw_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen);
+u8 *rtw_get_ie(u8*pbuf, sint index, sint *len, sint limit);
+void rtw_set_supported_rate(u8* SupportedRates, uint mode) ;
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit);
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+int rtw_get_wpa_cipher_suite(u8 *s);
+int rtw_get_wpa2_cipher_suite(u8 *s);
+int rtw_parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher);
+int rtw_parse_wpa2_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher);
+
+int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len);
+int rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
+
+uint	rtw_get_rateset_len(u8	*rateset);
+
+struct registry_priv;
+int rtw_generate_ie(struct registry_priv *pregistrypriv);
+
+
+int rtw_get_bit_value_from_ieee_value(u8 val);
+
+uint	rtw_is_cckrates_included(u8 *rate);
+
+uint	rtw_is_cckratesonly_included(u8 *rate);
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel);
+
+
+#endif /* IEEE80211_H */
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/if_ether.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/if_ether.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/if_ether.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/if_ether.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,132 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@redhat.com>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence). 
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+ 
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+ 
+struct ethhdr 
+{
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+};
+
+struct _vlan {
+   unsigned short       h_vlan_TCI;                // Encapsulates priority and VLAN ID
+   unsigned short       h_vlan_encapsulated_proto;
+};
+
+
+
+#define get_vlan_id(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI)) & 0xfff)
+#define get_vlan_priority(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI))>>13)
+#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short )pvlan->h_vlan_encapsulated_proto))
+
+
+#endif	/* _LINUX_IF_ETHER_H */
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ip.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ip.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/ip.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/ip.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,158 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the IP protocol.
+ *
+ * Version:	@(#)ip.h	1.0.2	04/28/93
+ *
+ * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+#include <rtw_byteorder.h>
+
+/* SOL_IP socket options */
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 |IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
+#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
+#define IPOPT_RR	(7 |IPOPT_CONTROL)
+#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+/* struct timestamp, struct route and MAX_ROUTES are removed.
+
+   REASONS: it is clear that nobody used them because:
+   - MAX_ROUTES value was wrong.
+   - "struct route" was wrong.
+   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
+ */
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+#ifdef PLATFORM_LINUX
+
+struct ip_options {
+  __u32		faddr;				/* Saved first hop address */
+  unsigned char	optlen;
+  unsigned char srr;
+  unsigned char rr;
+  unsigned char ts;
+  unsigned char is_setbyuser:1,			/* Set by setsockopt?			*/
+                is_data:1,			/* Options in __data, rather than skb	*/
+                is_strictroute:1,		/* Strict source route			*/
+                srr_is_hit:1,			/* Packet destination addr was our one	*/
+                is_changed:1,			/* IP checksum more not valid		*/	
+                rr_needaddr:1,			/* Need to record addr of outgoing dev	*/
+                ts_needtime:1,			/* Need to record timestamp		*/
+                ts_needaddr:1;			/* Need to record addr of outgoing dev  */
+  unsigned char router_alert;
+  unsigned char __pad1;
+  unsigned char __pad2;
+  unsigned char __data[0];
+};
+
+#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
+#endif
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+  		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__u16	tot_len;
+	__u16	id;
+	__u16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__u16	check;
+	__u32	saddr;
+	__u32	daddr;
+	/*The options start here. */
+};
+
+#endif	/* _LINUX_IP_H */
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/mlme_osdep.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/mlme_osdep.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/mlme_osdep.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/mlme_osdep.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#if defined(PLATFORM_WINDOWS) || defined(PLATFORM_MPIXEL)
+extern int time_after(u32 now, u32 old);
+#endif
+
+extern void rtw_init_mlme_timer(_adapter *padapter);
+extern void rtw_os_indicate_disconnect( _adapter *adapter );
+extern void rtw_os_indicate_connect( _adapter *adapter );
+extern void rtw_report_sec_ie(_adapter *adapter,u8 authmode,u8 *sec_ie);
+extern void rtw_reset_securitypriv( _adapter *adapter );
+
+#endif	//_MLME_OSDEP_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/mp_custom_oid.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/mp_custom_oid.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/mp_custom_oid.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/mp_custom_oid.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,353 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__CUSTOM_OID_H
+#define __CUSTOM_OID_H
+
+// by Owen
+// 0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit
+// 0xFF818500 - 0xFF81850F		RTL8185 Setup Utility
+// 0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility
+
+//
+
+// by Owen for Production Kit
+// For Production Kit with Agilent Equipments
+// in order to make our custom oids hopefully somewhat unique
+// we will use 0xFF (indicating implementation specific OID)
+//               81(first byte of non zero Realtek unique identifier)
+//               80 (second byte of non zero Realtek unique identifier)
+//               XX (the custom OID number - providing 255 possible custom oids)
+
+#define OID_RT_PRO_RESET_DUT				0xFF818000
+#define OID_RT_PRO_SET_DATA_RATE			0xFF818001
+#define OID_RT_PRO_START_TEST				0xFF818002
+#define OID_RT_PRO_STOP_TEST    			0xFF818003
+#define OID_RT_PRO_SET_PREAMBLE				0xFF818004
+#define OID_RT_PRO_SET_SCRAMBLER			0xFF818005
+#define OID_RT_PRO_SET_FILTER_BB			0xFF818006
+#define OID_RT_PRO_SET_MANUAL_DIVERSITY_BB		0xFF818007
+#define OID_RT_PRO_SET_CHANNEL_DIRECT_CALL		0xFF818008
+#define OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL		0xFF818009
+#define OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL		0xFF81800A
+
+#define OID_RT_PRO_SET_TX_ANTENNA_BB			0xFF81800D
+#define OID_RT_PRO_SET_ANTENNA_BB			0xFF81800E
+#define OID_RT_PRO_SET_CR_SCRAMBLER			0xFF81800F
+#define OID_RT_PRO_SET_CR_NEW_FILTER			0xFF818010
+#define OID_RT_PRO_SET_TX_POWER_CONTROL			0xFF818011
+#define OID_RT_PRO_SET_CR_TX_CONFIG			0xFF818012
+#define OID_RT_PRO_GET_TX_POWER_CONTROL			0xFF818013
+#define OID_RT_PRO_GET_CR_SIGNAL_QUALITY		0xFF818014
+#define OID_RT_PRO_SET_CR_SETPOINT			0xFF818015
+#define OID_RT_PRO_SET_INTEGRATOR			0xFF818016
+#define OID_RT_PRO_SET_SIGNAL_QUALITY			0xFF818017
+#define OID_RT_PRO_GET_INTEGRATOR			0xFF818018
+#define OID_RT_PRO_GET_SIGNAL_QUALITY			0xFF818019
+#define OID_RT_PRO_QUERY_EEPROM_TYPE			0xFF81801A
+#define OID_RT_PRO_WRITE_MAC_ADDRESS			0xFF81801B
+#define OID_RT_PRO_READ_MAC_ADDRESS			0xFF81801C
+#define OID_RT_PRO_WRITE_CIS_DATA			0xFF81801D
+#define OID_RT_PRO_READ_CIS_DATA			0xFF81801E
+#define OID_RT_PRO_WRITE_POWER_CONTROL			0xFF81801F
+#define OID_RT_PRO_READ_POWER_CONTROL			0xFF818020
+#define OID_RT_PRO_WRITE_EEPROM				0xFF818021
+#define OID_RT_PRO_READ_EEPROM				0xFF818022
+#define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
+#define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025 
+#define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
+#define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
+#define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
+#define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
+#define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
+#define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
+// added by Owen on 04/08/03 for Cameo's request
+#define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
+#define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
+#define OID_RT_PRO_SET_MODULATION			0xFF81802F
+//
+
+//Sean		
+#define OID_RT_DRIVER_OPTION				0xFF818080
+#define OID_RT_RF_OFF					0xFF818081
+#define OID_RT_AUTH_STATUS				0xFF818082
+
+//========================================================================
+#define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
+#define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
+#define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
+#define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
+//========================================================================
+
+
+// by Owen for RTL8185 Phy Status Report Utility
+#define OID_RT_UTILITY_FALSE_ALARM_COUNTERS				0xFF818580
+#define OID_RT_UTILITY_SELECT_DEBUG_MODE				0xFF818581
+#define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER				0xFF818582
+#define OID_RT_UTILITY_GET_RSSI_STATUS					0xFF818583
+#define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS			0xFF818584
+#define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS	0xFF818585
+#define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS			0xFF818586
+//
+
+// by Owen on 03/09/19-03/09/22 for RTL8185
+#define OID_RT_WIRELESS_MODE				0xFF818500
+#define OID_RT_SUPPORTED_RATES				0xFF818501
+#define OID_RT_DESIRED_RATES				0xFF818502
+#define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
+//
+
+#define OID_RT_GET_CONNECT_STATE                	0xFF030001
+#define OID_RT_RESCAN	                        	0xFF030002
+#define OID_RT_SET_KEY_LENGTH				0xFF030003
+#define OID_RT_SET_DEFAULT_KEY_ID			0xFF030004
+
+#define OID_RT_SET_CHANNEL				0xFF010182
+#define OID_RT_SET_SNIFFER_MODE                 	0xFF010183
+#define OID_RT_GET_SIGNAL_QUALITY               	0xFF010184
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185		
+#define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
+#define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
+#define OID_RT_GET_TX_RETRY				0xFF010188
+#define OID_RT_GET_RX_RETRY				0xFF010189
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A//S
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B//S
+
+#define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
+#define OID_RT_GET_TX_BEACON_OK				0xFF010191
+#define OID_RT_GET_TX_BEACON_ERR			0xFF010192
+#define OID_RT_GET_RX_ICV_ERR				0xFF010193
+#define OID_RT_SET_ENCRYPTION_ALGORITHM			0xFF010194
+#define OID_RT_SET_NO_AUTO_RESCAN			0xFF010195
+#define OID_RT_GET_PREAMBLE_MODE			0xFF010196
+#define OID_RT_GET_DRIVER_UP_DELTA_TIME			0xFF010197
+#define OID_RT_GET_AP_IP				0xFF010198
+#define OID_RT_GET_CHANNELPLAN				0xFF010199
+#define OID_RT_SET_PREAMBLE_MODE			0xFF01019A
+#define OID_RT_SET_BCN_INTVL				0xFF01019B
+#define OID_RT_GET_RF_VENDER				0xFF01019C
+#define OID_RT_DEDICATE_PROBE				0xFF01019D
+#define OID_RT_PRO_RX_FILTER_PATTERN			0xFF01019E
+
+#define OID_RT_GET_DCST_CURRENT_THRESHOLD		0xFF01019F
+
+#define OID_RT_GET_CCA_ERR				0xFF0101A0
+#define OID_RT_GET_CCA_UPGRADE_THRESHOLD		0xFF0101A1
+#define OID_RT_GET_CCA_FALLBACK_THRESHOLD		0xFF0101A2
+
+#define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
+#define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
+
+// by Owen on 03/31/03 for Cameo's request
+#define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
+//
+#define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
+#define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
+#define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
+#define OID_RT_GET_TOTAL_RX_BYTES			0xFF0101A8
+#define OID_RT_CURRENT_TX_POWER_LEVEL			0xFF0101A9
+#define OID_RT_GET_ENC_KEY_MISMATCH_COUNT		0xFF0101AA
+#define OID_RT_GET_ENC_KEY_MATCH_COUNT			0xFF0101AB
+#define OID_RT_GET_CHANNEL				0xFF0101AC
+
+#define OID_RT_SET_CHANNELPLAN				0xFF0101AD
+#define OID_RT_GET_HARDWARE_RADIO_OFF			0xFF0101AE
+#define OID_RT_CHANNELPLAN_BY_COUNTRY			0xFF0101AF
+#define OID_RT_SCAN_AVAILABLE_BSSID			0xFF0101B0
+#define OID_RT_GET_HARDWARE_VERSION			0xFF0101B1
+#define OID_RT_GET_IS_ROAMING				0xFF0101B2
+#define OID_RT_GET_IS_PRIVACY				0xFF0101B3
+#define OID_RT_GET_KEY_MISMATCH				0xFF0101B4
+#define OID_RT_SET_RSSI_ROAM_TRAFFIC_TH			0xFF0101B5
+#define OID_RT_SET_RSSI_ROAM_SIGNAL_TH			0xFF0101B6
+#define OID_RT_RESET_LOG				0xFF0101B7
+#define OID_RT_GET_LOG					0xFF0101B8
+#define OID_RT_SET_INDICATE_HIDDEN_AP			0xFF0101B9
+#define OID_RT_GET_HEADER_FAIL				0xFF0101BA
+#define OID_RT_SUPPORTED_WIRELESS_MODE			0xFF0101BB
+#define OID_RT_GET_CHANNEL_LIST				0xFF0101BC
+#define OID_RT_GET_SCAN_IN_PROGRESS			0xFF0101BD
+#define OID_RT_GET_TX_INFO				0xFF0101BE
+#define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
+#define OID_RT_RF_READ_WRITE				0xFF0101C0
+
+// For Netgear request. 2005.01.13, by rcnjko.
+#define OID_RT_FORCED_DATA_RATE				0xFF0101C1
+#define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
+// For Netgear request. 2005.02.17, by rcnjko.
+#define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
+// For AZ project. 2005.06.27, by rcnjko.
+#define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
+
+// Vincent 8185MP
+#define OID_RT_PRO_RX_FILTER				0xFF0111C0
+
+//Andy TEST
+//#define OID_RT_PRO_WRITE_REGISTRY			0xFF0111C1
+//#define OID_RT_PRO_READ_REGISTRY			0xFF0111C2
+#define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
+#define OID_CE_USB_READ_REGISTRY			0xFF0111C2
+
+
+#define OID_RT_PRO_SET_INITIAL_GAIN			0xFF0111C3
+#define OID_RT_PRO_SET_BB_RF_STANDBY_MODE		0xFF0111C4
+#define OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE		0xFF0111C5
+#define OID_RT_PRO_SET_TX_CHARGE_PUMP			0xFF0111C6
+#define OID_RT_PRO_SET_RX_CHARGE_PUMP			0xFF0111C7
+#define OID_RT_PRO_RF_WRITE_REGISTRY			0xFF0111C8
+#define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
+#define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
+
+// AP OID
+#define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
+#define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
+#define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
+#define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
+#define OID_RT_AP_SUPPORTED				0xFF010304	// Determine if driver supports AP mode. 2004.08.27, by rcnjko.
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305	// Set WPA-PSK passphrase into authenticator. 2005.07.08, byrcnjko.
+
+// 8187MP. 2004.09.06, by rcnjko.
+#define OID_RT_PRO8187_WI_POLL				0xFF818780
+#define OID_RT_PRO_WRITE_BB_REG				0xFF818781
+#define OID_RT_PRO_READ_BB_REG				0xFF818782
+#define OID_RT_PRO_WRITE_RF_REG				0xFF818783
+#define OID_RT_PRO_READ_RF_REG				0xFF818784
+
+// Meeting House. added by Annie, 2005-07-20.
+#define OID_RT_MH_VENDER_ID				0xFFEDC100
+
+//8711 MP OID added 20051230.
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100//S
+
+#define OID_RT_PRO_READ_REGISTER			0xFF871101 //Q
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102 //S
+
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 //Q		
+#define OID_RT_PRO_BURST_WRITE_REGISTER 		0xFF871104 //S
+
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105 //S
+
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106 //Q
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107 //S
+
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108 //S
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109 //Q
+
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A //Q
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B //Q
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C//Q
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D//S
+
+
+//Method 2 for H2C/C2H
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110 //S
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111 //Q
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112 //S
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113 //Q
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114//Q
+
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115 //Q, S
+
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116 //S
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117 //Q,S
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118 //Q
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119 //Q
+
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A //S
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B //Q
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C //S
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D //Q
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E //S
+#define OID_RT_POLL_RX_STATUS				0xFF87111F //Q
+
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120 //Q,S
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121//S
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122//S
+#define OID_RT_PRO_READ_TSSI				0xFF871123//S
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124//S
+
+ 
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 //Q
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 //S 
+
+//Method 2 , using workitem
+#define OID_RT_SET_READ_REG				0xFF871181 //S
+#define OID_RT_SET_WRITE_REG				0xFF871182 //S
+#define OID_RT_SET_BURST_READ_REG			0xFF871183 //S
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184 //S
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185 //S
+#define OID_RT_SET_READ16_EEPROM			0xFF871186 //S
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187 //S
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188 //Q
+
+//For SDIO INTERFACE only
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0 //Q, S
+#define OID_RT_PRO_871X_DRV_EXT 			0xFF8711A1
+
+//For USB INTERFACE only
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0 //Q, S
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1 //S
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2 //S
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3 //Q
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4 //Q
+
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB //S
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC //S
+#define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
+
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200 //Q, S
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201 //S
+#define OID_RT_PRO_DELE_STA_INFO    			0xFF871202 //S
+#define OID_RT_PRO_QUERY_DR_VARIABLE   			0xFF871203 //Q
+
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204 //Q, S
+
+#define OID_RT_PRO_READ_EFUSE				0xFF871205 //Q
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206 //S
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207 //Q, S
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208 //Q
+
+#define OID_RT_SET_BANDWIDTH				0xFF871209 //S
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A //S
+
+#define OID_RT_SET_RX_PACKET_TYPE    			0xFF87120B //S
+
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C //Q
+
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D //S
+
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E //S
+
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F //S
+
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210 //Q
+
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211 //S
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212 //Q
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213 //Q
+
+#define OID_RT_SET_POWER_DOWN				0xFF871214 //S
+
+#define OID_RT_GET_POWER_MODE				0xFF871215 //Q
+
+#define OID_RT_PRO_EFUSE				0xFF871216 //Q, S
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217 //Q, S
+
+#endif //#ifndef	__CUSTOM_OID_H
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/nic_spec.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/nic_spec.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/nic_spec.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/nic_spec.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/	
+
+
+#ifndef __NIC_SPEC_H__
+#define __NIC_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8711_MCTRL_		(0x20000)
+#define RTL8711_UART_		(0x30000)
+#define RTL8711_TIMER_		(0x40000)
+#define RTL8711_FINT_		(0x50000)
+#define RTL8711_HINT_		(0x50000)
+#define RTL8711_GPIO_		(0x60000)
+#define RTL8711_WLANCTRL_	(0x200000)
+#define RTL8711_WLANFF_		(0xe00000)
+#define RTL8711_HCICTRL_	(0x600000)
+#define RTL8711_SYSCFG_		(0x620000)
+#define RTL8711_SYSCTRL_	(0x620000)
+#define RTL8711_MCCTRL_		(0x020000)
+
+
+#include <rtl8711_regdef.h>
+
+#include <rtl8711_bitdef.h>
+
+
+#endif // __RTL8711_SPEC_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/osdep_ce_service.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/osdep_ce_service.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/osdep_ce_service.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/osdep_ce_service.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,133 @@
+
+
+#ifndef __OSDEP_CE_SERVICE_H_
+#define __OSDEP_CE_SERVICE_H_
+
+
+#include <ndis.h>
+#include <ntddndis.h>
+
+#ifdef CONFIG_SDIO_HCI
+#include "SDCardDDK.h"
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usbdi.h>
+#endif
+
+typedef HANDLE 	_sema;
+typedef	LIST_ENTRY	_list;
+typedef NDIS_STATUS _OS_STATUS;
+
+typedef NDIS_SPIN_LOCK	_lock;
+
+typedef HANDLE 		_mutex; //Mutex
+
+typedef u32	_irqL;
+
+typedef NDIS_HANDLE  _nic_hdl;
+
+
+typedef NDIS_MINIPORT_TIMER    _timer;
+
+struct	__queue	{
+	LIST_ENTRY	queue;
+	_lock	lock;
+};
+
+typedef	NDIS_PACKET	_pkt;
+typedef NDIS_BUFFER	_buffer;
+typedef struct	__queue	_queue;
+
+typedef HANDLE 	_thread_hdl_;
+typedef DWORD thread_return;
+typedef void*	thread_context;
+typedef NDIS_WORK_ITEM _workitem;
+
+#define thread_exit() ExitThread(STATUS_SUCCESS); return 0;
+
+
+#define SEMA_UPBND	(0x7FFFFFFF)   //8192
+
+__inline static _list *get_prev(_list	*list)
+{
+	return list->Blink;
+}
+	
+__inline static _list *get_next(_list	*list)
+{
+	return list->Flink;
+}
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
+
+__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisAcquireSpinLock(plock);
+}
+
+__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisReleaseSpinLock(plock);
+}
+
+__inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);	
+}
+
+__inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);	
+}
+
+
+__inline static void _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	WaitForSingleObject(*pmutex, INFINITE );
+
+}
+
+__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	ReleaseMutex(*pmutex);
+}
+
+__inline static void list_delete(_list *plist)
+{
+	RemoveEntryList(plist);
+	InitializeListHead(plist);
+}
+
+__inline static void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,PVOID cntx)
+{
+	NdisMInitializeTimer(ptimer, padapter, pfunc, cntx);
+}
+
+__inline static void _set_timer(_timer *ptimer,u32 delay_time)
+{
+ 	NdisMSetTimer(ptimer,delay_time);
+}
+
+__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	NdisMCancelTimer(ptimer,bcancelled);
+}
+
+__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+
+	NdisInitializeWorkItem(pwork, pfunc, cntx);
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+	NdisScheduleWorkItem(pwork);
+}
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/osdep_intf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/osdep_intf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/osdep_intf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/osdep_intf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifdef PLATFORM_LINUX
+
+#ifdef CONFIG_USB_HCI
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#endif
+
+#endif
+
+#ifdef PLATFORM_OS_XP
+
+#ifdef CONFIG_SDIO_HCI
+#include <ntddsd.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb.h>
+#include <usbioctl.h>
+#include <usbdlib.h>
+#endif
+
+#endif
+
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0: 1)) << 2)
+
+
+struct intf_priv {
+	
+	u8 *intf_dev;
+	u32	max_iosz; 	//USB2.0: 128, USB1.1: 64, SDIO:64
+	u32	max_xmitsz; //USB2.0: unlimited, SDIO:512
+	u32	max_recvsz; //USB2.0: unlimited, SDIO:512
+
+	volatile u8 *io_rwmem;
+	volatile u8 *allocated_io_rwmem;
+	u32	io_wsz; //unit: 4bytes
+	u32	io_rsz;//unit: 4bytes
+	u8 intf_status;	
+	
+	void (*_bus_io)(u8 *priv);	
+
+/*
+Under Sync. IRP (SDIO/USB)
+A protection mechanism is necessary for the io_rwmem(read/write protocol)
+
+Under Async. IRP (SDIO/USB)
+The protection mechanism is through the pending queue.
+*/
+
+	_mutex ioctl_mutex;
+
+	
+#ifdef PLATFORM_LINUX	
+	#ifdef CONFIG_USB_HCI	
+	// when in USB, IO is through interrupt in/out endpoints
+	struct usb_device 	*udev;
+	PURB	piorw_urb;
+	u8 io_irp_cnt;
+	u8 bio_irp_pending;
+	_sema io_retevt;
+	_timer	io_timer;
+	u8 bio_irp_timeout;
+	u8 bio_timer_cancel;
+	#endif
+#endif
+
+#ifdef PLATFORM_OS_XP
+	#ifdef CONFIG_SDIO_HCI
+		// below is for io_rwmem...	
+		PMDL pmdl;
+		PSDBUS_REQUEST_PACKET  sdrp;
+		PSDBUS_REQUEST_PACKET  recv_sdrp;
+		PSDBUS_REQUEST_PACKET  xmit_sdrp;
+
+			PIRP		piorw_irp;
+
+	#endif
+	#ifdef CONFIG_USB_HCI
+		PURB	piorw_urb;
+		PIRP		piorw_irp;
+		u8 io_irp_cnt;
+		u8 bio_irp_pending;
+		_sema io_retevt;	
+	#endif	
+#endif
+
+};	
+
+
+struct intf_hdl;
+
+extern uint _init_intf_hdl(_adapter *padapter, struct intf_hdl *pintf_hdl);
+extern void _unload_intf_hdl(struct intf_priv *pintfpriv);
+
+u32 rtw_open_fw(_adapter * padapter, void **pphfwfile_hdl, u8 **ppmappedfw);
+void rtw_close_fw(_adapter *padapter, void *phfwfile_hdl);
+
+
+#ifdef PLATFORM_LINUX
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+int rtw_init_netdev_name(struct net_device *pnetdev);
+struct net_device *rtw_init_netdev(void);
+
+#ifdef CONFIG_PROC_DEBUG
+void rtw_proc_init_one(struct net_device *dev);
+void rtw_proc_remove_one(struct net_device *dev);
+#endif
+#endif
+
+
+#endif	//_OSDEP_INTF_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/osdep_service.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/osdep_service.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/osdep_service.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/osdep_service.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,528 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+#include <drv_conf.h>
+#include <basic_types.h>
+//#include <rtl871x_byteorder.h>
+
+#define _SUCCESS	1
+#define _FAIL		0
+
+#undef _TRUE
+#define _TRUE		1
+
+#undef _FALSE
+#define _FALSE		0
+
+
+#ifdef PLATFORM_LINUX
+	#include <linux/version.h>
+	#include <linux/spinlock.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+	#include <asm/semaphore.h>
+#else
+	#include <linux/semaphore.h>
+#endif
+	#include <linux/sem.h>
+	#include <linux/sched.h>
+	#include <linux/netdevice.h>
+	#include <linux/etherdevice.h>
+	#include <net/iw_handler.h>
+	#include <linux/proc_fs.h>	// Necessary because we use the proc fs
+	
+
+
+
+#ifdef CONFIG_USB_HCI
+	typedef struct urb *  PURB;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
+#ifdef CONFIG_USB_SUSPEND
+#define CONFIG_AUTOSUSPEND	1
+#endif
+#endif
+#endif
+
+	typedef struct 	semaphore _sema;
+	typedef	spinlock_t	_lock;
+	
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	typedef struct mutex 		_mutex;
+#else
+	typedef struct semaphore	_mutex;
+#endif
+
+	typedef struct timer_list _timer;
+
+	struct	__queue	{
+		struct	list_head	queue;	
+		_lock	lock;
+	};
+
+	typedef	struct sk_buff	_pkt;
+	typedef unsigned char	_buffer;
+	
+	typedef struct	__queue	_queue;
+	typedef struct	list_head	_list;
+	typedef	int	_OS_STATUS;
+	//typedef u32	_irqL;
+	typedef unsigned long _irqL;
+	typedef	struct	net_device * _nic_hdl;
+	
+	typedef pid_t		_thread_hdl_;
+	typedef int		thread_return;
+	typedef void*	thread_context;
+
+	#define thread_exit() complete_and_exit(NULL, 0)
+
+	typedef void timer_hdl_return;
+	typedef void* timer_hdl_context;
+	typedef struct work_struct _workitem;
+	
+
+__inline static _list *get_next(_list	*list)
+{
+	return list->next;
+}	
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+
+	
+#define LIST_CONTAINOR(ptr, type, member) \
+        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))	
+
+        
+__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	spin_lock_bh(plock);
+}
+
+__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	spin_unlock_bh(plock);
+}
+
+__inline static void _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		mutex_lock(pmutex);
+#else
+		down(pmutex);
+#endif
+}
+
+
+__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		mutex_unlock(pmutex);
+#else
+		up(pmutex);
+#endif
+}
+
+__inline static void list_delete(_list *plist)
+{
+	
+
+
+	list_del_init(plist);
+	
+
+	
+}
+
+__inline static void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,void* cntx)
+{
+	//setup_timer(ptimer, pfunc,(u32)cntx);	
+	ptimer->function = pfunc;
+	ptimer->data = (unsigned long)cntx;
+	init_timer(ptimer);
+}
+
+__inline static void _set_timer(_timer *ptimer,u32 delay_time)
+{	
+	if(!ptimer)
+		panic("ptimer is NULL pointer...\n");
+	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));	
+}
+
+__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	del_timer_sync(ptimer); 	
+	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
+}
+
+__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+	INIT_WORK(pwork, pfunc);
+#else
+	INIT_WORK(pwork, pfunc,pwork);
+#endif
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+	schedule_work(pwork);
+}
+
+#endif	
+
+
+#ifdef PLATFORM_OS_XP
+
+	#include <ndis.h>
+	#include <ntddk.h>
+	#include <ntddsd.h>
+	#include <ntddndis.h>
+	#include <ntdef.h>
+	
+
+	typedef KSEMAPHORE 	_sema;
+	typedef	LIST_ENTRY	_list;
+	typedef NDIS_STATUS _OS_STATUS;
+	
+
+	typedef NDIS_SPIN_LOCK	_lock;
+
+	typedef KMUTEX 			_mutex;
+
+	typedef KIRQL	_irqL;
+
+	// USB_PIPE for WINCE , but handle can be use just integer under windows
+	typedef NDIS_HANDLE  _nic_hdl;
+
+
+	typedef NDIS_MINIPORT_TIMER    _timer;
+
+	struct	__queue	{
+		LIST_ENTRY	queue;	
+		_lock	lock;
+	};
+
+	typedef	NDIS_PACKET	_pkt;
+	typedef NDIS_BUFFER	_buffer;
+	typedef struct	__queue	_queue;
+	
+	typedef PKTHREAD _thread_hdl_;
+	typedef void	thread_return;
+	typedef void* thread_context;
+
+	typedef NDIS_WORK_ITEM _workitem;
+
+	#define thread_exit() PsTerminateSystemThread(STATUS_SUCCESS);
+
+	#define HZ			10000000
+	#define SEMA_UPBND	(0x7FFFFFFF)   //8192
+	
+__inline static _list *get_next(_list	*list)
+{
+	return list->Flink;
+}	
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return (&(queue->queue));
+}
+	
+
+#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
+     
+
+__inline static _enter_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisAcquireSpinLock(plock);	
+}
+
+__inline static _exit_critical(_lock *plock, _irqL *pirqL)
+{
+	NdisReleaseSpinLock(plock);	
+}
+
+
+__inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);	
+}
+
+__inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);	
+}
+
+__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	NdisDprAcquireSpinLock(plock);
+}
+
+__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	NdisDprReleaseSpinLock(plock);
+}
+
+__inline static _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	KeWaitForSingleObject(pmutex, Executive, KernelMode, FALSE, NULL);
+}
+
+
+__inline static _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	KeReleaseMutex(pmutex, FALSE);
+}
+
+
+__inline static void list_delete(_list *plist)
+{
+	RemoveEntryList(plist);
+	InitializeListHead(plist);	
+}
+
+__inline static void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,PVOID cntx)
+{
+	NdisMInitializeTimer(ptimer, padapter, pfunc, cntx);
+}
+
+__inline static void _set_timer(_timer *ptimer,u32 delay_time)
+{	
+ 	NdisMSetTimer(ptimer,delay_time);	
+}
+
+__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
+{
+	NdisMCancelTimer(ptimer,bcancelled);
+}
+
+__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
+{
+
+	NdisInitializeWorkItem(pwork, pfunc, cntx);
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+	NdisScheduleWorkItem(pwork);
+}
+
+#endif
+
+
+#ifdef PLATFORM_OS_CE
+#include <osdep_ce_service.h>
+#endif
+
+#include <rtw_byteorder.h>
+
+#ifndef BIT
+	#define BIT(x)	( 1 << (x))
+#endif
+extern u8*	_rtw_zmalloc(u32 sz);
+extern u8*	_rtw_malloc(u32 sz);
+extern void	_rtw_mfree(u8 *pbuf, u32 sz);
+extern void	_rtw_memcpy(void* dec, void* sour, u32 sz);
+extern int	_rtw_memcmp(void *dst, void *src, u32 sz);
+extern void	_rtw_memset(void *pbuf, int c, u32 sz);
+
+extern void	_rtw_init_listhead(_list *list);
+extern u32	rtw_is_list_empty(_list *phead);
+extern void	rtw_list_insert_tail(_list *plist, _list *phead);
+extern void	list_delete(_list *plist);
+extern void	_rtw_init_sema(_sema *sema, int init_val);
+extern void	_rtw_free_sema(_sema	*sema);
+extern void	_rtw_up_sema(_sema	*sema);
+extern u32	_rtw_down_sema(_sema *sema);
+extern void	_rtw_mutex_init(_mutex *pmutex);
+extern void	_rtw_spinlock_init(_lock *plock);
+extern void	_rtw_spinlock_free(_lock *plock);
+extern void	_rtw_spinlock(_lock	*plock);
+extern void	_rtw_spinunlock(_lock	*plock);
+extern void	_rtw_spinlock_ex(_lock	*plock);
+extern void	_rtw_spinunlock_ex(_lock	*plock);
+extern void	_rtw_init_queue(_queue	*pqueue);
+extern u32	_rtw_queue_empty(_queue	*pqueue);
+extern u32	rtw_end_of_queue_search(_list *queue, _list *pelement);
+extern u32	rtw_get_current_time(void);
+
+extern void	rtw_sleep_schedulable(int ms);
+
+extern void	rtw_msleep_os(int ms);
+extern void	rtw_usleep_os(int us);
+extern void	rtw_mdelay_os(int ms);
+extern void	rtw_udelay_os(int us);
+
+
+
+__inline static unsigned char _cancel_timer_ex(_timer *ptimer)
+{
+#ifdef PLATFORM_LINUX
+	return del_timer_sync(ptimer);
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	u8 bcancelled;
+	
+	_cancel_timer(ptimer, &bcancelled);
+	
+	return bcancelled;
+#endif
+}
+
+__inline static void thread_enter(void *context)
+{
+#ifdef PLATFORM_LINUX
+	//struct net_device *pnetdev = (struct net_device *)context;
+	//daemonize("%s", pnetdev->name);
+	daemonize("%s", "RTKTHREAD");
+	allow_signal(SIGTERM);
+#endif
+}
+
+__inline static void flush_signals_thread(void) 
+{
+#ifdef PLATFORM_LINUX
+	if (signal_pending (current)) 
+	{
+		flush_signals(current);
+	}
+#endif
+}
+
+__inline static _OS_STATUS res_to_status(sint res)
+{
+
+
+#if defined (PLATFORM_LINUX) || defined (PLATFORM_MPIXEL)
+	return res;
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+	if (res == _SUCCESS)
+		return NDIS_STATUS_SUCCESS;
+	else
+		return NDIS_STATUS_FAILURE;
+
+#endif	
+	
+}
+
+__inline static u32 _RND4(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 2) + ((sz & 3) ? 1: 0)) << 2;
+	
+	return val;
+
+}
+
+__inline static u32 _RND8(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 3) + ((sz & 7) ? 1: 0)) << 3;
+	
+	return val;
+
+}
+
+__inline static u32 _RND128(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
+	
+	return val;
+
+}
+
+__inline static u32 _RND256(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
+	
+	return val;
+
+}
+
+__inline static u32 _RND512(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
+	
+	return val;
+
+}
+
+__inline static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1) break;
+
+	return i;
+}
+
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+
+//#ifdef __GNUC__
+#ifdef PLATFORM_LINUX
+#define STRUCT_PACKED __attribute__ ((packed))
+#else
+#define STRUCT_PACKED
+#endif
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/recv_osdep.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/recv_osdep.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/recv_osdep.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/recv_osdep.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,59 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+extern sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
+extern void _rtw_free_recv_priv (struct recv_priv *precvpriv);
+extern  sint update_rxstatus(_adapter *adapter, union recv_frame *precv_frame, struct recv_stat *rxstatus );
+
+
+extern s32  rtw_recv_entry(union recv_frame *precv_frame);	
+extern void rtw_recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
+extern void recv_returnpacket(IN _nic_hdl cnxt, IN _pkt *preturnedpkt);
+
+extern void hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame);
+extern void rtw_handle_tkip_mic_err(_adapter *padapter,u8 bgroup);
+		
+
+int	rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
+void rtw_free_recv_priv (struct recv_priv *precvpriv);
+
+
+int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter);
+int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe);
+void rtw_os_recv_resource_free(struct recv_priv *precvpriv);
+
+
+int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf);
+int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf);
+
+void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf);
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+
+#endif //
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_cmd.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_cmd.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_cmd.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_cmd.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,422 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192C_CMD_H_
+#define __RTL8192C_CMD_H_
+
+
+enum cmd_msg_element_id
+{	
+	NONE_CMDMSG_EID,
+	AP_OFFLOAD_EID=0,
+	SET_PWRMODE_EID=1,
+	JOINBSS_RPT_EID=2,
+	RSVD_PAGE_EID=3,
+	RSSI_4_EID = 4,
+	RSSI_SETTING_EID=5,
+	MACID_CONFIG_EID=6,
+	MACID_PS_MODE_EID=7,
+	P2P_PS_OFFLOAD_EID=8,
+	SELECTIVE_SUSPEND_ROF_CMD=9,
+	MAX_CMDMSG_EID	 
+};
+
+struct cmd_msg_parm {
+	u8 eid; //element id
+	u8 sz; // sz
+	u8 buf[6];
+};
+
+#ifdef CONFIG_LPS
+enum LPS_CTRL_TYPE
+{
+	LPS_CTRL_SCAN=0,
+	LPS_CTRL_JOINBSS=1,
+	LPS_CTRL_CONNECT=2,
+	LPS_CTRL_DISCONNECT=3,
+	LPS_CTRL_SPECIAL_PACKET=4,
+};
+
+typedef struct _SETPWRMODE_PARM{
+	u8 	Mode;
+	u8 	SmartPS;
+	unsigned char  AwakeInterval; //Unit: beacon interval, this field is only valid in PS_DTIM mode
+}SETPWRMODE_PARM, *PSETPWRMODE_PARM;
+
+typedef struct JOINBSSRPT_PARM{
+	u8	OpMode;	// RT_MEDIA_STATUS
+}JOINBSSRPT_PARM, *PJOINBSSRPT_PARM;
+
+typedef struct _RSVDPAGE_LOC{
+	u8 	LocProbeRsp;
+	u8 	LocPsPoll;
+	u8	LocNullData;
+}RSVDPAGE_LOC, *PRSVDPAGE_LOC;
+
+void lps_ctrl_wk_hdl(_adapter *padapter, u8 *pbuf, int sz);
+u8 lps_ctrl_wk_cmd(_adapter*padapter, u8 lps_ctrl_type, u8 enqueue);
+void set_FwPwrMode_cmd(_adapter*padapter, u8 Mode);
+void set_FwJoinBssReport_cmd(_adapter* padapter, u8 mstatus);
+#endif
+
+#ifdef CONFIG_AUTOSUSPEND
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+struct H2C_SS_RFOFF_PARAM{
+	u8 	ROFOn; // 1: on, 0:off
+	u16	gpio_period; // unit: 1024 us
+}__attribute__ ((packed));
+u8 set_FWSelectSuspend_cmd(_adapter*padapter,u8 bfwpoll, u16 period);
+#endif
+#endif
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+void antenna_select_wk_hdl(_adapter *padapter, u8 *pbuf, int antenna);
+u8 antenna_select_cmd(_adapter*padapter, u8 antenna, u8 enqueue);
+#endif
+
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+u8 usb_io_chk_cmd(_adapter*padapter);
+#endif
+// host message to firmware cmd
+u8 set_rssi_cmd(_adapter*padapter, u8 *param);
+u8 set_raid_cmd(_adapter*padapter, u32 mask, u8 arg);
+
+
+/* these calls are synchronous, and may not be used in an interrupt context.*/
+u32 read_macreg(_adapter *padapter, u32 addr, u32 sz);
+void write_macreg(_adapter *padapter, u32 addr, u32 val, u32 sz);
+u32 read_bbreg(_adapter *padapter, u32 addr, u32 bitmask);
+void write_bbreg(_adapter *padapter, u32 addr, u32 bitmask, u32 val);
+u32 read_rfreg(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask);
+void write_rfreg(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
+
+/* these calls are asynchronous, and can be used in an interrupt context.*/
+//u32 read_macreg_cmd(_adapter *padapter, u32 addr, u32 sz);
+void write_macreg_cmd(_adapter *padapter, u32 addr, u32 val, u32 sz);
+//u32 read_bbreg_cmd(_adapter *padapter, u32 addr, u32 bitmask);
+void write_bbreg_cmd(_adapter *padapter, u32 addr, u32 bitmask, u32 val);
+//u32 read_rfreg_cmd(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask);
+void write_rfreg_cmd(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
+
+enum rtl8192c_h2c_cmd
+{
+	GEN_CMD_CODE(_Read_MACREG) ,	/*0*/
+ 	GEN_CMD_CODE(_Write_MACREG) ,    
+ 	GEN_CMD_CODE(_Read_BBREG) ,  
+ 	GEN_CMD_CODE(_Write_BBREG) ,  
+ 	GEN_CMD_CODE(_Read_RFREG) ,  
+ 	GEN_CMD_CODE(_Write_RFREG) , /*5*/
+ 	GEN_CMD_CODE(_Read_EEPROM) ,  
+ 	GEN_CMD_CODE(_Write_EEPROM) ,  
+ 	GEN_CMD_CODE(_Read_EFUSE) ,  
+ 	GEN_CMD_CODE(_Write_EFUSE) , 
+ 	
+ 	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
+ 	GEN_CMD_CODE(_Write_CAM) ,   
+ 	GEN_CMD_CODE(_setBCNITV),
+ 	GEN_CMD_CODE(_setMBIDCFG),
+ 	GEN_CMD_CODE(_JoinBss),   /*14*/
+ 	GEN_CMD_CODE(_DisConnect) , /*15*/
+ 	GEN_CMD_CODE(_CreateBss) ,
+	GEN_CMD_CODE(_SetOpMode) , 
+	GEN_CMD_CODE(_SiteSurvey),  /*18*/
+ 	GEN_CMD_CODE(_SetAuth) ,
+ 	
+ 	GEN_CMD_CODE(_SetKey) ,	/*20*/
+ 	GEN_CMD_CODE(_SetStaKey) ,
+ 	GEN_CMD_CODE(_SetAssocSta) ,
+ 	GEN_CMD_CODE(_DelAssocSta) ,
+ 	GEN_CMD_CODE(_SetStaPwrState) , 
+ 	GEN_CMD_CODE(_SetBasicRate) , /*25*/
+ 	GEN_CMD_CODE(_GetBasicRate) ,
+ 	GEN_CMD_CODE(_SetDataRate) ,
+ 	GEN_CMD_CODE(_GetDataRate) ,
+	GEN_CMD_CODE(_SetPhyInfo) ,
+	
+ 	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
+	GEN_CMD_CODE(_SetPhy) ,
+ 	GEN_CMD_CODE(_GetPhy) ,
+ 	GEN_CMD_CODE(_readRssi) ,
+ 	GEN_CMD_CODE(_readGain) ,
+ 	GEN_CMD_CODE(_SetAtim) , /*35*/
+ 	GEN_CMD_CODE(_SetPwrMode) , 
+ 	GEN_CMD_CODE(_JoinbssRpt),
+ 	GEN_CMD_CODE(_SetRaTable) ,
+ 	GEN_CMD_CODE(_GetRaTable) ,  	
+ 	
+ 	GEN_CMD_CODE(_GetCCXReport), /*40*/
+ 	GEN_CMD_CODE(_GetDTMReport),
+ 	GEN_CMD_CODE(_GetTXRateStatistics),
+ 	GEN_CMD_CODE(_SetUsbSuspend),
+ 	GEN_CMD_CODE(_SetH2cLbk),
+ 	GEN_CMD_CODE(_AddBAReq) , /*45*/
+	GEN_CMD_CODE(_SetChannel), /*46*/
+	GEN_CMD_CODE(_SetTxPower), 
+	GEN_CMD_CODE(_SwitchAntenna),
+	GEN_CMD_CODE(_SetCrystalCap),
+	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
+	
+	GEN_CMD_CODE(_SetSingleToneTx),/*51*/
+	GEN_CMD_CODE(_SetCarrierSuppressionTx),
+	GEN_CMD_CODE(_SetContinuousTx),
+	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
+	GEN_CMD_CODE(_TX_Beacon), /*55*/
+	
+	GEN_CMD_CODE(_Set_MLME_EVT), /*56*/
+	GEN_CMD_CODE(_Set_Drv_Extra), /*57*/
+	GEN_CMD_CODE(_Set_H2C_MSG), /*58*/
+
+#if 1
+	//To do, modify these h2c cmd, add or delete
+	GEN_CMD_CODE(_GetH2cLbk) ,
+
+	// WPS extra IE
+	GEN_CMD_CODE(_SetProbeReqExtraIE) ,
+	GEN_CMD_CODE(_SetAssocReqExtraIE) ,
+	GEN_CMD_CODE(_SetProbeRspExtraIE) ,
+	GEN_CMD_CODE(_SetAssocRspExtraIE) ,
+	
+	// the following is driver will do
+	GEN_CMD_CODE(_GetCurDataRate) , 
+
+	GEN_CMD_CODE(_GetTxRetrycnt),  // to record times that Tx retry to transmmit packet after association
+	GEN_CMD_CODE(_GetRxRetrycnt), // to record total number of the received frame with ReTry bit set in the WLAN header
+
+	GEN_CMD_CODE(_GetBCNOKcnt),
+	GEN_CMD_CODE(_GetBCNERRcnt),
+	GEN_CMD_CODE(_GetCurTxPwrLevel),
+
+	GEN_CMD_CODE(_SetDIG),
+	GEN_CMD_CODE(_SetRA),
+	GEN_CMD_CODE(_SetPT),
+	GEN_CMD_CODE(_ReadTSSI),
+	GEN_CMD_CODE(_SetRFIntFs),
+ #endif	
+	
+	MAX_H2CCMD
+};
+
+
+#define _GetBBReg_CMD_		_Read_BBREG_CMD_
+#define _SetBBReg_CMD_ 		_Write_BBREG_CMD_
+#define _GetRFReg_CMD_ 		_Read_RFREG_CMD_
+#define _SetRFReg_CMD_ 		_Write_RFREG_CMD_
+
+#ifdef _RTL8192C_CMD_C_
+struct _cmd_callback 	rtw_cmd_callback[] = 
+{
+	{GEN_CMD_CODE(_Read_MACREG), NULL}, /*0*/
+	{GEN_CMD_CODE(_Write_MACREG), NULL}, 
+	{GEN_CMD_CODE(_Read_BBREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_BBREG), NULL},
+	{GEN_CMD_CODE(_Read_RFREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_Read_EEPROM), NULL},
+	{GEN_CMD_CODE(_Write_EEPROM), NULL},
+	{GEN_CMD_CODE(_Read_EFUSE), NULL},
+	{GEN_CMD_CODE(_Write_EFUSE), NULL},
+	
+	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},	
+	{GEN_CMD_CODE(_setBCNITV), NULL},
+ 	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CreateBss), &rtw_createbss_cmd_callback},
+	{GEN_CMD_CODE(_SetOpMode), NULL},
+	{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SetAuth), NULL},
+	
+	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
+	{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetAssocSta), &rtw_setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},	
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},	
+	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
+	{GEN_CMD_CODE(_GetBasicRate), NULL},
+	{GEN_CMD_CODE(_SetDataRate), NULL},
+	{GEN_CMD_CODE(_GetDataRate), NULL},
+	{GEN_CMD_CODE(_SetPhyInfo), NULL},
+	
+	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
+	{GEN_CMD_CODE(_SetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},	
+	{GEN_CMD_CODE(_readRssi), NULL},
+	{GEN_CMD_CODE(_readGain), NULL},
+	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
+	{GEN_CMD_CODE(_SetPwrMode), NULL},
+	{GEN_CMD_CODE(_JoinbssRpt), NULL},
+	{GEN_CMD_CODE(_SetRaTable), NULL},
+	{GEN_CMD_CODE(_GetRaTable) , NULL},
+ 	
+	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
+ 	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+ 	{GEN_CMD_CODE(_GetTXRateStatistics), NULL}, 
+ 	{GEN_CMD_CODE(_SetUsbSuspend), NULL}, 
+ 	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+ 	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
+	{GEN_CMD_CODE(_SetTxPower), NULL},
+	{GEN_CMD_CODE(_SwitchAntenna), NULL},
+	{GEN_CMD_CODE(_SetCrystalCap), NULL},
+	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
+	
+	{GEN_CMD_CODE(_SetSingleToneTx), NULL}, /*51*/
+	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
+	{GEN_CMD_CODE(_SetContinuousTx), NULL},
+	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
+	{GEN_CMD_CODE(_TX_Beacon), NULL},/*55*/
+
+	{GEN_CMD_CODE(_Set_MLME_EVT), NULL},/*56*/
+	{GEN_CMD_CODE(_Set_Drv_Extra), NULL},/*57*/
+	{GEN_CMD_CODE(_Set_H2C_MSG), NULL},/*58*/
+	
+
+#if 1//To do, modify these h2c cmd, add or delete
+	{GEN_CMD_CODE(_GetH2cLbk), NULL},
+	{_SetProbeReqExtraIE_CMD_, NULL},
+	{_SetAssocReqExtraIE_CMD_, NULL},
+	{_SetProbeRspExtraIE_CMD_, NULL},
+	{_SetAssocRspExtraIE_CMD_, NULL},	
+	{_GetCurDataRate_CMD_, NULL},
+	{_GetTxRetrycnt_CMD_, NULL},
+	{_GetRxRetrycnt_CMD_, NULL},	
+	{_GetBCNOKcnt_CMD_, NULL},	
+	{_GetBCNERRcnt_CMD_, NULL},	
+	{_GetCurTxPwrLevel_CMD_, NULL},	
+	{_SetDIG_CMD_, NULL},	
+	{_SetRA_CMD_, NULL},		
+	{_SetPT_CMD_,NULL},
+	{GEN_CMD_CODE(_ReadTSSI), &rtw_readtssi_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetRFIntFs), NULL},
+#endif
+
+};
+#endif
+
+
+struct cmd_hdl {
+	uint	parmsize;
+	u8 (*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);	
+};
+
+
+u8 read_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+
+
+u8 rtl8192c_NULL_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_join_cmd_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_disconnect_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_createbss_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_setopmode_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf);	
+u8 rtl8192c_setauth_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_setkey_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_set_stakey_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_set_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_del_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtl8192c_add_ba_hdl(_adapter *padapter, unsigned char *pbuf);
+
+u8 rtl8192c_mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 rtl8192c_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 rtl8192c_h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf);
+
+#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &rtl8192c_ ## cmd ## _hdl},
+//#define GEN_DRV_CMD_HANDLER(size, cmd)		{size, &cmd ## _hdl},
+//#define GEN_MLME_EXT_HANDLER(size, cmd)	{size, &rtl8192c_ ## cmd ## _hdl},
+#define GEN_MLME_EXT_HANDLER(size, cmd)	{size, cmd},
+
+#ifdef _RTL8192C_CMD_C_
+
+struct cmd_hdl wlancmds[] = 
+{
+	GEN_DRV_CMD_HANDLER(0, NULL) /*0*/
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*10*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)		
+	GEN_MLME_EXT_HANDLER(sizeof (struct joinbss_parm), rtl8192c_join_cmd_hdl) /*14*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct disconnect_parm), rtl8192c_disconnect_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct createbss_parm), rtl8192c_createbss_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setopmode_parm), rtl8192c_setopmode_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct sitesurvey_parm), rtl8192c_sitesurvey_cmd_hdl) /*18*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct setauth_parm), rtl8192c_setauth_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setkey_parm), rtl8192c_setkey_hdl) /*20*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct set_stakey_parm), rtl8192c_set_stakey_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct set_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct del_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setstapwrstate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setphyinfo_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getphyinfo_parm), NULL)  /*30*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct setphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)	/*40*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), rtl8192c_add_ba_hdl)	
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*50*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) 
+	GEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), NULL) /*55*/
+
+	GEN_MLME_EXT_HANDLER(0, rtl8192c_mlme_evt_hdl) /*56*/
+	GEN_MLME_EXT_HANDLER(0, rtl8192c_drvextra_cmd_hdl) /*57*/
+
+	GEN_MLME_EXT_HANDLER(0, rtl8192c_h2c_msg_hdl) /*58*/
+
+};
+
+#endif
+
+#endif
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_dm.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_dm.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_dm.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_dm.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,410 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__HAL8190PCIDM_H__
+#define __HAL8190PCIDM_H__
+//============================================================
+// Description:
+//
+// This file is for 92CE/92CU dynamic mechanism only
+//
+//
+//============================================================
+
+//============================================================
+// structure and define
+//============================================================
+typedef struct _FALSE_ALARM_STATISTICS{
+	u32	Cnt_Parity_Fail;
+	u32  Cnt_Rate_Illegal;
+	u32	Cnt_Crc8_fail;
+	u32	Cnt_Mcs_fail;
+	u32	Cnt_Ofdm_fail;
+	u32	Cnt_Cck_fail;
+	u32	Cnt_all;
+	u32	Cnt_Fast_Fsync;
+	u32	Cnt_SB_Search_fail;
+}FALSE_ALARM_STATISTICS, *PFALSE_ALARM_STATISTICS;
+
+typedef struct _Dynamic_Initial_Gain_Threshold_
+{
+	u8		Dig_Enable_Flag;
+	u8		Dig_Ext_Port_Stage;
+	
+	int		RssiLowThresh;
+	int		RssiHighThresh;
+
+	u32		FALowThresh;
+	u32		FAHighThresh;
+
+	u8		CurSTAConnectState;
+	u8		PreSTAConnectState;
+	u8		CurMultiSTAConnectState;
+
+	u8		PreIGValue;
+	u8		CurIGValue;
+
+	char		BackoffVal;
+	char		BackoffVal_range_max;
+	char		BackoffVal_range_min;
+	u8		rx_gain_range_max;
+	u8		rx_gain_range_min;
+	u8		Rssi_val_min;
+
+	u8		PreCCKPDState;
+	u8		CurCCKPDState;
+        u8		PreCCKFAState;
+	u8		CurCCKFAState;
+	u8		PreCCAState;
+	u8		CurCCAState;
+
+	u8		LargeFAHit;
+	u8		ForbiddenIGI;
+	u32		Recover_cnt;
+	
+}DIG_T;
+
+typedef enum tag_Dynamic_Init_Gain_Operation_Type_Definition
+{
+	DIG_TYPE_THRESH_HIGH	= 0,
+	DIG_TYPE_THRESH_LOW	= 1,
+	DIG_TYPE_BACKOFF		= 2,
+	DIG_TYPE_RX_GAIN_MIN	= 3,
+	DIG_TYPE_RX_GAIN_MAX	= 4,
+	DIG_TYPE_ENABLE 		= 5,
+	DIG_TYPE_DISABLE 		= 6,
+	DIG_OP_TYPE_MAX
+}DM_DIG_OP_E;
+
+typedef enum tag_CCK_Packet_Detection_Threshold_Type_Definition
+{
+	CCK_PD_STAGE_LowRssi = 0,
+	CCK_PD_STAGE_HighRssi = 1,
+	CCK_PD_STAGE_MAX = 3,
+}DM_CCK_PDTH_E;
+
+typedef enum tag_1R_CCA_Type_Definition
+{
+	CCA_1R =0,
+	CCA_2R = 1,
+	CCA_MAX = 2,
+}DM_1R_CCA_E;
+
+typedef enum tag_DIG_EXT_PORT_ALGO_Definition
+{
+	DIG_EXT_PORT_STAGE_0 = 0,
+	DIG_EXT_PORT_STAGE_1 = 1,
+	DIG_EXT_PORT_STAGE_2 = 2,
+	DIG_EXT_PORT_STAGE_3 = 3,
+	DIG_EXT_PORT_STAGE_MAX = 4,
+}DM_DIG_EXT_PORT_ALG_E;
+
+
+typedef enum tag_DIG_Connect_Definition
+{
+	DIG_STA_DISCONNECT = 0,	
+	DIG_STA_CONNECT = 1,
+	DIG_STA_BEFORE_CONNECT = 2,
+	DIG_MultiSTA_DISCONNECT = 3,
+	DIG_MultiSTA_CONNECT = 4,
+	DIG_CONNECT_MAX
+}DM_DIG_CONNECT_E;
+
+
+
+typedef	enum _BT_Ant_NUM{
+	Ant_x2	= 0,		
+	Ant_x1	= 1
+} BT_Ant_NUM, *PBT_Ant_NUM;
+
+typedef	enum _BT_CoType{
+	BT_2Wire		= 0,		
+	BT_ISSC_3Wire	= 1,
+	BT_Accel		= 2,
+	BT_CSR_BC4		= 3,
+	BT_CSR_BC8		= 4,
+	BT_RTL8756		= 5,
+} BT_CoType, *PBT_CoType;
+
+typedef	enum _BT_CurState{
+	BT_OFF		= 0,	
+	BT_ON		= 1,
+} BT_CurState, *PBT_CurState;
+
+typedef	enum _BT_ServiceType{
+	BT_SCO		= 0,	
+	BT_A2DP		= 1,
+	BT_HID		= 2,
+	BT_HID_Idle	= 3,
+	BT_Scan		= 4,
+	BT_Idle		= 5,
+	BT_OtherAction	= 6,
+	BT_Busy			= 7,
+	BT_OtherBusy		= 8,
+	BT_PAN			= 9,
+} BT_ServiceType, *PBT_ServiceType;
+
+typedef	enum _BT_RadioShared{
+	BT_Radio_Shared 	= 0,	
+	BT_Radio_Individual	= 1,
+} BT_RadioShared, *PBT_RadioShared;
+
+struct btcoexist_priv	{
+	u8					BT_Coexist;
+	u8					BT_Ant_Num;
+	u8					BT_CoexistType;
+	u8					BT_State;
+	u8					BT_CUR_State;		//0:on, 1:off
+	u8					BT_Ant_isolation;	//0:good, 1:bad
+	u8					BT_PapeCtrl;		//0:SW, 1:SW/HW dynamic
+	u8					BT_Service;
+	u8					BT_Ampdu;	// 0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU.
+	u8					BT_RadioSharedType;
+	u32					Ratio_Tx;
+	u32					Ratio_PRI;
+	u8					BtRfRegOrigin1E;
+	u8					BtRfRegOrigin1F;
+	u8					BtRssiState;
+	u32					BtEdcaUL;
+	u32					BtEdcaDL;
+	u32					BT_EDCA[2];
+	u8					bCOBT;
+
+	u8					bInitSet;
+	u8					bBTBusyTraffic;
+	u8					bBTTrafficModeSet;
+	u8					bBTNonTrafficModeSet;
+//	BTTraffic				BT21TrafficStatistics;
+	u32					CurrentState;
+	u32					PreviousState;
+	u8					BtPreRssiState;
+	u8					bFWCoexistAllOff;
+	u8					bSWCoexistAllOff;
+};
+
+#define		BW_AUTO_SWITCH_HIGH_LOW	25
+#define		BW_AUTO_SWITCH_LOW_HIGH	30
+
+#define		DM_DIG_THRESH_HIGH			40
+#define		DM_DIG_THRESH_LOW			35
+
+#define		DM_FALSEALARM_THRESH_LOW	400
+#define		DM_FALSEALARM_THRESH_HIGH	1000
+
+#define		DM_DIG_MAX					0x3e
+#define		DM_DIG_MIN						0x1c
+
+#define		DM_DIG_FA_UPPER				0x32
+#define		DM_DIG_FA_LOWER				0x20
+#define		DM_DIG_FA_TH0					0x20
+#define		DM_DIG_FA_TH1					0x100
+#define		DM_DIG_FA_TH2					0x200
+
+#define		DM_DIG_BACKOFF_MAX			12
+#define		DM_DIG_BACKOFF_MIN			(-4)
+#define		DM_DIG_BACKOFF_DEFAULT		10
+
+#define		RxPathSelection_SS_TH_low		30
+#define		RxPathSelection_diff_TH			18
+
+#define		DM_RATR_STA_INIT			0
+#define		DM_RATR_STA_HIGH			1
+#define 		DM_RATR_STA_MIDDLE		2
+#define 		DM_RATR_STA_LOW			3
+
+#define		CTSToSelfTHVal					30
+#define		RegC38_TH						20
+
+#define		WAIotTHVal						25
+
+//Dynamic Tx Power Control Threshold
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
+
+#define		TxHighPwrLevel_Normal		0	
+#define		TxHighPwrLevel_Level1		1
+#define		TxHighPwrLevel_Level2		2
+
+#define		DM_Type_ByFW			0
+#define		DM_Type_ByDriver		1
+
+typedef struct _RATE_ADAPTIVE
+{
+	u8				RateAdaptiveDisabled;
+	u8				RATRState;
+	u16				reserve;	
+	
+	u32				HighRSSIThreshForRA;
+	u32				High2LowRSSIThreshForRA;
+	u8				Low2HighRSSIThreshForRA40M;
+	u32				LowRSSIThreshForRA40M;	
+	u8				Low2HighRSSIThreshForRA20M;
+	u32				LowRSSIThreshForRA20M;	
+	u32				UpperRSSIThresholdRATR;
+	u32				MiddleRSSIThresholdRATR;
+	u32				LowRSSIThresholdRATR;
+	u32				LowRSSIThresholdRATR40M;
+	u32				LowRSSIThresholdRATR20M;
+	u8				PingRSSIEnable;	//cosa add for Netcore long range ping issue
+	u32				PingRSSIRATR;	//cosa add for Netcore long range ping issue
+	u32				PingRSSIThreshForRA;//cosa add for Netcore long range ping issue
+	u32				LastRATR;
+	u8				PreRATRState;
+	
+} RATE_ADAPTIVE, *PRATE_ADAPTIVE;
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+// This indicates two different the steps. 
+// In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air.
+// In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK
+// with original RSSI to determine if it is necessary to switch antenna.
+#define SWAW_STEP_PEAK		0
+#define SWAW_STEP_DETERMINE	1
+
+#define	TP_MODE		0
+#define	RSSI_MODE		1
+#define	TRAFFIC_LOW	0
+#define	TRAFFIC_HIGH	1
+
+typedef struct _SW_Antenna_Switch_
+{
+	u8		try_flag;
+	s32		PreRSSI;
+	u8		CurAntenna;
+	u8		PreAntenna;
+	u8		RSSI_Trying;
+	u8		TestMode;
+	u8		bTriggerAntennaSwitch;
+	u8		SelectAntennaMap;
+	// Before link Antenna Switch check
+	u8		SWAS_NoLink_State;
+	
+}SWAT_T;
+typedef enum tag_SW_Antenna_Switch_Definition
+{
+	Antenna_B = 1,
+	Antenna_A = 2,
+	Antenna_MAX = 3,
+}DM_SWAS_E;
+
+
+#endif
+
+struct 	dm_priv	
+{
+	u8	DM_Type;
+	u8	DMFlag, DMFlag_tmp;
+	
+
+	//for DIG
+	u8 bDMInitialGainEnable;
+	DIG_T	DM_DigTable;
+
+	FALSE_ALARM_STATISTICS FalseAlmCnt;	
+	
+	//for rate adaptive, in fact,  88c/92c fw will handle this
+	u8 bUseRAMask;
+	RATE_ADAPTIVE RateAdaptive;
+
+	//* Upper and Lower Signal threshold for Rate Adaptive*/
+	int	UndecoratedSmoothedPWDB;
+	int	EntryMinUndecoratedSmoothedPWDB;
+	int	EntryMaxUndecoratedSmoothedPWDB;
+
+
+	//for High Power
+	u8 bDynamicTxPowerEnable;
+	u8 LastDTPLvl;
+	u8 DynamicTxHighPowerLvl;//Add by Jacken Tx Power Control for Near/Far Range 2008/03/06
+		
+	//for tx power tracking
+	//u8 bTXPowerTracking;
+	u8 TXPowercount;
+	u8 bTXPowerTrackingInit;	
+	u8 TxPowerTrackControl;	//for mp mode, turn off txpwrtracking as default
+
+	u8	ThermalValue;
+	u8	ThermalValue_LCK;
+	u8	ThermalValue_IQK;
+	
+	char CCK_index;
+	//u8 Record_CCK_20Mindex;
+	//u8 Record_CCK_40Mindex;
+	char OFDM_index[2];
+	
+	u32 TXPowerTrackingCallbackCnt;	//cosa add for debug
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	_timer SwAntennaSwitchTimer;
+	SWAT_T DM_SWAT_Table;
+	
+	u64	lastTxOkCnt;
+	u64	lastRxOkCnt;
+	u64	TXByteCnt_A;
+	u64	TXByteCnt_B;
+	u64	RXByteCnt_A;
+	u64	RXByteCnt_B;
+	u8	DoubleComfirm;
+	u8	TrafficLoad;
+#endif
+
+	u8		initial_gain_Multi_STA_binitialized ;
+	u8		TM_Trigger;
+	u8		BT_ServiceTypeCnt;
+	u8		BT_LastServiceType;
+	BOOLEAN		BT_bMediaConnect;
+};
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+//#define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;}
+
+
+//============================================================
+// function prototype
+//============================================================
+void init_dm_priv(_adapter *padapter);	
+void	rtl8192c_InitHalDm(	IN	PADAPTER	Adapter	);
+void	rtl8192c_HalDmWatchDog(IN	PADAPTER	Adapter	);
+void	DM_ChangeDynamicInitGainThresh(IN	PADAPTER	pAdapter,
+												IN	u32		DM_Type,
+												IN	u32		DM_Value);
+
+void DM_InitEdcaTurbo(IN PADAPTER	Adapter);
+
+//void AP_InitRateAdaptiveState(IN	PADAPTER	Adapter,	IN	PRT_WLAN_STA  pEntry);
+
+VOID dm_CheckTXPowerTracking(IN	PADAPTER Adapter);
+#ifdef CONFIG_BT_COEXIST
+void dm_InitBtCoexistDM(	PADAPTER	Adapter);
+void dm_BTCoexist(PADAPTER Adapter );
+void set_dm_bt_coexist(_adapter *padapter, u8 bStart);
+void issue_delete_ba(_adapter *padapter, u8 dir);
+#endif
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+void SwAntDivRSSICheck(_adapter *padapter ,u32 RxPWDBAll); 
+
+u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter);
+void dm_SW_AntennaSwitchCallback(void *FunctionContext);
+void SwAntDivRestAfterLink(	IN	PADAPTER	Adapter);
+#endif
+
+#endif	//__HAL8190PCIDM_H__
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_event.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_event.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_event.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_event.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8192C_EVENT_H_
+#define _RTL8192C_EVENT_H_
+
+struct C2HEvent_Header
+{
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	unsigned int len:16;
+	unsigned int ID:8;
+	unsigned int seq:8;
+	
+#elif defined(CONFIG_BIG_ENDIAN)
+
+	unsigned int seq:8;
+	unsigned int ID:8;
+	unsigned int len:16;
+	
+#else
+
+#  error "Must be LITTLE or BIG Endian"
+
+#endif
+
+	unsigned int rsvd;
+
+};
+
+void rtw_dummy_event_callback(_adapter *adapter , u8 *pbuf);
+static void fwdbg_event_callback(_adapter *adapter , u8 *pbuf);
+
+enum rtl8192c_c2h_event
+{
+	GEN_EVT_CODE(_Read_MACREG)=0, /*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+ 	GEN_EVT_CODE(_Read_RFREG),
+ 	GEN_EVT_CODE(_Read_EEPROM),
+ 	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),			/*5*/
+ 	GEN_EVT_CODE(_Get_BasicRate),  
+ 	GEN_EVT_CODE(_Get_DataRate),   
+ 	GEN_EVT_CODE(_Survey),	 /*8*/
+ 	GEN_EVT_CODE(_SurveyDone),	 /*9*/
+ 	
+ 	GEN_EVT_CODE(_JoinBss) , /*10*/
+ 	GEN_EVT_CODE(_AddSTA),
+ 	GEN_EVT_CODE(_DelSTA),
+ 	GEN_EVT_CODE(_AtimDone) ,
+ 	GEN_EVT_CODE(_TX_Report),  
+	GEN_EVT_CODE(_CCX_Report),			/*15*/
+ 	GEN_EVT_CODE(_DTM_Report),
+ 	GEN_EVT_CODE(_TX_Rate_Statistics),
+ 	GEN_EVT_CODE(_C2HLBK), 
+ 	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB	
+	GEN_EVT_CODE(_CloseRF),				//filen: only for PCIE, work around ASPM
+ 	MAX_C2HEVT
+};
+
+
+#ifdef _RTL8192C_CMD_C_		
+
+struct fwevent rtw_wlanevents[] = 
+{
+	{0, rtw_dummy_event_callback}, 	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_survey_event_callback},		/*8*/
+	{sizeof (struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/
+		
+	{0, &rtw_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
+	{sizeof(struct stadel_event), &rtw_stadel_event_callback},	
+	{0, &rtw_atimdone_event_callback},
+	{0, rtw_dummy_event_callback},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, fwdbg_event_callback},
+	{0, NULL},	 /*20*/
+	{0, NULL},
+	{0, NULL},	
+	{0, &rtw_cpwm_event_callback},
+};
+
+#endif//_RTL8192C_CMD_C_
+
+
+#endif
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_hal.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_hal.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_hal.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_hal.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,555 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192C_HAL_H__
+#define __RTL8192C_HAL_H__
+
+#include "Hal8192CPhyReg.h"
+#include "Hal8192CPhyCfg.h"
+#include "rtl8192c_dm.h"
+
+#if (DEV_BUS_TYPE == DEV_BUS_PCI_INTERFACE)
+
+	#define RTL819X_DEFAULT_RF_TYPE			RF_2T2R
+	//#define RTL819X_DEFAULT_RF_TYPE			RF_1T2R
+	#define RTL819X_TOTAL_RF_PATH				2
+
+	//2TODO:  The following need to check!!
+	#define	RTL8192C_FW_IMG					"rtl8192CE\\rtl8192cfw.bin"
+	#define	RTL8188C_FW_IMG					"rtl8192CE\\rtl8192cfw.bin"
+
+	#define RTL8188C_PHY_REG					"rtl8192CE\\PHY_REG_1T.txt"
+	#define RTL8188C_PHY_RADIO_A				"rtl8192CE\\radio_a_1T.txt"
+	#define RTL8188C_PHY_RADIO_B				"rtl8192CE\\radio_b_1T.txt"
+	#define RTL8188C_AGC_TAB					"rtl8192CE\\AGC_TAB_1T.txt"
+	#define RTL8188C_PHY_MACREG				"rtl8192CE\\MACREG_1T.txt"
+
+	#define RTL8192C_PHY_REG					"rtl8192CE\\PHY_REG_2T.txt"
+	#define RTL8192C_PHY_RADIO_A				"rtl8192CE\\radio_a_2T.txt"
+	#define RTL8192C_PHY_RADIO_B				"rtl8192CE\\radio_b_2T.txt"
+	#define RTL8192C_AGC_TAB					"rtl8192CE\\AGC_TAB_2T.txt"
+	#define RTL8192C_PHY_MACREG				"rtl8192CE\\MACREG_2T.txt"
+
+	#define RTL819X_PHY_MACPHY_REG			"rtl8192CE\\MACPHY_reg.txt"
+	#define RTL819X_PHY_MACPHY_REG_PG		"rtl8192CE\\MACPHY_reg_PG.txt"
+	#define RTL819X_PHY_MACREG				"rtl8192CE\\MAC_REG.txt"
+	#define RTL819X_PHY_REG					"rtl8192CE\\PHY_REG.txt"
+	#define RTL819X_PHY_REG_1T2R				"rtl8192CE\\PHY_REG_1T2R.txt"
+	#define RTL819X_PHY_REG_to1T1R				"rtl8192CE\\phy_to1T1R_a.txt"
+	#define RTL819X_PHY_REG_to1T2R				"rtl8192CE\\phy_to1T2R.txt"
+	#define RTL819X_PHY_REG_to2T2R				"rtl8192CE\\phy_to2T2R.txt"
+	#define RTL819X_PHY_REG_PG					"rtl8192CE\\PHY_REG_PG.txt"
+	#define RTL819X_AGC_TAB					"rtl8192CE\\AGC_TAB.txt"
+	#define RTL819X_PHY_RADIO_A				"rtl8192CE\\radio_a.txt"
+	#define RTL819X_PHY_RADIO_A_1T			"rtl8192CE\\radio_a_1t.txt"
+	#define RTL819X_PHY_RADIO_A_2T			"rtl8192CE\\radio_a_2t.txt"
+	#define RTL819X_PHY_RADIO_B				"rtl8192CE\\radio_b.txt"
+	#define RTL819X_PHY_RADIO_B_GM			"rtl8192CE\\radio_b_gm.txt"
+	#define RTL819X_PHY_RADIO_C				"rtl8192CE\\radio_c.txt"
+	#define RTL819X_PHY_RADIO_D				"rtl8192CE\\radio_d.txt"
+	#define RTL819X_EEPROM_MAP				"rtl8192CE\\8192ce.map"
+	#define RTL819X_EFUSE_MAP					"rtl8192CE\\8192ce.map"
+
+	// The file name "_2T" is for 92CE, "_1T"  is for 88CE. Modified by tynli. 2009.11.24.
+	#define Rtl819XFwImageArray				Rtl8192CEFwImgArray
+	#define Rtl819XMAC_Array					Rtl8192CEMAC_2T_Array
+	#define Rtl819XAGCTAB_2TArray				Rtl8192CEAGCTAB_2TArray
+	#define Rtl819XAGCTAB_1TArray				Rtl8192CEAGCTAB_1TArray
+	#define Rtl819XPHY_REG_2TArray			Rtl8192CEPHY_REG_2TArray
+	#define Rtl819XPHY_REG_1TArray			Rtl8192CEPHY_REG_1TArray
+	#define Rtl819XRadioA_2TArray				Rtl8192CERadioA_2TArray
+	#define Rtl819XRadioA_1TArray				Rtl8192CERadioA_1TArray
+	#define Rtl819XRadioB_2TArray				Rtl8192CERadioB_2TArray
+	#define Rtl819XRadioB_1TArray				Rtl8192CERadioB_1TArray
+	#define Rtl819XPHY_REG_Array_PG 			Rtl8192CEPHY_REG_Array_PG
+
+#elif (DEV_BUS_TYPE == DEV_BUS_USB_INTERFACE)
+
+	#include "Hal8192CUHWImg.h"
+
+	//2TODO: We should define 8192S firmware related macro settings here!!
+	#define RTL819X_DEFAULT_RF_TYPE			RF_1T2R
+	#define RTL819X_TOTAL_RF_PATH			2
+
+	//TODO:  The following need to check!!
+	#define	RTL8192C_FW_TSMC_IMG				"rtl8192CU\\rtl8192cfwT.bin"
+	#define	RTL8192C_FW_UMC_IMG				"rtl8192CU\\rtl8192cfwU.bin"
+	#define	RTL8723_FW_UMC_IMG				"rtl8192CU\\rtl8723fw.bin"
+	
+	//#define RTL819X_FW_BOOT_IMG   				"rtl8192CU\\boot.img"
+	//#define RTL819X_FW_MAIN_IMG				"rtl8192CU\\main.img"
+	//#define RTL819X_FW_DATA_IMG				"rtl8192CU\\data.img"
+
+	#define RTL8188C_PHY_REG					"rtl8188CU\\PHY_REG.txt"
+	#define RTL8188C_PHY_RADIO_A				"rtl8188CU\\radio_a.txt"
+	#define RTL8188C_PHY_RADIO_B				"rtl8188CU\\radio_b.txt"
+	#define RTL8188C_PHY_RADIO_A_mCard			"rtl8192CU\\radio_a_1T_mCard.txt"
+	#define RTL8188C_PHY_RADIO_B_mCard			"rtl8192CU\\radio_b_1T_mCard.txt" 
+	#define RTL8188C_PHY_RADIO_A_HP			"rtl8192CU\\radio_a_1T_HP.txt"
+	#define RTL8188C_AGC_TAB					"rtl8188CU\\AGC_TAB.txt"
+	#define RTL8188C_PHY_MACREG				"rtl8188CU\\MACREG.txt"
+
+	#define RTL8192C_PHY_REG					"rtl8192CU\\PHY_REG.txt"
+	#define RTL8192C_PHY_RADIO_A				"rtl8192CU\\radio_a.txt"
+	#define RTL8192C_PHY_RADIO_B				"rtl8192CU\\radio_b.txt"
+	#define RTL8192C_AGC_TAB					"rtl8192CU\\AGC_TAB.txt"
+	#define RTL8192C_PHY_MACREG				"rtl8192CU\\MACREG.txt"
+
+	#define RTL819X_PHY_REG_PG				"rtl8192CU\\PHY_REG_PG.txt"
+#if 0
+	#define RTL819X_PHY_MACPHY_REG			"rtl8192CU\\MACPHY_reg.txt"
+	#define RTL819X_PHY_MACPHY_REG_PG		"rtl8192CU\\MACPHY_reg_PG.txt"
+	#define RTL819X_PHY_MACREG				"rtl8192CU\\MAC_REG.txt"
+	#define RTL819X_PHY_REG					"rtl8192CU\\PHY_REG.txt"
+	#define RTL819X_PHY_REG_1T2R				"rtl8192CU\\PHY_REG_1T2R.txt"
+	#define RTL819X_PHY_REG_to1T1R			"rtl8192CU\\phy_to1T1R_a.txt"
+	#define RTL819X_PHY_REG_to1T2R			"rtl8192CU\\phy_to1T2R.txt"
+	#define RTL819X_PHY_REG_to2T2R			"rtl8192CU\\phy_to2T2R.txt"
+	//#define RTL819X_PHY_REG_PG				"rtl8192CU\\PHY_REG_PG.txt"
+	#define RTL819X_AGC_TAB					"rtl8192CU\\AGC_TAB.txt"
+	#define RTL819X_PHY_RADIO_A				"rtl8192CU\\radio_a.txt"
+	#define RTL819X_PHY_RADIO_B				"rtl8192CU\\radio_b.txt"
+	#define RTL819X_PHY_RADIO_B_GM			"rtl8192CU\\radio_b_gm.txt"
+	#define RTL819X_PHY_RADIO_C				"rtl8192CU\\radio_c.txt"
+	#define RTL819X_PHY_RADIO_D				"rtl8192CU\\radio_d.txt"
+	#define RTL819X_EEPROM_MAP				"rtl8192CU\\8192cu.map"
+	#define RTL819X_EFUSE_MAP					"rtl8192CU\\8192cu.map"
+	#define RTL819X_PHY_RADIO_A_1T			"rtl8192CU\\radio_a_1t.txt"
+	#define RTL819X_PHY_RADIO_A_2T			"rtl8192CU\\radio_a_2t.txt"
+#endif
+
+	// The file name "_2T" is for 92CU, "_1T"  is for 88CU. Modified by tynli. 2009.11.24.
+	#define Rtl819XFwImageArray					Rtl8192CUFwTSMCImgArray
+	#define Rtl819XFwTSMCImageArray			Rtl8192CUFwTSMCImgArray
+	#define Rtl819XFwUMCACutImageArray			Rtl8192CUFwUMCACutImgArray
+	#define Rtl819XFwUMCBCutImageArray			Rtl8192CUFwUMCBCutImgArray
+	
+	#define Rtl819XMAC_Array					Rtl8192CUMAC_2T_Array
+	#define Rtl819XAGCTAB_2TArray				Rtl8192CUAGCTAB_2TArray
+	#define Rtl819XAGCTAB_1TArray				Rtl8192CUAGCTAB_1TArray
+	#define Rtl819XAGCTAB_1T_HPArray			Rtl8192CUAGCTAB_1T_HPArray
+	#define Rtl819XPHY_REG_2TArray				Rtl8192CUPHY_REG_2TArray
+	#define Rtl819XPHY_REG_1TArray				Rtl8192CUPHY_REG_1TArray
+	#define Rtl819XPHY_REG_1T_mCardArray		Rtl8192CUPHY_REG_1T_mCardArray 					
+	#define Rtl819XPHY_REG_2T_mCardArray		Rtl8192CUPHY_REG_2T_mCardArray	
+	#define Rtl819XPHY_REG_1T_HPArray			Rtl8192CUPHY_REG_1T_HPArray
+	#define Rtl819XRadioA_2TArray					Rtl8192CURadioA_2TArray
+	#define Rtl819XRadioA_1TArray					Rtl8192CURadioA_1TArray
+	#define Rtl819XRadioA_1T_mCardArray			Rtl8192CURadioA_1T_mCardArray			
+	#define Rtl819XRadioB_2TArray					Rtl8192CURadioB_2TArray
+	#define Rtl819XRadioB_1TArray					Rtl8192CURadioB_1TArray	
+	#define Rtl819XRadioB_1T_mCardArray			Rtl8192CURadioB_1T_mCardArray
+	#define Rtl819XRadioA_1T_HPArray			Rtl8192CURadioA_1T_HPArray	
+	#define Rtl819XPHY_REG_Array_PG 			Rtl8192CUPHY_REG_Array_PG
+	#define Rtl819XPHY_REG_Array_PG_mCard 		Rtl8192CUPHY_REG_Array_PG_mCard			
+	#define Rtl819XPHY_REG_Array_PG_HP			Rtl8192CUPHY_REG_Array_PG_HP		
+		
+#endif
+
+
+enum RTL871X_HCI_TYPE {
+
+	RTL8192C_SDIO,
+	RTL8192C_USB,
+	RTL8192C_PCIE
+};
+
+#define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len)&0x7F ? 1:0))
+
+#define FW_8192C_SIZE					16384+32//16k
+#define FW_8192C_START_ADDRESS		0x1000
+#define FW_8192C_END_ADDRESS		0x3FFF
+
+#define MAX_PAGE_SIZE			4096	// @ page : 4k bytes
+
+#define IS_FW_HEADER_EXIST(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x92C0 ||\
+									(le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x88C0)
+
+typedef enum _FIRMWARE_SOURCE{
+	FW_SOURCE_IMG_FILE = 0,
+	FW_SOURCE_HEADER_FILE = 1,		//from header file
+}FIRMWARE_SOURCE, *PFIRMWARE_SOURCE;
+
+typedef struct _RT_FIRMWARE{
+	FIRMWARE_SOURCE	eFWSource;
+	u8			szFwBuffer[FW_8192C_SIZE];
+	u32			ulFwLength;
+}RT_FIRMWARE, *PRT_FIRMWARE, RT_FIRMWARE_92C, *PRT_FIRMWARE_92C;
+
+//
+// This structure must be cared byte-ordering
+//
+// Added by tynli. 2009.12.04.
+typedef struct _RT_8192C_FIRMWARE_HDR {//8-byte alinment required
+
+	//--- LONG WORD 0 ----
+	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+	u8		Category;	// AP/NIC and USB/PCI
+	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+	u16		Version;		// FW Version
+	u8		Subversion;	// FW Subversion, default 0x00
+	u16		Rsvd1;
+
+
+	//--- LONG WORD 1 ----
+	u8		Month;	// Release time Month field
+	u8		Date;	// Release time Date field
+	u8		Hour;	// Release time Hour field
+	u8		Minute;	// Release time Minute field
+	u16		RamCodeSize;	// The size of RAM code
+	u16		Rsvd2;
+
+	//--- LONG WORD 2 ----
+	u32		SvnIdx;	// The SVN entry index
+	u32		Rsvd3;
+
+	//--- LONG WORD 3 ----
+	u32		Rsvd4;
+	u32		Rsvd5;
+
+}RT_8192C_FIRMWARE_HDR, *PRT_8192C_FIRMWARE_HDR;
+
+#define DRIVER_EARLY_INT_TIME		0x05
+#define BCN_DMA_ATIME_INT_TIME		0x02
+
+#define USB_HIGH_SPEED_BULK_SIZE	512
+#define USB_FULL_SPEED_BULK_SIZE	64
+
+#if USB_RX_AGGREGATION_92C
+
+typedef enum _USB_RX_AGG_MODE{
+	USB_RX_AGG_DISABLE,
+	USB_RX_AGG_DMA,
+	USB_RX_AGG_USB,
+	USB_RX_AGG_MIX
+}USB_RX_AGG_MODE;
+
+#define MAX_RX_DMA_BUFFER_SIZE	10240		// 10K for 8192C RX DMA buffer
+
+#endif
+
+
+#define TX_SELE_HQ			BIT(0)		// High Queue
+#define TX_SELE_LQ			BIT(1)		// Low Queue
+#define TX_SELE_NQ			BIT(2)		// Normal Queue
+
+
+// Note: We will divide number of page equally for each queue other than public queue!
+
+#define TX_TOTAL_PAGE_NUMBER		0xF8
+#define TX_PAGE_BOUNDARY		(TX_TOTAL_PAGE_NUMBER + 1)
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER
+//#define NORMAL_PAGE_NUM_PUBQ		0x56
+//#define NORMAL_PAGE_NUM_PUBQ		0xb0
+#define NORMAL_PAGE_NUM_PUBQ		0xE7
+
+
+// For Test Chip Setting
+// (HPQ + LPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER
+#define TEST_PAGE_NUM_PUBQ		0x7E
+
+
+// For Test Chip Setting
+#define WMM_TEST_TX_TOTAL_PAGE_NUMBER	0xF5
+#define WMM_TEST_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) //F6
+
+#define WMM_TEST_PAGE_NUM_PUBQ		0xA3
+#define WMM_TEST_PAGE_NUM_HPQ		0x29
+#define WMM_TEST_PAGE_NUM_LPQ		0x29
+
+
+//Note: For Normal Chip Setting ,modify later
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER	0xF5
+#define WMM_NORMAL_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) //F6
+
+#define WMM_NORMAL_PAGE_NUM_PUBQ	0xB0
+#define WMM_NORMAL_PAGE_NUM_HPQ		0x29
+#define WMM_NORMAL_PAGE_NUM_LPQ		0x1C
+#define WMM_NORMAL_PAGE_NUM_NPQ		0x1C
+
+//-------------------------------------------------------------------------
+//	Chip specific
+//-------------------------------------------------------------------------
+#define CHIP_92C  					BIT(0)
+#define CHIP_92C_1T2R				BIT(1)
+#define CHIP_8723					BIT(2) // RTL8723 With BT feature
+#define CHIP_8723_DRV_REV			BIT(3) // RTL8723 Driver Revised
+#define NORMAL_CHIP  				BIT(4)
+#define CHIP_VENDOR_UMC			BIT(5)
+#define CHIP_VENDOR_UMC_B_CUT	BIT(6) // Chip version for ECO
+
+#define IS_NORMAL_CHIP(version)  	(((version) & NORMAL_CHIP) ? _TRUE : _FALSE) 
+#define IS_92C_SERIAL(version)   		(((version) & CHIP_92C) ? _TRUE : _FALSE)
+#define IS_8723_SERIES(version)   	(((version) & CHIP_8723) ? _TRUE : _FALSE)
+#define IS_92C_1T2R(version)			(((version) & CHIP_92C) && ((version) & CHIP_92C_1T2R))
+#define IS_VENDOR_UMC(version)		(((version) & CHIP_VENDOR_UMC) ? _TRUE : _FALSE)
+#define IS_VENDOR_UMC_A_CUT(version)	(((version) & CHIP_VENDOR_UMC) ? (((version) & (BIT6|BIT7)) ? _FALSE : _TRUE) : _FALSE)
+
+#define IS_VENDOR_8723_A_CUT(version)	(((version) & CHIP_VENDOR_UMC) ? (((version) & (BIT6)) ? _FALSE : _TRUE) : _FALSE)
+
+// 20100707 Joseph: Add vendor information into chip version definition.
+// 20100902 Roger: Add UMC B-Cut and RTL8723 chip info definition.
+/*
+|    BIT 7   |     BIT6     |                BIT 5                | BIT 4              |       BIT 3     |  BIT 2   |  BIT 1   |   BIT 0    |
++--------+---------+---------------------- +------------ +----------- +------ +-----------------+
+|Reserved | UMC BCut |Manufacturer(TSMC/UMC)  | TEST/NORMAL | 8723 Version | 8723?   | 1T2R?  | 88C/92C |
+*/
+typedef enum _VERSION_8192C{
+	VERSION_TEST_CHIP_88C = 0x00,
+	VERSION_TEST_CHIP_92C = 0x01,
+	VERSION_NORMAL_TSMC_CHIP_88C = 0x10,
+	VERSION_NORMAL_TSMC_CHIP_92C = 0x11,
+	VERSION_NORMAL_TSMC_CHIP_92C_1T2R = 0x13,
+	VERSION_NORMAL_UMC_CHIP_88C_A_CUT = 0x30,
+	VERSION_NORMAL_UMC_CHIP_92C_A_CUT = 0x31,
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT = 0x33,		
+	VERSION_NORMA_UMC_CHIP_8723_1T1R_A_CUT = 0x34,
+	VERSION_NORMA_UMC_CHIP_8723_1T1R_B_CUT = 0x3c,
+	VERSION_NORMAL_UMC_CHIP_88C_B_CUT = 0x70,
+	VERSION_NORMAL_UMC_CHIP_92C_B_CUT = 0x71,
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT = 0x73,	
+}VERSION_8192C,*PVERSION_8192C;
+
+#define CHIP_BONDING_92C_1T2R	0x1
+#define CHIP_BONDING_IDENTIFIER(_value)	(((_value)>>22)&0x3)
+//-------------------------------------------------------------------------
+//	Channel Plan
+//-------------------------------------------------------------------------
+enum ChannelPlan{
+	CHPL_FCC	= 0,
+	CHPL_IC		= 1,
+	CHPL_ETSI	= 2,
+	CHPL_SPAIN	= 3,
+	CHPL_FRANCE	= 4,
+	CHPL_MKK	= 5,
+	CHPL_MKK1	= 6,
+	CHPL_ISRAEL	= 7,
+	CHPL_TELEC	= 8,
+	CHPL_GLOBAL	= 9,
+	CHPL_WORLD	= 10,
+};
+
+typedef struct _TxPowerInfo{
+	u8 CCKIndex[RF90_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT40_1SIndex[RF90_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT40_2SIndexDiff[RF90_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT20IndexDiff[RF90_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 OFDMIndexDiff[RF90_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT40MaxOffset[RF90_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT20MaxOffset[RF90_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 TSSI_A;
+	u8 TSSI_B;
+}TxPowerInfo, *PTxPowerInfo;
+
+struct	_hal_ops {
+	u32 (*hal_init)(PADAPTER padapter);
+	u32 (*hal_deinit)(PADAPTER padapter);
+
+	u32  (*inirp_init)(PADAPTER adapter);
+	u32  (*inirp_deinit)(PADAPTER adapter);
+
+	void (*intf_chip_configure)(PADAPTER Adapter);
+
+	void (*read_adapter_info)(PADAPTER Adapter);
+
+	void (*set_bwmode_handler)(PADAPTER padapter, HT_CHANNEL_WIDTH Bandwidth, u8 Offset);
+	void (*set_channel_handler)(PADAPTER padapter, u8 channel);
+
+	void (*process_phy_info)(PADAPTER padapter, void *prframe);
+	void	(*hal_dm_watchdog)(PADAPTER Adapter);
+};
+
+struct hal_priv
+{
+	struct _hal_ops	hal_ops;
+
+	unsigned short HardwareType;
+	unsigned short VersionID;
+	unsigned short CustomerID;
+
+	unsigned short FirmwareVersion;
+	unsigned short FirmwareVersionRev;
+	unsigned short FirmwareSubVersion;
+
+	//current WIFI_PHY values
+	unsigned long ReceiveConfig;
+	unsigned char CurrentChannel;
+	WIRELESS_MODE CurrentWirelessMode;
+	HT_CHANNEL_WIDTH CurrentChannelBW;
+	unsigned char nCur40MhzPrimeSC;// Control channel sub-carrier
+
+	//rf_ctrl
+	unsigned char rf_chip;
+	unsigned char rf_type;
+	unsigned char NumTotalRFPath;
+
+
+	BB_REGISTER_DEFINITION_T	PHYRegDef[4];	//Radio A/B/C/D
+
+
+	// Read/write are allow for following hardware information variables
+	u8					framesync;
+	unsigned int			framesyncC34;
+	u8					framesyncMonitor;
+	u8					DefaultInitialGain[4];
+	u8					pwrGroupCnt;
+	u32					MCSTxPowerLevelOriginalOffset[7][16];	// 7 gropus of pwr diff by rates
+	u32					CCKTxPowerLevelOriginalOffset;
+	u8					TxPowerLevelCCK[14];			// CCK channel 1~14
+	u8					TxPowerLevelOFDM24G[14];		// OFDM 2.4G channel 1~14
+	u8					TxPowerLevelOFDM5G[14];			// OFDM 5G
+	u8					AntennaTxPwDiff[3];	// Antenna gain offset, index 0 for B, 1 for C, and 2 for D
+
+	//u8					ThermalMeter[2];	// ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u32					AntennaTxPath;					// Antenna path Tx
+	u32					AntennaRxPath;					// Antenna path Rx
+	u8					BoardType;
+	u8					BluetoothCoexist;
+	u8					ExternalPA;
+
+	u32					LedControlNum;
+	u32					LedControlMode;
+	//u32					TxPowerTrackControl;
+	u8					b1x1RecvCombine;	// for 1T1R receive combining
+
+	u8					bCCKinCH14;
+
+	//vivi, for tx power tracking, 20080407
+	//u2Byte					TSSI_13dBm;
+	//u4Byte					Pwr_Track;
+	// The current Tx Power Level
+	unsigned char	CurrentCckTxPwrIdx;
+	unsigned char	CurrentOfdm24GTxPwrIdx;
+
+	unsigned char	LegacyHTTxPowerDiff;// Legacy to HT rate power diff
+
+	unsigned char bCckHighPower;
+
+	unsigned int	RfRegChnlVal[2];
+
+	//
+	// The same as 92CE.
+	//
+	//u8					ThermalMeter[2];	// ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u8					ThermalValue;
+	u8					ThermalValue_LCK;
+	u8					ThermalValue_IQK;
+	u8					bRfPiEnable;
+
+	//for APK
+	u32					APKoutput[2][2];	//path A/B; output1_1a/output1_2a
+	u8					bAPKdone;
+	u8					bAPKThermalMeterIgnore;
+
+	//for TxPwrTracking
+	int					RegE94;
+	int 					RegE9C;
+	int					RegEB4;
+	int					RegEBC;
+
+	//for IQK
+	u32				IQKInitialized;
+
+	unsigned int		ADDA_backup[16];
+	unsigned int		IQK_MAC_backup[4];
+	u32				IQK_BB_backup[10];
+	//RDG enable
+	BOOLEAN	 	bRDGEnable;
+	u8		bDumpRxPkt;
+
+	//for host message to fw
+	u8 LastHMEBoxNum;
+	u8 PowerIndex_backup[6];
+
+#ifdef CONFIG_USB_HCI
+
+	// For 92C USB endpoint setting
+	//
+
+	unsigned int UsbBulkOutSize;
+
+	int	RtNumInPipes;	// Number of Rx pipes in the ring, RtInPipe.
+	int	RtNumOutPipes;	// Number of Tx pipes in the ring, RtOutPipe.
+
+	unsigned char	OutEpQueueSel;
+	unsigned char OutEpNumber;
+
+	unsigned char Queue2EPNum[8];//for out endpoint number mapping
+
+#if USB_TX_AGGREGATION_92C
+	unsigned char			UsbTxAggMode;
+	unsigned char			UsbTxAggDescNum;
+#endif
+#if USB_RX_AGGREGATION_92C
+	u16				HwRxPageSize;				// Hardware setting
+	u32				MaxUsbRxAggBlock;
+
+	USB_RX_AGG_MODE	UsbRxAggMode;
+	u8				UsbRxAggBlockCount;			// USB Block count. Block size is 512-byte in hight speed and 64-byte in full speed
+	u8				UsbRxAggBlockTimeout;
+	u8				UsbRxAggPageCount;			// 8192C DMA page count
+	u8				UsbRxAggPageTimeout;
+#endif
+
+#endif
+
+	u8 				fw_ractrl;
+	u8				RegTxPause;
+	u32				RegBcnCtrlVal;
+	// Beacon function related global variable.
+	u8				RegFwHwTxQCtrl;
+	u8				RegReg542;
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	u8				CurAntenna;	
+	u8				AntDivCfg;
+
+	//SW Antenna Switch
+	s32				RSSI_sum_A;
+	s32				RSSI_sum_B;
+	s32				RSSI_cnt_A;
+	s32				RSSI_cnt_B;
+	BOOLEAN			RSSI_test;
+	
+#endif
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv		bt_coexist;	
+#endif
+	u8			bRxRSSIDisplay;
+
+};
+
+
+int FirmwareDownload92C(IN	PADAPTER Adapter);
+void NicIFReadAdapterInfo8192C(PADAPTER Adapter);
+void rtl8192c_ReadChipVersion(IN PADAPTER Adapter);
+
+
+
+typedef struct hal_priv HAL_DATA_TYPE, *PHAL_DATA_TYPE;
+typedef struct eeprom_priv EEPROM_EFUSE_PRIV, *PEEPROM_EFUSE_PRIV;
+
+#define GET_HAL_DATA(priv)	(&priv->halpriv)
+#define GET_RF_TYPE(priv)	(GET_HAL_DATA(priv)->rf_type)
+
+#define GET_EEPROM_EFUSE_PRIV(priv)	(&priv->eeprompriv)
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_recv.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_recv.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_recv.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_recv.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,287 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8192C_RECV_H_
+#define _RTL8192C_RECV_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#ifdef PLATFORM_OS_XP
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF 1024//512//128
+	#else
+		#define NR_RECVBUFF (16)
+	#endif
+#elif defined(PLATFORM_OS_CE)
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF (128)
+	#else
+		#define NR_RECVBUFF (4)
+	#endif
+#else
+	#define NR_RECVBUFF (4)
+	#define NR_PREALLOC_RECV_SKB (8)
+#endif
+
+#define RXDESC_SIZE	24
+#define RXDESC_OFFSET RXDESC_SIZE
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+//#define MAX_RECVBUF_SZ 2048 // 2k
+//#define MAX_RECVBUF_SZ (8192) // 8K
+//#define MAX_RECVBUF_SZ (16384) //16K
+//#define MAX_RECVBUF_SZ (16384 + 1024) //16K + 1k
+//#define MAX_RECVBUF_SZ (30720) //30k
+//#define MAX_RECVBUF_SZ (30720 + 1024) //30k+1k
+//#define MAX_RECVBUF_SZ (32768) // 32k
+
+#if defined(CONFIG_SDIO_HCI)
+
+#define MAX_RECVBUF_SZ (50000) //30k //(2048)//(30720) //30k
+
+#elif defined(CONFIG_USB_HCI)
+
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+//#define MAX_RECVBUF_SZ (32768) // 32k
+//#define MAX_RECVBUF_SZ (16384) //16K
+//#define MAX_RECVBUF_SZ (10240) //10K
+#define MAX_RECVBUF_SZ (15360) // 15k < 16k
+#endif
+
+#endif
+
+#define RECV_BULK_IN_ADDR		0x80
+#define RECV_INT_IN_ADDR		0x81
+
+#define RECVBUFF_ALIGN_SZ 512
+
+#define RSVD_ROOM_SZ (0)
+
+
+//These definition is used for Rx packet reordering.
+#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
+#define SN_EQUAL(a, b)	(a == b)
+//#define REORDER_WIN_SIZE	128
+//#define REORDER_ENTRY_NUM	128
+#define REORDER_WAIT_TIME	(30) // (ms)
+
+
+struct recv_stat
+{
+	unsigned int rxdw0;
+
+	unsigned int rxdw1;
+
+	unsigned int rxdw2;
+
+	unsigned int rxdw3;
+
+	unsigned int rxdw4;
+
+	unsigned int rxdw5;
+};
+
+struct phy_cck_rx_status
+{
+	/* For CCK rate descriptor. This is a unsigned 8:1 variable. LSB bit presend
+	   0.5. And MSB 7 bts presend a signed value. Range from -64~+63.5. */
+	u8	adc_pwdb_X[4];
+	u8	sq_rpt;
+	u8	cck_agc_rpt;
+};
+
+struct phy_stat
+{
+	unsigned int phydw0;
+
+	unsigned int phydw1;
+
+	unsigned int phydw2;
+
+	unsigned int phydw3;
+
+	unsigned int phydw4;
+
+	unsigned int phydw5;
+
+	unsigned int phydw6;
+
+	unsigned int phydw7;
+};
+#define PHY_STAT_GAIN_TRSW_SHT 0
+#define PHY_STAT_PWDB_ALL_SHT 4
+#define PHY_STAT_CFOSHO_SHT 5
+#define PHY_STAT_CCK_AGC_RPT_SHT 5
+#define PHY_STAT_CFOTAIL_SHT 9
+#define PHY_STAT_RXEVM_SHT 13
+#define PHY_STAT_RXSNR_SHT 15
+#define PHY_STAT_PDSNR_SHT 19
+#define PHY_STAT_CSI_CURRENT_SHT 21
+#define PHY_STAT_CSI_TARGET_SHT 23
+#define PHY_STAT_SIGEVM_SHT 25
+#define PHY_STAT_MAX_EX_PWR_SHT 26
+
+// Rx smooth factor
+#define	Rx_Smooth_Factor (20)
+
+union recvstat {
+	struct recv_stat recv_stat;
+	unsigned int value[RXDESC_SIZE>>2];
+};
+
+
+struct recv_buf{
+
+	_list list;
+
+	_lock recvbuf_lock;
+
+	u32	ref_cnt;
+
+	_adapter  *adapter;
+
+#ifdef CONFIG_SDIO_HCI
+#ifdef PLATFORM_OS_XP
+	PMDL mdl_ptr;
+#endif
+	u8	cmd_fail;
+#endif
+
+
+#ifdef CONFIG_USB_HCI
+
+	#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	purb;
+
+	#endif
+
+	#ifdef PLATFORM_OS_XP
+		PIRP		pirp;
+	#endif
+
+	#ifdef PLATFORM_OS_CE
+		USB_TRANSFER	usb_transfer_read_port;
+	#endif
+
+	u8  irp_pending;
+	int  transfer_len;
+
+#endif
+
+#ifdef PLATFORM_LINUX
+	_pkt *pskb;
+	u8 reuse;
+#endif
+
+	struct rtw_transfer_buffer *rx_transfer_buf;
+
+	uint  len;
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+
+	u8 *pbuf;
+	u8 *pallocated_buf;
+
+
+};
+
+
+/*
+	head  ----->
+
+		data  ----->
+
+			payload
+
+		tail  ----->
+
+
+	end   ----->
+
+	len = (unsigned int )(tail - data);
+
+*/
+struct recv_frame_hdr{
+
+	_list	list;
+	_pkt	*pkt;
+	_pkt *pkt_newalloc;
+
+	_adapter  *adapter;
+	
+	u8 fragcnt;
+
+	int frame_tag;
+
+	struct rx_pkt_attrib attrib;
+
+	uint  len;
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+
+	void *precvbuf;
+
+
+	//
+	struct sta_info *psta;
+
+	//for A-MPDU Rx reordering buffer control
+	struct recv_reorder_ctrl *preorder_ctrl;
+
+};
+
+
+union recv_frame{
+
+	union{
+		_list list;
+		struct recv_frame_hdr hdr;
+		uint mem[RECVFRAME_HDR_ALIGN>>2];
+	}u;
+
+	//uint mem[MAX_RXSZ>>2];
+
+};
+
+
+int rtw_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+
+void rtl8192cu_update_recvframe_attrib_from_recvstat(union recv_frame *precvframe, struct recv_stat *prxstat);
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext);
+
+void rtl8192c_query_rx_phy_status(union recv_frame *prframe, struct recv_stat *prxstat );
+
+//void rtl8192c_process_phy_info(_adapter *padapter, union recv_frame *prframe);
+void rtl8192c_process_phy_info(_adapter *padapter, void *prframe);
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_spec.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_spec.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_spec.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_spec.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1861 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192C_SPEC_H__
+#define __RTL8192C_SPEC_H__
+
+#include <drv_conf.h>
+
+#ifndef BIT
+#define BIT(x)		(1 << (x))
+#endif
+
+#define BIT0		0x00000001
+#define BIT1		0x00000002
+#define BIT2		0x00000004
+#define BIT3		0x00000008
+#define BIT4		0x00000010
+#define BIT5		0x00000020
+#define BIT6		0x00000040
+#define BIT7		0x00000080
+#define BIT8		0x00000100
+#define BIT9		0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+
+//============================================================
+//       8192C Regsiter offset definition
+//============================================================
+
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_SYS_ISO_CTRL			0x0000
+#define REG_SYS_FUNC_EN				0x0002
+#define REG_APS_FSMCO				0x0004
+#define REG_SYS_CLKR				0x0008
+#define REG_9346CR					0x000A
+#define REG_EE_VPD					0x000C
+#define REG_AFE_MISC				0x0010
+#define REG_SPS0_CTRL				0x0011
+#define REG_SPS_OCP_CFG				0x0018
+#define REG_RSV_CTRL				0x001C
+#define REG_RF_CTRL					0x001F
+#define REG_LDOA15_CTRL			0x0020
+#define REG_LDOV12D_CTRL			0x0021
+#define REG_LDOHCI12_CTRL			0x0022
+#define REG_LPLDO_CTRL				0x0023
+#define REG_AFE_XTAL_CTRL			0x0024
+#define REG_AFE_PLL_CTRL			0x0028
+#define REG_EFUSE_CTRL				0x0030
+#define REG_EFUSE_TEST				0x0034
+#define REG_PWR_DATA				0x0038
+#define REG_CAL_TIMER				0x003C
+#define REG_ACLK_MON				0x003E
+#define REG_GPIO_MUXCFG				0x0040
+//#define REG_GPIO_MUXCFG				0x0041
+#define REG_GPIO_IO_SEL				0x0042
+#define REG_MAC_PINMUX_CFG			0x0043
+#define REG_GPIO_PIN_CTRL			0x0044
+//----------------------------------------------------------------------------
+//       8192C GPIO PIN Control Register (offset 0x44, 4 byte)
+//----------------------------------------------------------------------------
+#define GPIO_IN				REG_GPIO_PIN_CTRL		// GPIO pins input value
+#define GPIO_OUT				(REG_GPIO_PIN_CTRL+1)	// GPIO pins output value
+#define GPIO_IO_SEL			(REG_GPIO_PIN_CTRL+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
+#define GPIO_MOD				(REG_GPIO_PIN_CTRL+3)
+
+
+#define REG_GPIO_INTM				0x0048
+#define REG_LEDCFG0					0x004C
+#define REG_LEDCFG1					0x004D
+#define REG_LEDCFG2					0x004E
+#define REG_LEDCFG3					0x004F
+#define REG_LEDCFG					REG_LEDCFG2
+
+#define REG_FSIMR					0x0050
+#define REG_FSISR					0x0054
+#define REG_HSIMR					0x0058
+#define REG_HSISR					0x005c
+
+#define REG_MCUFWDL					0x0080
+
+#define REG_HMEBOX_EXT_0			0x0088
+#define REG_HMEBOX_EXT_1			0x008A
+#define REG_HMEBOX_EXT_2			0x008C
+#define REG_HMEBOX_EXT_3			0x008E
+
+#define REG_BIST_SCAN				0x00D0
+#define REG_BIST_RPT				0x00D4
+#define REG_BIST_ROM_RPT			0x00D8
+#define REG_USB_SIE_INTF			0x00E0
+#define REG_PCIE_MIO_INTF			0x00E4
+#define REG_PCIE_MIO_INTD			0x00E8
+#define REG_HPON_FSM				0x00EC
+#define REG_SYS_CFG					0x00F0
+#define REG_GPIO_OUTSTS			0x00F4	// For RTL8723 only.
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_CR						0x0100
+#define REG_PBP						0x0104
+#define REG_TRXDMA_CTRL			0x010C
+#define REG_TRXFF_BNDY				0x0114
+#define REG_TRXFF_STATUS			0x0118
+#define REG_RXFF_PTR				0x011C
+#define REG_HIMR					0x0120
+#define REG_HISR						0x0124
+#define REG_HIMRE					0x0128
+#define REG_HISRE					0x012C
+#define REG_CPWM					0x012F
+#define REG_FWIMR					0x0130
+#define REG_FWISR					0x0134
+#define REG_PKTBUF_DBG_CTRL		0x0140
+#define REG_PKTBUF_DBG_DATA_L		0x0144
+#define REG_PKTBUF_DBG_DATA_H		0x0148
+
+#define REG_TC0_CTRL				0x0150
+#define REG_TC1_CTRL				0x0154
+#define REG_TC2_CTRL				0x0158
+#define REG_TC3_CTRL				0x015C
+#define REG_TC4_CTRL				0x0160
+#define REG_TCUNIT_BASE				0x0164
+#define REG_MBIST_START				0x0174
+#define REG_MBIST_DONE				0x0178
+#define REG_MBIST_FAIL				0x017C
+#define REG_C2HEVT_MSG_NORMAL		0x01A0
+#define REG_C2HEVT_MSG_TEST			0x01B8
+#define REG_C2HEVT_CLEAR				0x01BF
+#define REG_MCUTST_1					0x01c0
+#define REG_FMETHR					0x01C8
+#define REG_HMETFR					0x01CC
+#define REG_HMEBOX_0				0x01D0
+#define REG_HMEBOX_1				0x01D4
+#define REG_HMEBOX_2				0x01D8
+#define REG_HMEBOX_3				0x01DC
+
+#define REG_LLT_INIT				0x01E0
+#define REG_BB_ACCEESS_CTRL			0x01E8
+#define REG_BB_ACCESS_DATA			0x01EC
+
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RQPN					0x0200
+#define REG_FIFOPAGE				0x0204
+#define REG_TDECTRL					0x0208
+#define REG_TXDMA_OFFSET_CHK		0x020C
+#define REG_TXDMA_STATUS			0x0210
+#define REG_RQPN_NPQ				0x0214
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_AGG_PG_TH			0x0280
+#define REG_RXPKT_NUM				0x0284
+#define REG_RXDMA_STATUS			0x0288
+
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_CTRL_REG			0x0300
+#define	REG_INT_MIG					0x0304	// Interrupt Migration 
+#define	REG_BCNQ_DESA				0x0308	// TX Beacon Descriptor Address
+#define	REG_HQ_DESA					0x0310	// TX High Queue Descriptor Address
+#define	REG_MGQ_DESA				0x0318	// TX Manage Queue Descriptor Address
+#define	REG_VOQ_DESA				0x0320	// TX VO Queue Descriptor Address
+#define	REG_VIQ_DESA				0x0328	// TX VI Queue Descriptor Address
+#define	REG_BEQ_DESA				0x0330	// TX BE Queue Descriptor Address
+#define	REG_BKQ_DESA				0x0338	// TX BK Queue Descriptor Address
+#define	REG_RX_DESA					0x0340	// RX Queue	Descriptor Address
+#define	REG_DBI						0x0348	// Backdoor REG for Access Configuration
+#define	REG_MDIO					0x0354	// MDIO for Access PCIE PHY
+#define	REG_DBG_SEL					0x0360	// Debug Selection Register
+#define	REG_PCIE_HRPWM				0x0361	//PCIe RPWM
+#define	REG_PCIE_HCPWM				0x0363	//PCIe CPWM
+#define	REG_UART_CTRL				0x0364	// UART	Control
+#define	REG_UART_TX_DESA			0x0370	// UART TX Descriptor Address
+#define	REG_UART_RX_DESA			0x0378	// UART Rx Descriptor Address
+
+
+// spec version 11
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_VOQ_INFORMATION			0x0400
+#define REG_VIQ_INFORMATION			0x0404
+#define REG_BEQ_INFORMATION			0x0408
+#define REG_BKQ_INFORMATION			0x040C
+#define REG_MGQ_INFORMATION			0x0410
+#define REG_HGQ_INFORMATION			0x0414
+#define REG_BCNQ_INFORMATION		0x0418
+
+
+#define REG_CPU_MGQ_INFORMATION		0x041C
+#define REG_FWHW_TXQ_CTRL			0x0420
+#define REG_HWSEQ_CTRL				0x0423
+#define REG_TXPKTBUF_BCNQ_BDNY		0x0424
+#define REG_TXPKTBUF_MGQ_BDNY		0x0425
+#define REG_MULTI_BCNQ_EN			0x0426
+#define REG_MULTI_BCNQ_OFFSET		0x0427
+#define REG_SPEC_SIFS				0x0428
+#define REG_RL						0x042A
+#define REG_DARFRC					0x0430
+#define REG_RARFRC					0x0438
+#define REG_RRSR					0x0440
+#define REG_ARFR0					0x0444
+#define REG_ARFR1					0x0448
+#define REG_ARFR2					0x044C
+#define REG_ARFR3					0x0450
+#define REG_AGGLEN_LMT				0x0458
+#define REG_AMPDU_MIN_SPACE			0x045C
+#define REG_TXPKTBUF_WMAC_LBK_BF_HD	0x045D
+#define REG_FAST_EDCA_CTRL			0x0460
+#define REG_RD_RESP_PKT_TH			0x0463
+#define REG_INIRTS_RATE_SEL			0x0480
+#define REG_INIDATA_RATE_SEL		0x0484
+#define REG_POWER_STATUS			0x04A4
+#define REG_POWER_STAGE1			0x04B4
+#define REG_POWER_STAGE2			0x04B8
+#define REG_PKT_LIFE_TIME			0x04C0
+#define REG_STBC_SETTING			0x04C4
+#define REG_PROT_MODE_CTRL			0x04C8
+#define REG_BAR_MODE_CTRL			0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT		0x04CF
+#define REG_NQOS_SEQ				0x04DC
+#define REG_QOS_SEQ					0x04DE
+#define REG_NEED_CPU_HANDLE			0x04E0
+#define REG_PKT_LOSE_RPT			0x04E1
+#define REG_PTCL_ERR_STATUS			0x04E2
+#define REG_DUMMY					0x04FC
+
+
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_EDCA_VO_PARAM			0x0500
+#define REG_EDCA_VI_PARAM			0x0504
+#define REG_EDCA_BE_PARAM			0x0508
+#define REG_EDCA_BK_PARAM			0x050C
+#define REG_BCNTCFG					0x0510
+#define REG_PIFS					0x0512
+#define REG_RDG_PIFS				0x0513
+#define REG_SIFS_CCK				0x0514
+#define REG_SIFS_OFDM				0x0516
+#define REG_SIFS_CTX				0x0514
+#define REG_SIFS_TRX				0x0516
+#define REG_AGGR_BREAK_TIME			0x051A
+#define REG_SLOT					0x051B
+#define REG_TX_PTCL_CTRL			0x0520
+#define REG_TXPAUSE					0x0522
+#define REG_DIS_TXREQ_CLR			0x0523
+#define REG_RD_CTRL					0x0524
+#define REG_TBTT_PROHIBIT			0x0540
+#define REG_RD_NAV_NXT				0x0544
+#define REG_NAV_PROT_LEN			0x0546
+#define REG_BCN_CTRL				0x0550
+#define REG_USTIME_TSF				0x0551
+#define REG_MBID_NUM				0x0552
+#define REG_DUAL_TSF_RST				0x0553
+#define REG_BCN_INTERVAL			0x0554	// The same as REG_MBSSID_BCN_SPACE
+#define REG_MBSSID_BCN_SPACE		0x0554
+#define REG_DRVERLYINT				0x0558
+#define REG_BCNDMATIM				0x0559
+#define REG_ATIMWND					0x055A
+#define REG_BCN_MAX_ERR				0x055D
+#define REG_RXTSF_OFFSET_CCK		0x055E
+#define REG_RXTSF_OFFSET_OFDM		0x055F	
+#define REG_TSFTR					0x0560
+#define REG_INIT_TSFTR				0x0564
+#define REG_PSTIMER					0x0580
+#define REG_TIMER0					0x0584
+#define REG_TIMER1					0x0588
+#define REG_ACMHWCTRL				0x05C0
+#define REG_ACMRSTCTRL				0x05C1
+#define REG_ACMAVG					0x05C2
+#define REG_VO_ADMTIME				0x05C4
+#define REG_VI_ADMTIME				0x05C6
+#define REG_BE_ADMTIME				0x05C8
+#define REG_EDCA_RANDOM_GEN			0x05CC
+#define REG_SCH_TXCMD				0x05D0
+
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_APSD_CTRL				0x0600
+#define REG_BWOPMODE				0x0603
+#define REG_TCR						0x0604
+#define REG_RCR						0x0608
+#define REG_RX_PKT_LIMIT			0x060C
+#define REG_RX_DLK_TIME				0x060D
+#define REG_RX_DRVINFO_SZ			0x060F
+
+#define REG_MACID					0x0610
+#define REG_BSSID					0x0618
+#define REG_MAR						0x0620
+#define REG_MBIDCAMCFG				0x0628
+
+#define REG_USTIME_EDCA				0x0638
+#define REG_MAC_SPEC_SIFS			0x063A
+
+// 20100719 Joseph: Hardware register definition change. (HW datasheet v54)
+#define REG_R2T_SIFS				0x063C	// [15:8]SIFS_R2T_OFDM, [7:0]SIFS_R2T_CCK
+#define REG_T2T_SIFS				0x063E	// [15:8]SIFS_T2T_OFDM, [7:0]SIFS_T2T_CCK
+
+#define REG_RESP_SIFS_CCK			0x063C
+#define REG_RESP_SIFS_OFDM			0x063F
+#define REG_ACKTO					0x0640
+#define REG_CTS2TO					0x0641
+#define REG_EIFS					0x0642
+
+
+//WMA, BA, CCX
+#define REG_NAV_CTRL				0x0650
+#define REG_BACAMCMD				0x0654
+#define REG_BACAMCONTENT			0x0658
+#define REG_LBDLY					0x0660
+#define REG_FWDLY					0x0661
+#define REG_RXERR_RPT				0x0664
+#define REG_WMAC_TRXPTCL_CTL		0x0668
+
+
+// Security
+#define REG_CAMCMD					0x0670
+#define REG_CAMWRITE				0x0674
+#define REG_CAMREAD					0x0678
+#define REG_CAMDBG					0x067C
+#define REG_SECCFG					0x0680
+
+// Power
+#define REG_WOW_CTRL				0x0690
+#define REG_PSSTATUS				0x0691
+#define REG_PS_RX_INFO				0x0692
+#define REG_LPNAV_CTRL				0x0694
+#define REG_WKFMCAM_CMD				0x0698
+#define REG_WKFMCAM_RWD				0x069C
+#define REG_RXFLTMAP0				0x06A0
+#define REG_RXFLTMAP1				0x06A2
+#define REG_RXFLTMAP2				0x06A4
+#define REG_BCN_PSR_RPT				0x06A8
+#define REG_CALB32K_CTRL			0x06AC
+#define REG_PKT_MON_CTRL			0x06B4
+#define REG_BT_COEX_TABLE			0x06C0
+#define REG_WMAC_RESP_TXINFO		0x06D8
+
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+#define REG_USB_INFO				0xFE17
+#define REG_USB_SPECIAL_OPTION		0xFE55
+#define REG_USB_DMA_AGG_TO			0xFE5B
+#define REG_USB_AGG_TO				0xFE5C
+#define REG_USB_AGG_TH				0xFE5D
+
+// For test chip
+#define REG_TEST_USB_TXQS			0xFE48
+#define REG_TEST_SIE_VID			0xFE60		// 0xFE60~0xFE61
+#define REG_TEST_SIE_PID			0xFE62		// 0xFE62~0xFE63
+#define REG_TEST_SIE_OPTIONAL		0xFE64
+#define REG_TEST_SIE_CHIRP_K		0xFE65
+#define REG_TEST_SIE_PHY			0xFE66		// 0xFE66~0xFE6B
+#define REG_TEST_SIE_MAC_ADDR		0xFE70		// 0xFE70~0xFE75
+#define REG_TEST_SIE_STRING			0xFE80		// 0xFE80~0xFEB9
+
+
+// For normal chip
+#define REG_NORMAL_SIE_VID			0xFE60		// 0xFE60~0xFE61
+#define REG_NORMAL_SIE_PID			0xFE62		// 0xFE62~0xFE63
+#define REG_NORMAL_SIE_OPTIONAL		0xFE64
+#define REG_NORMAL_SIE_EP			0xFE65		// 0xFE65~0xFE67
+#define REG_NORMAL_SIE_PHY			0xFE68		// 0xFE68~0xFE6B
+#define REG_NORMAL_SIE_MAC_ADDR		0xFE70		// 0xFE70~0xFE75
+#define REG_NORMAL_SIE_STRING		0xFE80		// 0xFE80~0xFEDF
+
+
+//-----------------------------------------------------
+//
+//	Redifine 8192C register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+
+#define	SYS_ISO_CTRL				REG_SYS_ISO_CTRL	// System Isolation Interface Control.
+#define	SYS_FUNC_EN					REG_SYS_FUNC_EN		// System Function Enable.
+#define	SYS_CLK						REG_SYS_CLKR
+#define	CR9346						REG_9346CR			// 93C46/93C56 Command Register.
+#define	EFUSE_CTRL					REG_EFUSE_CTRL		// E-Fuse Control.
+#define	EFUSE_TEST					REG_EFUSE_TEST		// E-Fuse Test.
+#define	MSR							(REG_CR + 2)		// Media Status register
+#define	ISR							REG_HISR
+#define	TSFR						REG_TSFTR			// Timing Sync Function Timer Register.
+
+#define	MACIDR0						REG_MACID			// MAC ID Register, Offset 0x0050-0x0053
+#define	MACIDR4						(REG_MACID + 4)		// MAC ID Register, Offset 0x0054-0x0055
+
+#define PBP							REG_PBP
+
+// Redifine MACID register, to compatible prior ICs.
+#define	IDR0						MACIDR0
+#define	IDR4						MACIDR4
+
+
+//
+// 9. Security Control Registers	(Offset: )
+//
+#define	RWCAM						REG_CAMCMD		//IN 8190 Data Sheet is called CAMcmd
+#define	WCAMI						REG_CAMWRITE	// Software write CAM input content
+#define	RCAMO						REG_CAMREAD		// Software read/write CAM config
+#define	CAMDBG						REG_CAMDBG
+#define	SECR						REG_SECCFG		//Security Configuration Register
+
+// Unused register
+#define	UnusedRegister				0x1BF
+#define	DCAM						UnusedRegister
+#define	PSR							UnusedRegister
+#define BBAddr						UnusedRegister
+#define	PhyDataR					UnusedRegister
+
+#define	InvalidBBRFValue			0x12345678
+
+// Min Spacing related settings.
+#define	MAX_MSS_DENSITY_2T 			0x13
+#define	MAX_MSS_DENSITY_1T 			0x0A
+
+//----------------------------------------------------------------------------
+//       8192C Cmd9346CR bits					(Offset 0xA, 16bit)
+//----------------------------------------------------------------------------
+#define	CmdEEPROM_En				BIT5	 // EEPROM enable when set 1
+#define	CmdEERPOMSEL				BIT4 	// System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346
+#define	Cmd9346CR_9356SEL			BIT4
+#define	AutoLoadEEPROM				(CmdEEPROM_En|CmdEERPOMSEL)
+#define	AutoLoadEFUSE				CmdEEPROM_En
+
+//----------------------------------------------------------------------------
+//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)  
+//----------------------------------------------------------------------------
+/*
+Network Type
+00: No link
+01: Link in ad hoc network
+10: Link in infrastructure network
+11: AP mode
+Default: 00b.
+*/
+#define	MSR_NOLINK					0x00
+#define	MSR_ADHOC					0x01
+#define	MSR_INFRA					0x02
+#define	MSR_AP						0x03
+
+//
+// 6. Adaptive Control Registers  (Offset: 0x0160 - 0x01CF)
+//
+//----------------------------------------------------------------------------
+//       8192C Response Rate Set Register	(offset 0x181, 24bits)
+//----------------------------------------------------------------------------
+#define	RRSR_RSC_OFFSET				21
+#define	RRSR_SHORT_OFFSET			23
+#define	RRSR_RSC_BW_40M				0x600000
+#define	RRSR_RSC_UPSUBCHNL			0x400000
+#define	RRSR_RSC_LOWSUBCHNL			0x200000
+#define	RRSR_SHORT					0x800000
+#define	RRSR_1M						BIT0
+#define	RRSR_2M						BIT1 
+#define	RRSR_5_5M					BIT2 
+#define	RRSR_11M					BIT3 
+#define	RRSR_6M						BIT4 
+#define	RRSR_9M						BIT5 
+#define	RRSR_12M					BIT6 
+#define	RRSR_18M					BIT7 
+#define	RRSR_24M					BIT8 
+#define	RRSR_36M					BIT9 
+#define	RRSR_48M					BIT10 
+#define	RRSR_54M					BIT11
+#define	RRSR_MCS0					BIT12
+#define	RRSR_MCS1					BIT13
+#define	RRSR_MCS2					BIT14
+#define	RRSR_MCS3					BIT15
+#define	RRSR_MCS4					BIT16
+#define	RRSR_MCS5					BIT17
+#define	RRSR_MCS6					BIT18
+#define	RRSR_MCS7					BIT19
+#define	BRSR_AckShortPmb			BIT23	
+// CCK ACK: use Short Preamble or not
+
+
+//----------------------------------------------------------------------------
+//       8192C Rate Definition
+//----------------------------------------------------------------------------
+//CCK
+#define	RATR_1M						0x00000001
+#define	RATR_2M						0x00000002
+#define	RATR_55M					0x00000004
+#define	RATR_11M					0x00000008
+//OFDM 		
+#define	RATR_6M						0x00000010
+#define	RATR_9M						0x00000020
+#define	RATR_12M					0x00000040
+#define	RATR_18M					0x00000080
+#define	RATR_24M					0x00000100
+#define	RATR_36M					0x00000200
+#define	RATR_48M					0x00000400
+#define	RATR_54M					0x00000800
+//MCS 1 Spatial Stream	
+#define	RATR_MCS0					0x00001000
+#define	RATR_MCS1					0x00002000
+#define	RATR_MCS2					0x00004000
+#define	RATR_MCS3					0x00008000
+#define	RATR_MCS4					0x00010000
+#define	RATR_MCS5					0x00020000
+#define	RATR_MCS6					0x00040000
+#define	RATR_MCS7					0x00080000
+//MCS 2 Spatial Stream
+#define	RATR_MCS8					0x00100000
+#define	RATR_MCS9					0x00200000
+#define	RATR_MCS10					0x00400000
+#define	RATR_MCS11					0x00800000
+#define	RATR_MCS12					0x01000000
+#define	RATR_MCS13					0x02000000
+#define	RATR_MCS14					0x04000000
+#define	RATR_MCS15					0x08000000
+
+
+// NOTE: For 92CU - Ziv
+//CCK
+#define RATE_1M						BIT(0)
+#define RATE_2M						BIT(1)
+#define RATE_5_5M					BIT(2)
+#define RATE_11M					BIT(3)
+//OFDM 
+#define RATE_6M						BIT(4)
+#define RATE_9M						BIT(5)
+#define RATE_12M					BIT(6)
+#define RATE_18M					BIT(7)
+#define RATE_24M					BIT(8)
+#define RATE_36M					BIT(9)
+#define RATE_48M					BIT(10)
+#define RATE_54M					BIT(11)
+//MCS 1 Spatial Stream
+#define RATE_MCS0					BIT(12)
+#define RATE_MCS1					BIT(13)
+#define RATE_MCS2					BIT(14)
+#define RATE_MCS3					BIT(15)
+#define RATE_MCS4					BIT(16)
+#define RATE_MCS5					BIT(17)
+#define RATE_MCS6					BIT(18)
+#define RATE_MCS7					BIT(19)
+//MCS 2 Spatial Stream
+#define RATE_MCS8					BIT(20)
+#define RATE_MCS9					BIT(21)
+#define RATE_MCS10					BIT(22)
+#define RATE_MCS11					BIT(23)
+#define RATE_MCS12					BIT(24)
+#define RATE_MCS13					BIT(25)
+#define RATE_MCS14					BIT(26)
+#define RATE_MCS15					BIT(27)
+
+
+
+
+// ALL CCK Rate
+#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M 
+#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
+									RATR_36M|RATR_48M|RATR_54M	
+#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
+									RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7	
+#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
+									RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
+
+//----------------------------------------------------------------------------
+//       8192C BW_OPMODE bits					(Offset 0x203, 8bit)
+//----------------------------------------------------------------------------
+#define	BW_OPMODE_20MHZ				BIT2
+#define	BW_OPMODE_5G				BIT1
+#define	BW_OPMODE_11J				BIT0
+
+
+//----------------------------------------------------------------------------
+//       8192C CAM Config Setting (offset 0x250, 1 byte)
+//----------------------------------------------------------------------------
+#define	CAM_VALID					BIT15
+#define	CAM_NOTVALID				0x0000
+#define	CAM_USEDK					BIT5
+
+#define	CAM_CONTENT_COUNT 			8
+       	       		
+#define	CAM_NONE					0x0
+#define	CAM_WEP40					0x01
+#define	CAM_TKIP					0x02
+#define	CAM_AES						0x04
+#define	CAM_WEP104					0x05
+        		
+#define	TOTAL_CAM_ENTRY				32
+#define	HALF_CAM_ENTRY				16	
+       		
+#define	CAM_CONFIG_USEDK			_TRUE
+#define	CAM_CONFIG_NO_USEDK			_FALSE
+       		
+#define	CAM_WRITE					BIT16
+#define	CAM_READ					0x00000000
+#define	CAM_POLLINIG				BIT31
+
+#define	SCR_UseDK					0x01
+#define	SCR_TxSecEnable				0x02
+#define	SCR_RxSecEnable				0x04
+
+
+//
+// 12. Host Interrupt Status Registers	 (Offset: 0x0300 - 0x030F)
+//
+//----------------------------------------------------------------------------
+//       8190 IMR/ISR bits						(offset 0xfd,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR8190_DISABLED			0x0
+// IMR DW0 Bit 0-31
+#define	IMR_BCNDMAINT6				BIT31		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5				BIT30		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4				BIT29		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3				BIT28		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2				BIT27		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1				BIT26		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK8					BIT25		// Beacon Queue DMA OK Interrup 8
+#define	IMR_BCNDOK7					BIT24		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6					BIT23		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5					BIT22		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4					BIT21		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3					BIT20		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2					BIT19		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1					BIT18		// Beacon Queue DMA OK Interrup 1
+#define	IMR_TIMEOUT2				BIT17		// Timeout interrupt 2
+#define	IMR_TIMEOUT1				BIT16		// Timeout interrupt 1
+#define	IMR_TXFOVW					BIT15		// Transmit FIFO Overflow
+#define	IMR_PSTIMEOUT				BIT14		// Power save time out interrupt 
+#define	IMR_BcnInt					BIT13		// Beacon DMA Interrupt 0
+#define	IMR_RXFOVW					BIT12		// Receive FIFO Overflow
+#define	IMR_RDU						BIT11		// Receive Descriptor Unavailable
+#define	IMR_ATIMEND					BIT10		// For 92C,ATIM Window End Interrupt
+#define	IMR_BDOK					BIT9		// Beacon Queue DMA OK Interrup
+#define	IMR_HIGHDOK					BIT8		// High Queue DMA OK Interrupt
+#define	IMR_TBDOK					BIT7		// Transmit Beacon OK interrup
+#define	IMR_MGNTDOK					BIT6		// Management Queue DMA OK Interrupt
+#define	IMR_TBDER					BIT5		// For 92C,Transmit Beacon Error Interrupt
+#define	IMR_BKDOK					BIT4		// AC_BK DMA OK Interrupt
+#define	IMR_BEDOK					BIT3		// AC_BE DMA OK Interrupt
+#define	IMR_VIDOK					BIT2		// AC_VI DMA OK Interrupt
+#define	IMR_VODOK					BIT1		// AC_VO DMA Interrupt
+#define	IMR_ROK						BIT0		// Receive DMA OK Interrupt
+
+// 13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh)
+#define	IMR_TXERR				BIT11
+#define	IMR_RXERR				BIT10
+#define	IMR_C2HCMD				BIT9
+#define	IMR_CPWM				BIT8
+//RSVD [2-7]
+#define	IMR_OCPINT				BIT1
+#define	IMR_WLANOFF			BIT0
+
+
+
+//----------------------------------------------------------------------------
+// 8192C EFUSE
+//----------------------------------------------------------------------------
+#define	HWSET_MAX_SIZE				128
+
+
+//----------------------------------------------------------------------------
+//       8192C EEPROM/EFUSE share register definition.
+//----------------------------------------------------------------------------
+
+//
+// Default Value for EEPROM or EFUSE!!!
+//
+#define	EEPROM_Default_TSSI					0x0
+#define EEPROM_Default_TxPowerDiff			0x0
+#define EEPROM_Default_CrystalCap			0x5
+#define EEPROM_Default_BoardType			0x02 // Default: 2X2, RTL8192CE(QFPN68)
+#define EEPROM_Default_TxPower				0x1010
+#define	EEPROM_Default_HT2T_TxPwr			0x10
+
+#define	EEPROM_Default_LegacyHTTxPowerDiff	0x3
+#define	EEPROM_Default_ThermalMeter			0x12
+
+#define	EEPROM_Default_AntTxPowerDiff		0x0
+#define	EEPROM_Default_TxPwDiff_CrystalCap	0x5
+#define	EEPROM_Default_TxPowerLevel			0x22
+#define	EEPROM_Default_HT40_2SDiff			0x0
+#define EEPROM_Default_HT20_Diff			2	// HT20<->40 default Tx Power Index Difference
+#define	EEPROM_Default_LegacyHTTxPowerDiff	0x3
+#define EEPROM_Default_HT40_PwrMaxOffset	0
+#define EEPROM_Default_HT20_PwrMaxOffset	0
+
+// For debug
+#define EEPROM_Default_PID					0x1234
+#define EEPROM_Default_VID					0x5678
+#define EEPROM_Default_CustomerID			0xAB
+#define EEPROM_Default_SubCustomerID		0xCD
+#define EEPROM_Default_Version				0
+
+#define	EEPROM_CHANNEL_PLAN_FCC				0x0
+#define	EEPROM_CHANNEL_PLAN_IC				0x1
+#define	EEPROM_CHANNEL_PLAN_ETSI			0x2
+#define	EEPROM_CHANNEL_PLAN_SPAIN			0x3
+#define	EEPROM_CHANNEL_PLAN_FRANCE			0x4
+#define	EEPROM_CHANNEL_PLAN_MKK				0x5
+#define	EEPROM_CHANNEL_PLAN_MKK1			0x6
+#define	EEPROM_CHANNEL_PLAN_ISRAEL			0x7
+#define	EEPROM_CHANNEL_PLAN_TELEC			0x8
+#define	EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN	0x9
+#define	EEPROM_CHANNEL_PLAN_WORLD_WIDE_13	0xA
+#define	EEPROM_CHANNEL_PLAN_NCC				0xB
+#define	EEPROM_CHANNEL_PLAN_BY_HW_MASK		0x80
+
+
+#define EEPROM_CID_DEFAULT					0x0
+#define EEPROM_CID_TOSHIBA					0x4
+#define	EEPROM_CID_CCX						0x10 // CCX test. By Bruce, 2009-02-25.
+#define	EEPROM_CID_QMI						0x0D
+#define EEPROM_CID_WHQL 					0xFE // added by chiyoko for dtm, 20090108
+
+
+#define	RTL8192_EEPROM_ID					0x8129
+
+
+#ifdef CONFIG_PCIE_HCI
+#define RTL8190_EEPROM_ID					0x8129	// 0-1
+#define EEPROM_HPON							0x02 // LDO settings.2-5
+#define EEPROM_CLK							0x06 // Clock settings.6-7
+#define EEPROM_TESTR						0x08 // SE Test mode.8
+
+#define EEPROM_VID							0x0A // SE Vendor ID.A-B
+#define EEPROM_DID							0x0C // SE Device ID. C-D
+#define EEPROM_SVID							0x0E // SE Vendor ID.E-F
+#define EEPROM_SMID							0x10 // SE PCI Subsystem ID. 10-11
+
+#define EEPROM_MAC_ADDR						0x16 // SEMAC Address. 12-17
+
+//----------------------------------------------------------------
+// Ziv - Let PCIe and USB use the same define. Modify address mapping later.
+#define EEPROM_CCK_TX_PWR_INX				0x5A
+#define EEPROM_HT40_1S_TX_PWR_INX			0x60
+#define EEPROM_HT40_2S_TX_PWR_INX_DIFF		0x66
+#define EEPROM_HT20_TX_PWR_INX_DIFF			0x69
+#define EEPROM_OFDM_TX_PWR_INX_DIFF			0x6C
+#define EEPROM_HT40_MAX_PWR_OFFSET			0x6F
+#define EEPROM_HT20_MAX_PWR_OFFSET			0x72
+
+#define EEPROM_XTAL_K						0x75
+#define EEPROM_TSSI_A						0x76
+#define EEPROM_TSSI_B						0x77
+#define EEPROM_THERMAL_METER				0x78
+#define EEPROM_RF_OPT1						0x79
+#define EEPROM_RF_OPT2						0x7A
+#define EEPROM_RF_OPT3						0x7B
+#define EEPROM_RF_OPT4						0x7C
+#define EEPROM_CHANNEL_PLAN					0x7D
+#define EEPROM_VERSION						0x7E
+#define EEPROM_CUSTOMER_ID					0x7F
+
+#define	EEPROM_NORMAL_BoardType					EEPROM_RF_OPT1	//[7:5]
+//----------------------------------------------------------------
+
+
+#define EEPROM_PwDiff				0x54 // Difference of gain index between legacy and high throughput OFDM.
+
+#define EEPROM_TxPowerCCK			0x5A // CCK Tx Power base
+#define	EEPROM_TxPowerHT40_1S		0x60 // HT40 Tx Power base
+#define	EEPROM_TxPowerHT40_2SDiff	0x66 // HT40 Tx Power diff
+#define EEPROM_TxPowerHT20Diff		0x69// HT20 Tx Power diff
+#define EEPROM_TxPowerOFDMDiff		0x6C// OFDM Tx Power diff
+
+
+#define	EEPROM_TxPWRGroup			0x6F// Power diff for channel group
+
+//
+#define EEPROM_TSSI_A				0x76 //TSSI value of path A.
+#define EEPROM_TSSI_B				0x77 //TSSI value of path B.
+#define EEPROM_ThermalMeter			0x78 // Thermal meter default value.
+
+#define EEPROM_ChannelPlan				0x75 // Map of supported channels.	
+
+#define RF_OPTION1						0x79// Check if power safety spec is need
+#define RF_OPTION2						0x7A
+#define RF_OPTION3						0x7B
+#define RF_OPTION4						0x7C
+
+#define EEPROM_Version					0x7E // The EEPROM content version
+#define EEPROM_CustomID				0x7F
+
+#endif 
+
+#ifdef CONFIG_USB_HCI
+
+//should be renamed and moved to another file
+typedef	enum _BOARD_TYPE_8192CUSB{
+	BOARD_USB_DONGLE 			= 0,		// USB dongle
+	BOARD_USB_High_PA 			= 1,		// USB dongle with high power PA
+	BOARD_MINICARD		  	= 2,		// Minicard
+	BOARD_USB_SOLO 		 	= 3,		// USB solo-Slim module
+	BOARD_USB_COMBO			= 4,		// USB Combo-Slim module
+} BOARD_TYPE_8192CUSB, *PBOARD_TYPE_8192CUSB;
+
+#define	SUPPORT_HW_RADIO_DETECT(Adapter) 	((BOARD_MINICARD == Adapter->halpriv.BoardType )||	(BOARD_USB_SOLO == Adapter->halpriv.BoardType)||(BOARD_USB_COMBO == Adapter->halpriv.BoardType))
+
+//---------------------------------------------------------------
+// EEPROM address for Test chip
+//---------------------------------------------------------------
+#define EEPROM_TEST_USB_OPT						0x0E
+#define EEPROM_TEST_CHIRP_K						0x0F
+#define EEPROM_TEST_EP_SETTING					0x0E
+#define EEPROM_TEST_USB_PHY						0x10
+
+
+//---------------------------------------------------------------
+// EEPROM address for Normal chip
+//---------------------------------------------------------------
+#define EEPROM_NORMAL_USB_OPT					0x0E
+#define EEPROM_NORMAL_CHIRP_K					0x0E	// Changed
+#define EEPROM_NORMAL_EP_SETTING				0x0F	// Changed
+#define EEPROM_NORMAL_USB_PHY					0x12	// Changed
+
+
+// Test chip and normal chip common define
+//---------------------------------------------------------------
+// EEPROM address for both
+//---------------------------------------------------------------
+#define	EEPROM_ID0								0x00
+#define	EEPROM_ID1								0x01
+#define EEPROM_RTK_RSV1							0x02
+#define EEPROM_RTK_RSV2							0x03
+#define EEPROM_RTK_RSV3							0x04
+#define EEPROM_RTK_RSV4							0x05
+#define EEPROM_RTK_RSV5							0x06
+#define EEPROM_DBG_SEL							0x07
+#define EEPROM_RTK_RSV6							0x08
+#define EEPROM_VID								0x0A
+#define EEPROM_PID								0x0C
+
+#define EEPROM_MAC_ADDR							0x16
+#define EEPROM_STRING							0x1C
+#define EEPROM_SUBCUSTOMER_ID					0x59
+#define EEPROM_CCK_TX_PWR_INX					0x5A
+#define EEPROM_HT40_1S_TX_PWR_INX				0x60
+#define EEPROM_HT40_2S_TX_PWR_INX_DIFF			0x66
+#define EEPROM_HT20_TX_PWR_INX_DIFF				0x69
+#define EEPROM_OFDM_TX_PWR_INX_DIFF				0x6C
+#define EEPROM_HT40_MAX_PWR_OFFSET				0x6F
+#define EEPROM_HT20_MAX_PWR_OFFSET				0x72
+
+#define EEPROM_XTAL_K							0x75
+#define EEPROM_TSSI_A							0x76
+#define EEPROM_TSSI_B							0x77
+#define EEPROM_THERMAL_METER					0x78
+
+#define EEPROM_RF_OPT1							0x79
+#define EEPROM_RF_OPT2							0x7A
+#define EEPROM_RF_OPT3							0x7B
+#define EEPROM_RF_OPT4							0x7C
+
+#define EEPROM_CHANNEL_PLAN						0x7D
+#define EEPROM_VERSION							0x7E
+#define EEPROM_CUSTOMER_ID						0x7F
+
+#define	EEPROM_BoardType						0x54 //0x0: RTL8188SU, 0x1: RTL8191SU, 0x2: RTL8192SU, 0x3: RTL8191GU
+#define	EEPROM_TxPwIndex						0x5C //0x5C-0x76, Tx Power index.
+#define	EEPROM_PwDiff							0x67 // Difference of gain index between legacy and high throughput OFDM.
+
+#define	EEPROM_TxPowerCCK						0x5A // CCK Tx Power
+
+// 2009/02/09 Cosa Add for SD3 requirement 
+#define	EEPROM_TX_PWR_HT20_DIFF					0x6e// HT20 Tx Power Index Difference
+#define	DEFAULT_HT20_TXPWR_DIFF					2	// HT20<->40 default Tx Power Index Difference
+#define	EEPROM_TX_PWR_OFDM_DIFF					0x71// OFDM Tx Power Index Difference
+
+#define	EEPROM_TxPWRGroup						0x73// Power diff for channel group
+#define EEPROM_Regulatory						0x79// Check if power safety is need
+
+#define	EEPROM_BLUETOOTH_COEXIST				0x7E // 92cu, 0x7E[4]
+#define	EEPROM_NORMAL_BoardType					EEPROM_RF_OPT1	//[7:5]
+#define BOARD_TYPE_NORMAL_MASK					0xE0
+#define BOARD_TYPE_TEST_MASK					0x0F
+#define EEPROM_EASY_REPLACEMENT				0x50//BIT0 1 for build-in module, 0 for external dongle
+//-------------------------------------------------------------
+//	EEPROM content definitions
+//-------------------------------------------------------------
+#define OS_LINK_SPEED							BIT(5)
+
+#define BOARD_TYPE_MASK							0xF
+
+#define BT_COEXISTENCE							BIT(4)
+#define BT_CO_SHIFT								4
+
+#define EP_NUMBER_MASK							0x30	//bit 4:5 0Eh
+#define EP_NUMBER_SHIFT							4
+
+
+#define USB_PHY_PARA_SIZE						5
+
+
+//-------------------------------------------------------------
+//	EEPROM default value definitions
+//-------------------------------------------------------------
+// Use 0xABCD instead of 0x8192 for debug
+#define	EEPROM_DEF_ID_0							0xCD	// Byte 0x00
+#define	EEPROM_DEF_ID_1							0xAB	// Byte 0x01
+
+#define EEPROM_DEF_RTK_RSV_A3					0x74	// Byte 0x03
+#define EEPROM_DEF_RTK_RSV_A4					0x6D	// Byte 0x04
+#define EEPROM_DEF_RTK_RSV_A8					0xFF	// Byte 0x08
+
+#define EEPROM_DEF_VID_0						0x0A	// Byte 0x0A
+#define EEPROM_DEF_VID_1						0x0B
+
+#define EEPROM_DEF_PID_0						0x92	// Byte 0x0C
+#define EEPROM_DEF_PID_1						0x81
+
+
+#define EEPROM_TEST_DEF_USB_OPT					0x80	// Byte 0x0E
+#define EEPROM_NORMAL_DEF_USB_OPT				0x00	// Byte 0x0E
+
+#define EEPROM_DEF_CHIRPK						0x15	// Byte 0x0F
+
+#define EEPROM_DEF_USB_PHY_0					0x85	// Byte 0x10
+#define EEPROM_DEF_USB_PHY_1					0x62	// Byte 0x11
+#define EEPROM_DEF_USB_PHY_2					0x9E	// Byte 0x12
+#define EEPROM_DEF_USB_PHY_3					0x06	// Byte 0x13
+
+#define EEPROM_DEF_TSSI_A						0x09	// Byte 0x78
+#define EEPROM_DEF_TSSI_B						0x09	// Byte 0x79
+
+
+#define EEPROM_DEF_THERMAL_METER				0x12	// Byte 0x7A
+
+
+#define	EEPROM_USB_SN							BIT(0)
+#define	EEPROM_USB_REMOTE_WAKEUP				BIT(1)
+#define	EEPROM_USB_DEVICE_PWR					BIT(2)
+#define	EEPROM_EP_NUMBER						(BIT(3)|BIT(4))
+
+#if 0
+#define	EEPROM_CHANNEL_PLAN_FCC					0x0
+#define	EEPROM_CHANNEL_PLAN_IC					0x1
+#define	EEPROM_CHANNEL_PLAN_ETSI				0x2
+#define	EEPROM_CHANNEL_PLAN_SPAIN				0x3
+#define	EEPROM_CHANNEL_PLAN_FRANCE				0x4
+#define	EEPROM_CHANNEL_PLAN_MKK					0x5
+#define	EEPROM_CHANNEL_PLAN_MKK1				0x6
+#define	EEPROM_CHANNEL_PLAN_ISRAEL				0x7
+#define	EEPROM_CHANNEL_PLAN_TELEC				0x8
+#define	EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN		0x9
+#define	EEPROM_CHANNEL_PLAN_WORLD_WIDE_13		0xA
+#define	EEPROM_CHANNEL_PLAN_BY_HW_MASK			0x80
+
+#define	EEPROM_CID_DEFAULT						0x0
+
+#define	EEPROM_CID_WHQL 						0xFE // added by chiyoko for dtm, 20090108
+
+
+#define	EEPROM_CID_CCX							0x10 // CCX test. By Bruce, 2009-02-25.
+#endif
+
+#endif
+
+
+/*===================================================================
+=====================================================================
+Here the register defines are for 92C. When the define is as same with 92C, 
+we will use the 92C's define for the consistency
+So the following defines for 92C is not entire!!!!!!
+=====================================================================
+=====================================================================*/
+/*
+Based on Datasheet V33---090401
+Register Summary
+Current IOREG MAP
+0x0000h ~ 0x00FFh   System Configuration (256 Bytes)
+0x0100h ~ 0x01FFh   MACTOP General Configuration (256 Bytes)
+0x0200h ~ 0x027Fh   TXDMA Configuration (128 Bytes)
+0x0280h ~ 0x02FFh   RXDMA Configuration (128 Bytes)
+0x0300h ~ 0x03FFh   PCIE EMAC Reserved Region (256 Bytes)
+0x0400h ~ 0x04FFh   Protocol Configuration (256 Bytes)
+0x0500h ~ 0x05FFh   EDCA Configuration (256 Bytes)
+0x0600h ~ 0x07FFh   WMAC Configuration (512 Bytes)
+0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
+*/
+
+//----------------------------------------------------------------------------
+//       8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits)
+//----------------------------------------------------------------------------
+#define	RCR_APPFCS					BIT31		//WMAC append FCS after pauload
+#define	RCR_APP_MIC					BIT30
+#define	RCR_APP_PHYSTS				BIT28//
+#define	RCR_APP_ICV					BIT29       //
+#define	RCR_APP_PHYST_RXFF			BIT28       //
+#define	RCR_APP_BA_SSN				BIT27		//Accept BA SSN
+#define	RCR_ENMBID					BIT24		//Enable Multiple BssId.
+#define	RCR_LSIGEN					BIT23
+#define	RCR_MFBEN					BIT22
+#define	RCR_HTC_LOC_CTRL			BIT14       //MFC<--HTC=1 MFC-->HTC=0
+#define	RCR_AMF						BIT13		//Accept management type frame
+#define	RCR_ACF						BIT12		//Accept control type frame
+#define	RCR_ADF						BIT11		//Accept data type frame
+#define	RCR_AICV					BIT9		//Accept ICV error packet
+#define	RCR_ACRC32					BIT8		//Accept CRC32 error packet 
+#define	RCR_CBSSID_BCN				BIT7		//Accept BSSID match packet (Rx beacon, probe rsp)
+#define	RCR_CBSSID_DATA			BIT6		//Accept BSSID match packet (Data)
+#define	RCR_CBSSID					RCR_CBSSID_DATA		//Accept BSSID match packet
+#define	RCR_APWRMGT					BIT5		//Accept power management packet
+#define	RCR_ADD3					BIT4		//Accept address 3 match packet
+#define	RCR_AB						BIT3		//Accept broadcast packet 
+#define	RCR_AM						BIT2		//Accept multicast packet 
+#define	RCR_APM						BIT1		//Accept physical match packet
+#define	RCR_AAP						BIT0		//Accept all unicast packet 
+#define	RCR_MXDMA_OFFSET			8
+#define	RCR_FIFO_OFFSET				13
+
+
+
+//============================================================================
+//       8192c USB specific Regsiter Offset and Content definition, 
+//       2009.08.18, added by vivi. for merge 92c and 92C into one driver
+//============================================================================
+//#define APS_FSMCO				0x0004  same with 92Ce
+#define RSV_CTRL					0x001C
+#define RD_CTRL						0x0524
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+#define REG_USB_INFO				0xFE17
+#define REG_USB_SPECIAL_OPTION		0xFE55
+#define REG_USB_DMA_AGG_TO			0xFE5B
+#define REG_USB_AGG_TO				0xFE5C
+#define REG_USB_AGG_TH				0xFE5D
+
+#define REG_USB_VID					0xFE60
+#define REG_USB_PID					0xFE62
+#define REG_USB_OPTIONAL			0xFE64
+#define REG_USB_CHIRP_K				0xFE65
+#define REG_USB_PHY					0xFE66
+#define REG_USB_MAC_ADDR			0xFE70
+
+#define REG_USB_HRPWM				0xFE58
+#define REG_USB_HCPWM				0xFE57
+
+#define	InvalidBBRFValue			0x12345678
+
+//============================================================================
+//       8192C Regsiter Bit and Content definition 
+//============================================================================
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+
+//2 SPS0_CTRL
+#define SW18_FPWM					BIT(3)
+
+
+//2 SYS_ISO_CTRL
+#define ISO_MD2PP					BIT(0)
+#define ISO_UA2USB					BIT(1)
+#define ISO_UD2CORE					BIT(2)
+#define ISO_PA2PCIE					BIT(3)
+#define ISO_PD2CORE					BIT(4)
+#define ISO_IP2MAC					BIT(5)
+#define ISO_DIOP					BIT(6)
+#define ISO_DIOE					BIT(7)
+#define ISO_EB2CORE					BIT(8)
+#define ISO_DIOR					BIT(9)
+
+#define PWC_EV25V					BIT(14)
+#define PWC_EV12V					BIT(15)
+
+
+//2 SYS_FUNC_EN
+#define FEN_BBRSTB					BIT(0)
+#define FEN_BB_GLB_RSTn				BIT(1)
+#define FEN_USBA					BIT(2)
+#define FEN_UPLL					BIT(3)
+#define FEN_USBD					BIT(4)
+#define FEN_DIO_PCIE				BIT(5)
+#define FEN_PCIEA					BIT(6)
+#define FEN_PPLL					BIT(7)
+#define FEN_PCIED					BIT(8)
+#define FEN_DIOE					BIT(9)
+#define FEN_CPUEN					BIT(10)
+#define FEN_DCORE					BIT(11)
+#define FEN_ELDR					BIT(12)
+#define FEN_DIO_RF					BIT(13)
+#define FEN_HWPDN					BIT(14)
+#define FEN_MREGEN					BIT(15)
+
+//2 APS_FSMCO
+#define PFM_LDALL					BIT(0)
+#define PFM_ALDN					BIT(1)
+#define PFM_LDKP					BIT(2)
+#define PFM_WOWL					BIT(3)
+#define EnPDN						BIT(4)
+#define PDN_PL						BIT(5)
+#define APFM_ONMAC					BIT(8)
+#define APFM_OFF					BIT(9)
+#define APFM_RSM					BIT(10)
+#define AFSM_HSUS					BIT(11)
+#define AFSM_PCIE					BIT(12)
+#define APDM_MAC					BIT(13)
+#define APDM_HOST					BIT(14)
+#define APDM_HPDN					BIT(15)
+#define RDY_MACON					BIT(16)
+#define SUS_HOST					BIT(17)
+#define ROP_ALD						BIT(20)
+#define ROP_PWR						BIT(21)
+#define ROP_SPS						BIT(22)
+#define SOP_MRST					BIT(25)
+#define SOP_FUSE					BIT(26)
+#define SOP_ABG						BIT(27)
+#define SOP_AMB						BIT(28)
+#define SOP_RCK						BIT(29)
+#define SOP_A8M						BIT(30)
+#define XOP_BTCK					BIT(31)
+
+//2 SYS_CLKR
+#define ANAD16V_EN					BIT(0)
+#define ANA8M						BIT(1)
+#define MACSLP						BIT(4)
+#define LOADER_CLK_EN				BIT(5)
+#define _80M_SSC_DIS				BIT(7)
+#define _80M_SSC_EN_HO				BIT(8)
+#define PHY_SSC_RSTB				BIT(9)
+#define SEC_CLK_EN					BIT(10)
+#define MAC_CLK_EN					BIT(11)
+#define SYS_CLK_EN					BIT(12)
+#define RING_CLK_EN					BIT(13)
+
+
+//2 9346CR
+
+
+#define 	EEDO					BIT(0)
+#define 	EEDI					BIT(1)
+#define 	EESK					BIT(2)
+#define 	EECS					BIT(3)
+//#define 	EERPROMSEL			BIT(4)
+//#define 	EEPROM_EN			BIT(5)
+#define	BOOT_FROM_EEPROM		BIT(4)
+#define	EEPROM_EN				BIT(5)
+#define 	EEM0					BIT(6)
+#define 	EEM1					BIT(7)
+
+
+//2 AFE_MISC
+#define AFE_BGEN					BIT(0)
+#define AFE_MBEN					BIT(1)
+#define MAC_ID_EN					BIT(7)
+
+
+//2 SPS0_CTRL
+
+
+//2 SPS_OCP_CFG
+
+
+//2 RSV_CTRL
+#define WLOCK_ALL					BIT(0)
+#define WLOCK_00					BIT(1)
+#define WLOCK_04					BIT(2)
+#define WLOCK_08					BIT(3)
+#define WLOCK_40					BIT(4)
+#define R_DIS_PRST_0				BIT(5)
+#define R_DIS_PRST_1				BIT(6)
+#define LOCK_ALL_EN					BIT(7)
+
+//2 RF_CTRL
+#define RF_EN						BIT(0)
+#define RF_RSTB						BIT(1)
+#define RF_SDMRSTB					BIT(2)
+
+
+
+//2 LDOA15_CTRL
+#define LDA15_EN					BIT(0)
+#define LDA15_STBY					BIT(1)
+#define LDA15_OBUF					BIT(2)
+#define LDA15_REG_VOS				BIT(3)
+#define _LDA15_VOADJ(x)				(((x) & 0x7) << 4)
+
+
+
+//2 LDOV12D_CTRL
+#define LDV12_EN					BIT(0)
+#define LDV12_SDBY					BIT(1)
+#define LPLDO_HSM					BIT(2)
+#define LPLDO_LSM_DIS				BIT(3)
+#define _LDV12_VADJ(x)				(((x) & 0xF) << 4)
+
+
+//2 AFE_XTAL_CTRL
+#define XTAL_EN						BIT(0)
+#define XTAL_BSEL					BIT(1)
+#define _XTAL_BOSC(x)				(((x) & 0x3) << 2)
+#define _XTAL_CADJ(x)				(((x) & 0xF) << 4)
+#define XTAL_GATE_USB				BIT(8)
+#define _XTAL_USB_DRV(x)			(((x) & 0x3) << 9)
+#define XTAL_GATE_AFE				BIT(11)
+#define _XTAL_AFE_DRV(x)			(((x) & 0x3) << 12)
+#define XTAL_RF_GATE				BIT(14)
+#define _XTAL_RF_DRV(x)				(((x) & 0x3) << 15)
+#define XTAL_GATE_DIG				BIT(17)
+#define _XTAL_DIG_DRV(x)			(((x) & 0x3) << 18)
+#define XTAL_BT_GATE				BIT(20)
+#define _XTAL_BT_DRV(x)				(((x) & 0x3) << 21)
+#define _XTAL_GPIO(x)				(((x) & 0x7) << 23)
+
+
+#define CKDLY_AFE					BIT(26)
+#define CKDLY_USB					BIT(27)
+#define CKDLY_DIG					BIT(28)
+#define CKDLY_BT					BIT(29)
+
+
+//2 AFE_PLL_CTRL
+#define APLL_EN						BIT(0)
+#define APLL_320_EN					BIT(1)
+#define APLL_FREF_SEL				BIT(2)
+#define APLL_EDGE_SEL				BIT(3)
+#define APLL_WDOGB					BIT(4)
+#define APLL_LPFEN					BIT(5)
+
+#define APLL_REF_CLK_13MHZ			0x1
+#define APLL_REF_CLK_19_2MHZ		0x2
+#define APLL_REF_CLK_20MHZ			0x3
+#define APLL_REF_CLK_25MHZ			0x4
+#define APLL_REF_CLK_26MHZ			0x5
+#define APLL_REF_CLK_38_4MHZ		0x6
+#define APLL_REF_CLK_40MHZ			0x7
+
+#define APLL_320EN					BIT(14)
+#define APLL_80EN					BIT(15)
+#define APLL_1MEN					BIT(24)
+
+
+//2 EFUSE_CTRL
+#define ALD_EN						BIT(18)
+#define EF_PD						BIT(19)
+#define EF_FLAG						BIT(31)
+
+//2 EFUSE_TEST 
+#define EF_TRPT						BIT(7)
+#define LDOE25_EN					BIT(31)
+
+//2 PWR_DATA 
+
+//2 CAL_TIMER
+
+//2 ACLK_MON
+#define RSM_EN						BIT(0)
+#define Timer_EN					BIT(4)
+
+
+//2 GPIO_MUXCFG
+#define TRSW0EN						BIT(2)
+#define TRSW1EN						BIT(3)
+#define EROM_EN						BIT(4)
+#define EnBT						BIT(5)
+#define EnUart						BIT(8)
+#define Uart_910					BIT(9)
+#define EnPMAC						BIT(10)
+#define SIC_SWRST					BIT(11)
+#define EnSIC						BIT(12)
+#define SIC_23						BIT(13)
+#define EnHDP						BIT(14)
+#define SIC_LBK						BIT(15)
+
+//2 GPIO_PIN_CTRL
+
+// GPIO BIT
+#define	HAL_8192C_HW_GPIO_WPS_BIT		BIT(2)
+
+//2 GPIO_INTM
+
+//2 LEDCFG
+#define LED0PL 						BIT(4)  
+#define LED0DIS						BIT(7)
+#define LED1DIS						BIT(15)
+#define LED1PL 						BIT(12)
+
+#define  SECCAM_CLR					BIT(30)
+
+
+//2 FSIMR
+
+//2 FSISR
+
+
+//2 8051FWDL
+//2 MCUFWDL
+#define MCUFWDL_EN					BIT(0)
+#define MCUFWDL_RDY					BIT(1)
+#define FWDL_ChkSum_rpt				BIT(2)
+#define MACINI_RDY					BIT(3)
+#define BBINI_RDY					BIT(4)
+#define RFINI_RDY					BIT(5)
+#define WINTINI_RDY					BIT(6)
+#define CPRST						BIT(23)
+
+
+
+
+//2 REG_SYS_CFG
+#define XCLK_VLD					BIT(0)
+#define ACLK_VLD					BIT(1)
+#define UCLK_VLD					BIT(2)
+#define PCLK_VLD					BIT(3)
+#define PCIRSTB						BIT(4)
+#define V15_VLD						BIT(5)
+#define TRP_B15V_EN					BIT(7)
+#define SIC_IDLE						BIT(8)
+#define BD_MAC2						BIT(9)
+#define BD_MAC1						BIT(10)
+#define IC_MACPHY_MODE			BIT(11)
+#define BT_FUNC						BIT(16)
+#define VENDOR_ID					BIT(19)
+#define PAD_HWPD_IDN				BIT(22)
+#define TRP_VAUX_EN					BIT(23)
+#define TRP_BT_EN					BIT(24)
+#define BD_PKG_SEL					BIT(25)
+#define BD_HCI_SEL					BIT(26)
+#define TYPE_ID						BIT(27)
+
+
+#define CHIP_VER_RTL_MASK			0xF000	//Bit 12 ~ 15
+#define CHIP_VER_RTL_SHIFT			12
+
+//REG_GPIO_OUTSTS (For RTL8723 only)
+#define	EFS_HCI_SEL				(BIT(0)|BIT(1))
+#define	PAD_HCI_SEL				(BIT(2)|BIT(3))
+#define	HCI_SEL						(BIT(4)|BIT(5)) 
+#define	PKG_SEL_HCI				BIT(6)
+#define	FEN_GPS					BIT(7)
+#define	FEN_BT						BIT(8)
+#define	FEN_WL						BIT(9)
+#define	FEN_PCI						BIT(10)
+#define	FEN_USB					BIT(11)
+#define	BTRF_HWPDN_N				BIT(12)
+#define	WLRF_HWPDN_N				BIT(13)
+#define	PDN_BT_N					BIT(14)
+#define	PDN_GPS_N					BIT(15)
+#define	BT_CTL_HWPDN				BIT(16)
+#define	GPS_CTL_HWPDN				BIT(17)
+#define	PPHY_SUSB					BIT(20)
+#define	UPHY_SUSB					BIT(21)
+#define	PCI_SUSEN					BIT(22)
+#define	USB_SUSEN					BIT(23)
+#define	RF_RL_ID					(BIT(31)|BIT(30)|BIT(29)|BIT(28))
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+
+
+//2 Function Enable Registers
+//2 CR
+
+#define REG_LBMODE					(REG_CR + 3)
+
+
+#define HCI_TXDMA_EN				BIT(0)
+#define HCI_RXDMA_EN				BIT(1)
+#define TXDMA_EN					BIT(2)
+#define RXDMA_EN					BIT(3)
+#define PROTOCOL_EN					BIT(4)
+#define SCHEDULE_EN					BIT(5)
+#define MACTXEN						BIT(6)
+#define MACRXEN						BIT(7)
+#define ENSWBCN						BIT(8)
+#define ENSEC						BIT(9)
+
+// Network type
+#define _NETTYPE(x)					(((x) & 0x3) << 16)
+#define MASK_NETTYPE				0x30000
+#define NT_NO_LINK					0x0
+#define NT_LINK_AD_HOC				0x1
+#define NT_LINK_AP					0x2
+#define NT_AS_AP					0x3
+
+#define _LBMODE(x)					(((x) & 0xF) << 24)
+#define MASK_LBMODE					0xF000000
+#define LOOPBACK_NORMAL				0x0
+#define LOOPBACK_IMMEDIATELY		0xB
+#define LOOPBACK_MAC_DELAY			0x3
+#define LOOPBACK_PHY				0x1
+#define LOOPBACK_DMA				0x7
+
+
+//2 PBP - Page Size Register
+#define GET_RX_PAGE_SIZE(value)		((value) & 0xF)
+#define GET_TX_PAGE_SIZE(value)		(((value) & 0xF0) >> 4)
+#define _PSRX_MASK					0xF
+#define _PSTX_MASK					0xF0
+#define _PSRX(x)					(x)
+#define _PSTX(x)					((x) << 4)
+
+#define PBP_64						0x0
+#define PBP_128						0x1
+#define PBP_256						0x2
+#define PBP_512						0x3
+#define PBP_1024					0x4
+
+
+//2 TX/RXDMA
+#define RXDMA_ARBBW_EN				BIT(0)
+#define RXSHFT_EN					BIT(1)
+#define RXDMA_AGG_EN				BIT(2)
+#define QS_VO_QUEUE					BIT(8)
+#define QS_VI_QUEUE					BIT(9)
+#define QS_BE_QUEUE					BIT(10)
+#define QS_BK_QUEUE					BIT(11)
+#define QS_MANAGER_QUEUE			BIT(12)
+#define QS_HIGH_QUEUE				BIT(13)
+
+#define HQSEL_VOQ					BIT(0)
+#define HQSEL_VIQ					BIT(1)
+#define HQSEL_BEQ					BIT(2)
+#define HQSEL_BKQ					BIT(3)
+#define HQSEL_MGTQ					BIT(4)
+#define HQSEL_HIQ					BIT(5)
+
+// For normal driver, 0x10C
+#define _TXDMA_HIQ_MAP(x) 	 		(((x)&0x3) << 14)
+#define _TXDMA_MGQ_MAP(x) 	 		(((x)&0x3) << 12)
+#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)		
+#define _TXDMA_BEQ_MAP(x) 	 		(((x)&0x3) << 8 )
+#define _TXDMA_VIQ_MAP(x) 	 		(((x)&0x3) << 6 )
+#define _TXDMA_VOQ_MAP(x) 	 		(((x)&0x3) << 4 )
+
+#define QUEUE_LOW					1
+#define QUEUE_NORMAL				2
+#define QUEUE_HIGH					3
+
+
+
+//2 TRXFF_BNDY
+
+
+//2 LLT_INIT
+#define _LLT_NO_ACTIVE				0x0
+#define _LLT_WRITE_ACCESS			0x1
+#define _LLT_READ_ACCESS			0x2
+
+#define _LLT_INIT_DATA(x)			((x) & 0xFF)
+#define _LLT_INIT_ADDR(x)			(((x) & 0xFF) << 8)
+#define _LLT_OP(x)					(((x) & 0x3) << 30)
+#define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)
+
+
+//2 BB_ACCESS_CTRL
+#define BB_WRITE_READ_MASK			(BIT(31) | BIT(30))
+#define BB_WRITE_EN					BIT(30)
+#define BB_READ_EN					BIT(31)
+//#define BB_ADDR_MASK				0xFFF
+//#define _BB_ADDR(x)					((x) & BB_ADDR_MASK)
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+//2 RQPN
+#define _HPQ(x)						((x) & 0xFF)
+#define _LPQ(x)						(((x) & 0xFF) << 8)
+#define _PUBQ(x)					(((x) & 0xFF) << 16)
+#define _NPQ(x)						((x) & 0xFF)			// NOTE: in RQPN_NPQ register
+
+
+#define HPQ_PUBLIC_DIS				BIT(24)
+#define LPQ_PUBLIC_DIS				BIT(25)
+#define LD_RQPN						BIT(31)
+
+
+//2 TDECTRL
+#define BCN_VALID					BIT(16)
+#define BCN_HEAD(x)					(((x) & 0xFF) << 8)
+#define	BCN_HEAD_MASK				0xFF00
+
+//2 TDECTL
+#define BLK_DESC_NUM_SHIFT			4
+#define BLK_DESC_NUM_MASK			0xF
+
+
+//2 TXDMA_OFFSET_CHK
+#define DROP_DATA_EN				BIT(9)
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+//2 FWHW_TXQ_CTRL
+#define EN_AMPDU_RTY_NEW			BIT(7)
+
+//2 INIRTSMCS_SEL
+#define _INIRTSMCS_SEL(x)			((x) & 0x3F)
+
+
+//2 SPEC SIFS
+#define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
+#define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)
+
+
+//2 RRSR
+
+#define RATE_REG_BITMAP_ALL			0xFFFFF
+
+#define _RRSC_BITMAP(x)				((x) & 0xFFFFF)
+
+#define _RRSR_RSC(x)				(((x) & 0x3) << 21)
+#define RRSR_RSC_RESERVED			0x0
+#define RRSR_RSC_UPPER_SUBCHANNEL	0x1
+#define RRSR_RSC_LOWER_SUBCHANNEL	0x2
+#define RRSR_RSC_DUPLICATE_MODE		0x3
+
+
+//2 ARFR
+#define USE_SHORT_G1				BIT(20)
+
+//2 AGGLEN_LMT_L
+#define _AGGLMT_MCS0(x)				((x) & 0xF)
+#define _AGGLMT_MCS1(x)				(((x) & 0xF) << 4)
+#define _AGGLMT_MCS2(x)				(((x) & 0xF) << 8)
+#define _AGGLMT_MCS3(x)				(((x) & 0xF) << 12)
+#define _AGGLMT_MCS4(x)				(((x) & 0xF) << 16)
+#define _AGGLMT_MCS5(x)				(((x) & 0xF) << 20)
+#define _AGGLMT_MCS6(x)				(((x) & 0xF) << 24)
+#define _AGGLMT_MCS7(x)				(((x) & 0xF) << 28)
+
+
+//2 RL
+#define	RETRY_LIMIT_SHORT_SHIFT		8
+#define	RETRY_LIMIT_LONG_SHIFT		0
+
+
+//2 DARFRC
+#define _DARF_RC1(x)				((x) & 0x1F)
+#define _DARF_RC2(x)				(((x) & 0x1F) << 8)
+#define _DARF_RC3(x)				(((x) & 0x1F) << 16)
+#define _DARF_RC4(x)				(((x) & 0x1F) << 24)
+// NOTE: shift starting from address (DARFRC + 4)
+#define _DARF_RC5(x)				((x) & 0x1F)
+#define _DARF_RC6(x)				(((x) & 0x1F) << 8)
+#define _DARF_RC7(x)				(((x) & 0x1F) << 16)
+#define _DARF_RC8(x)				(((x) & 0x1F) << 24)
+
+
+//2 RARFRC
+#define _RARF_RC1(x)				((x) & 0x1F)
+#define _RARF_RC2(x)				(((x) & 0x1F) << 8)
+#define _RARF_RC3(x)				(((x) & 0x1F) << 16)
+#define _RARF_RC4(x)				(((x) & 0x1F) << 24)
+// NOTE: shift starting from address (RARFRC + 4)
+#define _RARF_RC5(x)				((x) & 0x1F)
+#define _RARF_RC6(x)				(((x) & 0x1F) << 8)
+#define _RARF_RC7(x)				(((x) & 0x1F) << 16)
+#define _RARF_RC8(x)				(((x) & 0x1F) << 24)
+
+
+
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+
+
+
+//2 EDCA setting
+#define AC_PARAM_TXOP_LIMIT_OFFSET	16
+#define AC_PARAM_ECW_MAX_OFFSET		12
+#define AC_PARAM_ECW_MIN_OFFSET		8
+#define AC_PARAM_AIFS_OFFSET		0
+
+
+//2 EDCA_VO_PARAM
+#define _AIFS(x)					(x)
+#define _ECW_MAX_MIN(x)				((x) << 8)
+#define _TXOP_LIMIT(x)				((x) << 16)
+
+
+#define _BCNIFS(x)					((x) & 0xFF)
+#define _BCNECW(x)					(((x) & 0xF))<< 8)
+
+
+#define _LRL(x)						((x) & 0x3F)
+#define _SRL(x)						(((x) & 0x3F) << 8)
+
+
+//2 SIFS_CCK
+#define _SIFS_CCK_CTX(x)			((x) & 0xFF)
+#define _SIFS_CCK_TRX(x)			(((x) & 0xFF) << 8);
+
+
+//2 SIFS_OFDM
+#define _SIFS_OFDM_CTX(x)			((x) & 0xFF)
+#define _SIFS_OFDM_TRX(x)			(((x) & 0xFF) << 8);
+
+
+//2 TBTT PROHIBIT
+#define _TBTT_PROHIBIT_HOLD(x)		(((x) & 0xFF) << 8)
+
+
+//2 REG_RD_CTRL
+#define DIS_EDCA_CNT_DWN			BIT(11)
+
+
+//2 BCN_CTRL
+#define EN_MBSSID					BIT(1)
+#define EN_TXBCN_RPT				BIT(2)
+#define	EN_BCN_FUNCTION				BIT(3)
+
+// The same function but different bit field.
+#define	DIS_TSF_UDT0_NORMAL_CHIP	BIT(4)
+#define	DIS_TSF_UDT0_TEST_CHIP		BIT(5)
+
+//2 ACMHWCTRL
+#define	AcmHw_HwEn					BIT(0)
+#define	AcmHw_BeqEn					BIT(1)
+#define	AcmHw_ViqEn					BIT(2)
+#define	AcmHw_VoqEn					BIT(3)
+#define	AcmHw_BeqStatus				BIT(4)
+#define	AcmHw_ViqStatus				BIT(5)
+#define	AcmHw_VoqStatus				BIT(6)
+
+
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+
+//2 APSD_CTRL
+#define APSDOFF						BIT(6)
+#define APSDOFF_STATUS				BIT(7)
+
+
+//2 BWOPMODE
+#define BW_20MHZ					BIT(2)
+//#define BW_OPMODE_20MHZ				BIT(2)	// For compability
+
+
+#define RATE_BITMAP_ALL				0xFFFFF
+
+// Only use CCK 1M rate for ACK
+#define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
+
+//2 TCR
+#define TSFRST						BIT(0)
+#define DIS_GCLK					BIT(1)
+#define PAD_SEL						BIT(2)
+#define PWR_ST						BIT(6)
+#define PWRBIT_OW_EN				BIT(7)
+#define ACRC						BIT(8)
+#define CFENDFORM					BIT(9)
+#define ICV							BIT(10)
+
+
+
+//2 RCR
+#define AAP							BIT(0)
+#define APM							BIT(1)
+#define AM							BIT(2)
+#define AB							BIT(3)
+#define ADD3						BIT(4)
+#define APWRMGT						BIT(5)
+#define CBSSID						BIT(6)
+#define CBSSID_BCN					BIT(7)
+#define ACRC32						BIT(8)
+#define AICV						BIT(9)
+#define ADF							BIT(11)
+#define ACF							BIT(12)
+#define AMF							BIT(13)
+#define HTC_LOC_CTRL				BIT(14)
+#define UC_DATA_EN					BIT(16)
+#define BM_DATA_EN					BIT(17)
+#define MFBEN						BIT(22)
+#define LSIGEN						BIT(23)
+#define EnMBID						BIT(24)
+#define APP_BASSN					BIT(27)
+#define APP_PHYSTS					BIT(28)
+#define APP_ICV						BIT(29)
+#define APP_MIC						BIT(30)
+#define APP_FCS						BIT(31)
+
+//2 RX_PKT_LIMIT
+
+//2 RX_DLK_TIME
+
+//2 MBIDCAMCFG
+
+
+
+//2 AMPDU_MIN_SPACE
+#define _MIN_SPACE(x)				((x) & 0x7)
+#define _SHORT_GI_PADDING(x)		(((x) & 0x1F) << 3)
+
+
+//2 RXERR_RPT
+#define RXERR_TYPE_OFDM_PPDU			0
+#define RXERR_TYPE_OFDM_FALSE_ALARM		1
+#define	RXERR_TYPE_OFDM_MPDU_OK			2
+#define RXERR_TYPE_OFDM_MPDU_FAIL		3
+#define RXERR_TYPE_CCK_PPDU				4
+#define RXERR_TYPE_CCK_FALSE_ALARM		5
+#define RXERR_TYPE_CCK_MPDU_OK			6
+#define RXERR_TYPE_CCK_MPDU_FAIL		7
+#define RXERR_TYPE_HT_PPDU				8
+#define RXERR_TYPE_HT_FALSE_ALARM		9
+#define RXERR_TYPE_HT_MPDU_TOTAL		10
+#define RXERR_TYPE_HT_MPDU_OK			11
+#define RXERR_TYPE_HT_MPDU_FAIL			12
+#define RXERR_TYPE_RX_FULL_DROP			15
+
+#define RXERR_COUNTER_MASK				0xFFFFF
+#define RXERR_RPT_RST					BIT(27)
+#define _RXERR_RPT_SEL(type)			((type) << 28)
+
+
+//2 SECCFG
+#define	SCR_TxUseDK						BIT(0)			//Force Tx Use Default Key
+#define	SCR_RxUseDK						BIT(1)			//Force Rx Use Default Key
+#define	SCR_TxEncEnable					BIT(2)			//Enable Tx Encryption
+#define	SCR_RxDecEnable					BIT(3)			//Enable Rx Decryption
+#define	SCR_SKByA2						BIT(4)			//Search kEY BY A2
+#define	SCR_NoSKMC						BIT(5)			//No Key Search Multicast
+
+
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+
+//2 USB Information (0xFE17)
+#define USB_IS_HIGH_SPEED				0
+#define USB_IS_FULL_SPEED				1
+#define USB_SPEED_MASK					BIT(5)
+
+#define USB_NORMAL_SIE_EP_MASK			0xF
+#define USB_NORMAL_SIE_EP_SHIFT			4
+
+#define USB_TEST_EP_MASK				0x30
+#define USB_TEST_EP_SHIFT				4
+
+//2 Special Option
+#define USB_AGG_EN						BIT(3)
+
+
+//========================================================
+// General definitions
+//========================================================
+
+#define MAC_ADDR_LEN					6
+#define LAST_ENTRY_OF_TX_PKT_BUFFER		255
+
+#define POLLING_LLT_THRESHOLD			20
+#define POLLING_READY_TIMEOUT_COUNT		1000
+
+// Min Spacing related settings.
+#define	MAX_MSS_DENSITY_2T				0x13
+#define	MAX_MSS_DENSITY_1T				0x0A
+
+//----------------------------------------------------------------------------
+//       8192C GPIO MUX Configuration Register (offset 0x40, 4 byte)
+//----------------------------------------------------------------------------
+#define	GPIOSEL_GPIO				0
+#define	GPIOSEL_ENBT				BIT5
+
+//----------------------------------------------------------------------------
+//       8192C GPIO PIN Control Register (offset 0x44, 4 byte)
+//----------------------------------------------------------------------------
+#define	GPIO_IN						REG_GPIO_PIN_CTRL		// GPIO pins input value
+#define	GPIO_OUT					(REG_GPIO_PIN_CTRL+1)	// GPIO pins output value
+#define	GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
+#define	GPIO_MOD					(REG_GPIO_PIN_CTRL+3)
+
+
+
+#include "basic_types.h"
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_xmit.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_xmit.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8192c_xmit.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8192c_xmit.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,132 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8192C_XMIT_H_
+#define _RTL8192C_XMIT_H_
+
+#define HWXMIT_ENTRY	4
+
+#define VO_QUEUE_INX	0
+#define VI_QUEUE_INX	1
+#define BE_QUEUE_INX	2
+#define BK_QUEUE_INX	3
+#define TS_QUEUE_INX	4
+#define MGT_QUEUE_INX	5
+#define BMC_QUEUE_INX	6
+#define BCN_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+//
+// Queue Select Value in TxDesc
+//
+#define QSLT_BK							0x2//0x01
+#define QSLT_BE							0x0
+#define QSLT_VI							0x5//0x4
+#define QSLT_VO							0x7//0x6
+#define QSLT_BEACON						0x10
+#define QSLT_HIGH						0x11
+#define QSLT_MGNT						0x12
+#define QSLT_CMD						0x13
+
+#define TXDESC_SIZE 32
+#define PACKET_OFFSET_SZ (8)
+#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
+
+#if USB_TX_AGGREGATION_92C
+#define MAX_TX_AGG_PACKET_NUMBER 0xFF
+#endif
+
+#define tx_cmd tx_desc
+
+//
+//defined for TX DESC Operation
+//
+
+#define MAX_TID (15)
+
+//OFFSET 0
+#define OFFSET_SZ (0)
+#define OFFSET_SHT (16)
+#define OWN 	BIT(31)
+#define FSG	BIT(27)
+#define LSG	BIT(26)
+
+//OFFSET 4
+#define PKT_OFFSET_SZ (0)
+#define QSEL_SHT (8)
+#define NAVUSEHDR BIT(20)
+#define HWPC BIT(31)
+
+//OFFSET 8
+#define BMC BIT(7)
+#define BK BIT(30)
+#define AGG_EN BIT(29)
+
+//OFFSET 12
+#define SEQ_SHT (16)
+
+//OFFSET 16
+#define TXBW BIT(18)
+
+//OFFSET 20
+#define DISFB BIT(15)
+
+struct tx_desc{
+
+	//DWORD 0
+	u32 txdw0;
+
+	u32 txdw1;
+
+	u32 txdw2;
+
+	u32 txdw3;
+
+	u32 txdw4;
+
+	u32 txdw5;
+
+	u32 txdw6;
+
+	u32 txdw7;	
+
+};
+
+
+union txdesc {
+	struct tx_desc txdesc;
+	u32 value[TXDESC_SIZE>>2];	
+};
+
+void cal_txdesc_chksum(struct tx_desc	*ptxdesc);
+s32 rtw_update_txdesc(struct xmit_frame *pxmitframe, u32 *ptxdesc, s32 sz);
+void rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe);
+
+s32 rtw_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+void rtw_do_queue_select(_adapter *padapter, struct pkt_attrib *pattrib);
+u32 rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe);
+
+s32 pre_xmitframe(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 xmitframe_direct(_adapter *padapter, struct xmit_frame *pxmitframe);
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_bitdef.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_bitdef.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_bitdef.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_bitdef.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/	
+
+
+#ifndef __RTL8712_BITDEF_H__
+#define __RTL8712_BITDEF_H__
+
+
+#include "rtl8712_spec/ioreg_def/rtl8712_cmdctrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_syscfg_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_macsetting_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_timectrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_fifoctrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_ratectrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_edcasetting_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_wmac_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_security_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_powersave_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_gp_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_interrupt_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_debugctrl_bitdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_offload_bitdef.h"
+#include "rtl8712_spec/sdio_reg/rtl8712_sdio_bitdef.h"
+#include "rtl8712_spec/sdio_reg/rtl8712_sdio_regdef.h"
+
+#endif // __RTL8712_BITDEF_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_cmd.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_cmd.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_cmd.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_cmd.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,303 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_CMD_H_
+#define __RTL8712_CMD_H_
+
+enum rtl8712_h2c_cmd
+{
+	GEN_CMD_CODE(_Read_MACREG) ,	/*0*/
+ 	GEN_CMD_CODE(_Write_MACREG) ,    
+ 	GEN_CMD_CODE(_Read_BBREG) ,  
+ 	GEN_CMD_CODE(_Write_BBREG) ,  
+ 	GEN_CMD_CODE(_Read_RFREG) ,  
+ 	GEN_CMD_CODE(_Write_RFREG) , /*5*/
+ 	GEN_CMD_CODE(_Read_EEPROM) ,  
+ 	GEN_CMD_CODE(_Write_EEPROM) ,  
+ 	GEN_CMD_CODE(_Read_EFUSE) ,  
+ 	GEN_CMD_CODE(_Write_EFUSE) , 
+ 	
+ 	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
+ 	GEN_CMD_CODE(_Write_CAM) ,   
+ 	GEN_CMD_CODE(_setBCNITV),
+ 	GEN_CMD_CODE(_setMBIDCFG),
+ 	GEN_CMD_CODE(_JoinBss),   /*14*/
+ 	GEN_CMD_CODE(_DisConnect) , /*15*/
+ 	GEN_CMD_CODE(_CreateBss) ,
+	GEN_CMD_CODE(_SetOpMode) , 
+	GEN_CMD_CODE(_SiteSurvey),  /*18*/
+ 	GEN_CMD_CODE(_SetAuth) ,
+ 	
+ 	GEN_CMD_CODE(_SetKey) ,	/*20*/
+ 	GEN_CMD_CODE(_SetStaKey) ,
+ 	GEN_CMD_CODE(_SetAssocSta) ,
+ 	GEN_CMD_CODE(_DelAssocSta) ,
+ 	GEN_CMD_CODE(_SetStaPwrState) , 
+ 	GEN_CMD_CODE(_SetBasicRate) , /*25*/
+ 	GEN_CMD_CODE(_GetBasicRate) ,
+ 	GEN_CMD_CODE(_SetDataRate) ,
+ 	GEN_CMD_CODE(_GetDataRate) ,
+	GEN_CMD_CODE(_SetPhyInfo) ,
+	
+ 	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
+	GEN_CMD_CODE(_SetPhy) ,
+ 	GEN_CMD_CODE(_GetPhy) ,
+ 	GEN_CMD_CODE(_readRssi) ,
+ 	GEN_CMD_CODE(_readGain) ,
+ 	GEN_CMD_CODE(_SetAtim) , /*35*/
+ 	GEN_CMD_CODE(_SetPwrMode) , 
+ 	GEN_CMD_CODE(_JoinbssRpt),
+ 	GEN_CMD_CODE(_SetRaTable) ,
+ 	GEN_CMD_CODE(_GetRaTable) ,  	
+ 	
+ 	GEN_CMD_CODE(_GetCCXReport), /*40*/
+ 	GEN_CMD_CODE(_GetDTMReport),
+ 	GEN_CMD_CODE(_GetTXRateStatistics),
+ 	GEN_CMD_CODE(_SetUsbSuspend),
+ 	GEN_CMD_CODE(_SetH2cLbk),
+ 	GEN_CMD_CODE(_AddBAReq) , /*45*/
+
+	GEN_CMD_CODE(_SetChannel), /*46*/
+#ifdef MP_FIRMWARE_OFFLOAD
+	GEN_CMD_CODE(_SetTxPower), 
+	GEN_CMD_CODE(_SwitchAntenna),
+	GEN_CMD_CODE(_SetCrystalCap),
+	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
+	GEN_CMD_CODE(_SetSingleToneTx),
+	GEN_CMD_CODE(_SetCarrierSuppressionTx),
+	GEN_CMD_CODE(_SetContinuousTx),
+	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
+#endif
+#if 1//To do, modify these h2c cmd, add or delete
+	GEN_CMD_CODE(_GetH2cLbk) ,
+
+	// WPS extra IE
+	GEN_CMD_CODE(_SetProbeReqExtraIE) ,
+	GEN_CMD_CODE(_SetAssocReqExtraIE) ,
+	GEN_CMD_CODE(_SetProbeRspExtraIE) ,
+	GEN_CMD_CODE(_SetAssocRspExtraIE) ,
+	
+	// the following is driver will do
+	GEN_CMD_CODE(_GetCurDataRate) , 
+
+	GEN_CMD_CODE(_GetTxRetrycnt),  // to record times that Tx retry to transmmit packet after association
+	GEN_CMD_CODE(_GetRxRetrycnt), // to record total number of the received frame with ReTry bit set in the WLAN header
+
+	GEN_CMD_CODE(_GetBCNOKcnt),
+	GEN_CMD_CODE(_GetBCNERRcnt),
+	GEN_CMD_CODE(_GetCurTxPwrLevel),
+
+	GEN_CMD_CODE(_SetDIG),
+	GEN_CMD_CODE(_SetRA),
+	GEN_CMD_CODE(_SetPT),
+	GEN_CMD_CODE(_ReadTSSI),	
+ #endif
+	MAX_H2CCMD
+};
+
+
+#define _GetBBReg_CMD_		_Read_BBREG_CMD_
+#define _SetBBReg_CMD_ 		_Write_BBREG_CMD_
+#define _GetRFReg_CMD_ 		_Read_RFREG_CMD_
+#define _SetRFReg_CMD_ 		_Write_RFREG_CMD_
+#define _DRV_INT_CMD_		(MAX_H2CCMD+1)
+#define _SetRFIntFs_CMD_	(MAX_H2CCMD+2)
+
+#ifdef _RTL8712_CMD_C_
+struct _cmd_callback 	rtw_cmd_callback[] = 
+{
+	{GEN_CMD_CODE(_Read_MACREG), NULL}, /*0*/
+	{GEN_CMD_CODE(_Write_MACREG), NULL}, 
+	{GEN_CMD_CODE(_Read_BBREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_BBREG), NULL},
+	{GEN_CMD_CODE(_Read_RFREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_Read_EEPROM), NULL},
+	{GEN_CMD_CODE(_Write_EEPROM), NULL},
+	{GEN_CMD_CODE(_Read_EFUSE), NULL},
+	{GEN_CMD_CODE(_Write_EFUSE), NULL},
+	
+	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},	
+	{GEN_CMD_CODE(_setBCNITV), NULL},
+ 	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CreateBss), &rtw_createbss_cmd_callback},
+	{GEN_CMD_CODE(_SetOpMode), NULL},
+	{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SetAuth), NULL},
+	
+	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
+	{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetAssocSta), &rtw_setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},	
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},	
+	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
+	{GEN_CMD_CODE(_GetBasicRate), NULL},
+	{GEN_CMD_CODE(_SetDataRate), NULL},
+	{GEN_CMD_CODE(_GetDataRate), NULL},
+	{GEN_CMD_CODE(_SetPhyInfo), NULL},
+	
+	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
+	{GEN_CMD_CODE(_SetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},	
+	{GEN_CMD_CODE(_readRssi), NULL},
+	{GEN_CMD_CODE(_readGain), NULL},
+	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
+	{GEN_CMD_CODE(_SetPwrMode), NULL},
+	{GEN_CMD_CODE(_JoinbssRpt), NULL},
+	{GEN_CMD_CODE(_SetRaTable), NULL},
+	{GEN_CMD_CODE(_GetRaTable) , NULL},
+ 	
+	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
+ 	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+ 	{GEN_CMD_CODE(_GetTXRateStatistics), NULL}, 
+ 	{GEN_CMD_CODE(_SetUsbSuspend), NULL}, 
+ 	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+ 	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+
+	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
+#ifdef MP_FIRMWARE_OFFLOAD
+	{GEN_CMD_CODE(_SetTxPower), NULL},
+	{GEN_CMD_CODE(_SwitchAntenna), NULL},
+	{GEN_CMD_CODE(_SetCrystalCap), NULL},
+	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
+	{GEN_CMD_CODE(_SetSingleToneTx), NULL},
+	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
+	{GEN_CMD_CODE(_SetContinuousTx), NULL},
+	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
+#endif
+
+#if 1//To do, modify these h2c cmd, add or delete
+	{GEN_CMD_CODE(_GetH2cLbk), NULL},
+
+	{_SetProbeReqExtraIE_CMD_, NULL},
+	{_SetAssocReqExtraIE_CMD_, NULL},
+	{_SetProbeRspExtraIE_CMD_, NULL},
+	{_SetAssocRspExtraIE_CMD_, NULL},	
+	{_GetCurDataRate_CMD_, NULL},
+	{_GetTxRetrycnt_CMD_, NULL},
+	{_GetRxRetrycnt_CMD_, NULL},	
+	{_GetBCNOKcnt_CMD_, NULL},	
+	{_GetBCNERRcnt_CMD_, NULL},	
+	{_GetCurTxPwrLevel_CMD_, NULL},	
+	{_SetDIG_CMD_, NULL},	
+	{_SetRA_CMD_, NULL},		
+	{_SetPT_CMD_,NULL},
+	{GEN_CMD_CODE(_ReadTSSI), &rtw_readtssi_cmdrsp_callback}
+#endif
+};
+#endif
+
+
+#ifdef CONFIG_MLME_EXT
+
+struct cmd_hdl {
+	uint	parmsize;
+	u8 (*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);	
+};
+
+
+u8 read_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+
+#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
+
+extern u8 r871x_NULL_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_joinbss_hdl(_adapter *padapter, u8 *pbuf);	
+extern u8 r871x_disconnect_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_createbss_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_setopmode_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_sitesurvey_hdl(_adapter *padapter, u8 *pbuf);	
+extern u8 r871x_setauth_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_setkey_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_set_stakey_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_set_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+extern u8 r871x_del_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+
+#define GEN_MLME_CMD_HANDLER(size, cmd)	{size, &r871x_ ## cmd ## _hdl},
+
+#ifdef _RTL8712_CMD_C_
+struct cmd_hdl	wlancmds[] = 
+{
+	GEN_DRV_CMD_HANDLER(0, read_macreg) /*0*/
+	GEN_DRV_CMD_HANDLER(0, write_macreg)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	
+	GEN_MLME_CMD_HANDLER(0, NULL) /*10*/
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)		
+	GEN_MLME_CMD_HANDLER(sizeof (struct joinbss_parm), joinbss) /*14*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct disconnect_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct createbss_parm), createbss)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setopmode_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct sitesurvey_parm), sitesurvey) /*18*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct setauth_parm), setauth)
+	
+	GEN_MLME_CMD_HANDLER(sizeof (struct setkey_parm), setkey) /*20*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct set_stakey_parm), set_stakey)
+	GEN_MLME_CMD_HANDLER(sizeof (struct set_assocsta_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct del_assocsta_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setstapwrstate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setbasicrate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct getbasicrate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setdatarate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct getdatarate_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct setphyinfo_parm), NULL)
+	
+	GEN_MLME_CMD_HANDLER(sizeof (struct getphyinfo_parm), NULL)  /*30*/
+	GEN_MLME_CMD_HANDLER(sizeof (struct setphy_parm), NULL)
+	GEN_MLME_CMD_HANDLER(sizeof (struct getphy_parm), NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	
+	GEN_MLME_CMD_HANDLER(0, NULL)	/*40*/
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	GEN_MLME_CMD_HANDLER(0, NULL)
+	
+};
+#endif
+
+#endif//end of CONFIG_MLME_EXT
+
+
+
+u8 read_macreg_cmd(_adapter  *padapter, u32 offset, u8 *pval);
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_efuse.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_efuse.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_efuse.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_efuse.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,64 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_EFUSE_H__
+#define __RTL8712_EFUSE_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+#define _REPEAT_THRESHOLD_	3
+
+#define	EFUSE_MAX_PGPKT_SIZE   	9 //header+ 2* 4 words (BYTES)
+#define	EFUSE_PGPKT_DATA_SIZE 	8 //BYTES sizeof(u8)*8
+#define	EFUSE_MAX_PGPKT_OFFSET	16
+		
+#define	EFUSE_PGPKG_MAX_WORDS 	4
+#define	EFUSE_REPROG_THRESHOLD	3
+
+#define	EFUSE_PG_STATE_HEADER	0x01
+#define	EFUSE_PG_STATE_DATA		0x20
+#define	EFUSE_MAX_PHYSICAL_SIZE	512
+#define	EFUSE_MAX_LOGICAL_SIZE	128
+
+#define GET_EFUSE_OFFSET(header)	((header & 0xF0) >> 4)
+#define GET_EFUSE_WORD_EN(header)	(header & 0x0F)
+#define MAKE_EFUSE_HEADER(offset, word_en)	(((offset & 0x0F) << 4) | (word_en & 0x0F))
+//------------------------------------------------------------------------------
+typedef struct PG_PKT_STRUCT{
+	u8 offset;
+	u8 word_en;
+	u8 data[EFUSE_PGPKT_DATA_SIZE];
+} PGPKT_STRUCT,*PPGPKT_STRUCT;
+//------------------------------------------------------------------------------
+extern u8 	rtw_efuse_reg_init(_adapter *padapter);
+extern void 	rtw_efuse_reg_uninit(_adapter *padapter);
+extern u16 	rtw_efuse_get_current_phy_size(_adapter *padapter);
+extern int 	rtw_efuse_get_max_phy_size(_adapter *padapter);
+
+extern u8 	rtw_efuse_pg_packet_read(_adapter *padapter, u8 offset, u8 *data);
+extern u8 	rtw_efuse_pg_packet_write(_adapter *padapter, const u8 offset, const u8 word_en, const u8 *data);
+extern u8 	rtw_efuse_access(_adapter *padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data);
+extern u8	rtw_efuse_map_read(_adapter *padapter, u16 addr, u16 cnts, u8 *data);
+extern u8	rtw_efuse_map_write(_adapter *padapter, u16 addr, u16 cnts, u8 *data);
+
+u8 efuse_one_byte_read(_adapter *padapter, u16 addr, u8 *data);
+
+#endif
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_event.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_event.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_event.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_event.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,101 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_EVENT_H_
+#define _RTL8712_EVENT_H_
+
+void event_handle(_adapter *padapter, uint *peventbuf);
+
+
+void rtw_dummy_event_callback(_adapter *adapter , u8 *pbuf);
+static void fwdbg_event_callback(_adapter *adapter , u8 *pbuf);
+
+enum rtl8712_c2h_event
+{
+	GEN_EVT_CODE(_Read_MACREG)=0, /*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+ 	GEN_EVT_CODE(_Read_RFREG),
+ 	GEN_EVT_CODE(_Read_EEPROM),
+ 	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),			/*5*/
+ 	GEN_EVT_CODE(_Get_BasicRate),  
+ 	GEN_EVT_CODE(_Get_DataRate),   
+ 	GEN_EVT_CODE(_Survey),	 /*8*/
+ 	GEN_EVT_CODE(_SurveyDone),	 /*9*/
+ 	
+ 	GEN_EVT_CODE(_JoinBss) , /*10*/
+ 	GEN_EVT_CODE(_AddSTA),
+ 	GEN_EVT_CODE(_DelSTA),
+ 	GEN_EVT_CODE(_AtimDone) ,
+ 	GEN_EVT_CODE(_TX_Report),  
+	GEN_EVT_CODE(_CCX_Report),			/*15*/
+ 	GEN_EVT_CODE(_DTM_Report),
+ 	GEN_EVT_CODE(_TX_Rate_Statistics),
+ 	GEN_EVT_CODE(_C2HLBK), 
+ 	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB	
+	GEN_EVT_CODE(_CloseRF),				//filen: only for PCIE, work around ASPM
+ 	MAX_C2HEVT
+};
+
+
+#ifdef _RTL8712_CMD_C_		
+
+struct fwevent rtw_wlanevents[] = 
+{
+	{0, rtw_dummy_event_callback}, 	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_survey_event_callback},		/*8*/
+	{sizeof (struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/
+		
+	{0, &rtw_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
+	{sizeof(struct stadel_event), &rtw_stadel_event_callback},	
+	{0, &rtw_atimdone_event_callback},
+	{0, rtw_dummy_event_callback},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, fwdbg_event_callback},
+	{0, NULL},	 /*20*/
+	{0, NULL},
+	{0, NULL},	
+	{0, &rtw_cpwm_event_callback},
+};
+
+#endif//_RTL8712_CMD_C_
+
+void recv_event_bh(void *priv);
+
+#ifdef CONFIG_MLME_EXT
+int event_queuing (_adapter *padapter, struct event_node *evtnode);
+#endif
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_hal.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_hal.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_hal.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_hal.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,171 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_HAL_H__
+#define __RTL8712_HAL_H__
+
+
+
+enum _HW_VERSION {
+
+	RTL8712_FPGA,
+	RTL8712_1stCUT,//A Cut (RTL8712_ASIC)
+	RTL8712_2ndCUT,//B Cut
+	RTL8712_3rdCUT,//C Cut
+};
+
+
+enum _LOOPBACK_TYPE {
+
+ RTL8712_AIR_TRX = 0,
+ RTL8712_MAC_LBK,
+ RTL8712_BB_LBK,
+ RTL8712_MAC_FW_LBK = 4,
+ RTL8712_BB_FW_LBK = 8,
+
+};
+
+enum RTL871X_HCI_TYPE {
+
+	RTL8712_SDIO,	
+	RTL8712_USB,
+};
+
+enum RTL8712_RF_CONFIG{
+	RTL8712_RF_1T1R,
+	RTL8712_RF_1T2R,
+	RTL8712_RF_2T2R
+};
+
+
+enum _RTL8712_HCI_TYPE_{
+ RTL8712_HCI_TYPE_PCIE=0x01,
+ RTL8712_HCI_TYPE_AP_PCIE=0x81,  
+ RTL8712_HCI_TYPE_USB=0x02,
+ RTL8712_HCI_TYPE_92USB=0x02,
+ RTL8712_HCI_TYPE_AP_USB=0x82,   
+ RTL8712_HCI_TYPE_72USB=0x12,
+ RTL8712_HCI_TYPE_SDIO=0x04,
+ RTL8712_HCI_TYPE_72SDIO=0x14
+};
+
+
+struct fw_priv {   //8-bytes alignment required
+
+	//--- long word 0 ----
+ unsigned char  signature_0;  //0x12: CE product, 0x92: IT product
+ unsigned char  signature_1;  //0x87: CE product, 0x81: IT product
+ unsigned char  hci_sel;   //0x81: PCI-AP, 01:PCIe, 02: 92S-U, 0x82: USB-AP, 0x12: 72S-U, 03:SDIO
+ unsigned char  chip_version; //the same value as reigster value 
+ unsigned char  customer_ID_0; //customer  ID low byte
+ unsigned char  customer_ID_1; //customer  ID high byte
+ unsigned char  rf_config;  //0x11:  1T1R, 0x12: 1T2R, 0x92: 1T2R turbo, 0x22: 2T2R
+ unsigned char  usb_ep_num;  // 4: 4EP, 6: 6EP, 11: 11EP
+	
+	//--- long word 1 ----
+ unsigned char  regulatory_class_0; //regulatory class bit map 0
+ unsigned char  regulatory_class_1; //regulatory class bit map 1
+ unsigned char  regulatory_class_2; //regulatory class bit map 2
+ unsigned char  regulatory_class_3; //regulatory class bit map 3 
+ unsigned char  rfintfs;    // 0:SWSI, 1:HWSI, 2:HWPI
+ unsigned char  def_nettype;  //
+ unsigned char  turboMode;
+ unsigned char  lowPowerMode;// 0: noral mode, 1: low power mode
+	
+	//--- long word 2 ----
+ unsigned char  lbk_mode; //0x00: normal, 0x03: MACLBK, 0x01: PHYLBK
+ unsigned char  mp_mode; // 1: for MP use, 0: for normal driver (to be discussed)
+ unsigned char  vcsType; /* 0:off 1:on 2:auto */
+ unsigned char  vcsMode; /* 1:RTS/CTS 2:CTS to self */
+ unsigned char  rsvd022;
+ unsigned char  rsvd023;
+ unsigned char  rsvd024;
+ unsigned char  rsvd025;
+	
+	//--- long word 3 ----
+ unsigned char  qos_en;    //1: QoS enable
+ unsigned char  bw_40MHz_en;   //1: 40MHz BW enable
+ unsigned char  AMSDU2AMPDU_en;   //1: 4181 convert AMSDU to AMPDU, 0: disable
+ unsigned char  AMPDU_en;   //1: 11n AMPDU enable
+ unsigned char  rate_control_offload;  //1: FW offloads, 0: driver handles
+ unsigned char  aggregation_offload;  //1: FW offloads, 0: driver handles
+ unsigned char  rsvd030;
+ unsigned char  rsvd031;
+
+	//--- long word 4 ----
+ unsigned char  beacon_offload;   // 1. FW offloads, 0: driver handles
+ unsigned char  MLME_offload;   // 2. FW offloads, 0: driver handles
+ unsigned char  hwpc_offload;   // 3. FW offloads, 0: driver handles
+ unsigned char  tcp_checksum_offload; // 4. FW offloads, 0: driver handles
+ unsigned char  tcp_offload;    // 5. FW offloads, 0: driver handles
+ unsigned char  ps_control_offload;  // 6. FW offloads, 0: driver handles
+ unsigned char  WWLAN_offload;   // 7. FW offloads, 0: driver handles
+ unsigned char  rsvd040;
+
+	//--- long word 5 ----
+ unsigned char  tcp_tx_frame_len_L;  //tcp tx packet length low byte
+ unsigned char  tcp_tx_frame_len_H;  //tcp tx packet length high byte
+ unsigned char  tcp_rx_frame_len_L;  //tcp rx packet length low byte
+ unsigned char  tcp_rx_frame_len_H;  //tcp rx packet length high byte
+ unsigned char  rsvd050;
+ unsigned char  rsvd051;
+ unsigned char  rsvd052;
+ unsigned char  rsvd053;
+	
+};
+
+
+struct fw_hdr{//8-byte alinment required
+
+	unsigned short	signature;//
+	unsigned short	version;//0x8000 ~ 0x8FFF for FPGA version,	//0x0000 ~ 0x7FFF for ASIC version,
+	
+	unsigned int		dmem_size;    //define the size of boot loader
+
+	unsigned int		img_IMEM_size;    //define the size of FW in IMEM
+	
+	unsigned int		img_SRAM_size;    //define the size of FW in SRAM
+
+	unsigned int		fw_priv_sz;       //define the size of DMEM variable 
+	
+	unsigned short	efuse_addr;
+	unsigned short 	h2ccnd_resp_addr;
+	
+	unsigned short	debug_dump_addr;
+	unsigned short	rsvd1;
+	
+	unsigned int  		release_time; //Mon:Day:Hr:Min
+
+	struct fw_priv 	fwpriv;	
+	
+};
+
+struct hal_priv{
+
+	//Endpoint handles
+	_nic_hdl	pipehdls_r8712[10];
+	
+	u8 (*hal_bus_init)(_adapter *adapter);
+	u8  (*hal_bus_deinit)(_adapter *adapter);
+	
+};
+
+uint	 rtl8712_hal_init(_adapter *padapter);
+
+#endif
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_recv.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_recv.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_recv.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_recv.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,280 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_RECV_H_
+#define _RTL8712_RECV_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#ifdef PLATFORM_OS_XP
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF 1024//512//128
+	#else
+		#define NR_RECVBUFF (16)
+	#endif
+#elif defined(PLATFORM_OS_CE)
+	#ifdef CONFIG_SDIO_HCI
+		#define NR_RECVBUFF (128)
+#else
+		#define NR_RECVBUFF (4)
+	#endif
+#else
+	#define NR_RECVBUFF (4)
+	#define NR_PREALLOC_RECV_SKB (8)
+#endif
+
+#define RXDESC_SIZE	24
+#define RXDESC_OFFSET RXDESC_SIZE
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+//#define MAX_RECVBUF_SZ 2048 // 2k
+//#define MAX_RECVBUF_SZ (8192) // 8K
+//#define MAX_RECVBUF_SZ (16384) //16K
+//#define MAX_RECVBUF_SZ (16384 + 1024) //16K + 1k
+//#define MAX_RECVBUF_SZ (30720) //30k
+//#define MAX_RECVBUF_SZ (30720 + 1024) //30k+1k
+//#define MAX_RECVBUF_SZ (32768) // 32k
+
+#if defined(CONFIG_SDIO_HCI)
+
+#define MAX_RECVBUF_SZ (50000) //30k //(2048)//(30720) //30k
+
+#elif defined(CONFIG_USB_HCI)
+
+#ifdef PLATFORM_OS_CE
+#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#else
+//#define MAX_RECVBUF_SZ (32768) // 32k
+#define MAX_RECVBUF_SZ (16384) //16K
+#endif
+
+#endif
+
+#define RECVBUFF_ALIGN_SZ 512
+
+#define RSVD_ROOM_SZ (0)
+
+
+//These definition is used for Rx packet reordering.
+#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
+#define SN_EQUAL(a, b)	(a == b)
+//#define REORDER_WIN_SIZE	128
+//#define REORDER_ENTRY_NUM	128
+#define REORDER_WAIT_TIME	10 // (ms)
+
+
+struct recv_stat
+{	
+	unsigned int rxdw0;
+
+	unsigned int rxdw1;
+
+	unsigned int rxdw2;
+
+	unsigned int rxdw3;
+
+	unsigned int rxdw4;
+
+	unsigned int rxdw5;	
+};
+
+struct phy_cck_rx_status
+{
+	/* For CCK rate descriptor. This is a unsigned 8:1 variable. LSB bit presend
+	   0.5. And MSB 7 bts presend a signed value. Range from -64~+63.5. */
+	u8	adc_pwdb_X[4];
+	u8	sq_rpt;	
+	u8	cck_agc_rpt;
+};
+
+struct phy_stat
+{
+	unsigned int phydw0;
+
+	unsigned int phydw1;
+
+	unsigned int phydw2;
+
+	unsigned int phydw3;
+
+	unsigned int phydw4;
+
+	unsigned int phydw5;	
+	
+	unsigned int phydw6;
+
+	unsigned int phydw7;	
+};
+#define PHY_STAT_GAIN_TRSW_SHT 0
+#define PHY_STAT_PWDB_ALL_SHT 4
+#define PHY_STAT_CFOSHO_SHT 5
+#define PHY_STAT_CCK_AGC_RPT_SHT 5
+#define PHY_STAT_CFOTAIL_SHT 9
+#define PHY_STAT_RXEVM_SHT 13
+#define PHY_STAT_RXSNR_SHT 15
+#define PHY_STAT_PDSNR_SHT 19
+#define PHY_STAT_CSI_CURRENT_SHT 21
+#define PHY_STAT_CSI_TARGET_SHT 23
+#define PHY_STAT_SIGEVM_SHT 25
+#define PHY_STAT_MAX_EX_PWR_SHT 26
+
+
+union recvstat {
+	struct recv_stat recv_stat;
+	unsigned int value[RXDESC_SIZE>>2];	
+};
+
+
+struct recv_buf{
+
+	_list list;
+	
+	_lock recvbuf_lock;
+	
+	u32	ref_cnt;
+
+	_adapter  *adapter;
+
+#ifdef CONFIG_SDIO_HCI
+#ifdef PLATFORM_OS_XP
+	PMDL mdl_ptr;	
+#endif	
+	u8	cmd_fail;
+#endif
+
+
+#ifdef CONFIG_USB_HCI
+
+	#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	purb;
+
+	#endif
+
+	#ifdef PLATFORM_OS_XP
+		PIRP		pirp;
+	#endif
+
+	#ifdef PLATFORM_OS_CE
+		USB_TRANSFER	usb_transfer_read_port;
+	#endif
+
+	u8  irp_pending;
+	int  transfer_len;	
+	
+#endif	
+
+#ifdef PLATFORM_LINUX
+	_pkt *pskb;		
+	u8 reuse;
+#endif
+
+	uint  len;	
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+	
+	u8 *pbuf;	
+	u8 *pallocated_buf;
+
+
+};
+
+
+/*
+	head  ----->
+
+		data  ----->
+	
+			payload
+	
+		tail  ----->
+	
+	
+	end   ----->
+
+	len = (unsigned int )(tail - data);
+
+*/
+struct recv_frame_hdr{
+
+	_list	list;
+	_pkt	*pkt;
+	_pkt *pkt_newalloc;
+
+	_adapter  *adapter;
+	u8 fragcnt;
+
+	struct rx_pkt_attrib attrib;
+
+	uint  len;	
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+
+	void *precvbuf;		
+
+
+	//
+	struct sta_info *psta;
+		
+	//for A-MPDU Rx reordering buffer control
+	struct recv_reorder_ctrl *preorder_ctrl;	
+
+};
+
+
+union recv_frame{
+
+	union{	
+		_list list;
+		struct recv_frame_hdr hdr;
+		uint mem[RECVFRAME_HDR_ALIGN>>2];
+	}u;
+
+	//uint mem[MAX_RXSZ>>2];
+
+};
+
+
+int rtw_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf);
+void rxcmd_event_hdl(_adapter *padapter, void *prxcmdbuf);
+
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext);
+
+#ifdef PLATFORM_LINUX
+#ifdef CONFIG_RECV_TASKLET
+void recv_tasklet(void *priv);
+#else
+void recv_bh(void *priv);
+#endif
+#endif
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_regdef.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_regdef.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_regdef.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_regdef.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef __RTL8712_REGDEF_H__
+#define __RTL8712_REGDEF_H__
+
+
+#include "rtl8712_spec/ioreg_def/rtl8712_syscfg_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_cmdctrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_macsetting_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_timectrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_fifoctrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_ratectrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_edcasetting_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_wmac_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_security_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_powersave_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_gp_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_interrupt_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_debugctrl_regdef.h"
+#include "rtl8712_spec/ioreg_def/rtl8712_offload_regdef.h"
+
+
+#endif // __RTL8712_REGDEF_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_rf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_rf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_rf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_rf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTL8712_RF_H_ 
+#define __RTL8712_RF_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <rtw_mp_phy_regdef.h>
+
+#define WIFI_20MHZ_MODE			0x0000
+#define WIFI_40MHZ_MODE			0x8000
+
+// Bandwidth Offset
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER		1
+#define HAL_PRIME_CHNL_OFFSET_UPPER		2
+
+/*
+u32 get_bbreg(PADAPTER pAdapter ,u16 offset ,u32 bitmask);
+u8 set_bbreg(PADAPTER pAdapter ,u16 offset ,u32 bitmask, u32 value);
+u32 get_rfreg(PADAPTER pAdapter ,u8 path,u8 offset,u32 bitmask);
+u8 set_rfreg(PADAPTER pAdapter ,u8 path,u8 offset,u32 bitmask,u32 value);
+*/
+
+u32 get_efuse_content(_adapter *padapter, u16 offset);
+void dump_efuse_content(_adapter *padapter, unsigned int *pbuf, int sz);
+
+
+
+void set_channel_and_txpower(_adapter *padapter, u8 level, u8 ch);
+void switchBWOPMODE(_adapter *padapter, unsigned short bwmode, unsigned char channel_offset);
+
+
+//int set_init_ra_tbl(PADAPTER pAdapter, unsigned short param, unsigned int bitmap);
+
+//u8 get_rf_mimo_mode(_adapter *padapter);
+
+#endif //_RTL8712_RF_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_spec.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_spec.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_spec.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_spec.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,128 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SPEC_H__
+#define __RTL8712_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8712_IOBASE_TXPKT			0x10200000	//IOBASE_TXPKT
+#define RTL8712_IOBASE_RXPKT			0x10210000	//IOBASE_RXPKT
+#define RTL8712_IOBASE_RXCMD			0x10220000	//IOBASE_RXCMD
+#define RTL8712_IOBASE_TXSTATUS		0x10230000	//IOBASE_TXSTATUS
+#define RTL8712_IOBASE_RXSTATUS		0x10240000	//IOBASE_RXSTATUS
+#define RTL8712_IOBASE_IOREG			0x10250000	//IOBASE_IOREG ADDR
+#define RTL8712_IOBASE_SCHEDULER		0x10260000	//IOBASE_SCHEDULER
+#define RTL8712_IOBASE_TRXDMA			0x10270000	//IOBASE_TRXDMA
+#define RTL8712_IOBASE_TXLLT			0x10280000	//IOBASE_TXLLT
+#define RTL8712_IOBASE_WMAC			0x10290000	//IOBASE_WMAC
+#define RTL8712_IOBASE_FW2HW			0x102A0000	//IOBASE_FW2HW
+#define RTL8712_IOBASE_ACCESS_PHYREG	0x102B0000	//IOBASE_ACCESS_PHYREG
+
+#define RTL8712_IOBASE_FF	0x10300000	//IOBASE_FIFO 0x1031000~0x103AFFFF 
+
+
+//IOREG Offset for 8712
+#define RTL8712_SYSCFG_		RTL8712_IOBASE_IOREG
+#define RTL8712_CMDCTRL_		(RTL8712_IOBASE_IOREG + 0x40)
+#define RTL8712_MACIDSETTING_	(RTL8712_IOBASE_IOREG + 0x50)
+#define RTL8712_TIMECTRL_		(RTL8712_IOBASE_IOREG + 0x80)
+#define RTL8712_FIFOCTRL_		(RTL8712_IOBASE_IOREG + 0xA0)
+#define RTL8712_RATECTRL_		(RTL8712_IOBASE_IOREG + 0x160)
+#define RTL8712_EDCASETTING_	(RTL8712_IOBASE_IOREG + 0x1D0)
+#define RTL8712_WMAC_			(RTL8712_IOBASE_IOREG + 0x200)
+#define RTL8712_SECURITY_		(RTL8712_IOBASE_IOREG + 0x240)
+#define RTL8712_POWERSAVE_	(RTL8712_IOBASE_IOREG + 0x260)
+#define RTL8712_GP_				(RTL8712_IOBASE_IOREG + 0x2E0)
+#define RTL8712_INTERRUPT_		(RTL8712_IOBASE_IOREG + 0x300)
+#define RTL8712_DEBUGCTRL_		(RTL8712_IOBASE_IOREG + 0x310)
+#define RTL8712_OFFLOAD_		(RTL8712_IOBASE_IOREG + 0x2D0)
+
+
+//FIFO for 8712
+#define RTL8712_DMA_BCNQ		(RTL8712_IOBASE_FF + 0x10000)
+#define RTL8712_DMA_MGTQ		(RTL8712_IOBASE_FF + 0x20000)
+#define RTL8712_DMA_BMCQ		(RTL8712_IOBASE_FF + 0x30000)
+#define RTL8712_DMA_VOQ		(RTL8712_IOBASE_FF + 0x40000)
+#define RTL8712_DMA_VIQ		(RTL8712_IOBASE_FF + 0x50000)
+#define RTL8712_DMA_BEQ		(RTL8712_IOBASE_FF + 0x60000)
+#define RTL8712_DMA_BKQ		(RTL8712_IOBASE_FF + 0x70000)
+#define RTL8712_DMA_RX0FF		(RTL8712_IOBASE_FF + 0x80000)
+#define RTL8712_DMA_H2CCMD	(RTL8712_IOBASE_FF + 0x90000)
+#define RTL8712_DMA_C2HCMD	(RTL8712_IOBASE_FF + 0xA0000)
+
+
+//------------------------------
+
+//BIT 16 15
+#define	DID_SDIO_LOCAL			0	// 0 0
+#define	DID_WLAN_IOREG			1	// 0 1
+#define	DID_WLAN_FIFO			3	// 1 1
+#define   DID_UNDEFINE				(-1)
+
+#define CMD_ADDR_MAPPING_SHIFT			2	//SDIO CMD ADDR MAPPING ,shift 2 bit for match offset[14:2]
+
+//Offset for SDIO LOCAL
+#define	OFFSET_SDIO_LOCAL				0x0FFF
+
+//Offset for WLAN IOREG
+#define OFFSET_WLAN_IOREG				0x0FFF
+
+//Offset for WLAN FIFO
+#define	OFFSET_TX_BCNQ				0x0300
+#define	OFFSET_TX_HIQ					0x0310
+#define	OFFSET_TX_CMDQ				0x0320
+#define	OFFSET_TX_MGTQ				0x0330
+#define	OFFSET_TX_HCCAQ				0x0340
+#define	OFFSET_TX_VOQ					0x0350
+#define	OFFSET_TX_VIQ					0x0360
+#define	OFFSET_TX_BEQ					0x0370
+#define	OFFSET_TX_BKQ					0x0380
+#define	OFFSET_RX_RX0FFQ				0x0390
+#define	OFFSET_RX_C2HFFQ				0x03A0
+
+#define	BK_QID_01	1
+#define	BK_QID_02	2
+#define	BE_QID_01	0
+#define	BE_QID_02	3
+#define	VI_QID_01	4
+#define	VI_QID_02	5
+#define	VO_QID_01	6
+#define	VO_QID_02	7
+#define	HCCA_QID_01	8
+#define	HCCA_QID_02	9
+#define	HCCA_QID_03	10
+#define	HCCA_QID_04	11
+#define	HCCA_QID_05	12
+#define	HCCA_QID_06	13
+#define	HCCA_QID_07	14
+#define	HCCA_QID_08	15
+#define	HI_QID		17
+#define	CMD_QID	19
+#define	MGT_QID	18
+#define	BCN_QID	16
+
+#include "rtl8712_regdef.h"
+
+#include "rtl8712_bitdef.h"
+
+#include "basic_types.h"
+
+#endif // __RTL8712_SPEC_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_xmit.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_xmit.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtl8712_xmit.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtl8712_xmit.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,300 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_XMIT_H_
+#define _RTL8712_XMIT_H_
+
+#define HWXMIT_ENTRY	4
+
+#define VO_QUEUE_INX	0
+#define VI_QUEUE_INX	1
+#define BE_QUEUE_INX	2
+#define BK_QUEUE_INX	3
+#define TS_QUEUE_INX	4
+#define MGT_QUEUE_INX	5
+#define BMC_QUEUE_INX	6
+#define BCN_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+#define TXDESC_SIZE 32
+#define TXDESC_OFFSET TXDESC_SIZE
+
+#define NR_AMSDU_XMITFRAME 8
+#define NR_TXAGG_XMITFRAME 8
+
+#define MAX_AMSDU_XMITBUF_SZ 8704
+#define MAX_TXAGG_XMITBUF_SZ 16384 //16k
+
+
+#define tx_cmd tx_desc
+
+
+//
+//defined for TX DESC Operation
+//
+
+#define MAX_TID (15)
+
+//OFFSET 0
+#define OFFSET_SZ (0)
+#define OFFSET_SHT (16)
+#define OWN 	BIT(31)
+#define FSG	BIT(27)
+#define LSG	BIT(26)
+
+//OFFSET 4
+#define PKT_OFFSET_SZ (0)
+#define QSEL_SHT (8)
+#define HWPC BIT(31)
+
+//OFFSET 8
+#define BMC BIT(7)
+#define BK BIT(30)
+#define AGG_EN BIT(29)
+
+//OFFSET 12
+#define SEQ_SHT (16)
+
+//OFFSET 16
+#define TXBW BIT(18)
+
+//OFFSET 20
+#define DISFB BIT(15)
+
+struct tx_desc{
+
+	//DWORD 0
+	unsigned int txdw0;
+
+	unsigned int txdw1;
+
+	unsigned int txdw2;
+
+	unsigned int txdw3;
+
+	unsigned int txdw4;
+
+	unsigned int txdw5;
+
+	unsigned int txdw6;
+
+	unsigned int txdw7;	
+
+};
+
+
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE>>2];	
+};
+
+
+#if 0
+#define tx_desc tx_cmd
+
+struct tx_cmd {
+
+#ifdef CONFIG_LITTLE_ENDIAN
+	// DWORD 1
+	unsigned int	txpktsize:16;
+	unsigned int	offset:8;
+	unsigned int	frame_type:2;
+	unsigned int	ls:1;
+	unsigned int	fs:1;
+	unsigned int	linip:1;
+	unsigned int	amsdu:1;
+	unsigned int	gf:1;
+	unsigned int	own:1;	
+	// DWORD 2
+	unsigned int	macid:5;			
+	unsigned int	moredata:1;
+	unsigned int	morefrag:1;
+	unsigned int	pifs:1;
+	unsigned int	qsel:5;
+	unsigned int	ack_policy:2;
+	unsigned int	noacm:1;
+	unsigned int	non_qos:1;
+	unsigned int	key_id:2;
+	unsigned int	oui:1;
+	unsigned int	pkt_type:1;
+	unsigned int	en_desc_id:1;
+	unsigned int	sectype:2;
+	unsigned int	wds:1;//padding0
+	unsigned int	htc:1;//padding1
+	unsigned int	pkt_offset:5;//padding_len (hw)	
+	unsigned int	hwpc:1;		
+	// DWORD 3
+	unsigned int	data_retry_lmt:6;
+	unsigned int	rty_lmt_en:1;
+	unsigned int	tsfl:5;
+	unsigned int	rts_rc:6;
+	unsigned int	data_rc:6;
+	unsigned int	rsvd2:5;
+	unsigned int	agg_en:1;
+	unsigned int	bk:1;
+	unsigned int	own_mac:1;
+	// DWORD 4
+	unsigned int	nextheadpage:8;
+	unsigned int	tailpage:8;
+	unsigned int	seq:12;
+	unsigned int	frag:4;	
+	// DWORD 5
+	unsigned int	rtsrate:6;
+	unsigned int	disrtsfb:1;
+	unsigned int	rts_ratefb_lmt:4;
+	unsigned int	cts2self:1;
+	unsigned int	rtsen:1;
+	unsigned int	ra_brsr_id:3;
+	unsigned int	txht:1;
+	unsigned int	txshort:1;//for data
+	unsigned int	txbw:1;
+	unsigned int	txsc:2;
+	unsigned int	stbc:2;
+	unsigned int	rd:1;
+	unsigned int	rtsht:1;
+	unsigned int	rtsshort:1;
+	unsigned int	rtsbw:1;
+	unsigned int	rts_sc:2;
+	unsigned int	rts_stbc:2;
+	unsigned int	userate:1;	
+	// DWORD 6
+	unsigned int	packet_id:9;
+	unsigned int	txrate:6;
+	unsigned int	disfb:1;
+	unsigned int	data_ratefb_lmt:5;
+	unsigned int	txagc:11;	
+	// DWORD 7
+	unsigned int	ip_chksum:16;
+	unsigned int	tcp_chksum:16;
+	// DWORD 8
+	unsigned int	txbuffsize:16;//pcie
+	unsigned int	ip_hdr_offset:8;
+	unsigned int	rsvd3:7;
+	unsigned int	tcp_en:1;
+/*	
+	// DWORD 9
+	unsigned int	tx_buffer_address:32;	//pcie
+	// DWORD 10
+	unsigned int	next_tx_desc_address:32;	//pcie
+*/	
+
+#else
+
+#endif
+
+} ;
+
+
+union txcmd {
+	struct tx_cmd cmd;
+	uint value[8];	
+};
+
+#endif
+
+struct amsdu_xmit_frame {
+	
+	_list	list;
+	struct	pkt_attrib	attrib;
+	_pkt *pkt;
+	
+	int frame_tag;
+	 _adapter *	padapter;
+	
+#ifdef CONFIG_USB_HCI
+	//insert urb, irp, and irpcnt info below...      
+       u8 *mem_addr;      
+       u32 sz[8];	   
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	pxmit_urb[8];
+#endif
+
+	
+#ifdef PLATFORM_WINDOWS
+	PIRP		pxmit_irp[8];
+#endif
+	u8 bpending[8];
+	sint ac_tag[8];
+	sint last[8];
+       uint irpcnt;         
+       uint fragcnt;
+		   
+#endif
+
+	uint	mem[(MAX_AMSDU_XMITBUF_SZ>>2)];	
+
+};
+
+struct agg_xmit_frame {
+	
+	_list	list;
+	struct	pkt_attrib	attrib;
+	_pkt *pkt;
+	
+	int frame_tag;
+	_adapter *padapter;
+	
+#ifdef CONFIG_USB_HCI
+	//insert urb, irp, and irpcnt info below...       
+       u8 *mem_addr;      
+       u32 sz[8];	   
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_WINDOWS
+	PIRP		pxmit_irp[8];
+#endif
+	u8 bpending[8];
+	sint ac_tag[8];
+	sint last[8];
+       uint irpcnt;         
+       uint fragcnt;
+	   
+#endif
+
+	uint	mem[(MAX_TXAGG_XMITBUF_SZ>>2)];
+
+};
+
+
+
+struct amsdu_xmit_frame *alloc_amsdu_xmitframe(struct xmit_priv *pxmitpriv);
+int free_amsdu_xmitframe(struct xmit_priv *pxmitpriv, struct amsdu_xmit_frame *pxmitframe);
+struct agg_xmit_frame *alloc_txagg_xmitframe(struct xmit_priv *pxmitpriv);
+int free_txagg_xmitframe(struct xmit_priv *pxmitpriv, struct agg_xmit_frame *pxmitframe);
+
+void rtw_update_txdesc(struct xmit_frame *pxmitframe, uint *ptxdesc, int sz);
+void rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe);
+
+int rtw_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+
+struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, _queue *pframe_queue);
+struct xmit_frame *dequeue_amsdu_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, _queue *pframe_queue);
+struct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, sint entry);
+
+void rtw_do_queue_select(_adapter *padapter, struct pkt_attrib *pattrib);
+u32 rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe);
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_byteorder.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_byteorder.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_byteorder.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_byteorder.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_BYTEORDER_H_
+#define _RTL871X_BYTEORDER_H_
+
+#include <drv_conf.h>
+
+#if defined (CONFIG_LITTLE_ENDIAN) && defined (CONFIG_BIG_ENDIAN)
+#error "Shall be CONFIG_LITTLE_ENDIAN or CONFIG_BIG_ENDIAN, but not both!\n"
+#endif
+
+#if defined (CONFIG_LITTLE_ENDIAN)
+#ifndef CONFIG_PLATFORM_MSTAR389
+#  include <byteorder/little_endian.h>
+#endif
+#elif defined (CONFIG_BIG_ENDIAN)
+#  include <byteorder/big_endian.h>
+#else
+#  error "Must be LITTLE/BIG Endian Host"
+#endif
+
+#endif /* _RTL871X_BYTEORDER_H_ */
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_cmd.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_cmd.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_cmd.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_cmd.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,975 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_CMD_H_
+#define __RTL871X_CMD_H_
+
+#include <drv_conf.h>
+#include <wlan_bssdef.h>
+#include <rtw_rf.h>
+
+#define C2H_MEM_SZ (16*1024)
+
+#ifndef CONFIG_RTL8711FW
+
+	#include <osdep_service.h>
+	#include <ieee80211.h> // <ieee80211/ieee80211.h>
+
+
+	#define FREE_CMDOBJ_SZ	128
+	
+	#define MAX_CMDSZ	1024
+	#define MAX_RSPSZ	512
+	#define MAX_EVTSZ	1024
+
+#ifdef PLATFORM_OS_CE
+	#define CMDBUFF_ALIGN_SZ 4
+#else
+	#define CMDBUFF_ALIGN_SZ 512
+#endif
+
+	struct cmd_obj {
+		u16	cmdcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	cmdsz;
+		u8	*rsp;
+		u32	rspsz;
+		//_sema 	cmd_sem;
+		_list	list;
+	};
+
+	struct cmd_priv {
+		_sema	cmd_queue_sema;
+		//_sema	cmd_done_sema;
+		_sema	terminate_cmdthread_sema;		
+		_queue	cmd_queue;
+		u8	cmd_seq;
+		u8	*cmd_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*cmd_allocated_buf;
+		u8	*rsp_buf;	//shall be non-paged, and 4 bytes aligned		
+		u8	*rsp_allocated_buf;
+		u32	cmd_issued_cnt;
+		u32	cmd_done_cnt;
+		u32	rsp_cnt;
+		_adapter *padapter;
+	};
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	struct evt_obj {
+		u16	evtcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	evtsz;		
+		_list	list;
+	};
+#endif
+
+	struct	evt_priv {
+#ifdef CONFIG_EVENT_THREAD_MODE
+		_sema	evt_notify;
+		_sema	terminate_evtthread_sema;
+		_queue	evt_queue;
+#endif		
+		
+#ifdef CONFIG_H2CLBK
+		_sema	lbkevt_done;
+		u8	lbkevt_limit;
+		u8	lbkevt_num;
+		u8	*cmdevt_parm;		
+#endif		
+		u8	event_seq;
+		u8	*evt_buf;	//shall be non-paged, and 4 bytes aligned		
+		u8	*evt_allocated_buf;
+		u32	evt_done_cnt;
+#ifdef CONFIG_SDIO_HCI
+		u8	*c2h_mem;
+		u8	*allocated_c2h_mem;
+#ifdef PLATFORM_OS_XP
+		PMDL	pc2h_mdl;
+#endif
+#endif
+
+	};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+do {\
+	_rtw_init_listhead(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = (u8 *)(pparm);\
+	pcmd->cmdsz = sizeof (*pparm);\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while(0)
+
+extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern u32 rtw_enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern struct cmd_obj *rtw_dequeue_cmd(_queue *queue);
+extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+extern u32 enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj);
+extern struct evt_obj *dequeue_evt(_queue *queue);
+extern void free_evt_obj(struct evt_obj *pcmd);
+#endif
+
+thread_return rtw_cmd_thread(thread_context context);
+
+extern u32 cmd_enqueue(_queue *cmdq,struct cmd_obj	*pcmd);
+
+extern u32 rtw_init_cmd_priv (struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_priv (struct cmd_priv *pcmdpriv);
+
+extern u32 rtw_init_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_free_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
+extern void evt_notify_isr(struct evt_priv *pevtpriv);
+
+#else
+	#include <ieee80211.h>
+#endif	/* CONFIG_RTL8711FW */
+
+
+enum rtw_drvextra_cmd_id
+{	
+	NONE_WK_CID,
+	DYNAMIC_CHK_WK_CID,
+	DM_CTRL_WK_CID,
+	PBC_POLLING_WK_CID,
+	POWER_SAVING_CTRL_WK_CID,//IPS,AUTOSuspend
+	LPS_CTRL_WK_CID,
+	ANT_SELECT_WK_CID,
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+	USB_IO_CHECK_WK_CID,
+#endif
+	MAX_WK_CID
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To enter USB suspend mode
+
+Command Mode
+
+*/
+struct usb_suspend_parm {
+	u32 action;// 1: sleep, 0:resume
+};
+
+/*
+Caller Mode: Infra, Ad-HoC
+
+Notes: To join a known BSS.
+
+Command-Event Mode
+
+*/
+
+/*
+Caller Mode: Infra, Ad-Hoc
+
+Notes: To join the specified bss
+
+Command Event Mode
+
+*/
+struct joinbss_parm {
+	WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To disconnect the current associated BSS
+
+Command Mode
+
+*/
+struct disconnect_parm {
+	u32 rsvd;
+};
+
+/*
+Caller Mode: AP, Ad-HoC(M)
+
+Notes: To create a BSS
+
+Command Mode
+*/
+struct createbss_parm {
+	WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To set the NIC mode of RTL8711
+
+Command Mode
+
+The definition of mode:
+
+#define IW_MODE_AUTO	0	// Let the driver decides which AP to join
+#define IW_MODE_ADHOC	1	// Single cell network (Ad-Hoc Clients)
+#define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
+#define IW_MODE_MASTER	3	// Synchronisation master or Access Point
+#define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
+#define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
+#define IW_MODE_MONITOR	6	// Passive monitor (listen only)
+
+*/
+struct	setopmode_parm {
+	u8	mode;
+	u8	rsvd[3];
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To ask RTL8711 performing site-survey
+
+Command-Event Mode 
+
+*/
+struct sitesurvey_parm {
+	sint scan_mode;	//active: 1, passive: 0 
+	sint bsslimit;	// 1 ~ 48
+	sint	ss_ssidlen;
+	u8 	ss_ssid[IW_ESSID_MAX_SIZE + 1];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the auth type of RTL8711. open/shared/802.1x
+
+Command Mode
+
+*/
+struct setauth_parm {
+	u8 mode;  //0: legacy open, 1: legacy shared 2: 802.1x
+	u8 _1x;   //0: PSK, 1: TLS
+	u8 rsvd[2];
+};
+
+/*
+Caller Mode: Infra
+
+a. algorithm: wep40, wep104, tkip & aes
+b. keytype: grp key/unicast key
+c. key contents
+
+when shared key ==> keyid is the camid
+when 802.1x ==> keyid [0:1] ==> grp key
+when 802.1x ==> keyid > 2 ==> unicast key
+
+*/
+struct setkey_parm {
+	u8	algorithm;	// encryption algorithm, could be none, wep40, TKIP, CCMP, wep104
+	u8	keyid;		
+	u8 	grpkey;		// 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x
+	u8	key[16];	// this could be 40 or 104
+};
+
+/*
+When in AP or Ad-Hoc mode, this is used to 
+allocate an sw/hw entry for a newly associated sta.
+
+Command
+
+when shared key ==> algorithm/keyid 
+
+*/
+struct set_stakey_parm {
+	u8	addr[ETH_ALEN];
+	u8	algorithm;
+	u8	key[16];
+};
+
+struct set_stakey_rsp {
+	u8	addr[ETH_ALEN];
+	u8	keyid;
+	u8	rsvd;
+};
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	u8	cam_id;
+	u8	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+	
+	Command mode
+	
+	This is to force fw to del an sta_data entry per driver's request
+	
+	FW will invalidate the cam entry associated with it.
+
+*/
+struct del_assocsta_parm {
+	u8  	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	u8	staid;
+	u8	status;
+	u8	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	u8	basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	u8 basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+#ifdef MP_FIRMWARE_OFFLOAD
+	u32	curr_rateidx;
+#else
+	u8	mac_id;
+	u8	datarates[NumRates];
+#endif
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+	
+};
+struct getdatarate_rsp {
+	u8 datarates[NumRates];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+struct	setphyinfo_parm {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+struct	getphyinfo_parm {
+	u32 rsvd;
+};
+
+struct	getphyinfo_rsp {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+struct	setphy_parm {
+	u8	rfchannel;
+	u8	modem;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_parm {
+	u32 rsvd;
+
+};
+struct	getphy_rsp {
+	u8	rfchannel;
+	u8	modem;
+};
+
+struct readBB_parm {
+	u8	offset;
+};
+struct readBB_rsp {
+	u8	value;
+};
+
+struct readTSSI_parm {
+	u8	offset;
+};
+struct readTSSI_rsp {
+	u8	value;
+};
+
+struct writeBB_parm {
+	u8	offset;
+	u8	value;
+};
+
+struct writePTM_parm {
+	u8	type;
+};
+
+struct readRF_parm {
+	u8	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct setrfintfs_parm {
+	u8	rfintfs;
+};
+
+struct getrfintfs_parm {
+	u8	rfintfs;
+};
+
+
+struct Tx_Beacon_param
+{
+	WLAN_BSSID_EX network;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0 
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+	
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+	
+	The rsp layout shall be:
+	rsp: 			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=  	swap32(w1);
+		b0		= 	b1
+		s2		= 	s0 + s1
+		b1		= 	b0
+		w1		=	w0
+		
+	mac[0] == 	2
+	==> CMD_EVENT mode, return 	H2C_SUCCESS
+	The event layout shall be:
+	event:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   swap16(s0) - event.mac[2];
+		s1		=   s1 + event.mac[2];
+		w0		=  	swap32(w0);
+		b0		= 	b1
+		s2		= 	s0 + event.mac[2]
+		b1		= 	b0 
+		w1		=	swap32(w1) - event.mac[2];	
+	
+		parm->mac[3] is the total event counts that host requested.
+		
+	
+	event will be the same with the cmd's param.
+		
+*/
+
+#ifdef CONFIG_H2CLBK
+
+struct seth2clbk_parm {
+	u8 mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16  s2;
+	u8	b1;
+	u32	w1;
+};
+
+struct geth2clbk_parm {
+	u32 rsv;	
+};
+
+struct geth2clbk_rsp {
+	u8	mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16	s2;
+	u8	b1;
+	u32	w1;
+};
+
+#endif	/* CONFIG_H2CLBK */
+
+// CMD param Formart for driver extra cmd handler
+struct drvextra_cmd_parm {
+	int ec_id; //extra cmd id
+	int sz; // buf sz
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	u8	tx_antset;		
+	u8	rx_antset;
+	u8	tx_antenna;		
+	u8	rx_antenna;		
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;		// 0: pure hw, 1: fw
+};
+
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	u8	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+
+struct setssdlevel_parm	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+
+struct	setcountjudge_parm {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+struct	getcountjudge_rsp {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+
+struct setratable_parm {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+struct getratable_parm {
+                uint rsvd;
+};
+struct getratable_rsp {
+        u8 ss_ForceUp[NumRates];
+        u8 ss_ULevel[NumRates];
+        u8 ss_DLevel[NumRates];
+        u8 count_judge[NumRates];
+};
+
+
+//to get TX,RX retry count
+struct gettxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct gettxretrycnt_rsp{
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct getrxretrycnt_rsp{
+	unsigned long rx_retrycnt;
+};
+
+//to get BCNOK,BCNERR count
+struct getbcnokcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnokcnt_rsp{
+	unsigned long  bcnokcnt;
+};
+
+struct getbcnerrcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp{
+	unsigned long bcnerrcnt;
+};
+
+// to get current TX power level
+struct getcurtxpwrlevel_parm{
+	unsigned int rsvd;
+};
+struct getcurtxpwrlevel_rsp{
+	unsigned short tx_power;
+};
+
+//dynamic on/off DIG
+struct setdig_parm{
+	unsigned char dig_on;		// 1:on , 0:off
+};
+
+//dynamic on/off RA
+struct setra_parm{
+	unsigned char ra_on;		// 1:on , 0:off
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+
+struct addBaReq_parm
+{
+ 	unsigned int tid;
+	u8	addr[ETH_ALEN];
+};
+
+/*H2C Handler index: 46 */
+struct SetChannel_parm
+{
+	u32 curr_ch;	
+};
+
+#ifdef MP_FIRMWARE_OFFLOAD
+/*H2C Handler index: 47 */
+struct SetTxPower_parm
+{
+	u8 TxPower;
+};
+
+/*H2C Handler index: 48 */
+struct SwitchAntenna_parm
+{
+	u16 antenna_tx;
+	u16 antenna_rx;
+//	R_ANTENNA_SELECT_CCK cck_txrx;
+	u8 cck_txrx;
+};
+
+/*H2C Handler index: 49 */
+struct SetCrystalCap_parm
+{
+	u32 curr_crystalcap;
+};
+
+/*H2C Handler index: 50 */
+struct SetSingleCarrierTx_parm
+{
+	u8 bStart;
+};
+
+/*H2C Handler index: 51 */
+struct SetSingleToneTx_parm
+{
+	u8 bStart;
+	u8 curr_rfpath;
+};
+
+/*H2C Handler index: 52 */
+struct SetCarrierSuppressionTx_parm
+{
+	u8 bStart;
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 53 */
+struct SetContinuousTx_parm
+{
+	u8 bStart;
+	u8 CCK_flag; /*1:CCK 2:OFDM*/
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 54 */
+struct SwitchBandwidth_parm
+{
+	u8 curr_bandwidth;
+};
+
+#endif	/* MP_FIRMWARE_OFFLOAD */
+
+#ifndef CONFIG_RTL8711FW
+#else
+struct cmdobj {
+	uint	parmsize;
+	u8 (*h2cfuns)(u8 *pbuf);	
+};
+extern u8 joinbss_hdl(u8 *pbuf);	
+extern u8 disconnect_hdl(u8 *pbuf);
+extern u8 createbss_hdl(u8 *pbuf);
+extern u8 setopmode_hdl(u8 *pbuf);
+extern u8 sitesurvey_hdl(u8 *pbuf);	
+extern u8 setauth_hdl(u8 *pbuf);
+extern u8 setkey_hdl(u8 *pbuf);
+extern u8 set_stakey_hdl(u8 *pbuf);
+extern u8 set_assocsta_hdl(u8 *pbuf);
+extern u8 del_assocsta_hdl(u8 *pbuf);
+extern u8 setstapwrstate_hdl(u8 *pbuf);
+extern u8 setbasicrate_hdl(u8 *pbuf);	
+extern u8 getbasicrate_hdl(un8 *pbuf);
+extern u8 setdatarate_hdl(u8 *pbuf);
+extern u8 getdatarate_hdl(u8 *pbuf);
+extern u8 setphyinfo_hdl(u8 *pbuf);	
+extern u8 getphyinfo_hdl(u8 *pbuf);
+extern u8 setphy_hdl(u8 *pbuf);
+extern u8 getphy_hdl(u8 *pbuf);
+#ifdef CONFIG_H2CLBK
+extern u8 seth2clbk_hdl(u8 *pbuf);
+extern u8 geth2clbk_hdl(u8 *pbuf);
+#endif	/* CONFIG_H2CLBK */
+#endif  /* CONFIG_RTL8711FW */
+
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+
+/*
+
+Result: 
+0x00: success
+0x01: sucess, and check Response.
+0x02: cmd ignored due to duplicated sequcne number
+0x03: cmd dropped due to invalid cmd code
+0x04: reserved.
+
+*/
+
+#define H2C_RSP_OFFSET			512
+
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+
+extern u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr);
+extern u8 rtw_setstandby_cmd(_adapter *padapter, uint action);
+extern u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *pssid);
+extern u8 rtw_createbss_cmd(_adapter  *padapter);
+extern u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int sz);
+extern u8 rtw_setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);
+extern u8 rtw_setstakey_cmd(_adapter  *padapter, u8 *psta, u8 unicast_key);
+extern u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork);
+extern u8 rtw_disassoc_cmd(_adapter  *padapter);
+extern u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+extern u8 rtw_setdatarate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 rtw_setbasicrate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 rtw_setbbreg_cmd(_adapter * padapter, u8 offset, u8 val);
+extern u8 rtw_setrfreg_cmd(_adapter * padapter, u8 offset, u32 val);
+extern u8 rtw_getbbreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
+extern u8 rtw_getrfreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
+extern u8 rtw_setrfintfs_cmd(_adapter  *padapter, u8 mode);
+extern u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table);
+extern u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval);
+
+extern u8 rtw_gettssi_cmd(_adapter  *padapter, u8 offset,u8 *pval);
+extern u8 rtw_setptm_cmd(_adapter*padapter, u8 type);
+extern u8 rtw_setfwdig_cmd(_adapter*padapter, u8 type);
+extern u8 rtw_setfwra_cmd(_adapter*padapter, u8 type);
+
+extern u8 rtw_addbareq_cmd(_adapter*padapter, u8 tid, u8 *addr);
+
+extern u8 dynamic_chk_wk_cmd(_adapter *adapter);
+
+extern void rtw_survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_disassoc_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);	
+extern void rtw_createbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd);
+
+extern void rtw_setstaKey_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_setassocsta_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void getrttbl_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(_adapter  *padapter, struct cmd_obj *cmd);
+};
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_cmd.h"
+#endif
+
+#ifdef CONFIG_RTL8192C
+#include "rtl8192c_cmd.h"
+#endif
+
+#endif // _CMD_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_debug.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_debug.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_debug.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_debug.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,337 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_DEBUG_H__
+#define __RTL871X_DEBUG_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#define _drv_emerg_			1
+#define _drv_alert_			2
+#define _drv_crit_			3
+#define _drv_err_			4
+#define	_drv_warning_		5
+#define _drv_notice_			6
+#define _drv_info_			7
+#define _drv_dump_			8
+#define	_drv_debug_		9
+
+
+#define 	_module_rtl871x_xmit_c_ 		BIT(0)
+#define 	_module_xmit_osdep_c_ 		BIT(1)
+#define 	_module_rtl871x_recv_c_ 		BIT(2)
+#define 	_module_recv_osdep_c_ 		BIT(3)
+#define 	_module_rtl871x_mlme_c_ 		BIT(4)
+#define	_module_mlme_osdep_c_ 		BIT(5)
+#define 	_module_rtl871x_sta_mgt_c_ 	BIT(6)
+#define 	_module_rtl871x_cmd_c_ 			BIT(7)
+#define	_module_cmd_osdep_c_ 	BIT(8)
+#define 	_module_rtl871x_io_c_ 				BIT(9)
+#define	_module_io_osdep_c_ 		BIT(10)
+#define 	_module_os_intfs_c_			BIT(11)
+#define 	_module_rtl871x_security_c_		BIT(12)
+#define 	_module_rtl871x_eeprom_c_			BIT(13)
+#define 	_module_hal_init_c_		BIT(14)
+#define 	_module_hci_hal_init_c_		BIT(15)
+#define 	_module_rtl871x_ioctl_c_		BIT(16)
+#define 	_module_rtl871x_ioctl_set_c_		BIT(17)
+#define 	_module_rtl871x_ioctl_query_c_	BIT(18)
+#define 	_module_rtl871x_pwrctrl_c_			BIT(19)
+#define 	_module_hci_intfs_c_			BIT(20)
+#define 	_module_hci_ops_c_			BIT(21)
+#define 	_module_osdep_service_c_			BIT(22)
+#define 	_module_rtl871x_mp_ioctl_c_			BIT(23)
+#define 	_module_hci_ops_os_c_			BIT(24)
+#define 	_module_rtl871x_ioctl_os_c			BIT(25)
+#define 	_module_rtl8712_cmd_c_ BIT(26)
+#define   _module_rtl871x_mp_c_ BIT(27)
+#define	_module_rtl8192c_xmit_c_ BIT(28)
+#define   _module_rtl8712_efuse_c_ BIT(29)
+#define   _module_rtl8712_recv_c_ BIT(30)
+#define   _module_rtl8712_led_c_ BIT(31)
+
+#undef _MODULE_DEFINE_
+
+#if defined _RTL871X_XMIT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_xmit_c_
+#elif defined _XMIT_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_xmit_osdep_c_	
+#elif defined _RTL871X_RECV_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_recv_c_
+#elif defined _RECV_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_recv_osdep_c_	
+#elif defined _RTL871X_MLME_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_mlme_c_
+#elif defined _MLME_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTL871X_STA_MGT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_sta_mgt_c_
+#elif defined _RTL871X_CMD_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_cmd_c_
+#elif defined _CMD_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_cmd_osdep_c_
+#elif defined _RTL871X_IO_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_io_c_
+#elif defined _IO_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_io_osdep_c_
+#elif defined _OS_INTFS_C_
+	#define	_MODULE_DEFINE_	_module_os_intfs_c_
+#elif defined _RTL871X_SECURITY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_security_c_	
+#elif defined _RTL871X_EEPROM_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_eeprom_c_	
+#elif defined _HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hal_init_c_	
+#elif defined _HCI_HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hci_hal_init_c_
+#elif defined _RTL871X_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_c_	
+#elif defined _RTL871X_IOCTL_SET_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_set_c_	
+#elif defined _RTL871X_IOCTL_QUERY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_query_c_		
+#elif defined _RTL871X_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_pwrctrl_c_			
+#elif defined _HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _HCI_OPS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_c_	
+#elif defined _OSDEP_HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _OSDEP_SERVICE_C_
+	#define	_MODULE_DEFINE_	_module_osdep_service_c_		
+#elif defined _RTL871X_MP_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_ioctl_c_		
+#elif defined _HCI_OPS_OS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_os_c_
+#elif defined _RTL871X_IOCTL_LINUX_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_os_c			
+#elif defined _RTL871X_MP_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_c_
+#elif defined _RTL8712_CMD_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_cmd_c_	
+#elif defined _RTL8192C_XMIT_C_
+	#define	_MODULE_DEFINE_	_module_rtl8192c_xmit_c_
+#elif  defined _RTL8712_EFUSE_C_	
+	#define	_MODULE_DEFINE_	_module_rtl8712_efuse_c_	
+#elif defined _RTL8712_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_		
+#elif defined _RTL8192CU_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#elif defined _RTL871X_MLME_EXT_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#endif		
+
+#ifdef PLATFORM_OS_CE
+extern void rtl871x_cedbg(const char *fmt, ...);	
+#endif
+	
+#define RT_TRACE(_Comp, _Level, Fmt) do{}while(0)
+#define _func_enter_ {}	
+#define _func_exit_ {}
+
+
+#undef	_dbgdump
+
+#ifdef CONFIG_DEBUG_RTL871X
+
+#ifndef _RTL871X_DEBUG_C_
+	extern u32 GlobalDebugLevel;
+	extern u64 GlobalDebugComponents;
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+		#ifdef PLATFORM_OS_XP
+		
+		#define _dbgdump	DbgPrint
+
+		#elif defined PLATFORM_OS_CE
+		
+		#define _dbgdump	rtl871x_cedbg
+
+		#endif
+
+	#elif defined PLATFORM_LINUX
+
+		#define _dbgdump	printk
+
+#endif
+	
+#endif /* CONFIG_DEBUG_RTL871X */
+
+
+#if	defined (_dbgdump) && defined (_MODULE_DEFINE_)
+	
+		#undef RT_TRACE
+		#define RT_TRACE(_Comp, _Level, Fmt)\
+		do {\
+			if((_Comp & GlobalDebugComponents) && (_Level <= GlobalDebugLevel)) {\
+			_dbgdump("%s [0x%08x,%d]", RTL871X_MODULE_NAME, (unsigned int)_Comp, _Level);\
+				_dbgdump Fmt;						\
+			}\
+		}while(0)	
+
+#endif
+	
+
+#if	defined (_dbgdump)
+	
+		#undef  _func_enter_
+		#define _func_enter_ \
+		do {	\
+			if (GlobalDebugLevel >= _drv_debug_) \
+			{																	\
+				_dbgdump("\n %s : %s enters at %d\n", RTL871X_MODULE_NAME, __FUNCTION__, __LINE__);\
+			}		\
+		} while(0)
+	
+		#undef  _func_exit_
+		#define _func_exit_ \
+		do {	\
+			if (GlobalDebugLevel >= _drv_debug_) \
+			{																	\
+				_dbgdump("\n %s : %s exits at %d\n", RTL871X_MODULE_NAME, __FUNCTION__, __LINE__); \
+			}	\
+		} while(0)
+
+#endif
+
+
+#ifndef CONFIG_DEBUG_RTL8192C
+	#ifdef PLATFORM_LINUX
+	#define printk(x, ...) {} 
+	#endif
+#endif	//CONFIG_DEBUG_RTL8192C
+
+	#ifdef PLATFORM_WINDOWS
+	#define _dbgdump	DbgPrint
+
+	#define DBG_871X {}
+
+	#define MSG_8192C {}
+
+	#define DBG_8192C {}
+
+	#define WRN_8192C {}
+
+	#define ERR_8192C {}	
+	#endif
+
+	#ifdef PLATFORM_LINUX
+	#define _dbgdump	printk
+
+	#define DBG_871X(x, ...) {}
+	
+	#define MSG_8192C(x, ...) {}
+
+	#define DBG_8192C(x,...)  {}
+
+	#define WRN_8192C(x,...)  {}
+
+	#define ERR_8192C(x,...)  {}
+	#endif
+
+	#undef DBG_871X
+	#define DBG_871X _dbgdump
+
+	#undef MSG_8192C
+	#define MSG_8192C _dbgdump
+
+	#undef DBG_8192C
+	#define DBG_8192C _dbgdump
+
+	#undef WRN_8192C
+	#define WRN_8192C _dbgdump
+
+	#undef ERR_8192C
+	#define ERR_8192C _dbgdump
+
+
+
+#endif	//__RTL871X_DEBUG_H__
+
+
+#ifdef CONFIG_PROC_DEBUG
+
+	int proc_get_write_reg(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+ 	int proc_set_write_reg(struct file *file, const char *buffer,
+		unsigned long count, void *data);
+
+	int proc_get_read_reg(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_read_reg(struct file *file, const char *buffer,
+		unsigned long count, void *data);
+
+
+	int proc_get_fwstate(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_sec_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_mlmext_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_qos_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_ht_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);	
+
+	int proc_get_rf_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_ap_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_adapter_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+	
+	int proc_get_trx_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+	
+		
+#ifdef CONFIG_AP_MODE
+
+	int proc_get_all_sta_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+	
+#endif		
+	
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_eeprom.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_eeprom.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_eeprom.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_eeprom.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,200 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_EEPROM_H__
+#define __RTL871X_EEPROM_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define	RTL8712_EEPROM_ID			0x8712
+#define	EEPROM_MAX_SIZE			256
+#define	CLOCK_RATE					50			//100us		
+
+//- EEPROM opcodes
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      // Erase/write enable
+#define EEPROM_EWDS_OPCODE		16      // Erase/write disable
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later	
+#define JAPAN						0x2 //temp, should be provided later
+
+#ifdef CONFIG_SDIO_HCI
+#define eeprom_cis0_sz	17
+#define eeprom_cis1_sz	50
+#endif
+
+#define	EEPROM_CID_DEFAULT			0x0
+#define	EEPROM_CID_ALPHA				0x1
+#define	EEPROM_CID_Senao				0x3
+#define	EEPROM_CID_NetCore				0x5
+#define	EEPROM_CID_CAMEO				0X8
+#define	EEPROM_CID_SITECOM				0x9
+#define	EEPROM_CID_COREGA				0xB
+#define	EEPROM_CID_EDIMAX_BELKIN		0xC
+#define	EEPROM_CID_SERCOMM_BELKIN		0xE
+#define	EEPROM_CID_CAMEO1				0xF
+#define	EEPROM_CID_WNC_COREGA		0x12
+#define	EEPROM_CID_CLEVO				0x13
+#define	EEPROM_CID_WHQL				0xFE // added by chiyoko for dtm, 20090108
+
+typedef enum _RT_CUSTOMER_ID
+{
+	RT_CID_DEFAULT = 0,
+	RT_CID_8187_ALPHA0 = 1,
+	RT_CID_8187_SERCOMM_PS = 2,
+	RT_CID_8187_HW_LED = 3,
+	RT_CID_8187_NETGEAR = 4,
+	RT_CID_WHQL = 5,
+	RT_CID_819x_CAMEO  = 6, 
+	RT_CID_819x_RUNTOP = 7,
+	RT_CID_819x_Senao = 8,
+	RT_CID_TOSHIBA = 9,	// Merge by Jacken, 2008/01/31.
+	RT_CID_819x_Netcore = 10,
+	RT_CID_Nettronix = 11,
+	RT_CID_DLINK = 12,
+	RT_CID_PRONET = 13,
+	RT_CID_COREGA = 14,
+	RT_CID_819x_ALPHA = 15,
+	RT_CID_819x_Sitecom = 16,
+	RT_CID_CCX = 17, // It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17.      
+	RT_CID_819x_Lenovo = 18,
+	RT_CID_819x_QMI = 19,
+	RT_CID_819x_Edimax_Belkin = 20,		
+	RT_CID_819x_Sercomm_Belkin = 21,			
+	RT_CID_819x_CAMEO1 = 22,
+	RT_CID_819x_MSI = 23,
+	RT_CID_819x_Acer = 24,
+	RT_CID_819x_AzWave_ASUS = 25,
+	RT_CID_819x_AzWave = 26, // For AzWave in PCIe, The ID is AzWave use and not only Asus
+	RT_CID_819x_HP = 27,
+	RT_CID_819x_WNC_COREGA = 28,
+	RT_CID_819x_Arcadyan_Belkin = 29,
+	RT_CID_819x_SAMSUNG = 30,
+	RT_CID_819x_CLEVO = 31,
+	RT_CID_819x_DELL = 32,
+	RT_CID_819x_PRONETS = 33,
+}RT_CUSTOMER_ID, *PRT_CUSTOMER_ID;
+
+struct eeprom_priv 
+{    
+	u8		bAutoload;
+	u8		bempty;
+	u8		sys_config;
+	u8		mac_addr[6];	//PermanentAddress
+	u8		config0;
+	u16		channel_plan;
+	u8		country_string[3];	
+	u8		tx_power_b[15];
+	u8		tx_power_g[15];
+	u8		tx_power_a[201];
+
+	u8		bBootFromEEPROM;
+	
+	u8		efuse_eeprom_data[EEPROM_MAX_SIZE];
+	u16		efuse_phy_max_size;
+#ifdef CONFIG_SDIO_HCI
+	u8		sdio_setting;	
+	u32		ocr;
+	u8		cis0[eeprom_cis0_sz];
+	u8		cis1[eeprom_cis1_sz];	
+#endif
+
+
+#ifdef CONFIG_RTL8192C
+	//
+	// EEPROM setting.
+	//
+	u8				EEPROMVersion;
+	u16				EEPROMVID;
+	u16				EEPROMPID;
+	u16				EEPROMSVID;
+	u16				EEPROMSDID;
+	u8				EEPROMCustomerID;
+	u8				EEPROMSubCustomerID;	
+	u8				EEPROMRegulatory;//ChannelPlan
+
+	u8	 			EEPROMUsbOption;
+	u8				EEPROMUsbEndPointNumber;
+	u8	 			EEPROMUsbPhyParam[5];
+
+	u8  				EEPROMThermalMeter;
+	u8  				EEPROMTSSI_A;
+	u8  				EEPROMTSSI_B;
+
+	u8				EEPROMBoardType;	
+
+
+	//
+	// The same as 92CE. May merge 92CU and 92CE into the other struct
+	//
+	//u8				ThermalMeter[2];	// ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u8				TxPwrLevelCck[RF90_PATH_MAX][CHANNEL_MAX_NUMBER];
+	u8				TxPwrLevelHT40_1S[RF90_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
+	u8				TxPwrLevelHT40_2S[RF90_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr	
+	u8				TxPwrHt20Diff[RF90_PATH_MAX][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
+	u8				TxPwrLegacyHtDiff[RF90_PATH_MAX][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
+	// For power group
+	u8				PwrGroupHT20[RF90_PATH_MAX][CHANNEL_MAX_NUMBER];
+	u8				PwrGroupHT40[RF90_PATH_MAX][CHANNEL_MAX_NUMBER];
+	
+
+	
+	//chip info from eeprom or efuse	
+	//unsigned char hw_addr[6];
+	//unsigned short chip_id;//EEPROMId	?
+	//unsigned char EEPROMUsbOption;
+	//unsigned char EEPROMUsbPhyParam[5];
+	//unsigned char EEPROMUsbEndPointNumber;
+	//unsigned char EEPROMVersion;
+	//unsigned char eeprom_ChannelPlan;
+	//unsigned char eeprom_CustomerID;
+	//unsigned char eeprom_SubCustomerID;
+	//unsigned char EEPROMBoardType;	
+	//unsigned char RfCckChnlAreaTxPwr[2][3];//RF-A&B CCK/OFDM Tx Power Level at three channel are [1-3] [4-9] [10-14]
+	//unsigned char RfOfdmChnlAreaTxPwr1T[2][3];	
+	//unsigned char RfOfdmChnlAreaTxPwr2T[2][3];	
+	//unsigned char EEPROMTxPowerDiff;
+	//unsigned char EEPROMThermalMeter;
+	//unsigned char EEPROMTSSI_A;
+	//unsigned char EEPROMTSSI_B;	
+	//unsigned char TxPwrHt20Diff[2][14];	// HT 20<->40 Pwr diff
+	//unsigned char TxPwrLegacyHtDiff[2][14];	// For HT<->legacy OFDM pwr diff
+	//unsigned char EEPROMPwrGroup[2][3];		
+	//unsigned char EEPROMRegulatory;
+	//unsigned char EEPROMOptional;
+	
+#endif //end of CONFIG_RTL8192C
+
+};
+
+
+extern void eeprom_write16(_adapter *padapter, u16 reg, u16 data);
+extern u16 eeprom_read16(_adapter *padapter, u16 reg);
+extern void read_eeprom_content(_adapter *padapter);
+extern void eeprom_read_sz(_adapter * padapter, u16 reg,u8* data, u32 sz); 
+
+extern void read_eeprom_content_by_attrib(_adapter *	padapter	);
+
+#endif  //__RTL871X_EEPROM_H__
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_event.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_event.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_event.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_event.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,161 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871x_EVENT_H_
+#define _RTL871x_EVENT_H_
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#ifndef CONFIG_RTL8711FW
+#ifdef PLATFORM_LINUX
+#include <wlan_bssdef.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/sem.h>
+#endif
+#else
+#include <wlan_bssdef.h>
+#endif//CONFIG_RTL8711FW
+
+
+
+#ifdef CONFIG_H2CLBK
+#include <h2clbk.h>
+#endif
+
+/*
+Used to report a bss has been scanned
+
+*/
+struct survey_event	{
+	WLAN_BSSID_EX bss;	
+};
+
+/*
+Used to report that the requested site survey has been done.
+
+bss_cnt indicates the number of bss that has been reported.
+
+
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;	
+	
+};
+
+/*
+Used to report the link result of joinning the given bss
+
+
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+Used to report a given STA has joinned the created BSS.
+It is used in AP/Ad-HoC(M) mode.
+
+
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+	int    cam_id;
+	
+};
+
+struct stadel_event {
+ unsigned char macaddr[6];
+ unsigned char rsvd[2]; 
+};
+
+struct addba_event
+{
+ 	unsigned int tid;
+};
+
+
+#ifdef CONFIG_H2CLBK
+struct c2hlbk_event{
+	unsigned char mac[6];
+	unsigned short	s0;
+	unsigned short	s1;
+	unsigned int	w0;
+	unsigned char	b0;
+	unsigned short  s2;
+	unsigned char	b1;
+	unsigned int	w1;	
+};
+#endif//CONFIG_H2CLBK
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(_adapter *dev, u8 *pbuf);
+};
+
+
+#define C2HEVENT_SZ			32	
+
+struct event_node{
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	volatile int	*caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	volatile int	head;
+	volatile int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	volatile int	head;
+	volatile int	tail;
+	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];	
+};
+
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_event.h"
+#endif
+
+#ifdef CONFIG_RTL8192C
+#include "rtl8192c_event.h"
+#endif
+
+#endif // _WLANEVENT_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ht.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ht.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ht.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ht.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_HT_H_
+#define _RTL871X_HT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include "wifi.h"
+
+struct ht_priv
+{
+	unsigned int	ht_option;	
+	unsigned int	ampdu_enable;//for enable Tx A-MPDU
+	//unsigned char	baddbareq_issued[16];	
+	unsigned int	tx_amsdu_enable;//for enable Tx A-MSDU
+	unsigned int	tx_amdsu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
+	unsigned int	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
+	
+	unsigned char	bwmode;//
+	unsigned char ch_offset;//PRIME_CHNL_OFFSET
+	unsigned char sgi;//short GI
+	
+	//for processing Tx A-MPDU
+	unsigned char		agg_enable_bitmap;
+	//unsigned char		ADDBA_retry_count;
+	unsigned char		candidate_tid_bitmap;
+	
+	struct ieee80211_ht_cap ht_cap;
+	
+};
+
+#endif	//_RTL871X_HT_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,270 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_H
+#define __IOCTL_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+// For DDK-defined OIDs
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+
+#define SZ_OID_NDIS_SEG1		  23
+#define SZ_OID_NDIS_SEG2		    3
+#define SZ_OID_NDIS_SEG3		    6
+#define SZ_OID_NDIS_SEG4		    6
+#define SZ_OID_NDIS_SEG5		    4
+#define SZ_OID_NDIS_SEG6		    8
+#define SZ_OID_NDIS_SEG7		    7
+#define SZ_OID_NDIS_SEG8		  36
+#define SZ_OID_NDIS_SEG9		  24
+#define SZ_OID_NDIS_SEG10		  19
+
+// For Realtek-defined OIDs
+#define OID_MP_SEG1		0xFF871100
+#define OID_MP_SEG2		0xFF818000
+
+#define OID_MP_SEG3		0xFF818700
+#define OID_MP_SEG4		0xFF011100
+
+#define DEBUG_OID(dbg, str)     		\
+       if((!dbg))				    			\
+      	{					    			\
+	   RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("%s(%d): %s", __FUNCTION__, __LINE__, str));	\
+      	}			
+
+
+enum oid_type
+{
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; //the starting number for OID
+	unsigned int oid_end; //the ending number for OID
+	struct oid_obj_priv *node_array; 
+	unsigned int array_sz; //the size of node_array
+	int query_counter; //count the number of query hits for this segment  
+	int set_counter; //count the number of set hits for this segment  
+};
+
+struct oid_par_priv
+{
+	void				*adapter_context;
+	NDIS_OID		oid;
+	void*			information_buf;
+	unsigned long		information_buf_len;
+	unsigned long*	bytes_rw;
+	unsigned long*	bytes_needed;
+	enum oid_type	type_of_oid;
+	unsigned int 		dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; // 0: without OID debug message  1: with OID debug message 
+	NDIS_STATUS (*oidfuns)(struct oid_par_priv *poid_par_priv);	
+};
+
+
+NDIS_STATUS oid_null_function(struct oid_par_priv* poid_par_priv);
+
+#ifdef PLATFORM_WINDOWS
+
+int TranslateNdisPsToRtPs(IN NDIS_802_11_POWER_MODE	ndisPsMode);
+
+//OID Handler for Segment 1
+NDIS_STATUS oid_gen_supported_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_hardware_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_in_use_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_lookahead_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_frame_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_link_speed_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_transmit_buffer_space_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_receive_buffer_space_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_transmit_block_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_receive_block_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_id_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_description_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_current_packet_filter_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_current_lookahead_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_driver_version_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_total_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_protocol_options_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_mac_options_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_media_connect_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_maximum_send_packets_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_vendor_driver_version_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 2
+NDIS_STATUS oid_gen_physical_medium_hdl(struct oid_par_priv* poid_par_priv);
+
+//OID Handler for Segment 3
+NDIS_STATUS oid_gen_xmit_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_xmit_error_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_error_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_gen_rcv_no_buffer_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 4
+NDIS_STATUS oid_802_3_permanent_address_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_current_address_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_multicast_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_maximum_list_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_mac_options_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 5
+NDIS_STATUS oid_802_3_rcv_error_alignment_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_one_collision_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_more_collisions_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 6
+NDIS_STATUS oid_802_3_xmit_deferred_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_max_collisions_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_rcv_overrun_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_underrun_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_heartbeat_failure_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_times_crs_lost_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_3_xmit_late_collisions_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 7
+NDIS_STATUS oid_pnp_capabilities_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_set_power_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_query_power_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_add_wake_up_pattern_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_remove_wake_up_pattern_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_wake_up_pattern_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_pnp_enable_wake_up_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+//OID Handler for Segment 8
+NDIS_STATUS oid_802_11_bssid_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_ssid_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_infrastructure_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_add_wep_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_remove_wep_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_disassociate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_authentication_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_privacy_filter_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_bssid_list_scan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_encryption_status_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_reload_defaults_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_add_key_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_remove_key_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_association_information_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_media_stream_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_capability_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_pmkid_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+
+
+//OID Handler for Segment 9
+NDIS_STATUS oid_802_11_network_types_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_network_type_in_use_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_tx_power_level_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rssi_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rssi_trigger_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_fragmentation_threshold_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rts_threshold_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_number_of_antennas_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_rx_antenna_selected_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_tx_antenna_selected_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_supported_rates_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_desired_rates_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_configuration_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_power_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_802_11_bssid_list_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment 10
+NDIS_STATUS oid_802_11_statistics_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//OID Handler for Segment ED 
+NDIS_STATUS oid_rt_mh_vender_id_hdl(struct oid_par_priv* poid_par_priv);
+
+void Set_802_3_MULTICAST_LIST(ADAPTER *pAdapter, UCHAR *MCListbuf, ULONG MCListlen, BOOLEAN bAcceptAllMulticast);
+
+#endif// end of PLATFORM_WINDOWS
+
+
+#ifdef PLATFORM_LINUX
+
+extern struct iw_handler_def  rtw_handlers_def;
+
+#endif
+
+extern	NDIS_STATUS drv_query_info(
+	IN	_nic_hdl		MiniportAdapterContext,
+	IN	NDIS_OID		Oid,
+	IN	void *			InformationBuffer,
+	IN	u32			InformationBufferLength,
+	OUT	u32*			BytesWritten,
+	OUT	u32*			BytesNeeded
+	);
+
+extern	NDIS_STATUS 	drv_set_info(
+	IN	_nic_hdl		MiniportAdapterContext,
+	IN	NDIS_OID		Oid,
+	IN	void *			InformationBuffer,
+	IN	u32			InformationBufferLength,
+	OUT	u32*			BytesRead,
+	OUT	u32*			BytesNeeded
+	);
+
+struct wowlan_ioctl_param{
+	unsigned int subcode;
+	unsigned int len;
+	unsigned char data[0];
+};
+
+#endif // #ifndef __INC_CEINFO_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_query.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_query.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_query.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_query.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_QUERY_H
+#define __IOCTL_QUERY_H
+
+#include <drv_conf.h>
+#include <drv_types.h>
+
+
+#ifdef PLATFORM_WINDOWS
+
+u8 query_802_11_capability(_adapter*	padapter,u8*	pucBuf,u32 *	pulOutLen);
+u8 query_802_11_association_information (_adapter * padapter, PNDIS_802_11_ASSOCIATION_INFORMATION pAssocInfo);
+
+#endif
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_rtl.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_rtl.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_rtl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_rtl.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_IOCTL_RTL_H
+#define _RTL871X_IOCTL_RTL_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+//************** oid_rtl_seg_01_01 ************** 
+NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv);//84
+NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_retry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_retry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_total_packet_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv);	//8a
+NDIS_STATUS oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv);	//8b
+
+NDIS_STATUS oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv);//93
+NDIS_STATUS oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_bcn_intvl_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_dedicate_probe_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_current_tx_power_level_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_key_mismatch_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_supported_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_scan_in_progress_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_forced_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+//**************  oid_rtl_seg_01_03 section start ************** 
+NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv);
+
+// oid_rtl_seg_01_11 
+NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv);
+
+//**************  oid_rtl_seg_03_00 section start **************  
+NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+
+#endif
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_set.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_set.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_set.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_ioctl_set.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,73 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_SET_H
+#define __IOCTL_SET_H
+
+#include <drv_conf.h>
+#include <drv_types.h>
+
+
+typedef u8 NDIS_802_11_PMKID_VALUE[16];
+
+typedef struct _BSSIDInfo {
+	NDIS_802_11_MAC_ADDRESS  BSSID;
+	NDIS_802_11_PMKID_VALUE  PMKID;
+} BSSIDInfo, *PBSSIDInfo;
+
+
+#ifdef PLATFORM_OS_XP
+typedef struct _NDIS_802_11_PMKID {
+	u32	Length;
+	u32	BSSIDInfoCount;
+	BSSIDInfo BSSIDInfo[1];
+} NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+u8 set_802_11_reload_defaults(_adapter * padapter, NDIS_802_11_RELOAD_DEFAULTS reloadDefaults);
+u8 set_802_11_test(_adapter * padapter, NDIS_802_11_TEST * test);
+u8 set_802_11_pmkid(_adapter *pdapter, NDIS_802_11_PMKID *pmkid);
+
+u8 pnp_set_power_sleep(_adapter* padapter);
+u8 pnp_set_power_wakeup(_adapter* padapter);
+
+void pnp_resume_wk(void *context);
+void pnp_sleep_wk(void * context);
+
+#endif
+
+u8 rtw_set_802_11_add_key(_adapter * padapter, NDIS_802_11_KEY * key);
+u8 rtw_set_802_11_authentication_mode(_adapter *pdapter, NDIS_802_11_AUTHENTICATION_MODE authmode);
+u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid);
+u8 rtw_set_802_11_add_wep(_adapter * padapter, NDIS_802_11_WEP * wep);
+u8 rtw_set_802_11_disassociate(_adapter * padapter);
+u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter);
+u8 rtw_set_802_11_infrastructure_mode(_adapter * padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+u8 rtw_set_802_11_remove_wep(_adapter * padapter, u32 keyindex);
+u8 rtw_set_802_11_ssid(_adapter * padapter, NDIS_802_11_SSID * ssid);
+u8 rtw_set_802_11_remove_key(_adapter * padapter, NDIS_802_11_REMOVE_KEY * key);
+
+
+u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid);
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_io.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_io.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_io.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_io.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,490 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _IO_H_
+#define _IO_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <osdep_intf.h>
+
+#ifdef PLATFORM_LINUX
+#include <asm/byteorder.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+#ifdef CONFIG_USB_HCI
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+#endif
+
+#endif
+
+
+#define NUM_IOREQ		8
+
+#ifdef PLATFORM_WINDOWS
+#define MAX_PROT_SZ	64
+#endif
+#ifdef PLATFORM_LINUX
+#define MAX_PROT_SZ	(64-16)
+#endif
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+// IO COMMAND TYPE
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+
+/* 
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+
+
+
+// IO STATUS TYPE
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+
+
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+
+/*
+
+	Only Sync. burst accessing is provided.
+
+*/
+
+#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+
+
+
+//below is for the intf_option bit defition...
+
+#define _INTF_ASYNC_	BIT(0)	//support async io
+
+struct intf_priv;
+struct	intf_hdl;
+struct io_queue;
+
+struct	_io_ops {
+
+
+		uint (*_sdbus_read_bytes_to_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+		uint (*_sdbus_read_blocks_to_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+		void (*_attrib_read)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+
+
+		uint (*_sdbus_write_blocks_from_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+		uint (*_sdbus_write_bytes_from_membuf)(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+		u8 (*_cmd52r)(struct intf_priv *pintfpriv, u32 addr);
+		void (*_cmd52w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+		u8 (*_cmdfunc152r)(struct intf_priv *pintfpriv, u32 addr);
+		void (*_cmdfunc152w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+
+
+		void (*_attrib_write)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		
+		void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		
+		void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+
+		void (*_writeN)(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
+
+		void (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		
+		void (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		
+		void (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+		
+
+		void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		
+		void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		
+		void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);
+
+		
+
+
+		u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		
+		u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		u32 (*_write_scsi)(struct intf_hdl *pintfhdl,u32 cnt, u8 *pmem);
+
+
+		void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
+		
+		void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
+
+		
+
+		u8 (*_async_read8)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u16 (*_async_read16)(struct intf_hdl *pintfhdl, u32 addr);
+		
+		u32 (*_async_read32)(struct intf_hdl *pintfhdl, u32 addr);
+				
+		void (*_async_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		
+		void (*_async_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		
+		void (*_async_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+					
+
+
+
+};
+
+struct io_req {	
+	_list	list;
+	u32	addr;	
+	volatile u32	val;
+	u32	command;
+	u32	status;
+	u8	*pbuf;	
+	_sema	sema;
+
+#ifdef PLATFORM_OS_CE
+#ifdef CONFIG_USB_HCI
+	// URB handler for write_mem
+	USB_TRANSFER usb_transfer_write_mem;
+#endif
+#endif
+	
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt);
+	u8 *cnxt;	
+
+#ifdef PLATFORM_OS_XP	
+	PMDL pmdl;
+	PIRP  pirp; 
+
+#ifdef CONFIG_SDIO_HCI
+	PSDBUS_REQUEST_PACKET sdrp;
+#endif	
+
+#endif	
+
+
+};
+
+struct	intf_hdl {
+
+/*	
+	u32	intf_option;
+	u32	bus_status;
+	u32	do_flush;
+	u8	*adapter;
+	u8	*intf_dev;	
+	struct intf_priv	*pintfpriv;
+	u8	cnt;
+	void (*intf_hdl_init)(u8 *priv);
+	void (*intf_hdl_unload)(u8 *priv);
+	void (*intf_hdl_open)(u8 *priv);
+	void (*intf_hdl_close)(u8 *priv);
+	struct	_io_ops	io_ops;
+	//u8 intf_status;//moved to struct intf_priv
+	u16 len;
+	u16 done_len;	
+*/
+	_adapter *padapter;
+	struct dvobj_priv *pintf_dev;//	pointer to &(padapter->dvobjpriv);
+	_mutex io_mutex;
+	struct _io_ops	io_ops;
+
+};
+
+struct reg_protocol_rd {
+
+#ifdef CONFIG_LITTLE_ENDIAN	
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	//u32		Value;
+#else
+
+
+//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;	
+
+	u32 Reserved2  :24;	
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;	
+
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;	
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;	
+	u32 BurstMode :1 ;	
+	u32 FixOrContinuous : 1;	
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	//u32		Value;
+
+#endif
+	
+};
+
+
+struct reg_protocol_wt {
+	
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	u32		Value;
+
+#else
+	//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;	
+
+	u32 Reserved2  :24;	
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;	
+		
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;	
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;	
+	u32 BurstMode :1 ;	
+	u32 FixOrContinuous : 1;	
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	u32		Value;
+
+#endif
+
+};
+
+
+
+/*
+Below is the data structure used by _io_handler
+
+*/
+
+struct io_queue {	
+	_lock	lock;	
+	_list  	free_ioreqs;	
+	_list		pending;		//The io_req list that will be served in the single protocol read/write.	
+	_list		processing;
+	u8	*free_ioreqs_buf; // 4-byte aligned
+	u8	*pallocated_free_ioreqs_buf;
+	struct	intf_hdl	intf;
+};
+
+struct io_priv{
+	
+	_adapter *padapter;	
+		
+	struct intf_hdl intf;
+
+};
+
+extern uint ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+extern void sync_ioreq_enqueue(struct io_req *preq,struct io_queue *ioqueue);
+extern uint sync_ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+
+
+extern uint free_ioreq(struct io_req *preq, struct io_queue *pio_queue);
+extern struct io_req *alloc_ioreq(struct io_queue *pio_q);
+
+extern uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl);
+extern void unregister_intf_hdl(struct intf_hdl *pintfhdl);
+
+extern void rtw_attrib_read(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void rtw_attrib_write(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern u8 rtw_read8(_adapter *adapter, u32 addr);
+extern u16 rtw_read16(_adapter *adapter, u32 addr);
+extern u32 rtw_read32(_adapter *adapter, u32 addr);
+extern void rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void rtw_write8(_adapter *adapter, u32 addr, u8 val);
+extern void rtw_write16(_adapter *adapter, u32 addr, u16 val);
+extern void rtw_write32(_adapter *adapter, u32 addr, u32 val);
+extern void writeN(_adapter *adapter, u32 addr, u32 length, u8 *pdata);
+
+extern void write8_async(_adapter *adapter, u32 addr, u8 val);
+extern void write16_async(_adapter *adapter, u32 addr, u16 val);
+extern void write32_async(_adapter *adapter, u32 addr, u32 val);
+
+extern void rtw_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void write_scsi(_adapter *adapter, u32 cnt, u8 *pmem);
+
+void write_port_cancel(_adapter *adapter);
+void read_port_cancel(_adapter *adapter);
+
+//ioreq 
+extern void ioreq_read8(_adapter *adapter, u32 addr, u8 *pval);
+extern void ioreq_read16(_adapter *adapter, u32 addr, u16 *pval);	
+extern void ioreq_read32(_adapter *adapter, u32 addr, u32 *pval);
+extern void ioreq_write8(_adapter *adapter, u32 addr, u8 val);
+extern void ioreq_write16(_adapter *adapter, u32 addr, u16 val);
+extern void ioreq_write32(_adapter *adapter, u32 addr, u32 val);
+
+
+extern uint async_read8(_adapter *adapter, u32 addr, u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
+extern uint async_read16(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
+extern uint async_read32(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
+
+extern void async_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern void async_write8(_adapter *adapter, u32 addr, u8 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write16(_adapter *adapter, u32 addr, u16 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write32(_adapter *adapter, u32 addr, u32 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+
+int init_io_priv(_adapter *padapter);
+extern uint alloc_io_queue(_adapter *adapter);
+extern void free_io_queue(_adapter *adapter);
+extern void async_bus_io(struct io_queue *pio_q);
+extern void bus_sync_io(struct io_queue *pio_q);
+extern u32 _ioreq2rwmem(struct io_queue *pio_q);
+extern void dev_power_down(_adapter * Adapter, u8 bpwrup);
+
+
+
+#define RTL_R8(reg)		rtw_read8(padapter, reg)
+#define RTL_R16(reg)            rtw_read16(padapter, reg)
+#define RTL_R32(reg)            rtw_read32(padapter, reg)
+#define RTL_W8(reg, val8)       rtw_write8(padapter, reg, val8)
+#define RTL_W16(reg, val16)     rtw_write16(padapter, reg, val16)
+#define RTL_W32(reg, val32)     rtw_write32(padapter, reg, val32)
+
+/*
+#define RTL_W8_ASYNC(reg, val8) write32_async(padapter, reg, val8)
+#define RTL_W16_ASYNC(reg, val16) write32_async(padapter, reg, val16)
+#define RTL_W32_ASYNC(reg, val32) write32_async(padapter, reg, val32)
+
+#define RTL_WRITE_BB(reg, val32)	phy_SetUsbBBReg(padapter, reg, val32)
+#define RTL_READ_BB(reg)	phy_QueryUsbBBReg(padapter, reg)
+*/
+
+#endif	//_RTL8711_IO_H_
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_led.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_led.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_led.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_led.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_LED_H
+#define __RTL8712_LED_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define MSECS(t)        (HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
+//#define LED_STATE_871x (unsigned int)
+
+
+//================================================================================
+// LED customization.
+//================================================================================
+typedef enum _LED_CTL_MODE{
+        LED_CTL_POWER_ON = 1,
+        LED_CTL_LINK = 2,
+        LED_CTL_NO_LINK = 3,
+        LED_CTL_TX = 4,
+        LED_CTL_RX = 5,
+        LED_CTL_SITE_SURVEY = 6,
+        LED_CTL_POWER_OFF = 7,
+        LED_CTL_START_TO_LINK = 8,
+        LED_CTL_START_WPS = 9,
+        LED_CTL_STOP_WPS = 10,
+        LED_CTL_START_WPS_BOTTON = 11, //added for runtop
+        LED_CTL_STOP_WPS_FAIL = 12, //added for ALPHA	
+	 LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, //added for BELKIN
+}LED_CTL_MODE;
+
+
+
+#define IS_LED_WPS_BLINKING(_LED_871x)	(((PLED_871x)_LED_871x)->CurrLedState==LED_BLINK_WPS \
+					|| ((PLED_871x)_LED_871x)->CurrLedState==LED_BLINK_WPS_STOP \
+					|| ((PLED_871x)_LED_871x)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_871x) 	(((PLED_871x)_LED_871x)->bLedWPSBlinkInProgress \
+					||((PLED_871x)_LED_871x)->bLedScanBlinkInProgress)
+
+typedef enum _LED_PIN_871x{
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1
+}LED_PIN_871x;
+
+//================================================================================
+// LED customization.
+//================================================================================
+typedef	enum _LED_STRATEGY_871x{
+	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
+	SW_LED_MODE1, // 2 LEDs, through LED0 and LED1. For ALPHA.
+	SW_LED_MODE2, // SW control 1 LED via GPIO0, customized for AzWave 8187 minicard.
+	SW_LED_MODE3, // SW control 1 LED via GPIO0, customized for Sercomm Printer Server case.
+	SW_LED_MODE4, //for Edimax / Belkin
+	SW_LED_MODE5, //for Sercomm / Belkin
+	SW_LED_MODE6, //for WNC / Corega
+	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.)
+}LED_STRATEGY_871x, *PLED_STRATEGY_871x;
+
+typedef struct _LED_871x{
+	_adapter				*padapter;
+	LED_PIN_871x			LedPin;	// Identify how to implement this SW led.
+	unsigned int		CurrLedState; // Current LED state.
+	u8					bLedOn; // true if LED is ON, false if LED is OFF.
+
+	u8					bSWLedCtrl;
+
+	u8					bLedBlinkInProgress; // true if it is blinking, false o.w..
+	// ALPHA, added by chiyoko, 20090106
+	u8					bLedNoLinkBlinkInProgress;
+	u8					bLedLinkBlinkInProgress;
+	u8					bLedStartToLinkBlinkInProgress;
+	u8					bLedScanBlinkInProgress;
+	u8					bLedWPSBlinkInProgress;
+	
+	u32					BlinkTimes; // Number of times to toggle led state for blinking.
+	unsigned int		BlinkingLedState; // Next state for blinking, either LED_ON or LED_OFF are.
+
+	struct timer_list		BlinkTimer; // Timer object for led blinking.
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	struct work_struct		BlinkWorkItem; // Workitem used by BlinkTimer to manipulate H/W to blink LED. 
+#endif
+} LED_871x, *PLED_871x;
+
+struct led_priv{
+	/* add for led controll */
+	LED_871x			SwLed0;
+	LED_871x			SwLed1;
+	LED_STRATEGY_871x	LedStrategy;
+	u8					bRegUseLed;
+	u8					bLedOpenDrain; // Support Open-drain arrangement for controlling the LED. 
+	void (*LedControlHandler)(_adapter *padapter, LED_CTL_MODE LedAction);
+	/* add for led controll */
+};
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+void rtw_InitSwLeds(_adapter *padapter);
+void rtw_DeInitSwLeds(_adapter *padapter);
+void rtw_LedControl871x(_adapter *padapter,LED_CTL_MODE LedAction);
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mlme_ext.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mlme_ext.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mlme_ext.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mlme_ext.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,437 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_MLME_EXT_H_
+#define __RTL871X_MLME_EXT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+
+#define SURVEY_TO			(100)
+#define REAUTH_TO			(50)
+#define REASSOC_TO		(50)
+//#define DISCONNECT_TO	(3000)
+#define ADDBA_TO			(2000)
+
+#define LINKED_TO (1) //unit:2 sec, 1x2=2 sec
+
+#define REAUTH_LIMIT	(2)
+#define REASSOC_LIMIT	(2)
+#define READDBA_LIMIT	(2)
+
+//#define	IOCMD_REG0		0x10250370		 	
+//#define	IOCMD_REG1		0x10250374
+//#define	IOCMD_REG2		0x10250378
+
+//#define	FW_DYNAMIC_FUN_SWITCH	0x10250364
+
+//#define	WRITE_BB_CMD		0xF0000001
+//#define	SET_CHANNEL_CMD	0xF3000000
+//#define	UPDATE_RA_CMD	0xFD0000A2
+
+#define	DYNAMIC_FUNC_DISABLE		(0x0)
+#define	DYNAMIC_FUNC_DIG			BIT(0)
+#define	DYNAMIC_FUNC_HP			BIT(1)
+#define	DYNAMIC_FUNC_SS			BIT(2) //Tx Power Tracking
+#define DYNAMIC_FUNC_BT			BIT(3)
+
+#define _HW_STATE_NOLINK_		0x00
+#define _HW_STATE_ADHOC_		0x01
+#define _HW_STATE_STATION_ 	0x02
+#define _HW_STATE_AP_			0x03
+
+
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+
+//
+// Channel Plan Type.
+// Note: 
+//	We just add new channel plan when the new channel plan is different from any of the following 
+//	channel plan. 
+//	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan,
+//	customize them in RT_CHANNEL_INFO in the RT_CHANNEL_LIST.
+// 
+typedef enum _RT_CHANNEL_DOMAIN
+{
+	RT_CHANNEL_DOMAIN_FCC = 0,
+	RT_CHANNEL_DOMAIN_IC = 1,
+	RT_CHANNEL_DOMAIN_ETSI = 2,
+	RT_CHANNEL_DOMAIN_SPAIN = 3,
+	RT_CHANNEL_DOMAIN_FRANCE = 4,
+	RT_CHANNEL_DOMAIN_MKK = 5,
+	RT_CHANNEL_DOMAIN_MKK1 = 6,
+	RT_CHANNEL_DOMAIN_ISRAEL = 7,
+	RT_CHANNEL_DOMAIN_TELEC = 8,
+	RT_CHANNEL_DOMAIN_MIC = 9,				// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN = 10,		// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_13 = 11,		// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_TELEC_NETGEAR = 12,		// Be compatible with old channel plan. No good!
+	RT_CHANNEL_DOMAIN_NCC = 13,
+	//===== Add new channel plan above this line===============//
+	RT_CHANNEL_DOMAIN_MAX,
+}RT_CHANNEL_DOMAIN, *PRT_CHANNEL_DOMAIN;
+
+typedef struct _RT_CHANNEL_PLAN
+{
+	u8	Channel[32];
+	u8	Len;
+}RT_CHANNEL_PLAN, *PRT_CHANNEL_PLAN;
+
+
+// Scan type including active and passive scan.
+typedef enum _RT_SCAN_TYPE
+{
+	SCAN_PASSIVE,
+	SCAN_ACTIVE,
+	SCAN_MIX,
+}RT_SCAN_TYPE, *PRT_SCAN_TYPE;
+
+
+enum Associated_AP
+{
+	atherosAP	= 0,
+	broadcomAP	= 1,
+	ciscoAP		= 2,
+	marvellAP	= 3,
+	ralinkAP	= 4,
+	realtekAP	= 5,
+	airgocapAP 	= 6,
+	unknownAP	= 7,
+	maxAP,
+};
+
+
+struct mlme_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
+};
+
+struct action_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
+};
+
+struct	ss_res	
+{
+	int							state;
+	int							bss_cnt;
+	int							channel_idx;
+	int							scan_mode;
+	int							ss_ssidlen;
+	unsigned char 	ss_ssid[IW_ESSID_MAX_SIZE + 1];
+};
+
+//#define AP_MODE				0x0C
+//#define STATION_MODE	0x08
+//#define AD_HOC_MODE		0x04
+//#define NO_LINK_MODE	0x00
+
+#define 	WIFI_FW_NULL_STATE			_HW_STATE_NOLINK_
+#define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
+#define	WIFI_FW_AP_STATE				_HW_STATE_AP_
+#define	WIFI_FW_ADHOC_STATE			_HW_STATE_ADHOC_
+
+#define	WIFI_FW_AUTH_NULL			0x00000100
+#define	WIFI_FW_AUTH_STATE			0x00000200
+#define	WIFI_FW_AUTH_SUCCESS			0x00000400
+
+#define	WIFI_FW_ASSOC_STATE			0x00002000
+#define	WIFI_FW_ASSOC_SUCCESS		0x00004000
+
+#define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_ASSOC_STATE)
+
+struct FW_Sta_Info
+{
+	struct sta_info	*psta;
+	unsigned char		status;
+	unsigned int		rx_pkt;
+	unsigned int		retry;
+	NDIS_802_11_RATES_EX  SupportedRates;
+};
+
+struct mlme_ext_info
+{
+	unsigned int		state;
+	unsigned int		reauth_count;
+	unsigned int		reassoc_count;
+	unsigned int		link_count;
+	unsigned int		auth_seq;
+	unsigned int		auth_algo;	// 802.11 auth, could be open, shared, auto
+	unsigned int 		authModeToggle;
+	unsigned int		enc_algo;//encrypt algorithm;
+	unsigned int		key_index;	// this is only valid for legendary wep, 0~3 for key id.
+	unsigned char 		key_mask;
+	unsigned int		iv;
+	unsigned char		chg_txt[128];
+	unsigned short		aid;
+	unsigned short	bcn_interval;
+	unsigned char		assoc_AP_vendor;
+	unsigned char		slotTime;
+	unsigned char		ERP_enable;
+	unsigned char		ERP_IE;
+	unsigned char		turboMode_cts2self;
+	unsigned char		turboMode_rtsen;
+	unsigned char		WMM_enable;
+	unsigned char		HT_enable;
+	unsigned char		HT_caps_enable;
+	unsigned char		HT_info_enable;
+	unsigned char		HT_protection;
+	unsigned char		agg_enable_bitmap;
+	unsigned char		ADDBA_retry_count;
+	unsigned char		candidate_tid_bitmap;
+	struct ADDBA_request		ADDBA_req;
+	struct WMM_para_element	WMM_param;
+	struct HT_caps_element	HT_caps;
+	struct HT_info_element	HT_info;
+	WLAN_BSSID_EX network;//join network or bss_network, if in ap mode, it is the same to cur_network.network
+	struct FW_Sta_Info FW_sta_info[NUM_STA];
+	// Accept ADDBA Request
+	BOOLEAN				bAcceptAddbaReq;	
+	unsigned char              bwmode_updated;	
+};
+// The channel information about this channel including joining, scanning, and power constraints.
+typedef struct _RT_CHANNEL_INFO
+{
+	u8				ChannelNum;		// The channel number.
+	RT_SCAN_TYPE	ScanType;		// Scan type such as passive or active scan.
+	//u16				ScanPeriod;		// Listen time in millisecond in this channel.
+	//s32				MaxTxPwrDbm;	// Max allowed tx power.
+	//u32				ExInfo;			// Extended Information for this channel.
+}RT_CHANNEL_INFO, *PRT_CHANNEL_INFO;
+
+struct mlme_ext_priv
+{
+	_adapter			*padapter;
+	unsigned char		mlmeext_init;
+	u8				event_seq;
+	unsigned short	mgnt_seq;
+	
+	//struct fw_priv 	fwpriv;
+	
+	unsigned char		cur_channel;
+	unsigned char		cur_bwmode;
+	unsigned char 		cur_ch_offset;//PRIME_CHNL_OFFSET
+	unsigned char 		cur_wireless_mode;
+	//unsigned char		channel_set[NUM_CHANNELS];
+	unsigned char			max_chan_nums;
+	RT_CHANNEL_INFO		channel_set[NUM_CHANNELS];
+	
+	unsigned char		basicrate[NumRates];
+	unsigned char		datarate[NumRates];
+	
+	struct ss_res		sitesurvey_res;		
+	struct mlme_ext_info	mlmext_info;//for sta/adhoc mode, including current scanning/connecting/connected related info.
+                                                     //for ap mode, network includes ap's cap_info
+	_timer		survey_timer;
+	_timer		link_timer;
+	//_timer		ADDBA_timer;
+	u8			chan_scan_time;
+
+	unsigned int	linked_to;//linked timeout
+	
+	u64 TSFValue;
+	
+#ifdef CONFIG_AP_MODE	
+	unsigned char bstart_bss;
+#endif
+
+};
+
+int init_mlme_ext_priv(_adapter* padapter);
+void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext);
+extern void init_mlme_ext_timer(_adapter *padapter);
+extern void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta);
+
+extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
+
+//void fill_fwpriv(_adapter * padapter, struct fw_priv *pfwpriv);
+
+unsigned char networktype_to_raid(unsigned char network_type);
+int judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen);
+void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len);
+
+void Save_DM_Func_Flag(_adapter *padapter);
+void Restore_DM_Func_Flag(_adapter *padapter);
+void Switch_DM_Func(_adapter *padapter, u8 mode, u8 enable);
+
+void Set_NETYPE1_MSR(_adapter *padapter, u8 type);
+void Set_NETYPE0_MSR(_adapter *padapter, u8 type);
+
+void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode);
+void SelectChannel(_adapter *padapter, unsigned char channel);
+void SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char channel_offset);
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
+
+void write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key);
+void read_cam(_adapter *padapter ,u8 entry);
+
+void invalidate_cam_all(_adapter *padapter);
+void CAM_mark_invalid(PADAPTER Adapter, u8 ucIndex);
+void CAM_empty_entry(PADAPTER Adapter, u8 ucIndex);
+
+
+int allocate_cam_entry(_adapter *padapter);
+void flush_all_cam_entry(_adapter *padapter);
+
+
+void site_survey(_adapter *padapter);
+u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
+
+int get_bsstype(unsigned short capability);
+u8* get_my_bssid(WLAN_BSSID_EX *pnetwork);
+u16 get_beacon_interval(WLAN_BSSID_EX *bss);
+
+int is_client_associated_to_ap(_adapter *padapter);
+int is_client_associated_to_ibss(_adapter *padapter);
+int is_IBSS_empty(_adapter *padapter);
+
+unsigned char check_assoc_AP(u8 *pframe, uint len);
+
+int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE);
+void WMMOnAssocRsp(_adapter *padapter);
+
+void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HTOnAssocRsp(_adapter *padapter);
+
+void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void VCS_update(_adapter *padapter, struct sta_info *psta);
+
+void update_beacon_info(_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
+
+void update_IOT_info(_adapter *padapter);
+void update_EDCA_param(_adapter *padapter);
+int update_sta_support_rate(_adapter *padapter, u8* pvar_ie, uint var_ie_len, int cam_idx);
+
+void Update_RA_Entry(_adapter *padapter, unsigned int mac_id);
+void enable_rate_adaptive(_adapter *padapter);
+void set_sta_rate(_adapter *padapter);
+
+unsigned int receive_disconnect(_adapter *padapter, unsigned char *MacAddr);
+
+unsigned char get_highest_rate_idx(u32 mask);
+int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps);
+unsigned int is_ap_in_tkip(_adapter *padapter);
+
+
+void report_join_res(_adapter *padapter, int res);
+void report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
+void report_surveydone_event(_adapter *padapter);
+void report_del_sta_event(_adapter *padapter, unsigned char* MacAddr);
+void report_add_sta_event(_adapter *padapter, unsigned char* MacAddr, int cam_idx);
+
+void beacon_timing_control(_adapter *padapter);
+extern u8 set_tx_beacon_cmd(_adapter*padapter);
+unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame);
+void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+void dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe);
+
+void issue_beacon(_adapter *padapter);
+void issue_probersp(_adapter *padapter, unsigned char *da);
+void issue_assocreq(_adapter *padapter);
+void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status);
+//	Added by Albert 2010/07/26
+//	blnbc: 1 -> broadcast probe request
+//	blnbc: 0 -> unicast probe request. The address 1 will be the BSSID.
+void issue_probereq(_adapter *padapter, u8 blnbc);
+void issue_nulldata(_adapter *padapter, unsigned int power_mode);
+void issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
+void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status);
+unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr);
+
+void start_clnt_assoc(_adapter *padapter);
+void start_clnt_auth(_adapter* padapter);
+void start_clnt_join(_adapter* padapter);
+void start_create_ibss(_adapter* padapter);
+
+unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int DoReserved(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAtim(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAuthClient(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame);
+
+unsigned int OnAction_qos(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_dls(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_public(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_ht(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_wmm(_adapter *padapter, union recv_frame *precv_frame);
+
+void mlmeext_joinbss_event_callback(_adapter *padapter);
+void mlmeext_sta_del_event_callback(_adapter *padapter);
+void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta);
+
+void linked_status_chk(_adapter *padapter);
+
+void survey_timer_hdl (_adapter *padapter);
+void link_timer_hdl (_adapter *padapter);
+void addba_timer_hdl(struct sta_info *psta);
+//void reauth_timer_hdl(_adapter *padapter);
+//void reassoc_timer_hdl(_adapter *padapter);
+
+
+extern int cckrates_included(unsigned char *rate, int ratelen);
+extern int cckratesonly_included(unsigned char *rate, int ratelen);
+
+extern void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr);
+
+extern void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
+extern void correct_TSF(_adapter *padapter, struct mlme_ext_priv *pmlmeext);
+
+extern void ResumeTxBeacon(_adapter *padapter);
+extern void StopTxBeacon(_adapter *padapter);
+
+#ifdef CONFIG_AP_MODE
+void init_mlme_ap_info(_adapter *padapter);
+#ifdef CONFIG_NATIVEAP_MLME
+void	expire_timeout_chk(_adapter *padapter);
+#endif //end of CONFIG_NATIVEAP_MLME
+	
+#endif //end of CONFIG_AP_MODE
+
+
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+void silentreset_for_specific_platform(_adapter *padapter);
+#endif
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mlme.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mlme.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mlme.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mlme.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,391 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_MLME_H_
+#define __RTL871X_MLME_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+
+
+#define	MAX_BSS_CNT	64
+//#define   MAX_JOIN_TIMEOUT	2500
+//#define   MAX_JOIN_TIMEOUT	2000
+#define   MAX_JOIN_TIMEOUT	6500
+
+#define 	SCANNING_TIMEOUT 	6000
+
+#define	SCAN_INTERVAL	(30) // unit:2sec, 30*2=60sec
+
+
+#ifdef PALTFORM_OS_WINCE
+#define	SCANQUEUE_LIFETIME 12000000 // unit:us
+#else
+#define	SCANQUEUE_LIFETIME 20 // unit:sec
+#endif
+
+#define 	WIFI_NULL_STATE		0x00000000
+#define	WIFI_ASOC_STATE		0x00000001		// Under Linked state...
+#define 	WIFI_REASOC_STATE	       0x00000002
+#define	WIFI_SLEEP_STATE	       0x00000004
+#define	WIFI_STATION_STATE	0x00000008
+#define	WIFI_AP_STATE				0x00000010
+#define	WIFI_ADHOC_STATE			0x00000020
+#define   WIFI_ADHOC_MASTER_STATE 0x00000040
+#define   WIFI_UNDER_LINKING		0x00000080
+//#define WIFI_UNDER_CMD			0x00000200
+#define WIFI_SITE_MONITOR		0x00000800		//to indicate the station is under site surveying
+
+#ifdef WDS
+#define	WIFI_WDS				0x00001000
+#define	WIFI_WDS_RX_BEACON	0x00002000		// already rx WDS AP beacon
+#endif
+#ifdef AUTO_CONFIG
+#define	WIFI_AUTOCONF			0x00004000
+#define	WIFI_AUTOCONF_IND	0x00008000
+#endif
+
+//#ifdef UNDER_MPTEST
+#define	WIFI_MP_STATE						0x00010000
+#define	WIFI_MP_CTX_BACKGROUND			0x00020000	// in continous tx background
+#define	WIFI_MP_CTX_ST					0x00040000	// in continous tx with single-tone
+#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	// pending in continous tx background due to out of skb
+#define	WIFI_MP_CTX_CCK_HW				0x00100000	// in continous tx
+#define	WIFI_MP_CTX_CCK_CS				0x00200000	// in continous tx with carrier suppression
+#define   WIFI_MP_LPBK_STATE				0x00400000
+//#endif
+
+//#define _FW_UNDER_CMD		WIFI_UNDER_CMD
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#define _FW_LINKED			WIFI_ASOC_STATE
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+enum dot11AuthAlgrthmNum {
+ dot11AuthAlgrthm_Open = 0,
+ dot11AuthAlgrthm_Shared,
+ dot11AuthAlgrthm_8021X,
+ dot11AuthAlgrthm_Auto,
+ dot11AuthAlgrthm_MaxNum
+};
+
+
+/*
+
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+
+
+Each _queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+
+*/
+
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	sint	traffic_busy;
+	_timer	sitesurvey_ctrl_timer;
+};
+
+struct mlme_priv {
+
+	_lock	lock;
+	sint	fw_state;	//shall we protect this variable? maybe not necessarily...
+
+	u8 to_join; //flag
+	u8 *nic_hdl;
+
+	_list		*pscanned;
+	_queue	free_bss_pool;
+	_queue	scanned_queue;
+	u8	*free_bss_buf;
+	unsigned long	num_of_scanned;
+
+	NDIS_802_11_SSID	assoc_ssid;
+	u8	assoc_bssid[6];
+
+	struct wlan_network	cur_network;
+
+	struct sitesurvey_ctrl sitesurveyctrl;
+
+	//uint wireless_mode; no used, remove it
+
+	u32 scan_interval;
+
+
+	_timer assoc_timer;
+
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+
+	_timer scan_to_timer; // driver itself handles scan_timeout status.	
+
+	struct qos_priv qospriv;
+
+#ifdef CONFIG_80211N_HT
+
+	/* Number of non-HT AP/stations */
+	int num_sta_no_ht;
+
+	/* Number of HT AP/stations 20 MHz */
+	//int num_sta_ht_20mhz; 
+
+
+	int num_FortyMHzIntolerant;
+
+	struct ht_priv	htpriv;
+
+#endif
+
+	_timer	dynamic_chk_timer; //dynamic/periodic check timer
+ 
+	u8	ChannelPlan;
+ 
+	u8 	scan_mode; // active: 1, passive: 0
+ 
+};
+
+#ifdef CONFIG_AP_MODE
+
+struct hostapd_priv
+{
+	_adapter *padapter;
+	
+#ifdef CONFIG_HOSTAPD_MLME
+	struct net_device *pmgnt_netdev;
+	struct usb_anchor anchored;
+#endif	
+	
+};
+
+extern int hostapd_mode_init(_adapter *padapter);
+extern void hostapd_mode_unload(_adapter *padapter);
+#endif
+
+extern void rtw_survey_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_surveydone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_atimdone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_cpwm_event_callback(_adapter *adapter, u8 *pbuf);
+
+#ifdef PLATFORM_WINDOWS
+extern thread_return event_thread(void *context);
+extern void sitesurvey_ctrl_handler(
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+extern void rtw_join_timeout_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+
+extern void _rtw_scan_timeout_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+
+#endif
+
+#ifdef PLATFORM_LINUX
+extern int event_thread(void *context);
+extern void sitesurvey_ctrl_handler(void* FunctionContext);
+extern void rtw_join_timeout_handler(void* FunctionContext);
+extern void _rtw_scan_timeout_handler(void* FunctionContext);
+#endif
+
+extern void rtw_free_network_queue(_adapter *adapter,u8 isfreeall);
+extern int rtw_init_mlme_priv(_adapter *adapter);// (struct mlme_priv *pmlmepriv);
+
+extern void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv);
+
+
+extern sint rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
+extern sint rtw_set_key(_adapter *adapter,struct security_priv *psecuritypriv,sint keyid);
+extern sint rtw_set_auth(_adapter *adapter,struct security_priv *psecuritypriv);
+
+__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv)
+{	//if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid
+	// if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+__inline static sint check_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	if (pmlmepriv->fw_state & state)
+		return _TRUE;
+
+	return _FALSE;
+}
+
+__inline static sint get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+ */
+__inline static void set_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state |= state;
+}
+
+__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state &= ~state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+__inline static void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	if (check_fwstate(pmlmepriv, state) == _TRUE)
+		pmlmepriv->fw_state ^= state;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+__inline static void clr_fwstate_ex(struct mlme_priv *pmlmepriv, sint state)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	_clr_fwstate_(pmlmepriv, state);
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+__inline static void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned++;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+__inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned--;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+__inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, sint val)
+{
+	_irqL irqL;
+
+	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	pmlmepriv->num_of_scanned = val;
+	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+}
+
+extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
+extern void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target);
+extern void disconnect_hdl_under_linked(_adapter* adapter, struct sta_info *psta, u8 free_assoc);
+extern void rtw_generate_random_ibss(u8 *pibss);
+static struct wlan_network* find_network(_queue *scanned_queue, u8 *addr);
+extern struct wlan_network* rtw_get_oldest_wlan_network(_queue *scanned_queue);
+
+extern void rtw_free_assoc_resources(_adapter* adapter);
+extern void rtw_indicate_disconnect(_adapter* adapter);
+extern void rtw_indicate_connect(_adapter* adapter);
+
+extern int rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie,u8 *out_ie,uint in_len);
+extern int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len);
+extern void rtw_init_registrypriv_dev_network(_adapter *adapter);
+
+extern void rtw_update_registrypriv_dev_network(_adapter *adapter);
+
+extern void rtw_get_encrypt_decrypt_from_registrypriv(_adapter *adapter);
+
+extern void _rtw_sitesurvey_ctrl_handler(_adapter *adapter);
+extern void _rtw_join_timeout_handler(_adapter *adapter);
+extern void rtw_scan_timeout_handler(_adapter *adapter);
+
+extern void dynamic_check_timer_handlder(_adapter *adapter);
+
+
+extern int _rtw_init_mlme_priv(_adapter *padapter);
+
+static void _free_mlme_priv(struct mlme_priv *pmlmepriv);
+
+extern int _rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork);
+
+extern struct wlan_network* _rtw_dequeue_network(_queue *queue);
+
+extern struct wlan_network* _rtw_alloc_network(struct mlme_priv *pmlmepriv);
+
+
+extern void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork,u8 isfreeall);
+static void _free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+
+
+extern struct wlan_network* _rtw_find_network(_queue *scanned_queue, u8 *addr);
+
+extern void _rtw_free_network_queue(_adapter* padapter,u8 isfreeall);
+
+extern sint rtw_if_up(_adapter *padapter);
+
+
+u8 *rtw_get_capability_from_ie(u8 *ie);
+u8 *rtw_get_timestampe_from_ie(u8 *ie);
+u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
+
+
+void rtw_joinbss_reset(_adapter *padapter);
+
+#ifdef CONFIG_80211N_HT
+unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
+void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len);
+void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe);
+#endif
+
+
+int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork);
+
+#endif //__RTL871X_MLME_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mp.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mp.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mp.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mp.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,464 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_MP_H_
+#define __RTL871X_MP_H_
+
+
+#ifndef PLATFORM_WINDOWS
+//	00 - Success
+//	11 - Error
+#define STATUS_SUCCESS				(0x00000000L)
+#define STATUS_PENDING				(0x00000103L)
+
+#define STATUS_UNSUCCESSFUL			(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
+#define STATUS_NOT_SUPPORTED			(0xC00000BBL)
+
+#define NDIS_STATUS_SUCCESS			((NDIS_STATUS)STATUS_SUCCESS)
+#define NDIS_STATUS_PENDING			((NDIS_STATUS) STATUS_PENDING)
+#define NDIS_STATUS_NOT_RECOGNIZED		((NDIS_STATUS)0x00010001L)
+#define NDIS_STATUS_NOT_COPIED			((NDIS_STATUS)0x00010002L)
+#define NDIS_STATUS_NOT_ACCEPTED		((NDIS_STATUS)0x00010003L)
+#define NDIS_STATUS_CALL_ACTIVE			((NDIS_STATUS)0x00010007L)
+
+#define NDIS_STATUS_FAILURE			((NDIS_STATUS) STATUS_UNSUCCESSFUL)
+#define NDIS_STATUS_RESOURCES			((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
+#define NDIS_STATUS_CLOSING			((NDIS_STATUS)0xC0010002L)
+#define NDIS_STATUS_BAD_VERSION			((NDIS_STATUS)0xC0010004L)
+#define NDIS_STATUS_BAD_CHARACTERISTICS		((NDIS_STATUS)0xC0010005L)
+#define NDIS_STATUS_ADAPTER_NOT_FOUND		((NDIS_STATUS)0xC0010006L)
+#define NDIS_STATUS_OPEN_FAILED			((NDIS_STATUS)0xC0010007L)
+#define NDIS_STATUS_DEVICE_FAILED		((NDIS_STATUS)0xC0010008L)
+#define NDIS_STATUS_MULTICAST_FULL		((NDIS_STATUS)0xC0010009L)
+#define NDIS_STATUS_MULTICAST_EXISTS		((NDIS_STATUS)0xC001000AL)
+#define NDIS_STATUS_MULTICAST_NOT_FOUND		((NDIS_STATUS)0xC001000BL)
+#define NDIS_STATUS_REQUEST_ABORTED		((NDIS_STATUS)0xC001000CL)
+#define NDIS_STATUS_RESET_IN_PROGRESS		((NDIS_STATUS)0xC001000DL)
+#define NDIS_STATUS_CLOSING_INDICATING		((NDIS_STATUS)0xC001000EL)
+#define NDIS_STATUS_NOT_SUPPORTED		((NDIS_STATUS)STATUS_NOT_SUPPORTED)
+#define NDIS_STATUS_INVALID_PACKET		((NDIS_STATUS)0xC001000FL)
+#define NDIS_STATUS_OPEN_LIST_FULL		((NDIS_STATUS)0xC0010010L)
+#define NDIS_STATUS_ADAPTER_NOT_READY		((NDIS_STATUS)0xC0010011L)
+#define NDIS_STATUS_ADAPTER_NOT_OPEN		((NDIS_STATUS)0xC0010012L)
+#define NDIS_STATUS_NOT_INDICATING		((NDIS_STATUS)0xC0010013L)
+#define NDIS_STATUS_INVALID_LENGTH		((NDIS_STATUS)0xC0010014L)
+#define NDIS_STATUS_INVALID_DATA		((NDIS_STATUS)0xC0010015L)
+#define NDIS_STATUS_BUFFER_TOO_SHORT		((NDIS_STATUS)0xC0010016L)
+#define NDIS_STATUS_INVALID_OID			((NDIS_STATUS)0xC0010017L)
+#define NDIS_STATUS_ADAPTER_REMOVED		((NDIS_STATUS)0xC0010018L)
+#define NDIS_STATUS_UNSUPPORTED_MEDIA		((NDIS_STATUS)0xC0010019L)
+#define NDIS_STATUS_GROUP_ADDRESS_IN_USE	((NDIS_STATUS)0xC001001AL)
+#define NDIS_STATUS_FILE_NOT_FOUND		((NDIS_STATUS)0xC001001BL)
+#define NDIS_STATUS_ERROR_READING_FILE		((NDIS_STATUS)0xC001001CL)
+#define NDIS_STATUS_ALREADY_MAPPED		((NDIS_STATUS)0xC001001DL)
+#define NDIS_STATUS_RESOURCE_CONFLICT		((NDIS_STATUS)0xC001001EL)
+#define NDIS_STATUS_NO_CABLE			((NDIS_STATUS)0xC001001FL)
+
+#define NDIS_STATUS_INVALID_SAP			((NDIS_STATUS)0xC0010020L)
+#define NDIS_STATUS_SAP_IN_USE			((NDIS_STATUS)0xC0010021L)
+#define NDIS_STATUS_INVALID_ADDRESS		((NDIS_STATUS)0xC0010022L)
+#define NDIS_STATUS_VC_NOT_ACTIVATED		((NDIS_STATUS)0xC0010023L)
+#define NDIS_STATUS_DEST_OUT_OF_ORDER		((NDIS_STATUS)0xC0010024L)  // cause 27
+#define NDIS_STATUS_VC_NOT_AVAILABLE		((NDIS_STATUS)0xC0010025L)  // cause 35,45
+#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE	((NDIS_STATUS)0xC0010026L)  // cause 37
+#define NDIS_STATUS_INCOMPATABLE_QOS		((NDIS_STATUS)0xC0010027L)  // cause 49
+#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED	((NDIS_STATUS)0xC0010028L)  // cause 93
+#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION	((NDIS_STATUS)0xC0010029L)  // cause 3
+#endif /* #ifndef PLATFORM_WINDOWS */
+
+#define MPT_NOOP			0
+#define MPT_READ_MAC_1BYTE		1
+#define MPT_READ_MAC_2BYTE		2
+#define MPT_READ_MAC_4BYTE		3
+#define MPT_WRITE_MAC_1BYTE		4
+#define MPT_WRITE_MAC_2BYTE		5
+#define MPT_WRITE_MAC_4BYTE		6
+#define MPT_READ_BB_CCK			7
+#define MPT_WRITE_BB_CCK		8
+#define MPT_READ_BB_OFDM		9
+#define MPT_WRITE_BB_OFDM		10
+#define MPT_READ_RF			11
+#define MPT_WRITE_RF			12
+#define MPT_READ_EEPROM_1BYTE		13
+#define MPT_WRITE_EEPROM_1BYTE		14
+#define MPT_READ_EEPROM_2BYTE		15
+#define MPT_WRITE_EEPROM_2BYTE		16
+#define MPT_SET_CSTHRESHOLD		21
+#define MPT_SET_INITGAIN		22
+#define MPT_SWITCH_BAND			23
+#define MPT_SWITCH_CHANNEL		24
+#define MPT_SET_DATARATE		25
+#define MPT_SWITCH_ANTENNA		26
+#define MPT_SET_TX_POWER		27
+#define MPT_SET_CONT_TX			28
+#define MPT_SET_SINGLE_CARRIER		29
+#define MPT_SET_CARRIER_SUPPRESSION	30
+#define MPT_GET_RATE_TABLE		31
+#define MPT_READ_TSSI			32
+#define MPT_GET_THERMAL_METER		33
+
+
+#define MAX_MP_XMITBUF_SZ 	2048
+#define NR_MP_XMITFRAME		8
+
+struct mp_xmit_frame
+{
+	_list	list;
+
+	struct pkt_attrib attrib;
+
+	_pkt *pkt;
+
+	int frame_tag;
+
+	_adapter *padapter;
+
+#ifdef CONFIG_USB_HCI
+
+	//insert urb, irp, and irpcnt info below...
+	//max frag_cnt = 8
+
+	u8 *mem_addr;
+	u32 sz[8];
+
+#if defined(PLATFORM_OS_XP) || defined(PLATFORM_LINUX)
+	PURB pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PIRP pxmit_irp[8];
+#endif
+
+	u8 bpending[8];
+	sint ac_tag[8];
+	sint last[8];
+	uint irpcnt;
+	uint fragcnt;
+#endif /* CONFIG_USB_HCI */
+
+	uint mem[(MAX_MP_XMITBUF_SZ >> 2)];
+};
+
+struct mp_wiparam
+{
+	u32 bcompleted;
+	u32 act_type;
+	u32 io_offset;
+	u32 io_value;
+};
+
+typedef void(*wi_act_func)(void* padapter);
+
+#ifdef PLATFORM_WINDOWS
+struct mp_wi_cntx
+{
+	u8 bmpdrv_unload;
+
+	// Work Item
+	NDIS_WORK_ITEM mp_wi;
+	NDIS_EVENT mp_wi_evt;
+	_lock mp_wi_lock;
+	u8 bmp_wi_progress;
+	wi_act_func curractfunc;
+	// Variable needed in each implementation of CurrActFunc.
+	struct mp_wiparam param;
+};
+#endif
+
+struct mp_priv
+{
+	_adapter *papdater;
+
+	//OID cmd handler
+	struct mp_wiparam workparam;
+	u8 act_in_progress;
+
+	//Tx Section
+	u8 TID;
+	u32 tx_pktcount;
+
+	//Rx Section
+	u32 rx_pktcount;
+	u32 rx_crcerrpktcount;
+	u32 rx_pktloss;
+
+	struct recv_stat rxstat;
+
+	//RF/BB relative
+	u32 curr_ch;
+	u32 curr_rateidx;
+	u8 curr_bandwidth;
+	u8 curr_modem;
+	u8 curr_txpoweridx;
+
+	u32 curr_crystalcap;
+
+	u16 antenna_tx;
+	u16 antenna_rx;
+	u8 curr_rfpath;
+
+	u8 check_mp_pkt;
+
+	uint ForcedDataRate;
+
+	struct wlan_network mp_network;
+	NDIS_802_11_MAC_ADDRESS network_macaddr;
+
+	//Testing Flag
+	u32 mode;//0 for normal type packet, 1 for loopback packet (16bytes TXCMD)
+
+	sint prev_fw_state;
+
+#ifdef PLATFORM_WINDOWS
+	u32 rx_testcnt;
+	u32 rx_testcnt1;
+	u32 rx_testcnt2;
+	u32 tx_testcnt;
+	u32 tx_testcnt1;
+
+	struct mp_wi_cntx wi_cntx;
+
+	u8 h2c_result;
+	u8 h2c_seqnum;
+	u16 h2c_cmdcode;
+	u8 h2c_resp_parambuf[512];
+	_lock h2c_lock;
+	_lock wkitm_lock;
+	u32 h2c_cmdcnt;
+	NDIS_EVENT h2c_cmd_evt;
+	NDIS_EVENT c2h_set;
+	NDIS_EVENT h2c_clr;
+	NDIS_EVENT cpwm_int;
+
+	NDIS_EVENT scsir_full_evt;
+	NDIS_EVENT scsiw_empty_evt;
+#endif
+
+	u8 *pallocated_mp_xmitframe_buf;
+	u8 *pmp_xmtframe_buf;
+	_queue free_mp_xmitqueue;
+	u32 free_mp_xmitframe_cnt;
+};
+
+typedef struct _IOCMD_STRUCT_ {
+	u8	cmdclass;
+	u16	value;
+	u8	index;
+}IOCMD_STRUCT;
+
+struct rf_reg_param {
+	u32 path;
+	u32 offset;
+	u32 value;
+};
+
+struct bb_reg_param {
+	u32 offset;
+	u32 value;
+};
+
+struct wifi_status{
+	u8 status;
+	u8 reserve;	
+};
+//=======================================================================
+
+#define LOWER 	_TRUE
+#define RAISE	_FALSE
+
+#if 0
+#define IOCMD_CTRL_REG			0x102502C0
+#define IOCMD_DATA_REG			0x102502C4
+#else
+#define IOCMD_CTRL_REG			0x10250370
+#define IOCMD_DATA_REG			0x10250374
+#endif
+
+#define IOCMD_GET_THERMAL_METER		0xFD000028
+
+#define IOCMD_CLASS_BB_RF		0xF0
+#define IOCMD_BB_READ_IDX		0x00
+#define IOCMD_BB_WRITE_IDX		0x01
+#define IOCMD_RF_READ_IDX		0x02
+#define IOCMD_RF_WRIT_IDX		0x03
+
+#define BB_REG_BASE_ADDR		0x800
+
+
+#define RF_PATH_A 	0
+#define RF_PATH_B 	1
+#define RF_PATH_C 	2
+#define RF_PATH_D 	3
+
+#define MAX_RF_PATH_NUMS	2
+
+
+#define _2MAC_MODE_	0
+#define _LOOPBOOK_MODE_	1
+
+static u8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+
+/* MP set force data rate base on the definition. */
+typedef enum _MPT_RATE_INDEX
+{
+	/* CCK rate. */
+	MPT_RATE_1M,	/* 0 */
+	MPT_RATE_2M,
+	MPT_RATE_55M,
+	MPT_RATE_11M,	/* 3 */
+
+	/* OFDM rate. */
+	MPT_RATE_6M,	/* 4 */
+	MPT_RATE_9M,
+	MPT_RATE_12M,
+	MPT_RATE_18M,
+	MPT_RATE_24M,
+	MPT_RATE_36M,
+	MPT_RATE_48M,
+	MPT_RATE_54M,	/* 11 */
+
+	/* HT rate. */
+	MPT_RATE_MCS0,	/* 12 */
+	MPT_RATE_MCS1,
+	MPT_RATE_MCS2,
+	MPT_RATE_MCS3,
+	MPT_RATE_MCS4,
+	MPT_RATE_MCS5,
+	MPT_RATE_MCS6,
+	MPT_RATE_MCS7,	/* 19 */
+	MPT_RATE_MCS8,
+	MPT_RATE_MCS9,
+	MPT_RATE_MCS10,
+	MPT_RATE_MCS11,
+	MPT_RATE_MCS12,
+	MPT_RATE_MCS13,
+	MPT_RATE_MCS14,
+	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_LAST
+}MPT_RATE_E, *PMPT_RATE_E;
+
+#if 0
+// Represent Channel Width in HT Capabilities
+typedef enum _HT_CHANNEL_WIDTH {
+	HT_CHANNEL_WIDTH_20 = 0,
+	HT_CHANNEL_WIDTH_40 = 1,
+}HT_CHANNEL_WIDTH, *PHT_CHANNEL_WIDTH;
+#endif
+
+
+#define MAX_TX_PWR_INDEX_N_MODE 64	// 0x3F
+
+typedef enum _POWER_MODE_ {
+	POWER_LOW = 0,
+	POWER_NORMAL
+}POWER_MODE;
+
+
+#define RX_PKT_BROADCAST	1
+#define RX_PKT_DEST_ADDR	2
+#define RX_PKT_PHY_MATCH	3
+
+#define RPTMaxCount 0x000FFFFF;
+
+// parameter 1 : BitMask
+// 	bit 0  : OFDM PPDU
+//	bit 1  : OFDM False Alarm
+//	bit 2  : OFDM MPDU OK
+//	bit 3  : OFDM MPDU Fail
+//	bit 4  : CCK PPDU
+//	bit 5  : CCK False Alarm
+//	bit 6  : CCK MPDU ok
+//	bit 7  : CCK MPDU fail
+//	bit 8  : HT PPDU counter
+//	bit 9  : HT false alarm
+//	bit 10 : HT MPDU total
+//	bit 11 : HT MPDU OK
+//	bit 12 : HT MPDU fail
+//	bit 15 : RX full drop
+typedef enum _RXPHY_BITMASK_
+{
+	OFDM_PPDU_BIT = 0,
+	OFDM_FALSE_BIT,
+	OFDM_MPDU_OK_BIT,
+	OFDM_MPDU_FAIL_BIT,
+	CCK_PPDU_BIT,
+	CCK_FALSE_BIT,
+	CCK_MPDU_OK_BIT,
+	CCK_MPDU_FAIL_BIT,
+	HT_PPDU_BIT,
+	HT_FALSE_BIT,
+	HT_MPDU_BIT,
+	HT_MPDU_OK_BIT,
+	HT_MPDU_FAIL_BIT,
+} RXPHY_BITMASK;
+
+
+typedef enum _ENCRY_CTRL_STATE_ {
+	HW_CONTROL,		//hw encryption& decryption
+	SW_CONTROL,		//sw encryption& decryption
+	HW_ENCRY_SW_DECRY,	//hw encryption & sw decryption
+	SW_ENCRY_HW_DECRY	//sw encryption & hw decryption
+}ENCRY_CTRL_STATE;
+
+
+//=======================================================================
+extern struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv);
+extern int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe);
+
+extern void mp871xinit(_adapter *padapter);
+
+extern void _irqlevel_changed_(_irqL *irqlevel, u8 bLower);
+//=======================================================================
+extern void	IQCalibrateBcut(PADAPTER pAdapter);
+
+extern u32	bb_reg_read(PADAPTER Adapter, u16 offset);
+extern u8	bb_reg_write(PADAPTER Adapter, u16 offset, u32 value);
+extern u32	rf_reg_read(PADAPTER Adapter, u8 path, u8 offset);
+extern u8	rf_reg_write(PADAPTER Adapter, u8 path, u8 offset, u32 value);
+
+extern u32	get_bb_reg(PADAPTER Adapter, u16 offset, u32 bitmask);
+extern u8	set_bb_reg(PADAPTER Adapter, u16 offset, u32 bitmask, u32 value);
+extern u32	get_rf_reg(PADAPTER Adapter, u8 path, u8 offset, u32 bitmask);
+extern u8	set_rf_reg(PADAPTER Adapter, u8 path, u8 offset, u32 bitmask, u32 value);
+
+extern void	SetChannel(PADAPTER pAdapter);
+extern void	SetTxPower(PADAPTER pAdapte);
+extern void	SetTxAGCOffset(PADAPTER pAdapter, u32 ulTxAGCOffset);
+extern void	SetDataRate(PADAPTER pAdapter);
+extern void	SwitchBandwidth(PADAPTER pAdapter);
+
+extern void	SwitchAntenna(PADAPTER pAdapter);
+
+extern void	SetCrystalCap(PADAPTER pAdapter);
+
+//extern void	TriggerRFThermalMeter(PADAPTER pAdapter);
+extern void	GetThermalMeter(PADAPTER pAdapter, u32 *value);
+
+extern void	SetContinuousTx(PADAPTER pAdapter, u8 bStart);
+extern void	SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
+extern void	SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
+extern void	SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
+
+extern void	ResetPhyRxPktCount(PADAPTER pAdapter);
+extern u32	GetPhyRxPktReceived(PADAPTER pAdapter);
+extern u32	GetPhyRxPktCRC32Error(PADAPTER pAdapter);
+
+#endif //__RTL871X_MP_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mp_ioctl.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mp_ioctl.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mp_ioctl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mp_ioctl.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,577 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_MP_IOCTL_H
+#define _RTL871X_MP_IOCTL_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <mp_custom_oid.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_rtl.h>
+#include <rtl8712_efuse.h>
+
+
+#define TESTFWCMDNUMBER			1000000
+#define TEST_H2CINT_WAIT_TIME		500
+#define TEST_C2HINT_WAIT_TIME		500
+#define HCI_TEST_SYSCFG_HWMASK		1
+#define _BUSCLK_40M			(4 << 2)
+
+//------------------------------------------------------------------------------
+typedef struct CFG_DBG_MSG_STRUCT {
+	u32 DebugLevel;
+	u32 DebugComponent_H32;
+	u32 DebugComponent_L32;
+}CFG_DBG_MSG_STRUCT,*PCFG_DBG_MSG_STRUCT;
+
+typedef struct _RW_REG {
+	uint offset;
+	uint width;
+	u32 value;
+}mp_rw_reg,RW_Reg, *pRW_Reg;
+
+//for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM
+typedef struct _EEPROM_RW_PARAM {
+	uint offset;
+	u16 value;
+}eeprom_rw_param,EEPROM_RWParam, *pEEPROM_RWParam;
+
+typedef struct _EFUSE_ACCESS_STRUCT_ {
+	u16	start_addr;
+	u16	cnts;
+	u8	data[0];
+}EFUSE_ACCESS_STRUCT, *PEFUSE_ACCESS_STRUCT;
+
+typedef struct _BURST_RW_REG {
+	uint offset;
+	uint len;
+	u8 Data[256];
+}burst_rw_reg,Burst_RW_Reg, *pBurst_RW_Reg;
+
+typedef struct _USB_VendorReq{
+	u8	bRequest;
+	u16	wValue;
+	u16	wIndex;
+	u16	wLength;
+	u8	u8Dir;//0:OUT, 1:IN
+	u8	u8InData;
+}usb_vendor_req, USB_VendorReq, *pUSB_VendorReq;
+
+typedef struct _DR_VARIABLE_STRUCT_ {
+	u8 offset;
+	u32 variable;
+}DR_VARIABLE_STRUCT;
+
+int mp_start_joinbss(_adapter *padapter, NDIS_802_11_SSID *pssid);
+
+void _irqlevel_changed_(_irqL *irqlevel, /*BOOLEAN*/unsigned char  bLower);
+
+
+// oid_rtl_seg_87_11_00
+NDIS_STATUS oid_rt_pro8711_join_bss_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_read_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_write_register_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_txcmd_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_write16_eeprom_hdl (struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_rd_attrib_mem_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_wr_attrib_mem_hdl (struct oid_par_priv* poid_par_priv);
+NDIS_STATUS  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_poll_rx_status_hdl(struct oid_par_priv* poid_par_priv);
+// oid_rtl_seg_87_11_20
+NDIS_STATUS oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_tssi_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_87_11_50
+NDIS_STATUS oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_87_11_F0
+NDIS_STATUS oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_80_00
+NDIS_STATUS oid_rt_pro_set_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_start_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_stop_test_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv* poid_par_priv);
+//oid_rtl_seg_81_80_20
+NDIS_STATUS oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_modulation_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_87
+NDIS_STATUS oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+
+//oid_rtl_seg_81_85
+NDIS_STATUS oid_rt_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+//oid_rtl_seg_87_12_00
+NDIS_STATUS oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_add_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_current_size_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_set_bandwidth_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_crystal_cap_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_set_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_max_size_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_get_thermal_meter_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_set_power_down_hdl(struct oid_par_priv* poid_par_priv);
+
+NDIS_STATUS oid_rt_get_power_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+#ifdef _RTL871X_MP_IOCTL_C_
+
+const struct oid_obj_priv oid_rtl_seg_81_80_00[] =
+{
+	{1, &oid_null_function},			//0x00	OID_RT_PRO_RESET_DUT
+	{1, &oid_rt_pro_set_data_rate_hdl},		//0x01
+	{1, &oid_rt_pro_start_test_hdl},		//0x02
+	{1, &oid_rt_pro_stop_test_hdl},			//0x03
+	{1, &oid_null_function},			//0x04	OID_RT_PRO_SET_PREAMBLE
+	{1, &oid_null_function},			//0x05	OID_RT_PRO_SET_SCRAMBLER
+	{1, &oid_null_function},			//0x06	OID_RT_PRO_SET_FILTER_BB
+	{1, &oid_null_function},			//0x07	OID_RT_PRO_SET_MANUAL_DIVERSITY_BB
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	//0x08
+	{1, &oid_null_function},			//0x09	OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL
+	{1, &oid_null_function},			//0x0A	OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL
+	{1, &oid_rt_pro_set_continuous_tx_hdl},		//0x0B	OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl},	//0x0C	OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS
+	{1, &oid_null_function},			//0x0D	OID_RT_PRO_SET_TX_ANTENNA_BB
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		//0x0E
+	{1, &oid_null_function},			//0x0F	OID_RT_PRO_SET_CR_SCRAMBLER
+	{1, &oid_null_function},			//0x10	OID_RT_PRO_SET_CR_NEW_FILTER
+	{1, &oid_rt_pro_set_tx_power_control_hdl},	//0x11	OID_RT_PRO_SET_TX_POWER_CONTROL
+	{1, &oid_null_function},			//0x12	OID_RT_PRO_SET_CR_TX_CONFIG
+	{1, &oid_null_function},			//0x13	OID_RT_PRO_GET_TX_POWER_CONTROL
+	{1, &oid_null_function},			//0x14	OID_RT_PRO_GET_CR_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x15	OID_RT_PRO_SET_CR_SETPOINT
+	{1, &oid_null_function},			//0x16	OID_RT_PRO_SET_INTEGRATOR
+	{1, &oid_null_function},			//0x17	OID_RT_PRO_SET_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x18	OID_RT_PRO_GET_INTEGRATOR
+	{1, &oid_null_function},			//0x19	OID_RT_PRO_GET_SIGNAL_QUALITY
+	{1, &oid_null_function},			//0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE
+	{1, &oid_null_function},			//0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS
+	{1, &oid_null_function},			//0x1C	OID_RT_PRO_READ_MAC_ADDRESS
+	{1, &oid_null_function},			//0x1D	OID_RT_PRO_WRITE_CIS_DATA
+	{1, &oid_null_function},			//0x1E	OID_RT_PRO_READ_CIS_DATA
+	{1, &oid_null_function}				//0x1F	OID_RT_PRO_WRITE_POWER_CONTROL
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_20[] =
+{
+	{1, &oid_null_function},			//0x20	OID_RT_PRO_READ_POWER_CONTROL
+	{1, &oid_null_function},			//0x21	OID_RT_PRO_WRITE_EEPROM
+	{1, &oid_null_function},			//0x22	OID_RT_PRO_READ_EEPROM
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	//0x23
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	//0x24
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	//0x25
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	//0x26
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},	//0x27
+	{1, &oid_null_function},			//0x28	OID_RT_PRO_QUERY_CURRENT_ADDRESS
+	{1, &oid_null_function},			//0x29	OID_RT_PRO_QUERY_PERMANENT_ADDRESS
+	{1, &oid_null_function},			//0x2A	OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},//0x2B	OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX
+	{1, &oid_null_function},			//0x2C	OID_RT_PRO_RECEIVE_PACKET
+	{1, &oid_null_function},			//0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE
+	{1, &oid_null_function},			//0x2E	OID_RT_PRO_READ_EEPROM_BYTE
+	{1, &oid_rt_pro_set_modulation_hdl}		//0x2F
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_40[] =
+{
+	{1, &oid_null_function},			//0x40
+	{1, &oid_null_function},			//0x41
+	{1, &oid_null_function},			//0x42
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	//0x43
+	{1, &oid_null_function},			//0x44
+	{1, &oid_null_function}				//0x45
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_80[] =
+{
+	{1, &oid_null_function},			//0x80	OID_RT_DRIVER_OPTION
+	{1, &oid_null_function},			//0x81	OID_RT_RF_OFF
+	{1, &oid_null_function}				//0x82	OID_RT_AUTH_STATUS
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_85[] =
+{
+	{1, &oid_rt_wireless_mode_hdl}			//0x00	OID_RT_WIRELESS_MODE
+};
+
+struct oid_obj_priv oid_rtl_seg_81_87[] =
+{
+	{1, &oid_null_function},			//0x80	OID_RT_PRO8187_WI_POLL
+	{1, &oid_rt_pro_write_bb_reg_hdl},		//0x81
+	{1, &oid_rt_pro_read_bb_reg_hdl},		//0x82
+	{1, &oid_rt_pro_write_rf_reg_hdl},		//0x82
+	{1, &oid_rt_pro_read_rf_reg_hdl}		//0x83
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_00[] =
+{
+	{1, &oid_rt_pro8711_join_bss_hdl},		//0x00  //S
+	{1, &oid_rt_pro_read_register_hdl},		//0x01
+	{1, &oid_rt_pro_write_register_hdl},		//0x02
+	{1, &oid_rt_pro_burst_read_register_hdl},	//0x03
+	{1, &oid_rt_pro_burst_write_register_hdl},	//0x04
+	{1, &oid_rt_pro_write_txcmd_hdl},		//0x05
+	{1, &oid_rt_pro_read16_eeprom_hdl},		//0x06
+	{1, &oid_rt_pro_write16_eeprom_hdl},		//0x07
+	{1, &oid_null_function},			//0x08	OID_RT_PRO_H2C_SET_COMMAND
+	{1, &oid_null_function},			//0x09	OID_RT_PRO_H2C_QUERY_RESULT
+	{1, &oid_rt_pro8711_wi_poll_hdl},		//0x0A
+	{1, &oid_rt_pro8711_pkt_loss_hdl},		//0x0B
+	{1, &oid_rt_rd_attrib_mem_hdl},			//0x0C
+	{1, &oid_rt_wr_attrib_mem_hdl},			//0x0D
+	{1, &oid_null_function},			//0x0E
+	{1, &oid_null_function},			//0x0F
+	{1, &oid_null_function},			//0x10	OID_RT_PRO_H2C_CMD_MODE
+	{1, &oid_null_function},			//0x11	OID_RT_PRO_H2C_CMD_RSP_MODE
+	{1, &oid_null_function},			//0X12	OID_RT_PRO_WAIT_C2H_EVENT
+	{1, &oid_null_function},			//0X13	OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST
+	{1, &oid_null_function},			//0X14	OID_RT_PRO_SCSI_ACCESS_TEST
+	{1, &oid_null_function},			//0X15	OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT
+	{1, &oid_null_function},			//0X16	OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN
+	{1, &oid_null_function},			//0X17	OID_RT_RRO_RX_PKT_VIA_IOCTRL
+	{1, &oid_null_function},			//0X18	OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL
+	{1, &oid_null_function},			//0X19	OID_RT_RPO_SET_PWRMGT_TEST
+	{1, &oid_null_function},			//0X1A
+	{1, &oid_null_function},			//0X1B	OID_RT_PRO_QRY_PWRMGT_TEST
+	{1, &oid_null_function},			//0X1C	OID_RT_RPO_ASYNC_RWIO_TEST
+	{1, &oid_null_function},			//0X1D	OID_RT_RPO_ASYNC_RWIO_POLL
+	{1, &oid_rt_pro_set_rf_intfs_hdl},		//0X1E
+	{1, &oid_rt_poll_rx_status_hdl}			//0X1F
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_20[] =
+{
+	{1, &oid_rt_pro_cfg_debug_message_hdl},		//0x20
+	{1, &oid_rt_pro_set_data_rate_ex_hdl},		//0x21
+	{1, &oid_rt_pro_set_basic_rate_hdl},		//0x22
+	{1, &oid_rt_pro_read_tssi_hdl},			//0x23
+	{1, &oid_rt_pro_set_power_tracking_hdl}		//0x24
+};
+
+
+struct oid_obj_priv oid_rtl_seg_87_11_50[] =
+{
+	{1, &oid_rt_pro_qry_pwrstate_hdl},		//0x50
+	{1, &oid_rt_pro_set_pwrstate_hdl}		//0x51
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_80[] =
+{
+	{1, &oid_null_function}				//0x80
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_B0[] =
+{
+	{1, &oid_null_function}				//0xB0
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_F0[] =
+{
+	{1, &oid_null_function},			//0xF0
+	{1, &oid_null_function},			//0xF1
+	{1, &oid_null_function},			//0xF2
+	{1, &oid_null_function},			//0xF3
+	{1, &oid_null_function},			//0xF4
+	{1, &oid_null_function},			//0xF5
+	{1, &oid_null_function},			//0xF6
+	{1, &oid_null_function},			//0xF7
+	{1, &oid_null_function},			//0xF8
+	{1, &oid_null_function},			//0xF9
+	{1, &oid_null_function},			//0xFA
+	{1, &oid_rt_pro_h2c_set_rate_table_hdl},	//0xFB
+	{1, &oid_rt_pro_h2c_get_rate_table_hdl},	//0xFC
+	{1, &oid_null_function},			//0xFD
+	{1, &oid_null_function},			//0xFE	OID_RT_PRO_H2C_C2H_LBK_TEST
+	{1, &oid_null_function}				//0xFF
+
+};
+
+struct oid_obj_priv oid_rtl_seg_87_12_00[]=
+{
+	{1, &oid_rt_pro_encryption_ctrl_hdl},		//0x00	Q&S
+	{1, &oid_rt_pro_add_sta_info_hdl},		//0x01	S
+	{1, &oid_rt_pro_dele_sta_info_hdl},		//0x02	S
+	{1, &oid_rt_pro_query_dr_variable_hdl},		//0x03	Q
+	{1, &oid_rt_pro_rx_packet_type_hdl},		//0x04	Q,S
+	{1, &oid_rt_pro_read_efuse_hdl},		//0x05	Q	OID_RT_PRO_READ_EFUSE
+	{1, &oid_rt_pro_write_efuse_hdl},		//0x06	S	OID_RT_PRO_WRITE_EFUSE
+	{1, &oid_rt_pro_rw_efuse_pgpkt_hdl},		//0x07	Q,S
+	{1, &oid_rt_get_efuse_current_size_hdl},	//0x08 	Q
+	{1, &oid_rt_set_bandwidth_hdl},			//0x09
+	{1, &oid_rt_set_crystal_cap_hdl},		//0x0a
+	{1, &oid_rt_set_rx_packet_type_hdl},		//0x0b	S
+	{1, &oid_rt_get_efuse_max_size_hdl},		//0x0c
+	{1, &oid_rt_pro_set_tx_agc_offset_hdl},		//0x0d
+	{1, &oid_rt_pro_set_pkt_test_mode_hdl},		//0x0e
+	{1, &oid_null_function},			//0x0f		OID_RT_PRO_FOR_EVM_TEST_SETTING
+	{1, &oid_rt_get_thermal_meter_hdl},		//0x10	Q	OID_RT_PRO_GET_THERMAL_METER
+	{1, &oid_rt_reset_phy_rx_packet_count_hdl},	//0x11	S	OID_RT_RESET_PHY_RX_PACKET_COUNT
+	{1, &oid_rt_get_phy_rx_packet_received_hdl},	//0x12	Q	OID_RT_GET_PHY_RX_PACKET_RECEIVED
+	{1, &oid_rt_get_phy_rx_packet_crc32_error_hdl},	//0x13	Q	OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR
+	{1, &oid_rt_set_power_down_hdl},		//0x14	Q	OID_RT_SET_POWER_DOWN
+	{1, &oid_rt_get_power_mode_hdl}			//0x15	Q	OID_RT_GET_POWER_MODE
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+
+extern struct oid_obj_priv oid_rtl_seg_81_80_00[32];
+extern struct oid_obj_priv oid_rtl_seg_81_80_20[16];
+extern struct oid_obj_priv oid_rtl_seg_81_80_40[6];
+extern struct oid_obj_priv oid_rtl_seg_81_80_80[3];
+
+extern struct oid_obj_priv oid_rtl_seg_81_85[1];
+extern struct oid_obj_priv oid_rtl_seg_81_87[5];
+
+extern struct oid_obj_priv oid_rtl_seg_87_11_00[32];
+extern struct oid_obj_priv oid_rtl_seg_87_11_20[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_50[2];
+extern struct oid_obj_priv oid_rtl_seg_87_11_80[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_B0[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_F0[16];
+
+extern struct oid_obj_priv oid_rtl_seg_87_12_00[32];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+
+enum MP_MODE {
+	MP_START_MODE,
+	MP_STOP_MODE,
+	MP_ERR_MODE
+};
+
+struct rwreg_param{
+	unsigned int offset;
+	unsigned int width;
+	unsigned int value;
+};
+
+struct bbreg_param{
+	unsigned int offset;
+	unsigned int phymask;
+	unsigned int value;
+};
+/*
+struct rfchannel_param{
+	unsigned int ch;
+	unsigned int modem;
+};
+*/
+struct txpower_param{
+	unsigned int pwr_index;
+};
+
+
+struct datarate_param{
+	unsigned int rate_index;
+};
+
+
+struct rfintfs_parm {
+	unsigned int rfintfs;
+};
+
+struct mp_xmit_packet {
+	unsigned int len;
+	unsigned int mem[MAX_MP_XMITBUF_SZ >> 2];
+};
+
+struct psmode_param {
+	unsigned int ps_mode;
+	unsigned int smart_ps;
+};
+
+//for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM
+struct eeprom_rw_param {
+	unsigned int offset;
+	unsigned short value;
+};
+
+struct mp_ioctl_handler {
+	unsigned int paramsize;
+	unsigned int (*handler)(struct oid_par_priv* poid_par_priv);
+	unsigned int oid;
+};
+
+struct mp_ioctl_param{
+	unsigned int subcode;
+	unsigned int len;
+	unsigned char data[0];
+};
+
+#define GEN_MP_IOCTL_SUBCODE(code) _MP_IOCTL_ ## code ## _CMD_
+
+enum RTL871X_MP_IOCTL_SUBCODE {
+	GEN_MP_IOCTL_SUBCODE(MP_START), 		/*0*/
+	GEN_MP_IOCTL_SUBCODE(MP_STOP), 			/*1*/
+	GEN_MP_IOCTL_SUBCODE(READ_REG), 		/*2*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_CHANNEL),		/*4*/
+	GEN_MP_IOCTL_SUBCODE(SET_TXPOWER),		/*5*/
+	GEN_MP_IOCTL_SUBCODE(SET_DATARATE),		/*6*/
+	GEN_MP_IOCTL_SUBCODE(READ_BB_REG),		/*7*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_BB_REG),
+	GEN_MP_IOCTL_SUBCODE(READ_RF_REG),		/*9*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_RF_INTFS),
+	GEN_MP_IOCTL_SUBCODE(IOCTL_XMIT_PACKET),	/*12*/
+	GEN_MP_IOCTL_SUBCODE(PS_STATE),			/*13*/
+	GEN_MP_IOCTL_SUBCODE(READ16_EEPROM),		/*14*/
+	GEN_MP_IOCTL_SUBCODE(WRITE16_EEPROM),		/*15*/
+	GEN_MP_IOCTL_SUBCODE(SET_PTM),			/*16*/
+	GEN_MP_IOCTL_SUBCODE(READ_TSSI),		/*17*/
+	GEN_MP_IOCTL_SUBCODE(CNTU_TX),			/*18*/
+	GEN_MP_IOCTL_SUBCODE(SET_BANDWIDTH),		/*19*/
+	GEN_MP_IOCTL_SUBCODE(SET_RX_PKT_TYPE),		/*20*/
+	GEN_MP_IOCTL_SUBCODE(RESET_PHY_RX_PKT_CNT),	/*21*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_RECV),	/*22*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_ERROR),	/*23*/
+	GEN_MP_IOCTL_SUBCODE(SET_POWER_DOWN),		/*24*/
+	GEN_MP_IOCTL_SUBCODE(GET_THERMAL_METER),	/*25*/
+	GEN_MP_IOCTL_SUBCODE(GET_POWER_MODE),		/*26*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE),			/*27*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE_MAP),		/*28*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_MAX_SIZE),	/*29*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_CURRENT_SIZE),	/*30*/
+	GEN_MP_IOCTL_SUBCODE(SC_TX),			/*31*/
+	GEN_MP_IOCTL_SUBCODE(CS_TX),			/*32*/
+	GEN_MP_IOCTL_SUBCODE(ST_TX),			/*33*/
+	GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO),		/*34*/
+	GEN_MP_IOCTL_SUBCODE(SET_DM_BT),		/*35*/
+	GEN_MP_IOCTL_SUBCODE(DEL_BA),			/*36*/
+	GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS),	/*37*/
+	MAX_MP_IOCTL_SUBCODE,
+};
+
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+#ifdef _RTL871X_MP_IOCTL_C_
+
+#define GEN_MP_IOCTL_HANDLER(sz, hdl, oid) {sz, hdl, oid},
+
+#define EXT_MP_IOCTL_HANDLER(sz, subcode, oid) {sz, &mp_ioctl_ ## subcode ## _hdl, oid},
+
+
+struct mp_ioctl_handler mp_ioctl_hdl[] = {
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_start_test_hdl, OID_RT_PRO_START_TEST)/*0*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_stop_test_hdl, OID_RT_PRO_STOP_TEST)/*1*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_read_register_hdl, OID_RT_PRO_READ_REGISTER)/*2*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_write_register_hdl, OID_RT_PRO_WRITE_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_channel_direct_call_hdl, OID_RT_PRO_SET_CHANNEL_DIRECT_CALL)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct txpower_param), oid_rt_pro_set_tx_power_control_hdl, OID_RT_PRO_SET_TX_POWER_CONTROL)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_data_rate_hdl, OID_RT_PRO_SET_DATA_RATE)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_read_bb_reg_hdl, OID_RT_PRO_READ_BB_REG)/*7*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_write_bb_reg_hdl, OID_RT_PRO_WRITE_BB_REG)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_read_rf_reg_hdl, OID_RT_PRO_RF_READ_REGISTRY)/*9*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_write_rf_reg_hdl, OID_RT_PRO_RF_WRITE_REGISTRY)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rfintfs_parm), NULL, 0)
+
+	EXT_MP_IOCTL_HANDLER(0, xmit_packet, 0)/*12*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct psmode_param), NULL, 0)/*13*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)/*14*/
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)/*15*/
+
+	GEN_MP_IOCTL_HANDLER(sizeof(unsigned char), NULL, 0)/*16*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), NULL, 0)/*17*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_continuous_tx_hdl, OID_RT_PRO_SET_CONTINUOUS_TX)/*18*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_bandwidth_hdl, OID_RT_SET_BANDWIDTH)/*19*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_rx_packet_type_hdl, OID_RT_SET_RX_PACKET_TYPE)/*20*/
+	GEN_MP_IOCTL_HANDLER(0, oid_rt_reset_phy_rx_packet_count_hdl, OID_RT_RESET_PHY_RX_PACKET_COUNT)/*21*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_received_hdl, OID_RT_GET_PHY_RX_PACKET_RECEIVED)/*22*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_crc32_error_hdl, OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR)/*23*/
+	GEN_MP_IOCTL_HANDLER(sizeof(unsigned char), oid_rt_set_power_down_hdl, OID_RT_SET_POWER_DOWN)/*24*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_thermal_meter_hdl, OID_RT_PRO_GET_THERMAL_METER)/*25*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_power_mode_hdl, OID_RT_GET_POWER_MODE)/*26*/
+	GEN_MP_IOCTL_HANDLER(sizeof(EFUSE_ACCESS_STRUCT), oid_rt_pro_efuse_hdl, OID_RT_PRO_EFUSE)/*27*/
+	GEN_MP_IOCTL_HANDLER(EFUSE_MAX_LOGICAL_SIZE, oid_rt_pro_efuse_map_hdl, OID_RT_PRO_EFUSE_MAP)/*28*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_max_size_hdl, OID_RT_GET_EFUSE_MAX_SIZE)/*29*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_current_size_hdl, OID_RT_GET_EFUSE_CURRENT_SIZE)/*30*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_carrier_tx_hdl, OID_RT_PRO_SET_SINGLE_CARRIER_TX)/*31*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_carrier_suppression_tx_hdl, OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX)/*32*/
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_tone_tx_hdl, OID_RT_PRO_SET_SINGLE_TONE_TX)/*33*/
+	GEN_MP_IOCTL_HANDLER(0, oid_rt_pro_trigger_gpio_hdl, 0)/*34*/
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+
+extern struct mp_ioctl_handler mp_ioctl_hdl[];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mp_phy_regdef.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mp_phy_regdef.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_mp_phy_regdef.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_mp_phy_regdef.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,1097 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*****************************************************************************
+ *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
+ *
+ * Module:	__INC_HAL8192SPHYREG_H
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *			
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:	
+ *
+ * History:
+ *	Data			Who		Remark 
+ *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
+ *						2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ * 
+ *****************************************************************************/
+#ifndef __RTL871X_MP_PHY_REGDEF_H
+#define __RTL871X_MP_PHY_REGDEF_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//============================================================
+//       8192S Regsiter offset definition
+//============================================================
+
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+//
+// 2. Page2(0x200)
+//
+// The following two definition are only used for USB interface.
+//#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
+//#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
+
+//
+// 3. Page8(0x800)
+//
+#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+
+#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+
+#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming2			0x814
+//#define rFPGA0_XC_RFTiming        		0x818
+//#define rFPGA0_XD_RFTiming        		0x81c
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rFPGA0_XC_HSSIParameter1		0x830
+#define		rFPGA0_XC_HSSIParameter2		0x834
+#define		rFPGA0_XD_HSSIParameter1		0x838
+#define		rFPGA0_XD_HSSIParameter2		0x83c
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+#define		rFPGA0_XC_LSSIParameter		0x848
+#define		rFPGA0_XD_LSSIParameter		0x84c
+
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rFPGA0_XC_RFInterfaceOE		0x868
+#define		rFPGA0_XD_RFInterfaceOE		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+//
+// 4. Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+
+//
+// 5. PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+
+//
+// 6. PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync. 
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG  
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+#define		rOFDM0_RxIQExtAnta				0xca0
+
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+
+
+//
+// 7. PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 8. PageE(0xE00)
+//
+#define		rTxAGC_Rate18_06				0xe00
+#define		rTxAGC_Rate54_24				0xe04
+#define		rTxAGC_CCK_Mcs32				0xe08
+#define		rTxAGC_Mcs03_Mcs00			0xe10
+#define		rTxAGC_Mcs07_Mcs04			0xe14
+#define		rTxAGC_Mcs11_Mcs08			0xe18
+#define		rTxAGC_Mcs15_Mcs12			0xe1c
+
+// Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register]
+#define 		rRx_Wait_CCCA					0xe70
+#define		rAnapar_Ctrl_BB					0xee0
+
+//
+// 7. RF Register 0x00-0x2E (RF 8256)
+//    RF-0222D 0x00-3F
+//
+//Zebra1
+#define RTL92SE_FPGA_VERIFY 0
+#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+//#if (RTL92SE_FPGA_VERIFY == 1)
+#define		rZebra1_Channel				0x7	// RF channel switch
+//#else
+
+//#endif
+#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+//Zebra4
+#define		rGlobalCtrl						0	// Useless now
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+//RTL8258
+#define		rRTL8258_TxLPF					0x11	// Useless now
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+//
+// RL6052 Register definition
+//
+#define		RF_AC						0x00	// 
+
+#define		RF_IQADJ_G1				0x01	// 
+#define		RF_IQADJ_G2				0x02	// 
+#define		RF_POW_TRSW				0x05	// 
+
+#define		RF_GAIN_RX					0x06	// 
+#define		RF_GAIN_TX					0x07	// 
+
+#define		RF_TXM_IDAC				0x08	// 
+#define		RF_BS_IQGEN				0x0F	// 
+
+#define		RF_MODE1					0x10	// 
+#define		RF_MODE2					0x11	// 
+
+#define		RF_RX_AGC_HP				0x12	// 
+#define		RF_TX_AGC					0x13	// 
+#define		RF_BIAS						0x14	// 
+#define		RF_IPA						0x15	// 
+#define		RF_POW_ABILITY			0x17	// 
+#define		RF_MODE_AG				0x18	// 
+#define		rRfChannel					0x18	// RF channel and BW switch
+#define		RF_CHNLBW					0x18	// RF channel and BW switch
+#define		RF_TOP						0x19	// 
+
+#define		RF_RX_G1					0x1A	// 
+#define		RF_RX_G2					0x1B	// 
+
+#define		RF_RX_BB2					0x1C	// 
+#define		RF_RX_BB1					0x1D	// 
+
+#define		RF_RCK1					0x1E	// 
+#define		RF_RCK2					0x1F	// 
+
+#define		RF_TX_G1					0x20	// 
+#define		RF_TX_G2					0x21	// 
+#define		RF_TX_G3					0x22	// 
+
+#define		RF_TX_BB1					0x23	// 
+
+#define		RF_T_METER					0x24	// 
+
+#define		RF_SYN_G1					0x25	// RF TX Power control
+#define		RF_SYN_G2					0x26	// RF TX Power control
+#define		RF_SYN_G3					0x27	// RF TX Power control
+#define		RF_SYN_G4					0x28	// RF TX Power control
+#define		RF_SYN_G5					0x29	// RF TX Power control
+#define		RF_SYN_G6					0x2A	// RF TX Power control
+#define		RF_SYN_G7					0x2B	// RF TX Power control
+#define		RF_SYN_G8					0x2C	// RF TX Power control
+
+#define		RF_RCK_OS					0x30	// RF TX PA control
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define		bBBResetB						0x100	// Useless now?
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define 		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+// 2. Page8(0x800)
+#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	// Useless now
+#define		bOFDMTxDACPhase           		0x40000
+#define		bXATxAGC                  			0x3f
+
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+       		
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       		0x400
+
+#define		b3WireRFPowerDown         		0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        		0x3
+#define		bRFSW_TxOptionAnt         		0x30
+#define		bRFSW_RxDefaultAnt        		0x300
+#define		bRFSW_RxOptionAnt         		0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               			0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                			0x400
+#define		bRFSI_PAPE5G              		0x800 
+#define		bBandSelect               			0x1
+#define		bHTSIG2_GI                			0x80
+#define		bHTSIG2_Smoothing         		0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         		0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         		0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         		0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              			0x20
+#define		bCCKRxPhase               		0x4
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadAddress          		0x3f000000   //LSSI "Read" Address	// Reg 0x824 rFPGA0_XA_HSSIParameter2
+#else
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+#endif
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadBackData         		0xfff		// Reg 0x8a0 rFPGA0_XA_LSSIReadBack
+#else
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+#endif
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz       		
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      		0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 			0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        		0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+#define 		bXtalCap                			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          		0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               			0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          		0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          		0x100
+#define		bDA10PSAtRx               		0x1000       		
+#define		bCCKRxAGCFormat           		0x200       		
+#define		bPSDFFTSamplepPoint       		0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                			0xffff
+
+// 3. Page9(0x900)
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	      			0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+// 4. PageA(0xA00)
+#define		bCCKBBMode                		0x3	// Useless
+#define		bCCKTxPowerSaving         		0x80
+#define		bCCKRxPowerSaving         		0x40
+
+#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble              		0x8	// Useless
+#define		bCCKAntDiversity    		      	0x8000
+#define		bCCKCarrierRecovery   	    	0x4000
+#define		bCCKTxRate           		     	0x3000
+#define		bCCKDCCancel             	 	0x0800
+#define		bCCKISICancel             		0x0400
+#define		bCCKMatchFilter           		0x0200
+#define		bCCKEqualizer             		0x0100
+#define		bCCKPreambleDetect       	 	0x800000
+#define		bCCKFastFalseCCA          		0x400000
+#define		bCCKChEstStart            		0x300000
+#define		bCCKCCACount              		0x080000
+#define		bCCKcs_lim                			0x070000
+#define		bCCKBistMode              		0x80000000
+#define		bCCKCCAMask             	  	0x40000000
+#define		bCCKTxDACPhase         	   	0x4
+#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0         	   	0x0100
+#define		bCCKTxDCOffset           	 	0xf0
+#define		bCCKRxDCOffset           	 	0xf
+#define		bCCKCCAMode              	 	0xc000
+#define		bCCKFalseCS_lim           		0x3f00
+#define		bCCKCS_ratio              		0xc00000
+#define		bCCKCorgBit_sel           		0x300000
+#define		bCCKPD_lim                			0x0f0000
+#define		bCCKNewCCA                		0x80000000
+#define		bCCKRxHPofIG              		0x8000
+#define		bCCKRxIG                  			0x7f00
+#define		bCCKLNAPolarity           		0x800000
+#define		bCCKRx1stGain             		0x7f0000
+#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel        	 	0x1f000000
+#define		bCCKRxAGCSatCount       	  	0xe0
+#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity      	 	0x2000
+#define		bCCKTxFilterType          		0x0c00
+#define		bCCKRxAGCReportType   	   	0x0300
+#define		bCCKRxDAGCEn              		0x80000000
+#define		bCCKRxDAGCPeriod        	  	0x20000000
+#define		bCCKRxDAGCSatLevel     	   	0x1f000000
+#define		bCCKTimingRecovery       	 	0x800000
+#define		bCCKTxC0                  			0x3f0000
+#define		bCCKTxC1                  			0x3f000000
+#define		bCCKTxC2                  			0x3f
+#define		bCCKTxC3                  			0x3f00
+#define		bCCKTxC4                  			0x3f0000
+#define		bCCKTxC5                  			0x3f000000
+#define		bCCKTxC6                  			0x3f
+#define		bCCKTxC7                  			0x3f00
+#define		bCCKDebugPort             		0xff0000
+#define		bCCKDACDebug              		0x0f000000
+#define		bCCKFalseAlarmEnable      		0x8000
+#define		bCCKFalseAlarmRead        		0x4000
+#define		bCCKTRSSI                 			0x7f
+#define		bCCKRxAGCReport           		0xfe
+#define		bCCKRxReport_AntSel       		0x80000000
+#define		bCCKRxReport_MFOff        		0x40000000
+#define		bCCKRxRxReport_SQLoss     	0x20000000
+#define		bCCKRxReport_Pktloss      		0x10000000
+#define		bCCKRxReport_Lockedbit    	0x08000000
+#define		bCCKRxReport_RateError    	0x04000000
+#define		bCCKRxReport_RxRate       		0x03000000
+#define		bCCKRxFACounterLower      	0xff
+#define		bCCKRxFACounterUpper      	0xff000000
+#define		bCCKRxHPAGCStart          		0xe000
+#define		bCCKRxHPAGCFinal          		0x1c00       		
+#define		bCCKRxFalseAlarmEnable    	0x8000
+#define		bCCKFACounterFreeze       		0x4000       		
+#define		bCCKTxPathSel             		0x10000000
+#define		bCCKDefaultRxPath         		0xc000000
+#define		bCCKOptionRxPath          		0x3000000
+
+// 5. PageC(0xC00)
+#define		bNumOfSTF                			0x3	// Useless
+#define		bShift_L                 			0xc0
+#define		bGI_TH                   			0xc
+#define		bRxPathA                 			0x1
+#define		bRxPathB                 			0x2
+#define		bRxPathC                 			0x4
+#define		bRxPathD                 			0x8
+#define		bTxPathA                 			0x1
+#define		bTxPathB                 			0x2
+#define		bTxPathC                 			0x4
+#define		bTxPathD                 			0x8
+#define		bTRSSIFreq               			0x200
+#define		bADCBackoff              			0x3000
+#define		bDFIRBackoff             			0xc000
+#define		bTRSSILatchPhase         		0x10000
+#define		bRxIDCOffset             			0xff
+#define		bRxQDCOffset             			0xff00
+#define		bRxDFIRMode              		0x1800000
+#define		bRxDCNFType              		0xe000000
+#define		bRXIQImb_A               			0x3ff
+#define		bRXIQImb_B               			0xfc00
+#define		bRXIQImb_C               			0x3f0000
+#define		bRXIQImb_D               			0xffc00000
+#define		bDC_dc_Notch             		0x60000
+#define		bRxNBINotch              			0x1f000000
+#define		bPD_TH                   			0xf
+#define		bPD_TH_Opt2              		0xc000
+#define		bPWED_TH                 			0x700
+#define		bIfMF_Win_L              			0x800
+#define		bPD_Option               			0x1000
+#define		bMF_Win_L                			0xe000
+#define		bBW_Search_L             		0x30000
+#define		bwin_enh_L               			0xc0000
+#define		bBW_TH                   			0x700000
+#define		bED_TH2                  			0x3800000
+#define		bBW_option               			0x4000000
+#define		bRatio_TH                			0x18000000
+#define		bWindow_L                			0xe0000000
+#define		bSBD_Option              			0x1
+#define		bFrame_TH                			0x1c
+#define		bFS_Option               			0x60
+#define		bDC_Slope_check          		0x80
+#define		bFGuard_Counter_DC_L     		0xe00
+#define		bFrame_Weight_Short      		0x7000
+#define		bSub_Tune                			0xe00000
+#define		bFrame_DC_Length         		0xe000000
+#define		bSBD_start_offset        		0x30000000
+#define		bFrame_TH_2              		0x7
+#define		bFrame_GI2_TH            		0x38
+#define		bGI2_Sync_en             		0x40
+#define		bSarch_Short_Early       		0x300
+#define		bSarch_Short_Late        		0xc00
+#define		bSarch_GI2_Late          		0x70000
+#define		bCFOAntSum               		0x1
+#define		bCFOAcc                  			0x2
+#define		bCFOStartOffset          		0xc
+#define		bCFOLookBack             		0x70
+#define		bCFOSumWeight            		0x80
+#define		bDAGCEnable              			0x10000
+#define		bTXIQImb_A               			0x3ff
+#define		bTXIQImb_B               			0xfc00
+#define		bTXIQImb_C               			0x3f0000
+#define		bTXIQImb_D               			0xffc00000
+#define		bTxIDCOffset             			0xff
+#define		bTxQDCOffset             			0xff00
+#define		bTxDFIRMode              		0x10000
+#define		bTxPesudoNoiseOn         		0x4000000
+#define		bTxPesudoNoise_A         		0xff
+#define		bTxPesudoNoise_B         		0xff00
+#define		bTxPesudoNoise_C         		0xff0000
+#define		bTxPesudoNoise_D         		0xff000000
+#define		bCCADropOption           		0x20000
+#define		bCCADropThres            		0xfff00000
+#define		bEDCCA_H                 			0xf
+#define		bEDCCA_L                 			0xf0
+#define		bLambda_ED               0x300
+#define		bRxInitialGain           0x7f
+#define		bRxAntDivEn              0x80
+#define		bRxAGCAddressForLNA      0x7f00
+#define		bRxHighPowerFlow         0x8000
+#define		bRxAGCFreezeThres        0xc0000
+#define		bRxFreezeStep_AGC1       0x300000
+#define		bRxFreezeStep_AGC2       0xc00000
+#define		bRxFreezeStep_AGC3       0x3000000
+#define		bRxFreezeStep_AGC0       0xc000000
+#define		bRxRssi_Cmp_En           0x10000000
+#define		bRxQuickAGCEn            0x20000000
+#define		bRxAGCFreezeThresMode    0x40000000
+#define		bRxOverFlowCheckType     0x80000000
+#define		bRxAGCShift              0x7f
+#define		bTRSW_Tri_Only           0x80
+#define		bPowerThres              0x300
+#define		bRxAGCEn                 0x1
+#define		bRxAGCTogetherEn         0x2
+#define		bRxAGCMin                0x4
+#define		bRxHP_Ini                0x7
+#define		bRxHP_TRLNA              0x70
+#define		bRxHP_RSSI               0x700
+#define		bRxHP_BBP1               0x7000
+#define		bRxHP_BBP2               0x70000
+#define		bRxHP_BBP3               0x700000
+#define		bRSSI_H                  0x7f0000     //the threshold for high power
+#define		bRSSI_Gen                0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW           0x7
+#define		bRxSettle_LNA            0x38
+#define		bRxSettle_RSSI           0x1c0
+#define		bRxSettle_BBP            0xe00
+#define		bRxSettle_RxHP           0x7000
+#define		bRxSettle_AntSW_RSSI     0x38000
+#define		bRxSettle_AntSW          0xc0000
+#define		bRxProcessTime_DAGC      0x300000
+#define		bRxSettle_HSSI           0x400000
+#define		bRxProcessTime_BBPPW     0x800000
+#define		bRxAntennaPowerShift     0x3000000
+#define		bRSSITableSelect         0xc000000
+#define		bRxHP_Final              0x7000000
+#define		bRxHTSettle_BBP          0x7
+#define		bRxHTSettle_HSSI         0x8
+#define		bRxHTSettle_RxHP         0x70
+#define		bRxHTSettle_BBPPW        0x80
+#define		bRxHTSettle_Idle         0x300
+#define		bRxHTSettle_Reserved     0x1c00
+#define		bRxHTRxHPEn              0x8000
+#define		bRxHTAGCFreezeThres      0x30000
+#define		bRxHTAGCTogetherEn       0x40000
+#define		bRxHTAGCMin              0x80000
+#define		bRxHTAGCEn               0x100000
+#define		bRxHTDAGCEn              0x200000
+#define		bRxHTRxHP_BBP            0x1c00000
+#define		bRxHTRxHP_Final          0xe0000000
+#define		bRxPWRatioTH             0x3
+#define		bRxPWRatioEn             0x4
+#define		bRxMFHold                0x3800
+#define		bRxPD_Delay_TH1          0x38
+#define		bRxPD_Delay_TH2          0x1c0
+#define		bRxPD_DC_COUNT_MAX       0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH           0x8000
+#define		bRxProcess_Delay         0xf0000
+#define		bRxSearchrange_GI2_Early 0x700000
+#define		bRxFrame_Guard_Counter_L 0x3800000
+#define		bRxSGI_Guard_L           0xc000000
+#define		bRxSGI_Search_L          0x30000000
+#define		bRxSGI_TH                0xc0000000
+#define		bDFSCnt0                 0xff
+#define		bDFSCnt1                 0xff00
+#define		bDFSFlag                 0xf0000       		
+#define		bMFWeightSum             0x300000
+#define		bMinIdxTH                0x7f000000       		
+#define		bDAFormat                0x40000       		
+#define		bTxChEmuEnable           0x01000000       		
+#define		bTRSWIsolation_A         0x7f
+#define		bTRSWIsolation_B         0x7f00
+#define		bTRSWIsolation_C         0x7f0000
+#define		bTRSWIsolation_D         0x7f000000       		
+#define		bExtLNAGain              0x7c00          
+
+// 6. PageE(0xE00)
+#define		bSTBCEn                  0x4	// Useless
+#define		bAntennaMapping          0x10
+#define		bNss                     0x20
+#define		bCFOAntSumD              0x200
+#define		bPHYCounterReset         0x8000000
+#define		bCFOReportGet            0x4000000
+#define		bOFDMContinueTx          0x10000000
+#define		bOFDMSingleCarrier       0x20000000
+#define		bOFDMSingleTone          0x40000000
+//#define bRxPath1                 0x01
+//#define bRxPath2                 0x02
+//#define bRxPath3                 0x04
+//#define bRxPath4                 0x08
+//#define bTxPath1                 0x10
+//#define bTxPath2                 0x20
+#define		bHTDetect                0x100
+#define		bCFOEn                   0x10000
+#define		bCFOValue                0xfff00000
+#define		bSigTone_Re              0x3f
+#define		bSigTone_Im              0x7f00
+#define		bCounter_CCA             0xffff
+#define		bCounter_ParityFail      0xffff0000
+#define		bCounter_RateIllegal     0xffff
+#define		bCounter_CRC8Fail        0xffff0000
+#define		bCounter_MCSNoSupport    0xffff
+#define		bCounter_FastSync        0xffff
+#define		bShortCFO                0xfff
+#define		bShortCFOTLength         12   //total
+#define		bShortCFOFLength         11   //fraction
+#define		bLongCFO                 0x7ff
+#define		bLongCFOTLength          11
+#define		bLongCFOFLength          11
+#define		bTailCFO                 0x1fff
+#define		bTailCFOTLength          13
+#define		bTailCFOFLength          12       		
+#define		bmax_en_pwdB             0xffff
+#define		bCC_power_dB             0xffff0000
+#define		bnoise_pwdB              0xffff
+#define		bPowerMeasTLength        10
+#define		bPowerMeasFLength        3
+#define		bRx_HT_BW                0x1
+#define		bRxSC                    0x6
+#define		bRx_HT                   0x8       		
+#define		bNB_intf_det_on          0x1
+#define		bIntf_win_len_cfg        0x30
+#define		bNB_Intf_TH_cfg          0x1c0       		
+#define		bRFGain                  0x3f
+#define		bTableSel                0x40
+#define		bTRSW                    0x80       		
+#define		bRxSNR_A                 0xff
+#define		bRxSNR_B                 0xff00
+#define		bRxSNR_C                 0xff0000
+#define		bRxSNR_D                 0xff000000
+#define		bSNREVMTLength           8
+#define		bSNREVMFLength           1       		
+#define		bCSI1st                  0xff
+#define		bCSI2nd                  0xff00
+#define		bRxEVM1st                0xff0000
+#define		bRxEVM2nd                0xff000000       		
+#define		bSIGEVM                  0xff
+#define		bPWDB                    0xff00
+#define		bSGIEN                   0x10000
+       		
+#define		bSFactorQAM1             0xf	// Useless
+#define		bSFactorQAM2             0xf0
+#define		bSFactorQAM3             0xf00
+#define		bSFactorQAM4             0xf000
+#define		bSFactorQAM5             0xf0000
+#define		bSFactorQAM6             0xf0000
+#define		bSFactorQAM7             0xf00000
+#define		bSFactorQAM8             0xf000000
+#define		bSFactorQAM9             0xf0000000
+#define		bCSIScheme               0x100000
+       		
+#define		bNoiseLvlTopSet          0x3	// Useless
+#define		bChSmooth                0x4
+#define		bChSmoothCfg1            0x38
+#define		bChSmoothCfg2            0x1c0
+#define		bChSmoothCfg3            0xe00
+#define		bChSmoothCfg4            0x7000
+#define		bMRCMode                 0x800000
+#define		bTHEVMCfg                0x7000000
+       		
+#define		bLoopFitType             0x1	// Useless
+#define		bUpdCFO                  0x40
+#define		bUpdCFOOffData           0x80
+#define		bAdvUpdCFO               0x100
+#define		bAdvTimeCtrl             0x800
+#define		bUpdClko                 0x1000
+#define		bFC                      0x6000
+#define		bTrackingMode            0x8000
+#define		bPhCmpEnable             0x10000
+#define		bUpdClkoLTF              0x20000
+#define		bComChCFO                0x40000
+#define		bCSIEstiMode             0x80000
+#define		bAdvUpdEqz               0x100000
+#define		bUChCfg                  0x7000000
+#define		bUpdEqz                  0x8000000
+
+#define		bTxAGCRate18_06			0x7f7f7f7f	// Useless
+#define		bTxAGCRate54_24			0x7f7f7f7f
+#define		bTxAGCRateMCS32			0x7f
+#define		bTxAGCRateCCK			0x7f00
+#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
+#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
+#define		bTxAGCRateMCS11_MCS8	0x7f7f7f7f
+#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn         0x20000000	// Useless
+#define		bRxPesudoNoise_A         0xff
+#define		bRxPesudoNoise_B         0xff00
+#define		bRxPesudoNoise_C         0xff0000
+#define		bRxPesudoNoise_D         0xff000000
+#define		bPesudoNoiseState_A      0xffff
+#define		bPesudoNoiseState_B      0xffff0000
+#define		bPesudoNoiseState_C      0xffff
+#define		bPesudoNoiseState_D      0xffff0000
+
+//7. RF Register
+//Zebra1
+#define		bZebra1_HSSIEnable        0x8		// Useless
+#define		bZebra1_TRxControl        0xc00
+#define		bZebra1_TRxGainSetting    0x07f
+#define		bZebra1_RxCorner          0xc00
+#define		bZebra1_TxChargePump      0x38
+#define		bZebra1_RxChargePump      0x7
+#define		bZebra1_ChannelNum        0xf80
+#define		bZebra1_TxLPFBW           0x400
+#define		bZebra1_RxLPFBW           0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1      0x100	// Useless
+#define		bRTL8256RegModeCtrl0      0x40
+#define		bRTL8256_TxLPFBW          0x18
+#define		bRTL8256_RxLPFBW          0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW          0xc	// Useless
+#define		bRTL8258_RxLPFBW          0xc00
+#define		bRTL8258_RSSILPFBW        0xc0
+
+
+//
+// Other Definition
+//
+
+//byte endable for sb_write
+#define		bByte0                    0x1	// Useless
+#define		bByte1                    0x2
+#define		bByte2                    0x4
+#define		bByte3                    0x8
+#define		bWord0                    0x3
+#define		bWord1                    0xc
+#define		bDWord                    0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0                0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1                0xff00
+#define		bMaskByte2                0xff0000
+#define		bMaskByte3                0xff000000
+#define		bMaskHWord                0xffff0000
+#define		bMaskLWord                0x0000ffff
+#define		bMaskDWord                0xffffffff
+#define		bMaskH4Bits		  0xf0000000	
+#define 		bMaskOFDM_D	  0xffc00000
+#define		bMaskCCK		  0x3f3f3f3f
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+#if (RTL92SE_FPGA_VERIFY == 1)
+//#define		bMask12Bits               0xfff	// RF Reg mask bits
+//#define		bMask20Bits               0xfff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask	0xfff		
+#else
+//#define		bMask12Bits               0xfffff	// RF Reg mask bits
+//#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
+#define 		bRFRegOffsetMask	0xfffff		
+#endif       		
+#define		bEnable                   0x1	// Useless
+#define		bDisable                  0x0
+       		
+#define		LeftAntenna               0x0	// Useless
+#define		RightAntenna              0x1
+       		
+#define		tCheckTxStatus            500   //500ms // Useless
+#define		tUpdateRxCounter          100   //100ms
+       		
+#define		rateCCK     0	// Useless
+#define		rateOFDM    1
+#define		rateHT      2
+
+//define Register-End
+#define		bPMAC_End                 0x1ff	// Useless
+#define		bFPGAPHY0_End             0x8ff
+#define		bFPGAPHY1_End             0x9ff
+#define		bCCKPHY0_End              0xaff
+#define		bOFDMPHY0_End             0xcff
+#define		bOFDMPHY1_End             0xdff
+
+//define max debug item in each debug page
+//#define bMaxItem_FPGA_PHY0        0x9
+//#define bMaxItem_FPGA_PHY1        0x3
+//#define bMaxItem_PHY_11B          0x16
+//#define bMaxItem_OFDM_PHY0        0x29
+//#define bMaxItem_OFDM_PHY1        0x0
+
+#define		bPMACControl	0x0		// Useless
+#define		bWMACControl	0x1
+#define		bWNICControl	0x2
+       		
+#define		ANTENNA_A	0x1	// Useless
+#define		ANTENNA_B	0x2
+#define		ANTENNA_AB	0x3	// ANTENNA_A |ANTENNA_B
+
+#define		ANTENNA_C	0x4
+#define		ANTENNA_D	0x8
+
+
+#define RCR_AAP			BIT(0)				// accept all physical address
+#define RCR_APM			BIT(1)				// accept physical match
+#define RCR_AM			BIT(2)				// accept multicast
+#define RCR_AB			BIT(3)				// accept broadcast
+#define RCR_ACRC32		BIT(5)				// accept error packet
+#define RCR_9356SEL		BIT(6)
+#define RCR_AICV		BIT(12)				// Accept ICV error packet
+#define RCR_RXFTH0		(BIT(13)|BIT(14)|BIT(15))	// Rx FIFO threshold
+#define RCR_ADF			BIT(18)				// Accept Data(frame type) frame
+#define RCR_ACF			BIT(19)				// Accept control frame
+#define RCR_AMF			BIT(20)				// Accept management frame
+#define RCR_ADD3		BIT(21)
+#define RCR_APWRMGT		BIT(22)				// Accept power management packet
+#define RCR_CBSSID		BIT(23)				// Accept BSSID match packet
+#define RCR_ENMARP		BIT(28)				// enable mac auto reset phy
+#define RCR_EnCS1		BIT(29)				// enable carrier sense method 1
+#define RCR_EnCS2		BIT(30)				// enable carrier sense method 2
+#define RCR_OnlyErlPkt		BIT(31)				// Rx Early mode is performed for packet size greater than 1536
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	//__INC_HAL8192SPHYREG_H
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_pwrctrl.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_pwrctrl.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_pwrctrl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_pwrctrl.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,243 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_PWRCTRL_H_
+#define __RTL871X_PWRCTRL_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>		
+#include <drv_types.h>
+
+
+#define FW_PWR0	0	
+#define FW_PWR1 	1
+#define FW_PWR2 	2
+#define FW_PWR3 	3
+
+
+#define HW_PWR0	7	
+#define HW_PWR1 	6
+#define HW_PWR2 	2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+
+
+enum Power_Mgnt
+{
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM
+};
+
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define 	PS_DPS				BIT(0)
+#define 	PS_LCLK				(PS_DPS)
+#define	PS_RF_OFF			BIT(1)
+#define	PS_ALL_ON			BIT(2)
+#define	PS_ST_ACTIVE		BIT(3)
+#define	PS_LP				BIT(4)	// low performance
+
+#define	PS_STATE_MASK		(0x0F)
+#define	PS_STATE_HW_MASK	(0x07)
+#define 	PS_SEQ_MASK		(0xc0)
+
+#define	PS_STATE(x)			(PS_STATE_MASK & (x))
+#define	PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define	PS_SEQ(x)			(PS_SEQ_MASK & (x))
+
+#define	PS_STATE_S0		(PS_DPS)
+#define 	PS_STATE_S1		(PS_LCLK)
+#define	PS_STATE_S2		(PS_RF_OFF)
+#define 	PS_STATE_S3		(PS_ALL_ON)
+#define	PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define 	PS_IS_RF_ON(x)		((x) & (PS_ALL_ON))
+#define 	PS_IS_ACTIVE(x)		((x) & (PS_ST_ACTIVE))
+#define 	CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; //the CPWM value
+	unsigned short rsvd;
+}; 
+
+
+typedef _sema _pwrlock;
+
+
+__inline static void _init_pwrlock(_pwrlock *plock)
+{
+	_rtw_init_sema(plock, 1);
+}
+
+__inline static void _free_pwrlock(_pwrlock *plock)
+{
+	_rtw_free_sema(plock);
+}
+
+
+__inline static void _enter_pwrlock(_pwrlock *plock)
+{
+	_rtw_down_sema(plock);
+}
+
+
+__inline static void _exit_pwrlock(_pwrlock *plock)
+{
+	_rtw_up_sema(plock);
+}
+
+#define LPS_DELAY_TIME	1*HZ // 1 sec
+
+#define EXE_PWR_NONE	0x01
+#define EXE_PWR_IPS		0x02
+#define EXE_PWR_LPS		0x04
+
+// RF state.
+typedef enum _rt_rf_power_state
+{
+	rf_on,		// RF is on after RFSleep or RFOff
+	rf_sleep,	// 802.11 Power Save mode
+	rf_off,		// HW/SW Radio OFF or Inactive Power Save
+	//=====Add the new RF state above this line=====//
+	rf_max
+}rt_rf_power_state;
+
+
+enum _PS_BBRegBackup_ {
+	PSBBREG_RF0 = 0,
+	PSBBREG_RF1,
+	PSBBREG_RF2,
+	PSBBREG_AFE0,
+	PSBBREG_TOTALCNT
+};
+
+enum _SS_LEVEL_{
+	SS_LEVEL_MIN,//rf on/off ,keep 8051
+	SS_LEVEL_DEEP,//card disable, 8051 reset 
+};
+	
+struct	pwrctrl_priv {
+	_pwrlock	lock;
+	volatile u8 rpwm; // requested power state for fw
+	volatile u8 cpwm; // fw current power state. updated when 1. read from HCPWM 2. driver lowers power level
+	volatile u8 tog; // toggling
+	volatile u8 cpwm_tog; // toggling
+	uint pwr_mode;
+	uint smart_ps;
+	uint alives;
+	u8	bLeisurePs;
+	u8	LpsIdleCount;
+	//u8	FWCtrlPSMode;
+	u8	power_mgnt;
+	u8	bFwCurrentInPSMode;
+	u32	DelayLPSLastTimeStamp;
+
+	s32		pnp_current_pwr_state;
+	u8		pnp_bstop_trx;
+	u8		bInternalAutoSuspend;
+	u8		bSupportRemoteWakeup;	
+//===========================================
+	_timer 	pwr_state_check_timer;
+	int		pwr_state_check_inverval;
+	u8		pwr_state_check_cnts;
+	uint 		bips_processing;
+
+	_workitem InactivePSWorkItem;
+
+	rt_rf_power_state current_rfpwrstate;
+	rt_rf_power_state	change_rfpwrstate;
+	
+	uint 		ips_enter_cnts;
+	uint 		ips_leave_cnts;		
+	
+	u8		wepkeymask;
+	u8		bHWPowerdown;//if support hw power down
+	u8		bHWPwrPindetect;
+	u8		bkeepfwalive;		
+	u8		brfoffbyhw;
+	unsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];
+	//=========================================
+	#ifdef CONFIG_WOWLAN
+	u8		bSupportWakeOnWlan;
+	#endif
+	
+};
+
+
+
+extern void rtw_init_pwrctrl_priv(_adapter *adapter);
+extern void rtw_free_pwrctrl_priv(_adapter * adapter);
+extern sint rtw_register_tx_alive(_adapter *padapter);
+extern void rtw_unregister_tx_alive(_adapter *padapter);
+extern sint rtw_register_rx_alive(_adapter *padapter);
+extern void rtw_unregister_rx_alive(_adapter *padapter);
+extern sint rtw_register_cmd_alive(_adapter *padapter);
+extern void rtw_unregister_cmd_alive(_adapter *padapter);
+extern sint rtw_register_evt_alive(_adapter *padapter);
+extern void rtw_unregister_evt_alive(_adapter *padapter);
+extern void cpwm_int_hdl(_adapter *padapter, struct reportpwrstate_parm *preportpwrstate);
+extern void rtw_set_ps_mode(_adapter * padapter, uint ps_mode, uint smart_ps);
+static void set_rpwm(_adapter * padapter, u8 val8);
+extern void LeaveAllPowerSaveMode(PADAPTER Adapter);
+
+#ifdef CONFIG_AUTOSUSPEND
+int autoresume_enter(_adapter* padapter);
+#endif
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter );
+#endif
+
+#ifdef CONFIG_IPS
+void ips_enter(_adapter * padapter);
+int ips_leave(_adapter * padapter);
+#endif
+
+#ifdef CONFIG_LPS
+void LPS_Enter(PADAPTER padapter);
+void LPS_Leave(PADAPTER padapter);
+u8 FWLPS_RF_ON(PADAPTER padapter);
+#endif
+void power_saving_ctrl_wk_hdl(_adapter *padapter, u8 *pbuf, int sz);
+#endif  //__RTL871X_PWRCTRL_H_
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_qos.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_qos.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_qos.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_qos.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef _RTL871X_QOS_H_
+#define _RTL871X_QOS_H_
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+
+
+
+
+struct	qos_priv	{
+	
+	unsigned int	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...		
+
+};
+
+
+#endif	//_RTL871X_QOS_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_recv.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_recv.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_recv.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_recv.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,532 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_RECV_H_
+#define _RTL871X_RECV_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifdef PLATFORM_OS_XP
+#define NR_RECVFRAME 256
+#else
+#define NR_RECVFRAME 256
+#endif
+
+#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)
+
+#define MAX_RXFRAME_CNT	512
+#define MAX_RX_NUMBLKS		(32)
+#define RECVFRAME_HDR_ALIGN 128
+
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+static u8 SNAP_ETH_TYPE_APPLETALK_DDP[2] = {0x80, 0x9b};
+static u8 SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; // Datagram Delivery Protocol
+
+static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
+static u8 oui_rfc1042[]= {0x00,0x00,0x00};
+
+#define MAX_SUBFRAME_COUNT	64
+static u8 rfc1042_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 bridge_tunnel_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+
+//for Rx reordering buffer control
+struct recv_reorder_ctrl
+{
+	_adapter	*padapter;
+	u8 enable;
+	u16 indicate_seq;//=wstart_b, init_value=0xffff
+	u16 wend_b;
+       u8 wsize_b;	
+	_queue pending_recvframe_queue;
+	_timer reordering_ctrl_timer;
+};
+
+struct	stainfo_rxcache	{
+	u16 	tid_rxseq[16];
+/*	
+	unsigned short 	tid0_rxseq;
+	unsigned short 	tid1_rxseq;
+	unsigned short 	tid2_rxseq;
+	unsigned short 	tid3_rxseq;
+	unsigned short 	tid4_rxseq;
+	unsigned short 	tid5_rxseq;
+	unsigned short 	tid6_rxseq;
+	unsigned short 	tid7_rxseq;
+	unsigned short 	tid8_rxseq;
+	unsigned short 	tid9_rxseq;
+	unsigned short 	tid10_rxseq;
+	unsigned short 	tid11_rxseq;
+	unsigned short 	tid12_rxseq;
+	unsigned short 	tid13_rxseq;
+	unsigned short 	tid14_rxseq;
+	unsigned short 	tid15_rxseq;
+*/
+};
+
+#define		PHY_RSSI_SLID_WIN_MAX				100
+#define		PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+
+struct smooth_rssi_data {
+	u32	elements[100];	//array to store values
+	u32	index;			//index to current array to store
+	u32	total_num;		//num of valid elements
+	u32	total_val;		//sum of valid elements
+};
+
+struct rtw_transfer_buffer
+{
+	_list list;
+	u8 *pallocated_transfer_buf;
+	u8 *transfer_buf;    // alignmented buffer 
+	u32 buffer_len;
+	u32 transfer_len;
+};
+
+struct rx_pkt_attrib	{
+	u8   physt;
+	u8 	amsdu;
+	u8	order;
+	u8	qos;
+	u8 	to_fr_ds;
+	u8	frag_num;
+	u16	seq_num;
+	u8   pw_save;
+	u8    mfrag;
+	u8    mdata;	
+	u8	privacy; //in frame_ctrl field
+	u8	bdecrypted;
+	int	hdrlen;		//the WLAN Header Len
+	int	encrypt;		//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	int	iv_len;
+	int	icv_len;
+	int	priority;
+	int	ack_policy;
+#ifdef CONFIG_MP_INCLUDED
+ 	u8	crc_err;
+#endif
+	u8 	dst[ETH_ALEN];
+	u8 	src[ETH_ALEN];
+	u8 	ta[ETH_ALEN];
+	u8 	ra[ETH_ALEN];
+	u8 	bssid[ETH_ALEN];
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	u8	tcpchk_valid; // 0: invalid, 1: valid
+	u8	ip_chkrpt; //0: incorrect, 1: correct
+	u8	tcp_chkrpt; //0: incorrect, 1: correct
+#endif
+
+	u8	mcs_rate;
+	u8	rxht;
+	u8	signal_qual;
+	s8	rx_mimo_signal_qual[2];	
+	u8	signal_strength;
+
+	u32 RxPWDBAll;
+	s32	RecvSignalPower;
+	int 	RxSNRdB[2];
+};
+
+
+
+
+
+
+/*
+accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
+; halt(passive) ;
+
+using enter_critical section to protect
+*/
+struct recv_priv {
+
+  	  _lock	lock;
+
+	_sema	recv_sema;
+	_sema	terminate_recvthread_sema;
+	
+	//_queue	blk_strms[MAX_RX_NUMBLKS];    // keeping the block ack frame until return ack
+	_queue	free_recv_queue;
+	_queue	recv_pending_queue;
+	
+
+	u8 *pallocated_frame_buf;
+	u8 *precv_frame_buf; 
+	
+	uint free_recvframe_cnt;
+	
+	_adapter	*adapter;
+	
+#ifdef PLATFORM_WINDOWS
+	_nic_hdl  RxPktPoolHdl;
+	_nic_hdl  RxBufPoolHdl;
+
+#ifdef PLATFORM_OS_XP
+	PMDL	pbytecnt_mdl;
+#endif
+	uint	counter; //record the number that up-layer will return to drv; only when counter==0 can we  release recv_priv 
+	NDIS_EVENT 	recv_resource_evt ;
+#endif	
+
+	u32	NumRxUnicastOkInPeriod;
+	u64	rx_bytes;
+	u64	rx_pkts;
+	u64	rx_drop;
+
+
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+
+#ifdef CONFIG_USB_HCI	
+	//u8 *pallocated_urb_buf;	
+	_sema allrxreturnevt;
+	u8  rx_pending_cnt;
+	uint	ff_hwaddr;
+#endif	
+#ifdef PLATFORM_LINUX
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+#endif
+
+  
+	u8 *pallocated_recv_buf;
+	u8 *precv_buf;    // 4 alignment	
+	_queue	free_recv_buf_queue;
+	u32	free_recv_buf_queue_cnt;
+
+
+#ifdef CONFIG_SDIO_HCI
+        u8 bytecnt_buf[512];
+//	u8 * recvbuf_drop_ori;
+	//u8 * recvbuf_drop;
+	struct recv_buf *recvbuf_drop;
+#endif
+
+	//For display the phy informatiom
+	s8 rssi;
+	u8 signal_strength;
+	u8 signal_qual;
+	u8 noise;
+	
+	int RxSNRdB[2];
+	struct smooth_rssi_data signal_qual_data;
+	struct smooth_rssi_data signal_strength_data;
+	
+
+	_queue pending_rx_transfer_buffer_queue;
+	u32 pending_rx_transfer_buffer_cnt;
+	
+};
+
+
+struct sta_recv_priv {
+    
+    _lock	lock;
+	sint	option;	
+	
+	//_queue	blk_strms[MAX_RX_NUMBLKS];
+	_queue defrag_q;	 //keeping the fragment frame until defrag
+	
+	struct	stainfo_rxcache rxcache;  
+	
+	//uint	sta_rx_bytes;
+	//uint	sta_rx_pkts;
+	//uint	sta_rx_fail;
+
+};
+
+
+
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_recv.h"
+#endif
+
+#ifdef CONFIG_RTL8192C
+#include "rtl8192c_recv.h"
+#endif
+
+
+extern union recv_frame *rtw_alloc_recvframe (_queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
+extern void rtw_init_recvframe(union recv_frame *precvframe ,struct recv_priv *precvpriv);
+extern int	 rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue);  
+static union recv_frame *dequeue_recvframe (_queue *queue);
+extern int	 rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue);
+extern void rtw_free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue);  
+
+
+void rtw_enqueue_rx_transfer_buffer(struct recv_priv *precvpriv, struct rtw_transfer_buffer *transfer_buffer);
+struct rtw_transfer_buffer *rtw_dequeue_rx_transfer_buffer(struct recv_priv *precvpriv);
+struct rtw_transfer_buffer *rtw_alloc_transfer_buffer(u32 sz);
+void rtw_free_transfer_buffer(struct rtw_transfer_buffer *transfer_buffer);
+void rtw_free_pending_transfer_buffers(struct recv_priv *precvpriv);
+
+
+__inline static u8 *get_rxmem(union recv_frame *precvframe)
+{
+	//always return rx_head...
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_head;
+}
+
+__inline static u8 *get_rx_status(union recv_frame *precvframe)
+{
+	
+	return get_rxmem(precvframe);
+	
+}
+
+__inline static u8 *get_recvframe_data(union recv_frame *precvframe)
+{
+	
+	//alwasy return rx_data	
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_data;
+	
+}
+
+__inline static u8 *recvframe_push(union recv_frame *precvframe, sint sz)
+{	
+	// append data before rx_data 
+
+	/* add data to the start of recv_frame
+ *
+ *      This function extends the used data area of the recv_frame at the buffer
+ *      start. rx_data must be still larger than rx_head, after pushing.
+ */
+ 
+	if(precvframe==NULL)
+		return NULL;
+
+
+	precvframe->u.hdr.rx_data -= sz ;
+	if( precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head )
+	{
+		precvframe->u.hdr.rx_data += sz ;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len +=sz;
+
+	return precvframe->u.hdr.rx_data;
+	
+}
+
+
+__inline static u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
+{
+	// rx_data += sz; move rx_data sz bytes  hereafter
+
+	//used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller
+
+
+	if(precvframe==NULL)
+		return NULL;
+
+	
+	precvframe->u.hdr.rx_data += sz;
+
+	if(precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail)
+	{
+		precvframe->u.hdr.rx_data -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -=sz;
+	
+	return precvframe->u.hdr.rx_data;
+	
+}
+
+__inline static u8 *recvframe_put(union recv_frame *precvframe, sint sz)
+{
+	// rx_tai += sz; move rx_tail sz bytes  hereafter
+
+	//used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller
+	//after putting, rx_tail must be still larger than rx_end. 
+ 	unsigned char * prev_rx_tail;
+
+	if(precvframe==NULL)
+		return NULL;
+
+	prev_rx_tail = precvframe->u.hdr.rx_tail;
+	
+	precvframe->u.hdr.rx_tail += sz;
+	
+	if(precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end)
+	{
+		precvframe->u.hdr.rx_tail -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len +=sz;
+
+	return precvframe->u.hdr.rx_tail;
+
+}
+
+
+
+__inline static u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
+{
+	// rmv data from rx_tail (by yitsen)
+	
+	//used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller
+	//after pulling, rx_end must be still larger than rx_data.
+
+	if(precvframe==NULL)
+		return NULL;
+
+	precvframe->u.hdr.rx_tail -= sz;
+
+	if(precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data)
+	{
+		precvframe->u.hdr.rx_tail += sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -=sz;
+
+	return precvframe->u.hdr.rx_tail;
+
+}
+
+
+
+__inline static _buffer * get_rxbuf_desc(union recv_frame *precvframe)
+{
+	_buffer * buf_desc;
+	
+	if(precvframe==NULL)
+		return NULL;
+#ifdef PLATFORM_WINDOWS	
+	NdisQueryPacket(precvframe->u.hdr.pkt, NULL, NULL, &buf_desc, NULL);
+#endif
+
+	return buf_desc;
+}
+
+#if 0
+__inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
+{
+	//due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame 
+	//from any given member of recv_frame.
+	// rxmem indicates the any member/address in recv_frame
+	
+	return (union recv_frame*)(((uint)rxmem>>RXFRAME_ALIGN) <<RXFRAME_ALIGN) ;
+	
+}
+
+__inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
+{
+	
+	u8 * buf_star;
+	union recv_frame * precv_frame;
+#ifdef PLATFORM_WINDOWS
+	_buffer * buf_desc;
+	uint len;
+
+	NdisQueryPacket(pkt, NULL, NULL, &buf_desc, &len);
+	NdisQueryBufferSafe(buf_desc, &buf_star, &len, HighPagePriority);
+#endif
+	precv_frame = rxmem_to_recvframe((unsigned char*)buf_star);
+
+	return precv_frame;
+}
+
+__inline static u8 *pkt_to_recvmem(_pkt *pkt)
+{
+	// return the rx_head
+	
+	union recv_frame * precv_frame = pkt_to_recvframe(pkt);
+
+	return 	precv_frame->u.hdr.rx_head;
+
+}
+
+__inline static u8 *pkt_to_recvdata(_pkt *pkt)
+{
+	// return the rx_data
+
+	union recv_frame * precv_frame =pkt_to_recvframe(pkt);
+
+	return 	precv_frame->u.hdr.rx_data;
+	
+}
+#endif
+
+__inline static sint get_recvframe_len(union recv_frame *precvframe)
+{
+	return precvframe->u.hdr.len;
+}
+
+__inline static u8 query_rx_pwr_percentage(s8 antpower )
+{
+	if ((antpower <= -100) || (antpower >= 20))
+	{
+		return	0;
+	}
+	else if (antpower >= 0)
+	{
+		return	100;
+	}
+	else
+	{
+		return	(100+antpower);
+	}
+}
+__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
+{
+	s32	SignalPower; // in dBm.
+
+	// Translate to dBm (x=0.5y-95).
+	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1); 
+	SignalPower -= 95; 
+
+	return SignalPower;
+}
+
+
+struct sta_info;
+
+extern void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+
+extern void  mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame);
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_rf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_rf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_rf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_rf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTL871X_RF_H_ 
+#define __RTL871X_RF_H_
+
+#include <drv_conf.h>
+#include <rtw_cmd.h>
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+
+#define NumRates	(13)
+
+
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+
+
+#define NUM_CHANNELS	15
+//#define NUM_REGULATORYS	21
+#define NUM_REGULATORYS	1
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later	
+#define JAPAN						0x2 //temp, should be provided later	
+
+struct	regulatory_class {
+	u32	starting_freq;					//MHz, 
+	u8	channel_set[NUM_CHANNELS];
+	u8	channel_cck_power[NUM_CHANNELS];//dbm
+	u8	channel_ofdm_power[NUM_CHANNELS];//dbm
+	u8	txpower_limit;  				//dbm
+	u8	channel_spacing;				//MHz
+	u8	modem;
+};
+
+
+enum	_REG_PREAMBLE_MODE{
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+
+enum _RTL8712_RF_MIMO_CONFIG_{
+ RTL8712_RFCONFIG_1T=0x10,
+ RTL8712_RFCONFIG_2T=0x20,
+ RTL8712_RFCONFIG_1R=0x01,
+ RTL8712_RFCONFIG_2R=0x02,
+ RTL8712_RFCONFIG_1T1R=0x11,
+ RTL8712_RFCONFIG_1T2R=0x12,
+ RTL8712_RFCONFIG_TURBO=0x92,
+ RTL8712_RFCONFIG_2T2R=0x22
+};
+
+
+// Bandwidth Offset
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+
+// Represent Channel Width in HT Capabilities
+//
+typedef enum _HT_CHANNEL_WIDTH {
+	HT_CHANNEL_WIDTH_20 = 0,
+	HT_CHANNEL_WIDTH_40 = 1,
+}HT_CHANNEL_WIDTH, *PHT_CHANNEL_WIDTH;
+
+//
+// Represent Extention Channel Offset in HT Capabilities
+// This is available only in 40Mhz mode.
+//
+typedef enum _HT_EXTCHNL_OFFSET{
+	HT_EXTCHNL_OFFSET_NO_EXT = 0,
+	HT_EXTCHNL_OFFSET_UPPER = 1,
+	HT_EXTCHNL_OFFSET_NO_DEF = 2,
+	HT_EXTCHNL_OFFSET_LOWER = 3,
+}HT_EXTCHNL_OFFSET, *PHT_EXTCHNL_OFFSET;
+
+/* 2007/11/15 MH Define different RF type. */
+typedef	enum _RT_RF_TYPE_DEFINITION
+{
+	RF_1T2R = 0,
+	RF_2T4R = 1,
+	RF_2T2R = 2,
+	RF_1T1R = 3,
+	RF_2T2R_GREEN = 4,
+	RF_819X_MAX_TYPE = 5,
+}RT_RF_TYPE_DEF_E;
+
+struct setphyinfo_parm;
+static void init_phyinfo(_adapter  *adapter, struct setphyinfo_parm* psetphyinfopara);
+static u8 writephyinfo_fw(_adapter *padapter, u32 addr);
+u32 rtw_ch2freq(u32 ch);
+u32 rtw_freq2ch(u32 freq);
+
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_rf.h"
+#endif
+
+
+#endif //_RTL8711_RF_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_security.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_security.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_security.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_security.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,283 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_SECURITY_H_
+#define __RTL871X_SECURITY_H_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#define _NO_PRIVACY_	0x0
+#define _WEP40_			0x1
+#define _TKIP_			0x2
+#define _TKIP_WTMIC_	0x3
+#define _AES_			0x4
+#define _WEP104_		0x5
+
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#ifndef Ndis802_11AuthModeWPA2
+#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
+#endif
+
+#ifndef Ndis802_11AuthModeWPA2PSK
+#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
+#endif
+
+union pn48	{
+	
+	u64	val;
+	
+#ifdef CONFIG_LITTLE_ENDIAN
+
+struct {
+  u8 TSC0;
+  u8 TSC1;
+  u8 TSC2;
+  u8 TSC3;
+  u8 TSC4;
+  u8 TSC5;
+  u8 TSC6;
+  u8 TSC7;
+} _byte_;
+ 
+#elif defined(CONFIG_BIG_ENDIAN)
+
+struct {
+  u8 TSC7;
+  u8 TSC6;
+  u8 TSC5;
+  u8 TSC4;
+  u8 TSC3;
+  u8 TSC2;
+  u8 TSC1;
+  u8 TSC0;
+} _byte_;
+ 
+#endif
+
+};
+
+union Keytype {
+        u8   skey[16];
+        u32    lkey[4];
+};
+
+
+typedef struct _RT_PMKID_LIST
+{
+	u8						bUsed;
+	u8 						Bssid[6];
+	u8						PMKID[16];
+	u8						SsidBuf[33];
+	u8*						ssid_octet;
+	u16 						ssid_length;
+} RT_PMKID_LIST, *PRT_PMKID_LIST;
+
+
+struct security_priv
+{
+	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch 
+	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
+
+	/* WEP */
+	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id.
+	union Keytype dot11DefKey[4];			// this is only valid for def. key	
+	u32 	dot11DefKeylen[4];
+
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key 
+	u32	dot118021XGrpKeyid;		// key id used for Grp Key
+	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1	
+	union Keytype	dot118021XGrptxmickey;
+	union Keytype	dot118021XGrprxmickey;
+	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
+	union pn48		dot11Grprxpn;			// PN48 used for Grp Key recv.
+
+#ifdef CONFIG_AP_MODE
+	//extend security capabilities for AP_MODE 
+	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
+	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	unsigned int wpa_group_cipher;
+	unsigned int wpa2_group_cipher;
+	unsigned int wpa_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;	
+#endif
+
+	u8 wps_phase;//for wps
+	u8 wps_ie[MAX_WPA_IE_LEN<<2];
+	int wps_ie_len;
+	
+	
+	u8	binstallGrpkey;
+	u8	busetkipkey;
+	_timer tkip_timer;
+	u8	bcheck_grpkey;
+	u8	bgrpkey_handshake;
+	
+	//u8	packet_cnt;//unused, removed
+	
+	s32	sw_encrypt;//from registry_priv
+	s32	sw_decrypt;//from registry_priv
+	
+	s32 	hw_decrypted;//if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready.
+
+
+	//keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc)
+	u32 ndisauthtype;	// NDIS_802_11_AUTHENTICATION_MODE
+	u32 ndisencryptstatus;	// NDIS_802_11_ENCRYPTION_STATUS
+
+	WLAN_BSSID_EX sec_bss;  //for joinbss (h2c buffer) usage
+
+	NDIS_802_11_WEP ndiswep;
+#ifdef PLATFORM_WINDOWS
+	u8 KeyMaterial[16];// variable length depending on above field.
+#endif
+
+	u8 assoc_info[600];
+	u8 szofcapability[256]; //for wpa2 usage
+	u8 oidassociation[512]; //for wpa/wpa2 usage
+	u8 authenticator_ie[256];  //store ap security information element
+	u8 supplicant_ie[256];  //store sta security information element
+
+
+	//for tkip countermeasure
+	u32 last_mic_err_time;	
+	u8	btkip_countermeasure;
+	u8	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+
+	//---------------------------------------------------------------------------
+	// For WPA2 Pre-Authentication.
+	//---------------------------------------------------------------------------
+	//u8				RegEnablePreAuth;				// Default value: Pre-Authentication enabled or not, from registry "EnablePreAuth". Added by Annie, 2005-11-01.
+	//u8				EnablePreAuthentication;			// Current Value: Pre-Authentication enabled or not.
+	RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	// Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13.
+	u8				PMKIDIndex;
+	//u32				PMKIDCount;						// Added by Annie, 2006-10-13.
+	//u8				szCapability[256];				// For WPA2-PSK using zero-config, by Annie, 2005-09-20.
+
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
+do{\
+	switch(psecuritypriv->dot11AuthAlgrthm)\
+	{\
+		case dot11AuthAlgrthm_Open:\
+		case dot11AuthAlgrthm_Shared:\
+		case dot11AuthAlgrthm_Auto:\
+			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
+			break;\
+		case dot11AuthAlgrthm_8021X:\
+			if(bmcst)\
+				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
+			else\
+				encry_algo =(u8) psta->dot118021XPrivacy;\
+			break;\
+	}\
+}while(0)
+
+
+#define SET_ICE_IV_LEN( iv_len, icv_len, encrypt)\
+do{\
+	switch(encrypt)\
+	{\
+		case _WEP40_:\
+		case _WEP104_:\
+			iv_len = 4;\
+			icv_len = 4;\
+			break;\
+		case _TKIP_:\
+			iv_len = 8;\
+			icv_len = 4;\
+			break;\
+		case _AES_:\
+			iv_len = 8;\
+			icv_len = 8;\
+			break;\
+		default:\
+			iv_len = 0;\
+			icv_len = 0;\
+			break;\
+	}\
+}while(0)
+
+
+#define GET_TKIP_PN(iv,dot11txpn)\
+do{\
+	dot11txpn._byte_.TSC0=iv[2];\
+	dot11txpn._byte_.TSC1=iv[0];\
+	dot11txpn._byte_.TSC2=iv[4];\
+	dot11txpn._byte_.TSC3=iv[5];\
+	dot11txpn._byte_.TSC4=iv[6];\
+	dot11txpn._byte_.TSC5=iv[7];\
+}while(0)
+
+
+#define ROL32( A, n )	( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
+#define ROR32( A, n ) 	ROL32( (A), 32-(n) )
+
+struct mic_data
+{
+	u32  K0, K1;         // Key
+	u32  L, R;           // Current state
+	u32  M;              // Message accumulator (single word)
+	u32     nBytesInM;      // # bytes in M
+};
+
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key );
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b );
+void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes );
+void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst );
+
+void rtw_seccalctkipmic(
+	u8 * key,
+	u8 *header,
+	u8 *data,
+	u32 data_len,
+	u8 *Miccode,
+	u8   priority);
+
+u32 rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe);
+u32 rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe);
+void rtw_wep_encrypt(_adapter *padapter, u8  *pxmitframe);
+
+u32 rtw_aes_decrypt(_adapter *padapter, u8  *precvframe);
+u32 rtw_tkip_decrypt(_adapter *padapter, u8  *precvframe);
+void rtw_wep_decrypt(_adapter *padapter, u8  *precvframe);
+
+
+
+#ifdef PLATFORM_WINDOWS
+void rtw_use_tkipkey_handler (
+	IN	PVOID					SystemSpecific1,
+	IN	PVOID					FunctionContext,
+	IN	PVOID					SystemSpecific2,
+	IN	PVOID					SystemSpecific3
+	);
+#endif
+#ifdef PLATFORM_LINUX
+void rtw_use_tkipkey_handler(void* FunctionContext);
+#endif
+#endif	//__RTL871X_SECURITY_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_version.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_version.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_version.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_version.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1 @@
+#define DRIVERVERSION	"v2.0.1406.20110309"
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_xmit.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_xmit.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/rtw_xmit.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/rtw_xmit.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,442 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_XMIT_H_
+#define _RTL871X_XMIT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <xmit_osdep.h>
+
+#ifdef CONFIG_SDIO_HCI
+#define MAX_XMITBUF_SZ (30720)//	(2048)
+#define NR_XMITBUFF	(16)
+#else //USB
+#if USB_TX_AGGREGATION_92C
+//#define MAX_XMITBUF_SZ	16384	// 32k
+#define MAX_XMITBUF_SZ	20480	// 20k
+#else
+#define MAX_XMITBUF_SZ	(2048)
+#endif
+#define NR_XMITBUFF	(4)
+#endif
+
+#ifdef PLATFORM_OS_CE
+#define XMITBUF_ALIGN_SZ 4
+#else
+#define XMITBUF_ALIGN_SZ 512
+#endif
+
+#define MAX_NUMBLKS		(1)
+
+#define XMIT_QUEUE_ENTRY	(4)
+
+#define XMIT_VO_QUEUE (0)
+#define XMIT_VI_QUEUE (1)
+#define XMIT_BE_QUEUE (2)
+#define XMIT_BK_QUEUE (3)
+
+
+
+#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+	dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0: (dot11txpn.val+1);\
+}while(0)
+
+
+#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = 0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+
+
+struct	hw_xmit	{
+	_lock xmit_lock;
+	_list	pending;	
+	_queue *sta_queue;
+	struct hw_txqueue *phwtxqueue;
+	sint	txcmdcnt;		
+	int	accnt;		
+};
+
+struct pkt_attrib
+{	
+	u8	type;
+	u8   subtype;
+	u8	bswenc;
+	u8   dhcp_pkt;
+	u16	ether_type;	
+	int	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
+	int	pkt_hdrlen;	//the original 802.3 pkt header len
+	int	hdrlen;		//the WLAN Header Len	
+	int	nr_frags;
+	int	last_txcmdsz;
+	int	encrypt;	//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	unsigned char iv[8];
+	int	iv_len;
+	unsigned char icv[8];	
+	int	icv_len;
+	int	priority;
+	int	ack_policy;
+	int	mac_id;
+	int	vcs_mode;	//virtual carrier sense method	
+	
+	u8 	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8 	ra[ETH_ALEN];
+
+	u8 key_idx;
+
+	u8 qos_en;
+	u8 ht_en;	
+	u8 raid;//rate adpative id
+	u8 bwmode;
+	u8 ch_offset;//PRIME_CHNL_OFFSET
+	u8 sgi;//short GI
+	u8 ampdu_en;//tx ampdu enable
+
+	u8  pctrl;//per packet txdesc control enable
+	
+	u32 qsel;
+	u16 seqnum;
+
+	struct sta_info * psta;
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	u8 hw_tcp_csum;
+#endif	
+};
+
+
+#define WLANHDR_OFFSET	64
+
+#define NULL_FRAMETAG		(0x0)
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+
+#define MP_FRAMETAG		0x07
+
+
+#define TXAGG_FRAMETAG 	0x08
+
+
+struct xmit_buf
+{
+	_list	list;
+		
+	_adapter *padapter;
+
+	u8 *pallocated_buf;
+	
+       u8 *pbuf;
+
+	void *priv_data;
+
+	u8 flags;
+
+#ifdef CONFIG_USB_HCI	
+       
+       u32 sz[8];	   
+
+#if defined(PLATFORM_OS_XP)||defined(PLATFORM_LINUX)
+	PURB	pxmit_urb[8];
+#endif
+
+#ifdef PLATFORM_OS_XP
+	PIRP		pxmit_irp[8];
+#endif
+
+#ifdef PLATFORM_OS_CE
+	USB_TRANSFER	usb_transfer_write_port;
+#endif
+
+	u8 bpending[8];
+	
+	sint last[8];
+ 
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+	u32  len;	
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+	u32 ff_hwaddr;
+#ifdef PLATFORM_OS_XP
+	PMDL pxmitbuf_mdl;
+	PIRP  pxmitbuf_irp; 
+	PSDBUS_REQUEST_PACKET pxmitbuf_sdrp;
+#endif	
+#endif
+	
+
+};
+
+struct xmit_frame
+{
+	_list	list;
+
+	struct pkt_attrib attrib;
+	
+	_pkt *pkt;
+	
+	int frame_tag;
+	
+	 _adapter *padapter;
+
+	 u8 *buf_addr;
+
+	 struct xmit_buf *pxmitbuf;
+
+
+#ifdef CONFIG_SDIO_HCI
+	u8 pg_num;
+#endif
+
+#if USB_TX_AGGREGATION_92C
+	u8 agg_num;
+	u8 pkt_offset;
+#endif
+};
+
+struct tx_servq {
+	_list	tx_pending;
+	_queue	sta_pending;	
+	int qcnt;		
+};
+
+
+
+struct sta_xmit_priv
+{
+	_lock	lock;
+	sint	option;
+	sint	apsd_setting;	//When bit mask is on, the associated edca queue supports APSD.
+
+
+	//struct tx_servq blk_q[MAX_NUMBLKS];
+	struct tx_servq	be_q;			//priority == 0,3 
+	struct tx_servq	bk_q;			//priority == 1,2
+	struct tx_servq	vi_q;			//priority == 4,5
+	struct tx_servq	vo_q;			//priority == 6,7
+	_list 	legacy_dz;
+	_list  apsd;
+
+	u16 txseq_tid[16];
+
+	//uint	sta_tx_bytes;
+	//u64	sta_tx_pkts;
+	//uint	sta_tx_fail;
+
+};
+
+
+struct	hw_txqueue	{
+	volatile sint	head;
+	volatile sint	tail;
+	volatile sint 	free_sz;	//in units of 64 bytes	
+	volatile sint      free_cmdsz;
+	volatile sint	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	sint	ac_tag;
+};
+
+
+struct	xmit_priv	{
+	
+	_lock	lock;
+
+	_sema	xmit_sema;
+	_sema	terminate_xmitthread_sema;
+	
+	//_queue	blk_strms[MAX_NUMBLKS];
+	_queue	be_pending;
+	_queue	bk_pending;
+	_queue	vi_pending;
+	_queue	vo_pending;
+	_queue	bm_pending;
+	
+	//_queue	legacy_dz_queue;
+	//_queue	apsd_queue;
+	
+	u8 *pallocated_frame_buf;
+	u8 *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+
+	//uint mapping_addr;
+	//uint pkt_sz;	
+	
+	_queue	free_xmit_queue;	
+
+	struct	hw_txqueue	be_txqueue;
+	struct	hw_txqueue	bk_txqueue;
+	struct	hw_txqueue	vi_txqueue;
+	struct	hw_txqueue	vo_txqueue;
+	struct	hw_txqueue	bmc_txqueue;
+
+	uint	frag_len;
+
+	_adapter	*adapter;
+	
+	u8   vcs_setting;
+	u8	vcs;
+	u8	vcs_type;
+	u16  rts_thresh;
+	
+	u32	NumTxOkInPeriod;
+	u64	tx_bytes;
+	u64	tx_pkts;
+	u64	tx_drop;
+	u16 nqos_ssn;
+	struct hw_xmit *hwxmits;
+	u8	hwxmit_entry;
+
+#ifdef CONFIG_USB_HCI
+	_sema	tx_retevt;//all tx return event;
+	u8		txirp_cnt;//
+	
+#ifdef PLATFORM_OS_CE
+	USB_TRANSFER	usb_transfer_write_port;
+//	USB_TRANSFER	usb_transfer_write_mem;
+#endif
+#ifdef PLATFORM_LINUX
+	struct tasklet_struct xmit_tasklet;
+#endif
+	//per AC pending irp
+	int beq_cnt;
+	int bkq_cnt;
+	int viq_cnt;
+	int voq_cnt;
+	
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+	u8 free_pg[8];
+	u8	public_pgsz;
+	u8	required_pgsz;
+	u8	used_pgsz;
+	u8	init_pgsz;
+#ifdef PLATFORM_OS_XP
+	PMDL prd_freesz_mdl[2];
+	u8 brd_freesz_pending[2];
+	PIRP  prd_freesz_irp[2]; 
+	PSDBUS_REQUEST_PACKET prd_freesz_sdrp[2];
+	u8 rd_freesz_irp_idx;
+#endif
+
+#endif
+
+	_queue free_xmitbuf_queue;
+	_queue pending_xmitbuf_queue;
+	u8 *pallocated_xmitbuf;
+	u8 *pxmitbuf;
+	uint free_xmitbuf_cnt;	
+
+};
+
+
+extern s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+extern struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+
+extern void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len);
+
+extern s32 rtw_make_wlanhdr(_adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib);
+extern s32 rtw_put_snap(u8 *data, u16 h_proto);
+
+extern struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv);
+extern s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+extern void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue );
+extern s32 xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+extern struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, u8 flags);
+
+extern s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
+extern thread_return xmit_thread(thread_context context);
+extern s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
+
+s32 _init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag);
+void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+
+
+s32 rtw_txframes_pending(_adapter *padapter);
+s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib);
+void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry);
+
+
+s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter);
+void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv);
+
+
+void rtw_alloc_hwxmits(_adapter *padapter);
+void rtw_free_hwxmits(_adapter *padapter);
+
+s32 rtw_free_xmitframe_ex(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+
+s32 rtw_xmit(_adapter *padapter, _pkt *pkt);
+
+#ifdef CONFIG_AP_MODE
+sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
+void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta);
+#endif
+
+extern s32 hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe);
+
+#ifdef CONFIG_RTL8712
+#include "rtl8712_xmit.h"
+#endif
+
+#ifdef CONFIG_RTL8192C
+#include "rtl8192c_xmit.h"
+#endif
+
+#endif	//_RTL871X_XMIT_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_hal.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_hal.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_hal.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_hal.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_HAL_H__
+
+#define __SDIO_HAL_H__
+
+extern u8 sd_hal_bus_init(_adapter * adapter);
+extern u8 sd_hal_bus_deinit(_adapter * adapter);
+
+
+u8  sd_int_isr (IN PADAPTER	padapter);
+void sd_int_dpc(PADAPTER padapter);
+
+
+#endif //__SDIO_HAL_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops_ce.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops_ce.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops_ce.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops_ce.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _SDIO_OPS_WINCE_H_
+#define _SDIO_OPS_WINCE_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_OS_CE
+
+
+extern u8 sdbus_cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w_ce(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+
+
+uint sdbus_read_blocks_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+extern uint sdbus_read_bytes_to_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_membuf_ce(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern u8 sdbus_func1cmd52r_ce(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_func1cmd52w_ce(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+
+#endif
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_OPS_H_
+#define __SDIO_OPS_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#ifdef PLATFORM_LINUX
+#include <sdio_ops_linux.h>
+#endif
+
+
+
+#ifdef PLATFORM_WINDOWS
+
+#ifdef PLATFORM_OS_XP
+#include <sdio_ops_xp.h>
+struct async_context
+{
+	PMDL pmdl;
+	PSDBUS_REQUEST_PACKET sdrp;
+	unsigned char* r_buf;
+	unsigned char* padapter;
+};
+#endif
+#ifdef PLATFORM_OS_CE
+#include <sdio_ops_ce.h>
+#endif
+#endif
+
+
+
+extern void sdio_set_intf_option(u32 *poption);
+
+extern void sdio_set_intf_funs(struct intf_hdl *pintf_hdl);
+
+extern uint sdio_init_intf_priv(struct intf_priv *pintfpriv);
+
+extern void sdio_unload_intf_priv(struct intf_priv *pintfpriv);
+
+extern void sdio_intf_hdl_init(u8 *priv);
+
+extern void sdio_intf_hdl_unload(u8 *priv);
+
+extern void sdio_intf_hdl_open(u8 *priv);
+
+extern void sdio_intf_hdl_close(u8 *priv);
+
+extern void sdio_set_intf_ops(struct _io_ops *pops);
+	
+//extern void sdio_set_intf_callbacks(struct _io_callbacks *pcallbacks);
+extern void sdio_func1cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+extern void sdio_func1cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+
+extern	uint __inline _cvrt2ftaddr(const u32 addr, u32 *pftaddr)  ;
+
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops_linux.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops_linux.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops_linux.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops_linux.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _SDIO_OPS_LINUX_H_
+#define _SDIO_OPS_LINUX_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_LINUX
+
+
+extern u8 sdbus_cmd52r(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+extern u8 sdbus_direct_read8(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_direct_write8(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+
+extern uint sdbus_read_bytes_to_recvbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern uint sdbus_read_blocks_to_recvbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_xmitbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_xmitbuf(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+#endif
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops_xp.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops_xp.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_ops_xp.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_ops_xp.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,36 @@
+#ifndef _SDIO_OPS_XP_H_
+#define _SDIO_OPS_XP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+
+#ifdef PLATFORM_OS_XP
+
+
+extern u8 sdbus_cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);
+
+
+extern void sdbus_cmd52w_xp(struct intf_priv *pintfpriv, u32 addr,u8 val8);
+
+
+uint sdbus_read_blocks_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+extern uint sdbus_read_bytes_to_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+
+
+extern uint sdbus_write_blocks_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf,u8 async);
+
+extern uint sdbus_write_bytes_from_membuf_xp(struct intf_priv *pintfpriv, u32 addr, u32 cnt, u8 *pbuf);
+extern u8 sdbus_func1cmd52r_xp(struct intf_priv *pintfpriv, u32 addr);
+extern void sdbus_func1cmd52w_xp(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+extern uint sdbus_read_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern uint sdbus_write_reg(struct intf_priv *pintfpriv, u32 addr, u32 cnt,void *pdata);
+extern void sdio_read_int(_adapter *padapter, u32 addr,u8 sz,void *pdata);
+
+#endif
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_osintf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_osintf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sdio_osintf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sdio_osintf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __SDIO_OSINTF_H
+#define __SDIO_OSINTF_H
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+extern unsigned int sd_dvobj_init(_adapter * adapter);
+extern void sd_dvobj_deinit(_adapter * adapter);
+
+void rtl871x_intf_stop(_adapter *padapter);
+
+u8 sd_hal_bus_init(_adapter * padapter);
+u8 sd_hal_bus_deinit(_adapter * padapter);
+void update_xmit_hw_res(_adapter * padapter);
+void sd_c2h_hdl( PADAPTER	padapter);
+
+#ifdef PLATFORM_OS_CE
+extern NDIS_STATUS ce_sd_get_dev_hdl(_adapter *padapter );
+SD_API_STATUS  
+ce_sd_int_callback(SD_DEVICE_HANDLE hDevice, _adapter* padapter);
+extern void sd_setup_irs(_adapter *padapter);
+#endif
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sta_info.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sta_info.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/sta_info.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/sta_info.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,205 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+
+#define NUM_STA 32
+#define NUM_ACL 64
+
+
+//if mode ==0, then the sta is allowed once the addr is hit.
+//if mode ==1, then the sta is rejected once the addr is non-hit.
+struct wlan_acl_node {
+        _list		        list;
+        u8       addr[ETH_ALEN];
+        u8       mode;
+};
+
+struct wlan_acl_pool {
+        struct wlan_acl_node aclnode[NUM_ACL];
+};
+
+
+struct	stainfo_stats	{
+
+	u64	rx_pkts;
+	u64	rx_bytes;
+	u64	rx_drops;
+	
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64  tx_drops;
+
+};
+
+struct sta_info {
+
+	_lock lock;
+	_list list; //free_sta_queue
+	_list hash_list; //sta_hash
+	//_list asoc_list; //20061114
+	//_list sleep_list;//sleep_q
+	//_list wakeup_list;//wakeup_q
+	
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+	
+	_queue sleep_q;
+	unsigned int sleepq_len;
+	
+	uint state;
+	uint aid;
+	uint mac_id;
+	uint qos_option;
+	u8	hwaddr[ETH_ALEN];
+
+	uint	ieee8021x_blocked;	//0: allowed, 1:blocked 
+	uint	dot118021XPrivacy; //aes, tkip...
+	union Keytype	dot11tkiptxmickey;
+	union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;	
+	union pn48		dot11txpn;			// PN48 used for Unicast xmit.
+	union pn48		dot11rxpn;			// PN48 used for Unicast recv.
+
+
+	u8	bssrateset[16];
+	uint	bssratelen;
+	s32  rssi;
+	s32	signal_quality;
+	
+	unsigned char		cts2self;
+	unsigned char		rtsen;
+
+	unsigned char		raid;
+	unsigned int 		init_rate;
+
+	struct stainfo_stats sta_stats;
+
+	//for A-MPDU TX, ADDBA timeout check	
+	_timer addba_retry_timer;
+	
+	//for A-MPDU Rx reordering buffer control 
+	struct recv_reorder_ctrl recvreorder_ctrl[16];
+
+	//for A-MPDU Tx
+	//unsigned char		ampdu_txen_bitmap;
+
+#ifdef CONFIG_80211N_HT
+	struct ht_priv	htpriv;	
+#endif
+	
+
+	//Notes:	
+	//STA_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO	
+	//scan_q: AP CAP/INFO
+
+	//AP_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
+	//sta_info: (AP & STA) CAP/INFO
+		
+#ifdef CONFIG_NATIVEAP_MLME
+
+	_list asoc_list;
+	_list auth_list;
+	 
+	unsigned int expire_to;
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+
+	unsigned int tx_ra_bitmap;
+
+#endif	
+
+	
+
+};
+
+
+
+struct	sta_priv {
+	
+	u8 *pallocated_stainfo_buf;
+	u8 *pstainfo_buf;
+	_queue	free_sta_queue;
+	
+	_lock sta_hash_lock;
+	_list   sta_hash[NUM_STA];
+	int asoc_sta_count;
+	_queue sleep_q;
+	_queue wakeup_q;
+	
+	_adapter *padapter;
+	
+
+#ifdef CONFIG_AP_MODE
+	u16 sta_dz_bitmap;//only support 16 stations, staion aid bitmap for sleeping sta.
+	u16 tim_bitmap;//only support 16 stations, aid=1~16 mapping bit0~bit15
+#endif	
+	
+#ifdef CONFIG_NATIVEAP_MLME
+    	
+	_list asoc_list;
+	_list auth_list;
+
+	unsigned int auth_to;  //sec, time to expire in authenticating.
+	unsigned int assoc_to; //sec, time to expire before associating.
+	unsigned int expire_to; //sec , time to expire after associated.
+	
+#endif		
+	
+};
+
+
+__inline static u32 wifi_mac_hash(u8 *mac)
+{
+        u32 x;
+
+        x = mac[0];
+        x = (x << 2) ^ mac[1];
+        x = (x << 2) ^ mac[2];
+        x = (x << 2) ^ mac[3];
+        x = (x << 2) ^ mac[4];
+        x = (x << 2) ^ mac[5];
+
+        x ^= x >> 8;
+        x  = x & (NUM_STA - 1);
+		
+        return x;
+}
+
+
+extern u32	_rtw_init_sta_priv(struct sta_priv *pstapriv);
+extern u32	_rtw_free_sta_priv(struct sta_priv *pstapriv);
+extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr);
+extern u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta);
+extern void rtw_free_all_stainfo(_adapter *padapter);
+extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+extern u32 rtw_init_bcmc_stainfo(_adapter* padapter);
+extern struct sta_info* rtw_get_bcmc_stainfo(_adapter* padapter);
+extern u8 rtw_access_ctrl(struct wlan_acl_pool* pacl_list, u8 * mac_addr);
+
+#endif //_STA_INFO_H_
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_hal.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_hal.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_hal.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_hal.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_HAL_H__
+#define __USB_HAL_H__
+
+//u32 rtl8192cu_hal_init(_adapter * adapter);
+//u32 rtl8192cu_hal_deinit(_adapter * adapter);
+
+//unsigned int rtl8192cu_inirp_init(_adapter * padapter);
+//unsigned int rtl8192cu_inirp_deinit(_adapter * padapter);
+
+//void rtl8192cu_interface_configure(_adapter *padapter);
+
+void rtl8192cu_set_hal_ops(_adapter * padapter);
+
+#endif //__USB_HAL_H__
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_ops.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_ops.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_ops.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_ops.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,45 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#define REALTEK_USB_VENQT_READ		0xC0
+#define REALTEK_USB_VENQT_WRITE		0x40
+#define REALTEK_USB_VENQT_CMD_REQ	0x05
+#define REALTEK_USB_VENQT_CMD_IDX	0x00
+
+enum{
+	VENDOR_WRITE = 0x00,
+	VENDOR_READ = 0x01,
+};
+
+
+void rtl8192cu_set_intf_ops(struct _io_ops *pops);
+
+void rtl8192cu_trigger_gpio_0(_adapter *padapter);
+
+void rtl8192cu_recv_tasklet(void *priv);
+
+#endif
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_osintf.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_osintf.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_osintf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_osintf.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OSINTF_H
+#define __USB_OSINTF_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <usb_vendor_req.h>
+
+#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)
+
+
+//uint usb_dvobj_init(_adapter * adapter);
+//void usb_dvobj_deinit(_adapter * adapter);
+
+u8 usbvendorrequest(struct dvobj_priv *pdvobjpriv, RT_USB_BREQUEST brequest, RT_USB_WVALUE wvalue, u8 windex, void* data, u8 datalen, u8 isdirectionin);
+
+//void rtw_intf_stop(_adapter *padapter);
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_vendor_req.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_vendor_req.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/usb_vendor_req.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/usb_vendor_req.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,59 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+//4	Set/Get Register related wIndex/Data
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON				1
+#define	RT_USB_LDO_OFF				0
+
+//4	Set/Get SYSCLK related	wValue or Data
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+
+typedef enum _RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+} RT_USB_BREQUEST;
+
+
+typedef enum _RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO			=	4,
+	RT_USB_BOOT_TYPE	=	5
+} RT_USB_WVALUE;
+
+
+//BOOLEAN usbvendorrequest(PCE_USB_DEVICE	CEdevice, RT_USB_BREQUEST bRequest, RT_USB_WVALUE wValue, UCHAR wIndex, PVOID Data, UCHAR DataLength, BOOLEAN isDirectionIn);
+//BOOLEAN CEusbGetStatusRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT Index, PVOID Data);
+//BOOLEAN CEusbFeatureRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT FeatureSelector, IN USHORT Index);
+//BOOLEAN CEusbGetDescriptorRequest(PCE_USB_DEVICE CEdevice, IN short urbLength, IN UCHAR DescriptorType, IN UCHAR Index, IN USHORT LanguageId, IN PVOID  TransferBuffer, IN ULONG TransferBufferLength);
+
+#endif
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/version.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/version.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/version.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/version.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,20 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define DRIVERVERSION	v1.0.725.20100525
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/wifi.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/wifi.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/wifi.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/wifi.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,787 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+#include <rtw_byteorder.h>
+
+#ifdef BIT
+//#error	"BIT define occurred earlier elsewhere!\n"
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+#ifdef GREEN_HILL
+#pragma pack(1)
+#endif
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	//!< QoS Data	
+};
+
+enum WIFI_FRAME_SUBTYPE {
+
+    // below is for mgt frame
+    WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+    WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+    WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+    WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+    WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+    WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+    WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+    WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+
+    // below is for control frame
+    WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+    WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+
+    // below is for data frame
+    WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+    WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+    WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_					= 0,
+	_RSON_UNSPECIFIED_				= 1,
+	_RSON_AUTH_NO_LONGER_VALID_		= 2,
+	_RSON_DEAUTH_STA_LEAVING_		= 3,
+	_RSON_INACTIVITY_				= 4,
+	_RSON_UNABLE_HANDLE_			= 5,
+	_RSON_CLS2_						= 6,
+	_RSON_CLS3_						= 7,
+	_RSON_DISAOC_STA_LEAVING_		= 8,
+	_RSON_ASOC_NOT_AUTH_			= 9,
+
+	// WPA reason
+	_RSON_INVALID_IE_				= 13,
+	_RSON_MIC_FAILURE_				= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_					= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_			= 20,
+	_RSON_UNSUPPORT_RSNE_VER_		= 21,
+	_RSON_INVALID_RSNE_CAP_			= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+
+	//belowing are Realtek definition
+	_RSON_PMK_NOT_AVAILABLE_		= 24,
+};
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_			= 0,
+	_STATS_FAILURE_				= 1,
+	_STATS_CAP_FAIL_			= 10,
+	_STATS_NO_ASOC_				= 11,
+	_STATS_OTHER_				= 12,
+	_STATS_NO_SUPP_ALG_			= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_			= 18,
+};
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC		= 1,
+	DOMAIN_IC		= 2,
+	DOMAIN_ETSI		= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK		= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1		= 8,
+	DOMAIN_MKK2		= 9,
+	DOMAIN_MKK3		= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_			BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while(0)
+
+#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while(0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while(0)
+
+#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while(0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while(0)
+
+#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while(0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while(0)
+
+#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while(0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while(0)
+
+#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while(0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while(0)
+
+#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while(0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while(0)
+
+#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while(0)
+
+
+#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & (BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf,type)	\
+	do { 	\
+		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while(0)
+
+#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+#define SetFrameSubType(pbuf,type) \
+	do {    \
+		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
+	} while(0)
+
+#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while(0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu((unsigned short)~0xfff0)) | \
+			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+	} while(0)
+
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(unsigned short *)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
+	} while(0)
+
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while(0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(pbuf))) & 0xf)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (ack & 3) << 5); \
+	} while(0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
+	} while(0)	
+
+#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
+
+#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))
+
+#define MacAddr_isBcst(addr) \
+( \
+	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
+)
+
+
+__inline static int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01)
+		return _TRUE;
+	else
+		return _FALSE;
+}
+
+
+__inline static unsigned char * get_da(unsigned char *pframe)
+{
+	unsigned char 	*da;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			da = GetAddr3Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			da = GetAddr3Ptr(pframe);
+			break;
+	}
+
+	return da;
+}
+
+
+__inline static unsigned char * get_sa(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			sa = GetAddr4Ptr(pframe);
+			break;
+	}
+
+	return sa;
+}
+
+__inline static unsigned char * get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr1Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			sa = GetAddr2Ptr(pframe);
+			break;
+	}
+
+	return sa;
+}
+
+
+__inline static int IsFrameTypeCtrl(unsigned char *pframe)
+{
+	if(WIFI_CTRL_TYPE == GetFrameType(pframe))
+		return _TRUE;
+	else
+		return _FALSE;
+}
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_		2
+#define _PRE_ALLOCMEM_			1
+#define _PRE_ALLOCHDR_			3
+#define _PRE_ALLOCLLCHDR_		4
+#define _PRE_ALLOCICVHDR_		5
+#define _PRE_ALLOCMICHDR_		6
+
+#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A)?16:10)
+#define _ACKCTSLNG_				14	//14 bytes long, including crclng
+#define _CRCLNG_				4
+
+#define _ASOCREQ_IE_OFFSET_		4	// excluding wlan_hdr
+#define	_ASOCRSP_IE_OFFSET_		6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_		6
+#define _DEAUTH_IE_OFFSET_		0
+#define _BEACON_IE_OFFSET_		12
+
+#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
+
+#define _SSID_IE_				0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_				3
+#define _TIM_IE_					5
+#define _IBSS_PARA_IE_			6
+#define _CHLGETXT_IE_			16
+#define _RSN_IE_2_				48
+#define _SSN_IE_1_					221
+#define _ERPINFO_IE_			42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_			45
+#define _HT_EXTRA_INFO_IE_			61
+#define _HT_ADD_INFO_IE_			61 //_HT_EXTRA_INFO_IE_
+
+#define	EID_BSSCoexistence			72 // 20/40 BSS Coexistence
+#define	EID_BSSIntolerantChlReport	73
+
+#define _VENDOR_SPECIFIC_IE_		221
+
+#define	_RESERVED47_				47
+
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1		// WPA
+#define _IEEE8021X_PSK_			2		// WPA with pre-shared key
+
+/*
+#define _NO_PRIVACY_			0
+#define _WEP_40_PRIVACY_		1
+#define _TKIP_PRIVACY_			2
+#define _WRAP_PRIVACY_			3
+#define _CCMP_PRIVACY_			4
+#define _WEP_104_PRIVACY_		5
+#define _WEP_WPA_MIXED_PRIVACY_ 6	// WEP + WPA
+*/
+				
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  // for WMM STA
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n 
+------------------------------------------------------------------------------*/
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+//#ifdef CONFIG_80211N_HT
+
+#define SetOrderBit(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while(0)
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+
+/**
+ * struct ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+ #if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8712FW)
+struct ieee80211_bar {
+	unsigned short frame_control;
+	unsigned short duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	unsigned short control;
+	unsigned short start_seq_num;
+} __attribute__((packed));
+ #endif
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+
+ #if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8712FW)
+
+ /**
+ * struct ieee80211_ht_cap - HT capabilities
+ *
+ * This structure refers to "HT capabilities element" as
+ * described in 802.11n draft section 7.3.2.52
+ */
+ 
+struct ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __attribute__ ((packed));
+
+/**
+ * struct ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+} __attribute__ ((packed));
+
+
+struct HT_caps_element
+{
+	union
+	{ 
+		struct 
+		{ 	
+			unsigned short	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			unsigned short	HT_ext_caps;
+			unsigned int	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} HT_cap_element;
+		unsigned char HT_cap[26];
+	};
+} __attribute__ ((packed));
+
+struct HT_info_element
+{
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+}  __attribute__ ((packed));
+
+struct AC_param
+{
+	unsigned char		ACI_AIFSN;
+	unsigned char		CW;
+	unsigned short	TXOP_limit;
+}  __attribute__ ((packed));
+
+struct WMM_para_element
+{
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+}  __attribute__ ((packed));
+
+struct ADDBA_request
+{
+	unsigned char		dialog_token;
+	unsigned short	BA_para_set;
+	unsigned short	BA_timeout_value;
+	unsigned short	BA_starting_seqctrl;
+}  __attribute__ ((packed));
+
+
+
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+
+#pragma pack(1)
+
+struct ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+};
+
+
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+};
+
+struct HT_caps_element
+{
+	union
+	{ 
+		struct 
+		{ 	
+			unsigned short	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			unsigned short	HT_ext_caps;
+			unsigned int	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} HT_cap_element;
+		unsigned char HT_cap[26];
+	};
+};
+
+struct HT_info_element
+{
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+};
+
+struct AC_param
+{
+	unsigned char		ACI_AIFSN;
+	unsigned char		CW;
+	unsigned short	TXOP_limit;
+};
+
+struct WMM_para_element
+{
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+};
+
+struct ADDBA_request
+{
+	unsigned char		dialog_token;
+	unsigned short	BA_para_set;
+	unsigned short	BA_timeout_value;
+	unsigned short	BA_starting_seqctrl;
+};
+
+
+#pragma pack()
+
+#endif
+
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_RX_STBC		0x0300
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE	 	0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE 		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW 		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+
+//#endif
+
+#endif // _WIFI_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/wlan_bssdef.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/wlan_bssdef.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/wlan_bssdef.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/wlan_bssdef.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,433 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+
+#define MAX_IE_SZ	768
+
+
+#ifdef PLATFORM_LINUX
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef unsigned char   NDIS_802_11_MAC_ADDRESS[6];
+typedef long    		NDIS_802_11_RSSI;           // in dBm
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+
+
+typedef  ULONG  NDIS_802_11_KEY_INDEX;
+typedef unsigned long long NDIS_802_11_KEY_RSC;
+
+
+typedef struct _NDIS_802_11_SSID
+{
+  ULONG  SsidLength;
+  UCHAR  Ssid[32];
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+typedef enum _NDIS_802_11_NETWORK_TYPE
+{
+    Ndis802_11FH,
+    Ndis802_11DS,
+    Ndis802_11OFDM5,
+    Ndis802_11OFDM24,
+    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH
+{
+    ULONG           Length;             // Length of structure
+    ULONG           HopPattern;         // As defined by 802.11, MSB set
+    ULONG           HopSet;             // to one if non-802.11
+    ULONG           DwellTime;          // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+ 
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.	
+*/
+typedef struct _NDIS_802_11_CONFIGURATION
+{
+    ULONG           Length;             // Length of structure
+    ULONG           BeaconPeriod;       // units are Kusec
+    ULONG           ATIMWindow;         // units are Kusec
+    ULONG           DSConfig;           // Frequency, units are kHz
+    NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
+{
+    Ndis802_11IBSS,
+    Ndis802_11Infrastructure,
+    Ndis802_11AutoUnknown,
+    Ndis802_11InfrastructureMax,     // Not a real value, defined as upper bound
+    Ndis802_11APMode
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+
+
+
+
+typedef struct _NDIS_802_11_FIXED_IEs
+{
+  UCHAR  Timestamp[8];
+  USHORT  BeaconInterval;
+  USHORT  Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+
+
+typedef struct _NDIS_802_11_VARIABLE_IEs
+{
+  UCHAR  ElementID;
+  UCHAR  Length;
+  UCHAR  data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+
+
+/*
+
+
+
+Length is the 4 bytes multiples of the sume of
+	sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + sizeof (NDIS_802_11_SSID) + sizeof (ULONG)
++   sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (NDIS_802_11_CONFIGURATION)
++   sizeof (NDIS_802_11_RATES_EX) + IELength
+
+Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
+partial sum.
+
+*/
+#if 0
+typedef struct _NDIS_WLAN_BSSID_EX
+{
+  ULONG  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  UCHAR  Reserved[2];//[0]: IS beacon frame, [1]:optimum_antenna=>For antenna diversity;
+  NDIS_802_11_SSID  Ssid;
+  ULONG  Privacy;
+  NDIS_802_11_RSSI  Rssi;
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  ULONG  IELength;
+  UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
+
+
+typedef struct _NDIS_802_11_BSSID_LIST_EX
+{
+  ULONG  NumberOfItems;
+  NDIS_WLAN_BSSID_EX  Bssid[1];
+} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
+#endif
+
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE
+{
+    Ndis802_11AuthModeOpen,
+    Ndis802_11AuthModeShared,
+    Ndis802_11AuthModeAutoSwitch,
+    Ndis802_11AuthModeWPA,
+    Ndis802_11AuthModeWPAPSK,
+    Ndis802_11AuthModeWPANone,
+    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+typedef enum _NDIS_802_11_WEP_STATUS
+{
+    Ndis802_11WEPEnabled,
+    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+    Ndis802_11WEPDisabled,
+    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+    Ndis802_11WEPKeyAbsent,
+    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+    Ndis802_11WEPNotSupported,
+    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+    Ndis802_11Encryption2Enabled,
+    Ndis802_11Encryption2KeyAbsent,
+    Ndis802_11Encryption3Enabled,
+    Ndis802_11Encryption3KeyAbsent
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI
+{
+    USHORT Capabilities;
+    USHORT ListenInterval;
+    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI
+{
+    USHORT Capabilities;
+    USHORT StatusCode;
+    USHORT AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
+{
+    ULONG                   Length;
+    USHORT                  AvailableRequestFixedIEs;
+    NDIS_802_11_AI_REQFI    RequestFixedIEs;
+    ULONG                   RequestIELength;
+    ULONG                   OffsetRequestIEs;
+    USHORT                  AvailableResponseFixedIEs;
+    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+    ULONG                   ResponseIELength;
+    ULONG                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS
+{
+   Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+
+// Key mapping keys require a BSSID
+typedef struct _NDIS_802_11_KEY
+{
+    ULONG           Length;             // Length of this structure
+    ULONG           KeyIndex;           
+    ULONG           KeyLength;          // length of key in bytes
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    NDIS_802_11_KEY_RSC KeyRSC;
+    UCHAR           KeyMaterial[32];     // variable length depending on above field
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY
+{
+    ULONG                   Length;        // Length of this structure
+    ULONG                   KeyIndex;           
+    NDIS_802_11_MAC_ADDRESS BSSID;      
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct _NDIS_802_11_WEP
+{
+    ULONG     Length;        // Length of this structure
+    ULONG     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
+    ULONG     KeyLength;     // length of key in bytes
+    UCHAR     KeyMaterial[16];// variable length depending on above field
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
+{
+    ULONG Length;            // Length of structure
+    NDIS_802_11_MAC_ADDRESS Bssid;
+    ULONG Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+typedef enum _NDIS_802_11_STATUS_TYPE
+{
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,		
+	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+typedef struct _NDIS_802_11_STATUS_INDICATION
+{
+    NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+// mask for authentication/integrity fields
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+// MIC check time, 60 seconds.
+#define MIC_CHECK_TIME	60000000
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
+{
+    NDIS_802_11_STATUS_INDICATION       Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+        
+typedef struct _NDIS_802_11_TEST
+{
+    ULONG Length;
+    ULONG Type;
+    union
+    {
+        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+        NDIS_802_11_RSSI RssiTrigger;
+    }tt;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+
+#endif //end of #ifdef PLATFORM_LINUX
+
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
+#endif
+
+typedef struct _WLAN_PHY_INFO
+{
+	u8	SignalStrength;//(in percentage)
+  	u8	SignalQuality;//(in percentage)
+  	u8	Optimum_antenna;  //for Antenna diversity
+  	u8  	Reserved_0;
+}WLAN_PHY_INFO,*PWLAN_PHY_INFO;
+
+typedef struct _WLAN_BSSID_EX
+{
+  ULONG  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  UCHAR  Reserved[2];//[0]: IS beacon frame
+  NDIS_802_11_SSID  Ssid;
+  ULONG  Privacy;
+  NDIS_802_11_RSSI  Rssi;//(in dBM,raw data ,get from PHY)
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;  
+  WLAN_PHY_INFO	PhyInfo;  	
+  ULONG  IELength;
+  UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} WLAN_BSSID_EX, *PWLAN_BSSID_EX;
+
+__inline  static uint get_WLAN_BSSID_EX_sz(WLAN_BSSID_EX *bss)
+{
+	uint t_len;
+	
+	t_len = sizeof (ULONG) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + 
+			sizeof (NDIS_802_11_SSID) + sizeof (ULONG) + 
+			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + 
+			sizeof (NDIS_802_11_CONFIGURATION) +	
+			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +   
+			sizeof (NDIS_802_11_RATES_EX)+ 
+			//all new member add here
+			sizeof(WLAN_PHY_INFO)+	 
+			//all new member add here
+			sizeof (ULONG) + bss->IELength;	
+	return t_len;
+	
+}
+
+struct	wlan_network {
+	_list	list;	
+	int	network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
+	int	fixed;			// set to fixed when not to be removed as site-surveying
+	unsigned long	last_scanned; //timestamp for the network
+	int	aid;			//will only be valid when a BSS is joinned.
+	int	join_res;	
+	WLAN_BSSID_EX	network; //must be the last item
+#ifdef PLATFORM_WINDOWS	
+	unsigned char  iebuf[MAX_IE_SZ];
+#endif
+
+};
+
+enum VRTL_CARRIER_SENSE
+{
+    DISABLE_VCS,	
+    ENABLE_VCS,	
+    AUTO_VCS
+};
+
+enum VCS_TYPE
+{
+    NONE_VCS,	
+    RTS_CTS,
+    CTS_TO_SELF 
+};
+
+
+
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+
+enum UAPSD_MAX_SP
+{
+	NO_LIMIT,
+       TWO_MSDU,
+       FOUR_MSDU,
+       SIX_MSDU
+};
+
+
+//john
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+* 	WPA2
+*/
+
+#ifndef PLATFORM_OS_CE
+typedef struct _PMKID_CANDIDATE {
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    ULONG Flags;
+} PMKID_CANDIDATE, *PPMKID_CANDIDATE;
+
+typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
+{
+    ULONG Version;       // Version of the structure
+    ULONG NumCandidates; // No. of pmkid candidates
+    PMKID_CANDIDATE CandidateList[1];
+} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
+
+
+typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION
+{
+	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
+	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
+	
+} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
+
+typedef struct _NDIS_802_11_CAPABILITY 
+{
+	ULONG  Length;
+	ULONG  Version;
+	ULONG  NoOfPMKIDs;
+	ULONG  NoOfAuthEncryptPairsSupported;
+	NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
+	
+} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
+#endif
+
+
+#endif //#ifndef WLAN_BSSDEF_H_
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/xmit_osdep.h linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/xmit_osdep.h
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/include/xmit_osdep.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/include/xmit_osdep.h	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+struct pkt_file {
+	_pkt *pkt;
+	SIZE_T pkt_len;	 //the remainder length of the open_file
+	_buffer *cur_buffer;
+	u8 *buf_start;
+	u8 *cur_addr;
+	SIZE_T buf_len;
+};
+
+#ifdef PLATFORM_WINDOWS
+
+#ifdef PLATFORM_OS_XP
+#ifdef CONFIG_USB_HCI
+#include <usb.h>
+#include <usbdlib.h>
+#include <usbioctl.h>
+#endif
+#endif
+
+#define NR_XMITFRAME     128
+
+#define ETH_ALEN	6
+
+extern NDIS_STATUS rtw_xmit_entry(
+IN _nic_hdl		cnxt,
+IN NDIS_PACKET		*pkt,
+IN UINT				flags
+);
+
+#endif
+
+
+#ifdef PLATFORM_LINUX
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+extern int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
+
+#ifdef CONFIG_USB_HCI
+extern void xmit_tasklet(void *priv);
+#endif
+
+#endif
+
+
+int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf);
+void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf);
+
+extern void set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib);
+
+extern uint rtw_remainder_len(struct pkt_file *pfile);
+extern void _rtw_open_pktfile(_pkt *pkt, struct pkt_file *pfile);
+extern uint _rtw_pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen);
+extern sint rtw_endofpktfile (struct pkt_file *pfile);
+
+extern void os_pkt_complete(_adapter *padapter, _pkt *pkt);
+extern void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe);
+
+#endif //
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/Kconfig linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/Kconfig
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/Kconfig	2011-04-26 17:11:13.000000000 +0800
@@ -0,0 +1,8 @@
+config RTL8192CU
+	tristate "Realtek 8192C USB WiFi"
+	depends on USB
+	select WIRELESS_EXT 
+	select WEXT_PRIV 
+	---help---
+	  Help message of RTL8192CU
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/Makefile linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/Makefile
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/Makefile	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,341 @@
+EXTRA_CFLAGS += -O1 
+#EXTRA_CFLAGS += -O3
+#EXTRA_CFLAGS += -Wall 
+#EXTRA_CFLAGS += -Wextra 
+#EXTRA_CFLAGS += -Werror
+#EXTRA_CFLAGS += -pedantic
+#EXTRA_CFLAGS += -Wshadow -Wpointer-arith -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes 
+EXTRA_CFLAGS += -Wno-unused-variable -Wno-unused-value -Wno-unused-label -Wno-unused-parameter -Wno-uninitialized
+EXTRA_CFLAGS += -Wno-unused -Wno-unused-function
+EXTRA_CFLAGS += -I$(src)/include
+
+CONFIG_AUTOCFG_CP              =       n
+
+CONFIG_RTL8712			=	n
+CONFIG_RTL8192C			=       y
+
+CONFIG_USB_HCI			=	y
+CONFIG_SDIO_HCI			= 	n
+CONFIG_MP_INCLUDED		=	n
+CONFIG_POWER_SAVING			=	n
+CONFIG_USB_AUTOSUSPEND			=	n
+CONFIG_HW_PWRP_DETECTION		=	n
+CONFIG_WIFI_TEST						=	n
+CONFIG_RTL8192CU_REDEFINE_1X1 =n
+
+CONFIG_PLATFORM_I386_PC		=	y
+CONFIG_PLATFORM_ANDROID_X86	=	n
+CONFIG_PLATFORM_ARM_S3C2K4	=	n
+CONFIG_PLATFORM_ARM_PXA2XX	=	n
+CONFIG_PLATFORM_ARM_S3C6K4	=	n
+CONFIG_PLATFORM_MIPS_RMI	=	n
+CONFIG_PLATFORM_RTD2880B	=	n
+CONFIG_PLATFORM_MIPS_AR9132	=	n
+CONFIG_PLATFORM_MT53XX		=	n
+CONFIG_PLATFORM_RTK_DMP		=	n
+CONFIG_PLATFORM_ARM_TCC8900	=	n
+CONFIG_PLATFORM_ARM_MX51_241H		=	n
+CONFIG_PLATFORM_ACTIONS_ATJ227X = n
+
+CONFIG_DRVEXT_MODULE	=	n
+
+export TopDIR ?= $(shell pwd)
+
+
+ifeq ($(CONFIG_RTL8712), y)
+
+RTL871X = rtl8712
+
+ifeq ($(CONFIG_SDIO_HCI), y)
+MODULE_NAME = 8712s
+endif
+ifeq ($(CONFIG_USB_HCI), y)
+MODULE_NAME = 8712u
+endif
+
+endif
+
+ifeq ($(CONFIG_RTL8192C), y)
+
+RTL871X = rtl8192c
+
+ifeq ($(CONFIG_SDIO_HCI), y)
+MODULE_NAME = 8192cs
+endif
+ifeq ($(CONFIG_USB_HCI), y)
+MODULE_NAME = 8192cu
+endif
+
+endif
+
+
+ifeq ($(CONFIG_SDIO_HCI), y)
+
+ 
+_OS_INTFS_FILES := os_intf/osdep_service.o \
+                    os_intf/linux/os_intfs.o \
+                    os_intf/osdep_sdio_intf.o \
+		    		os_intf/linux/sdio_intf.o \
+
+_HAL_INTFS_FILES := hal/$(RTL871X)/hal_init.o \
+		    hal/$(RTL871X)/sdio_halinit.o \
+		    hal/$(RTL871X)/sdio_ops.o \
+		    hal/$(RTL871X)/sdio_ops_linux.o    	
+
+endif
+
+
+ifeq ($(CONFIG_USB_HCI), y)
+ 
+ifeq ($(CONFIG_AUTOCFG_CP), y)
+$(shell cp $(TopDIR)/autoconf_$(RTL871X)_usb_linux.h $(TopDIR)/include/autoconf.h)
+endif
+
+#ifeq ($(CONFIG_BEST_BATTERYLIFE), y)
+#EXTRA_CFLAGS += -DCONFIG_BEST_BATTERYLIFE
+#endif
+
+ifeq ($(CONFIG_POWER_SAVING), y)
+EXTRA_CFLAGS += -DCONFIG_POWER_SAVING
+endif
+
+ifeq ($(CONFIG_USB_AUTOSUSPEND), y)
+EXTRA_CFLAGS += -DCONFIG_USB_AUTOSUSPEND
+endif
+
+ifeq ($(CONFIG_HW_PWRP_DETECTION), y)
+EXTRA_CFLAGS += -DCONFIG_HW_PWRP_DETECTION
+endif
+
+ifeq ($(CONFIG_WIFI_TEST), y)
+EXTRA_CFLAGS += -DCONFIG_WIFI_TEST
+endif
+
+ifeq ($(CONFIG_RTL8192CU_REDEFINE_1X1), y)
+EXTRA_CFLAGS += -DRTL8192C_RECONFIG_TO_1T1R
+endif 
+
+ifeq ($(CONFIG_PLATFORM_I386_PC), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
+ARCH ?= $(SUBARCH)
+CROSS_COMPILE ?=
+KVER  := $(shell uname -r)
+KSRC := /lib/modules/$(KVER)/build
+MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
+INSTALL_PREFIX :=
+endif
+
+ifeq ($(CONFIG_PLATFORM_ANDROID_X86), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID
+SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
+ARCH := $(SUBARCH)
+CROSS_COMPILE ?= i686-unknown-linux-gnu-
+KSRC := /usr/src/froyo-x86/out/target/product/eeepc/obj/kernel
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_PXA2XX), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+ARCH := arm
+CROSS_COMPILE := arm-none-linux-gnueabi-
+KVER  := 2.6.34.1
+KSRC ?= /usr/src/linux-2.6.34.1
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_S3C2K4), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+ARCH := arm
+CROSS_COMPILE := arm-linux-
+KVER  := 2.6.24.7_$(ARCH)
+KSRC := /usr/src/kernels/linux-$(KVER)
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_S3C6K4), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+ARCH := arm
+CROSS_COMPILE := arm-none-linux-gnueabi-
+KVER  := 2.6.34.1
+KSRC ?= /usr/src/linux-2.6.34.1
+endif
+
+ifeq ($(CONFIG_PLATFORM_RTD2880B), y)
+EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN -DCONFIG_PLATFORM_RTD2880B
+ARCH:=
+CROSS_COMPILE:=
+KVER:=
+KSRC:=
+endif
+
+ifeq ($(CONFIG_PLATFORM_MIPS_RMI), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+ARCH:=mips
+CROSS_COMPILE:=mipsisa32r2-uclibc-
+KVER:= 
+KSRC:= /root/work/kernel_realtek
+endif
+
+ifeq ($(CONFIG_PLATFORM_MIPS_PLM), y)
+EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
+ARCH:=mips
+CROSS_COMPILE:=mipsisa32r2-uclibc-
+KVER:= 
+KSRC:= /root/work/kernel_realtek
+endif
+
+ifeq ($(CONFIG_PLATFORM_MSTAR389), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR389
+ARCH:=mips
+CROSS_COMPILE:= mips-linux-gnu-
+KVER:= 2.6.28.10
+KSRC:= /home/mstar/mstar_linux/2.6.28.9/
+endif
+
+ifeq ($(CONFIG_PLATFORM_MIPS_AR9132), y)
+EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
+ARCH := mips
+CROSS_COMPILE := mips-openwrt-linux-
+KSRC := /home/alex/test_openwrt/tmp/linux-2.6.30.9
+endif
+
+ifeq ($(CONFIG_PLATFORM_MT53XX), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MT53XX
+ARCH:= arm
+CROSS_COMPILE:= arm11_mtk_le-
+KVER:= 2.6.27
+KSRC?= /proj/mtk00802/BD_Compare/BDP/Dev/BDP_V301/BDP_Linux/linux-2.6.27
+endif
+
+ifeq ($(CONFIG_PLATFORM_RTK_DMP), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DRTK_DMP_PLATFORM
+ARCH:=mips
+CROSS_COMPILE:=mipsel-linux-
+KVER:= 
+KSRC ?= /root/Desktop/SVN/linux-2.6.12
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_TCC8900), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID
+ARCH ?= arm
+CROSS_COMPILE ?= /usr/src/telechip/SDK_0127_20101006/prebuilt/linux-x86/toolchain/arm-eabi-4.3.1/bin/arm-eabi-
+KSRC ?= /usr/src/telechip/SDK_0127_20101006/kernel
+endif
+
+ifeq ($(CONFIG_PLATFORM_ARM_MX51_241H), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_WISTRON_PLATFORM
+ARCH := arm
+CROSS_COMPILE := /opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-
+KVER  := 2.6.31
+KSRC ?= /lib/modules/2.6.31-770-g0e46b52/source
+endif
+ 
+ifeq ($(CONFIG_PLATFORM_ACTIONS_ATJ227X), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ACTIONS_ATJ227X
+ARCH := mips
+CROSS_COMPILE := /home/cnsd4/project/actions/tools-2.6.27/bin/mipsel-linux-gnu-
+KVER  := 2.6.27
+KSRC := /home/cnsd4/project/actions/linux-2.6.27.28
+endif
+
+ 
+_OS_INTFS_FILES :=	os_dep/osdep_service.o \
+			os_dep/linux/os_intfs.o \
+			os_dep/linux/usb_intf.o \
+			os_dep/linux/ioctl_linux.o \
+			os_dep/linux/xmit_linux.o \
+			os_dep/linux/mlme_linux.o \
+			os_dep/linux/recv_linux.o \
+
+
+_HAL_INTFS_FILES :=	hal/hal_init.o \
+                        hal/rtl8192c_d_hal_init.o \
+			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
+			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
+			hal/$(RTL871X)/$(RTL871X)_dm.o \
+			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
+			hal/$(RTL871X)/usb/usb_ops_linux.o \
+			hal/$(RTL871X)/usb/usb_halinit.o \
+			hal/$(RTL871X)/usb/Hal8192CUHWImg.o \
+			hal/$(RTL871X)/usb/rtl$(MODULE_NAME)_xmit.o \
+			hal/$(RTL871X)/usb/rtl$(MODULE_NAME)_recv.o \
+			hal/$(RTL871X)/usb/$(RTL871X)_cmd.o \
+		
+endif
+
+
+ifneq ($(KERNELRELEASE),)
+
+
+rtk_core :=	core/rtw_cmd.o \
+		core/rtw_security.o \
+		core/rtw_debug.o \
+		core/rtw_io.o \
+		core/rtw_ioctl_query.o \
+		core/rtw_ioctl_set.o \
+		core/ieee80211.o \
+		core/rtw_mlme.o \
+		core/rtw_mlme_ext.o \
+		core/rtw_wlan_util.o \
+		core/rtw_pwrctrl.o \
+		core/rtw_rf.o \
+		core/rtw_recv.o \
+		core/rtw_sta_mgt.o \
+		core/rtw_xmit.o \
+
+
+$(MODULE_NAME)-y += $(rtk_core)							
+								
+$(MODULE_NAME)-y += core/efuse/rtl8712_efuse.o
+
+$(MODULE_NAME)-y += core/led/$(RTL871X)_led.o
+
+$(MODULE_NAME)-y += $(_HAL_INTFS_FILES)
+
+$(MODULE_NAME)-y += $(_OS_INTFS_FILES)
+
+
+$(MODULE_NAME)-$(CONFIG_MP_INCLUDED) += mp/rtl871x_mp.o \
+					mp/rtl871x_mp_ioctl.o \
+					ioctl/rtl871x_ioctl_rtl.o
+
+obj-$(CONFIG_RTL8192CU) := $(MODULE_NAME).o
+
+
+else
+
+export CONFIG_RTL8192CU = m
+
+all: modules
+
+modules:
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KSRC) M=$(shell pwd)  modules
+
+install:
+	install -p -m 644 $(MODULE_NAME).ko  $(MODDESTDIR)
+	/sbin/depmod -a ${KVER}
+
+uninstall:
+	rm -f $(MODDESTDIR)/$(MODULE_NAME).ko
+	/sbin/depmod -a ${KVER}
+	
+	
+config_r:
+	@echo "make config"
+	/bin/bash script/Configure script/config.in
+	
+.PHONY: modules clean
+
+clean:
+	rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~
+	rm .tmp_versions -fr ; rm Module.symvers -fr
+	rm -fr Module.markers ; rm -fr modules.order
+	cd core/efuse ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
+	cd core/led ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd core ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd hal/$(RTL871X)/usb ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd hal/$(RTL871X)/pcie ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd hal/$(RTL871X) ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd os_dep/linux ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd os_dep ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+
+endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/ioctl_linux.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/ioctl_linux.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/ioctl_linux.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/ioctl_linux.c	2011-04-26 15:17:59.000000000 +0800
@@ -0,0 +1,6340 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define  _RTL871X_IOCTL_LINUX_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+#include <rtw_debug.h>
+#include <wifi.h>
+#include <rtw_mlme.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_set.h>
+#include <rtw_ioctl_query.h>
+//#ifdef CONFIG_MP_INCLUDED
+#include <rtw_mp_ioctl.h>
+//#endif
+#include <usb_ops.h>
+#include <linux/wireless.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+#include <rtw_version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#define  iwe_stream_add_event(a, b, c, d, e)  iwe_stream_add_event(b, c, d, e)
+#define  iwe_stream_add_point(a, b, c, d, e)  iwe_stream_add_point(b, c, d, e)
+#endif
+
+
+#define RTL_IOCTL_WPA_SUPPLICANT	SIOCIWFIRSTPRIV+30
+
+#define SCAN_ITEM_SIZE 768
+#define MAX_CUSTOM_LEN 64
+#define RATE_COUNT 4
+
+
+u32 rtw_rates[] = {1000000,2000000,5500000,11000000,
+	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
+
+static const long ieee80211_wlan_frequencies[] = {  
+	2412, 2417, 2422, 2427, 
+	2432, 2437, 2442, 2447, 
+	2452, 2457, 2462, 2467, 
+	2472, 2484  
+};
+
+static const char * const iw_operation_mode[] = 
+{ 
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary", "Monitor" 
+};
+
+
+//prototype declare
+static int rtw_wx_get_rate(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra);
+
+static int hex2num_i(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return -1;
+}
+
+static int hex2byte_i(const char *hex)
+{
+	int a, b;
+	a = hex2num_i(*hex++);
+	if (a < 0)
+		return -1;
+	b = hex2num_i(*hex++);
+	if (b < 0)
+		return -1;
+	return (a << 4) | b;
+}
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton_i(const char *txt, u8 *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int a, b;
+
+		a = hex2num_i(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex2num_i(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+static void request_wps_pbc_event(_adapter *padapter)
+{
+	u8 *buff, *p;
+	union iwreq_data wrqu;
+
+
+	buff = _rtw_zmalloc(IW_CUSTOM_MAX);
+	if(!buff)
+		return;
+		
+	//_rtw_memset(buff, 0, IW_CUSTOM_MAX);
+		
+	p=buff;
+		
+	p+=sprintf(p, "WPS_PBC_START.request=TRUE");
+		
+	_rtw_memset(&wrqu,0,sizeof(wrqu));
+		
+	wrqu.data.length = p-buff;
+		
+	wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+
+	printk("%s\n", __FUNCTION__);
+		
+	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
+
+	if(buff)
+	{
+		_rtw_mfree(buff, IW_CUSTOM_MAX);
+	}
+
+}
+
+
+void rtw_indicate_wx_assoc_event(_adapter *padapter)
+{	
+	union iwreq_data wrqu;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;	
+	
+	_rtw_memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
+
+	printk("+rtw_indicate_wx_assoc_event\n");
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+void rtw_indicate_wx_disassoc_event(_adapter *padapter)
+{	
+	union iwreq_data wrqu;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	_rtw_memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+	
+	//printk("+rtw_indicate_wx_disassoc_event\n");
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+/*
+uint	rtw_is_cckrates_included(u8 *rate)
+{	
+		u32	i = 0;			
+
+		while(rate[i]!=0)
+		{		
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||		
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )		
+			return _TRUE;	
+			i++;
+		}
+		
+		return _FALSE;
+}
+
+uint	rtw_is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while(rate[i]!=0)
+	{
+			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+			return _FALSE;		
+			i++;
+	}
+	
+	return _TRUE;
+}
+*/
+
+inline static char *translate_scan(_adapter *padapter, 
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop  )
+{
+	struct iw_event iwe;
+	u16 cap;
+	u32 ht_ielen = 0;
+	char custom[MAX_CUSTOM_LEN];
+	char *p;
+	u16 max_rate=0, rate, ht_cap=_FALSE;
+	u32 i = 0;	
+	char	*current_val;
+	long rssi;	
+	u8 bw_40MHz=0, short_GI=0;
+	u16 mcs_rate=0;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+
+	/*  AP MAC address  */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+
+	_rtw_memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+
+
+	/* Add the ESSID */
+#ifdef CONFIG_PLATFORM_ANDROID	
+	if(rtw_validate_ssid(&(pnetwork->network.Ssid))==_FALSE)
+	{		
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("translate_scan : rtw_validate_ssid==FALSE \n"));
+	}	
+	else
+#endif
+	{		
+		/* Add the ESSID */
+		iwe.cmd = SIOCGIWESSID;
+		iwe.u.data.flags = 1;	
+		iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+		start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+	}
+
+
+	
+	//parsing HT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
+	if(p && ht_ielen>0)
+	{
+		struct ieee80211_ht_cap *pht_capie;
+		ht_cap = _TRUE;			
+		pht_capie = (struct ieee80211_ht_cap *)(p+2);		
+		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+			
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+	}
+
+	/* Add the protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)		
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	}	
+	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)	
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	}	
+	else
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+	else
+		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+	}	
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+
+	  /* Add mode */
+        iwe.cmd = SIOCGIWMODE;
+	_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+
+	cap = le16_to_cpu(cap);
+
+	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe.u.mode = IW_MODE_MASTER;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
+	}
+
+	if(pnetwork->network.Configuration.DSConfig<1 || pnetwork->network.Configuration.DSConfig>14)
+		pnetwork->network.Configuration.DSConfig = 1;
+
+	 /* Add frequency/channel */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = ieee80211_wlan_frequencies[pnetwork->network.Configuration.DSConfig-1] * 100000;
+	iwe.u.freq.e = 1;
+	iwe.u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+	
+	/*Add basic and extended rates */
+	max_rate = 0;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	while(pnetwork->network.SupportedRates[i]!=0)
+	{
+		rate = pnetwork->network.SupportedRates[i]&0x7F; 
+		if (rate > max_rate)
+			max_rate = rate;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		i++;
+	}
+	
+	if(ht_cap == _TRUE)
+	{
+		if(mcs_rate&0x8000)//MCS15
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+			
+		}
+		else if(mcs_rate&0x0080)//MCS7
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+		else//default MCS7
+		{
+			printk("wx_get_scan, mcs_rate_bitmap=0x%x\n", mcs_rate);
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+
+		max_rate = max_rate*2;//Mbps/2;		
+	}
+
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = max_rate * 500000;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);
+	
+         //parsing WPA/WPA2 IE
+	{
+		u8 buf[MAX_WPA_IE_LEN];
+		u8 wpa_ie[255],rsn_ie[255];
+		u16 wpa_len=0,rsn_len=0;
+		u8 *p;
+		sint out_len=0;
+		out_len=rtw_get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,rsn_ie,&rsn_len,wpa_ie,&wpa_len);
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wpa_len=%d rsn_len=%d\n",wpa_len,rsn_len));
+
+		if (wpa_len > 0)
+		{
+			p=buf;
+			_rtw_memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "wpa_ie=");
+			for (i = 0; i < wpa_len; i++) {
+				p += sprintf(p, "%02x", wpa_ie[i]);
+			}
+	
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
+			
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd =IWEVGENIE;
+			iwe.u.data.length = wpa_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);			
+		}
+		if (rsn_len > 0)
+		{
+			p = buf;
+			_rtw_memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "rsn_ie=");
+			for (i = 0; i < rsn_len; i++) {
+				p += sprintf(p, "%02x", rsn_ie[i]);
+			}
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
+		
+			_rtw_memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd =IWEVGENIE;
+			iwe.u.data.length = rsn_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);		
+		}
+	}
+
+	 {//parsing WPS IE
+		u8 wps_ie[512];
+		uint wps_ielen;
+
+		if(rtw_get_wps_ie(pnetwork->network.IEs, pnetwork->network.IELength, wps_ie, &wps_ielen)==_TRUE)
+		{
+			if(wps_ielen>2)
+			{				
+				iwe.cmd =IWEVGENIE;
+				iwe.u.data.length = (u16)wps_ielen;
+				start = iwe_stream_add_point(info, start, stop, &iwe, wps_ie);
+			}	
+		}
+	}
+
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	rssi = pnetwork->network.Rssi;//dBM
+	
+#ifdef CONFIG_RTL8711	
+	rssi = (rssi*2) + 190;
+	if(rssi>100) rssi = 100;
+	if(rssi<0) rssi = 0;
+#endif	
+	
+	//printk("RSSI=0x%X%%\n", rssi);
+
+	// we only update signal_level (signal strength) that is rssi.
+	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID
+	#ifdef CONFIG_PLATFORM_ANDROID
+		| IW_QUAL_DBM
+	#endif
+	;
+	
+	#ifdef CONFIG_PLATFORM_ANDROID
+	iwe.u.qual.level = (u8)pnetwork->network.Rssi;//dbm
+	#else
+	iwe.u.qual.level = (u8)pnetwork->network.PhyInfo.SignalStrength;//%
+	#endif
+
+	iwe.u.qual.qual = (u8)pnetwork->network.PhyInfo.SignalStrength;   // signal quality
+	iwe.u.qual.noise = 0; // noise level
+	
+	//printk("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+		
+	return start;	
+}
+
+static int wpa_set_auth_algs(struct net_device *dev, u32 value)
+{	
+	_adapter *padapter = netdev_priv(dev);
+	int ret = 0;
+
+	if ((value & AUTH_ALG_SHARED_KEY)&&(value & AUTH_ALG_OPEN_SYSTEM))
+	{
+		printk("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY and  AUTH_ALG_OPEN_SYSTEM [value:0x%x]\n",value);
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+	} 
+	else if (value & AUTH_ALG_SHARED_KEY)
+	{
+		printk("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY  [value:0x%x]\n",value);
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+#endif
+	} 
+	else if(value & AUTH_ALG_OPEN_SYSTEM)
+	{
+		printk("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n");
+		//padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		if(padapter->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK)
+		{
+#ifdef CONFIG_PLATFORM_MT53XX
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+ 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+#endif
+		}
+		
+	}
+	else if(value & AUTH_ALG_LEAP)
+	{
+		printk("wpa_set_auth_algs, AUTH_ALG_LEAP\n");
+	}
+	else
+	{
+		printk("wpa_set_auth_algs, error!\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+	
+}
+
+static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len;
+	NDIS_802_11_WEP	 *pwep = NULL;	
+	_adapter *padapter = netdev_priv(dev);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;		
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+_func_enter_;
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+	
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		if (param->u.crypt.idx >= WEP_KEYS)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("wpa_set_encryption, crypt.alg = WEP\n"));
+		printk("wpa_set_encryption, crypt.alg = WEP\n");
+		
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;	
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+			
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(1)wep_key_idx=%d\n", wep_key_idx));
+		printk("(1)wep_key_idx=%d\n", wep_key_idx);
+
+		if (wep_key_idx > WEP_KEYS)
+			return -EINVAL;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(2)wep_key_idx=%d\n", wep_key_idx));
+
+		if (wep_key_len > 0) 
+		{			
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+
+		 	pwep =(NDIS_802_11_WEP	 *) _rtw_zmalloc(wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial));
+			if(pwep == NULL){
+				RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,(" wpa_set_encryption: pwep allocate fail !!!\n"));
+				goto exit;
+			}
+			
+		 	//_rtw_memset(pwep, 0, sizeof(NDIS_802_11_WEP));
+		
+		 	pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+
+			if(wep_key_len==13)
+			{
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			}			
+		}
+		else {		
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000; 
+
+		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+	
+		if(param->u.crypt.set_tx)
+		{
+			printk("wep, set_tx=1\n");
+			
+		if(rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+			{
+				ret = -EOPNOTSUPP ;
+			}	
+		}
+		else
+		{
+			printk("wep, set_tx=0\n");
+			
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
+			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to fw/cam
+			
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP ;
+				goto exit;
+			}				
+			
+		      _rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;	
+			rtw_set_key(padapter, psecuritypriv, wep_key_idx);			
+		}
+
+		goto exit;		
+	}
+
+	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	{
+		struct sta_info * psta,*pbcmc_sta;
+		struct sta_priv * pstapriv = &padapter->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
+		{
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));				
+			if (psta == NULL) {
+				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
+			}
+			else
+			{
+				psta->ieee8021x_blocked = _FALSE;
+				
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{
+					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}		
+
+				if(param->u.crypt.set_tx ==1)//pairwise key
+				{ 
+					_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					{						
+						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						padapter->securitypriv.busetkipkey=_FALSE;
+						_set_timer(&padapter->securitypriv.tkip_timer, 50);						
+					}
+
+					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
+					//DEBUG_ERR(("\n ~~~~stastakey:unicastkey\n"));
+					
+					rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
+				}
+				else//group key
+				{ 					
+					_rtw_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx-1].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey.skey,&(param->u.crypt.key[16]),8);
+					_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey.skey,&(param->u.crypt.key[24]),8);
+                                        padapter->securitypriv.binstallGrpkey = _TRUE;	
+					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
+					//DEBUG_ERR(("\n ~~~~stastakey:groupkey\n"));
+					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
+					rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx);
+				}						
+			}
+
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if(pbcmc_sta==NULL)
+			{
+				//DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n"));
+			}
+			else
+			{
+				pbcmc_sta->ieee8021x_blocked = _FALSE;
+				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
+				{							
+					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}					
+			}				
+		}
+		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		{		
+		}			
+	}
+
+exit:
+	
+	if (pwep) {
+		_rtw_mfree((u8 *)pwep, wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial));		
+	}	
+	
+	_func_exit_;
+	
+	return ret;	
+}
+
+static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
+{
+	u8 *buf=NULL, *pos=NULL;	
+	u32 left; 	
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;	
+
+	if((ielen > MAX_WPA_IE_LEN) || (pie == NULL)){
+		padapter->securitypriv.wps_phase = _FALSE;	
+		if(pie == NULL)	
+			return ret;
+		else
+			return -EINVAL;
+	}
+
+	if(ielen)
+	{		
+		buf = _rtw_malloc(ielen);
+		if (buf == NULL){
+			ret =  -ENOMEM;
+			goto exit;
+		}
+	
+		_rtw_memcpy(buf, pie , ielen);
+
+		//dump
+		{
+			int i;
+			printk("\n wpa_ie(length:%d):\n", ielen);
+			for(i=0;i<ielen;i=i+8)
+				printk("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
+		}
+	
+		pos = buf;
+		if(ielen < RSN_HEADER_LEN){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
+			ret  = -1;
+			goto exit;
+		}
+
+#if 0
+		pos += RSN_HEADER_LEN;
+		left  = ielen - RSN_HEADER_LEN;
+		
+		if (left >= RSN_SELECTOR_LEN){
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}		
+		else if (left > 0){
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie length mismatch, %u too much \n", left));
+			ret =-1;
+			goto exit;
+		}
+#endif		
+		
+		if(rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
+		}
+	
+		if(rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;		
+		}
+			
+		switch(group_cipher)
+		{			
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:	
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+
+		switch(pairwise_cipher)
+		{		
+			case WPA_CIPHER_NONE:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+				padapter->securitypriv.ndisencryptstatus=Ndis802_11EncryptionDisabled;
+				break;
+			case WPA_CIPHER_WEP40:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+			case WPA_CIPHER_TKIP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_TKIP_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case WPA_CIPHER_CCMP:
+				padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+			case WPA_CIPHER_WEP104:	
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+				break;
+		}
+		
+		padapter->securitypriv.wps_phase = _FALSE;			
+		{//set wps_ie	
+			u16 cnt = 0;	
+			u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+			 
+			while( cnt < ielen )
+			{
+				eid = buf[cnt];
+		
+				if((eid==_VENDOR_SPECIFIC_IE_)&&(_rtw_memcmp(&buf[cnt+2], wps_oui, 4)==_TRUE))
+				{
+					printk("SET WPS_IE\n");
+
+					padapter->securitypriv.wps_ie_len = ( (buf[cnt+1]+2) < (MAX_WPA_IE_LEN<<2)) ? (buf[cnt+1]+2):(MAX_WPA_IE_LEN<<2);
+					
+					_rtw_memcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);
+					
+					padapter->securitypriv.wps_phase = _TRUE;					
+
+					printk("SET WPS_IE, wps_phase==_TRUE\n");
+
+					cnt += buf[cnt+1]+2;
+					
+					break;
+				} else {
+					cnt += buf[cnt+1]+2; //goto next	
+				}				
+			}			
+		}		
+	}
+	
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_set_wpa_ie: pairwise_cipher=0x%08x padapter->securitypriv.ndisencryptstatus=%d padapter->securitypriv.ndisauthtype=%d\n",
+		  pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
+ 	
+exit:
+
+	if (buf) _rtw_mfree(buf, ielen);
+	
+	return ret;	
+}
+
+static int rtw_wx_get_name(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	u16 cap;
+	u32 ht_ielen = 0;
+	char *p;
+	u8 ht_cap=_FALSE;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+	NDIS_802_11_RATES_EX* prates = NULL;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("cmd_code=%x\n", info->cmd));
+	
+	_func_enter_;	
+ 
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+			//parsing HT_CAP_IE
+			p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+			if(p && ht_ielen>0)
+			{
+				ht_cap = _TRUE;	
+			}
+			
+			prates = &pcur_bss->SupportedRates;
+        
+		if (rtw_is_cckratesonly_included((u8*)prates) == _TRUE)
+		{				
+			if(ht_cap == _TRUE)			
+			    snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
+			else
+		            snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");				
+		}
+	        else if ((rtw_is_cckrates_included((u8*)prates)) == _TRUE)	
+		{	
+			if(ht_cap == _TRUE)
+			    snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
+			else
+		            snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");				
+		}	
+		else
+		{
+				if(ht_cap == _TRUE)
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
+				else
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+		}		
+	}		
+	else
+	{
+			//prates = &padapter->registrypriv.dev_network.SupportedRates;
+			//snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+			snprintf(wrqu->name, IFNAMSIZ, "unassociated");
+	}		
+		
+	_func_exit_;
+	
+	return 0;	
+}
+
+static int rtw_wx_set_freq(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{	
+	_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));
+
+	_func_exit_;
+	
+	return 0;
+}
+
+static int rtw_wx_get_freq(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+ 
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	{
+		wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1] * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
+
+	}
+	else return -1;
+
+	return 0;
+}
+
+static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
+	int ret = 0;
+	
+	_func_enter_;
+	
+	switch(wrqu->mode)
+	{
+		case IW_MODE_AUTO:
+			networkType = Ndis802_11AutoUnknown;
+			printk("set_mode = IW_MODE_AUTO\n");	
+			break;				
+		case IW_MODE_ADHOC:		
+			networkType = Ndis802_11IBSS;
+			printk("set_mode = IW_MODE_ADHOC\n");			
+			break;
+		case IW_MODE_MASTER:		
+			networkType = Ndis802_11APMode;
+			printk("set_mode = IW_MODE_MASTER\n");
+                        //rtw_setopmode_cmd(padapter, networkType);	
+			break;				
+		case IW_MODE_INFRA:
+			networkType = Ndis802_11Infrastructure;
+			printk("set_mode = IW_MODE_INFRA\n");			
+			break;
+	
+		default :
+			ret = -EINVAL;;
+			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("\n Mode: %s is not supported  \n", iw_operation_mode[wrqu->mode]));
+			goto exit;
+	}
+	
+/*	
+	if(Ndis802_11APMode == networkType)
+	{
+		rtw_setopmode_cmd(padapter, networkType);
+	}	
+	else
+	{
+		rtw_setopmode_cmd(padapter, Ndis802_11AutoUnknown);	
+	}
+*/
+	
+       if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==_FALSE){
+
+		ret = -1;
+		goto exit;
+
+	 }	
+	
+	 rtw_setopmode_cmd(padapter, networkType);
+	
+exit:
+	
+	_func_exit_;
+	
+	return ret;
+	
+}
+
+static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_get_mode \n"));
+
+	_func_enter_;
+ 
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	{
+		wrqu->mode = IW_MODE_INFRA;
+	}
+	else if  ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+		
+	{
+		wrqu->mode = IW_MODE_ADHOC;
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	{
+		wrqu->mode = IW_MODE_MASTER;
+	}
+	else
+	{
+		wrqu->mode = IW_MODE_AUTO;
+	}
+
+	_func_exit_;
+	
+	return 0;
+	
+}
+
+
+static int rtw_wx_set_pmkid(struct net_device *dev,
+	                     struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+
+	_adapter    *padapter = (_adapter *)netdev_priv(dev);
+	u8          j,blInserted = _FALSE;
+	int         intReturn = _FALSE;
+	struct mlme_priv  *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+        struct iw_pmksa*  pPMK = ( struct iw_pmksa* ) extra;
+        u8     strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
+        u8     strIssueBssid[ ETH_ALEN ] = { 0x00 };
+        
+/*
+        struct iw_pmksa
+        {
+            __u32   cmd;
+            struct sockaddr bssid;
+            __u8    pmkid[IW_PMKID_LEN];   //IW_PMKID_LEN=16
+        }
+        There are the BSSID information in the bssid.sa_data array.
+        If cmd is IW_PMKSA_FLUSH, it means the wpa_suppplicant wants to clear all the PMKID information.
+        If cmd is IW_PMKSA_ADD, it means the wpa_supplicant wants to add a PMKID/BSSID to driver.
+        If cmd is IW_PMKSA_REMOVE, it means the wpa_supplicant wants to remove a PMKID/BSSID from driver.
+        */
+
+	_rtw_memcpy( strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
+        if ( pPMK->cmd == IW_PMKSA_ADD )
+        {
+                printk( "[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n" );
+                if ( _rtw_memcmp( strIssueBssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
+                {
+                    return( intReturn );
+                }
+                else
+                {
+                    intReturn = _TRUE;
+                }
+		blInserted = _FALSE;
+		
+		//overwrite PMKID
+		for(j=0 ; j<NUM_PMKID_CACHE; j++)
+		{
+			if( _rtw_memcmp( psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE )
+			{ // BSSID is matched, the same AP => rewrite with new PMKID.
+                                
+                                printk( "[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n" );
+
+				_rtw_memcpy( psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+                                psecuritypriv->PMKIDList[ j ].bUsed = _TRUE;
+				psecuritypriv->PMKIDIndex = j+1;
+				blInserted = _TRUE;
+				break;
+			}	
+	        }
+
+	        if(!blInserted)
+                {
+		    // Find a new entry
+                    printk( "[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
+                            psecuritypriv->PMKIDIndex );
+
+	            _rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+		    _rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+
+                    psecuritypriv->PMKIDList[ psecuritypriv->PMKIDIndex ].bUsed = _TRUE;
+		    psecuritypriv->PMKIDIndex++ ;
+		    if(psecuritypriv->PMKIDIndex==16)
+                    {
+		        psecuritypriv->PMKIDIndex =0;
+                    }
+		}
+        }
+        else if ( pPMK->cmd == IW_PMKSA_REMOVE )
+        {
+                printk( "[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n" );
+                intReturn = _TRUE;
+		for(j=0 ; j<NUM_PMKID_CACHE; j++)
+		{
+			if( _rtw_memcmp( psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE )
+			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it. 
+                                _rtw_memset( psecuritypriv->PMKIDList[ j ].Bssid, 0x00, ETH_ALEN );
+                                psecuritypriv->PMKIDList[ j ].bUsed = _FALSE;
+				break;
+			}	
+	        }
+        }
+        else if ( pPMK->cmd == IW_PMKSA_FLUSH ) 
+        {
+            printk( "[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n" );
+            _rtw_memset( &psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+            psecuritypriv->PMKIDIndex = 0;
+            intReturn = _TRUE;
+        }
+    return( intReturn );
+}
+
+static int rtw_wx_get_sens(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = netdev_priv(dev);
+	
+	wrqu->sens.value = 0;
+	wrqu->sens.fixed = 0;	/* no auto select */
+	wrqu->sens.disabled = 1;
+	
+	return 0;
+
+}
+
+static int rtw_wx_get_range(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	u16 val;
+	int i;
+	
+	_func_enter_;
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_range. cmd_code=%x\n", info->cmd));
+
+	wrqu->data.length = sizeof(*range);
+	_rtw_memset(range, 0, sizeof(*range));
+
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+	
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;     
+
+	// TODO: Not used in 802.11b?
+//	range->min_nwid;	/* Minimal NWID we are able to set */
+	// TODO: Not used in 802.11b?
+//	range->max_nwid;	/* Maximal NWID we are able to set */
+	
+        /* Old Frequency (backward compat - moved lower ) */
+//	range->old_num_channels; 
+//	range->old_num_frequency;
+//	range->old_freq[6]; /* Filler to keep "version" at the same offset */
+
+	// TODO: 8711 sensitivity ?
+	/* signal level threshold range */
+
+#ifdef CONFIG_RTL8711	
+	range->max_qual.qual = 100;
+	/* TODO: Find real max RSSI and stick here */
+	range->max_qual.level = 0;
+	range->max_qual.noise = -98;
+	range->max_qual.updated = 7; /* Updated all three */
+#endif
+
+
+#if defined(CONFIG_RTL8712) || defined(CONFIG_RTL8192C)
+	//percent values between 0 and 100.
+	range->max_qual.qual = 100;	
+	range->max_qual.level = 100;
+	range->max_qual.noise = 100;
+	range->max_qual.updated = 7; /* Updated all three */
+#endif
+
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 20 + -98;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+
+	range->num_bitrates = RATE_COUNT;
+	
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
+		range->bitrate[i] = rtw_rates[i];
+	}
+	
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+	
+	range->pm_capa = 0;
+
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+//	range->retry_capa;	/* What retry options are supported */
+//	range->retry_flags;	/* How to decode max/min retry limit */
+//	range->r_time_flags;	/* How to decode max/min retry life */
+//	range->min_retry;	/* Minimal number of retries */
+//	range->max_retry;	/* Maximal number of retries */
+//	range->min_r_time;	/* Minimal retry lifetime */
+//	range->max_r_time;	/* Maximal retry lifetime */
+
+        range->num_channels = pmlmeext->max_chan_nums;
+
+	for (i = 0, val = 0; i < range->num_channels; i++) {
+		
+		// Include only legal frequencies for some countries
+		//if ((priv->challow)[i+1]) {
+		        range->freq[val].i = i + 1;
+			range->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;
+			range->freq[val].e = 1;
+			val++;
+		//} else {
+			// FIXME: do we need to set anything for channels
+			// we don't use ?
+		//}
+		
+		if (val == IW_MAX_FREQUENCIES)
+		break;
+	}
+
+	range->num_frequency = val;
+
+// Commented by Albert 2009/10/13
+// The following code will proivde the security capability to network manager.
+// If the driver doesn't provide this capability to network manager,
+// the WPA/WPA2 routers can't be choosen in the network manager.
+
+/*
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+*/
+
+#if WIRELESS_EXT > 17
+	range->enc_capa = IW_ENC_CAPA_WPA|IW_ENC_CAPA_WPA2|
+			  IW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;
+#endif
+
+#ifdef IW_SCAN_CAPA_ESSID //WIRELESS_EXT > 21
+	range->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE |IW_SCAN_CAPA_BSSID|
+					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
+#endif
+
+
+	_func_exit_;
+	
+	return 0;
+	
+}
+
+static int rtw_wx_set_priv(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *awrq,
+				char *extra)
+{
+
+#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	char *ext_dbg;
+#endif
+
+	int ret = 0;
+#ifdef CONFIG_PLATFORM_ANDROID
+	int len = 0;
+	char *ext;
+
+	_adapter *padapter = netdev_priv(dev);
+	struct iw_point *dwrq = (struct iw_point*)awrq;
+	
+	//RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+rtw_wx_set_priv\n"));
+
+	len = dwrq->length;
+	if (!(ext = _rtw_malloc(len)))
+		return -ENOMEM;
+
+	if (copy_from_user(ext, dwrq->pointer, len)) {
+		_rtw_mfree(ext, len);
+		return -EFAULT;
+	}
+
+	//RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+	//	 ("rtw_wx_set_priv: %s req=%s\n",
+	//	  dev->name, ext));
+
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV	
+	if (!(ext_dbg = _rtw_malloc(len)))
+	{
+		_rtw_mfree(ext, len);
+		return -ENOMEM;
+	}	
+	
+	_rtw_memcpy(ext_dbg, ext, len);
+	#endif
+
+	//DBG_871X("rtw_wx_set_priv: %s req=%s\n", dev->name, ext);
+
+	if(0 == strcasecmp(ext,"START")){
+		//Turn on Wi-Fi hardware
+		//OK if successful
+		ret=-1;
+		//sprintf(ext, "OK");
+		goto FREE_EXT;
+		
+	}else if(0 == strcasecmp(ext,"STOP")){
+		//Turn off Wi-Fi hardwoare
+		//OK if successful
+		ret=-1;
+		//sprintf(ext, "OK");
+		goto FREE_EXT;
+		
+	}else if(0 == strcasecmp(ext,"RSSI")){
+		//Return received signal strength indicator in -db for current AP
+		//<ssid> Rssi xx 
+		struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+		struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+
+		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+			sprintf(ext, "%s rssi %d",
+				pcur_network->network.Ssid.Ssid,
+				padapter->recvpriv.rssi);
+				
+		} else {
+			sprintf(ext, "OK");
+		}
+		
+	}else if(0 == strcasecmp(ext,"LINKSPEED")){
+		//Return link speed in MBPS
+		//LinkSpeed xx 
+		union iwreq_data wrqd;
+		int ret_inner;
+		int mbps;
+		
+		if( 0!=(ret_inner=rtw_wx_get_rate(dev, info, &wrqd, extra)) ){
+			//DBG_8192C("rtw_wx_set_priv: (SIOCSIWPRIV) %s req=%s rtw_wx_get_rate return %d\n", 
+			//dev->name, ext, ret);
+			//goto FREE_EXT;
+			mbps=0;
+		} else {
+			mbps=wrqd.bitrate.value / 1000000;
+		}
+		
+		sprintf(ext, "LINKSPEED %d", mbps);
+		
+		
+	}else if(0 == strcasecmp(ext,"MACADDR")){
+		//Return mac address of the station
+		//Macaddr = xx.xx.xx.xx.xx.xx 
+		sprintf(ext,
+			"MACADDR = %02x.%02x.%02x.%02x.%02x.%02x",
+			*(dev->dev_addr),*(dev->dev_addr+1),*(dev->dev_addr+2),
+			*(dev->dev_addr+3),*(dev->dev_addr+4),*(dev->dev_addr+5));
+
+	}else if(0 == strcasecmp(ext,"SCAN-ACTIVE")){
+		//Set scan type to active
+		//OK if successful
+		struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+		pmlmepriv->scan_mode=SCAN_ACTIVE;
+		sprintf(ext, "OK");
+		
+	}else if(0 == strcasecmp(ext,"SCAN-PASSIVE")){
+		//Set scan type to passive
+		//OK if successfu
+		struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+		pmlmepriv->scan_mode=SCAN_PASSIVE;
+		sprintf(ext, "OK");
+		
+	}else{
+		#ifdef  CONFIG_DEBUG_RTW_WX_SET_PRIV
+		DBG_8192C("rtw_wx_set_priv: %s unknowned req=%s\n", 
+		dev->name, ext_dbg);
+		#endif
+		goto FREE_EXT;
+		
+	}
+
+	if (copy_to_user(dwrq->pointer, ext, min(dwrq->length, (u16)(strlen(ext)+1)) ) )
+		ret = -EFAULT;
+
+	//#if 1
+	//DBG_8192C("rtw_wx_set_priv: %s rep=%s :strlen(ext):%d\n", 
+	//	dev->name, ext ,strlen(ext));
+	//#endif
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	DBG_8192C("rtw_wx_set_priv: %s req=%s rep=%s\n", 
+	dev->name, ext_dbg ,ext);
+	#endif
+
+FREE_EXT:
+
+	_rtw_mfree(ext, len);
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	_rtw_mfree(ext_dbg, len);
+	#endif
+
+	//DBG_8192C("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n", 
+	//		dev->name, ret);
+#endif
+	return ret;
+	
+}
+
+//set bssid flow
+//s1. rtw_set_802_11_infrastructure_mode()
+//s2. rtw_set_802_11_authentication_mode()
+//s3. set_802_11_encryption_mode()
+//s4. rtw_set_802_11_bssid()
+static int rtw_wx_set_wap(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *awrq,
+			 char *extra)
+{
+	uint ret = 0;
+	_adapter *padapter = netdev_priv(dev);
+	struct sockaddr *temp = (struct sockaddr *)awrq;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	_list	*phead;
+	u8 *dst_bssid, *src_bssid;
+	_queue	*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE	authmode;
+
+	_func_enter_;
+ 
+	if(!padapter->bup){
+		ret = -1;
+		goto exit;
+	}
+
+	
+	if (temp->sa_family != ARPHRD_ETHER){
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	authmode = padapter->securitypriv.ndisauthtype;
+
+       phead = get_list_head(queue);
+       pmlmepriv->pscanned = get_next(phead);
+
+	while (1)
+	 {
+			
+		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == _TRUE)
+		{
+#if 0		
+			ret = -EINVAL;
+			goto exit;
+
+			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+			{
+	            		rtw_set_802_11_bssid(padapter, temp->sa_data);
+	    			goto exit;                    
+			}
+			else
+			{
+				ret = -EINVAL;
+				goto exit;
+			}
+#endif
+
+			if (rtw_set_802_11_bssid(padapter, temp->sa_data) == _FALSE)
+				ret = -1;
+
+	    		goto exit;   			
+		}
+	
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+		dst_bssid = pnetwork->network.MacAddress;
+
+		src_bssid = temp->sa_data;
+
+		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE)
+		{			
+			if(!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode))
+			{
+				ret = -1;
+				goto exit;
+			}
+
+				break;			
+		}
+
+	}		
+
+	rtw_set_802_11_authentication_mode(padapter, authmode);
+
+	//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+	
+	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == _FALSE) {
+		ret = -1;
+		goto exit;		
+	}	
+	
+exit:
+	
+	_func_exit_;
+	
+	return ret;	
+}
+
+static int rtw_wx_get_wap(struct net_device *dev, 
+			    struct iw_request_info *info, 
+			    union iwreq_data *wrqu, char *extra)
+{
+
+	_adapter *padapter = (_adapter *)netdev_priv(dev);	
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;	
+	
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+	
+	_rtw_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_wap\n"));
+
+	_func_enter_;
+ 
+	if  ( ((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE) || 
+			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == _TRUE) ||
+			((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == _TRUE) )
+	{
+
+		_rtw_memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
+	}
+	else
+	{
+	 	_rtw_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	}		
+
+	_func_exit_;
+	
+	return 0;
+	
+}
+
+static int rtw_wx_set_mlme(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+#if 0
+/* SIOCSIWMLME data */
+struct	iw_mlme
+{
+	__u16		cmd; /* IW_MLME_* */
+	__u16		reason_code;
+	struct sockaddr	addr;
+};
+#endif
+
+	int ret=0;
+	u16 reason;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+	
+
+	if(mlme==NULL)
+		return -1;
+ 
+	reason = cpu_to_le16(mlme->reason_code);
+
+	switch (mlme->cmd) 
+	{
+		case IW_MLME_DEAUTH:			
+				if(!rtw_set_802_11_disassociate(padapter))
+				ret = -1;						
+				break;
+				
+		case IW_MLME_DISASSOC:			
+				if(!rtw_set_802_11_disassociate(padapter))
+						ret = -1;		
+				
+				break;
+				
+		default:
+			return -EOPNOTSUPP;
+	}
+	
+	return ret;
+	
+}	
+
+int rfpwrstate_check(_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+		
+	if( pwrctrlpriv->power_mgnt == PS_MODE_ACTIVE )
+		return _TRUE;		
+	
+	if(rf_off == pwrpriv->current_rfpwrstate )
+	{		
+#if (DEV_BUS_TYPE==DEV_BUS_USB_INTERFACE)
+#ifdef CONFIG_AUTOSUSPEND
+		 if(pwrpriv->brfoffbyhw==_TRUE)
+		{
+			printk("hw still in rf_off state ...........\n");
+			return _FAIL;
+		}
+		else if(padapter->registrypriv.usbss_enable)
+		{
+			printk("\n rfpwrstate_check call autoresume_enter....\n");	
+			if(_FAIL ==  autoresume_enter(padapter))
+			{
+				printk("======> autoresume fail.............\n");
+				return _FAIL;			
+			}	
+		}
+		
+		else
+#endif
+#endif
+		{
+#ifdef CONFIG_IPS
+			printk("\n rfpwrstate_check call ips_leave....\n");				
+			if(_FAIL ==  ips_leave(padapter))
+			{
+				printk("======> ips_leave fail.............\n");
+				return _FAIL;			
+			}
+#endif
+		}
+			
+	}
+	return _SUCCESS;
+
+}
+
+static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	u8 _status;
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)netdev_priv(dev);		
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+
+	_irqL irqL;
+		
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_set_scan\n"));
+	
+	_func_enter_;	 	
+	_enter_critical_mutex(&padapter->silentreset_mutex, &irqL);
+
+	if(_FAIL == rfpwrstate_check(padapter))
+	{
+		ret= _FAIL;
+		goto exit;
+	}
+
+	if(padapter->bDriverStopped){
+           printk("rtw_wx_set_scan bDriverStopped=%d\n", padapter->bDriverStopped);
+		ret= -1;
+		goto exit;
+	}
+	
+	if(!padapter->bup){
+		printk("rtw_wx_set_scan padapter->bup=%d\n",padapter->bup);
+		ret = -1;
+		goto exit;
+	}
+	
+	if (padapter->hw_init_completed==_FALSE){
+		printk("rtw_wx_set_scan padapter->hw_init_completed=%d\n",padapter->hw_init_completed);
+		ret = -1;
+		goto exit;
+	}
+	
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) 
+	{
+		printk("%s exit cause fw state(%x) mismatch\n",__FUNCTION__,pmlmepriv->fw_state);
+		ret = 0;
+		goto exit;
+	}
+
+	if(pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE)
+	{
+		printk("%s exit cause traffic_busy(%x) RCR(0x%04x)\n",__FUNCTION__,pmlmepriv->sitesurveyctrl.traffic_busy,rtw_read16(padapter,REG_RCR));
+		ret = 0;
+		goto exit;
+	} 
+
+/*
+	if(pmlmepriv->scan_interval>10)
+		pmlmepriv->scan_interval = 0;
+
+	if(pmlmepriv->scan_interval > 0)
+	{
+		printk("scan done\n");
+		ret = 0;
+		goto exit;
+	}
+*/		
+
+#if WIRELESS_EXT >= 17
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) 
+	{
+		struct iw_scan_req *req = (struct iw_scan_req *)extra;
+	
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID)
+		{
+			NDIS_802_11_SSID ssid;
+			_irqL	irqL;			
+			int len = min((int)req->essid_len, IW_ESSID_MAX_SIZE);
+
+			_rtw_memset((unsigned char*)&ssid, 0, sizeof(NDIS_802_11_SSID));
+
+			_rtw_memcpy(ssid.Ssid, req->essid, len);
+			ssid.SsidLength = len;	
+
+			printk("IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
+		
+			_enter_critical_bh(&pmlmepriv->lock, &irqL);				
+		
+			_status = rtw_sitesurvey_cmd(padapter, &ssid);
+		
+			_exit_critical_bh(&pmlmepriv->lock, &irqL);
+			
+		}
+		else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
+		{
+			printk("rtw_wx_set_scan, req->scan_type == IW_SCAN_TYPE_PASSIVE\n");
+		}
+		
+	}
+	else
+#endif		
+	{
+	         _status = rtw_set_802_11_bssid_list_scan(padapter);
+	}
+	
+	if(_status == _FALSE)
+		ret = -1;
+	
+exit:		
+	_exit_critical_mutex(&padapter->silentreset_mutex, &irqL);
+	_func_exit_;
+	
+	return ret;	
+}
+
+static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	_irqL	irqL;
+	_list					*plist, *phead;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	_queue				*queue	= &(pmlmepriv->scanned_queue);	
+	struct	wlan_network	*pnetwork = NULL;
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+	u32 ret = 0;	
+	u32 cnt=0;
+	
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan\n"));
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
+
+	_func_enter_;
+ 	
+	 if(padapter->pwrctrlpriv.brfoffbyhw && padapter->bDriverStopped)	
+	 {		         
+		return -EINVAL;
+		
+	}		
+  
+  	//printk("==> %s \n",__FUNCTION__);
+  	// 20110214 Commented by Jeff: 
+  	// In rockchip 2818 platforms with low-speed IO, the UI will not show scan list bause of this busy waiting
+  	#ifndef CONFIG_PLATFORM_ANDROID
+ 	while((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == _TRUE)
+	{	
+		rtw_msleep_os(30);
+		cnt++;
+		if(cnt > 100)
+			break;
+	}
+	#endif
+	
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+		if((stop - ev) < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+                
+		ev=translate_scan(padapter, a, pnetwork, ev, stop);
+
+		plist = get_next(plist);
+	
+	}        
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+       wrqu->data.length = ev-extra;
+	wrqu->data.flags = 0;
+	
+exit:		
+	
+	_func_exit_;	
+	
+	return ret ;
+	
+}
+
+//set ssid flow
+//s1. rtw_set_802_11_infrastructure_mode()
+//s2. set_802_11_authenticaion_mode()
+//s3. set_802_11_encryption_mode()
+//s4. rtw_set_802_11_ssid()
+static int rtw_wx_set_essid(struct net_device *dev, 
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	_queue *queue = &pmlmepriv->scanned_queue;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	_list *phead;
+	s8 status = _TRUE;
+	struct wlan_network *pnetwork = NULL;
+
+	NDIS_802_11_AUTHENTICATION_MODE authmode;	
+	NDIS_802_11_SSID ndis_ssid;	
+	u8 *dst_ssid, *src_ssid;
+
+	uint ret = 0, len;
+
+	_func_enter_;
+ 	
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("+rtw_wx_set_essid: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
+
+	if(_FAIL == rfpwrstate_check(padapter))
+	{
+		return _FAIL;
+	}
+
+	if(!padapter->bup){
+		ret = -1;
+		goto exit;
+	}
+#if WIRELESS_EXT <= 20
+	if (wrqu->essid.length-1 > IW_ESSID_MAX_SIZE)
+#else
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE)
+#endif
+	{
+		ret= -E2BIG;
+		goto exit;
+	}
+	
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -1;
+		goto exit;
+	}		
+	
+	authmode = padapter->securitypriv.ndisauthtype;
+	printk("=>%s\n",__FUNCTION__);
+	if (wrqu->essid.flags && wrqu->essid.length)
+	{
+		// Commented by Albert 20100519
+		// We got the codes in "set_info" function of iwconfig source code.
+		//	=========================================
+		//	wrq.u.essid.length = strlen(essid) + 1;
+	  	//	if(we_kernel_version > 20)
+		//		wrq.u.essid.length--;
+		//	=========================================
+		//	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1.
+#if WIRELESS_EXT <= 20
+		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
+#else
+		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? wrqu->essid.length : IW_ESSID_MAX_SIZE;
+#endif
+
+		printk("ssid=%s, len=%d\n", extra, wrqu->essid.length);
+
+		_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));
+		ndis_ssid.SsidLength = len;
+		_rtw_memcpy(ndis_ssid.Ssid, extra, len);		
+		src_ssid = ndis_ssid.Ssid;
+		
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("rtw_wx_set_essid: ssid=[%s]\n", src_ssid));
+		
+	       phead = get_list_head(queue);
+              pmlmepriv->pscanned = get_next(phead);
+
+		while (1)
+		{			
+			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+			{
+#if 0			
+				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				{
+	            			rtw_set_802_11_ssid(padapter, &ndis_ssid);
+
+		    			goto exit;                    
+				}
+				else
+				{
+					RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("rtw_wx_set_ssid(): scanned_queue is empty\n"));
+					ret = -EINVAL;
+					goto exit;
+				}
+#endif			
+			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
+					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
+
+				break;
+			}
+	
+			pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
+
+			pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+			dst_ssid = pnetwork->network.Ssid.Ssid;
+
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+				 ("rtw_wx_set_essid: dst_ssid=%s\n",
+				  pnetwork->network.Ssid.Ssid));
+
+			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == _TRUE) &&
+				(pnetwork->network.Ssid.SsidLength==ndis_ssid.SsidLength))
+			{
+				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+					 ("rtw_wx_set_essid: find match, set infra mode\n"));
+
+				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				{
+					if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+						continue;
+				}	
+					
+				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
+				{
+					ret = -1;
+					goto exit;
+				}
+
+				break;			
+			}
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("set ssid: set_802_11_auth. mode=%d\n", authmode));
+		rtw_set_802_11_authentication_mode(padapter, authmode);
+		//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
+		if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) {
+			ret = -1;
+			goto exit;
+		}	
+	}			
+	printk("<=%s\n",__FUNCTION__);
+exit:
+	
+	_func_exit_;
+	
+	return ret;	
+}
+
+static int rtw_wx_get_essid(struct net_device *dev, 
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	u32 len,ret = 0;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_essid\n"));
+
+	_func_enter_;
+ 
+	if ( (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
+	      (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+	{
+		len = pcur_bss->Ssid.SsidLength;
+
+		wrqu->essid.length = len;
+			
+		_rtw_memcpy(extra, pcur_bss->Ssid.Ssid, len);
+
+		wrqu->essid.flags = 1;
+	}
+	else
+	{
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+	
+	_func_exit_;
+	
+	return ret;
+	
+}
+
+static int rtw_wx_set_rate(struct net_device *dev, 
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	int	i, ret = 0;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	u8	datarates[NumRates];
+	u32	target_rate = wrqu->bitrate.value;
+	u32	fixed = wrqu->bitrate.fixed;
+	u32	ratevalue = 0;
+	 u8 mpdatarate[NumRates]={11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+
+	_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_set_rate \n"));
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("target_rate = %d, fixed = %d\n",target_rate,fixed));
+	
+	if(target_rate == -1){
+		ratevalue = 11;
+		goto set_rate;
+	}
+	target_rate = target_rate/100000;
+
+	switch(target_rate){
+		case 10:
+			ratevalue = 0;
+			break;
+		case 20:
+			ratevalue = 1;
+			break;
+		case 55:
+			ratevalue = 2;
+			break;
+		case 60:
+			ratevalue = 3;
+			break;
+		case 90:
+			ratevalue = 4;
+			break;
+		case 110:
+			ratevalue = 5;
+			break;
+		case 120:
+			ratevalue = 6;
+			break;
+		case 180:
+			ratevalue = 7;
+			break;
+		case 240:
+			ratevalue = 8;
+			break;
+		case 360:
+			ratevalue = 9;
+			break;
+		case 480:
+			ratevalue = 10;
+			break;
+		case 540:
+			ratevalue = 11;
+			break;
+		default:
+			ratevalue = 11;
+			break;
+	}
+
+set_rate:
+
+	for(i=0; i<NumRates; i++)
+	{
+		if(ratevalue==mpdatarate[i])
+		{
+			datarates[i] = mpdatarate[i];
+			if(fixed == 0)
+				break;
+		}
+		else{
+			datarates[i] = 0xff;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("datarate_inx=%d\n",datarates[i]));
+	}
+
+	if( rtw_setdatarate_cmd(padapter, datarates) !=_SUCCESS){
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("rtw_wx_set_rate Fail!!!\n"));
+		ret = -1;
+	}
+
+	_func_exit_;
+	
+	return ret;
+	
+}
+
+static int rtw_wx_get_rate(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{	
+	int i;
+	u8 *p;
+	u16 rate, max_rate=0, ht_cap=_FALSE;
+	u32 ht_ielen = 0;	
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+	struct ieee80211_ht_cap *pht_capie;
+	u8 bw_40MHz=0, short_GI=0;
+	u16 mcs_rate=0;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+	unsigned char rf_type = GET_RF_TYPE(padapter);
+	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
+
+	i=0;
+	 
+	if((check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) || (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+	{
+		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if(p && ht_ielen>0)
+		{
+			ht_cap = (phtpriv->ht_option==1)?_TRUE:_FALSE;	
+
+			pht_capie = (struct ieee80211_ht_cap *)(p+2);
+		
+			_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+			if((rf_type == RF_1T1R) ||(rf_type == RF_1T2R))
+				mcs_rate &= 0xFF;
+
+			bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+
+			short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+		}
+
+		while( (pcur_bss->SupportedRates[i]!=0) && (pcur_bss->SupportedRates[i]!=0xFF))
+		{
+			rate = pcur_bss->SupportedRates[i]&0x7F;
+			if(rate>max_rate)
+				max_rate = rate;
+
+			wrqu->bitrate.fixed = 0;	/* no auto select */
+			//wrqu->bitrate.disabled = 1/;		
+			i++;
+		}
+	
+		/* 
+		 * The mcs_rate got from cur_network will be replaced by scan result,
+		 * which is the AP capability rather than the negotiated one. We need to
+		 * consider the RF type of our device to get the final MCS
+		 */
+		if(ht_cap == _TRUE)
+		{
+
+
+#if 0 //have some issue,neet to debug - 20101008-georgia
+			if(mcs_rate&0x8000)//MCS15
+			{
+				max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+			
+			}
+			else if(mcs_rate&0x0080)//MCS7
+			{
+				max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+			}
+			else//default MCS7
+			{
+				//printk("wx_get_rate, mcs_rate_bitmap=0x%x\n", mcs_rate);
+				max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+			}
+#else
+			if(rf_type == RF_1T1R)
+				max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);				
+			else
+				max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+#endif
+
+			max_rate = max_rate*2;//Mbps/2			
+			wrqu->bitrate.value = max_rate*500000;
+			
+		}
+		else
+		{
+			wrqu->bitrate.value = max_rate*500000;
+		}	
+
+	}
+	else
+	{
+		return -1;
+	}	
+	return 0;
+	
+}
+
+static int rtw_wx_get_rts(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	
+	_func_enter_;
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_get_rts \n"));
+	
+	wrqu->rts.value = padapter->registrypriv.rts_thresh;
+	wrqu->rts.fixed = 0;	/* no auto select */
+	//wrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);
+	
+	_func_exit_;
+	
+	return 0;
+}
+
+static int rtw_wx_set_frag(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+
+	_func_enter_;
+ 	
+	if (wrqu->frag.disabled)
+		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
+	else {
+		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+			return -EINVAL;
+		
+		padapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
+	}
+	
+	_func_exit_;
+	
+	return 0;
+	
+}
+
+
+static int rtw_wx_get_frag(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+	
+	_func_enter_;
+	
+	wrqu->frag.value = padapter->xmitpriv.frag_len;
+	wrqu->frag.fixed = 0;	/* no auto select */
+	//wrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
+	
+	_func_exit_;
+	
+	return 0;
+}
+
+static int rtw_wx_get_retry(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = netdev_priv(dev);
+ 	
+	wrqu->retry.value = 7;
+	wrqu->retry.fixed = 0;	/* no auto select */
+	wrqu->retry.disabled = 1;
+	
+	return 0;
+
+}	
+
+#if 0
+#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
+#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
+#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
+#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
+#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
+#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
+#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
+#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
+#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
+/*
+iwconfig wlan0 key on -> flags = 0x6001 -> maybe it means auto
+iwconfig wlan0 key off -> flags = 0x8800
+iwconfig wlan0 key open -> flags = 0x2800
+iwconfig wlan0 key open 1234567890 -> flags = 0x2000
+iwconfig wlan0 key restricted -> flags = 0x4800
+iwconfig wlan0 key open [3] 1234567890 -> flags = 0x2003
+iwconfig wlan0 key restricted [2] 1234567890 -> flags = 0x4002
+iwconfig wlan0 key open [3] -> flags = 0x2803
+iwconfig wlan0 key restricted [2] -> flags = 0x4802
+*/
+#endif
+
+static int rtw_wx_set_enc(struct net_device *dev, 
+			    struct iw_request_info *info, 
+			    union iwreq_data *wrqu, char *keybuf)
+{	
+	u32 key, ret = 0;
+	u32 keyindex_provided;
+	NDIS_802_11_WEP	 wep;	
+	NDIS_802_11_AUTHENTICATION_MODE authmode;
+
+	struct iw_point *erq = &(wrqu->encoding);
+	_adapter *padapter = netdev_priv(dev);
+ 
+	printk("+rtw_wx_set_enc, flags=0x%x\n", erq->flags);
+
+	_rtw_memset(&wep, 0, sizeof(NDIS_802_11_WEP));
+	
+	key = erq->flags & IW_ENCODE_INDEX;
+	
+	_func_enter_;	
+
+	if (erq->flags & IW_ENCODE_DISABLED)
+	{
+		printk("EncryptionDisabled\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+     		
+		goto exit;
+	}
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+		keyindex_provided = 1;
+	} 
+	else
+	{
+		keyindex_provided = 0;
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+		printk("rtw_wx_set_enc, key=%d\n", key);
+	}
+	
+	//set authentication mode	
+	if(erq->flags & IW_ENCODE_OPEN)
+	{
+		printk("rtw_wx_set_enc():IW_ENCODE_OPEN\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;//Ndis802_11EncryptionDisabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open;
+#endif
+
+		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}	
+	else if(erq->flags & IW_ENCODE_RESTRICTED)
+	{		
+		printk("rtw_wx_set_enc():IW_ENCODE_RESTRICTED\n");
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+#ifdef CONFIG_PLATFORM_MT53XX
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+#else
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Shared;
+#endif
+
+		padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;			
+		authmode = Ndis802_11AuthModeShared;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}
+	else
+	{
+		printk("rtw_wx_set_enc():erq->flags=0x%x\n", erq->flags);
+
+		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;//Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+  		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype=authmode;
+	}
+	
+	wep.KeyIndex = key;
+	if (erq->length > 0)
+	{
+		wep.KeyLength = erq->length <= 5 ? 5 : 13;
+
+		wep.Length = wep.KeyLength + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+	}
+	else
+	{
+		wep.KeyLength = 0 ;
+		
+		if(keyindex_provided == 1)// set key_id only, no given KeyMaterial(erq->length==0).
+		{
+			padapter->securitypriv.dot11PrivacyKeyIndex = key;
+
+			printk("(keyindex_provided == 1), keyid=%d, key_len=%d\n", key, padapter->securitypriv.dot11DefKeylen[key]);
+
+			switch(padapter->securitypriv.dot11DefKeylen[key])
+			{
+				case 5:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;					
+					break;
+				case 13:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;					
+					break;
+				default:
+					padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;					
+					break;
+			}
+				
+			goto exit;
+			
+		}
+		
+	}
+
+	wep.KeyIndex |= 0x80000000;
+
+	_rtw_memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
+	
+	if (rtw_set_802_11_add_wep(padapter, &wep) == _FALSE) {
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}	
+
+exit:
+	
+	_func_exit_;
+	
+	return ret;
+	
+}
+
+static int rtw_wx_get_enc(struct net_device *dev, 
+			    struct iw_request_info *info, 
+			    union iwreq_data *wrqu, char *keybuf)
+{
+	uint key, ret =0;
+	_adapter *padapter = netdev_priv(dev);
+	struct iw_point *erq = &(wrqu->encoding);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	_func_enter_;
+	 
+	if(check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
+	{
+		 if(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE)
+		 {
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+		return 0;
+	}	
+	}	
+
+	
+	key = erq->flags & IW_ENCODE_INDEX;
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+	} else
+	{
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+	}	
+
+	erq->flags = key + 1;
+
+	//if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+	//{
+	//      erq->flags |= IW_ENCODE_OPEN;
+	//}	  
+	
+	switch(padapter->securitypriv.ndisencryptstatus)
+	{
+		case Ndis802_11EncryptionNotSupported:
+		case Ndis802_11EncryptionDisabled:
+
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+	
+		break;
+		
+		case Ndis802_11Encryption1Enabled:					
+		
+		erq->length = padapter->securitypriv.dot11DefKeylen[key];		
+
+		if(erq->length)
+		{
+			_rtw_memcpy(keybuf, padapter->securitypriv.dot11DefKey[key].skey, padapter->securitypriv.dot11DefKeylen[key]);
+		
+		erq->flags |= IW_ENCODE_ENABLED;
+
+			if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+			{
+	     			erq->flags |= IW_ENCODE_OPEN;
+			}
+			else if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeShared)
+			{
+		erq->flags |= IW_ENCODE_RESTRICTED;
+			}	
+		}	
+		else
+		{
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+		}
+
+		break;
+
+		case Ndis802_11Encryption2Enabled:
+		case Ndis802_11Encryption3Enabled:
+
+		erq->length = 16;
+		erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN | IW_ENCODE_NOKEY);
+
+		break;
+	
+		default:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+
+		break;
+		
+	}
+	
+	_func_exit_;
+	
+	return ret;
+	
+}				     
+
+static int rtw_wx_get_power(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	//_adapter *padapter = netdev_priv(dev);
+ 	
+	wrqu->power.value = 0;
+	wrqu->power.fixed = 0;	/* no auto select */
+	wrqu->power.disabled = 1;
+	
+	return 0;
+
+}
+
+static int rtw_wx_set_gen_ie(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret;
+	_adapter *padapter = netdev_priv(dev);
+	 	
+       ret = rtw_set_wpa_ie(padapter, extra, wrqu->data.length);
+	   
+	return ret;
+}	
+
+//#ifdef CONFIG_PLATFORM_MT53XX
+static int rtw_wx_set_mtk_wps_ie(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+
+	return rtw_set_wpa_ie(padapter, wrqu->data.pointer, wrqu->data.length);
+}
+//#endif
+
+
+static int rtw_wx_set_auth(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+	struct iw_param *param = (struct iw_param*)&(wrqu->param);
+	int ret = 0;
+ 	
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		
+		break;
+	case IW_AUTH_KEY_MGMT:
+		/*
+		 *  ??? does not use these parameters
+		 */
+		break;
+
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+        {
+	    if ( param->value )
+            {  // wpa_supplicant is enabling the tkip countermeasure.
+               padapter->securitypriv.btkip_countermeasure = _TRUE; 
+            }
+            else
+            {  // wpa_supplicant is disabling the tkip countermeasure.
+               padapter->securitypriv.btkip_countermeasure = _FALSE; 
+            }
+		break;
+        }
+	case IW_AUTH_DROP_UNENCRYPTED:
+		{
+			/* HACK:
+			 *
+			 * wpa_supplicant calls set_wpa_enabled when the driver
+			 * is loaded and unloaded, regardless of if WPA is being
+			 * used.  No other calls are made which can be used to
+			 * determine if encryption will be used or not prior to
+			 * association being expected.  If encryption is not being
+			 * used, drop_unencrypted is set to false, else true -- we
+			 * can use this to determine if the CAP_PRIVACY_ON bit should
+			 * be set.
+			 */
+
+			if(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled)
+			{
+				break;//it means init value, or using wep, ndisencryptstatus = Ndis802_11Encryption1Enabled, 
+						// then it needn't reset it;
+			}
+			
+			if(param->value){
+				padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+				padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+				padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeOpen;
+			}
+			
+			break;
+		}
+
+	case IW_AUTH_80211_AUTH_ALG:
+
+		#ifdef CONFIG_PLATFORM_ANDROID
+		/*
+		 *  It's the starting point of a link layer connection using wpa_supplicant
+		*/
+		if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+			rtw_disassoc_cmd(padapter);
+			printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+			rtw_indicate_disconnect(padapter);
+			rtw_free_assoc_resources(padapter);
+		}
+		#endif
+
+		ret = wpa_set_auth_algs(dev, (u32)param->value);		
+	
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+
+		//if(param->value)
+		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; //802.1x
+		//else
+		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;//open system
+		
+		//_disassociate(priv);
+		
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		//ieee->ieee802_1x = param->value;
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		//ieee->privacy_invoked = param->value;
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+		
+	}
+	
+	return ret;
+	
+}
+
+static int rtw_wx_set_enc_ext(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{
+	char *alg_name;
+	u32 param_len;
+	struct ieee_param *param = NULL;
+	struct iw_point *pencoding = &wrqu->encoding;
+ 	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
+	int ret=0;
+ 	
+	param_len = sizeof(struct ieee_param) + pext->key_len;
+	param = (struct ieee_param *)_rtw_zmalloc(param_len);
+	if (param == NULL)
+		return -1;
+	
+	//_rtw_memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	_rtw_memset(param->sta_addr, 0xff, ETH_ALEN);
+
+
+	switch (pext->alg) {
+	case IW_ENCODE_ALG_NONE:
+		//todo: remove key 
+		//remove = 1;	
+		alg_name = "none";
+		break;
+	case IW_ENCODE_ALG_WEP:
+		alg_name = "WEP";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg_name = "TKIP";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:	
+		return -1;
+	}
+	
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+
+	
+	if(pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)//?
+	{
+		param->u.crypt.set_tx = 0;
+	}
+
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)//?
+	{
+		param->u.crypt.set_tx = 1;
+	}
+
+	param->u.crypt.idx = (pencoding->flags&0x00FF) -1 ;
+	
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) 
+	{	
+		_rtw_memcpy(param->u.crypt.seq, pext->rx_seq, 8);
+	}
+
+	if(pext->key_len)
+	{
+		param->u.crypt.key_len = pext->key_len;
+		//_rtw_memcpy(param + 1, pext + 1, pext->key_len);
+		_rtw_memcpy(param->u.crypt.key, pext + 1, pext->key_len);
+	}	
+
+	
+	if (pencoding->flags & IW_ENCODE_DISABLED)
+	{		
+		//todo: remove key 
+		//remove = 1;		
+	}	
+	
+	ret =  wpa_set_encryption(dev, param, param_len);	
+	
+
+	if(param)
+	{
+		_rtw_mfree((u8*)param, param_len);
+	}
+		
+	
+	return ret;		
+
+}
+
+
+static int rtw_wx_get_nick(struct net_device *dev, 
+			     struct iw_request_info *info, 
+			     union iwreq_data *wrqu, char *extra)
+{	
+	// _adapter *padapter = netdev_priv(dev);
+	 //struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	 //struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	if(extra)
+	{
+		wrqu->data.length = 14;
+		wrqu->data.flags = 1;
+		_rtw_memcpy(extra, "<WIFI@REALTEK>", 14);
+	}
+
+	//kill_pid(find_vpid(pid), SIGUSR1, 1); //for test
+
+	//dump debug info here	
+/*
+	u32 dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, and 8021x
+	u32 dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key 
+	u32 ndisauthtype;
+	u32 ndisencryptstatus;
+*/
+
+	//printk("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+	//		psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+	//		psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+	
+	//printk("enc_alg=0x%x\n", psecuritypriv->dot11PrivacyAlgrthm);
+	//printk("auth_type=0x%x\n", psecuritypriv->ndisauthtype);
+	//printk("enc_type=0x%x\n", psecuritypriv->ndisencryptstatus);
+
+#if 0
+	printk("dbg(0x210)=0x%x\n", rtw_read32(padapter, 0x210));
+	printk("dbg(0x608)=0x%x\n", rtw_read32(padapter, 0x608));
+	printk("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
+	printk("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
+	printk("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));
+	
+	printk("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));
+
+
+	printk("\n");
+
+	printk("dbg(0x430)=0x%x\n", rtw_read32(padapter, 0x430));
+	printk("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));
+
+	printk("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));
+	
+	printk("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));
+	
+	printk("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
+	printk("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));
+	
+	printk("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
+	printk("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
+	printk("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
+	printk("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
+#endif
+	
+	return 0;
+
+}
+
+static int rtw_wx_read32(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+
+	u32 addr;
+	u32 data32;
+
+
+	addr = *(u32*)extra;
+	data32 = rtw_read32(padapter, addr);
+	sprintf(extra, "0x%08x", data32);
+
+	return 0;
+}
+
+static int rtw_wx_write32(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+
+	u32 addr;
+	u32 data32;
+
+
+	addr = *(u32*)extra;
+	data32 = *((u32*)extra + 1);
+	rtw_write32(padapter, addr, data32);
+
+	return 0;
+}
+
+static int r8192_wx_read_rf(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+	u32 path, addr, data32;
+
+
+	path = *(u32*)extra;
+	addr = *((u32*)extra + 1);
+	data32 = read_rfreg(padapter, path, addr, 0xFFFFFFFF);
+//	printk("%s: path=%d addr=0x%02x data=0x%05x\n", __func__, path, addr, data32);
+	/*
+	 * IMPORTANT!!
+	 * Only when wireless private ioctl is at odd order,
+	 * "extra" would be copied to user space.
+	 */
+	sprintf(extra, "0x%05x", data32);
+
+	return 0;
+}
+
+static int r8192_wx_write_rf(struct net_device *dev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter = netdev_priv(dev);
+	u32 path, addr, data32;
+
+
+	path = *(u32*)extra;
+	addr = *((u32*)extra + 1);
+	data32 = *((u32*)extra + 2);
+//	printk("%s: path=%d addr=0x%02x data=0x%05x\n", __func__, path, addr, data32);
+	write_rfreg(padapter, path, addr, 0xFFFFFFFF, data32);
+
+	return 0;
+}
+
+static int dummy(struct net_device *dev, struct iw_request_info *a,
+		 union iwreq_data *wrqu, char *b)
+{
+	//_adapter *padapter = (_adapter *)netdev_priv(dev);	
+	//struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	//printk("cmd_code=%x, fwstate=0x%x\n", a->cmd, pmlmepriv->fw_state);
+	
+	return -1;
+	
+}
+
+//#ifdef CONFIG_PLATFORM_MT53XX
+static int rtw_wx_set_mtk_wps_probe_ie(struct net_device *dev,
+		struct iw_request_info *a,
+		union iwreq_data *wrqu, char *b)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+		 ("WLAN IOCTL: cmd_code=%x, fwstate=0x%x\n",
+		  a->cmd, pmlmepriv->fw_state));
+
+	return 0;
+}
+
+static int rtw_wx_get_sensitivity(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *buf)
+{
+
+	_adapter *padapter = netdev_priv(dev);
+
+    //wrqu->qual.level = (u8)padapter->mlmepriv.cur_network.network.Rssi;
+
+	wrqu->qual.level = padapter->recvpriv.signal_strength;
+
+    printk(" level = %u\n",  wrqu->qual.level );
+
+	return 0;
+}
+//#endif
+
+
+/*
+typedef int (*iw_handler)(struct net_device *dev, struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra);
+*/
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+static  int rtw_drvext_hdl(struct net_device *dev, struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+
+ #if 0
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+ #endif
+
+#if 0
+	u8 res;
+	struct drvext_handler *phandler;	
+	struct drvext_oidparam *poidparam;		
+	int ret;
+	u16 len;
+	u8 *pparmbuf, bset;
+	_adapter *padapter = netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	if( (!p->length) || (!p->pointer)){
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+	
+	
+	bset = (u8)(p->flags&0xFFFF);
+	len = p->length;
+	pparmbuf = (u8*)_rtw_malloc(len);
+	if (pparmbuf == NULL){
+		ret = -ENOMEM;
+		goto _rtw_drvext_hdl_exit;
+	}
+	
+	if(bset)//set info
+	{
+		if (copy_from_user(pparmbuf, p->pointer,len)) {
+			_rtw_mfree(pparmbuf, len);
+			ret = -EFAULT;
+			goto _rtw_drvext_hdl_exit;
+		}		
+	}
+	else//query info
+	{
+	
+	}
+
+	
+	//
+	poidparam = (struct drvext_oidparam *)pparmbuf;	
+	
+	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("drvext set oid subcode [%d], len[%d], InformationBufferLength[%d]\r\n",
+        					 poidparam->subcode, poidparam->len, len));
+
+
+	//check subcode	
+	if ( poidparam->subcode >= MAX_DRVEXT_HANDLERS)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext handlers\r\n"));		
+		ret = -EINVAL;
+		goto exit_drvext_set_info;
+	}
+
+
+	if ( poidparam->subcode >= MAX_DRVEXT_OID_SUBCODES)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext subcodes\r\n"));		
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+
+	phandler = drvextoidhandlers + poidparam->subcode;
+
+	if (poidparam->len != phandler->parmsize)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext param size %d vs %d\r\n",			
+						poidparam->len , phandler->parmsize));		
+		ret = -EINVAL;		
+		goto _rtw_drvext_hdl_exit;
+	}
+
+
+	res = phandler->handler(padapter, bset, poidparam->data);
+
+	if(res==0)
+		ret = 0
+	else
+		ret = -EFAULT;
+
+	
+_rtw_drvext_hdl_exit:	
+	
+	return ret;	
+	
+#endif
+
+	return 0;
+
+}
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+u8 _get_wifi_status(_adapter *padapter)	
+{
+	u8 status = WIFI_STATUS_SUCCESS;
+	u32 val32 = 0;
+	_irqL irqL;	
+	if(padapter->silent_reset_inprogress == _TRUE)
+        {
+		return status;
+	}
+	val32 = rtw_read32(padapter,REG_TXDMA_STATUS);
+	if(val32==0xeaeaeaea){
+		padapter->Wifi_Error_Status = WIFI_IF_NOT_EXIST;
+	}
+	else if(val32!=0){
+		printk("txdmastatu(%x)\n",val32);
+		padapter->Wifi_Error_Status = WIFI_MAC_TXDMA_ERROR;
+	}	
+
+	if(WIFI_STATUS_SUCCESS !=padapter->Wifi_Error_Status)
+	{
+		printk("==>%s error_status(0x%x) \n",__FUNCTION__,padapter->Wifi_Error_Status);
+		status = (padapter->Wifi_Error_Status &( ~(USB_READ_PORT_FAIL|USB_WRITE_PORT_FAIL)));
+	}
+	printk("==> %s wifi_status(0x%x)\n",__FUNCTION__,status);
+
+	//status restore 
+	padapter->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
+
+	return status;
+}
+#endif
+
+static void rtw_dbg_mode_hdl(_adapter *padapter, u32 id, u8 *pdata, u32 len)
+{
+	pRW_Reg 	RegRWStruct;
+	struct rf_reg_param *prfreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+	printk("%s\n", __FUNCTION__);
+
+	switch(id)
+	{
+		case GEN_MP_IOCTL_SUBCODE(MP_START):
+			printk("8192cu_mp start.................\n");
+			break;
+		case GEN_MP_IOCTL_SUBCODE(READ_REG):
+			RegRWStruct = (pRW_Reg)pdata;
+			switch (RegRWStruct->width)
+			{
+				case 1:
+					RegRWStruct->value = rtw_read8(padapter, RegRWStruct->offset);
+					break;
+				case 2:
+					RegRWStruct->value = rtw_read16(padapter, RegRWStruct->offset);
+					break;
+				case 4:
+					RegRWStruct->value = rtw_read32(padapter, RegRWStruct->offset);
+					break;
+				default:
+					break;
+			}
+		
+			break;
+		case GEN_MP_IOCTL_SUBCODE(WRITE_REG):
+			RegRWStruct = (pRW_Reg)pdata;
+			switch (RegRWStruct->width)
+			{
+				case 1:
+					rtw_write8(padapter, RegRWStruct->offset, (u8)RegRWStruct->value);
+					break;
+				case 2:
+					rtw_write16(padapter, RegRWStruct->offset, (u16)RegRWStruct->value);
+					break;
+				case 4:
+					rtw_write32(padapter, RegRWStruct->offset, (u32)RegRWStruct->value);
+					break;
+				default:					
+				break;
+			}
+				
+			break;
+		case GEN_MP_IOCTL_SUBCODE(READ_RF_REG):
+
+			prfreg = (struct rf_reg_param *)pdata;
+
+			path = (u8)prfreg->path;		
+			offset = (u8)prfreg->offset;	
+			
+			value =  read_rfreg(padapter, path, offset, bMaskDWord);
+
+			prfreg->value = value;
+
+			break;			
+		case GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG):
+
+			prfreg = (struct rf_reg_param *)pdata;
+
+			path = (u8)prfreg->path;
+			offset = (u8)prfreg->offset;	
+			value = prfreg->value;
+			
+			write_rfreg(padapter, path, offset, bMaskDWord, value);
+			
+			break;			
+                case GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO):
+			printk("==> trigger gpio 0\n");
+			rtl8192cu_trigger_gpio_0(padapter);
+			break;	
+#ifdef CONFIG_BT_COEXIST
+		case	GEN_MP_IOCTL_SUBCODE(SET_DM_BT):			
+			printk("==> set dm_bt_coexist:%x\n",*(u8 *)pdata);
+			set_dm_bt_coexist(padapter,*(u8 *)pdata);
+			break;
+		case GEN_MP_IOCTL_SUBCODE(DEL_BA):
+			printk("==> delete ba:%x\n",*(u8 *)pdata);
+			issue_delete_ba(padapter,*(u8 *)pdata);
+			break;
+#endif
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+		case GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS):					
+			*pdata = _get_wifi_status(padapter);					
+			break;
+#endif
+		default:
+			break;
+	}
+	
+}
+
+static  int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+        int ret = 0;
+	unsigned long BytesRead, BytesWritten, BytesNeeded;
+	struct oid_par_priv	oid_par;
+	struct mp_ioctl_handler	*phandler;	
+	struct mp_ioctl_param	*poidparam;
+	uint status=0;
+	u16 len;
+	u8 *pparmbuf = NULL, bset;
+	_adapter *padapter = netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	//printk("+rtw_mp_ioctl_hdl\n");
+
+	//mutex_lock(&ioctl_mutex);
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	pparmbuf = NULL;
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+	pparmbuf = (u8*)_rtw_malloc(len);
+	if (pparmbuf == NULL){
+		ret = -ENOMEM;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	poidparam = (struct mp_ioctl_param *)pparmbuf;	
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_mp_ioctl_hdl: subcode [%d], len[%d], buffer_len[%d]\r\n",
+        	  poidparam->subcode, poidparam->len, len));
+
+	if (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("no matching drvext subcodes\r\n"));
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	printk("+rtw_mp_ioctl_hdl(%d)\n", poidparam->subcode);
+
+#ifdef CONFIG_MP_INCLUDED 
+	phandler = mp_ioctl_hdl + poidparam->subcode;
+
+	if ((phandler->paramsize != 0) && (poidparam->len < phandler->paramsize))
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("no matching drvext param size %d vs %d\r\n",			
+			  poidparam->len, phandler->paramsize));
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	if (phandler->oid == 0 && phandler->handler) {
+	        status = phandler->handler(&oid_par);
+	}
+	else if (phandler->handler)
+	{
+		oid_par.adapter_context = padapter;
+		oid_par.oid = phandler->oid;
+		oid_par.information_buf = poidparam->data;
+		oid_par.information_buf_len = poidparam->len;
+		oid_par.dbg = 0;
+
+		BytesWritten = 0;
+		BytesNeeded = 0;
+
+		if (bset) {
+			oid_par.bytes_rw = &BytesRead;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = SET_OID;
+		} else {
+			oid_par.bytes_rw = &BytesWritten;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = QUERY_OID;
+		}
+
+		status = phandler->handler(&oid_par);
+
+		//todo:check status, BytesNeeded, etc.
+	}
+	else {
+		printk("rtw_mp_ioctl_hdl(): err!, subcode=%d, oid=%d, handler=%p\n", 
+			poidparam->subcode, phandler->oid, phandler->handler);
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+#else
+
+	rtw_dbg_mode_hdl(padapter, poidparam->subcode, poidparam->data, poidparam->len);
+	
+#endif
+
+	if (bset == 0x00) {//query info
+		//_rtw_memcpy(p->pointer, pparmbuf, len);
+		if (copy_to_user(p->pointer, pparmbuf, len))
+			ret = -EFAULT;
+	}
+
+	if (status) {
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+_rtw_mp_ioctl_hdl_exit:
+
+	if (pparmbuf)
+		_rtw_mfree(pparmbuf, 0);
+
+	//mutex_unlock(&ioctl_mutex);	
+
+	return ret;
+}
+
+static int rtw_get_ap_info(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int bssid_match, ret = 0;
+	u32 cnt=0, wpa_ielen;
+	_irqL	irqL;
+	_list	*plist, *phead;
+	unsigned char *pbuf;
+	u8 bssid[ETH_ALEN];
+	char data[32];
+	struct wlan_network *pnetwork = NULL;
+	_adapter *padapter = netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
+	_queue *queue = &(pmlmepriv->scanned_queue);
+	struct iw_point *pdata = &wrqu->data;	
+
+	printk("+rtw_get_aplist_info\n");
+
+	if((padapter->bDriverStopped) || (pdata==NULL))
+	{                
+		ret= -EINVAL;
+		goto exit;
+	}		
+  
+ 	while((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == _TRUE)
+	{	
+		rtw_msleep_os(30);
+		cnt++;
+		if(cnt > 100)
+			break;
+	}
+	
+
+	//pdata->length = 0;//?	
+	pdata->flags = 0;
+	if(pdata->length>=32)
+	{
+		if(copy_from_user(data, pdata->pointer, 32))
+		{
+			ret= -EINVAL;
+			goto exit;
+		}
+	}	
+	else
+	{
+		ret= -EINVAL;
+		goto exit;
+	}	
+
+	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+       
+	while(1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			break;
+
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+
+		//if(hwaddr_aton_i(pdata->pointer, bssid)) 
+		if(hwaddr_aton_i(data, bssid)) 
+		{			
+			printk("Invalid BSSID '%s'.\n", (u8*)data);
+			return -EINVAL;
+		}		
+		
+	
+		if(_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)//BSSID match, then check if supporting wpa/wpa2
+		{
+			printk("BSSID:" MACSTR "\n", MAC2STR(bssid));
+			
+			pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);				
+			if(pbuf && (wpa_ielen>0))
+			{
+				pdata->flags = 1;
+				break;
+			}
+
+			pbuf = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+			if(pbuf && (wpa_ielen>0))
+			{
+				pdata->flags = 2;
+				break;
+			}
+			
+		}
+
+		plist = get_next(plist);		
+	
+	}        
+
+	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+
+	if(pdata->length>=34)
+	{
+		if(copy_to_user((u8*)pdata->pointer+32, (u8*)&pdata->flags, 1))
+		{
+			ret= -EINVAL;
+			goto exit;
+		}
+	}	
+	
+exit:
+	
+	return ret;
+		
+}
+
+static int rtw_set_pid(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;	
+
+	printk("+rtw_set_pid\n");
+
+	if((padapter->bDriverStopped) || (pdata==NULL))
+	{                
+		ret= -EINVAL;
+		goto exit;
+	}		
+  
+ 	//pdata->length = 0;
+	//pdata->flags = 0;
+
+	//_rtw_memcpy(&padapter->pid, pdata->pointer, sizeof(int));
+	if(copy_from_user(&padapter->pid, pdata->pointer, sizeof(int)))
+	{
+		ret= -EINVAL;
+		goto exit;
+	}
+
+	printk("got pid=%d\n", padapter->pid);
+
+exit:
+	
+	return ret;
+		
+}
+static int rtw_wps_start(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	
+	int ret = 0;	
+	_adapter *padapter = netdev_priv(dev);	
+	struct iw_point *pdata = &wrqu->data;
+	u32   u32wps_start = 0;
+        unsigned int uintRet = 0;
+
+        uintRet = copy_from_user( ( void* ) &u32wps_start, pdata->pointer, 4 );
+
+	if((padapter->bDriverStopped) || (pdata==NULL))
+	{                
+		ret= -EINVAL;
+		goto exit;
+	}		
+
+       if ( u32wps_start == 0 )
+       {
+           u32wps_start = *extra;
+       }
+
+       printk( "[%s] wps_start = %d\n", __FUNCTION__, u32wps_start );
+
+       if ( u32wps_start == 1 ) // WPS Start
+       {
+           padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_WPS);
+       }
+	else if ( u32wps_start == 2 ) // WPS Stop because of wps success
+	{
+           padapter->ledpriv.LedControlHandler(padapter, LED_CTL_STOP_WPS);
+	}
+	else if ( u32wps_start == 3 ) // WPS Stop because of wps fail
+	{
+           padapter->ledpriv.LedControlHandler(padapter, LED_CTL_STOP_WPS_FAIL);
+	}
+exit:
+	
+	return ret;
+		
+}
+
+void mac_reg_dump(_adapter *padapter)
+{
+	int i,j=1;		
+	printk("\n======= MAC REG =======\n");
+	for(i=0x0;i<0x300;i+=4)
+	{	
+		if(j%4==1)	printk("0x%02x",i);
+		printk(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	printk("\n");	
+	}
+	for(i=0x400;i<0x800;i+=4)
+	{	
+		if(j%4==1)	printk("0x%02x",i);
+		printk(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	printk("\n");	
+	}									
+}
+void bb_reg_dump(_adapter *padapter)
+{
+	int i,j=1;		
+	printk("\n======= BB REG =======\n");
+	for(i=0x800;i<0x1000;i+=4)
+	{
+		if(j%4==1) printk("0x%02x",i);
+				
+		printk(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	printk("\n");	
+	}		
+}
+void rf_reg_dump(_adapter *padapter)
+{	
+	int i,j=1,path;
+	u32 value;			
+	printk("\n======= RF REG =======\n");
+	for(path=0;path<2;path++)
+	{
+		printk("\nRF_Path(%x)\n",path);
+		for(i=0;i<0x100;i++)
+		{								
+			value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
+			if(j%4==1)	printk("0x%02x ",i);
+			printk(" 0x%08x ",value);
+			if((j++)%4==0)	printk("\n");	
+		}	
+	}
+}
+static int rtw_dbg_port(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{	
+	_irqL irqL;
+	int ret = 0;
+	u8 major_cmd, minor_cmd;
+	u16 arg;
+	u32 extra_arg, *pdata, val32;
+	struct sta_info *psta;						
+	_adapter *padapter = netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);	
+	
+
+	pdata = (u32*)&wrqu->data;	
+
+	val32 = *pdata;
+	arg = (u16)(val32&0x0000ffff);
+	major_cmd = (u8)(val32>>24);
+	minor_cmd = (u8)((val32>>16)&0x00ff);
+
+	extra_arg = *(pdata+1);
+	
+	switch(major_cmd)
+	{
+		case 0x70://read_reg
+			switch(minor_cmd)
+			{
+				case 1:
+					printk("rtw_read8(0x%x)=0x%x\n", arg, rtw_read8(padapter, arg));
+					break;
+				case 2:
+					printk("rtw_read16(0x%x)=0x%x\n", arg, rtw_read16(padapter, arg));
+					break;
+				case 4:
+					printk("rtw_read32(0x%x)=0x%x\n", arg, rtw_read32(padapter, arg));
+					break;
+			}			
+			break;
+		case 0x71://write_reg
+			switch(minor_cmd)
+			{
+				case 1:
+					rtw_write8(padapter, arg, extra_arg);
+					printk("rtw_write8(0x%x)=0x%x\n", arg, rtw_read8(padapter, arg));
+					break;
+				case 2:
+					rtw_write16(padapter, arg, extra_arg);
+					printk("rtw_write16(0x%x)=0x%x\n", arg, rtw_read16(padapter, arg));
+					break;
+				case 4:
+					rtw_write32(padapter, arg, extra_arg);
+					printk("rtw_write32(0x%x)=0x%x\n", arg, rtw_read32(padapter, arg));
+					break;
+			}			
+			break;
+		case 0x72://read_bb
+			printk("read_bbreg(0x%x)=0x%x\n", arg, read_bbreg(padapter, arg, 0xffffffff));			
+			break;
+		case 0x73://write_bb
+			write_bbreg(padapter, arg, 0xffffffff, extra_arg);
+			printk("write_bbreg(0x%x)=0x%x\n", arg, read_bbreg(padapter, arg, 0xffffffff));	
+			break;
+		case 0x74://read_rf		
+			{
+				u32 value ;
+				value = PHY_QueryRFReg(padapter, minor_cmd, arg, 0xffffffff);	
+				printk("read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg,value);
+			}
+			break;
+		case 0x75://write_rf		
+			{
+				u32 value = extra_arg;
+				PHY_SetRFReg(padapter, minor_cmd, arg, 0xffffffff, value);
+				printk("write RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg,value);
+				value = PHY_QueryRFReg(padapter, minor_cmd, arg, 0xffffffff);	
+				printk("read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg,value);
+			}
+			break;	
+
+		case 0x7F:
+			switch(minor_cmd)
+			{
+				case 0x0:
+					printk("fwstate=0x%x\n", pmlmepriv->fw_state);
+					break;
+				case 0x01:
+					printk("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+					break;
+				case 0x02:
+					printk("pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
+					break;
+				case 0x03:
+					printk("qos_option=%d\n", pmlmepriv->qospriv.qos_option);
+					printk("ht_option=%d\n", pmlmepriv->htpriv.ht_option);
+					break;
+				case 0x04:
+					printk("cur_ch=%d\n", pmlmeext->cur_channel);
+					printk("cur_bw=%d\n", pmlmeext->cur_bwmode);
+					printk("cur_ch_off=%d\n", pmlmeext->cur_ch_offset);
+					break;
+				case 0x05:
+					psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+					if(psta)
+					{
+						int i;
+						struct recv_reorder_ctrl *preorder_ctrl;
+					
+						printk("sta's macaddr:" MACSTR "\n", MAC2STR(psta->hwaddr));
+						printk("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+						printk("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+						printk("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+						printk("bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+						printk("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
+						printk("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+						
+						for(i=0;i<16;i++)
+						{							
+							preorder_ctrl = &psta->recvreorder_ctrl[i];
+							if(preorder_ctrl->enable)
+							{
+								printk("tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
+							}
+						}	
+							
+					}
+					else
+					{							
+						printk("can't get sta's macaddr, cur_network's macaddr:" MACSTR "\n", MAC2STR(cur_network->network.MacAddress));
+					}					
+					break;
+				case 0x06:
+					{
+						struct dm_priv *pdmpriv = &padapter->dmpriv;
+
+						printk("(B)DMFlag=0x%x, arg=0x%x\n", pdmpriv->DMFlag, arg);						
+						pdmpriv->DMFlag = (u8)(0x0f&arg);
+						printk("(A)DMFlag=0x%x\n", pdmpriv->DMFlag);				
+					}
+					break;
+				case 0x07:
+					printk("bSurpriseRemoved=%d, bDriverStopped=%d\n", 
+						padapter->bSurpriseRemoved, padapter->bDriverStopped);
+					break;
+                         case 0x08:
+					{
+						struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+						struct recv_priv  *precvpriv = &padapter->recvpriv;
+						
+						printk("free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d\n", 
+							pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt);
+						
+						printk("rx_urb_pending_cn=%d\n", precvpriv->rx_pending_cnt);
+					}
+					break;	
+				case 0x09:
+					{
+						int i, j;
+						_list	*plist, *phead;
+						struct recv_reorder_ctrl *preorder_ctrl;
+						
+						_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+						for(i=0; i< NUM_STA; i++)
+						{
+							phead = &(pstapriv->sta_hash[i]);
+							plist = get_next(phead);
+		
+							while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+							{
+								psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+
+								plist = get_next(plist);
+
+								if(extra_arg == psta->aid)
+								{
+									printk("sta's macaddr:" MACSTR "\n", MAC2STR(psta->hwaddr));
+									printk("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+									printk("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+									printk("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+									printk("bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+									printk("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
+									printk("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+						
+									for(j=0;j<16;j++)
+									{							
+										preorder_ctrl = &psta->recvreorder_ctrl[j];
+										if(preorder_ctrl->enable)
+										{
+											printk("tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
+										}
+									}		
+									
+								}							
+			
+							}
+						}
+	
+						_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+					}
+					break;
+				case 0x0a:
+					{
+						struct dm_priv *pdmpriv = &padapter->dmpriv;
+						PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pdmpriv->FalseAlmCnt);
+						
+						printk("S-PWDB=%d\n", pdmpriv->UndecoratedSmoothedPWDB);
+						
+						printk("Ofdm_fail=%d\n", FalseAlmCnt->Cnt_Ofdm_fail);
+
+						printk("Parity_Fail=%d\n", FalseAlmCnt->Cnt_Parity_Fail);
+
+						printk("Rate_Illegal=%d\n", FalseAlmCnt->Cnt_Rate_Illegal);
+
+						printk("Crc8_fail=%d\n", FalseAlmCnt->Cnt_Crc8_fail);
+
+						printk("Mcs_fail=%d\n", FalseAlmCnt->Cnt_Mcs_fail);
+
+						printk("Cck_fail=%d\n", FalseAlmCnt->Cnt_Cck_fail);
+
+						printk("Cnt_all=%d\n", FalseAlmCnt->Cnt_all);		
+								
+					}
+					break;
+				case 0x0b:
+					{
+/*						
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00			0xe10
+#define		rTxAGC_A_Mcs07_Mcs04			0xe14
+#define		rTxAGC_A_Mcs11_Mcs08			0xe18
+#define		rTxAGC_A_Mcs15_Mcs12			0xe1c
+
+#define		rTxAGC_B_Rate18_06			0x830
+#define		rTxAGC_B_Rate54_24			0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+*/
+					printk("rTxAGC_A_Rate18_06=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_A_Rate18_06, bMaskDWord));
+					printk("rTxAGC_A_Rate54_24=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_A_Rate54_24, bMaskDWord));
+					printk("rTxAGC_A_Mcs03_Mcs00=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_A_Mcs03_Mcs00, bMaskDWord));					
+					printk("rTxAGC_A_Mcs07_Mcs04=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_A_Mcs07_Mcs04, bMaskDWord));
+					printk("rTxAGC_A_Mcs11_Mcs08=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_A_Mcs11_Mcs08, bMaskDWord));
+					printk("rTxAGC_A_Mcs15_Mcs12=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_A_Mcs15_Mcs12, bMaskDWord));
+
+
+					printk("rTxAGC_A_CCK1_Mcs32=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_A_CCK1_Mcs32, bMaskDWord));	
+
+					printk("rTxAGC_B_CCK11_A_CCK2_11=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskDWord));
+
+					printk("rTxAGC_B_CCK1_55_Mcs32=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_CCK1_55_Mcs32, bMaskDWord));				
+
+
+					printk("rTxAGC_B_Rate18_06=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_Rate18_06, bMaskDWord));
+					printk("rTxAGC_B_Rate54_24=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_Rate54_24, bMaskDWord));					
+					printk("rTxAGC_B_Mcs03_Mcs00=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_Mcs03_Mcs00, bMaskDWord));
+					printk("rTxAGC_B_Mcs07_Mcs04=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_Mcs07_Mcs04, bMaskDWord));
+					printk("rTxAGC_B_Mcs11_Mcs08=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_Mcs11_Mcs08, bMaskDWord));
+					printk("rTxAGC_B_Mcs15_Mcs12=0x%x\n", PHY_QueryBBReg(padapter, rTxAGC_B_Mcs15_Mcs12, bMaskDWord));
+							
+					}
+					break;
+				case 0x0c://dump rx packet
+					{
+						printk("dump rx packet (%d)\n",extra_arg);
+						pHalData->bDumpRxPkt =extra_arg;						
+					}
+					break;
+				case 0x0d://dump cam
+					{
+						//u8 entry = (u8) extra_arg;
+						u8 entry=0;
+						//dump cam
+						for(entry=0;entry<32;entry++)
+							read_cam(padapter,entry);
+					}				
+					break;
+		#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+				case 0x0f:
+						{
+							if(extra_arg == 0){	
+								printk("###### silent reset test.......#####\n");
+								silentreset_for_specific_platform(padapter);						
+							}
+							
+						}
+				break;
+				case 0x12:
+					{
+						struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;	
+						printk("==>silent resete cnts:%d\n",pwrpriv->ips_enter_cnts);
+					}
+					break;	
+					
+		#endif	
+				case 0x10:// driver version display
+					printk("rtw driver version=%s\n", DRIVERVERSION);		
+					break;
+				case 0x11:
+					{
+						printk("turn %s Rx RSSI display function\n",(extra_arg==1)?"on":"off");
+						padapter->halpriv.bRxRSSIDisplay = extra_arg ;						
+					}
+					break;
+				case 0xdd://registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg
+						{						
+						if(extra_arg==0){
+							mac_reg_dump(padapter);
+						}
+						else if(extra_arg==1){
+							bb_reg_dump(padapter);
+						}
+						else if(extra_arg==2){
+							rf_reg_dump(padapter);
+						}
+																				
+					}
+					break;		
+				case 0xee://turn on/off dynamic funcs
+					{	
+						struct dm_priv *pdmpriv = &padapter->dmpriv;
+						if(extra_arg == 0){
+							pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
+						}
+						else if(extra_arg == 1){
+							pdmpriv->DMFlag &= (~DYNAMIC_FUNC_DIG);
+						}
+						else if(extra_arg == 2){
+							pdmpriv->DMFlag &= (~DYNAMIC_FUNC_SS);
+						}
+						else if(extra_arg == 3){
+							pdmpriv->DMFlag |= (DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_SS) ;
+						}			
+					}
+					break;
+				case 0xfd:
+					rtw_write8(padapter, 0xc50, arg);
+					printk("wr(0xc50)=0x%x\n", rtw_read8(padapter, 0xc50));
+					rtw_write8(padapter, 0xc58, arg);
+					printk("wr(0xc58)=0x%x\n", rtw_read8(padapter, 0xc58));
+					break;
+				case 0xfe:
+					printk("rd(0xc50)=0x%x\n", rtw_read8(padapter, 0xc50));
+					printk("rd(0xc58)=0x%x\n", rtw_read8(padapter, 0xc58));
+					break;
+				case 0xff:
+					{
+						printk("dbg(0x210)=0x%x\n", rtw_read32(padapter, 0x210));
+						printk("dbg(0x608)=0x%x\n", rtw_read32(padapter, 0x608));
+						printk("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
+						printk("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
+						printk("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));
+	
+						printk("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));
+
+
+						printk("\n");
+		
+						printk("dbg(0x430)=0x%x\n", rtw_read32(padapter, 0x430));
+						printk("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));
+
+						printk("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));
+	
+						printk("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));
+	
+						printk("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
+						printk("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));
+	
+						printk("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
+						printk("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
+						printk("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
+						printk("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
+					}
+					break;
+			}			
+			break;
+		default:
+			printk("error dbg cmd!\n");
+			break;	
+	}
+	
+
+	return ret;
+
+}
+u16 CRC16(u8 data,u16 CRC)
+{
+	unsigned char shift_in,CRC_BIT15,DataBit,CRC_BIT11,CRC_BIT4 ;
+	int index;
+	unsigned short CRC_Result;
+
+	for(index=0;index<8;index++)
+	{
+		CRC_BIT15=((CRC&BIT15) ? 1:0);
+		DataBit  =(data&(BIT0<<index) ? 1:0);
+		shift_in=CRC_BIT15^DataBit;
+		//printf("CRC_BIT15=%d, DataBit=%d, shift_in=%d \n",CRC_BIT15,DataBit,shift_in);
+		
+		CRC_Result=CRC<<1;
+		//set BIT0 
+		//	printf("CRC =%x\n",CRC_Result);
+		//CRC bit 0 =shift_in,
+		if(shift_in==0)
+		{
+			CRC_Result&=(~BIT0); 
+		}
+		else
+		{
+			CRC_Result|=BIT0;
+		}
+		//printf("CRC =%x\n",CRC_Result);
+
+		CRC_BIT11 = ((CRC&BIT11) ? 1:0)^shift_in;
+		if(CRC_BIT11==0)
+		{
+			CRC_Result&=(~BIT12); 
+		}
+		else
+		{
+			CRC_Result|=BIT12;
+		}
+		//printf("bit12 CRC =%x\n",CRC_Result);
+
+		CRC_BIT4 = ((CRC&BIT4) ? 1:0)^shift_in;
+		if(CRC_BIT4==0)
+		{
+			CRC_Result&=(~BIT5); 
+		}
+		else
+		{
+			CRC_Result|=BIT5;
+		}
+		//printf("bit5 CRC =%x\n",CRC_Result);
+
+		CRC=CRC_Result; //W@G
+	}
+
+	return CRC;
+	
+}
+/////////////////////////////////////////////////
+//
+//function name :calc_crc
+//
+//input         : char* pattern , pattern size
+//
+//////////////////////////////////////////////////
+u16 calc_crc(u8 * pdata,int length)
+{
+//    unsigned char data[2]={0xC6,0xAA};
+	u16 CRC=0xffff;
+	int i;
+	
+	for(i=0;i<length;i++)
+	{
+		CRC=CRC16(pdata[i],CRC);
+	}
+
+	CRC=~CRC;                  //
+	printk("CRC =%x\n",CRC);
+	return CRC;
+}
+static int rtw_wowlan_set_pattern(_adapter *padapter ,u16 len,u8* pbuf){
+	int res=0,crc_idx;
+	u32 content=0,cmd=0;
+	u32 *pdata;
+	u8 config,crc,mc,bc,uc,idx,pattern_len,packet[200],packet_len,valid;
+	u16 crc_val=0,i;
+	if(len <20){
+		printk("+rtw_wowlan_set_pattern(len=%d)\n", len);
+		res=-1;
+		goto _rtw_wowlan_set_pattern_exit;
+	}
+	config=pbuf[0];
+	bc=config & BIT(3);
+	mc=config & BIT(4);
+	uc=config &BIT(5);
+	idx=config & 0x7;
+	crc=config & BIT(6);
+	valid=config & BIT(7);
+	pattern_len=pbuf[1];
+	packet_len=pattern_len*8;
+	pdata=(u32 *)pbuf;
+
+	// Write to the Wakeup CAM
+	//offset 0
+	if(pattern_len>=4){
+	content=pdata[1];
+	}
+	else{	
+		content=0;
+	}
+	printk("\n\n\n\nrtw_wowlan_set_pattern offset[0]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(__constant_ntohl(content)));
+	rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(__constant_ntohl(content)));
+	cmd=BIT(31)|BIT(16)|(idx+0);
+	rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+	//offset 4
+	if(pattern_len>=8){
+	content=pdata[2];
+	}
+	else{	
+		content=0;
+	}
+	printk("rtw_wowlan_set_pattern offset[4]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(__constant_ntohl(content)));
+	rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(__constant_ntohl(content)));
+	cmd=BIT(31)|BIT(16)|(idx+1);
+	rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+	//offset 8
+	if(pattern_len>=12){
+	content=pdata[3];
+	}
+	else{	
+		content=0;
+	}
+	printk("rtw_wowlan_set_pattern offset[8]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(__constant_ntohl(content)));
+	rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(__constant_ntohl(content)));
+	cmd=BIT(31)|BIT(16)|(idx+2);
+	rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+	//offset 12
+	if(pattern_len>=16){
+	content=pdata[4];
+	}
+	else{	
+		content=0;
+	}
+	printk("rtw_wowlan_set_pattern offset[12]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(__constant_ntohl(content)));
+	rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(__constant_ntohl(content)));
+	cmd=BIT(31)|BIT(16)|(idx+3);
+	rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+
+	if(crc==BIT(6)){
+		// Have the CRC value
+		crc_val=*(u16 *)(&pbuf[2]);
+	}
+	else{
+		printk("+rtw_wowlan_set_pattern   crc=0[%x]  Should calculate the CRC\n", crc);
+		// calculate the CRC the write to the Wakeup CAM
+		crc_idx=0;
+		for(i=0;i<packet_len;i++){
+			if(pbuf[4+(i/8)]&(0x01<<(i%8)))
+			{
+				packet[crc_idx++]=pbuf[20+i];
+		//		printk("\n i=%d packet[i]=%x pbuf[20+i(%d)]=%x \n",i,packet[i],20+i,pbuf[20+i]);
+			}
+		}
+		crc_val=calc_crc(packet, crc_idx);
+		printk("+rtw_wowlan_set_pattern   crc_val=0x%.8x \n", crc_val);
+	}
+
+	//offset 16
+	content=(valid<<31)| (bc<<26)|(mc<<25)|(uc<<24) |crc_val;
+	printk("rtw_wowlan_set_pattern offset[16]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
+	rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content));
+	cmd=BIT(31)|BIT(16)|(idx+4);
+	rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+
+	
+_rtw_wowlan_set_pattern_exit:
+	return res;
+}
+static int rtw_wowlan_ctrl(struct net_device *dev,
+                               struct iw_request_info *info,
+                               union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	struct oid_par_priv	oid_par;
+	struct wowlan_ioctl_param *poidparam;
+	uint status=0;
+	u16 len;
+	u8 *pparmbuf = NULL, bset;
+	_adapter *padapter = netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	printk("+rtw_wowlan_ctrl\n");
+
+	//mutex_lock(&ioctl_mutex);
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _rtw_wowlan_ctrl_exit;
+	}
+
+	pparmbuf = NULL;
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+	pparmbuf = (u8*)_rtw_malloc(len);
+	if (pparmbuf == NULL){
+		ret = -ENOMEM;
+		goto _rtw_wowlan_ctrl_exit;
+	}
+
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _rtw_wowlan_ctrl_exit;
+	}
+
+	poidparam = (struct wowlan_ioctl_param *)pparmbuf;	
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_wowlan_ctrl: subcode [%d], len[%d], buffer_len[%d]\r\n",
+        	  poidparam->subcode, poidparam->len, len));
+	printk("rtw_wowlan_ctrl: subcode [%d], len[%d], buffer_len[%d]\r\n",
+        	  poidparam->subcode, poidparam->len, len);
+	switch (poidparam->subcode){
+		case 1:
+			//Turn on the Wowlan function
+			printk("\n poidparam->data[0]=%d\n",poidparam->data[0]);
+			if(poidparam->data[0]==1)
+				rtw_write8(padapter, REG_WOW_CTRL, (rtw_read8(padapter, REG_WOW_CTRL)|BIT(1)));
+			else
+				rtw_write8(padapter, REG_WOW_CTRL, (rtw_read8(padapter, REG_WOW_CTRL)&~BIT(1)));
+			break;
+		case 2:
+			//Turn on the Magic Packet
+			printk("\n poidparam->data[0]=%d\n",poidparam->data[0]);
+			if(poidparam->data[0]==1)
+				rtw_write8(padapter, REG_WOW_CTRL, (rtw_read8(padapter, REG_WOW_CTRL)|BIT(2)));
+			else
+				rtw_write8(padapter, REG_WOW_CTRL, (rtw_read8(padapter, REG_WOW_CTRL)&~BIT(2)));
+			break;
+		case 3:
+			//Turn on the pattern match bit
+			if(poidparam->data[0]==1)
+				rtw_write8(padapter, REG_WOW_CTRL, (rtw_read8(padapter, REG_WOW_CTRL)|BIT(3)));
+			else
+				rtw_write8(padapter, REG_WOW_CTRL, (rtw_read8(padapter, REG_WOW_CTRL)&~BIT(3)));
+			break;
+		case 4:
+			//Setting the Pattern for wowlan
+			ret=rtw_wowlan_set_pattern(padapter,len,poidparam->data);
+			if(ret)
+				printk("rtw_wowlan_set_pattern retern value=0x%x",ret);
+			break;
+		case 5:
+			//dump the WKFMCAM and WOW_CTRL register
+			printk("\n\n\n\n rtw_wowlan_ctrl: WOW_CTRL=0x%x \n",rtw_read8(padapter, REG_WOW_CTRL));
+			printk("print WKFMCAM index =%d ",poidparam->data[0]);
+			{	int cmd=0,offset=0;
+				for(offset=0;offset<5;offset++){
+					cmd=BIT(31)|(poidparam->data[0]+offset);
+					rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+					printk("offset[%d]=0x%.8x  ",offset,rtw_read32(padapter, REG_WKFMCAM_RWD));
+				}
+			}
+			break;
+		default:
+			break;
+	}
+
+_rtw_wowlan_ctrl_exit:
+	
+	printk("+rtw_wowlan_ctrl( subcode = %d)\n", poidparam->subcode);
+	return ret;
+}
+
+
+static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
+{
+	uint ret=0;
+	u32 flags;
+	_adapter *padapter = netdev_priv(dev);
+	
+	switch (name){
+	case IEEE_PARAM_WPA_ENABLED:
+
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X; //802.1x
+		
+		//ret = ieee80211_wpa_enable(ieee, value);
+		
+		switch((value)&0xff)
+		{
+			case 1 : //WPA
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK; //WPA_PSK
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+				break;
+			case 2: //WPA2
+			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK; //WPA2_PSK
+			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+				break;
+		}
+		
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("wpa_set_param:padapter->securitypriv.ndisauthtype=%d\n", padapter->securitypriv.ndisauthtype));
+		
+		break;
+
+	case IEEE_PARAM_TKIP_COUNTERMEASURES:
+		//ieee->tkip_countermeasures=value;
+		break;
+
+	case IEEE_PARAM_DROP_UNENCRYPTED: 
+	{
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+		 
+#if 0	 
+		struct ieee80211_security sec = {
+			.flags = SEC_ENABLED,
+			.enabled = value,
+		};
+ 		ieee->drop_unencrypted = value;
+		/* We only change SEC_LEVEL for open mode. Others
+		 * are set by ipw_wpa_set_encryption.
+		 */
+		if (!value) {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_0;
+		}
+		else {
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_1;
+		}
+		if (ieee->set_security)
+			ieee->set_security(ieee->dev, &sec);
+#endif		
+		break;
+
+	}
+	case IEEE_PARAM_PRIVACY_INVOKED:	
+		
+		//ieee->privacy_invoked=value;
+		
+		break;
+
+	case IEEE_PARAM_AUTH_ALGS:
+		
+		ret = wpa_set_auth_algs(dev, value);
+		
+		break;
+
+	case IEEE_PARAM_IEEE_802_1X:
+		
+		//ieee->ieee802_1x=value;		
+		
+		break;
+		
+	case IEEE_PARAM_WPAX_SELECT:
+		
+		// added for WPA2 mixed mode
+		//printk(KERN_WARNING "------------------------>wpax value = %x\n", value);
+		/*
+		spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
+		ieee->wpax_type_set = 1;
+		ieee->wpax_type_notify = value;
+		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
+		*/
+		
+		break;
+
+	default:		
+
+
+		
+		ret = -EOPNOTSUPP;
+
+		
+		break;
+	
+	}
+
+	return ret;
+	
+}
+
+static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
+{	
+	int ret = 0;
+	_adapter *padapter = netdev_priv(dev);
+
+	switch (command)
+	{
+		case IEEE_MLME_STA_DEAUTH:
+
+			if(!rtw_set_802_11_disassociate(padapter))
+				ret = -1;		
+			
+			break;
+
+		case IEEE_MLME_STA_DISASSOC:
+		
+			if(!rtw_set_802_11_disassociate(padapter))
+				ret = -1;		
+	
+			break;
+
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	return ret;
+	
+}
+
+static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	uint ret=0;
+
+	//down(&ieee->wx_sem);	
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer){
+		ret = -EINVAL;
+		goto out;
+	}
+	
+	param = (struct ieee_param *)_rtw_malloc(p->length);
+	if (param == NULL)
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	if (copy_from_user(param, p->pointer, p->length))
+	{
+		_rtw_mfree((u8*)param, 0);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	switch (param->cmd) {
+
+	case IEEE_CMD_SET_WPA_PARAM:
+		ret = wpa_set_param(dev, param->u.wpa_param.name, param->u.wpa_param.value);
+		break;
+
+	case IEEE_CMD_SET_WPA_IE:
+		//ret = wpa_set_wpa_ie(dev, param, p->length);
+		ret =  rtw_set_wpa_ie((_adapter *)netdev_priv(dev), (char*)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
+		break;
+
+	case IEEE_CMD_SET_ENCRYPTION:
+		ret = wpa_set_encryption(dev, param, p->length);
+		break;
+
+	case IEEE_CMD_MLME:
+		ret = wpa_mlme(dev, param->u.mlme.command, param->u.mlme.reason_code);
+		break;
+
+	default:
+		printk("Unknown WPA supplicant request: %d\n", param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
+		
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	_rtw_mfree((u8 *)param, sizeof(struct ieee_param));
+	
+out:
+	
+	//up(&ieee->wx_sem);
+	
+	return ret;
+	
+}
+
+#ifdef CONFIG_AP_MODE
+static u8 set_pairwise_key(_adapter *padapter, struct sta_info *psta)
+{
+	struct cmd_obj*			ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
+	u8	res=_SUCCESS;
+
+	ph2c = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct cmd_obj));
+	if ( ph2c == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm*)_rtw_zmalloc(sizeof(struct set_stakey_parm));
+	if(psetstakey_para==NULL){
+		_rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		res=_FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+
+
+	psetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;
+
+	_rtw_memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);	
+	
+	_rtw_memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
+
+	
+	rtw_enqueue_cmd(pcmdpriv, ph2c);	
+
+exit:
+
+	return res;
+	
+}
+
+static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
+{
+	u8 keylen;
+	struct cmd_obj* pcmd;
+	struct setkey_parm *psetkeyparm;
+	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);	
+	int res=_SUCCESS;
+
+	printk("%s\n", __FUNCTION__);
+	
+	pcmd = (struct cmd_obj*)_rtw_zmalloc(sizeof(struct	cmd_obj));
+	if(pcmd==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+	psetkeyparm=(struct setkey_parm*)_rtw_zmalloc(sizeof(struct setkey_parm));
+	if(psetkeyparm==NULL){
+		_rtw_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
+		res= _FAIL;
+		goto exit;
+	}
+
+	//_rtw_memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+		
+	psetkeyparm->keyid=(u8)keyid;
+
+	psetkeyparm->algorithm = alg;
+
+	switch(alg)
+	{
+		case _WEP40_:					
+			keylen = 5;
+			break;
+		case _WEP104_:
+			keylen = 13;			
+			break;
+		case _TKIP_:
+		case _TKIP_WTMIC_:		
+		case _AES_:
+			keylen = 16;		
+		default:
+			keylen = 16;		
+	}
+
+	_rtw_memcpy(&(psetkeyparm->key[0]), key, keylen);
+	
+	pcmd->cmdcode = _SetKey_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;   
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));  
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+
+	_rtw_init_listhead(&pcmd->list);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return _SUCCESS;
+	
+
+}
+
+static int set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid)
+{	
+	u8 alg;
+
+	switch(keylen)
+	{
+		case 5:
+			alg =_WEP40_;			
+			break;
+		case 13:
+			alg =_WEP104_;			
+			break;
+		default:
+			alg =_NO_PRIVACY_;			
+	}
+
+	return set_group_key(padapter, key, alg, keyid);
+
+}
+
+static void add_RATid(_adapter *padapter, struct sta_info *psta)
+{	
+	int i;
+	u32 init_rate=0;
+	unsigned char	 sta_band, raid, shortGIrate = _FALSE;
+	unsigned char limit;	
+	unsigned int tx_ra_bitmap=0;
+	struct ht_priv	*psta_ht = NULL;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	
+	if(psta)
+		psta_ht = &psta->htpriv;
+	else
+		return;
+	
+	//b/g mode ra_bitmap  
+	for (i=0; i<sizeof(psta->bssrateset); i++)
+	{
+		if (psta->bssrateset[i])
+			tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
+	}
+
+	//n mode ra_bitmap
+	if(psta_ht->ht_option) 
+	{
+		if(pHalData->rf_type == RF_2T2R)
+			limit=16;// 2R
+		else
+			limit=8;// 1R
+
+		for (i=0; i<limit; i++) {
+			if (psta_ht->ht_cap.supp_mcs_set[i/8] & BIT(i%8))
+				tx_ra_bitmap |= BIT(i+12);
+		}
+
+		//max short GI rate
+		shortGIrate = psta_ht->sgi;
+	}
+
+
+#if 0//gtest
+	if(get_rf_mimo_mode(padapter) == RTL8712_RF_2T2R)
+	{
+		//is this a 2r STA?
+		if((pstat->tx_ra_bitmap & 0x0ff00000) != 0 && !(priv->pshare->has_2r_sta & BIT(pstat->aid)))
+		{
+			priv->pshare->has_2r_sta |= BIT(pstat->aid);
+			if(rtw_read16(padapter, 0x102501f6) != 0xffff)
+			{
+				rtw_write16(padapter, 0x102501f6, 0xffff);
+				reset_1r_sta_RA(priv, 0xffff);
+				Switch_1SS_Antenna(priv, 3);
+			}
+		}
+		else// bg or 1R STA? 
+		{ 
+			if((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) && pstat->ht_cap_len && priv->pshare->has_2r_sta == 0)
+			{
+				if(rtw_read16(padapter, 0x102501f6) != 0x7777)
+				{ // MCS7 SGI
+					rtw_write16(padapter, 0x102501f6,0x7777);
+					reset_1r_sta_RA(priv, 0x7777);
+					Switch_1SS_Antenna(priv, 2);
+				}
+			}
+		}
+		
+	}
+
+	if ((pstat->rssi_level < 1) || (pstat->rssi_level > 3)) 
+	{
+		if (pstat->rssi >= priv->pshare->rf_ft_var.raGoDownUpper)
+			pstat->rssi_level = 1;
+		else if ((pstat->rssi >= priv->pshare->rf_ft_var.raGoDown20MLower) ||
+			((priv->pshare->is_40m_bw) && (pstat->ht_cap_len) &&
+			(pstat->rssi >= priv->pshare->rf_ft_var.raGoDown40MLower) &&
+			(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))))
+			pstat->rssi_level = 2;
+		else
+			pstat->rssi_level = 3;
+	}
+
+	// rate adaptive by rssi
+	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) && pstat->ht_cap_len)
+	{
+		if ((get_rf_mimo_mode(priv) == MIMO_1T2R) || (get_rf_mimo_mode(priv) == MIMO_1T1R))
+		{
+			switch (pstat->rssi_level) {
+				case 1:
+					pstat->tx_ra_bitmap &= 0x100f0000;
+					break;
+				case 2:
+					pstat->tx_ra_bitmap &= 0x100ff000;
+					break;
+				case 3:
+					if (priv->pshare->is_40m_bw)
+						pstat->tx_ra_bitmap &= 0x100ff005;
+					else
+						pstat->tx_ra_bitmap &= 0x100ff001;
+
+					break;
+			}
+		}
+		else 
+		{
+			switch (pstat->rssi_level) {
+				case 1:
+					pstat->tx_ra_bitmap &= 0x1f0f0000;
+					break;
+				case 2:
+					pstat->tx_ra_bitmap &= 0x1f0ff000;
+					break;
+				case 3:
+					if (priv->pshare->is_40m_bw)
+						pstat->tx_ra_bitmap &= 0x000ff005;
+					else
+						pstat->tx_ra_bitmap &= 0x000ff001;
+
+					break;
+			}
+
+			// Don't need to mask high rates due to new rate adaptive parameters
+			//if (pstat->is_broadcom_sta)		// use MCS12 as the highest rate vs. Broadcom sta
+			//	pstat->tx_ra_bitmap &= 0x81ffffff;
+
+			// NIC driver will report not supporting MCS15 and MCS14 in asoc req
+			//if (pstat->is_rtl8190_sta && !pstat->is_2t_mimo_sta)
+			//	pstat->tx_ra_bitmap &= 0x83ffffff;		// if Realtek 1x2 sta, don't use MCS15 and MCS14
+		}
+	}
+	else if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11G) && isErpSta(pstat))
+	{
+		switch (pstat->rssi_level) {
+			case 1:
+				pstat->tx_ra_bitmap &= 0x00000f00;
+				break;
+			case 2:
+				pstat->tx_ra_bitmap &= 0x00000ff0;
+				break;
+			case 3:
+				pstat->tx_ra_bitmap &= 0x00000ff5;
+				break;
+		}
+	}
+	else 
+	{
+		pstat->tx_ra_bitmap &= 0x0000000d;
+	}
+
+	// disable tx short GI when station cannot rx MCS15(AP is 2T2R)
+	// disable tx short GI when station cannot rx MCS7 (AP is 1T2R or 1T1R)
+	// if there is only 1r STA and we are 2T2R, DO NOT mask SGI rate
+	if ((!(pstat->tx_ra_bitmap & 0x8000000) && (priv->pshare->has_2r_sta > 0) && (get_rf_mimo_mode(padapter) == RTL8712_RF_2T2R)) ||
+		 (!(pstat->tx_ra_bitmap & 0x80000) && (get_rf_mimo_mode(padapter) != RTL8712_RF_2T2R)))
+	{
+		pstat->tx_ra_bitmap &= ~BIT(28);	
+	}
+#endif
+
+	
+	if (tx_ra_bitmap & 0xffff000)
+		sta_band |= WIRELESS_11N | WIRELESS_11G | WIRELESS_11B;
+	else if (tx_ra_bitmap & 0xff0)
+		sta_band |= WIRELESS_11G |WIRELESS_11B;
+	else
+		sta_band |= WIRELESS_11B;
+
+
+	raid = networktype_to_raid(sta_band);	
+	init_rate = get_highest_rate_idx(tx_ra_bitmap&0x0fffffff)&0x3f;
+	if (shortGIrate==_TRUE)
+			init_rate |= BIT(6);
+	
+	if (psta->aid < 32) 
+	{
+		if(pHalData->fw_ractrl == _TRUE)
+		{
+			u8 arg = 0;
+
+			arg = psta->aid&0x1f;
+		
+			arg |= BIT(7);
+		
+			if (shortGIrate==_TRUE)
+				arg |= BIT(5);
+
+			tx_ra_bitmap |= ((raid<<28)&0xf0000000);
+
+			DBG_871X("update raid entry, mask=0x%x, arg=0x%x\n", tx_ra_bitmap, arg);
+
+			set_raid_cmd(padapter, tx_ra_bitmap, arg);		
+		
+		}
+		else
+		{
+			rtw_write8(padapter, (REG_INIDATA_RATE_SEL+psta->aid), init_rate);		
+		}
+
+
+		//set ra_id, init_rate
+		psta->raid = raid;
+		psta->init_rate = init_rate;
+			
+		//DBG_871X("Add id %d val %08x to ratr\n", psta->aid, tx_ra_bitmap);
+		
+	}
+	else 
+	{
+		DBG_871X("station aid %d exceed the max number\n", psta->aid);
+	}
+
+}
+
+static void update_bmc_sta(_adapter *padapter)
+{
+	_irqL	irqL;
+	u32 init_rate=0;
+	unsigned char	network_type, raid;
+	unsigned short para16;
+	int i, supportRateNum = 0;	
+	unsigned int tx_ra_bitmap=0;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;	
+	struct sta_info *psta = rtw_get_bcmc_stainfo(padapter);
+
+	if(psta)
+	{
+		psta->aid = 0;//default set to 0
+		psta->mac_id = psta->aid+4;		
+
+		psta->qos_option = 0;		
+		psta->htpriv.ht_option = 0;
+
+		psta->ieee8021x_blocked = 0;
+
+		_rtw_memset((void*)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
+
+		//psta->dot118021XPrivacy = _NO_PRIVACY_;//!!! remove it, because it has been set before this.
+
+
+
+		//prepare for add_RATid		
+		supportRateNum = rtw_get_rateset_len((u8*)&pcur_network->SupportedRates);
+		network_type = rtw_check_network_type((u8*)&pcur_network->SupportedRates, supportRateNum, 1);
+		
+		_rtw_memcpy(psta->bssrateset, &pcur_network->SupportedRates, supportRateNum);
+		psta->bssratelen = supportRateNum;
+
+		//b/g mode ra_bitmap  
+		for (i=0; i<supportRateNum; i++)
+		{	
+			if (psta->bssrateset[i])
+				tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
+		}
+
+		//force to b mode 
+		network_type = WIRELESS_11B;
+		tx_ra_bitmap = 0xf;
+		//tx_ra_bitmap = update_basic_rate(pcur_network->SupportedRates, supportRateNum);
+
+		raid = networktype_to_raid(network_type);
+		init_rate = get_highest_rate_idx(tx_ra_bitmap&0x0fffffff)&0x3f;
+		//if (shortGIrate==_TRUE)
+			//init_rate |= BIT(6);
+				
+		//DBG_871X("Add id %d val %08x to ratr for bmc sta\n", psta->aid, tx_ra_bitmap);
+
+		if(pHalData->fw_ractrl == _TRUE)
+		{
+			u8 arg = 0;
+
+			arg = psta->aid&0x1f;
+		
+			arg |= BIT(7);
+		
+			//if (shortGIrate==_TRUE)
+			//	arg |= BIT(5);
+
+			
+			tx_ra_bitmap |= ((raid<<28)&0xf0000000);
+			
+
+			DBG_871X("update_bmc_sta, mask=0x%x, arg=0x%x\n", tx_ra_bitmap, arg);
+
+			set_raid_cmd(padapter, tx_ra_bitmap, arg);		
+		
+		}
+		else
+		{
+			rtw_write8(padapter, (REG_INIDATA_RATE_SEL+psta->mac_id), init_rate);		
+		}
+
+		//set ra_id, init_rate
+		psta->raid = raid;
+		psta->init_rate = init_rate;
+	 
+		_enter_critical_bh(&psta->lock, &irqL);
+		psta->state = _FW_LINKED;
+		_exit_critical_bh(&psta->lock, &irqL);
+
+	}
+	else
+	{
+		printk("add_RATid_bmc_sta error!\n");
+	}
+		
+}
+
+static void update_sta_info(_adapter *padapter, struct sta_info *psta)
+{	
+	_irqL	irqL;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
+	struct ht_priv	*phtpriv_sta = &psta->htpriv;
+
+	//set intf_tag to if1
+	//psta->intf_tag = 0;
+
+	//notes: mac_id from 1+4, 0+4 for bmc sta
+	psta->mac_id = psta->aid+4;
+
+
+	if(psecuritypriv->dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
+		psta->ieee8021x_blocked = _TRUE;
+	else
+		psta->ieee8021x_blocked = _FALSE;
+	
+
+	//update sta's cap
+	
+	//ERP
+	VCS_update(padapter, psta);
+		
+	//HT related cap
+	if(phtpriv_sta->ht_option)
+	{
+		//check if sta supports rx ampdu
+		phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
+
+		//check if sta support s Short GI
+		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
+		{
+			phtpriv_sta->sgi = _TRUE;
+		}
+
+		// bwmode
+		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))
+		{
+			//phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_40;
+			phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
+			phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
+			
+		}		
+
+		psta->qos_option = _TRUE;
+		
+	}
+	else
+	{
+		phtpriv_sta->ampdu_enable = _FALSE;
+		
+		phtpriv_sta->sgi = _FALSE;
+		phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
+		phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	}
+
+	//Rx AMPDU
+	send_delba(padapter, 0, psta->hwaddr);// recipient
+	
+	//TX AMPDU
+	send_delba(padapter, 1, psta->hwaddr);// // originator
+	phtpriv_sta->agg_enable_bitmap = 0x0;//reset
+	phtpriv_sta->candidate_tid_bitmap = 0x0;//reset
+	
+
+	//todo: init other variables
+	
+	_rtw_memset((void*)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
+
+
+	//add ratid
+	add_RATid(padapter, psta);
+
+
+	_enter_critical_bh(&psta->lock, &irqL);
+	psta->state = _FW_LINKED;
+	_exit_critical_bh(&psta->lock, &irqL);
+	
+
+}
+
+static void start_bss_network(_adapter *padapter, u8 *pbuf)
+{
+	u8 *p;
+	u8 cur_channel, cur_bwmode, cur_ch_offset;
+	int ie_len;
+	u32	bcn_interval, xmitbcnDown;
+	u8	bxmitok = _FALSE;
+	int	retry=0;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);	
+	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork_mlmeext = &(pmlmeinfo->network);
+	
+	
+	//printk("%s\n", __FUNCTION__);
+
+	bcn_interval = pnetwork->Configuration.BeaconPeriod;	
+	cur_channel = pnetwork->Configuration.DSConfig;
+	cur_bwmode = HT_CHANNEL_WIDTH_20;;
+	cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	
+	//todo: update wmm, ht cap
+	//pmlmeinfo->WMM_enable;
+	//pmlmeinfo->HT_enable;
+	if(pmlmepriv->qospriv.qos_option)
+		pmlmeinfo->WMM_enable = _TRUE;
+
+	if(pmlmepriv->htpriv.ht_option)
+	{
+		pmlmeinfo->WMM_enable = _TRUE;
+		pmlmeinfo->HT_enable = _TRUE;
+	}
+	
+
+	if(pmlmepriv->cur_network.join_res != _TRUE) //setting only at  first time
+	{		
+		flush_all_cam_entry(padapter);	//clear CAM
+	}	
+
+	//set MSR to AP_Mode		
+	Set_NETYPE0_MSR(padapter, _HW_STATE_AP_);	
+		
+	//Set BSSID REG
+	rtw_write32(padapter, REG_BSSID, 
+					(pnetwork->MacAddress[0] | (pnetwork->MacAddress[1] << 8)  | 
+					(pnetwork->MacAddress[2] << 16) | (pnetwork->MacAddress[3] << 24)));	
+	rtw_write32(padapter, (REG_BSSID + 4), (pnetwork->MacAddress[4] | (pnetwork->MacAddress[5] << 8)));
+	
+	//Set RCR
+	//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
+	rtw_write32(padapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
+	//enable to rx data frame				
+	rtw_write16(padapter, REG_RXFLTMAP2, 0xFFFF);
+	//enable to rx ps-poll
+	rtw_write16(padapter, REG_RXFLTMAP1, 0x0400);
+
+	//Set EDCA param reg
+	rtw_write32(padapter, REG_EDCA_VO_PARAM, 0x002F3217);
+	rtw_write32(padapter, REG_EDCA_VI_PARAM, 0x005E4317);
+	rtw_write32(padapter, REG_EDCA_BE_PARAM, 0x00105320);
+	rtw_write32(padapter, REG_EDCA_BK_PARAM, 0x0000A444);
+
+	//Set Security
+	(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)? rtw_write8(padapter, REG_SECCFG, 0xcc): rtw_write8(padapter, REG_SECCFG, 0xcf);
+
+	//Beacon Control related register
+	rtw_write16(padapter, REG_BCN_INTERVAL, bcn_interval);
+
+	if(pmlmepriv->cur_network.join_res != _TRUE) //setting only at  first time
+	{
+		//disable dynamic functions, such as high power, DIG
+		Save_DM_Func_Flag(padapter);
+		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+
+		//config the initial gain under linking, need to write the BB registers
+		write_bbreg(padapter, rOFDM0_XAAGCCore1, 0x7f, 0x3e);
+		write_bbreg(padapter, rOFDM0_XBAGCCore1, 0x7f, 0x3e);
+	
+		//Beacon Control related register for first time 
+		rtw_write8(padapter, REG_BCNDMATIM, 0x02); // 2ms		
+		rtw_write8(padapter, REG_DRVERLYINT, 0x05);// 5ms
+		rtw_write8(padapter, REG_BCN_MAX_ERR, 0xFF);
+		rtw_write16(padapter, REG_BCNTCFG, 0x00);
+		rtw_write16(padapter, REG_TBTT_PROHIBIT, 0x6404);		
+	
+		//reset TSF		
+		rtw_write8(padapter, REG_DUAL_TSF_RST, BIT(0));
+
+		//enable TSF Function for if1
+		rtw_write8(padapter, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+			
+		//enable update TSF for if1
+		if(IS_NORMAL_CHIP(pHalData->VersionID))
+		{			
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));			
+		}
+		else
+		{
+			rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~(BIT(4)|BIT(5))));
+		}
+		
+	}
+	
+
+	//set channel, bwmode	
+	p = rtw_get_ie((pnetwork->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+	if( p && ie_len)
+	{
+		struct HT_info_element *pht_info = (struct HT_info_element *)(p+2);
+					
+		if ((pregpriv->cbw40_enable) &&	 (pht_info->infos[0] & BIT(2)))
+		{
+			//switch to the 40M Hz mode
+			//pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
+			cur_bwmode = HT_CHANNEL_WIDTH_40;
+			switch (pht_info->infos[0] & 0x3)
+			{
+				case 1:
+					//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+					break;
+			
+				case 3:
+					//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;					
+					break;
+				
+				default:
+					//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+					break;
+			}		
+						
+		}
+					
+	}
+
+	//TODO: need to judge the phy parameters on concurrent mode for single phy
+	//set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+	set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
+
+	DBG_871X("CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
+
+	//
+	pmlmeext->cur_channel = cur_channel;	
+	pmlmeext->cur_bwmode = cur_bwmode;
+	pmlmeext->cur_ch_offset = cur_ch_offset;	
+
+	//let pnetwork_mlmeext == pnetwork_mlme.
+	_rtw_memcpy(pnetwork_mlmeext, pnetwork, pnetwork->Length);
+
+	//issue beacon frame
+	do{	
+
+		issue_beacon(padapter);
+		
+		xmitbcnDown= rtw_read32(padapter, REG_TDECTRL);
+		if(xmitbcnDown & BCN_VALID ){
+			rtw_write32(padapter,REG_TDECTRL, xmitbcnDown | BCN_VALID  ); // write 1 to clear, Clear by sw
+			bxmitok = _TRUE;
+		}
+			
+	}while((_FALSE == bxmitok) &&((retry++)<100 ));
+
+	if(retry == 100)
+	{
+		DBG_871X("@@@@ %s issue_beacon failed...@@@@\n", __FUNCTION__);	
+	}
+	
+}
+
+static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len;
+	NDIS_802_11_WEP	 *pwep = NULL;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;	
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	printk("%s\n", __FUNCTION__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	//sizeof(struct ieee_param) = 64 bytes;
+	//if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		if (param->u.crypt.idx >= WEP_KEYS)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}	
+	}
+	else 
+	{		
+		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+		if(!psta)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}			
+	}
+
+	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
+	{
+		//todo:clear default encryption keys
+
+		printk("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
+		
+		goto exit;
+	}
+
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta==NULL))
+	{		
+		printk("r871x_set_encryption, crypt.alg = WEP\n");
+		
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+					
+		printk("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
+
+		if((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+			
+
+		if (wep_key_len > 0) 
+		{			
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
+
+		 	pwep =(NDIS_802_11_WEP *)_rtw_zmalloc(wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial));
+			if(pwep == NULL){
+				printk(" r871x_set_encryption: pwep allocate fail !!!\n");
+				goto exit;
+			}
+			
+		 	//_rtw_memset(pwep, 0, sizeof(NDIS_802_11_WEP));
+		
+		 	pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+			
+		}
+		
+		pwep->KeyIndex = wep_key_idx;
+
+		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if(param->u.crypt.set_tx)
+		{
+			printk("wep, set_tx=1\n");
+
+			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
+			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+			
+			if(pwep->KeyLength==13)
+			{
+				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
+				psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+			}
+
+		
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+			
+			_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;
+
+			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);		
+
+			
+		}
+		else
+		{
+			printk("wep, set_tx=0\n");
+			
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
+			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to cam
+					
+		      _rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;			
+
+			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);
+			
+		}
+
+		goto exit;
+		
+	}
+
+	
+	if(!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
+	{
+		if(param->u.crypt.set_tx ==1)
+		{
+			if(strcmp(param->u.crypt.alg, "WEP") == 0)
+			{
+				printk("%s, set group_key, WEP\n", __FUNCTION__);
+				
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+				if(param->u.crypt.key_len==13)
+				{						
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+				}
+				
+			}
+			else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+			{						
+				printk("%s, set group_key, TKIP\n", __FUNCTION__);
+				
+				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx-1].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+				//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+				//set mic key
+				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey.skey, &(param->u.crypt.key[16]), 8);
+				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+				psecuritypriv->busetkipkey = _TRUE;
+											
+			}
+			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+			{
+				printk("%s, set group_key, CCMP\n", __FUNCTION__);
+			
+				psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx-1].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+			}
+			else
+			{
+				printk("%s, set group_key, none\n", __FUNCTION__);
+				
+				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+			}
+
+			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+			psecuritypriv->binstallGrpkey = _TRUE;
+
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+								
+			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+			
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if(pbcmc_sta)
+			{
+				pbcmc_sta->ieee8021x_blocked = _FALSE;
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+			}	
+						
+		}
+
+		goto exit;
+		
+	}	
+
+	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
+	{
+		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		{
+			if(param->u.crypt.set_tx ==1)
+			{ 
+				_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					printk("%s, set pairwise key, WEP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _WEP40_;
+					if(param->u.crypt.key_len==13)
+					{						
+						psta->dot118021XPrivacy = _WEP104_;
+					}
+				}
+				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{						
+					printk("%s, set pairwise key, TKIP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _TKIP_;
+				
+					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					//set mic key
+					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = _TRUE;
+											
+				}
+				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+
+					printk("%s, set pairwise key, CCMP\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _AES_;
+				}
+				else
+				{
+					printk("%s, set pairwise key, none\n", __FUNCTION__);
+					
+					psta->dot118021XPrivacy = _NO_PRIVACY_;
+				}
+						
+				set_pairwise_key(padapter, psta);
+					
+				psta->ieee8021x_blocked = _FALSE;
+					
+			}			
+			else//group key???
+			{ 
+				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					
+					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+					if(param->u.crypt.key_len==13)
+					{						
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+					}
+				}
+				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{						
+					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx-1].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				
+					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					//set mic key
+					_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey.skey, &(param->u.crypt.key[16]), 8);
+					_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = _TRUE;
+											
+				}
+				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx-1].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				}
+				else
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+				}
+
+				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+				psecuritypriv->binstallGrpkey = _TRUE;	
+								
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+								
+				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+			
+				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+				if(pbcmc_sta)
+				{
+					pbcmc_sta->ieee8021x_blocked = _FALSE;
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+				}					
+
+			}
+			
+		}
+				
+	}
+
+exit:
+
+	if(pwep)
+	{
+		_rtw_mfree((u8 *)pwep, wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial));		
+	}	
+	
+	return ret;
+	
+}
+
+static int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret=0;
+	unsigned char *p;
+	struct sta_info *psta = NULL;
+	unsigned short cap, ht_cap=_FALSE;
+	unsigned int ie_len = 0;
+	int group_cipher, pairwise_cipher;	
+	unsigned char	channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];
+	int supportRateNum = 0;
+	unsigned char OUI1[] = {0x00, 0x50, 0xf2,0x01};
+	unsigned char wps_oui[4]={0x0,0x50,0xf2,0x04};
+	unsigned char WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};	
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;	
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	WLAN_BSSID_EX *pbss_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;	
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	unsigned char *ie = pbss_network->IEs;
+	unsigned char *pbuf = param->u.bcn_ie.buf;
+
+	/* SSID */
+	/* Supported rates */
+	/* DS Params */
+	/* WLAN_EID_COUNTRY */
+	/* ERP Information element */
+	/* Extended supported rates */
+	/* WPA/WPA2 */
+	/* Wi-Fi Wireless Multimedia Extensions */
+	/* ht_capab, ht_oper */
+	/* WPS IE */
+
+
+	printk("%s, len=%d\n", __FUNCTION__, len);
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+		return -EINVAL;
+
+
+	pbss_network->IELength = len-12-2;// 12 = param header, 2:no packed
+
+	if(pbss_network->IELength>MAX_IE_SZ)
+		return -ENOMEM;
+	
+
+	_rtw_memset(ie, 0, MAX_IE_SZ);
+	
+	_rtw_memcpy(ie, pbuf, pbss_network->IELength);
+
+
+	if(pbss_network->InfrastructureMode!=Ndis802_11APMode)
+		return -EINVAL;
+
+	pbss_network->Rssi = 0;
+
+	_rtw_memcpy(pbss_network->MacAddress, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	
+	//beacon interval
+	p = rtw_get_beacon_interval_from_ie(ie);//ie + 8;	// 8: TimeStamp, 2: Beacon Interval 2:Capability
+	pbss_network->Configuration.BeaconPeriod = *(unsigned short*)p;
+	
+	//capability
+	cap = *(unsigned short *)rtw_get_capability_from_ie(ie);
+
+	//SSID
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SSID_IE_, &ie_len, (pbss_network->IELength -_BEACON_IE_OFFSET_));
+	if(p && ie_len>0)
+	{
+		_rtw_memset(&pbss_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+		_rtw_memcpy(pbss_network->Ssid.Ssid, (p + 2), ie_len);
+		pbss_network->Ssid.SsidLength = ie_len;
+	}	
+
+	//chnnel
+	channel = 0;
+	pbss_network->Configuration.Length = 0;
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _DSSET_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if(p && ie_len>0)
+		channel = *(p + 2);
+
+	pbss_network->Configuration.DSConfig = channel;
+
+	
+	_rtw_memset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);
+	// get supported rates
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));	
+	if (p !=  NULL) 
+	{
+		_rtw_memcpy(supportRate, p+2, ie_len);	
+		supportRateNum = ie_len;
+	}
+	
+	//get ext_supported rates
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _EXT_SUPPORTEDRATES_IE_, &ie_len, pbss_network->IELength - _BEACON_IE_OFFSET_);	
+	if (p !=  NULL)
+	{
+		_rtw_memcpy(supportRate+supportRateNum, p+2, ie_len);
+		supportRateNum += ie_len;
+	
+	}
+
+	network_type = rtw_check_network_type(supportRate, supportRateNum, channel);
+
+	rtw_set_supported_rate(pbss_network->SupportedRates, network_type);
+
+
+	//parsing ERP_IE
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _ERPINFO_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if(p && ie_len>0)
+	{
+		ERP_IE_handler(padapter, (PNDIS_802_11_VARIABLE_IEs)p);
+	}
+
+	//parsing HT_CAP_IE
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if(p && ie_len>0)
+	{
+		ht_cap = _TRUE;
+		network_type |= WIRELESS_11N;
+
+		if(pHalData->rf_type == RF_1T1R)
+		{
+			struct ieee80211_ht_cap *pht_cap = (struct ieee80211_ht_cap *)(p+2);
+			
+			pht_cap->supp_mcs_set[0] = 0xff;
+			pht_cap->supp_mcs_set[1] = 0x0;				
+		}			
+		
+		_rtw_memcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);		
+	}
+
+	switch(network_type)
+	{
+		case WIRELESS_11B:
+			pbss_network->NetworkTypeInUse = Ndis802_11DS;
+			break;	
+		case WIRELESS_11G:
+		case WIRELESS_11BG:
+             case WIRELESS_11GN:
+		case WIRELESS_11BGN:
+			pbss_network->NetworkTypeInUse = Ndis802_11OFDM24;
+			break;
+		case WIRELESS_11A:
+			pbss_network->NetworkTypeInUse = Ndis802_11OFDM5;
+			break;
+		default :
+			pbss_network->NetworkTypeInUse = Ndis802_11OFDM24;
+			break;
+	}
+	
+	pmlmepriv->cur_network.network_type = network_type;
+
+	//update privacy/security
+	if (cap & BIT(4))
+		pbss_network->Privacy = 1;
+	else
+		pbss_network->Privacy = 0;
+
+	psecuritypriv->wpa_psk = 0;
+
+	//wpa2
+	group_cipher = 0; pairwise_cipher = 0;
+	psecuritypriv->wpa2_group_cipher = _NO_PRIVACY_;
+	psecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;	
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _RSN_IE_2_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));		
+	if(p && ie_len>0)
+	{
+		if(rtw_parse_wpa2_ie(p, ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			psecuritypriv->dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			
+			psecuritypriv->dot8021xalg = 1;//psk,  todo:802.1x
+			psecuritypriv->wpa_psk |= BIT(1);
+
+			switch(group_cipher)
+			{
+				case WPA_CIPHER_NONE:				
+				psecuritypriv->wpa2_group_cipher = _NO_PRIVACY_;
+				break;
+				case WPA_CIPHER_WEP40:				
+				psecuritypriv->wpa2_group_cipher = _WEP40_;
+				break;
+				case WPA_CIPHER_TKIP:				
+				psecuritypriv->wpa2_group_cipher = _TKIP_;
+				break;
+				case WPA_CIPHER_CCMP:				
+				psecuritypriv->wpa2_group_cipher = _AES_;				
+				break;
+				case WPA_CIPHER_WEP104:					
+				psecuritypriv->wpa2_group_cipher = _WEP104_;
+				break;
+			}
+
+			switch(pairwise_cipher)
+			{
+				case WPA_CIPHER_NONE:			
+				psecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;
+				break;
+				case WPA_CIPHER_WEP40:			
+				psecuritypriv->wpa2_pairwise_cipher = _WEP40_;
+				break;
+				case WPA_CIPHER_TKIP:				
+				psecuritypriv->wpa2_pairwise_cipher = _TKIP_;
+				break;
+				case WPA_CIPHER_CCMP:			
+				psecuritypriv->wpa2_pairwise_cipher = _AES_;
+				break;
+				case WPA_CIPHER_WEP104:					
+				psecuritypriv->wpa2_pairwise_cipher = _WEP104_;
+				break;
+			}
+			
+		}
+		
+	}
+
+	//wpa
+	ie_len = 0;
+	group_cipher = 0; pairwise_cipher = 0;
+	psecuritypriv->wpa_group_cipher = _NO_PRIVACY_;
+	psecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;	
+	for (p = ie + _BEACON_IE_OFFSET_; ;p += (ie_len + 2))
+	{
+		p = rtw_get_ie(p, _SSN_IE_1_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));		
+		if ((p) && (_rtw_memcmp(p+2, OUI1, 4)))
+		{
+			if(rtw_parse_wpa_ie(p, ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+			{
+				psecuritypriv->dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+				
+				psecuritypriv->dot8021xalg = 1;//psk,  todo:802.1x
+
+				psecuritypriv->wpa_psk |= BIT(0);
+
+				switch(group_cipher)
+				{
+					case WPA_CIPHER_NONE:					
+					psecuritypriv->wpa_group_cipher = _NO_PRIVACY_;
+					break;
+					case WPA_CIPHER_WEP40:					
+					psecuritypriv->wpa_group_cipher = _WEP40_;
+					break;
+					case WPA_CIPHER_TKIP:					
+					psecuritypriv->wpa_group_cipher = _TKIP_;
+					break;
+					case WPA_CIPHER_CCMP:					
+					psecuritypriv->wpa_group_cipher = _AES_;				
+					break;
+					case WPA_CIPHER_WEP104:					
+					psecuritypriv->wpa_group_cipher = _WEP104_;
+					break;
+				}
+
+				switch(pairwise_cipher)
+				{
+					case WPA_CIPHER_NONE:					
+					psecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;
+					break;
+					case WPA_CIPHER_WEP40:					
+					psecuritypriv->wpa_pairwise_cipher = _WEP40_;
+					break;
+					case WPA_CIPHER_TKIP:					
+					psecuritypriv->wpa_pairwise_cipher = _TKIP_;
+					break;
+					case WPA_CIPHER_CCMP:					
+					psecuritypriv->wpa_pairwise_cipher = _AES_;
+					break;
+					case WPA_CIPHER_WEP104:					
+					psecuritypriv->wpa_pairwise_cipher = _WEP104_;
+					break;
+				}
+				
+			}
+
+			break;
+			
+		}
+			
+		if ((p == NULL) || (ie_len == 0))
+		{
+				break;
+		}
+		
+	}
+
+	//wmm
+	ie_len = 0;
+	pmlmepriv->qospriv.qos_option = 0;
+	if(pregistrypriv->wmm_enable)
+	{
+		for (p = ie + _BEACON_IE_OFFSET_; ;p += (ie_len + 2))
+		{			
+			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));	
+			if((p) && _rtw_memcmp(p+2, WMM_PARA_IE, 6)) 
+			{
+				pmlmepriv->qospriv.qos_option = 1;	
+				break;				
+			}
+			
+			if ((p == NULL) || (ie_len == 0))
+			{
+				break;
+			}			
+		}		
+	}
+
+	pmlmepriv->htpriv.ht_option = 0;
+#ifdef CONFIG_80211N_HT
+	//ht_cap	
+	if(pregistrypriv->ht_enable && ht_cap==_TRUE)
+	{		
+		pmlmepriv->htpriv.ht_option = 1;
+		pmlmepriv->qospriv.qos_option = 1;
+
+		if(pregistrypriv->ampdu_enable==1)
+		{
+			pmlmepriv->htpriv.ampdu_enable = _TRUE;
+		}
+	}
+#endif
+
+
+	pbss_network->Length = get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX  *)pbss_network);
+
+	//issue beacon to start bss network
+	start_bss_network(padapter, (u8*)pbss_network);
+			
+
+	//alloc sta_info for ap itself
+	psta = rtw_get_stainfo(&padapter->stapriv, pbss_network->MacAddress);
+	if(!psta)
+	{
+		psta = rtw_alloc_stainfo(&padapter->stapriv, pbss_network->MacAddress);
+		if (psta == NULL) 
+		{ 
+			return -EINVAL;
+		}	
+	}	
+			
+	rtw_indicate_connect( padapter);
+
+	pmlmepriv->cur_network.join_res = _TRUE;//for check if already set beacon
+		
+	//update bc/mc sta_info
+	update_bmc_sta(padapter);
+
+	return ret;
+	
+}
+
+static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
+{
+	_irqL irqL;
+	int ret=0;	
+	struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	printk("rtw_add_sta(aid=%d)=" MACSTR "\n", param->u.add_sta.aid, MAC2STR(param->sta_addr));
+	
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)	
+	{
+		return -EINVAL;		
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if(psta)
+	{
+		printk("rtw_add_sta(), free has been added psta=%p\n", psta);
+		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		rtw_free_stainfo(padapter,  psta);		
+		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+
+		psta = NULL;
+	}	
+
+	psta = rtw_alloc_stainfo(pstapriv, param->sta_addr);	
+	if(psta)
+	{
+		int flags = param->u.add_sta.flags;			
+		
+		//printk("rtw_add_sta(), init sta's variables, psta=%p\n", psta);
+		
+		psta->aid = param->u.add_sta.aid;//aid=1~2007
+
+		_rtw_memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);
+		
+		
+		//check wmm cap.
+		if(WLAN_STA_WME&flags)
+			psta->qos_option = 1;
+		else
+			psta->qos_option = 0;
+
+		if(pmlmepriv->qospriv.qos_option == 0)	
+			psta->qos_option = 0;
+
+		
+#ifdef CONFIG_80211N_HT		
+		//chec 802.11n ht cap.
+		if(WLAN_STA_HT&flags)
+		{
+			psta->htpriv.ht_option = 1;
+			psta->qos_option = 1;
+			_rtw_memcpy((void*)&psta->htpriv.ht_cap, (void*)&param->u.add_sta.ht_cap, sizeof(struct ieee80211_ht_cap));
+		}
+		else		
+		{
+			psta->htpriv.ht_option = 0;
+		}
+		
+		if(pmlmepriv->htpriv.ht_option == 0)	
+			psta->htpriv.ht_option = 0;
+#endif		
+
+
+		update_sta_info(padapter, psta);
+		
+		
+	}
+	else
+	{
+		ret = -ENOMEM;
+	}	
+	
+	return ret;
+	
+}
+
+static int rtw_del_sta(struct net_device *dev, struct ieee_param *param)
+{
+	_irqL irqL;
+	int ret=0;	
+	struct sta_info *psta = NULL;
+	_adapter *padapter = (_adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	printk("rtw_del_sta=" MACSTR "\n", MAC2STR(param->sta_addr));
+		
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
+	{
+		return -EINVAL;		
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
+	{
+		return -EINVAL;	
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if(psta)
+	{
+		//printk("free psta=%p, aid=%d\n", psta, psta->aid);
+		
+		//tear down Rx AMPDU
+		send_delba(padapter, 0, psta->hwaddr);// recipient
+	
+		//tear down TX AMPDU
+		send_delba(padapter, 1, psta->hwaddr);// // originator
+		psta->htpriv.agg_enable_bitmap = 0x0;//reset
+		psta->htpriv.candidate_tid_bitmap = 0x0;//reset
+		
+		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		rtw_free_stainfo(padapter,  psta);		
+		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+
+		psta = NULL;
+	}
+	else
+	{
+		printk("rtw_del_sta(), sta has already been removed or never been added\n");
+		
+		//ret = -1;
+	}
+	
+	
+	return ret;
+	
+}
+
+static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	int ret=0;
+
+	//printk("%s\n", __FUNCTION__);
+
+	//if (p->length < sizeof(struct ieee_param) || !p->pointer){
+	if(!p->pointer){
+		ret = -EINVAL;
+		goto out;
+	}
+	
+	param = (struct ieee_param *)_rtw_malloc(p->length);
+	if (param == NULL)
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	if (copy_from_user(param, p->pointer, p->length))
+	{
+		_rtw_mfree((u8*)param, sizeof(struct ieee_param));
+		ret = -EFAULT;
+		goto out;
+	}
+
+	//printk("%s, cmd=%d\n", __FUNCTION__, param->cmd);
+
+	switch (param->cmd) 
+	{	
+		case RTL871X_HOSTAPD_ADD_STA:	
+			
+			ret = rtw_add_sta(dev, param);					
+			
+			break;
+
+		case RTL871X_HOSTAPD_REMOVE_STA:
+
+			ret = rtw_del_sta(dev, param);
+
+			break;
+	
+		case RTL871X_HOSTAPD_SET_BEACON:
+
+			ret = rtw_set_beacon(dev, param, p->length);
+
+			break;
+			
+		case RTL871X_SET_ENCRYPTION:
+
+			ret = rtw_set_encryption(dev, param, p->length);
+			
+			break;
+			
+		default:
+			printk("Unknown hostapd request: %d\n", param->cmd);
+			ret = -EOPNOTSUPP;
+			break;
+		
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+
+	_rtw_mfree((u8 *)param, p->length);
+	
+out:
+		
+	return ret;
+	
+}
+#endif
+
+//based on "driver_ipw" and for hostapd
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	//_adapter *padapter = netdev_priv(dev);
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int ret=0;
+
+	//down(&priv->wx_sem);
+
+	switch (cmd)
+	{
+	    case RTL_IOCTL_WPA_SUPPLICANT:	
+			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
+			break;
+#ifdef CONFIG_AP_MODE
+		case RTL_IOCTL_HOSTAPD:
+			ret = rtw_hostapd_ioctl(dev, &wrq->u.data);			
+			break;
+#endif
+	    default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	//up(&priv->wx_sem);
+	
+	return ret;
+	
+}
+
+static iw_handler rtw_handlers[] =
+{
+        NULL,                     			/* SIOCSIWCOMMIT */
+        rtw_wx_get_name,   	  	/* SIOCGIWNAME */
+        dummy,                    			/* SIOCSIWNWID */
+        dummy,                   			 /* SIOCGIWNWID */
+	 rtw_wx_set_freq,			/* SIOCSIWFREQ */
+        rtw_wx_get_freq,        	/* SIOCGIWFREQ */
+        rtw_wx_set_mode,       	 /* SIOCSIWMODE */
+        rtw_wx_get_mode,       	 /* SIOCGIWMODE */
+        dummy,//rtw_wx_set_sens,       /* SIOCSIWSENS */
+	 rtw_wx_get_sens,        		/* SIOCGIWSENS */
+        NULL,                     			/* SIOCSIWRANGE */
+        rtw_wx_get_range,	  	/* SIOCGIWRANGE */
+        rtw_wx_set_priv,			/* SIOCSIWPRIV */
+        NULL,                     			/* SIOCGIWPRIV */
+        NULL,                     			/* SIOCSIWSTATS */
+        NULL,                    			 /* SIOCGIWSTATS */
+        dummy,                   			 /* SIOCSIWSPY */
+        dummy,                   			 /* SIOCGIWSPY */
+        NULL,                    			 /* SIOCGIWTHRSPY */
+        NULL,                     			/* SIOCWIWTHRSPY */
+        rtw_wx_set_wap,      	  	/* SIOCSIWAP */
+        rtw_wx_get_wap,        		 /* SIOCGIWAP */
+        rtw_wx_set_mlme,                  /* request MLME operation; uses struct iw_mlme */
+        dummy,                     		/* SIOCGIWAPLIST -- depricated */
+        rtw_wx_set_scan,        	/* SIOCSIWSCAN */
+        rtw_wx_get_scan,        	/* SIOCGIWSCAN */
+        rtw_wx_set_essid,       	/* SIOCSIWESSID */
+        rtw_wx_get_essid,       	/* SIOCGIWESSID */
+        dummy,                    			/* SIOCSIWNICKN */
+        rtw_wx_get_nick,             		/* SIOCGIWNICKN */
+        NULL,                     			/* -- hole -- */
+        NULL,                    			 /* -- hole -- */
+	 rtw_wx_set_rate,			/* SIOCSIWRATE */
+        rtw_wx_get_rate,       		 /* SIOCGIWRATE */
+        dummy,                    			/* SIOCSIWRTS */
+        rtw_wx_get_rts,                    /* SIOCGIWRTS */
+        rtw_wx_set_frag,        		/* SIOCSIWFRAG */
+        rtw_wx_get_frag,       		 /* SIOCGIWFRAG */
+        dummy,                   			 /* SIOCSIWTXPOW */
+        dummy,                   			 /* SIOCGIWTXPOW */
+        dummy,//rtw_wx_set_retry,       /* SIOCSIWRETRY */
+        rtw_wx_get_retry,//          	/* SIOCGIWRETRY */
+        rtw_wx_set_enc,         		/* SIOCSIWENCODE */
+        rtw_wx_get_enc,         	/* SIOCGIWENCODE */
+        dummy,                    			/* SIOCSIWPOWER */
+        rtw_wx_get_power,            /* SIOCGIWPOWER */
+        NULL,			/*---hole---*/
+	 NULL, 			/*---hole---*/
+	 rtw_wx_set_gen_ie, 		/* SIOCSIWGENIE */
+	 NULL, 						/* SIOCGWGENIE */
+	 rtw_wx_set_auth,			/* SIOCSIWAUTH */
+	 NULL,						/* SIOCGIWAUTH */
+	 rtw_wx_set_enc_ext, 		/* SIOCSIWENCODEEXT */
+	 NULL,						/* SIOCGIWENCODEEXT */
+	 rtw_wx_set_pmkid, 						/* SIOCSIWPMKSA */
+	 NULL, 			 			/*---hole---*/
+		
+}; 
+
+static const struct iw_priv_args rtw_private_args[] = {
+	{
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "write32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "read32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3, 0, 0, "" // mp_ioctl
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x4,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x5,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "setpid"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x6,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
+	},	
+
+//#ifdef CONFIG_PLATFORM_MT53XX	
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "get_sensitivity"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x8,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_prob_req_ie"
+	},	
+	{
+		SIOCIWFIRSTPRIV + 0x9,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_assoc_req_ie"
+	},
+//#endif
+	{
+		SIOCIWFIRSTPRIV + 0xA,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "dbg"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xB,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "rfw"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xC,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "rfr"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xD,0,0, "wowlan_ctrl"
+	}
+
+};
+
+static iw_handler rtw_private_handler[] = 
+{
+	rtw_wx_write32,
+	rtw_wx_read32,
+	rtw_drvext_hdl,
+	rtw_mp_ioctl_hdl,
+	rtw_get_ap_info, /*for MM DTV platform*/
+	rtw_set_pid,
+	rtw_wps_start,	
+//#ifdef CONFIG_PLATFORM_MT53XX
+	rtw_wx_get_sensitivity,			//0x7
+	rtw_wx_set_mtk_wps_probe_ie,	//0x8
+	rtw_wx_set_mtk_wps_ie,			//0x9
+//#endif
+	rtw_dbg_port,					//0xa
+	r8192_wx_write_rf,				//0xb
+	r8192_wx_read_rf,				//0xc
+	rtw_wowlan_ctrl,				//0xd
+
+};
+
+#if WIRELESS_EXT >= 17	
+static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
+{
+       _adapter *padapter = netdev_priv(dev);
+	   struct iw_statistics *piwstats=&padapter->iwstats;
+	int tmp_level = 0;
+	int tmp_qual = 0;
+	int tmp_noise = 0;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != _TRUE)
+	{
+		piwstats->qual.qual = 0;
+		piwstats->qual.level = 0;
+		piwstats->qual.noise = 0;
+		//printk("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise);
+	}
+	else{
+		tmp_level =padapter->recvpriv.rssi; 
+		tmp_qual =padapter->recvpriv.signal_strength; //padapter->recvpriv.signal_qual;
+		tmp_noise =padapter->recvpriv.noise;		
+		//printk("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,padapter->recvpriv.rssi);
+
+		piwstats->qual.level = tmp_level;
+		piwstats->qual.qual = tmp_qual;
+		piwstats->qual.noise = tmp_noise;
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
+	piwstats->qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID | IW_QUAL_DBM;
+#else
+        piwstats->qual.updated = 0x0f;
+#endif
+
+       return &padapter->iwstats;
+}
+#endif
+
+struct iw_handler_def rtw_handlers_def =
+{
+	.standard = rtw_handlers,
+	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
+	.private = rtw_private_handler,
+	.private_args = (struct iw_priv_args *)rtw_private_args,
+	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
+ 	.num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),
+#if WIRELESS_EXT >= 17	
+	.get_wireless_stats = rtw_get_wireless_stats,
+#endif		
+};
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/mlme_linux.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/mlme_linux.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/mlme_linux.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/mlme_linux.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,555 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _MLME_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <mlme_osdep.h>
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/smp_lock.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <net/iw_handler.h>
+
+/*
+void sitesurvey_ctrl_handler(void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+
+	_rtw_sitesurvey_ctrl_handler(adapter);
+
+	_set_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 3000);
+}
+*/
+
+void rtw_join_timeout_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	_rtw_join_timeout_handler(adapter);
+}
+
+
+void _rtw_scan_timeout_handler (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+	rtw_scan_timeout_handler(adapter);
+}
+
+
+void _dynamic_check_timer_handlder (void *FunctionContext)
+{
+	_adapter *adapter = (_adapter *)FunctionContext;
+		 
+	dynamic_check_timer_handlder(adapter);	
+	_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);
+}
+
+
+void rtw_init_mlme_timer(_adapter *padapter)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev, rtw_join_timeout_handler, (pmlmepriv->nic_hdl));
+	//_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer), padapter->pnetdev, sitesurvey_ctrl_handler, (u8 *)(pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev, _rtw_scan_timeout_handler, (pmlmepriv->nic_hdl));
+
+	_init_timer(&(pmlmepriv->dynamic_chk_timer), padapter->pnetdev, _dynamic_check_timer_handlder, (u8 *)(pmlmepriv->nic_hdl));
+
+}
+
+extern void rtw_indicate_wx_assoc_event(_adapter *padapter);
+extern void rtw_indicate_wx_disassoc_event(_adapter *padapter);
+
+void rtw_os_indicate_connect(_adapter *adapter)
+{
+
+_func_enter_;	
+        rtw_indicate_wx_assoc_event(adapter);
+	netif_carrier_on(adapter->pnetdev);
+
+_func_exit_;	
+
+}
+
+static RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+
+void rtw_reset_securitypriv( _adapter *adapter )	
+{
+	 u8              backupPMKIDIndex = 0;
+ 	 u8              backupTKIPCountermeasure = 0x00;
+	 
+	if(adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
+   	{		 
+	        // Added by Albert 2009/02/18
+	        // We have to backup the PMK information for WiFi PMK Caching test item.
+	        //
+	        // Backup the btkip_countermeasure information.
+	        // When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds.
+	        
+	        _rtw_memset( &backupPMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+
+	        _rtw_memcpy( &backupPMKIDList[ 0 ], &adapter->securitypriv.PMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+	        backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
+	        backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
+
+	       _rtw_memset((unsigned char *)&adapter->securitypriv, 0, sizeof (struct security_priv));
+	       _init_timer(&(adapter->securitypriv.tkip_timer),adapter->pnetdev, rtw_use_tkipkey_handler, adapter);
+
+	       // Added by Albert 2009/02/18
+	       // Restore the PMK information to securitypriv structure for the following connection.
+	       _rtw_memcpy( &adapter->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+	       adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
+	       adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
+
+		adapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+		adapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;
+
+	   }
+	   else //reset values in securitypriv 
+	   {	   	
+		struct security_priv *psec_priv=&adapter->securitypriv;
+
+		psec_priv->dot11AuthAlgrthm =dot11AuthAlgrthm_Open;  //open system
+		psec_priv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		psec_priv->dot11PrivacyKeyIndex = 0;
+
+		psec_priv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+		psec_priv->dot118021XGrpKeyid = 1;
+
+		psec_priv->ndisauthtype = Ndis802_11AuthModeOpen;
+		psec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;	
+		psec_priv->wps_phase = _FALSE;
+	   	
+	   }
+}
+
+void rtw_os_indicate_disconnect( _adapter *adapter )
+{
+   //RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+  
+      
+_func_enter_;
+
+   	rtw_indicate_wx_disassoc_event(adapter);	
+   	netif_carrier_off(adapter->pnetdev);
+	rtw_reset_securitypriv(adapter); 
+
+_func_exit_;
+
+}
+
+void rtw_report_sec_ie(_adapter *adapter,u8 authmode,u8 *sec_ie)
+{
+		uint len;
+		u8 *buff,*p,i;
+		union iwreq_data wrqu;
+
+_func_enter_;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+rtw_report_sec_ie, authmode=%d\n", authmode));
+
+	buff = NULL;
+	if(authmode==_WPA_IE_ID_)
+	{
+		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("rtw_report_sec_ie, authmode=%d\n", authmode));
+		
+		buff = _rtw_zmalloc(IW_CUSTOM_MAX);
+		
+		//_rtw_memset(buff,0,IW_CUSTOM_MAX);
+		
+		p=buff;
+		
+		p+=sprintf(p,"ASSOCINFO(ReqIEs=");
+
+		len = sec_ie[1]+2;
+		len =  (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
+			
+		for(i=0;i<len;i++){
+			p+=sprintf(p,"%02x",sec_ie[i]);
+		}
+
+		p+=sprintf(p,")");
+		
+		_rtw_memset(&wrqu,0,sizeof(wrqu));
+		
+		wrqu.data.length=p-buff;
+		
+		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+		
+		wireless_send_event(adapter->pnetdev,IWEVCUSTOM,&wrqu,buff);
+
+		if(buff)
+		    _rtw_mfree(buff, IW_CUSTOM_MAX);
+		
+	}
+
+_func_exit_;
+
+}
+
+void _survey_timer_hdl (void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	
+	survey_timer_hdl(padapter);
+}
+
+void _link_timer_hdl (void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	link_timer_hdl(padapter);
+}
+
+void _addba_timer_hdl(void *FunctionContext)
+{
+	struct sta_info *psta = (struct sta_info *)FunctionContext;
+	addba_timer_hdl(psta);
+}
+
+void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta)
+{
+
+	_init_timer(&psta->addba_retry_timer, padapter->pnetdev, _addba_timer_hdl, psta);
+}
+
+/*
+void _reauth_timer_hdl(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	reauth_timer_hdl(padapter);
+}
+
+void _reassoc_timer_hdl(void *FunctionContext)
+{
+	_adapter *padapter = (_adapter *)FunctionContext;
+	reassoc_timer_hdl(padapter);
+}
+*/
+
+void init_mlme_ext_timer(_adapter *padapter)
+{	
+	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	_init_timer(&pmlmeext->survey_timer, padapter->pnetdev, _survey_timer_hdl, padapter);
+	_init_timer(&pmlmeext->link_timer, padapter->pnetdev, _link_timer_hdl, padapter);
+	//_init_timer(&pmlmeext->ADDBA_timer, padapter->pnetdev, _addba_timer_hdl, padapter);
+
+	//_init_timer(&pmlmeext->reauth_timer, padapter->pnetdev, _reauth_timer_hdl, padapter);
+	//_init_timer(&pmlmeext->reassoc_timer, padapter->pnetdev, _reassoc_timer_hdl, padapter);
+}
+
+
+#ifdef CONFIG_HOSTAPD_MLME
+
+static void mgnt_xmit_cb(struct urb *urb)
+{	
+	struct sk_buff *skb = (struct sk_buff *)urb->context;
+
+	//printk("%s\n", __FUNCTION__);
+
+
+	dev_kfree_skb_any(skb);
+	
+}
+
+static int mgnt_xmit_entry(struct sk_buff *skb, struct net_device *pnetdev)
+{
+	u16 fc;
+	int rc, len, pipe;	
+	unsigned int bmcst, tid, qsel;
+	struct sk_buff *pxmit_skb;
+	struct urb *urb;
+	unsigned char *pxmitbuf;
+	struct tx_desc *ptxdesc;
+	struct ieee80211_hdr *tx_hdr;
+	struct hostapd_priv *phostapdpriv = netdev_priv(pnetdev);
+	_adapter *padapter = (_adapter *)phostapdpriv->padapter;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	struct dvobj_priv *pdvobj = &padapter->dvobjpriv;	
+
+	
+	//printk("%s\n", __FUNCTION__);
+
+	
+	len = skb->len;
+	tx_hdr = (struct ieee80211_hdr *)(skb->data);
+	fc = le16_to_cpu(tx_hdr->frame_ctl);
+	bmcst = IS_MCAST(tx_hdr->addr1);
+
+	if ((fc & IEEE80211_FCTL_FTYPE) != IEEE80211_FTYPE_MGMT)
+		goto _exit;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+	pxmit_skb = dev_alloc_skb(len + TXDESC_SIZE);			
+#else			
+	pxmit_skb = netdev_alloc_skb(pnetdev, len + TXDESC_SIZE);
+#endif		
+
+	if(!pxmit_skb)
+		goto _exit;
+
+	pxmitbuf = pxmit_skb->data;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		goto _exit;
+	}
+
+	// ----- fill tx desc -----	
+	ptxdesc = (struct tx_desc *)pxmitbuf;	
+	_rtw_memset(ptxdesc, 0, sizeof(*ptxdesc));
+		
+	//offset 0	
+	ptxdesc->txdw0 |= cpu_to_le32(len&0x0000ffff); 
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+
+	if(bmcst)	
+	{
+		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
+	}	
+
+	//offset 4	
+	ptxdesc->txdw1 |= cpu_to_le32(0x00);//MAC_ID
+
+	ptxdesc->txdw1 |= cpu_to_le32((0x12<<QSEL_SHT)&0x00001f00);
+
+	ptxdesc->txdw1 |= cpu_to_le32((0x06<< 16) & 0x000f0000);//b mode
+
+	//offset 8			
+
+	//offset 12		
+	ptxdesc->txdw3 |= cpu_to_le32((le16_to_cpu(tx_hdr->seq_ctl)<<16)&0xffff0000);
+
+	//offset 16		
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+		
+	//offset 20
+
+	cal_txdesc_chksum(ptxdesc);
+	// ----- end of fill tx desc -----
+
+	//
+	skb_put(pxmit_skb, len + TXDESC_SIZE);
+	pxmitbuf = pxmitbuf + TXDESC_SIZE;
+	_rtw_memcpy(pxmitbuf, skb->data, len);
+
+	//printk("mgnt_xmit, len=%x\n", pxmit_skb->len);
+
+
+	// ----- prepare urb for submit -----
+	
+	//translate DMA FIFO addr to pipehandle		
+	//pipe = ffaddr2pipehdl(pdvobj, MGT_QUEUE_INX);
+	pipe = usb_sndbulkpipe(pdvobj->pusbdev, pHalData->Queue2EPNum[(u8)MGT_QUEUE_INX]&0x0f);
+	
+	usb_fill_bulk_urb(urb, pdvobj->pusbdev, pipe,
+			  pxmit_skb->data, pxmit_skb->len, mgnt_xmit_cb, pxmit_skb);
+	
+	urb->transfer_flags |= URB_ZERO_PACKET;
+	usb_anchor_urb(urb, &phostapdpriv->anchored);
+	rc = usb_submit_urb(urb, GFP_ATOMIC);
+	if (rc < 0) {
+		usb_unanchor_urb(urb);
+		kfree_skb(skb);
+	}
+	usb_free_urb(urb);
+
+	
+_exit:	
+	
+	dev_kfree_skb_any(skb);
+
+	return 0;
+	
+}
+
+static int mgnt_netdev_open(struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = netdev_priv(pnetdev);
+
+	printk("mgnt_netdev_open: MAC Address:" MACSTR "\n", MAC2STR(pnetdev->dev_addr));
+
+
+	init_usb_anchor(&phostapdpriv->anchored);
+	
+ 	if(!netif_queue_stopped(pnetdev))
+      		netif_start_queue(pnetdev);
+	else
+		netif_wake_queue(pnetdev);
+
+
+	netif_carrier_on(pnetdev);
+		
+	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x0100);//only excluding beacon 
+		
+	return 0;	
+}
+static int mgnt_netdev_close(struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = netdev_priv(pnetdev);
+
+	printk("%s\n", __FUNCTION__);
+
+	usb_kill_anchored_urbs(&phostapdpriv->anchored);
+
+	netif_carrier_off(pnetdev);
+
+	if (!netif_queue_stopped(pnetdev))
+		netif_stop_queue(pnetdev);
+	
+	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x3f3f);
+	
+	return 0;	
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtl871x_mgnt_netdev_ops = {
+	.ndo_open = mgnt_netdev_open,
+       .ndo_stop = mgnt_netdev_close,
+       .ndo_start_xmit = mgnt_xmit_entry,
+       //.ndo_set_mac_address = r871x_net_set_mac_address,
+       //.ndo_get_stats = r871x_net_get_stats,
+       //.ndo_do_ioctl = r871x_mp_ioctl,
+};
+#endif
+
+int hostapd_mode_init(_adapter *padapter)
+{
+	unsigned char mac[ETH_ALEN];
+	struct hostapd_priv *phostapdpriv;
+	struct net_device *pnetdev;
+	
+	pnetdev = alloc_etherdev(sizeof(struct hostapd_priv));	
+	if (!pnetdev)
+	   return -ENOMEM;
+
+	//SET_MODULE_OWNER(pnetdev);
+       ether_setup(pnetdev);
+
+	//pnetdev->type = ARPHRD_IEEE80211;
+	
+	phostapdpriv = netdev_priv(pnetdev);
+	phostapdpriv->pmgnt_netdev = pnetdev;
+	phostapdpriv->padapter= padapter;
+	padapter->phostapdpriv = phostapdpriv;
+	
+	//pnetdev->init = NULL;
+	
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+
+	printk("register rtl871x_mgnt_netdev_ops to netdev_ops\n");
+
+	pnetdev->netdev_ops = &rtl871x_mgnt_netdev_ops;
+	
+#else
+
+	pnetdev->open = mgnt_netdev_open;
+
+	pnetdev->stop = mgnt_netdev_close;	
+	
+	pnetdev->hard_start_xmit = mgnt_xmit_entry;
+	
+	//pnetdev->set_mac_address = r871x_net_set_mac_address;
+	
+	//pnetdev->get_stats = r871x_net_get_stats;
+
+	//pnetdev->do_ioctl = r871x_mp_ioctl;
+	
+#endif
+
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */	
+
+	//pnetdev->wireless_handlers = NULL;
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	pnetdev->features |= NETIF_F_IP_CSUM;
+#endif	
+
+	
+	
+	if(dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
+	{
+		printk("hostapd_mode_init(): dev_alloc_name, fail! \n");		
+	}
+
+
+	//SET_NETDEV_DEV(pnetdev, pintfpriv->udev);
+
+
+	mac[0]=0x00;
+	mac[1]=0xe0;
+	mac[2]=0x4c;
+	mac[3]=0x87;
+	mac[4]=0x11;
+	mac[5]=0x12;
+				
+	_rtw_memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+	
+
+	netif_carrier_off(pnetdev);
+
+
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0)
+	{
+		printk("hostapd_mode_init(): register_netdev fail!\n");
+		
+		if(pnetdev)
+      		{	 
+			free_netdev(pnetdev);
+      		}
+	}
+	
+	return 0;
+	
+}
+
+void hostapd_mode_unload(_adapter *padapter)
+{
+	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;
+	struct net_device *pnetdev = phostapdpriv->pmgnt_netdev;
+
+	unregister_netdev(pnetdev);
+	free_netdev(pnetdev);
+	
+}
+
+#endif
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/os_intfs.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/os_intfs.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/os_intfs.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/os_intfs.c	2011-04-26 13:05:49.000000000 +0800
@@ -0,0 +1,1278 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _OS_INTFS_C_
+
+#include <drv_conf.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+ 
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <xmit_osdep.h>
+#include <recv_osdep.h>
+#include <hal_init.h>
+#include <rtw_ioctl.h>
+
+#ifdef CONFIG_SDIO_HCI
+#include <sdio_osintf.h>
+#include <linux/mmc/sdio_func.h> 
+#include <linux/mmc/sdio_ids.h>
+#endif
+
+#ifdef CONFIG_USB_HCI
+#include <usb_osintf.h>
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("realtek wireless lan driver");
+MODULE_AUTHOR("...");
+
+/* module param defaults */
+int rtw_chip_version = VERSION_TEST_CHIP_88C;
+int rtw_rfintfs = HWPI;
+int rtw_lbkmode = 0;//RTL8712_AIR_TRX;
+#ifdef CONFIG_SDIO_HCI
+int rtw_hci = RTL8192C_SDIO;
+#endif
+#ifdef CONFIG_USB_HCI
+int rtw_hci = RTL8192C_USB;
+#endif
+
+int rtw_network_mode = Ndis802_11IBSS;//Ndis802_11Infrastructure;//infra, ad-hoc, auto	  
+//NDIS_802_11_SSID	ssid;
+int rtw_channel = 1;//ad-hoc support requirement 
+int rtw_wireless_mode = WIRELESS_11BG;
+int rtw_vrtl_carrier_sense = AUTO_VCS;
+int rtw_vcs_type = RTS_CTS;//*
+int rtw_rts_thresh = 2347;//*
+int rtw_frag_thresh = 2346;//*
+int rtw_preamble = PREAMBLE_LONG;//long, short, auto
+int rtw_scan_mode = 1;//active, passive
+int rtw_adhoc_tx_pwr = 1;
+int rtw_soft_ap = 0;
+//int smart_ps = 1;  
+//#ifdef CONFIG_BEST_BATTERYLIFE
+#ifdef CONFIG_POWER_SAVING
+int rtw_power_mgnt = 1;
+#else
+int rtw_power_mgnt = PS_MODE_ACTIVE;
+#endif	
+
+int rtw_radio_enable = 1;
+int rtw_long_retry_lmt = 7;
+int rtw_short_retry_lmt = 7;
+int rtw_busy_thresh = 40;
+//int qos_enable = 0; //*
+int rtw_ack_policy = NORMAL_ACK;
+int rtw_mp_mode = 0;	
+int rtw_software_encrypt = 0;
+int rtw_software_decrypt = 0;	  
+ 
+int rtw_wmm_enable = 1;// default is set to enable the wmm.
+int rtw_uapsd_enable = 0;	  
+int rtw_uapsd_max_sp = NO_LIMIT;
+int rtw_uapsd_acbk_en = 0;
+int rtw_uapsd_acbe_en = 0;
+int rtw_uapsd_acvi_en = 0;
+int rtw_uapsd_acvo_en = 0;
+	
+#ifdef CONFIG_80211N_HT
+int rtw_ht_enable = 1;
+int rtw_cbw40_enable = 1;
+int rtw_ampdu_enable = 1;//for enable tx_ampdu,
+                                        // 0:disable
+                                        // 1:enable when wifi_spec=0, disable when wifi_spec=1
+                                        // 2:force enable whatever wifi_spec=1 or wifi_spec=0
+#endif
+//int rtw_rf_config = RF_1T2R;  // 1T2R	
+int rtw_rf_config = RF_819X_MAX_TYPE;  //auto
+int rtw_low_power = 0;
+
+#ifdef CONFIG_WIFI_TEST
+int wifi_spec = 1;//for wifi test
+#else
+int wifi_spec = 0;//for wifi test
+#endif
+
+int channel_plan = RT_CHANNEL_DOMAIN_MAX;
+
+#ifdef CONFIG_BT_COEXIST
+int bt_iso = 2;// 0:Low, 1:High, 2:From Efuse
+int bt_sco = 3;// 0:Idle, 1:None-SCO, 2:SCO, 3:From Counter, 4.Busy, 5.OtherBusy
+int bt_ampdu =1 ;// 0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU.
+#endif
+int AcceptAddbaReq = _TRUE;// 0:Reject AP's Add BA req, 1:Accept AP's Add BA req.
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+int  antdiv_cfg = 2; // 0:OFF , 1:ON, 2:decide by Efuse config
+#endif
+#ifdef CONFIG_USB_AUTOSUSPEND
+int enusbss = 1;//0:disable,1:enable
+#else
+int enusbss = 0;//0:disable,1:enable
+#endif
+
+int hwpdn_mode=2;//0:disable,1:enable,2: by EFUSE config
+
+#ifdef CONFIG_HW_PWRP_DETECTION
+int hwpwrp_detect = 1; 
+#else
+int hwpwrp_detect = 0; //HW power  ping detect 0:disable , 1:enable
+#endif
+char* rtw_initmac = 0;  // temp mac address if users want to use instead of the mac address in Efuse
+
+module_param(rtw_initmac, charp, 0644);
+module_param(rtw_chip_version, int, 0644);
+module_param(rtw_rfintfs, int, 0644);
+module_param(rtw_lbkmode, int, 0644);
+module_param(rtw_hci, int, 0644);
+module_param(rtw_network_mode, int, 0644);
+module_param(rtw_channel, int, 0644);
+module_param(rtw_mp_mode, int, 0644);
+module_param(rtw_wmm_enable, int, 0644);
+module_param(rtw_vrtl_carrier_sense, int, 0644);
+module_param(rtw_vcs_type, int, 0644);
+module_param(rtw_busy_thresh, int, 0644);
+#ifdef CONFIG_80211N_HT
+module_param(rtw_ht_enable, int, 0644);
+module_param(rtw_cbw40_enable, int, 0644);
+module_param(rtw_ampdu_enable, int, 0644);
+#endif
+module_param(rtw_rf_config, int, 0644);
+module_param(rtw_power_mgnt, int, 0644);
+module_param(rtw_low_power, int, 0644);
+module_param(wifi_spec, int, 0644);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+module_param(antdiv_cfg, int, 0644);
+#endif
+
+module_param(enusbss, int, 0644);
+module_param(hwpdn_mode, int, 0644);
+module_param(hwpwrp_detect, int, 0644);
+
+#ifdef CONFIG_R871X_TEST
+int start_pseudo_adhoc(_adapter *padapter);
+int stop_pseudo_adhoc(_adapter *padapter);
+#endif
+
+extern void rtw_dev_unload(_adapter *padapter);
+
+
+u32 rtw_start_drv_threads(_adapter *padapter);
+void rtw_stop_drv_threads (_adapter *padapter);
+u8 rtw_init_drv_sw(_adapter *padapter);
+u8 rtw_free_drv_sw(_adapter *padapter);
+
+
+static uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev);
+static int netdev_open (struct net_device *pnetdev);
+static int netdev_close (struct net_device *pnetdev);
+
+//#ifdef RTK_DMP_PLATFORM
+#ifdef CONFIG_PROC_DEBUG
+#define RTL8192C_PROC_NAME "rtl819xC"
+#define RTL8192D_PROC_NAME "rtl819xD"
+static char rtw_proc_name[IFNAMSIZ];
+static struct proc_dir_entry *rtw_proc = NULL;
+static int	rtw_proc_cnt = 0;
+
+void rtw_proc_init_one(struct net_device *dev)
+{
+	struct proc_dir_entry *dir_dev = NULL;
+	struct proc_dir_entry *entry=NULL;
+	_adapter	*padapter = netdev_priv(dev);
+
+	if(rtw_proc == NULL)
+	{
+		if(padapter->chip_type == RTL8188C_8192C)
+		{
+			_rtw_memcpy(rtw_proc_name, RTL8192C_PROC_NAME, sizeof(RTL8192C_PROC_NAME));
+		}
+		else if(padapter->chip_type == RTL8192D)
+		{
+			_rtw_memcpy(rtw_proc_name, RTL8192D_PROC_NAME, sizeof(RTL8192D_PROC_NAME));
+		}
+
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
+#else
+		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
+#endif
+		if (rtw_proc == NULL) {
+			printk(KERN_ERR "Unable to create rtw_proc directory\n");
+			return;
+		}
+	}
+
+	padapter->dir_dev = create_proc_entry(dev->name, 
+					  S_IFDIR | S_IRUGO | S_IXUGO, 
+					  rtw_proc);
+
+	dir_dev = padapter->dir_dev;
+
+	if(dir_dev==NULL)
+	{
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+		remove_proc_entry(rtw_proc_name, proc_net);
+#else
+		remove_proc_entry(rtw_proc_name, init_net.proc_net);
+#endif		
+		rtw_proc = NULL;
+
+		printk(KERN_ERR "Unable to create dir_dev directory\n");
+		return;
+	}
+
+	rtw_proc_cnt++;
+
+	entry = create_proc_read_entry("write_reg", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_write_reg, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+	entry->write_proc = proc_set_write_reg;
+
+	entry = create_proc_read_entry("read_reg", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_read_reg, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+	entry->write_proc = proc_set_read_reg;
+
+	
+	entry = create_proc_read_entry("fwstate", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_fwstate, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+
+	entry = create_proc_read_entry("sec_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_sec_info, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+
+	entry = create_proc_read_entry("mlmext_state", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_mlmext_state, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+
+	entry = create_proc_read_entry("qos_option", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_qos_option, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+	entry = create_proc_read_entry("ht_option", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_ht_option, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+	entry = create_proc_read_entry("rf_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_rf_info, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+	
+	entry = create_proc_read_entry("ap_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_ap_info, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+	entry = create_proc_read_entry("adapter_state", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_adapter_state, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+	entry = create_proc_read_entry("trx_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_trx_info, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+#ifdef CONFIG_AP_MODE
+
+	entry = create_proc_read_entry("all_sta_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_all_sta_info, dev);				   
+	if (!entry) {
+		DBG_871X("Unable to create_proc_read_entry!\n"); 
+		return;
+	}
+
+#endif
+	
+}
+
+void rtw_proc_remove_one(struct net_device *dev)
+{
+	struct proc_dir_entry *dir_dev = NULL;
+	_adapter	*padapter = netdev_priv(dev);
+
+	dir_dev = padapter->dir_dev;
+	padapter->dir_dev = NULL;
+
+	if (dir_dev) {
+
+		remove_proc_entry("write_reg", dir_dev);
+		remove_proc_entry("read_reg", dir_dev);
+		remove_proc_entry("fwstate", dir_dev);
+		remove_proc_entry("sec_info", dir_dev);
+		remove_proc_entry("mlmext_state", dir_dev);
+		remove_proc_entry("qos_option", dir_dev);
+		remove_proc_entry("ht_option", dir_dev);
+		remove_proc_entry("rf_info", dir_dev);		
+		remove_proc_entry("ap_info", dir_dev);
+		remove_proc_entry("adapter_state", dir_dev);
+		remove_proc_entry("trx_info", dir_dev);
+
+#ifdef CONFIG_AP_MODE	
+		remove_proc_entry("all_sta_info", dir_dev);
+#endif		
+
+		remove_proc_entry(dev->name, rtw_proc);
+		dir_dev = NULL;
+		
+	}
+	else
+	{
+		return;
+	}
+
+	rtw_proc_cnt--;
+
+	if(rtw_proc_cnt == 0)
+	{
+		if(rtw_proc){
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+			remove_proc_entry(rtw_proc_name, proc_net);
+#else
+			remove_proc_entry(rtw_proc_name, init_net.proc_net);
+#endif		
+			rtw_proc = NULL;
+		}
+	}
+}
+#endif
+
+uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev)
+{
+       
+	uint status = _SUCCESS;
+	struct registry_priv  *registry_par = &padapter->registrypriv;
+
+_func_enter_;
+
+	registry_par->chip_version = (u8)rtw_chip_version;
+	registry_par->rfintfs = (u8)rtw_rfintfs;
+	registry_par->lbkmode = (u8)rtw_lbkmode;	
+	registry_par->hci = (u8)rtw_hci;
+	registry_par->network_mode  = (u8)rtw_network_mode;	
+
+     	_rtw_memcpy(registry_par->ssid.Ssid, "ANY", 3);
+	registry_par->ssid.SsidLength = 3;
+	
+	registry_par->channel = (u8)rtw_channel;
+	registry_par->wireless_mode = (u8)rtw_wireless_mode;
+	registry_par->vrtl_carrier_sense = (u8)rtw_vrtl_carrier_sense ;
+	registry_par->vcs_type = (u8)rtw_vcs_type;
+	registry_par->rts_thresh = (u16)rtw_rts_thresh;
+	registry_par->frag_thresh=(u16)rtw_frag_thresh;
+	registry_par->preamble = (u8)rtw_preamble;
+	registry_par->scan_mode = (u8)rtw_scan_mode;
+	registry_par->adhoc_tx_pwr = (u8)rtw_adhoc_tx_pwr;
+	registry_par->soft_ap=  (u8)rtw_soft_ap;
+	//registry_par->smart_ps =  (u8)smart_ps;  
+	registry_par->power_mgnt = (u8)rtw_power_mgnt;
+
+	registry_par->radio_enable = (u8)rtw_radio_enable;
+	registry_par->long_retry_lmt = (u8)rtw_long_retry_lmt;
+	registry_par->short_retry_lmt = (u8)rtw_short_retry_lmt;
+  	registry_par->busy_thresh = (u16)rtw_busy_thresh;
+  	//registry_par->qos_enable = (u8)qos_enable;
+    	registry_par->ack_policy = (u8)rtw_ack_policy;
+	registry_par->mp_mode = (u8)rtw_mp_mode;	
+	registry_par->software_encrypt = (u8)rtw_software_encrypt;
+	registry_par->software_decrypt = (u8)rtw_software_decrypt;	  
+
+	 //UAPSD
+	registry_par->wmm_enable = (u8)rtw_wmm_enable;
+	registry_par->uapsd_enable = (u8)rtw_uapsd_enable;	  
+	registry_par->uapsd_max_sp = (u8)rtw_uapsd_max_sp;
+	registry_par->uapsd_acbk_en = (u8)rtw_uapsd_acbk_en;
+	registry_par->uapsd_acbe_en = (u8)rtw_uapsd_acbe_en;
+	registry_par->uapsd_acvi_en = (u8)rtw_uapsd_acvi_en;
+	registry_par->uapsd_acvo_en = (u8)rtw_uapsd_acvo_en;
+
+#ifdef CONFIG_80211N_HT
+	registry_par->ht_enable = (u8)rtw_ht_enable;
+	registry_par->cbw40_enable = (u8)rtw_cbw40_enable;
+	registry_par->ampdu_enable = (u8)rtw_ampdu_enable;
+#endif
+
+	registry_par->rf_config = (u8)rtw_rf_config;
+	registry_par->low_power = (u8)rtw_low_power;
+
+	
+	registry_par->wifi_spec = (u8)wifi_spec;
+
+	registry_par->channel_plan = (u8)channel_plan;
+
+#ifdef CONFIG_BT_COEXIST
+	registry_par->bt_iso = (u8)bt_iso;
+	registry_par->bt_sco = (u8)bt_sco;
+	registry_par->bt_ampdu = (u8)bt_ampdu;
+#endif
+	registry_par->bAcceptAddbaReq = (u8)AcceptAddbaReq;
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	registry_par->antdiv_cfg = (u8)antdiv_cfg;
+#endif
+	
+#ifdef CONFIG_AUTOSUSPEND
+	registry_par->usbss_enable = (u8)enusbss;//0:disable,1:enable
+#endif
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	registry_par->hwpdn_mode = (u8)hwpdn_mode;//0:disable,1:enable,2:by EFUSE config
+	registry_par->hwpwrp_detect = (u8)hwpwrp_detect;//0:disable,1:enable
+#endif
+
+_func_exit_;
+
+	return status;
+
+
+}
+
+static int rtw_net_set_mac_address(struct net_device *pnetdev, void *p)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(pnetdev);
+	struct sockaddr *addr = p;
+	
+	if(padapter->bup == _FALSE)
+	{
+		//printk("r8711_net_set_mac_address(), MAC=%x:%x:%x:%x:%x:%x\n", addr->sa_data[0], addr->sa_data[1], addr->sa_data[2], addr->sa_data[3],
+		//addr->sa_data[4], addr->sa_data[5]);
+		//_rtw_memcpy(padapter->eeprompriv.mac_addr, addr->sa_data, ETH_ALEN);
+		_rtw_memcpy(pnetdev->dev_addr, addr->sa_data, ETH_ALEN);
+		//padapter->bset_hwaddr = _TRUE;
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	padapter->stats.tx_packets = pxmitpriv->tx_pkts;//pxmitpriv->tx_pkts++;
+	padapter->stats.rx_packets = precvpriv->rx_pkts;//precvpriv->rx_pkts++; 		
+	padapter->stats.tx_dropped = pxmitpriv->tx_drop;
+	padapter->stats.rx_dropped = precvpriv->rx_drop;
+	padapter->stats.tx_bytes = pxmitpriv->tx_bytes;
+	padapter->stats.rx_bytes = precvpriv->rx_bytes;
+	
+	return &padapter->stats;	
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtw_netdev_ops = {
+	.ndo_open = netdev_open,
+        .ndo_stop = netdev_close,
+        .ndo_start_xmit = rtw_xmit_entry,
+        .ndo_set_mac_address = rtw_net_set_mac_address,
+        .ndo_get_stats = rtw_net_get_stats,
+        .ndo_do_ioctl = rtw_ioctl,
+};
+#endif
+
+int rtw_init_netdev_name(struct net_device *pnetdev)
+{
+	_adapter *padapter = netdev_priv(pnetdev);
+
+#ifdef CONFIG_EASY_REPLACEMENT
+	struct net_device	*TargetNetdev = NULL;
+	_adapter			*TargetAdapter = NULL;
+	struct net 		*devnet = NULL;
+
+	if(padapter->bDongle == 1)
+	{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+		TargetNetdev = dev_get_by_name("wlan0");
+#else
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+		devnet = pnetdev->nd_net;
+	#else
+		devnet = dev_net(pnetdev);
+	#endif
+		TargetNetdev = dev_get_by_name(devnet, "wlan0");
+#endif
+		if(TargetNetdev) {
+			printk("Force onboard module driver disappear !!!\n");
+			TargetAdapter = netdev_priv(TargetNetdev);
+			TargetAdapter->DriverState = DRIVER_DISAPPEAR;
+			if(TargetAdapter->pid != 0)
+				padapter->pid = TargetAdapter->pid;
+			dev_put(TargetNetdev);
+			unregister_netdev(TargetNetdev);
+#ifdef CONFIG_PROC_DEBUG
+			if(TargetAdapter->chip_type == padapter->chip_type)
+				rtw_proc_remove_one(TargetNetdev);
+#endif
+			padapter->DriverState = DRIVER_REPLACE_DONGLE;
+		}
+	}
+#endif
+
+	if(dev_alloc_name(pnetdev,"wlan%d") < 0)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("dev_alloc_name, fail! \n"));
+	}
+
+	netif_carrier_off(pnetdev);
+	//netif_stop_queue(pnetdev);
+
+	return 0;
+}
+
+struct net_device *rtw_init_netdev(void)	
+{
+	_adapter *padapter;
+	struct net_device *pnetdev;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+init_net_dev\n"));
+
+	//pnetdev = alloc_netdev(sizeof(_adapter), "wlan%d", ether_setup);
+	pnetdev = alloc_etherdev(sizeof(_adapter));	
+	if (!pnetdev)
+	   return NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	SET_MODULE_OWNER(pnetdev);
+#endif
+	
+	padapter = netdev_priv(pnetdev);
+	_rtw_memset(padapter, 0,sizeof(_adapter));
+	padapter->pnetdev = pnetdev;	
+	
+	//pnetdev->init = NULL;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+
+	printk("register rtl8192_netdev_ops to netdev_ops\n");
+	pnetdev->netdev_ops = &rtw_netdev_ops;
+
+#else
+	pnetdev->open = netdev_open;
+	pnetdev->stop = netdev_close;	
+	
+	pnetdev->hard_start_xmit = rtw_xmit_entry;
+
+	pnetdev->set_mac_address = rtw_net_set_mac_address;
+	pnetdev->get_stats = rtw_net_get_stats;
+
+	pnetdev->do_ioctl = rtw_ioctl;
+
+#endif
+
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	pnetdev->features |= NETIF_F_IP_CSUM;
+#endif	
+	//pnetdev->tx_timeout = NULL;
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */	
+	
+	pnetdev->wireless_handlers = (struct iw_handler_def *)&rtw_handlers_def;  
+	
+#ifdef WIRELESS_SPY
+	//priv->wireless_data.spy_data = &priv->spy_data;
+	//pnetdev->wireless_data = &priv->wireless_data;
+#endif
+
+	//step 2.
+   	loadparam(padapter, pnetdev);
+
+	return pnetdev;
+
+}
+
+u32 rtw_start_drv_threads(_adapter *padapter)
+{
+
+    u32 _status = _SUCCESS;
+
+    RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_start_drv_threads\n"));
+
+#ifdef CONFIG_SDIO_HCI
+    padapter->xmitThread = kernel_thread(xmit_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->xmitThread < 0)
+		_status = _FAIL;
+#endif
+
+#ifdef CONFIG_RECV_THREAD_MODE
+    padapter->recvThread = kernel_thread(recv_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->recvThread < 0)
+		_status = _FAIL;	
+#endif
+
+    padapter->cmdThread = kernel_thread(rtw_cmd_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->cmdThread < 0)
+		_status = _FAIL;		
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+    padapter->evtThread = kernel_thread(event_thread, padapter, CLONE_FS|CLONE_FILES);
+    if(padapter->evtThread < 0)
+		_status = _FAIL;		
+#endif
+  
+    return _status;
+
+}
+
+void rtw_stop_drv_threads (_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_stop_drv_threads\n"));	
+
+	//Below is to termindate rtw_cmd_thread & event_thread...
+	_rtw_up_sema(&padapter->cmdpriv.cmd_queue_sema);
+	//_rtw_up_sema(&padapter->cmdpriv.cmd_done_sema);
+	if(padapter->cmdThread){
+		_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema);
+	}
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+        _rtw_up_sema(&padapter->evtpriv.evt_notify);
+	if(padapter->evtThread){
+		_rtw_down_sema(&padapter->evtpriv.terminate_evtthread_sema);
+	}
+#endif
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+	// Below is to termindate tx_thread...
+	_rtw_up_sema(&padapter->xmitpriv.xmit_sema);	
+	_rtw_down_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt: xmit_thread can be terminated ! \n"));
+#endif
+	 
+#ifdef CONFIG_RECV_THREAD_MODE	
+	// Below is to termindate rx_thread...
+	_rtw_up_sema(&padapter->recvpriv.recv_sema);
+	_rtw_down_sema(&padapter->recvpriv.terminate_recvthread_sema);
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt:recv_thread can be terminated! \n"));
+#endif
+
+
+}
+
+u8 rtw_init_default_value(_adapter *padapter)
+{
+	u8 ret  = _SUCCESS;
+	struct registry_priv* pregistrypriv = &padapter->registrypriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	//xmit_priv
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+	
+		
+
+	//recv_priv
+	
+
+	//mlme_priv
+	pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+	pmlmepriv->scan_mode = SCAN_ACTIVE;
+	
+	//qos_priv
+	//pmlmepriv->qospriv.qos_option = pregistrypriv->wmm_enable;
+	
+	//ht_priv
+#ifdef CONFIG_80211N_HT		
+	pmlmepriv->htpriv.ampdu_enable = _FALSE;//set to disabled	
+#endif	
+
+	//security_priv
+	//rtw_get_encrypt_decrypt_from_registrypriv(padapter);
+	psecuritypriv->binstallGrpkey = _FAIL;
+	psecuritypriv->sw_encrypt=pregistrypriv->software_encrypt;
+	psecuritypriv->sw_decrypt=pregistrypriv->software_decrypt;
+	
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
+	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+
+	psecuritypriv->dot11PrivacyKeyIndex = 0;
+
+	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+	psecuritypriv->dot118021XGrpKeyid = 1;
+
+	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
+	psecuritypriv->ndisencryptstatus = Ndis802_11WEPDisabled;
+	
+
+	//pwrctrl_priv
+
+
+	//registry_priv
+	rtw_init_registrypriv_dev_network(padapter);		
+	rtw_update_registrypriv_dev_network(padapter);
+
+
+	//hal_priv
+	padapter->halpriv.fw_ractrl = _FALSE;
+	padapter->halpriv.LastHMEBoxNum = 0;
+	padapter->halpriv.bRxRSSIDisplay = 0;
+	//misc.
+	
+	padapter->bReadPortCancel = _FALSE;	
+	padapter->bWritePortCancel = _FALSE;		
+	return ret;
+}
+
+u8 reset_drv_sw(_adapter *padapter)
+{
+	u8	ret8=_SUCCESS;	
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+	struct sitesurvey_ctrl *psitesurveyctrl=&pmlmepriv->sitesurveyctrl;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+	//hal_priv	
+	padapter->halpriv.fw_ractrl = _FALSE;	
+	padapter->halpriv.bRxRSSIDisplay = 0;
+	if(!pwrctrlpriv->bkeepfwalive)
+	{
+	   padapter->halpriv.LastHMEBoxNum = 0;	//misc.		
+	}
+	padapter->bReadPortCancel = _FALSE;		
+	padapter->bWritePortCancel = _FALSE;	
+	pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+	pmlmepriv->scan_mode = SCAN_ACTIVE; // 1: active scan ,0 passive scan
+
+	//pwrctrlpriv->current_rfpwrstate = rf_on;
+	pwrctrlpriv->bips_processing = _FALSE;		
+	
+	padapter->xmitpriv.tx_pkts = psitesurveyctrl->last_tx_pkts = 0;
+	padapter->recvpriv.rx_pkts = psitesurveyctrl->last_rx_pkts = 0;
+	psitesurveyctrl->traffic_busy = _FALSE;	
+	pHalData->IQKInitialized = _FALSE;
+
+#ifdef CONFIG_AUTOSUSPEND	
+	#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
+		padapter->dvobjpriv.pusbdev->autosuspend_disabled = 1;//autosuspend disabled by the user
+	#endif
+#endif
+
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+	padapter->silent_reset_inprogress = _FALSE;
+	padapter->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
+	padapter->last_tx_time =0;
+	padapter->last_tx_complete_time =0;	
+#endif	
+	pwrctrlpriv->pwr_state_check_cnts = 0;
+	return ret8;
+}
+
+
+u8 rtw_init_drv_sw(_adapter *padapter)
+{
+
+	u8	ret8=_SUCCESS;
+
+_func_enter_;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_init_drv_sw\n"));
+
+	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init cmd_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+	
+	padapter->cmdpriv.padapter=padapter;
+	
+	if ((rtw_init_evt_priv(&padapter->evtpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init evt_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+	
+	
+	if (rtw_init_mlme_priv(padapter) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init mlme_priv\n"));
+		ret8=_FAIL;
+		goto exit;
+	}
+		
+	if(_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL)
+	{
+		DBG_871X("Can't _rtw_init_xmit_priv\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+		
+	if(_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL)
+	{
+		DBG_871X("Can't _rtw_init_recv_priv\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+
+	_rtw_memset((unsigned char *)&padapter->securitypriv, 0, sizeof (struct security_priv));	
+	_init_timer(&(padapter->securitypriv.tkip_timer), padapter->pnetdev, rtw_use_tkipkey_handler, padapter);
+
+	if(_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)
+	{
+		DBG_871X("Can't _rtw_init_sta_priv\n");
+		ret8=_FAIL;
+		goto exit;
+	}
+	
+	padapter->stapriv.padapter = padapter;	
+
+	rtw_init_bcmc_stainfo(padapter);
+
+	rtw_init_pwrctrl_priv(padapter);	
+
+	//_rtw_memset((u8 *)&padapter->qospriv, 0, sizeof (struct qos_priv));//move to mlme_priv
+
+	//_set_timer(&padapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 5000);	 	
+
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 5000);
+	
+#ifdef CONFIG_MP_INCLUDED
+        mp871xinit(padapter); 
+#endif
+
+	ret8 = rtw_init_default_value(padapter);	
+	init_dm_priv(padapter);
+
+	rtw_InitSwLeds(padapter);
+	_rtw_mutex_init(&padapter->silentreset_mutex );
+#ifdef SILENT_RESET_FOR_SPECIFIC_PLATFOM
+	padapter->silent_reset_inprogress = _FALSE;
+	padapter->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
+	padapter->last_tx_time =0;
+	padapter->last_tx_complete_time =0;	
+#endif	
+
+
+exit:
+	
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-rtw_init_drv_sw\n"));
+
+	_func_exit_;	
+	
+	return ret8;
+	
+}
+
+void cancel_all_timer(_adapter *padapter)
+{
+	u8 bcancelled;
+	_set_timer(&padapter->mlmepriv.assoc_timer, 10000);
+	while(1)
+	{
+		_cancel_timer(&padapter->mlmepriv.assoc_timer, &bcancelled);
+		if (bcancelled == _TRUE)
+			break;
+	}
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt:cancel association timer complete! \n"));
+
+/*
+	while(1)
+	{
+		_cancel_timer(&padapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, &bcancelled);
+		if (bcancelled == _TRUE)
+			break;
+	}
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt:cancel sitesurvey_ctrl_timer! \n"));
+*/
+	_set_timer(&padapter->securitypriv.tkip_timer, 10000);
+	while(1)
+	{
+		_cancel_timer(&padapter->securitypriv.tkip_timer, &bcancelled);
+		if (bcancelled == _TRUE)
+			break;
+	}
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt:cancel tkip_timer! \n"));
+	
+	
+	 _set_timer(&padapter->mlmepriv.scan_to_timer, 10000);
+   	 while(1)
+   	 {
+       	 _cancel_timer(&padapter->mlmepriv.scan_to_timer, &bcancelled);
+       	 if (bcancelled == _TRUE)
+           	 break;
+	}
+	
+	 _set_timer(&padapter->mlmepriv.dynamic_chk_timer, 10000);
+   	 while(1)
+   	 {
+       	 _cancel_timer(&padapter->mlmepriv.dynamic_chk_timer, &bcancelled);
+       	 if (bcancelled == _TRUE)
+           	 break;
+	}
+
+	rtw_DeInitSwLeds(padapter);
+
+
+	_set_timer(&padapter->pwrctrlpriv.pwr_state_check_timer, 10000);
+	 while(1)
+   	 {
+	       _cancel_timer(&padapter->pwrctrlpriv.pwr_state_check_timer, &bcancelled);
+	       if (bcancelled == _TRUE)
+	       	break;
+	}	
+
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+
+	_set_timer(&padapter->dmpriv.SwAntennaSwitchTimer, 10000);	
+	 while(1)
+   	 {
+	       	 _cancel_timer(&padapter->dmpriv.SwAntennaSwitchTimer, &bcancelled);
+	       	 if (bcancelled == _TRUE)
+	           	 break;
+	}
+	
+#endif
+}
+
+u8 rtw_free_drv_sw(_adapter *padapter)
+{
+
+
+	struct net_device *pnetdev = (struct net_device*)padapter->pnetdev;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("==>rtw_free_drv_sw"));	
+
+	free_mlme_ext_priv(&padapter->mlmeextpriv);
+	
+	rtw_free_cmd_priv(&padapter->cmdpriv);
+	
+	rtw_free_evt_priv(&padapter->evtpriv);
+	
+	rtw_free_mlme_priv(&padapter->mlmepriv);
+	
+	//free_io_queue(padapter);
+	
+	_rtw_free_xmit_priv(&padapter->xmitpriv);
+	
+	_rtw_free_sta_priv(&padapter->stapriv); //will free bcmc_stainfo here
+	
+	_rtw_free_recv_priv(&padapter->recvpriv);	
+
+	//_rtw_mfree((void *)padapter, sizeof (padapter));
+
+#ifdef CONFIG_DRVEXT_MODULE
+	free_drvext(&padapter->drvextpriv);
+#endif	
+
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("<==rtw_free_drv_sw\n"));
+
+	if(pnetdev)
+	{
+		free_netdev(pnetdev);
+	}
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-rtw_free_drv_sw\n"));
+
+	return _SUCCESS;
+	
+}
+
+
+static int netdev_open(struct net_device *pnetdev)
+{
+	uint status;	
+	_adapter *padapter = (_adapter *)netdev_priv(pnetdev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - dev_open\n"));
+	printk("+8192cu_drv - drv_open, bup=%d\n", padapter->bup);
+
+       if(padapter->bup == _FALSE)
+    	{    
+		padapter->bDriverStopped = _FALSE;
+	 	padapter->bSurpriseRemoved = _FALSE;	 
+		padapter->bCardDisableWOHSM = _FALSE;        			
+
+		status = rtw_hal_init(padapter);		
+		if (status ==_FAIL)
+		{			
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("rtl871x_hal_init(): Can't init h/w!\n"));
+			goto netdev_open_error;
+		}		
+		
+		if ( rtw_initmac == NULL )	//	Use the mac address stored in the Efuse
+		{
+			_rtw_memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
+		}
+		else
+		{	//	Use the user specifiy mac address.
+
+			//	Commented by Albert 2010/07/19
+			//	The "myid" function will get the wifi mac address from eeprompriv structure instead of netdev structure.			
+			//	So, we have to overwrite the mac_addr stored in the eeprompriv structure.
+			//	In this case, the real mac address won't be used anymore.
+			//	So that, the eeprompriv.mac_addr should store the mac which users specify.
+			_rtw_memcpy( padapter->eeprompriv.mac_addr, pnetdev->dev_addr, ETH_ALEN );
+		}		
+
+		printk("MAC Address = %x-%x-%x-%x-%x-%x\n", 
+				 pnetdev->dev_addr[0], pnetdev->dev_addr[1], pnetdev->dev_addr[2], pnetdev->dev_addr[3], pnetdev->dev_addr[4], pnetdev->dev_addr[5]);		
+
+		
+		status=rtw_start_drv_threads(padapter);
+		if(status ==_FAIL)
+		{			
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));			
+			goto netdev_open_error;			
+		}
+
+
+		if (init_mlme_ext_priv(padapter) == _FAIL)
+		{
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("can't init mlme_ext_priv\n"));
+			goto netdev_open_error;
+		}
+
+		
+#ifdef CONFIG_DRVEXT_MODULE
+		init_drvext(padapter);
+#endif	   		
+
+#ifdef CONFIG_USB_HCI	
+		if(pHalData->hal_ops.inirp_init == NULL)
+		{
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("Initialize dvobjpriv.inirp_init error!!!\n"));
+			goto netdev_open_error;	
+		}
+		else
+		{	
+			pHalData->hal_ops.inirp_init(padapter);
+		}			
+#endif
+
+#ifdef CONFIG_PROC_DEBUG
+		rtw_proc_init_one(pnetdev);
+#endif	
+
+             padapter->bup = _TRUE;
+		padapter->ledpriv.LedControlHandler(padapter, LED_CTL_POWER_ON);
+
+	}		
+
+	padapter->net_closed = _FALSE;	
+		
+
+	if(( pwrctrlpriv->power_mgnt != PS_MODE_ACTIVE ) ||(padapter->pwrctrlpriv.bHWPwrPindetect))
+	{	
+		padapter->pwrctrlpriv.bips_processing = _FALSE;		
+		_set_timer(&padapter->pwrctrlpriv.pwr_state_check_timer, padapter->pwrctrlpriv.pwr_state_check_inverval);	
+	}
+ 	
+		
+	//netif_carrier_on(pnetdev);//call this func when rtw_joinbss_event_callback return success       
+ 	if(!netif_queue_stopped(pnetdev))
+      		netif_start_queue(pnetdev);
+	else
+		netif_wake_queue(pnetdev);
+		
+        RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - dev_open\n"));
+	printk("-871x_drv - drv_open, bup=%d\n", padapter->bup);
+		
+	 return 0;
+	
+netdev_open_error:
+
+	padapter->bup = _FALSE;
+	
+	netif_carrier_off(pnetdev);	
+	netif_stop_queue(pnetdev);
+	
+	RT_TRACE(_module_os_intfs_c_,_drv_err_,("-871x_drv - dev_open, fail!\n"));
+	printk("-871x_drv - drv_open fail, bup=%d\n", padapter->bup);
+	
+	return (-1);
+	
+}
+
+#ifdef CONFIG_IPS
+int  ips_netdrv_open(_adapter *padapter)
+{
+	int status = _SUCCESS;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	padapter->net_closed = _FALSE;
+	printk("%s\n",__FUNCTION__);
+	//if(padapter->bup == _FALSE)
+    	{    
+		padapter->bDriverStopped = _FALSE;
+	 	padapter->bSurpriseRemoved = _FALSE;	 
+		padapter->bCardDisableWOHSM = _FALSE;
+		padapter->bup = _TRUE;        	
+	
+		status = rtw_hal_init(padapter);		
+		if (status ==_FAIL)
+		{			
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("_r8192cu_netdrv_open(): Can't init h/w!\n"));
+			goto netdev_open_error;
+		}
+  		
+
+#ifdef CONFIG_USB_HCI	
+		if(pHalData->hal_ops.inirp_init == NULL)
+		{
+			RT_TRACE(_module_os_intfs_c_,_drv_err_,("Initialize dvobjpriv.inirp_init error!!!\n"));
+			goto netdev_open_error;	
+		}
+		else
+		{	
+			pHalData->hal_ops.inirp_init(padapter);
+		}			
+#endif
+
+		_set_timer(&padapter->pwrctrlpriv.pwr_state_check_timer, padapter->pwrctrlpriv.pwr_state_check_inverval);
+	}		
+		
+        RT_TRACE(_module_os_intfs_c_,_drv_info_,("-r8192cu_drv - dev_open\n"));
+	//printk("-ips_netdrv_open - drv_open, bup=%d\n", padapter->bup);
+		
+	 return _SUCCESS;
+
+netdev_open_error:
+
+	//padapter->bup = _FALSE;
+	
+	RT_TRACE(_module_os_intfs_c_,_drv_err_,("-r8192cu_drv - dev_open, fail!\n"));
+	//printk("-ips_netdrv_open - drv_open fail, bup=%d\n", padapter->bup);
+	
+	return _FAIL;
+}
+#endif
+
+int pm_netdev_open(struct net_device *pnetdev,u8 bnormal)
+{
+	int status;
+	if(bnormal)
+		status = netdev_open(pnetdev);	
+	else
+		status =  (_SUCCESS == ips_netdrv_open((_adapter *)netdev_priv(pnetdev)))?(0):(-1);
+
+	return status;
+}
+
+extern int rfpwrstate_check(_adapter *padapter);
+static int netdev_close(struct net_device *pnetdev)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(pnetdev);
+		
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - drv_close\n"));	
+
+	if(padapter->pwrctrlpriv.bInternalAutoSuspend == _TRUE)
+	{
+		rfpwrstate_check(padapter);
+	}
+
+	padapter->net_closed = _TRUE;
+/*	if(!padapter->hw_init_completed)
+	{
+		printk("(1)871x_drv - drv_close, bup=%d, hw_init_completed=%d\n", padapter->bup, padapter->hw_init_completed);
+
+	padapter->bDriverStopped = _TRUE;   
+
+	rtw_dev_unload(padapter);	
+	}
+	else*/
+	{
+		printk("(2)8192cu_drv - drv_close, bup=%d, hw_init_completed=%d\n"
+			, padapter->bup
+			, padapter->hw_init_completed);
+
+		//s1.
+		if(pnetdev)   
+     		{
+			if (!netif_queue_stopped(pnetdev))
+				netif_stop_queue(pnetdev);
+     		}
+		
+#ifndef CONFIG_PLATFORM_ANDROID	
+		
+		//s2.	
+		//s2-1.  issue rtw_disassoc_cmd to fw
+		rtw_disassoc_cmd(padapter);	
+		//s2-2.  indicate disconnect to os
+		printk("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+		rtw_indicate_disconnect(padapter);
+		//s2-3. 
+	       rtw_free_assoc_resources(padapter);	
+		//s2-4.
+		rtw_free_network_queue(padapter,_TRUE);	
+#endif
+
+	}
+
+	// Close LED
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_POWER_OFF);
+
+	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - drv_close\n"));
+	printk("-871x_drv - drv_close, bup=%d\n", padapter->bup);
+	   
+	return 0;
+	
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/recv_linux.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/recv_linux.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/recv_linux.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/recv_linux.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,371 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RECV_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <wifi.h>
+#include <recv_osdep.h>
+
+#include <osdep_intf.h>
+#include <ethernet.h>
+#include <linux/if_arp.h>
+
+
+#ifdef CONFIG_USB_HCI
+#include <usb_ops.h>
+#endif
+
+//init os related resource in struct recv_priv
+int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter)
+{	
+	int	res=_SUCCESS;
+
+	return res;
+}
+
+//alloc os related resource in union recv_frame
+int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe)
+{	
+	int	res=_SUCCESS;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);	
+	
+	precvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;
+
+	return res;
+
+}
+
+//free os related resource in union recv_frame
+void rtw_os_recv_resource_free(struct recv_priv *precvpriv)
+{
+
+}
+
+
+//alloc os related resource in struct recv_buf
+int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res=_SUCCESS;
+
+		
+#ifdef CONFIG_USB_HCI	
+	precvbuf->irp_pending = _FALSE;
+	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
+	if(precvbuf->purb == NULL){		 				
+		res = _FAIL;			
+	}
+
+	precvbuf->pskb = NULL;
+
+	precvbuf->reuse = _FALSE;
+
+	precvbuf->pallocated_buf  = precvbuf->pbuf = NULL;
+
+        precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pend = NULL;
+
+	precvbuf->transfer_len = 0;
+
+	precvbuf->len = 0;
+	
+#endif
+#ifdef CONFIG_SDIO_HCI
+	precvbuf->pskb = NULL;
+
+	precvbuf->pallocated_buf  = precvbuf->pbuf = NULL;
+
+        precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pend = NULL;
+
+
+	precvbuf->len = 0;
+#endif
+	return res;
+	
+}
+
+//free os related resource in struct recv_buf
+int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int ret = _SUCCESS;
+	
+	if(precvbuf->pskb)
+		dev_kfree_skb_any(precvbuf->pskb);
+
+#ifdef CONFIG_USB_HCI
+	if(precvbuf->purb)
+	{
+		//usb_kill_urb(precvbuf->purb);
+		usb_free_urb(precvbuf->purb);
+	}
+#endif
+
+	return ret;	
+}
+
+void rtw_handle_tkip_mic_err(_adapter *padapter,u8 bgroup)
+{
+    union iwreq_data wrqu;
+    struct iw_michaelmicfailure    ev;
+    struct mlme_priv*              pmlmepriv  = &padapter->mlmepriv;
+
+    
+    _rtw_memset( &ev, 0x00, sizeof( ev ) );
+    if ( bgroup )
+    {
+        ev.flags |= IW_MICFAILURE_GROUP;
+    }
+    else
+    {
+        ev.flags |= IW_MICFAILURE_PAIRWISE;
+    }
+   
+    ev.src_addr.sa_family = ARPHRD_ETHER;
+    _rtw_memcpy( ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+
+    _rtw_memset( &wrqu, 0x00, sizeof( wrqu ) );
+    wrqu.data.length = sizeof( ev );
+
+    wireless_send_event( padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu, (char*) &ev );
+}
+
+void hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame)
+{
+#ifdef CONFIG_HOSTAPD_MLME	
+	_pkt *skb;
+	struct hostapd_priv *phostapdpriv  = padapter->phostapdpriv;
+	struct net_device *pmgnt_netdev = phostapdpriv->pmgnt_netdev;
+	
+	RT_TRACE(_module_recv_osdep_c_, _drv_info_, ("+hostapd_mlme_rx\n"));
+	
+	skb = precv_frame->u.hdr.pkt;	       
+	
+	if (skb == NULL) 
+		return;
+	
+	skb->data = precv_frame->u.hdr.rx_data;
+	skb->tail = precv_frame->u.hdr.rx_tail;	
+	skb->len = precv_frame->u.hdr.len;
+
+	//pskb_copy = skb_copy(skb, GFP_ATOMIC);	
+//	if(skb == NULL) goto _exit;
+
+	skb->dev = pmgnt_netdev;
+	skb->ip_summed = CHECKSUM_NONE;	
+	skb->pkt_type = PACKET_OTHERHOST;
+	//skb->protocol = __constant_htons(0x0019); /*ETH_P_80211_RAW*/
+	skb->protocol = __constant_htons(0x0003); /*ETH_P_80211_RAW*/
+	
+	//printk("(1)data=0x%x, head=0x%x, tail=0x%x, mac_header=0x%x, len=%d\n", skb->data, skb->head, skb->tail, skb->mac_header, skb->len);
+
+	//skb->mac.raw = skb->data;
+	skb_reset_mac_header(skb);
+
+       //skb_pull(skb, 24);
+       _rtw_memset(skb->cb, 0, sizeof(skb->cb));        
+
+	netif_rx(skb);
+
+	precv_frame->u.hdr.pkt = NULL; // set pointer to NULL before rtw_free_recvframe() if call netif_rx()
+#endif	
+}
+
+void rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
+{	
+       struct recv_priv *precvpriv;
+       _queue	*pfree_recv_queue;	     
+	_pkt *skb;	
+	struct mlme_priv*pmlmepriv = &padapter->mlmepriv;
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+#endif
+
+_func_enter_;
+
+	precvpriv = &(padapter->recvpriv);	
+	pfree_recv_queue = &(precvpriv->free_recv_queue);	
+     
+#ifdef CONFIG_DRVEXT_MODULE		
+	if (drvext_rx_handler(padapter, precv_frame->u.hdr.rx_data, precv_frame->u.hdr.len) == _SUCCESS)
+	{		
+		rtw_free_recvframe(precv_frame, pfree_recv_queue);
+		return;
+	}
+#endif
+
+	skb = precv_frame->u.hdr.pkt;	       
+       if(skb == NULL)
+       {        
+            RT_TRACE(_module_recv_osdep_c_,_drv_err_,("rtw_recv_indicatepkt():skb==NULL something wrong!!!!\n"));		   
+	     goto _recv_indicatepkt_drop;
+	}
+
+	   
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("rtw_recv_indicatepkt():skb != NULL !!!\n"));		
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("rtw_recv_indicatepkt():precv_frame->u.hdr.rx_head=%p  precv_frame->hdr.rx_data=%p\n", precv_frame->u.hdr.rx_head, precv_frame->u.hdr.rx_data));
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("precv_frame->hdr.rx_tail=%p precv_frame->u.hdr.rx_end=%p precv_frame->hdr.len=%d \n", precv_frame->u.hdr.rx_tail, precv_frame->u.hdr.rx_end, precv_frame->u.hdr.len));
+		
+	skb->data = precv_frame->u.hdr.rx_data;
+	
+#ifdef NET_SKBUFF_DATA_USES_OFFSET	
+	skb_set_tail_pointer(skb, precv_frame->u.hdr.len);
+#else
+	skb->tail = precv_frame->u.hdr.rx_tail;
+#endif
+
+	skb->len = precv_frame->u.hdr.len;
+	
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n", skb->head, skb->data, skb->tail, skb->end, skb->len));
+	
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)	 	
+	{	 	
+	 	_pkt *pskb2=NULL;
+	 	struct sta_info *psta = NULL;
+	 	struct sta_priv *pstapriv = &padapter->stapriv;	
+		struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;	
+		int bmcast = IS_MCAST(pattrib->dst);
+
+		//DBG_871X("bmcast=%d\n", bmcast);
+
+		if(_rtw_memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)==_FALSE)		
+		{
+			psta = rtw_get_stainfo(pstapriv, pattrib->dst);
+
+			//DBG_871X("not ap psta=%p, addr=%pM\n", psta, pattrib->dst);
+
+			if(bmcast)
+			{
+				pskb2 = skb_clone(skb, GFP_ATOMIC);	
+			}
+
+			if(psta)
+			{
+				//DBG_871X("directly forwarding to the xmit_entry\n");
+
+				//skb->ip_summed = CHECKSUM_NONE;	
+				//skb->protocol = eth_type_trans(skb, pnetdev);
+
+				skb->dev = padapter->pnetdev;	
+				rtw_xmit_entry(skb, padapter->pnetdev);			
+		
+				if(bmcast == _FALSE)				
+				        goto _recv_indicatepkt_end;			
+			
+			}
+
+			if(bmcast)
+				skb = pskb2;
+			
+		}
+		else// to APself
+		{
+			//DBG_871X("to APSelf\n");
+		}
+		
+	}
+
+
+	
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX
+        if ( (pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1) ) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		//printk("CHECKSUM_UNNECESSARY \n");
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+		//printk("CHECKSUM_NONE(%d, %d) \n", pattrib->tcpchk_valid, pattrib->tcp_chkrpt);
+	}
+#else /* !CONFIG_RTL8712_TCP_CSUM_OFFLOAD_RX */
+
+	skb->ip_summed = CHECKSUM_NONE;
+
+#endif
+
+	skb->dev = padapter->pnetdev;
+	skb->protocol = eth_type_trans(skb, padapter->pnetdev);
+	
+	netif_rx(skb);
+
+_recv_indicatepkt_end:
+
+	precv_frame->u.hdr.pkt = NULL; // pointers to NULL before rtw_free_recvframe()
+
+	rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n rtw_recv_indicatepkt :after netif_rx!!!!\n"));
+
+_func_exit_;		
+
+        return;		
+
+_recv_indicatepkt_drop:
+
+	 //enqueue back to free_recv_queue	
+	 if(precv_frame)
+		 rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	 
+ 	 precvpriv->rx_drop++;	
+
+_func_exit_;
+
+}
+
+void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf)
+{	
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+#ifdef CONFIG_USB_HCI
+
+	precvbuf->ref_cnt--;
+
+	//free skb in recv_buf
+	dev_kfree_skb_any(precvbuf->pskb);
+
+	precvbuf->pskb = NULL;
+	precvbuf->reuse = _FALSE;
+
+	if(precvbuf->irp_pending == _FALSE)
+	{
+		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+	}	
+		
+
+#endif
+#ifdef CONFIG_SDIO_HCI
+		precvbuf->pskb = NULL;
+#endif
+
+}
+
+void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
+	rtw_reordering_ctrl_timeout_handler(preorder_ctrl);
+}
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
+{
+	_adapter *padapter = preorder_ctrl->padapter;
+
+	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, _rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
+	
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/sdio_intf.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/sdio_intf.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/sdio_intf.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/sdio_intf.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,919 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _HCI_INTF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+
+#include <hal_init.h>
+#include <sdio_hal.h>
+#include <sdio_ops.h>
+#include <linux/mmc/sdio_func.h> 
+#include <linux/mmc/sdio_ids.h>
+extern u32 rtw_start_drv_threads(_adapter *padapter);
+extern void rtw_stop_drv_threads (_adapter *padapter);
+extern u8 rtw_init_drv_sw(_adapter *padapter);
+extern u8 rtw_free_drv_sw(_adapter *padapter);
+extern void cancel_all_timer(_adapter *padapter);
+extern struct net_device *rtw_init_netdev(void);
+extern void update_recvframe_attrib_from_recvstat(struct rx_pkt_attrib
+*pattrib, struct recv_stat *prxstat);
+static const struct sdio_device_id sdio_ids[] = {
+	{ SDIO_DEVICE(0x024c, 0x8712)		},
+//	{ SDIO_DEVICE_CLASS(SDIO_CLASS_WLAN)		},
+//	{ /* end: all zeroes */				},
+};
+
+typedef struct _driver_priv{
+		struct sdio_driver r871xs_drv;
+}drv_priv, *pdrv_priv;
+
+void	sd_sync_int_hdl(struct sdio_func *func);
+
+extern unsigned int sd_dvobj_init(_adapter * padapter){
+
+	struct dvobj_priv *psddev=&padapter->dvobjpriv;
+	struct sdio_func *func=psddev->func;
+	int ret;
+	_func_enter_;
+	//_rtw_init_sema(&psddev->init_finish,0);
+	sdio_claim_host(func);
+	 ret=sdio_enable_func(func);
+	if(ret){	
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("sd_dvobj_init: sdio_enable_func fail!!!!!\n"));
+		return _FAIL;
+	}
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("sd_dvobj_init: sdio_enable_func success!!!!!\n"));
+	padapter->EepromAddressSize = 6;
+	psddev->tx_block_mode=1;
+	psddev->rx_block_mode=1;
+	sdio_set_block_size(func, 512);
+	psddev->block_transfer_len=512;
+	psddev->blk_shiftbits=9;
+	ret=sdio_claim_irq(func,sd_sync_int_hdl);
+	sdio_release_host(func);
+	psddev->sdio_himr=0xff;
+	if(ret)	
+		return _FAIL;
+	_func_exit_;
+	return _SUCCESS;
+}
+
+extern void sd_dvobj_deinit(_adapter * padapter)
+{
+       unsigned char data;    
+	struct dvobj_priv *psddev=&padapter->dvobjpriv;
+	struct sdio_func *func=psddev->func;
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+SDIO deinit\n"));
+	if(func !=0){
+        sdio_claim_host(func);
+       RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in sd_dvobj_deinit():sdio_claim_host !\n"));
+//        sdio_release_irq(func);
+        RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in  sd_dvobj_deinit():sdio_release_irq !\n"));
+        sdio_disable_func(func);
+      RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in  sd_dvobj_deinit():sdio_disable_func !\n"));
+        sdio_release_host(func);
+      RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in  sd_dvobj_deinit():sdio_release_host !\n"));
+
+
+	}
+	return;
+}
+
+uint sdbus_read_reg_int(struct intf_priv *pintfpriv, u32 addr, u32 cnt, void *pdata)
+{
+	struct dvobj_priv *pdvobjpriv = (struct dvobj_priv*)pintfpriv->intf_dev;
+	struct sdio_func *func = pdvobjpriv->func;
+	u8 *mem = NULL;
+	int status;
+
+#ifdef CONFIG_IO_4B
+	u32 addr_org = addr, addr_offset = 0;
+	u32 cnt_org = cnt;
+#endif
+
+_func_enter_;
+
+#ifdef CONFIG_IO_4B
+	addr_offset = addr % 4;
+	if (addr_offset) {
+		addr = addr - addr_offset;
+		cnt = cnt + addr_offset;
+	}
+	if (cnt % 4)
+		cnt = ((cnt + 4) >> 2) << 2;
+#endif
+
+	mem = _rtw_malloc(cnt);
+	if (mem == NULL) {
+		RT_TRACE(_module_hci_ops_os_c_, _drv_emerg_,
+			 ("SDIO_STATUS_NO_RESOURCES - memory alloc fail\n"));
+		return _FAIL;
+	}
+
+	status = sdio_memcpy_fromio(func, mem, addr&0x1FFFF, cnt);
+	if (status) {
+		//error
+		RT_TRACE(_module_hci_ops_os_c_, _drv_emerg_,
+			 ("sdbus_read_reg_int error 0x%x\n"
+			  "***** Addr = %x *****\n"
+			  "***** Length = %d *****\n", status, addr, cnt));
+		status = _FAIL;
+	} else {
+#ifdef CONFIG_IO_4B
+		if (cnt != cnt_org)
+			_rtw_memcpy(pdata, mem + addr_offset, cnt_org);
+		else
+#endif
+		_rtw_memcpy(pdata, mem, cnt);
+		status = _SUCCESS;
+	}
+
+	_rtw_mfree(mem, cnt);
+
+_func_exit_;
+
+	return status;
+}
+
+void sdio_read_int(_adapter *padapter, u32 addr, u8 sz, void *pdata)
+{
+	struct io_queue	*pio_queue = (struct io_queue*)padapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &pio_queue->intf;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	u32 ftaddr = 0, res;
+
+_func_enter_;
+
+//	RT_TRACE(_module_hci_ops_c_,_drv_err_,("sdio_read_int\n"));
+
+	if ((_cvrt2ftaddr(addr, &ftaddr)) == _SUCCESS) {
+		res = sdbus_read_reg_int(pintfpriv, ftaddr, sz, pdata);
+		if (res != _SUCCESS) {
+			RT_TRACE(_module_hci_ops_c_, _drv_emerg_, ("sdio_read_int fail!!!\n"));
+		}
+	} else {
+		RT_TRACE(_module_hci_ops_c_, _drv_emerg_, (" sdio_read_int address translate error!!!\n"));
+	}
+
+_func_exit_;
+}
+
+uint sdbus_write_reg_int(struct intf_priv *pintfpriv, u32 addr, u32 cnt, void *pdata)
+{
+	struct dvobj_priv *pdvobjpriv = (struct dvobj_priv*)pintfpriv->intf_dev;
+	struct sdio_func *func = pdvobjpriv->func;
+	int status;
+#ifdef CONFIG_IO_4B
+	u32 addr_org = addr, addr_offset = 0;
+	u32 cnt_org = cnt;
+	void *pdata_org = pdata;
+#endif
+
+_func_enter_;
+
+#ifdef CONFIG_IO_4B
+	addr_offset = addr % 4;
+	if (addr_offset) {
+		addr = addr - addr_offset;
+		cnt = cnt + addr_offset;
+	}
+	if (cnt % 4)
+		cnt = ((cnt + 4) >> 2) << 2;
+	if (cnt != cnt_org) {
+		pdata = _rtw_malloc(cnt);
+		if (pdata == NULL) {
+			RT_TRACE(_module_hci_ops_os_c_, _drv_emerg_,
+				 ("SDIO_STATUS_NO_RESOURCES - _rtw_malloc fail\n"));
+			return _FAIL;
+		}
+		status = sdio_memcpy_fromio(func, pdata, addr&0x1FFFF, cnt);
+		if (status) {
+			RT_TRACE(_module_hci_ops_os_c_,_drv_emerg_,
+				 ("sdbus_write_reg_int read failed 0x%x\n "
+				  "***** Addr = %x *****\n"
+				  "***** Length = %d *****\n", status, addr, cnt));
+			_rtw_mfree(pdata, cnt);
+			return _FAIL;
+		}
+		_rtw_memcpy(pdata + addr_offset, pdata_org, cnt_org);
+		/* if data been modify between this read and write, may cause a problem */
+	}
+#endif
+	status = sdio_memcpy_toio(func, addr&0x1FFFF, pdata, cnt);
+	if (status) {
+		//error
+		RT_TRACE(_module_hci_ops_os_c_, _drv_emerg_,
+			 ("sdbus_write_reg_int failed 0x%x\n"
+			  "***** Addr = %x *****\n"
+			  "***** Length = %d *****\n", status, addr, cnt));
+
+		status = _FAIL;
+	} else
+		status = _SUCCESS;
+
+#ifdef CONFIG_IO_4B
+	if (cnt != cnt_org)
+		_rtw_mfree(pdata, cnt);
+#endif
+
+_func_exit_;
+
+	return status;
+}
+
+void sdio_write_int(_adapter *padapter, u32 addr, u32 val, u8 sz)
+{
+	struct io_queue	*pio_queue = (struct io_queue*)padapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &pio_queue->intf;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	u32 ftaddr = 0, res;
+
+_func_enter_;
+
+//	RT_TRACE(_module_hci_ops_c_,_drv_err_,("sdio_write_int\n"));
+
+	val = cpu_to_le32(val);
+
+	if ((_cvrt2ftaddr(addr, &ftaddr)) == _SUCCESS) {
+		res = sdbus_write_reg_int(pintfpriv, ftaddr, sz, &val);
+		if (res != _SUCCESS) {
+			RT_TRACE(_module_hci_ops_c_, _drv_emerg_, ("sdio_write_int fail!!!\n"));
+		}
+	} else {
+		RT_TRACE(_module_hci_ops_c_, _drv_emerg_, ("sdio_write_int address translate error!!!\n"));
+	}
+
+_func_exit_;
+}
+
+int recvbuf2recvframe_s(_adapter *padapter, struct recv_buf *precvbuf)
+{
+//	_irqL irql;
+	u8 *pbuf;
+//	u8 bsumbit = _FALSE;
+	uint pkt_len, pkt_offset;
+	int transfer_len;
+	struct recv_stat *prxstat;
+	u16 pkt_cnt, drvinfo_sz;
+	_queue *pfree_recv_queue;
+	union recv_frame *precvframe = NULL,*plast_recvframe = NULL;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+//	struct intf_hdl *pintfhdl = &padapter->pio_queue->intf;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+recvbuf2recvframe()\n"));
+
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+
+	pbuf = (u8*)precvbuf->pbuf;
+
+	prxstat = (struct recv_stat *)pbuf;
+/*	{
+		u8 i;
+		printk("\n-----recvbuf-----\n");
+		for (i=0;i<64;i=i+8) {
+			printk("0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x\n",pbuf[i],pbuf[i+1],pbuf[i+2],pbuf[i+3],pbuf[i+4],pbuf[i+5],pbuf[i+6],pbuf[i+7]);
+		}
+		printk("\n-----recvbuf end-----\n");
+	}*/
+	transfer_len = precvbuf->len;
+	precvbuf->ref_cnt = 1;
+	do {
+		precvframe = NULL;
+		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
+		if (precvframe == NULL){
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe(), precvframe==NULL\n"));
+			break;
+		}
+		if (plast_recvframe != NULL) {
+			if (rtw_recv_entry(plast_recvframe) != _SUCCESS) {
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe(), rtw_recv_entry(precvframe) != _SUCCESS\n"));
+			}
+		}
+		prxstat = (struct recv_stat*)pbuf;
+		pkt_len = le32_to_cpu(prxstat->rxdw0&0x00003fff); //pkt_len = prxstat->frame_length;             
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("rxdesc: offsset0:0x%08x, offsset4:0x%08x, offsset8:0x%08x, offssetc:0x%08x\n",prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
+
+		drvinfo_sz = le16_to_cpu((prxstat->rxdw0&0x000f0000)>>16);//uint 2^3 = 8 bytes
+		drvinfo_sz = drvinfo_sz << 3;
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_, ("pkt_len=%d[0x%x] drvinfo_sz=%d[0x%x]\n", pkt_len, pkt_len, drvinfo_sz, drvinfo_sz));
+		precvframe->u.hdr.precvbuf = precvbuf;
+		precvframe->u.hdr.adapter = padapter;
+		rtw_init_recvframe(precvframe, precvpriv);
+
+		precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
+		precvframe->u.hdr.rx_end = precvbuf->pend;
+		update_recvframe_attrib_from_recvstat(&precvframe->u.hdr.attrib, prxstat);
+		pkt_offset = pkt_len + drvinfo_sz + RXDESC_SIZE;
+
+		recvframe_put(precvframe, pkt_len + drvinfo_sz + RXDESC_SIZE);
+		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
+/*		{
+			u8 i;
+			printk("\n-----packet-----\n");
+			for(i=0;i<32;i++){
+			printk("0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x:0x%.2x\n",precvframe->u.hdr.rx_data[i],precvframe->u.hdr.rx_data[i+1],precvframe->u.hdr.rx_data[i+2],precvframe->u.hdr.rx_data[i+3],precvframe->u.hdr.rx_data[i+4],precvframe->u.hdr.rx_data[i+5],precvframe->u.hdr.rx_data[i+6],precvframe->u.hdr.rx_data[i+7]);
+			}
+			printk("\n-----packet end-----\n");
+		}*/
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n precvframe->u.hdr.rx_head=%p precvframe->u.hdr.rx_data=%p precvframe->u.hdr.rx_tail=%p precvframe->u.hdr.rx_end=%p\n",precvframe->u.hdr.rx_head,precvframe->u.hdr.rx_data,precvframe->u.hdr.rx_tail,precvframe->u.hdr.rx_end));
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\npkt_offset=%d [1]\n",pkt_offset));
+		pkt_offset = _RND512(pkt_offset);
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\npkt_offset=%d [2] transfer_len=%d\n",pkt_offset,transfer_len));
+		transfer_len -= pkt_offset;
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n transfer_len=%d \n",transfer_len));
+		pbuf += pkt_offset;
+		if (transfer_len > 0)
+			precvbuf->ref_cnt++;
+		plast_recvframe = precvframe;
+		precvframe = NULL;
+	} while (transfer_len > 0);
+
+	if (plast_recvframe != NULL) {
+		if (rtw_recv_entry(plast_recvframe) != _SUCCESS) {
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe(), rtw_recv_entry(precvframe) != _SUCCESS\n"));
+		}
+	}
+
+	dev_kfree_skb_any(precvbuf->pskb);
+	precvbuf->pskb = NULL;
+	return _SUCCESS;
+}
+
+u32 read_pkt2recvbuf(PADAPTER padapter, u32 rd_cnt, struct recv_buf *precvbuf)
+{
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	u32 skb_buf_sz;
+	if (rd_cnt < 1600)
+		skb_buf_sz = 1600;
+	else
+		skb_buf_sz = rd_cnt;
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n read_pkt2recvbuf------skb_buf_sz=%d rd_cnt=%d\n",skb_buf_sz,rd_cnt));
+//	if (precvbuf->pskb != NULL) {
+//		dev_kfree_skb_any(precvbuf->pskb );
+//	}
+
+	//alloc skb
+	{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+		precvbuf->pskb = dev_alloc_skb(skb_buf_sz);
+#else
+		precvbuf->pskb = netdev_alloc_skb(padapter->pnetdev, skb_buf_sz);
+#endif
+		if (precvbuf->pskb == NULL) {
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("==================rtw_init_recvbuf(): alloc_skb fail!\n"));
+			return _FAIL;
+		}
+
+		precvbuf->phead = precvbuf->pskb->head;
+		precvbuf->pdata = precvbuf->pskb->data;
+		precvbuf->ptail = precvbuf->pskb->tail;
+		precvbuf->pend = precvbuf->pskb->end;
+		precvbuf->pbuf = precvbuf->pskb->data;
+	}
+//	else {
+//               RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("after rtw_init_recvbuf(): skb !=NULL!\n"));
+//	}
+
+	rtw_read_port(padapter, RTL8712_DMA_RX0FF, rd_cnt, (u8*)precvbuf);
+	precvbuf->ptail = precvbuf->ptail + rd_cnt;
+	precvbuf->len = rd_cnt;
+	/*{
+		u32 i;
+		printk("-----After read port[%d]-----\n",skb_buf_sz);
+		for (i = 0; i < skb_buf_sz; i = i + 8) {
+			printk("0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\n",precvbuf->pbuf[i],precvbuf->pbuf[i+1],precvbuf->pbuf[i+2],precvbuf->pbuf[i+3],precvbuf->pbuf[i+4],precvbuf->pbuf[i+5],precvbuf->pbuf[i+6],precvbuf->pbuf[i+7]);
+		}
+
+		printk("-----------\n");
+	}*/
+#if 1
+	recvbuf2recvframe_s(padapter, precvbuf);
+#else
+{
+	dev_kfree_skb_any(precvbuf->pskb);
+	precvbuf->pskb = NULL;
+	list_delete(&(precvbuf->list));
+	rtw_list_insert_tail(&precvbuf->list, get_list_head(&precvpriv->free_recv_buf_queue));
+	precvpriv->free_recv_buf_queue_cnt++;
+}
+#endif
+
+	return _SUCCESS;
+}
+
+void sd_recv_rxfifo(PADAPTER padapter);
+#if 0
+void sd_recv_rxfifo(PADAPTER padapter)
+{
+//	u8 *pdata, *ptail, *pfixed_tail,*pfixed_head,*pfixed_end,blk_shift_bit;
+	u16 rx_blknum;
+	u32 blk_sz, cnt;//,remain,tmp_cnt;
+	struct recv_priv *precvpriv;
+//	struct recv_stat *prxstat;
+	//union recv_frame *precvframe, *ppreframe = NULL; 
+//	_queue *pfree_recv_queue, *ppending_recv_queue;
+//	u8 tmp[2048];
+	struct recv_buf *precvbuf;
+	_list *precvbuf_head, *precvbuf_list;
+	_irqL irql, rx_proc_irq;
+//	uint pkt_len;
+//	u16 drvinfo_sz;
+
+	precvpriv = &padapter->recvpriv;
+	blk_sz = padapter->dvobjpriv.block_transfer_len;
+//	blk_shift_bit= (u8)padapter->dvobjpriv.blk_shiftbits;
+//	pfree_recv_queue = &(precvpriv->free_recv_queue);
+//	ppending_recv_queue = &(precvpriv->recv_pending_queue);
+
+	rx_blknum = padapter->dvobjpriv.rxblknum;
+//	_enter_critical_mutex(&padapter->dvobjpriv.rx_protect, &rx_proc_irq);
+//	padapter->dvobjpriv.rxblknum=rtw_read16(padapter, SDIO_RX0_RDYBLK_NUM);
+	sdio_read_int(padapter, SDIO_RX0_RDYBLK_NUM, 2, &padapter->dvobjpriv.rxblknum);
+	if (rx_blknum>padapter->dvobjpriv.rxblknum) {
+		cnt = (0x10000 - rx_blknum + padapter->dvobjpriv.rxblknum) * blk_sz;
+	} else {
+		cnt = (padapter->dvobjpriv.rxblknum-rx_blknum) * blk_sz;
+	}
+	RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("=====================sd_recv_rxfifo  padapter->dvobjpriv.rxblknum=%x Blk_Num = %x   cnt=%d",padapter->dvobjpriv.rxblknum, rx_blknum,cnt));
+        
+	if (cnt == 0) {
+//		remain = 0;
+		precvbuf = NULL;
+		RT_TRACE(_module_hci_intfs_c_,_drv_info_,("---===============sd_recv_rxfifo padapter->dvobjpriv.rxblknum=0x%x padapter->dvobjpriv.rxblknum_rd=0x%x", padapter->dvobjpriv.rxblknum,padapter->dvobjpriv.rxblknum_rd));
+		goto drop_pkt;
+	}
+
+	if(_rtw_queue_empty(&precvpriv->free_recv_buf_queue) == _TRUE)
+	{
+		precvbuf = NULL;
+		RT_TRACE(_module_hci_intfs_c_,_drv_emerg_,("\n sd_recv_rxfifo : precvbuf= NULL precvpriv->free_recv_buf_queue_cnt=%d \n",precvpriv->free_recv_buf_queue_cnt));
+		goto drop_pkt;
+	}
+	else
+	{
+		_enter_critical(&precvpriv->free_recv_buf_queue.lock, &irql);
+		precvbuf_head = get_list_head(&precvpriv->free_recv_buf_queue);
+		precvbuf_list = get_next(precvbuf_head);
+		precvbuf = LIST_CONTAINOR(precvbuf_list, struct recv_buf, list);
+		list_delete(&precvbuf->list);
+		precvpriv->free_recv_buf_queue_cnt--;
+
+		RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("\n sd_recv_rxfifo : precvbuf= 0x%p  dequeue: free_recv_buf_queue_cnt=%d\n",precvbuf,precvpriv->free_recv_buf_queue_cnt));
+		_exit_critical(&precvpriv->free_recv_buf_queue.lock, &irql);
+	}
+	read_pkt2recvbuf(padapter, cnt, precvbuf);
+
+	return;	
+
+drop_pkt:
+
+	if (cnt >0) {
+		do{
+			if (cnt > MAX_RECVBUF_SZ) {
+				rtw_read_port(padapter, 0x10380000, MAX_RECVBUF_SZ, (u8 *)precvpriv->recvbuf_drop);
+				RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("=========sd_recv_rxfifo precvbuf= NULL  no recvbuf    cnt=%d  tmp read %d",cnt,MAX_RECVBUF_SZ));
+				cnt=cnt-MAX_RECVBUF_SZ;
+			} else {
+				rtw_read_port(padapter, 0x10380000, cnt, (u8 *)precvpriv->recvbuf_drop);
+				RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("=========sd_recv_rxfifo precvbuf= NULL  no recvbuf    cnt=%d  tmp read(@) %d",cnt,cnt));
+				cnt=0;
+			}
+		} while(cnt > 0);
+	}
+
+	return;
+}
+#endif
+#if 0
+void sd_c2h_hdl(PADAPTER padapter)
+{
+	u8 cmd_seq, pkt_num = 0;
+	u16 tmp16, sz, cmd_len = 0;
+	u32 rd_sz=0, cmd_sz = 0;//,ptr;
+	struct evt_priv *pevtpriv = &padapter->evtpriv;
+	pkt_num = rtw_read8(padapter, 0x102500BF);
+//	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("@ sd_c2h_hdl:pkt_num=%d",pkt_num));
+get_next:
+//	ptr=rtw_read32(padapter,0x102500e8);
+//	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("@ sd_c2h_hdl:C2H fifo RDPTR=0x%x",ptr));
+//	ptr=rtw_read32(padapter,0x102500ec);
+//	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("@ sd_c2h_hdl:C2H fifo WTPTR=0x%x",ptr));
+//	if(pkt_num==0x0 ){
+//	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("@ sd_c2h_hdl:cmd_pkt num=0x%x!",pkt_num));
+//		return;
+//	}
+	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("@ sd_c2h_hdl:pkt_num=%d",pkt_num));
+	//memset(pevtpriv->c2h_mem,0,512);
+	rtw_read_port(padapter, RTL8712_DMA_C2HCMD, 512, pevtpriv->c2h_mem);
+	cmd_sz = *(u16 *)&pevtpriv->c2h_mem[0];
+	cmd_sz &= 0x3fff;
+	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("sd_c2h_hdl: cmd_sz=%d[0x%x]!",cmd_sz,cmd_sz));
+	tmp16 = *(u16 *)&pevtpriv->c2h_mem[4];
+	tmp16 &= 0x01ff;
+	if (tmp16 !=0x1ff) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("sd_c2h_hdl: 0x1ff error[0x%x]!",pevtpriv->c2h_mem[4]));
+		goto exit;
+	}
+	if((cmd_sz+24) >512){
+		rtw_read_port(padapter, RTL8712_DMA_C2HCMD, (cmd_sz+24-512), pevtpriv->c2h_mem+512);
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("sd_c2h_hdl: read the second part of c2h event!"));
+	}
+	cmd_seq = pevtpriv->c2h_mem[27];
+	cmd_seq &= 0x7f;
+	if (pevtpriv->event_seq != cmd_seq) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("sd_c2h_hdl: pevtpriv->event_seq (%d) != c2hbuf seq(%d)",pevtpriv->event_seq,cmd_seq));
+	} else {
+		RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("sd_c2h_hdl: pevtpriv->event_seq (%d) == c2hbuf seq(%d)",pevtpriv->event_seq,cmd_seq));
+	}
+	cmd_len = *(u16 *)&pevtpriv->c2h_mem[0];	
+	cmd_len &= 0x3ff;
+	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("@sd_c2h_hdl: cmd_len=%d",cmd_len));
+//	if(cmd_len){
+//		memset(pevtpriv->c2h_mem+cmd_len,0,cmd_len);
+//	rtw_read_port(padapter, RTL8712_DMA_C2HCMD, cmd_len, pevtpriv->c2h_mem+cmd_len);
+//	}
+//	pevtpriv->event_seq=pevtpriv->event_seq++;
+//	if(pevtpriv->event_seq>127)
+//		pevtpriv->event_seq=0;
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("sd_c2h_hdl:!"));
+	rxcmd_event_hdl(padapter,pevtpriv->c2h_mem);
+	if (pkt_num > 1) {
+		pkt_num--;
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("sd_c2h_hdl: pkt_num=%d",pkt_num));
+		goto get_next;
+	}
+
+exit:
+
+	return;
+}
+#endif
+void update_free_ffsz_int(_adapter *padapter )
+{
+	struct xmit_priv *pxmitpriv=&padapter->xmitpriv;
+	RT_TRACE(_module_hci_ops_c_,_drv_err_,("\n====(before)=padapter->xmitpriv.public_pgsz=0x%x====update_free_ffsz:  free_pg=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x \n",
+			padapter->xmitpriv.public_pgsz,
+			pxmitpriv->free_pg[0],pxmitpriv->free_pg[1],pxmitpriv->free_pg[2],pxmitpriv->free_pg[3],
+			pxmitpriv->free_pg[4],pxmitpriv->free_pg[5],pxmitpriv->free_pg[6],pxmitpriv->free_pg[7]));
+//	rtw_read_mem(padapter,SDIO_BCNQ_FREEPG,8,pxmitpriv->free_pg);
+	sdio_read_int(padapter, SDIO_BCNQ_FREEPG, 8, pxmitpriv->free_pg);
+	padapter->xmitpriv.public_pgsz = pxmitpriv->free_pg[0];
+	if (pxmitpriv->public_pgsz > pxmitpriv->init_pgsz) {
+		pxmitpriv->init_pgsz = pxmitpriv->public_pgsz;
+	}
+
+	{
+		u8 diff;
+		if (pxmitpriv->public_pgsz > (pxmitpriv->init_pgsz - pxmitpriv->used_pgsz)) {
+			RT_TRACE(_module_hci_ops_c_,_drv_err_,("\n====(0)=====update_free_ffsz: pxmitpriv->public_pgsz=0x%x pxmitpriv->init_pgsz=0x%x  pxmitpriv->used_pgsz=0x%x \n",pxmitpriv->public_pgsz ,pxmitpriv->init_pgsz, pxmitpriv->used_pgsz));
+			diff = pxmitpriv->public_pgsz - (pxmitpriv->init_pgsz - pxmitpriv->used_pgsz);
+			pxmitpriv->used_pgsz = pxmitpriv->used_pgsz - diff;
+//			pxmitpriv->required_pgsz = pxmitpriv->required_pgsz - diff;
+			RT_TRACE(_module_hci_ops_c_,_drv_err_,("\n====(1)=====update_free_ffsz: pxmitpriv->public_pgsz =0x%x diff=0x%x pxmitpriv->used_pgsz=0x%x pxmitpriv->required_pgsz=0x%x\n",pxmitpriv->public_pgsz,diff,pxmitpriv->used_pgsz,pxmitpriv->required_pgsz) );
+		} else {
+
+		}
+	}
+
+	RT_TRACE(_module_hci_ops_c_,_drv_err_,("\n====(after)=====update_free_ffsz:  free_pg=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x:0x%x \n",
+		pxmitpriv->free_pg[0],pxmitpriv->free_pg[1],pxmitpriv->free_pg[2],pxmitpriv->free_pg[3],
+		pxmitpriv->free_pg[4],pxmitpriv->free_pg[5],pxmitpriv->free_pg[6],pxmitpriv->free_pg[7]));
+
+	return;
+}
+
+void sd_int_dpc(PADAPTER padapter);
+#if 0
+void sd_int_dpc(PADAPTER padapter)
+{
+	uint 	tasks= (padapter->IsrContent /*& padapter->ImrContent*/);
+//	rtw_write16(padapter,SDIO_HIMR,0);
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_notice_,(" sd_int_dpc[0x%x] ",padapter->IsrContent));
+
+	if ((tasks & _VOQ_AVAL_IND) || (tasks & _VIQ_AVAL_IND) || (tasks & _BEQ_AVAL_IND) || (tasks & _BKQ_AVAL_IND) || (tasks & _BMCQ_AVAL_IND)) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("==============INT : _TXDONE"));
+		update_free_ffsz_int(padapter);
+	} else {
+		if (((padapter->xmitpriv.init_pgsz - padapter->xmitpriv.used_pgsz) > 0 && (padapter->xmitpriv.init_pgsz - padapter->xmitpriv.used_pgsz) < 0x2f) || padapter->xmitpriv.required_pgsz > 0) {
+			RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("==============padapter->xmitpriv.public_pgsz[0x%x] <30 ",padapter->xmitpriv.public_pgsz));
+			update_free_ffsz_int(padapter);
+		}
+	}
+
+	if(tasks & _C2HCMD)
+	{
+//		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("======C2H_CMD========"));
+		padapter->IsrContent  ^= _C2HCMD;
+		sd_c2h_hdl(padapter);
+//		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("======C2H_CMD[end]========"));
+	}
+
+	if(tasks & _RXDONE)
+	{
+		RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("==============INT : _RXDONE"));
+		padapter->IsrContent  ^= _RXDONE;
+		sd_recv_rxfifo(padapter);
+	}
+
+}
+#endif
+void sd_sync_int_hdl(struct sdio_func *func)
+{
+	struct dvobj_priv *psdpriv = sdio_get_drvdata(func);
+	_adapter *padapter = (_adapter*)psdpriv->padapter;
+	u16 tmp16;
+//	uint tasks;
+
+_func_enter_;
+
+	if ((padapter->bDriverStopped ==_TRUE) || (padapter->bSurpriseRemoved == _TRUE)) {
+		goto exit;
+	}
+
+	//padapter->IsrContent=rtw_read16(padapter, SDIO_HISR);
+	sdio_read_int(padapter, SDIO_HISR, 2, &psdpriv->sdio_hisr);
+
+	if (psdpriv->sdio_hisr & psdpriv->sdio_himr)
+	{
+		sdio_write_int(padapter, SDIO_HIMR, 0, 2);
+		sd_int_dpc(padapter);
+		sdio_write_int(padapter, SDIO_HIMR, psdpriv->sdio_himr, 2);
+
+		sdio_read_int(padapter, SDIO_HIMR, 2, &tmp16);
+		if (tmp16 != psdpriv->sdio_himr)
+			sdio_write_int(padapter, SDIO_HIMR, psdpriv->sdio_himr, 2);
+	} else {
+		RT_TRACE(_module_hci_intfs_c_, _drv_info_, ("<=========== sd_sync_int_hdl(): not our INT"));
+	}
+exit:
+
+_func_exit_;
+
+	return;
+}
+
+static int r871xs_drv_init(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	_adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	struct net_device *pnetdev;
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_alert_,("+871x - drv_init:id=0x%p func->vendor=0x%x func->device=0x%x\n",id,func->vendor,func->device));
+
+	//step 1.
+	pnetdev = rtw_init_netdev();
+	if (!pnetdev)
+		goto error;	
+
+	padapter = netdev_priv(pnetdev);
+	pdvobjpriv = &padapter->dvobjpriv;
+	pdvobjpriv->padapter = padapter;
+	pdvobjpriv->func = func;
+	sdio_set_drvdata(func, pdvobjpriv);
+	SET_NETDEV_DEV(pnetdev, &func->dev);
+
+
+	//step 2.
+	if (alloc_io_queue(padapter) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Can't init io_reqs\n"));
+		goto error;
+	}
+
+
+#if 0  //temp remove
+	//step 3.
+	if (loadparam(padapter, pnetdev) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Read Parameter Failed!\n"));
+		goto error;
+	}
+#endif
+
+	//step 4.
+	//dvobj_init(padapter);
+	padapter->dvobj_init = &sd_dvobj_init;
+	padapter->dvobj_deinit = &sd_dvobj_deinit;
+	padapter->halpriv.hal_bus_init = &sd_hal_bus_init;
+	padapter->halpriv.hal_bus_deinit = &sd_hal_bus_deinit;
+
+	if (padapter->dvobj_init == NULL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n Initialize dvobjpriv.dvobj_init error!!!\n"));
+		goto error;
+	}
+
+	if (padapter->dvobj_init(padapter) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n initialize device object priv Failed!\n"));			
+		goto error;
+	}
+
+
+	//step 6.
+	if (rtw_init_drv_sw(padapter) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));			
+		goto error;
+	}
+
+#if 1
+{
+	//step 7.
+	u8 mac[6];
+	mac[0]=0x00;
+	mac[1]=0xe0;
+	mac[2]=0x4c;
+	mac[3]=0x87;
+	mac[4]=0x66;
+	mac[5]=0x55;
+
+	_rtw_memcpy(pnetdev->dev_addr, mac/*padapter->eeprompriv.mac_addr*/, ETH_ALEN);
+	RT_TRACE(_module_hci_intfs_c_,_drv_info_,("pnetdev->dev_addr=0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\n",pnetdev->dev_addr[0],pnetdev->dev_addr[1],pnetdev->dev_addr[2],pnetdev->dev_addr[3],pnetdev->dev_addr[4],pnetdev->dev_addr[5]));
+}
+#endif
+	//step 8.
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
+		goto error;
+	}
+	RT_TRACE(_module_hci_intfs_c_,_drv_info_,("register_netdev() success\n"));
+	RT_TRACE(_module_hci_intfs_c_,_drv_notice_,("-drv_init - Adapter->bDriverStopped=%d, Adapter->bSurpriseRemoved=%d\n",padapter->bDriverStopped, padapter->bSurpriseRemoved));
+	RT_TRACE(_module_hci_intfs_c_,_drv_info_,("-871xs_drv - drv_init, success!\n"));
+
+	return 0;
+
+error:
+
+	if (padapter->dvobj_deinit == NULL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n Initialize dvobjpriv.dvobj_deinit error!!!\n"));
+	} else {
+		padapter->dvobj_deinit(padapter);
+	} 	  
+
+	if (pnetdev) {
+		unregister_netdev(pnetdev);
+		free_netdev(pnetdev);
+	}
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_emerg_, ("-871x_sdio - drv_init, fail!\n"));
+
+	return -1;
+}
+
+void rtl871x_intf_stop(_adapter *padapter)
+{
+	// Disable interrupt, also done in rtl8712_hal_deinit
+//	rtw_write16(padapter, SDIO_HIMR, 0x00);
+}
+
+void r871x_dev_unload(_adapter *padapter)
+{
+	struct net_device *pnetdev = (struct net_device*)padapter->pnetdev;
+
+	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("+r871x_dev_unload\n"));
+
+	if (padapter->bup == _TRUE)
+	{
+#if 0
+		//s1.
+		if (pnetdev) {
+			netif_carrier_off(pnetdev);
+			netif_stop_queue(pnetdev);
+		}
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("@ r871x_dev_unload:complelte s1!\n"));
+
+		//s2.
+		// indicate-disconnect if necssary (free all assoc-resources)
+		// dis-assoc from assoc_sta (optional)
+		rtw_indicate_disconnect(padapter);
+		rtw_free_network_queue(padapter,_TRUE);
+#endif
+
+		padapter->bDriverStopped = _TRUE;
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("@ r871x_dev_unload:complete s2!\n"));
+
+		//s3.
+		rtl871x_intf_stop(padapter);
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("@ r871x_dev_unload:complete s3!\n"));
+
+		//s4.
+		rtw_stop_drv_threads(padapter);
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("@ r871x_dev_unload:complete s4!\n"));
+
+		//s5.
+		if (padapter->bSurpriseRemoved == _FALSE) {
+			rtl871x_hal_deinit(padapter);
+			padapter->bSurpriseRemoved = _TRUE;
+		}
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("@ r871x_dev_unload:complelt s5!\n"));
+
+		//s6.
+		if (padapter->dvobj_deinit) {
+			padapter->dvobj_deinit(padapter); // call sd_dvobj_deinit()
+		} else {
+			RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize hcipriv.hci_priv_init error!!!\n"));
+		}
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("@ r871x_dev_unload:complete s6!\n"));
+
+		padapter->bup = _FALSE;
+	}
+	else {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == _FALSE\n" ));
+	}
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-r871x_dev_unload\n"));
+}
+
+static void r8712s_dev_remove(struct sdio_func *func)
+{
+	_adapter *padapter = (_adapter*) (((struct dvobj_priv*)sdio_get_drvdata(func))->padapter);
+	struct net_device *pnetdev = (struct net_device *)padapter->pnetdev;
+
+_func_exit_;
+
+	if (padapter)
+	{
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("+dev_remove()\n"));
+
+//		padapter->bSurpriseRemoved = _TRUE;
+
+		if (pnetdev)
+			unregister_netdev(pnetdev); //will call netdev_close()
+
+		cancel_all_timer(padapter);
+		
+		r871x_dev_unload(padapter);
+
+		rtw_free_drv_sw(padapter);
+
+		sdio_claim_host(func);
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in dev_remove():sdio_claim_host !\n"));
+		sdio_release_irq(func);
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in dev_remove():sdio_release_irq !\n"));
+		sdio_disable_func(func);
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in dev_remove():sdio_disable_func !\n"));
+		sdio_release_host(func);
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" in dev_remove():sdio_release_host !\n"));
+	}
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-dev_remove()\n"));
+
+_func_exit_;
+
+	return;
+}
+
+static drv_priv drvpriv = {	
+		.r871xs_drv.probe		= r871xs_drv_init,
+		.r871xs_drv.remove		= r8712s_dev_remove,
+		.r871xs_drv.name		= "rtl871x_sdio_wlan",
+		.r871xs_drv.id_table	= sdio_ids,
+};	
+
+
+static int __init r8712s_drv_entry(void)
+{
+	int status;
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+8712s_sdio - drv_entry\n"));
+	status = sdio_register_driver(&drvpriv.r871xs_drv);
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-8712_sdio - drv_entry, status=%d\n", status));	
+
+	return status;
+}
+
+static void __exit r8712s_drv_halt(void)
+{
+	int ret;
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+8712_sdio - drv_halt\n"));
+	sdio_unregister_driver(&drvpriv.r871xs_drv);	// call r8712s_dev_remove()
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-8712_sdio - drv_halt\n"));
+
+}
+
+
+module_init(r8712s_drv_entry);
+module_exit(r8712s_drv_halt);
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,1223 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _HCI_INTF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+#include <hal_init.h>
+#include <rtl8712_efuse.h>
+#include <rtw_version.h>
+#include <mlme_osdep.h>
+
+#ifndef CONFIG_USB_HCI
+
+#error "CONFIG_USB_HCI shall be on!\n"
+
+#endif
+
+#include <usb_vendor_req.h>
+#include <usb_ops.h>
+#include <usb_osintf.h>
+#include <usb_hal.h>
+
+#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
+
+#error "Shall be Linux or Windows, but not both!\n"
+
+#endif
+
+#ifdef CONFIG_80211N_HT
+extern int rtw_ht_enable;
+extern int rtw_cbw40_enable;
+extern int rtw_ampdu_enable;//for enable tx_ampdu
+#endif
+
+extern char* rtw_initmac;
+
+static struct usb_interface *pintf;
+
+extern u32 rtw_start_drv_threads(_adapter *padapter);
+extern void rtw_stop_drv_threads (_adapter *padapter);
+extern u8 rtw_init_drv_sw(_adapter *padapter);
+extern u8 rtw_free_drv_sw(_adapter *padapter);
+extern struct net_device *rtw_init_netdev(void);
+extern void cancel_all_timer(_adapter *padapter);
+#ifdef CONFIG_IPS
+extern int  ips_netdrv_open(_adapter *padapter);
+extern void ips_dev_unload(_adapter *padapter);
+#endif
+
+int pm_netdev_open(struct net_device *pnetdev,u8 bnormal);
+int rtw_suspend(struct usb_interface *intf, pm_message_t message);
+int rtw_resume(struct usb_interface *intf);
+
+
+extern u8 reset_drv_sw(_adapter *padapter);
+static void rtw_dev_unload(_adapter *padapter);
+
+static int rtw_drv_init(struct usb_interface *pusb_intf,const struct usb_device_id *pdid);
+static void rtw_dev_remove(struct usb_interface *pusb_intf);
+
+#define USB_VENDER_ID_REALTEK		0x0BDA
+
+//DID_USB_V50_20110209
+static struct usb_device_id rtw_usb_id_tbl[] ={
+
+	/*=== Realtek demoboard ===*/		
+	{USB_DEVICE(0x0BDA, 0x8191)},//Default ID
+	
+	/****** 8188CUS ********/
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8176)},//8188cu 1*1 dongole 	
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8170)},//8188CE-VAU USB minCard
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817A)},//8188cu Slim Solo
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817B)},//8188cu Slim Combo	
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817D)},//8188RU High-power USB Dongle
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8754)},//8188 Combo for BC4
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817F)},//8188RU
+	
+	/****** 8192CUS ********/
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8177)},//8191cu 1*2
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8178)},//8192cu 2*2
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x817C)},//8192CE-VAU USB minCard
+
+	/*=== Customer ID ===*/	
+	/****** 8188CUS Dongle********/
+	{USB_DEVICE(0x07B8, 0x8189)},//Funai - Abocom
+	{USB_DEVICE(0x2019, 0xED17)},//PCI - Edimax        
+	{USB_DEVICE(0x0DF6, 0x0052)}, //Sitecom - Edimax    
+	{USB_DEVICE(0x7392, 0x7811)},//Edimax - Edimax  
+	{USB_DEVICE(0x07B8, 0x8189)},//Abocom - Abocom 
+	{USB_DEVICE(0x0EB0, 0x9071)},//NO Brand - Etop  
+	{USB_DEVICE(0x06F8, 0xE033)},//Hercules - Edimax 
+	{USB_DEVICE(0x103C, 0x1629)},//HP - Lite-On ,8188CUS Slim Combo
+	{USB_DEVICE(0x2001, 0x3308)},//D-Link - Alpha
+	{USB_DEVICE(0x050D, 0x1102)},//Belkin - Edimax
+	{USB_DEVICE(0x2019, 0xAB2A)},//Planex - Abocom
+	{USB_DEVICE(0x20F4, 0x648B)},//TRENDnet - Cameo
+	{USB_DEVICE(0x4855, 0x0090)},// 	- Feixun
+	{USB_DEVICE(0x13D3, 0x3357)},	// -AzureWave
+	{USB_DEVICE(0x0DF6, 0x005C)},//Sitecom-Edimax
+	{USB_DEVICE(0x0BDA, 0x5088)},//Thinkware-CC&C
+	{USB_DEVICE(0x4856, 0x0091)},//NetweeN-Feixun
+	{USB_DEVICE(0x9846, 0x9041)},//Netgear,Cameo
+	{USB_DEVICE(0x0846, 0x9041)},//Netgear,Cameo
+	
+	/****** 8188CE-VAU********/
+	{USB_DEVICE(0x13D3, 0x3358)},// -Azwave 8188CE-VAU
+
+	/****** 8188CUS Slim Solo********/
+	{USB_DEVICE(0x04F2, 0xAFF7)},//XAVI-XAVI
+
+	/****** 8188CUS Slim Combo ********/
+	{USB_DEVICE(0x04F2, 0xAFF8)},//XAVI-XAVI
+	{USB_DEVICE(0x04F2, 0xAFF9)},//XAVI-XAVI
+	{USB_DEVICE(0x04F2, 0xAFFA)},//XAVI-XAVI
+	{USB_DEVICE(0x04F2, 0xAFFB)},//XAVI-XAVI
+	{USB_DEVICE(0x04F2, 0xAFFC)},//XAVI-XAVI
+	
+	
+	/****** 8192CUS Dongle********/	
+	{USB_DEVICE(0x07b8, 0x8178)},//Funai -Abocom
+	{USB_DEVICE(0x2001, 0x3307)},//D-Link-Cameo   
+	{USB_DEVICE(0x2001, 0x330A)},//D-Link-Alpha   
+	{USB_DEVICE(0x2001, 0x3309)},//D-Link-Alpha   	
+	{USB_DEVICE(0x0586, 0x341F)},//Zyxel -Abocom
+	{USB_DEVICE(0x7392, 0x7822)},//Edimax -Edimax	
+	{USB_DEVICE(0x2019, 0xAB2B)},//Planex -Abocom
+	{USB_DEVICE(0x07B8, 0x8178)},//Abocom -Abocom	
+	{USB_DEVICE(0x07AA, 0x0056)},//ATKK-Gemtek	
+	{USB_DEVICE(0x4855, 0x0091)},// 	-Feixun
+	{USB_DEVICE(0x050D, 0x2102)},//Belkin-Sercomm
+	{USB_DEVICE(0x2001, 0x3307)},//D-Link-Cameo	
+	{USB_DEVICE(0x050D, 0x2102)},//Belkin-Sercomm
+	{USB_DEVICE(0x050D, 0x2103)},//Belkin-Edimax
+	{}
+};
+
+static struct specific_device_id specific_device_id_tbl[] = {
+	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x8177, .flags=SPEC_DEV_ID_DISABLE_HT},//8188cu 1*1 dongole, (b/g mode only)
+	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x817E, .flags=SPEC_DEV_ID_DISABLE_HT},//8188CE-VAU USB minCard (b/g mode only)
+	{.idVendor=0x0b05, .idProduct=0x1791, .flags=SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor=0x13D3, .idProduct=0x3311, .flags=SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor=0x13D3, .idProduct=0x3359, .flags=SPEC_DEV_ID_DISABLE_HT},	//Russian customer -Azwave (8188CE-VAU  g mode)		
+	{}
+};
+
+typedef struct _driver_priv{
+
+	struct usb_driver rtw_usb_drv;
+	int drv_registered;
+
+}drv_priv, *pdrv_priv;
+
+static drv_priv drvpriv = {
+	.rtw_usb_drv.name = (char*)"rtw_usb_drv",
+	.rtw_usb_drv.probe = rtw_drv_init,
+	.rtw_usb_drv.disconnect = rtw_dev_remove,
+	.rtw_usb_drv.id_table = rtw_usb_id_tbl,
+	.rtw_usb_drv.suspend =  rtw_suspend,
+	.rtw_usb_drv.resume = rtw_resume,
+#ifdef CONFIG_AUTOSUSPEND	
+	.rtw_usb_drv.supports_autosuspend = 1,	
+#endif
+};
+
+MODULE_DEVICE_TABLE(usb, rtw_usb_id_tbl);
+
+static void intf_chip_configure(_adapter *padapter)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);	
+
+	if(pHalData->hal_ops.intf_chip_configure)
+		pHalData->hal_ops.intf_chip_configure(padapter);
+}
+
+static void intf_read_chip_info(_adapter *padapter)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+
+	pHalData->hal_ops.read_adapter_info(padapter);
+}
+
+static u32 usb_dvobj_init(_adapter *padapter)
+{
+	int i;
+	u8 val8;
+	u32 blocksz;
+	int status = _SUCCESS;
+
+	struct usb_device_descriptor 		*pdev_desc;
+
+	struct usb_host_config			*phost_conf;
+	struct usb_config_descriptor 		*pconf_desc;
+
+	struct usb_host_interface		*phost_iface;
+	struct usb_interface_descriptor		*piface_desc;
+
+	struct usb_host_endpoint		*phost_endp;
+	struct usb_endpoint_descriptor		*pendp_desc;
+
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+
+	struct dvobj_priv *pdvobjpriv = &padapter->dvobjpriv;
+	struct usb_device *pusbd = pdvobjpriv->pusbdev;
+
+	//PURB urb = NULL;
+
+_func_enter_;
+
+	pdvobjpriv->padapter = padapter;
+
+	pHalData->RtNumInPipes = 0;
+	pHalData->RtNumOutPipes = 0;
+
+	//padapter->EepromAddressSize = 6;
+	//pdvobjpriv->nr_endpoint = 6;
+
+	pdev_desc = &pusbd->descriptor;
+
+#if 0
+	printk("\n8712_usb_device_descriptor:\n");
+	printk("bLength=%x\n", pdev_desc->bLength);
+	printk("bDescriptorType=%x\n", pdev_desc->bDescriptorType);
+	printk("bcdUSB=%x\n", pdev_desc->bcdUSB);
+	printk("bDeviceClass=%x\n", pdev_desc->bDeviceClass);
+	printk("bDeviceSubClass=%x\n", pdev_desc->bDeviceSubClass);
+	printk("bDeviceProtocol=%x\n", pdev_desc->bDeviceProtocol);
+	printk("bMaxPacketSize0=%x\n", pdev_desc->bMaxPacketSize0);
+	printk("idVendor=%x\n", pdev_desc->idVendor);
+	printk("idProduct=%x\n", pdev_desc->idProduct);
+	printk("bcdDevice=%x\n", pdev_desc->bcdDevice);
+	printk("iManufacturer=%x\n", pdev_desc->iManufacturer);
+	printk("iProduct=%x\n", pdev_desc->iProduct);
+	printk("iSerialNumber=%x\n", pdev_desc->iSerialNumber);
+	printk("bNumConfigurations=%x\n", pdev_desc->bNumConfigurations);
+#endif
+
+	phost_conf = pusbd->actconfig;
+	pconf_desc = &phost_conf->desc;
+
+#if 0
+	printk("\n8712_usb_configuration_descriptor:\n");
+	printk("bLength=%x\n", pconf_desc->bLength);
+	printk("bDescriptorType=%x\n", pconf_desc->bDescriptorType);
+	printk("wTotalLength=%x\n", pconf_desc->wTotalLength);
+	printk("bNumInterfaces=%x\n", pconf_desc->bNumInterfaces);
+	printk("bConfigurationValue=%x\n", pconf_desc->bConfigurationValue);
+	printk("iConfiguration=%x\n", pconf_desc->iConfiguration);
+	printk("bmAttributes=%x\n", pconf_desc->bmAttributes);
+	printk("bMaxPower=%x\n", pconf_desc->bMaxPower);
+#endif
+
+	//printk("\n/****** num of altsetting = (%d) ******/\n", pintf->num_altsetting);
+
+	phost_iface = &pintf->altsetting[0];
+	piface_desc = &phost_iface->desc;
+
+#if 0
+	printk("\n8712_usb_interface_descriptor:\n");
+	printk("bLength=%x\n", piface_desc->bLength);
+	printk("bDescriptorType=%x\n", piface_desc->bDescriptorType);
+	printk("bInterfaceNumber=%x\n", piface_desc->bInterfaceNumber);
+	printk("bAlternateSetting=%x\n", piface_desc->bAlternateSetting);
+	printk("bNumEndpoints=%x\n", piface_desc->bNumEndpoints);
+	printk("bInterfaceClass=%x\n", piface_desc->bInterfaceClass);
+	printk("bInterfaceSubClass=%x\n", piface_desc->bInterfaceSubClass);
+	printk("bInterfaceProtocol=%x\n", piface_desc->bInterfaceProtocol);
+	printk("iInterface=%x\n", piface_desc->iInterface);
+#endif
+
+	pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
+
+
+	//printk("\ndump 8712_usb_endpoint_descriptor:\n");
+
+	for (i = 0; i < pdvobjpriv->nr_endpoint; i++)
+	{
+		phost_endp = phost_iface->endpoint + i;
+		if (phost_endp)
+		{
+			pendp_desc = &phost_endp->desc;
+
+			printk("\n8192_usb_endpoint_descriptor(%d):\n", i);
+			printk("bLength=%x\n",pendp_desc->bLength);
+			printk("bDescriptorType=%x\n",pendp_desc->bDescriptorType);
+			printk("bEndpointAddress=%x\n",pendp_desc->bEndpointAddress);
+
+			if (pendp_desc->bEndpointAddress & USB_DIR_IN)
+				pHalData->RtNumInPipes++;
+			else
+				pHalData->RtNumOutPipes++;
+
+			//printk("bmAttributes=%x\n",pendp_desc->bmAttributes);
+			//printk("wMaxPacketSize=%x\n",pendp_desc->wMaxPacketSize);
+			printk("wMaxPacketSize=%x\n",le16_to_cpu(pendp_desc->wMaxPacketSize));
+			printk("bInterval=%x\n",pendp_desc->bInterval);
+			//printk("bRefresh=%x\n",pendp_desc->bRefresh);
+			//printk("bSynchAddress=%x\n",pendp_desc->bSynchAddress);
+		}
+	}
+	
+	printk("nr_endpoint=%d, in_num=%d, out_num=%d\n\n", pdvobjpriv->nr_endpoint, pHalData->RtNumInPipes, pHalData->RtNumOutPipes);
+
+	if (pusbd->speed == USB_SPEED_HIGH)
+	{
+		pdvobjpriv->ishighspeed = _TRUE;
+		pHalData->UsbBulkOutSize = USB_HIGH_SPEED_BULK_SIZE;//512 bytes
+		printk("8192cu: USB_SPEED_HIGH\n");
+	}
+	else
+	{
+		pdvobjpriv->ishighspeed = _FALSE;
+		pHalData->UsbBulkOutSize = USB_FULL_SPEED_BULK_SIZE;//64 bytes
+		printk("8192cu: NON USB_SPEED_HIGH\n");
+	}
+
+
+	//.2
+	if ((init_io_priv(padapter)) == _FAIL)
+	{
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" \n Can't init io_reqs\n"));
+		status = _FAIL;
+	}
+
+	//.3 misc
+	_rtw_init_sema(&(padapter->dvobjpriv.usb_suspend_sema), 0);	
+
+
+	//.4 usb endpoint mapping
+	intf_chip_configure(padapter);
+
+_func_exit_;
+
+	return status;
+}
+
+static void usb_dvobj_deinit(_adapter * padapter){
+
+	struct dvobj_priv *pdvobjpriv=&padapter->dvobjpriv;
+
+	_func_enter_;
+
+
+	_func_exit_;
+}
+
+static void decide_chip_type_by_usb_device_id(_adapter *padapter, const struct usb_device_id *pdid)
+{
+
+	padapter->chip_type = NULL_CHIP_TYPE;
+
+	//TODO:
+	padapter->chip_type = RTL8188C_8192C;
+
+}
+
+
+static void rtw_intf_stop(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtl871x_intf_stop\n"));
+
+	//disabel_hw_interrupt
+	if(padapter->bSurpriseRemoved == _FALSE)
+	{
+		//device still exists, so driver can do i/o operation
+		//TODO:
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("SurpriseRemoved==_FALSE\n"));
+	}
+
+	//cancel in irp
+	if(pHalData->hal_ops.inirp_deinit !=NULL)
+	{
+		pHalData->hal_ops.inirp_deinit(padapter);
+	}
+
+	//cancel out irp
+	write_port_cancel(padapter);
+
+
+	//todo:cancel other irps
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-rtl871x_intf_stop\n"));
+
+}
+
+void recv_buf_clean_up(_adapter *padapter)
+{
+	u8 trycnt = 100;
+	//RX DMA stop
+	rtw_write32(padapter,0x284,(rtw_read32(padapter,0x284)|BIT18));
+	do{
+		if(!(rtw_read32(padapter,0x284)&BIT17))
+			break;				
+	}while(trycnt--);
+	if(trycnt ==0)
+	{
+		printk("Stop RX DMA failed \n");
+	}
+	//RQPN Load 0
+	rtw_write16(padapter,0x214,0x0);
+	rtw_write32(padapter,0x200,0x80000000);
+	rtw_mdelay_os(10);
+}
+
+#ifdef CONFIG_IPS
+void ips_dev_unload(_adapter *padapter)
+{
+	struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+		
+	printk("%s...\n",__FUNCTION__);
+//	if(padapter->bup == _TRUE)
+	{
+		printk("+ips_dev_unload\n");
+		//padapter->bup = _FALSE;
+		//padapter->bDriverStopped = _TRUE;
+
+		//s3.
+		rtw_write8(padapter,0x522,0xff);//pause tx
+		//keep sn
+		pxmitpriv->nqos_ssn = rtw_read16(padapter,0x4dc);
+		recv_buf_clean_up(padapter);	//rx clean up	
+		rtw_intf_stop(padapter);//cancel read /write port
+
+		//s5.
+		if(padapter->bSurpriseRemoved == _FALSE)
+		{			
+			printk("r8192_dev_unload()->rtl8192_hal_deinit()\n");
+			rtw_hal_deinit(padapter);
+
+			//padapter->bSurpriseRemoved = _TRUE;
+		}
+
+		//s6.
+		if(padapter->dvobj_deinit)
+		{
+			padapter->dvobj_deinit(padapter);
+
+		}
+		else
+		{
+			RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize hcipriv.hci_priv_init error!!!\n"));
+		}
+
+	}
+/*	else
+	{
+		printk("ips_dev_unload():padapter->bup == _FALSE\n" );
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == _FALSE\n" ));
+	}*/
+	printk("-ips_dev_unload\n");
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-r871x_dev_unload\n"));
+}
+#endif
+static void rtw_dev_unload(_adapter *padapter)
+{
+	struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_dev_unload\n"));
+
+	if(padapter->bup == _TRUE)
+	{
+		printk("+rtw_dev_unload\n");
+		//s1.
+/*		if(pnetdev)
+		{
+			netif_carrier_off(pnetdev);
+			netif_stop_queue(pnetdev);
+		}
+
+		//s2.
+		//s2-1.  issue rtw_disassoc_cmd to fw
+		rtw_disassoc_cmd(padapter);
+		//s2-2.  indicate disconnect to os
+		rtw_indicate_disconnect(padapter);
+		//s2-3.
+		rtw_free_assoc_resources(padapter);
+		//s2-4.
+		rtw_free_network_queue(padapter,_TRUE);
+*/
+
+		padapter->bDriverStopped = _TRUE;
+		
+		//s3.
+		rtw_write8(padapter,0x522,0xff);//pause tx		
+		rtw_intf_stop(padapter);
+
+		//s4.
+		if(!padapter->pwrctrlpriv.bInternalAutoSuspend )			
+		rtw_stop_drv_threads(padapter);
+
+
+		//s5.
+		if(padapter->bSurpriseRemoved == _FALSE)
+		{
+			//printk("r871x_dev_unload()->rtl871x_hal_deinit()\n");
+			#ifdef CONFIG_WOWLAN
+			if(padapter->pwrctrlpriv.bSupportWakeOnWlan==_TRUE){
+				printk("%s bSupportWakeOnWlan==_TRUE  do not run rtw_hal_deinit()\n",__FUNCTION__);
+			}
+			else
+			#endif
+			{
+				rtw_hal_deinit(padapter);
+			}
+			padapter->bSurpriseRemoved = _TRUE;
+		}
+
+		//s6.
+		usb_dvobj_deinit(padapter);
+		
+
+		padapter->bup = _FALSE;
+
+	}
+	else
+	{
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == _FALSE\n" ));
+	}
+
+	printk("-rtw_dev_unload\n");
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-rtw_dev_unload\n"));
+
+}
+
+static void disable_ht_for_spec_devid(const struct usb_device_id *pdid)
+{
+#ifdef CONFIG_80211N_HT
+	u16 vid, pid;
+	u32 flags;
+	int i;
+	int num = sizeof(specific_device_id_tbl)/sizeof(struct specific_device_id);
+
+	for(i=0; i<num; i++)
+	{
+		vid = specific_device_id_tbl[i].idVendor;
+		pid = specific_device_id_tbl[i].idProduct;
+		flags = specific_device_id_tbl[i].flags;
+
+		if((pdid->idVendor==vid) && (pdid->idProduct==pid) && (flags&SPEC_DEV_ID_DISABLE_HT))
+		{
+			 rtw_ht_enable = 0;
+			 rtw_cbw40_enable = 0;
+			 rtw_ampdu_enable = 0;
+		}
+
+	}
+#endif
+}
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+extern u8 rtl8192c_disconnect_hdl(_adapter *padapter, u8 *pbuf);
+int rtw_hw_suspend(_adapter *padapter )
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct usb_interface *pusb_intf = padapter->dvobjpriv.pusbintf;	
+	struct net_device *pnetdev=usb_get_intfdata(pusb_intf);
+	
+	_func_enter_;
+
+	if((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
+	{
+		printk("padapter->bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n",
+			padapter->bup, padapter->bDriverStopped,padapter->bSurpriseRemoved);		
+		goto error_exit;
+	}
+	
+	if(padapter)//system suspend
+	{		
+		LeaveAllPowerSaveMode(padapter);
+		
+		printk("==> rtw_hw_suspend\n");	
+		_enter_pwrlock(&pwrpriv->lock);
+		pwrpriv->bips_processing = _TRUE;
+		padapter->net_closed = _TRUE;
+		//s1.
+		if(pnetdev)
+		{
+			netif_carrier_off(pnetdev);
+			netif_stop_queue(pnetdev);
+		}
+
+		//s2.
+		//s2-1.  issue rtw_disassoc_cmd to fw
+		//rtw_disassoc_cmd(padapter);
+		rtl8192c_disconnect_hdl(padapter, NULL);
+		//s2-2.  indicate disconnect to os
+
+		//rtw_indicate_disconnect(padapter);
+		{
+			struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;		
+
+			if((pmlmepriv->fw_state & _FW_LINKED))
+			{
+			        pmlmepriv->fw_state ^= _FW_LINKED;
+
+				padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);
+
+				rtw_os_indicate_disconnect(padapter);
+				
+#ifdef CONFIG_LPS
+				lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 0);
+#endif
+			}
+
+		}
+		//s2-3.
+		rtw_free_assoc_resources(padapter);
+
+		//s2-4.
+		rtw_free_network_queue(padapter,_TRUE);
+
+		ips_dev_unload(padapter);			
+
+		pwrpriv->current_rfpwrstate = rf_off;
+		pwrpriv->bips_processing = _FALSE;		
+
+		_exit_pwrlock(&pwrpriv->lock);
+	}
+	else
+		goto error_exit;
+	
+	_func_exit_;
+	return 0;
+	
+error_exit:
+	printk("%s, failed \n",__FUNCTION__);
+	return (-1);
+
+}
+
+int rtw_hw_resume(_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct usb_interface *pusb_intf = padapter->dvobjpriv.pusbintf;
+	struct net_device *pnetdev=usb_get_intfdata(pusb_intf);
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+
+	_func_enter_;
+
+	if(padapter)//system resume
+	{	
+		printk("==> rtw_hw_resume\n");
+		_enter_pwrlock(&pwrpriv->lock);
+		pwrpriv->bips_processing = _TRUE;
+		reset_drv_sw(padapter);
+	
+		if(pm_netdev_open(pnetdev,_FALSE) != 0)
+		{
+			_exit_pwrlock(&pwrpriv->lock);
+			goto error_exit;
+		}
+
+		netif_device_attach(pnetdev);	
+		netif_carrier_on(pnetdev);
+
+		if(!netif_queue_stopped(pnetdev))
+      			netif_start_queue(pnetdev);
+		else
+			netif_wake_queue(pnetdev);
+		
+		pwrpriv->bkeepfwalive = _FALSE;
+		pwrpriv->brfoffbyhw = _FALSE;
+		
+		pwrpriv->current_rfpwrstate = rf_on;
+		pwrpriv->bips_processing = _FALSE;	
+	
+		_exit_pwrlock(&pwrpriv->lock);
+	}
+	else
+	{
+		goto error_exit;	
+	}
+
+	_func_exit_;
+	
+	return 0;
+error_exit:
+	printk("%s, Open net dev failed \n",__FUNCTION__);
+	return (-1);
+}
+#endif
+
+int rtw_suspend(struct usb_interface *pusb_intf, pm_message_t message)
+{
+	struct net_device *pnetdev=usb_get_intfdata(pusb_intf);
+	_adapter *padapter = (_adapter*)netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct usb_device *usb_dev = interface_to_usbdev(pusb_intf);
+	
+	_func_enter_;
+
+	if((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
+	{
+		printk("padapter->bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n",
+			padapter->bup, padapter->bDriverStopped,padapter->bSurpriseRemoved);		
+		return 0;
+	}
+	
+
+	printk("###########  rtw_suspend  #################\n");
+
+	if(padapter)//system suspend
+	{		
+		LeaveAllPowerSaveMode(padapter);
+		
+		printk("==> rtw_suspend\n");	
+		_enter_pwrlock(&pwrpriv->lock);
+		padapter->net_closed = _TRUE;
+		//s1.
+		if(pnetdev)
+		{
+			netif_carrier_off(pnetdev);
+			netif_stop_queue(pnetdev);
+		}
+#ifdef CONFIG_WOWLAN
+		padapter->pwrctrlpriv.bSupportWakeOnWlan=_TRUE;
+#else		
+		//s2.
+		//s2-1.  issue rtw_disassoc_cmd to fw
+		rtw_disassoc_cmd(padapter);
+#endif	
+		//s2-2.  indicate disconnect to os
+		rtw_indicate_disconnect(padapter);
+		//s2-3.
+		rtw_free_assoc_resources(padapter);
+#ifdef CONFIG_AUTOSUSPEND
+		if(!pwrpriv->bInternalAutoSuspend )
+#endif
+		//s2-4.
+		rtw_free_network_queue(padapter,_TRUE);	
+	
+		rtw_dev_unload(padapter);
+#ifdef CONFIG_AUTOSUSPEND
+		pwrpriv->current_rfpwrstate = rf_off;
+		pwrpriv->bips_processing = _FALSE;
+		
+#endif		
+		_exit_pwrlock(&pwrpriv->lock);
+	}
+	else
+		goto error_exit;
+	
+	_func_exit_;
+	return 0;
+	
+error_exit:
+	printk("%s, failed \n",__FUNCTION__);
+	return (-1);
+
+}
+
+int rtw_resume(struct usb_interface *pusb_intf)
+{
+	struct net_device *pnetdev=usb_get_intfdata(pusb_intf);
+	_adapter *padapter = (_adapter*)netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct usb_device *usb_dev = interface_to_usbdev(pusb_intf);
+	
+	_func_enter_;
+
+	printk("###########  rtw_resume  #################\n");
+	printk("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
+
+	if(padapter)//system resume
+	{	
+		printk("==> rtw_resume\n");
+		_enter_pwrlock(&pwrpriv->lock);
+		reset_drv_sw(padapter);
+	
+		if(pm_netdev_open(pnetdev,_TRUE) != 0)
+			goto error_exit;
+
+		netif_device_attach(pnetdev);	
+		netif_carrier_on(pnetdev);
+#ifdef CONFIG_AUTOSUSPEND
+		if(pwrpriv->bInternalAutoSuspend )
+		{
+			HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+			pwrpriv->current_rfpwrstate = rf_on;	
+			pwrpriv->bkeepfwalive = _FALSE;
+			pwrpriv->bInternalAutoSuspend = _FALSE;
+			pwrpriv->brfoffbyhw = _FALSE;
+	#if ( RTL8192C_WEP_ISSUE==1)	
+			if(!IS_92C_SERIAL(pHalData->VersionID))
+	#endif
+			{
+				printk("enc_algorithm(%x),wepkeymask(%x)\n",padapter->securitypriv.dot11PrivacyAlgrthm,pwrpriv->wepkeymask);
+				if((_WEP40_ == padapter->securitypriv.dot11PrivacyAlgrthm) ||(_WEP104_ == padapter->securitypriv.dot11PrivacyAlgrthm))
+				{
+					sint keyid;	
+			
+					for(keyid=0;keyid<4;keyid++){				
+						if(pwrpriv->wepkeymask & BIT(keyid))
+							rtw_set_key(padapter,&padapter->securitypriv, keyid);	
+					}
+				}
+			}
+		}
+#endif
+		_exit_pwrlock(&pwrpriv->lock);
+	}
+	else
+	{
+		goto error_exit;	
+	}
+
+	_func_exit_;
+	
+	return 0;
+error_exit:
+	printk("%s, Open net dev failed \n",__FUNCTION__);
+	return (-1);
+}
+
+
+static u8 key_char2num(u8 ch)
+{
+    if((ch>='0')&&(ch<='9'))
+        return ch - '0';
+    else if ((ch>='a')&&(ch<='f'))
+        return ch - 'a' + 10;
+    else if ((ch>='A')&&(ch<='F'))
+        return ch - 'A' + 10;
+    else
+	 return 0xff;
+}
+
+static u8 key_2char2num(u8 hch, u8 lch)
+{
+    return ((key_char2num(hch) << 4) | key_char2num(lch));
+}
+
+/*
+ * drv_init() - a device potentially for us
+ *
+ * notes: drv_init() is called when the bus driver has located a card for us to support.
+ *        We accept the new device by returning 0.
+*/
+static int rtw_drv_init(struct usb_interface *pusb_intf, const struct usb_device_id *pdid)
+{
+	int i;
+	u8 mac[ETH_ALEN];
+	uint status;
+	_adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	struct net_device *pnetdev;
+	//struct device *dev = &pusb_intf->dev;
+	
+	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("+rtw_drv_init\n"));
+	//printk("+rtw_drv_init\n");
+
+	//2009.8.13, by Thomas
+	// In this probe function, O.S. will provide the usb interface pointer to driver.
+	// We have to increase the reference count of the usb device structure by using the usb_get_dev function.
+	usb_get_dev(interface_to_usbdev(pusb_intf));
+
+	pintf = pusb_intf;	
+
+
+#ifdef CONFIG_80211N_HT
+	//step 0.
+	disable_ht_for_spec_devid(pdid);
+#endif
+
+	//step 1. set USB interface data
+	// init data
+	pnetdev = rtw_init_netdev();
+	if (!pnetdev) goto error;
+	SET_NETDEV_DEV(pnetdev, &pusb_intf->dev);
+
+	padapter = netdev_priv(pnetdev);
+	pdvobjpriv = &padapter->dvobjpriv;
+	pdvobjpriv->padapter = padapter;
+	pdvobjpriv->pusbintf = pusb_intf ;
+	pdvobjpriv->pusbdev = interface_to_usbdev(pusb_intf);
+
+	// set data
+	usb_set_intfdata(pusb_intf, pnetdev);
+
+	//step 1-1., decide the chip_type via vid/pid
+	decide_chip_type_by_usb_device_id(padapter, pdid);	
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
+	if(padapter->pwrctrlpriv.bSupportRemoteWakeup)
+	{
+		pdvobjpriv->pusbdev->do_remote_wakeup=1;
+		pusb_intf->needs_remote_wakeup = 1;		
+		device_init_wakeup(&pusb_intf->dev, 1);
+		printk("\n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~~~~\n");
+		printk("\n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",device_may_wakeup(&pusb_intf->dev));
+	}
+#endif
+
+#ifdef CONFIG_AUTOSUSPEND
+	if( padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE )
+	{
+		if(padapter->registrypriv.usbss_enable ){ 	/* autosuspend (2s delay) */
+			pdvobjpriv->pusbdev->autosuspend_delay = 0 * HZ;//15 * HZ; idle-delay time		 	
+
+			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+			usb_enable_autosuspend(padapter->dvobjpriv.pusbdev);
+			#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
+			padapter->bDisableAutosuspend = padapter->dvobjpriv.pusbdev->autosuspend_disabled ;
+			padapter->dvobjpriv.pusbdev->autosuspend_disabled = 0;//autosuspend disabled by the user
+			#endif
+
+			usb_autopm_get_interface(padapter->dvobjpriv.pusbintf );//init pm_usage_cnt ,let it start from 1
+
+			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
+			printk("%s...pm_usage_cnt(%d).....\n",__FUNCTION__,atomic_read(&(pdvobjpriv->pusbintf ->pm_usage_cnt)));
+			#else
+			printk("%s...pm_usage_cnt(%d).....\n",__FUNCTION__,pdvobjpriv->pusbintf ->pm_usage_cnt);
+			#endif							
+		}
+	}	
+#endif
+
+	//step 2.	
+	if(padapter->chip_type == RTL8188C_8192C)
+	{
+#ifdef CONFIG_RTL8192C
+		rtl8192cu_set_hal_ops(padapter);
+#endif
+
+	}
+	else if(padapter->chip_type == RTL8192D)
+	{
+
+#ifdef CONFIG_RTL8192D
+		rtl8192cu_set_hal_ops(padapter);
+#endif
+		
+	}
+	else
+	{
+		status = _FAIL;
+		goto error;
+	}
+		
+
+	//step 3.
+	//initialize the dvobj_priv
+	status = usb_dvobj_init(padapter);	
+	if (status != _SUCCESS) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("initialize device object priv Failed!\n"));
+		goto error;
+	}
+
+
+	//step 4.
+	status = rtw_init_drv_sw(padapter);
+	if(status ==_FAIL){
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));
+		goto error;
+	}
+
+
+	//step 5. read efuse/eeprom data and get mac_addr
+	intf_read_chip_info(padapter);	
+
+	// alloc dev name after read efuse.
+	rtw_init_netdev_name(pnetdev);
+
+	if ( rtw_initmac )
+	{	//	Users specify the mac address
+		int jj,kk;
+
+		for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+		{
+			mac[jj] = key_2char2num(rtw_initmac[kk], rtw_initmac[kk+ 1]);
+		}
+	}
+	else
+	{	//	Use the mac address stored in the Efuse
+		_rtw_memcpy(mac, padapter->eeprompriv.mac_addr, ETH_ALEN);
+	}
+
+	if (((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff) &&
+	     (mac[3]==0xff) && (mac[4]==0xff) &&(mac[5]==0xff)) ||
+	    ((mac[0]==0x0) && (mac[1]==0x0) && (mac[2]==0x0) &&
+	     (mac[3]==0x0) && (mac[4]==0x0) &&(mac[5]==0x0)))
+	{
+		mac[0] = 0x00;
+		mac[1] = 0xe0;
+		mac[2] = 0x4c;
+		mac[3] = 0x87;
+		mac[4] = 0x00;
+		mac[5] = 0x00;
+	}
+	_rtw_memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+	printk("MAC Address from efuse= %02x:%02x:%02x:%02x:%02x:%02x\n",
+				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+
+
+	//step 6.
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
+		goto error;
+	}
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-drv_init - Adapter->bDriverStopped=%d, Adapter->bSurpriseRemoved=%d\n",padapter->bDriverStopped, padapter->bSurpriseRemoved));
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-871x_drv - drv_init, success!\n"));
+	//printk("-871x_drv - drv_init, success!\n");
+
+#ifdef CONFIG_PROC_DEBUG
+#ifdef RTK_DMP_PLATFORM
+	rtw_proc_init_one(pnetdev);
+#endif
+#endif
+
+#ifdef CONFIG_HOSTAPD_MLME
+	hostapd_mode_init(padapter);
+#endif
+
+#ifdef CONFIG_PLATFORM_RTD2880B
+	printk("wlan link up\n");
+	//rtd2885_wlan_netlink_sendMsg("linkup", "8712");
+#endif
+
+	return 0;
+
+error:
+
+	usb_put_dev(interface_to_usbdev(pusb_intf));//decrease the reference count of the usb device structure if driver fail on initialzation
+
+	usb_set_intfdata(pusb_intf, NULL);
+
+	usb_dvobj_deinit(padapter);
+	
+	if (pnetdev)
+	{
+		//unregister_netdev(pnetdev);
+		free_netdev(pnetdev);
+	}
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-871x_usb - drv_init, fail!\n"));
+	//printk("-871x_usb - drv_init, fail!\n");
+
+	return -ENODEV;
+}
+#ifdef CONFIG_IPS
+
+int rtw_ips_pwr_up(_adapter *padapter)
+{	
+	int result;
+	printk("===>  rtw_ips_pwr_up..............\n");
+	reset_drv_sw(padapter);
+	result = ips_netdrv_open(padapter);
+ 	printk("<===  rtw_ips_pwr_up..............\n");
+	return result;
+
+}
+
+void rtw_ips_pwr_down(_adapter *padapter)
+{
+	printk("===> rtw_ips_pwr_down...................\n");
+
+	padapter->bCardDisableWOHSM = _TRUE;
+	padapter->net_closed = _TRUE;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);
+	
+	ips_dev_unload(padapter);
+	padapter->bCardDisableWOHSM = _FALSE;
+	printk("<=== rtw_ips_pwr_down.....................\n");
+}
+#endif
+/*
+ * dev_remove() - our device is being removed
+*/
+//rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove() => how to recognize both
+static void rtw_dev_remove(struct usb_interface *pusb_intf)
+{
+	struct net_device *pnetdev=usb_get_intfdata(pusb_intf);
+	_adapter *padapter = (_adapter*)netdev_priv(pnetdev);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+_func_exit_;
+
+	usb_set_intfdata(pusb_intf, NULL);
+
+	if(padapter)
+	{
+		printk("+rtw_dev_remove\n");
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+dev_remove()\n"));
+
+#ifdef CONFIG_HOSTAPD_MLME
+		hostapd_mode_unload(padapter);
+#endif
+		
+		if(drvpriv.drv_registered == _TRUE)
+		{
+			//printk("r871xu_dev_remove():padapter->bSurpriseRemoved == _TRUE\n");
+			padapter->bSurpriseRemoved = _TRUE;
+		}
+		/*else
+		{
+			//printk("r871xu_dev_remove():module removed\n");
+			padapter->hw_init_completed = _FALSE;
+		}*/
+		LeaveAllPowerSaveMode(padapter);
+
+		#ifdef CONFIG_AUTOSUSPEND
+		if(padapter->registrypriv.usbss_enable)
+		{
+			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+			usb_disable_autosuspend(padapter->dvobjpriv.pusbdev);
+			#else
+			padapter->dvobjpriv.pusbdev->autosuspend_disabled =  padapter->bDisableAutosuspend;// 1;//autosuspend disabled by the user
+			#endif
+		}
+		#endif
+
+		if(padapter->DriverState != DRIVER_DISAPPEAR)
+		{
+			if(pnetdev) {
+				unregister_netdev(pnetdev); //will call netdev_close()
+#ifdef CONFIG_PROC_DEBUG
+				rtw_proc_remove_one(pnetdev);
+#endif
+			}
+		}
+
+		cancel_all_timer(padapter);
+
+		rtw_dev_unload(padapter);
+
+		printk("+r871xu_dev_remove, hw_init_completed=%d\n", padapter->hw_init_completed);
+
+		rtw_free_drv_sw(padapter);
+
+		//after rtw_free_drv_sw(), padapter has beed freed, don't refer to it.
+		
+	}
+
+	usb_put_dev(interface_to_usbdev(pusb_intf));//decrease the reference count of the usb device structure when disconnect
+
+	//If we didn't unplug usb dongle and remove/insert modlue, driver fails on sitesurvey for the first time when device is up . 
+	//Reset usb port for sitesurvey fail issue. 2009.8.13, by Thomas
+	if(interface_to_usbdev(pusb_intf)->state != USB_STATE_NOTATTACHED)
+	{
+		printk("usb attached..., try to reset usb device\n");
+		usb_reset_device(interface_to_usbdev(pusb_intf));
+	}	
+	
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-dev_remove()\n"));
+	printk("-r871xu_dev_remove, done\n");
+
+#ifdef CONFIG_PLATFORM_RTD2880B
+	printk("wlan link down\n");
+	//rtd2885_wlan_netlink_sendMsg("linkdown", "8712");
+#endif
+
+
+_func_exit_;
+
+	return;
+
+}
+
+
+static int __init rtw_drv_entry(void)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_entry\n"));
+	printk("rtw driver version=%s\n", DRIVERVERSION);		
+	drvpriv.drv_registered = _TRUE;
+	return usb_register(&drvpriv.rtw_usb_drv);
+}
+
+static void __exit rtw_drv_halt(void)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_halt\n"));
+	printk("+rtw_drv_halt\n");
+	drvpriv.drv_registered = _FALSE;
+	usb_deregister(&drvpriv.rtw_usb_drv);
+	printk("-rtw_drv_halt\n");
+}
+
+
+module_init(rtw_drv_entry);
+module_exit(rtw_drv_halt);
+
+
+/*
+init (driver module)-> r8712u_drv_entry
+probe (sd device)-> r871xu_drv_init(dev_init)
+open (net_device) ->netdev_open
+close (net_device) ->netdev_close
+remove (sd device) ->r871xu_dev_remove
+exit (driver module)-> r8712u_drv_halt
+*/
+
+
+/*
+r8711s_drv_entry()
+r8711u_drv_entry()
+r8712s_drv_entry()
+r8712u_drv_entry()
+*/
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/xmit_linux.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/xmit_linux.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/linux/xmit_linux.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/linux/xmit_linux.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,228 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _XMIT_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <if_ether.h>
+#include <ip.h>
+#include <rtw_byteorder.h>
+#include <wifi.h>
+#include <mlme_osdep.h>
+#include <xmit_osdep.h>
+#include <osdep_intf.h>
+#include <circ_buf.h>
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/udp.h>
+#endif
+
+uint rtw_remainder_len(struct pkt_file *pfile)
+{
+	return (pfile->buf_len - ((SIZE_PTR)(pfile->cur_addr) - (SIZE_PTR)(pfile->buf_start)));
+}
+
+void _rtw_open_pktfile (_pkt *pktptr, struct pkt_file *pfile)
+{
+_func_enter_;
+
+	pfile->pkt = pktptr;
+	pfile->cur_addr = pfile->buf_start = pktptr->data;
+	pfile->pkt_len = pfile->buf_len = pktptr->len;
+
+	pfile->cur_buffer = pfile->buf_start ;
+	
+_func_exit_;
+}
+
+uint _rtw_pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen)
+{	
+	uint	len = 0;
+	
+_func_enter_;
+
+       len =  rtw_remainder_len(pfile);
+      	len = (rlen > len)? len: rlen;
+
+       if(rmem)
+	  skb_copy_bits(pfile->pkt, pfile->buf_len-pfile->pkt_len, rmem, len);
+
+       pfile->cur_addr += len;
+       pfile->pkt_len -= len;
+	   
+_func_exit_;	       		
+
+	return len;	
+}
+
+sint rtw_endofpktfile(struct pkt_file *pfile)
+{
+_func_enter_;
+
+	if (pfile->pkt_len == 0) {
+_func_exit_;
+		return _TRUE;
+	}
+
+_func_exit_;
+
+	return _FALSE;
+}
+
+void set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib)
+{
+
+#ifdef CONFIG_RTL8712_TCP_CSUM_OFFLOAD_TX
+	struct sk_buff *skb = (struct sk_buff *)pkt;
+	pattrib->hw_tcp_csum = 0;
+	
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		if (skb_shinfo(skb)->nr_frags == 0)
+		{	
+                        const struct iphdr *ip = ip_hdr(skb);
+                        if (ip->protocol == IPPROTO_TCP) {
+                                // TCP checksum offload by HW
+                                printk("CHECKSUM_PARTIAL TCP\n");
+                                pattrib->hw_tcp_csum = 1;
+                                //skb_checksum_help(skb);
+                        } else if (ip->protocol == IPPROTO_UDP) {
+                                //printk("CHECKSUM_PARTIAL UDP\n");
+#if 1                       
+                                skb_checksum_help(skb);
+#else
+                                // Set UDP checksum = 0 to skip checksum check
+                                struct udphdr *udp = skb_transport_header(skb);
+                                udp->check = 0;
+#endif
+                        } else {
+				printk("%s-%d TCP CSUM offload Error!!\n", __FUNCTION__, __LINE__);
+                                WARN_ON(1);     /* we need a WARN() */
+			    }
+		}
+		else { // IP fragmentation case
+			printk("%s-%d nr_frags != 0, using skb_checksum_help(skb);!!\n", __FUNCTION__, __LINE__);
+                	skb_checksum_help(skb);
+		}		
+	}
+#endif	
+	
+}
+
+int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf)
+{
+
+#ifdef CONFIG_USB_HCI
+	int i;
+	
+       for(i=0; i<8; i++)
+      	{
+      		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+             	if(pxmitbuf->pxmit_urb[i] == NULL) 
+             	{
+             		printk("pxmitbuf->pxmit_urb[i]==NULL");
+	        	return _FAIL;	 
+             	}      		  	
+	
+      	}
+#endif
+
+	return _SUCCESS;	
+}
+
+void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf)
+{
+
+#ifdef CONFIG_USB_HCI
+	int i;
+	
+	for(i=0; i<8; i++)
+	{
+		if(pxmitbuf->pxmit_urb[i])
+		{
+			//usb_kill_urb(pxmitbuf->pxmit_urb[i]);
+			usb_free_urb(pxmitbuf->pxmit_urb[i]);
+		}	
+	}
+#endif
+
+}
+
+void os_pkt_complete(_adapter *padapter, _pkt *pkt)
+{
+	if (netif_queue_stopped(padapter->pnetdev))
+		netif_wake_queue(padapter->pnetdev);
+
+	dev_kfree_skb_any(pkt);
+}
+
+void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe)
+{
+	if(pxframe->pkt)
+	{
+		//RT_TRACE(_module_xmit_osdep_c_,_drv_err_,("linux : rtw_os_xmit_complete, dev_kfree_skb()\n"));	
+
+		//dev_kfree_skb_any(pxframe->pkt);	
+		os_pkt_complete(padapter, pxframe->pkt);
+		
+	}	
+
+	pxframe->pkt = NULL;
+}
+
+int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
+{
+	_adapter *padapter = (_adapter *)netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	s32 res = 0;
+	int ret = 0;
+
+_func_enter_;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
+
+	if (rtw_if_up(padapter) == _FALSE) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit_entry: rtw_if_up fail\n"));
+		goto drop_packet;
+	}
+
+	res = rtw_xmit(padapter, pkt);
+	if (res < 0) goto drop_packet;
+
+	pxmitpriv->tx_pkts++;
+	RT_TRACE(_module_xmit_osdep_c_, _drv_info_, ("rtw_xmit_entry: tx_pkts=%d\n", (u32)pxmitpriv->tx_pkts));
+	goto exit;
+
+drop_packet:
+	pxmitpriv->tx_drop++;
+	dev_kfree_skb_any(pkt);
+	RT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("rtw_xmit_entry: drop, tx_drop=%d\n", (u32)pxmitpriv->tx_drop));
+
+exit:
+
+_func_exit_;
+
+	return 0;
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/osdep_service.c linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/osdep_service.c
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/os_dep/osdep_service.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/os_dep/osdep_service.c	2011-03-09 11:43:10.000000000 +0800
@@ -0,0 +1,571 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#define _OSDEP_SERVICE_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+
+
+#define RT_TAG	'1178'
+
+u8* _rtw_zmalloc(u32 sz)
+{
+	u8 	*pbuf;
+#ifdef PLATFORM_LINUX
+	// kzalloc(sz, GFP_KERNEL);
+	pbuf = 	kmalloc(sz, /*GFP_KERNEL*/GFP_ATOMIC);
+	if (pbuf != NULL)
+		memset(pbuf, 0, sz);
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
+	if (pbuf != NULL)
+		NdisFillMemory(pbuf, sz, 0);
+#endif
+
+	return pbuf;	
+	
+}
+
+u8* _rtw_malloc(u32 sz)
+{
+	u8 	*pbuf;
+#ifdef PLATFORM_LINUX	
+	pbuf = 	kmalloc(sz, /*GFP_KERNEL*/GFP_ATOMIC);	
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);	
+#endif
+
+	return pbuf;	
+	
+}
+
+void	_rtw_mfree(u8 *pbuf, u32 sz)
+{
+
+#ifdef	PLATFORM_LINUX
+
+	kfree(pbuf);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisFreeMemory(pbuf,sz, 0);
+
+#endif
+	
+	
+}
+void _rtw_memcpy(void* dst, void* src, u32 sz)
+{
+
+#ifdef PLATFORM_LINUX
+
+	memcpy(dst, src, sz);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMoveMemory(dst, src, sz);
+
+#endif
+
+}
+
+int	_rtw_memcmp(void *dst, void *src, u32 sz)
+{
+
+#ifdef PLATFORM_LINUX
+//under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0
+
+	if (!(memcmp(dst, src, sz)))
+		return _TRUE;
+	else
+		return _FALSE;
+#endif
+
+
+#ifdef PLATFORM_WINDOWS
+//under Windows, the return value of NdisEqualMemory for two same mem. chunk is 1
+	
+	if (NdisEqualMemory (dst, src, sz))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif	
+	
+	
+	
+}
+
+void _rtw_memset(void *pbuf, int c, u32 sz)
+{
+
+#ifdef PLATFORM_LINUX
+
+        memset(pbuf, c, sz);
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+#if 0
+	NdisZeroMemory(pbuf, sz);
+	if (c != 0) memset(pbuf, c, sz);
+#else
+	NdisFillMemory(pbuf, sz, c);
+#endif
+#endif
+
+}
+
+void _rtw_init_listhead(_list *list)
+{
+
+#ifdef PLATFORM_LINUX
+
+        INIT_LIST_HEAD(list);
+
+#endif
+
+#ifdef PLATFORM_WINDOWS
+
+        NdisInitializeListHead(list);
+
+#endif
+
+}
+
+
+/*
+For the following list_xxx operations, 
+caller must guarantee the atomic context.
+Otherwise, there will be racing condition.
+*/
+u32	rtw_is_list_empty(_list *phead)
+{
+
+#ifdef PLATFORM_LINUX
+
+	if (list_empty(phead))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif
+	
+
+#ifdef PLATFORM_WINDOWS
+
+	if (IsListEmpty(phead))
+		return _TRUE;
+	else
+		return _FALSE;
+
+#endif
+
+	
+}
+
+
+void rtw_list_insert_tail(_list *plist, _list *phead)
+{
+
+#ifdef PLATFORM_LINUX	
+	
+	list_add_tail(plist, phead);
+	
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+  InsertTailList(phead, plist);
+
+#endif		
+	
+}
+
+
+/*
+
+Caller must check if the list is empty before calling list_delete
+
+*/
+
+
+void _rtw_init_sema(_sema	*sema, int init_val)
+{
+
+#ifdef PLATFORM_LINUX
+
+	sema_init(sema, init_val);
+
+#endif
+
+#ifdef PLATFORM_OS_XP
+
+	KeInitializeSemaphore(sema, init_val,  SEMA_UPBND); // count=0;
+
+#endif
+	
+#ifdef PLATFORM_OS_CE
+	if(*sema == NULL)
+		*sema = CreateSemaphore(NULL, init_val, SEMA_UPBND, NULL);
+#endif
+
+}
+
+void _rtw_free_sema(_sema	*sema)
+{
+
+#ifdef PLATFORM_OS_CE
+	CloseHandle(*sema);
+#endif
+
+}
+
+void _rtw_up_sema(_sema	*sema)
+{
+
+#ifdef PLATFORM_LINUX
+
+	up(sema);
+
+#endif	
+
+#ifdef PLATFORM_OS_XP
+
+	KeReleaseSemaphore(sema, IO_NETWORK_INCREMENT, 1,  FALSE );
+
+#endif
+
+#ifdef PLATFORM_OS_CE
+	ReleaseSemaphore(*sema,  1,  NULL );
+#endif
+}
+
+u32 _rtw_down_sema(_sema *sema)
+{
+
+#ifdef PLATFORM_LINUX
+	
+	if (down_interruptible(sema))
+		return _FAIL;
+    else
+    	return _SUCCESS;
+
+#endif    	
+
+#ifdef PLATFORM_OS_XP
+
+	if(STATUS_SUCCESS == KeWaitForSingleObject(sema, Executive, KernelMode, TRUE, NULL))
+		return  _SUCCESS;
+	else
+		return _FAIL;
+#endif
+
+#ifdef PLATFORM_OS_CE
+	if(WAIT_OBJECT_0 == WaitForSingleObject(*sema, INFINITE ))
+		return _SUCCESS; 
+	else
+		return _FAIL;
+#endif
+}
+
+
+
+void	_rtw_mutex_init(_mutex *pmutex)
+{
+#ifdef PLATFORM_LINUX
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	mutex_init(pmutex);
+#else
+	init_MUTEX(pmutex);
+#endif
+	
+#endif
+
+#ifdef PLATFORM_OS_XP
+
+	KeInitializeMutex(pmutex, 0);
+
+#endif
+
+#ifdef PLATFORM_OS_CE
+	*pmutex =  CreateMutex( NULL, _FALSE, NULL);
+#endif
+}
+
+
+void	_rtw_spinlock_init(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock_init(plock);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisAllocateSpinLock(plock);
+
+#endif
+	
+}
+
+void	_rtw_spinlock_free(_lock *plock)
+{
+
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisFreeSpinLock(plock);
+
+#endif
+	
+}
+
+
+void	_rtw_spinlock(_lock	*plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisAcquireSpinLock(plock);
+
+#endif
+	
+}
+
+void	_rtw_spinunlock(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_unlock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisReleaseSpinLock(plock);
+
+#endif
+}
+
+
+void	_rtw_spinlock_ex(_lock	*plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_lock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisDprAcquireSpinLock(plock);
+
+#endif
+	
+}
+
+void	_rtw_spinunlock_ex(_lock *plock)
+{
+
+#ifdef PLATFORM_LINUX
+
+	spin_unlock(plock);
+
+#endif
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisDprReleaseSpinLock(plock);
+
+#endif
+}
+
+
+
+void	_rtw_init_queue(_queue	*pqueue)
+{
+
+	_rtw_init_listhead(&(pqueue->queue));
+
+	_rtw_spinlock_init(&(pqueue->lock));
+
+}
+
+u32	  _rtw_queue_empty(_queue	*pqueue)
+{
+	return (rtw_is_list_empty(&(pqueue->queue)));
+}
+
+
+u32 rtw_end_of_queue_search(_list *head, _list *plist)
+{
+
+	if (head == plist)
+		return _TRUE;
+	else
+		return _FALSE;
+		
+}
+
+
+u32	rtw_get_current_time(void)
+{
+	
+#ifdef PLATFORM_LINUX
+
+	return jiffies;
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	LARGE_INTEGER	SystemTime;
+	NdisGetCurrentSystemTime(&SystemTime);
+	return (u32)(SystemTime.LowPart);// count of 100-nanosecond intervals 
+
+#endif
+	
+	
+}
+
+void rtw_sleep_schedulable(int ms)	
+{
+
+#ifdef PLATFORM_LINUX
+
+    u32 delta;
+    
+    delta = (ms * HZ)/1000;//(ms)
+    if (delta == 0) {
+        delta = 1;// 1 ms
+    }
+    set_current_state(TASK_INTERRUPTIBLE);
+    if (schedule_timeout(delta) != 0) {
+        return ;
+    }
+    return;
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+}
+
+
+void rtw_msleep_os(int ms)
+{
+
+#ifdef PLATFORM_LINUX
+
+  	msleep((unsigned int)ms);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+
+}
+void rtw_usleep_os(int us)
+{
+
+#ifdef PLATFORM_LINUX
+  	
+      // msleep((unsigned int)us);
+      if ( 1 < (us/1000) )
+                msleep(1);
+      else
+		msleep( (us/1000) + 1);
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisMSleep(us); //(us)
+
+#endif
+
+
+}
+
+void rtw_mdelay_os(int ms)
+{
+
+#ifdef PLATFORM_LINUX
+
+   	mdelay((unsigned long)ms); 
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisStallExecution(ms*1000); //(us)*1000=(ms)
+
+#endif
+
+
+}
+void rtw_udelay_os(int us)
+{
+
+#ifdef PLATFORM_LINUX
+
+      udelay((unsigned long)us); 
+
+#endif	
+	
+#ifdef PLATFORM_WINDOWS
+
+	NdisStallExecution(us); //(us)
+
+#endif
+
+}
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/runwpa linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/runwpa
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/runwpa	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/runwpa	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+if [ "`which iwconfig`" = "" ] ; then 
+	echo "WARNING:Wireless tool not exist!"
+	echo "        Please install it!"
+	exit
+else
+	if [ `uname -r | cut -d. -f2` -eq 4 ]; then
+		wpa_supplicant -D ipw -c wpa1.conf -i wlan0	
+	else
+	if [ `iwconfig -v |awk '{print $4}' | head -n 1` -lt  18 ] ; then
+		wpa_supplicant -D ipw -c wpa1.conf -i wlan0  
+	else	  
+		wpa_supplicant -D wext -c wpa1.conf -i wlan0 
+	fi
+
+	fi
+fi
+
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/wlan0dhcp linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/wlan0dhcp
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/wlan0dhcp	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/wlan0dhcp	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,16 @@
+#!/bin/bash
+
+var0=`ps aux|awk '/dhclient wlan0/'|awk '$11!="awk"{print $2}'`
+
+kill $var0
+cp ifcfg-wlan0 /etc/sysconfig/network-scripts/
+
+dhclient wlan0
+
+var1=`ifconfig wlan0 |awk '/inet/{print $2}'|awk -F: '{print $2}'`
+
+
+rm -f /etc/sysconfig/network-scripts/ifcfg-wlan0
+
+echo "get ip: $var1"
+
diff -Nruap linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/wpa1.conf linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/wpa1.conf
--- linux-2.6.34.orig/drivers/net/wireless/rtl8192cu/wpa1.conf	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.34.patched/drivers/net/wireless/rtl8192cu/wpa1.conf	2011-03-09 11:43:08.000000000 +0800
@@ -0,0 +1,11 @@
+ctrl_interface=/var/run/wpa_supplicant
+network={
+                        ssid="REALTEK"
+                        proto=WPA WPA2 
+                        key_mgmt=WPA-PSK
+                        pairwise=CCMP TKIP
+                        group=CCMP TKIP
+                        psk="12345678"
+                        priority=2
+         }
+
